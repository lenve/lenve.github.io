{"pages":[{"title":"我是谁","text":"大家好，我是江南一点雨，管理学学士，大学自学 Java 编程，从移动端到前端到后端均有涉猎，现在专注于 Java 微服务，我是 CSDN 博客专家、华为云云享专家、《Spring Boot + Vue全栈开发实战》 作者、运营了一个公众号 牧码小子，专注于 Spring Boot + 微服务技术分享，欢迎大家关注！关注公众号回复 Java，领取松哥为大家精心准备的 Java 干货！ 我的公众号 我的站点 独立站点： https://www.javaboy.org GitHub： https://github.com/lenve CSDN： http://wangsong.blog.csdn.net 思否： https://segmentfault.com 博客园： https://www.cnblogs.com/lenve 掘金： https://juejin.im/user/57d679af0bd1d000585012a7","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"JavaWeb 乱码问题终极解决方案！","text":"经常有读者在公众号上问 JavaWeb 乱码的问题，昨天又有一个小伙伴问及此事，其实这个问题很简单，但是想要说清楚却并不容易，因为每个人乱码的原因都不一样，给每位小伙伴都把乱码的原因讲一遍也挺费时间的，因此，松哥今天决定写一篇文章，和大伙好好捋捋 JavaWeb 中的乱码问题。 对于一些老司机而言，其实并不太容易遇到乱码问题，但是对于一些新手来说，乱码几乎是家常便饭，而且每当乱码时，网上搜了一大堆解决方案，发现自己的问题还是没能解决，其实这就是平时研究代码不求甚解导致的，乱码问题，也要去分析，然后才能对症下药，才能药到病除。 整体思路首先出现乱码之后，要先去确认乱码的地方，当一个网页上出现乱码，有可能是浏览器显示问题，也有可能是 Java 编码问题，也有可能数据库中的数据本身就是乱码的，所以我们要做的第一件事就是确认乱码发生的位置，缩小 bug 范围，通过打印日志或者 debug 首先去确认乱码发生的位置，然后再去进一步解决，一般来说，乱码的原因大致上可以分为两类： 请求乱码 响应乱码 请求乱码，可能是因为参数放在 URL 地址中乱码，也有可能是参数放在请求体中乱码，不同传参方案也对应了不同的乱码解决方案。如果是响应乱码，那么原因就会比较多了，一般来说，有如下几种可能的原因： 数据库本身乱码 数据在 Java 代码中乱码 数据在浏览器显示的时候乱码 数据在从 Java 应用传到数据库的过程中乱码 对于不同的乱码原因，会有不同的解决方案，对症下药，才能药到病除，所以当出现乱码时，大家要做的第一件事就是分析乱码发生的原因，找到原因了，才能找到解决方案。 基本原则发生乱码是因为各自编码不同导致的，所以，大家首先要有一个良好的开发习惯，项目编码，文件编码都要统一起来，松哥有个同事就因为 Freemarker 乱码，找了半天没找到原因，后来在松哥建议下修改了项目编码，乱码问题才解决了，一般来说，公司制度稍微成熟一些，都会对项目编码，文件编码有硬性规定的。在Eclipse 中，设置项目编码方式如下（工程的编码要提前设置，如果项目已经开发一半再去设置，已有的中文就会乱码）： Window-&gt;Preferences-&gt;General 然后对于 JSP 文件也需要提前设置好编码方式，如下： 这是在 Eclipse 中设置文件编码，如果是在 IntelliJ IDEA中，则不需要设置JSP文件编码，因为默认就是 UTF-8，只需要提前设置下工程编码即可： 除了开发工具的编码，数据库的编码也要统一，一般来说，主要是设置一下数据库的编码和数据表的编码，如下： 设置数据库编码： 1CREATE DATABASE `vhr` DEFAULT CHARACTER SET utf8; 设置数据表编码： 123456DROP TABLE IF EXISTS `adjustsalary`;CREATE TABLE `adjustsalary` ( `id` int(11) NOT NULL AUTO_INCREMENT, `eid` int(11) DEFAULT NULL, PRIMARY KEY (`id`),) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这些是准备工作，这些工作做好了，还是有可能会遇到乱码问题，接下来我们就具体问题具体分析。 请求乱码请求乱码，就是说数据在浏览器中显示是正常的，但是传到 Java 后端之后，就乱码了，这种乱码一般来说，分为两种： 参数放在 URL 地址中导致的乱码 参数放在请求体中导致的乱码 两种乱码原因，对应了两种不同的解决方案。分别来看。 URL 地址中的参数乱码这种乱码主要发生在 GET 请求中，因为在 GET 请求中我们一般通过 URL 来传递参数，这个问题可以在代码中解决，但是太过于麻烦，因此一般我们直接在Tomcat配置中解决，修改 Tomcat的conf/server.xml 文件，修改 URL 编码格式，如下： 这样就可以搞定 URL 地址中的参数乱码。 请求体中的参数乱码请求体中的参数乱码，我们可以在解析参数之前通过设置 HttpServletRequest 的编码来解决，如下： 1request.setCharacterEncoding(\"UTF-8\"); 但是一样也太过于麻烦，所以如果是普通的 Servlet/JSP 项目，我们就可以直接定义一个过滤器来处理，如下： 1234567public class EncodingFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(\"UTF-8\"); chain.doFilter(request, response); }} 过滤器配置： 12345678&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.sang.filter.EncodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在工程编码和JSP/HTML编码都没问题的情况下，请求乱码基本上就是这两种情况。 响应乱码如果在浏览器上加载页面看到了乱码，大家首先要确认在从服务端往浏览器写数据的前一刻，这个数据还没有乱码（即数据库中查询出来的数据是OK的，没有发生乱码的问题），那么对于这种乱码，我们只需要设置响应数据的 ContentType 就可以了，如下： 1response.setContentType(\"text/html;charset=UTF-8\"); 如果从数据库中查询出来的数据就是乱码的，那么就需要去确认数据库中的编码是否 OK 。 框架处理前面提到的方案，都是在 Servlet/JSP 项目中我们可以采用的方案，在 SSM 框架中当然也可以使用，但是，SpringMVC 框架本身也提供了一个过滤器，我们可以借用这个过滤器更加高效的解决响应乱码问题，如下： 1234567891011121314151617181920&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 当然，上面这段配置并不能代替 Tomcat 中 conf/server.xml 中的编码配置，如果是在 Spring Boot 中，配置可以更加简单，只需要在 application.properties 中添加如下配置即可： 123server.tomcat.uri-encoding=UTF-8spring.http.encoding.force-request=truespring.http.encoding.force-response=true 其他乱码其他乱码主要是指使用一些第三方框架导致的乱码，例如使用 Alibaba 的 fastjson，开发者就需要在配置 HttpMessageConverter 时指定编码格式，否则就有可能出现乱码，这种第三方框架的乱码松哥没法穷举，大伙在使用时需要注意看官方文档，fastjson 的 HttpMessageConverter 配置如下： 123456789@BeanFastJsonHttpMessageConverter fastJsonHttpMessageConverter() { FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig config = new FastJsonConfig(); config.setCharset(Charset.forName(\"UTF-8\")); converter.setFastJsonConfig(config); converter.setDefaultCharset(Charset.forName(\"UTF-8\")); return converter;} 一个隐蔽的乱码除了前面介绍的这几种乱码之外，还有一个比较隐蔽的乱码，容易被很多初学者忽略的地方，就是数据在从 Java 应用传递到 MySQL 的过程中，发生了乱码，这种问题一般在 Windows 上不易发生，如果数据库装在 Linux 上，则这个问题就很容易发生，数据在代码中命名没有乱码，存到 MySQL 上就乱码了，但是如果直接使用 Navicat 等工具往 MySQL 上存储数据，又不会乱码，或者 MySQL 中数据没有乱码，但是用 Java 查询出来就乱码了，这种都是数据在 应用 和 数据库 之间传递时发生了乱码，解决方式很简单，在数据库连接地址上指定编码即可，如下： 1db.url=jdbc:mysql:///yuetong?useUnicode=true&amp;characterEncoding=UTF-8 大致就这些，还有一些非常偶尔的情况可能会用到 @RequestMapping 注解中的 produces 属性，在这里指定数据类型即可。 好了，差不多就这些，下次有人问你为啥我的又乱码了，直接把这篇文章甩给他。大伙有什么解决乱码的独门密器也可以一起来讨论。","link":"/post/e1369978.html"},{"title":"Linux上安装Redis","text":"hello，各位小伙伴们好久不见！那么从今天开始，我想和各位小伙伴分享下Redis的用法，本文我们就先来看看什么是Redis以及如何安装Redis。 什么是RedisRedis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。从2015年6月开始，Redis的开发由Redis Labs赞助，而2013年5月至2015年6月期间，其开发由Pivotal赞助。在2013年5月之前，其开发由VMware赞助。根据月度排行网站DB-Engines.com的数据显示，Redis是最流行的键值对存储数据库。 Redis具有如下特点： Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，不会造成数据丢失 Redis支持五种不同的数据结构类型之间的映射，包括简单的key/value类型的数据，同时还提供list，set，zset，hash等数据结构的存储 Redis支持master-slave模式的数据备份 Redis具有如下功能： 内存存储和持久化：redis支持异步将内存中的数据写到硬盘上，在持久化的同时不影响继续服务 取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面 数据可以设置过期时间 自带发布、订阅消息系统 定时器、计数器 Redis安装Windows版Redis的安装，整体来说还是非常简单的，网上也有很多教程，考虑到Redis的大部分使用场景都是在Linux上，因此这里我对Windows上的安装不做介绍，小伙伴们有兴趣可以自行搜索，下面我们主要来看下Linux上怎么安装Redis。 环境：CentOS7redis4.0.8 1.首先下载Redis，下载地址https://redis.io/，下载获得redis-4.0.8.tar.gz后将它放入我们的Linux目录/opt 2./opt目录下，对文件进行解压，解压命令:tar -zxvf redis-4.0.8.tar.gz，如下： 3.解压完成后出现文件夹：redis-4.0.8，进入到该目录中:cd redis-4.0.8 4.在redis-4.0.8目录下执行make命令进行编译 5.如果make完成后继续执行make install进行安装 OK，至此，我们的redis就算安装成功了。 6.在我们启动之前，需要先做一个简单的配置：修改redis.conf文件，将里面的daemonize no 改成 yes，让服务在后台启动，如下： 7.启动，通过redis-server redis.conf命令启动redis，如下： 8.测试 首先我们可以通过redis-cli命令进入到控制台，然后通过ping命令进行连通性测试，如果看到pong，表示连接成功了，如下： 9.关闭，通过shutdown命令我们可以关闭实例，如下： OK，至此，我们的Redis就安装成功了，整体来说还是非常简单的，有问题欢迎留言讨论。","link":"/post/6800b8f4.html"},{"title":"MyBatis中主键回填的两种实现方式","text":"主键回填其实是一个非常常见的需求，特别是在数据添加的过程中，我们经常需要添加完数据之后，需要获取刚刚添加的数据 id，无论是 Jdbc 还是各种各样的数据库框架都对此提供了相关的支持，本文我就来和和大家分享下数据库主键回填在 MyBatis 中的两种实现思路。 原生写法框架来源于我们学过的基础知识，主键回填实际上是一个在 JDBC 中就被支持的写法，有的小伙伴可能不知道这一点，因此这里我先来说说在 JDBC 中如何实现主键回填。 JDBC 中实现主键回填其实非常容易，主要是在构造 PreparedStatement 时指定需要主键回填，然后在插入成功后，查询刚刚插入数据的 id ，示例代码如下： 1234567891011121314151617public int insert(Person person) { Connection con = null; PreparedStatement ps = null; ResultSet rs = null; con = DBUtils.getConnection(); ps = con.prepareStatement(\"INSERT INTO person(username,password,money) VALUES(?,?,?)\", PreparedStatement.RETURN_GENERATED_KEYS); ps.setObject(1, person.getUsername()); ps.setObject(2, person.getPassword()); ps.setObject(3, person.getMoney()); int i = ps.executeUpdate(); rs = ps.getGeneratedKeys(); int id = -1; if (rs.next()) { id = rs.getInt(1); } return id;} 和普通的插入 SQL 不同之处主要体现在两个地方： 第一个是构造 PreparedStatement 时，多了一个参数，指定了需要主键回填。 在更新操作执行完成之后，调用 getGeneratedKeys ，然后又会获取到一个 ResultSet 对象，从这个游标集中就可以获取到刚刚插入数据的id。 这个是原生的写法，在 MyBatis 中，对此需求提供了两种不同的实现方案，下面分别来看。 框架写法一般情况下，主键有两种生成方式： 主键自增长 自定义主键（一般可以使用UUID，或者类UUID） 如果是第二种，主键一般是在Java代码中生成，然后传入数据库执行插入操作，如果是第一个主键自增长，此时，Java 可能需要知道数据添加成功后的主键。 MyBatis 的基本用法就无需多说了，这也不是本文的重点，我们还是来看看 MyBatis 中主键回填的两种不同实现方式吧！ 方式一第一种方式比较简单，也是松哥推荐的一种实现方式： 123&lt;insert id=\"insertBook\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into t_book (b_name,author) values (#{name},#{author});&lt;/insert&gt; 这种方式比较简单，就是在插入节点上添加 useGeneratedKeys 属性，同时设置接收回传主键的属性。配置完成后，我们执行一个插入操作，插入时传入一个对象，插入完成后，这个对象的 id 就会被自动赋值，值就是刚刚插入成功的id。 松哥推荐大家使用这种方式，原因很简单，这种方式实现简便省事。 方式二第二种方式则是利用MySQL自带的 last_insert_id() 函数查询刚刚插入的id，示例代码如下： 123456&lt;insert id=\"insertBook\"&gt; &lt;selectKey keyProperty=\"id\" resultType=\"java.lang.Integer\"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; insert into t_book (b_name,author) values (#{name},#{author});&lt;/insert&gt; 这种方式是在 insert 节点中添加 selectKey 来实现主键回填，实际上这种方式的功能更加丰富，因为 selectKey 节点中的 SQL 我们既可以在插入之前执行，也可以在插入之后执行（通过设置节点的 Order 属性为 AFTER 或者 BEFORE 可以实现），具体什么时候执行，还是要看具体的需求，如果是做主键回填，我们当然需要在插入 SQL 执行之后执行 selectKey 节点中的 SQL。 注意第二种方式一样也要通过设置 keyProperty 来指定将查询到的数据绑定到哪个属性上。 总结好了，本文向大家介绍了 MyBatis 中主键回填的两种方式，大家有没有 get 到呢？有问题欢迎留言讨论。","link":"/post/eb3efe16.html"},{"title":"Spring Boot + Vue 前后端分离，两种文件上传方式总结","text":"在Vue.js 中，如果网络请求使用 axios ，并且使用了 ElementUI 库，那么一般来说，文件上传有两种不同的实现方案： 通过 Ajax 实现文件上传 通过 ElementUI 里边的 Upload 组件实现文件上传 两种方案，各有优缺点，我们分别来看。 准备工作首先我们需要一点点准备工作，就是在后端提供一个文件上传接口，这是一个普通的 Spring Boot 项目，如下： 12345678910111213141516SimpleDateFormat sdf = new SimpleDateFormat(\"/yyyy/MM/dd/\");@PostMapping(\"/import\")public RespBean importData(MultipartFile file, HttpServletRequest req) throws IOException { String format = sdf.format(new Date()); String realPath = req.getServletContext().getRealPath(\"/upload\") + format; File folder = new File(realPath); if (!folder.exists()) { folder.mkdirs(); } String oldName = file.getOriginalFilename(); String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\".\")); file.transferTo(new File(folder,newName)); String url = req.getScheme() + \"://\" + req.getServerName() + \":\" + req.getServerPort() + \"/upload\" + format + newName; System.out.println(url); return RespBean.ok(\"上传成功!\");} 这里的文件上传比较简单，上传的文件按照日期进行归类，使用 UUID 给文件重命名。 这里为了简化代码，我省略掉了异常捕获，上传结果直接返回成功，后端代码大伙可根据自己的实际情况自行修改。 Ajax 上传在 Vue 中，通过 Ajax 实现文件上传，方案和传统 Ajax 实现文件上传基本上是一致的，唯一不同的是查找元素的方式。 12&lt;input type=\"file\" ref=\"myfile\"&gt;&lt;el-button @click=\"importData\" type=\"success\" size=\"mini\" icon=\"el-icon-upload2\"&gt;导入数据&lt;/el-button&gt; 在这里，首先提供一个文件导入 input 组件，再来一个导入按钮，在导入按钮的事件中来完成导入的逻辑。 123456789101112importData() { let myfile = this.$refs.myfile; let files = myfile.files; let file = files[0]; var formData = new FormData(); formData.append(\"file\", file); this.uploadFileRequest(\"/system/basic/jl/import\",formData).then(resp=&gt;{ if (resp) { console.log(resp); } })} 关于这段上传核心逻辑，解释如下： 首先利用 Vue 中的 $refs 查找到存放文件的元素。 type 为 file 的 input 元素内部有一个 files 数组，里边存放了所有选择的 file，由于文件上传时，文件可以多选，因此这里拿到的 files 对象是一个数组。 从 files 对象中，获取自己要上传的文件，由于这里是单选，所以其实就是数组中的第一项。 构造一个 FormData ，用来存放上传的数据,FormData 不可以像 Java 中的 StringBuffer 使用链式配置。 构造好 FromData 后，就可以直接上传数据了，FormData 就是要上传的数据。 文件上传注意两点，1. 请求方法为 post，2. 设置 Content-Type 为 multipart/form-data 。 这种文件上传方式，实际上就是传统的 Ajax 上传文件，和大家常见的 jQuery 中写法不同的是，这里元素查找的方式不一样（实际上元素查找也可以按照JavaScript 中原本的写法来实现），其他写法一模一样。这种方式是一个通用的方式，和使用哪一种前端框架无关。最后再和大家来看下封装的上传方法： 12345678910export const uploadFileRequest = (url, params) =&gt; { return axios({ method: 'post', url: `${base}${url}`, data: params, headers: { 'Content-Type': 'multipart/form-data' } });} 经过这几步的配置后，前端就算上传完成了，可以进行文件上传了。 使用 Upload 组件如果使用 Upload ，则需要引入 ElementUI，所以一般建议，如果使用了 ElementUI 做 UI 控件的话，则可以考虑使用 Upload 组件来实现文件上传，如果没有使用 ElementUI 的话，则不建议使用 Upload 组件，至于其他的 UI 控件，各自都有自己的文件上传组件，具体使用可以参考各自文档。 123456789&lt;el-upload style=\"display: inline\" :show-file-list=\"false\" :on-success=\"onSuccess\" :on-error=\"onError\" :before-upload=\"beforeUpload\" action=\"/system/basic/jl/import\"&gt; &lt;el-button size=\"mini\" type=\"success\" :disabled=\"!enabledUploadBtn\" :icon=\"uploadBtnIcon\"&gt;{{btnText}}&lt;/el-button&gt;&lt;/el-upload&gt; show-file-list 表示是否展示上传文件列表，默认为true，这里设置为不展示。 before-upload 表示上传之前的回调，可以在该方法中，做一些准备工作，例如展示一个进度条给用户 。 on-success 和 on-error 分别表示上传成功和失败时候的回调，可以在这两个方法中，给用户一个相应的提示，如果有进度条，还需要在这两个方法中关闭进度条。 action 指文件上传地址。 上传按钮的点击状态和图标都设置为变量 ，在文件上传过程中，修改上传按钮的点击状态为不可点击，同时修改图标为一个正在加载的图标 loading。 上传的文本也设为变量，默认上传 button 的文本是 数据导入 ，当开始上传后，将找个 button 上的文本修改为 正在导入。 相应的回调如下： 123456789101112131415onSuccess(response, file, fileList) { this.enabledUploadBtn = true; this.uploadBtnIcon = 'el-icon-upload2'; this.btnText = '数据导入';},onError(err, file, fileList) { this.enabledUploadBtn = true; this.uploadBtnIcon = 'el-icon-upload2'; this.btnText = '数据导入';},beforeUpload(file) { this.enabledUploadBtn = false; this.uploadBtnIcon = 'el-icon-loading'; this.btnText = '正在导入';} 在文件开始上传时，修改上传按钮为不可点击，同时修改上传按钮的图标和文本。 文件上传成功或者失败时，修改上传按钮的状态为可以点击，同时恢复上传按钮的图标和文本。 上传效果图如下： 总结两种上传方式各有优缺点： 第一种方式最大的优势是通用，一招鲜吃遍天，到哪里都能用，但是对于上传过程的监控，进度条的展示等等逻辑都需要自己来实现。 第二种方式不够通用，因为它是 ElementUI 中的组件，得引入 ElementUI 才能使用，不过这种方式很明显有需多比较方便的回调，可以实现非常方便的处理常见的各种上传问题。 常规的上传需求第二种方式可以满足，但是如果要对上传的方法进行定制，则还是建议使用第一种上传方案。","link":"/post/8f3d9328.html"},{"title":"Spring Boot 中实现定时任务的两种方式","text":"在 Spring + SpringMVC 环境中，一般来说，要实现定时任务，我们有两中方案，一种是使用 Spring 自带的定时任务处理器 @Scheduled 注解，另一种就是使用第三方框架 Quartz ，Spring Boot 源自 Spring+SpringMVC ，因此天然具备这两个 Spring 中的定时任务实现策略，当然也支持 Quartz，本文我们就来看下 Spring Boot 中两种定时任务的实现方式。 @Scheduled使用 @Scheduled 非常容易，直接创建一个 Spring Boot 项目，并且添加 web 依赖 spring-boot-starter-web，项目创建成功后，添加 @EnableScheduling 注解，开启定时任务： 123456789@SpringBootApplication@EnableSchedulingpublic class ScheduledApplication { public static void main(String[] args) { SpringApplication.run(ScheduledApplication.class, args); }} 接下来配置定时任务： 123456789101112@Scheduled(fixedRate = 2000)public void fixedRate() { System.out.println(\"fixedRate&gt;&gt;&gt;\"+new Date()); }@Scheduled(fixedDelay = 2000)public void fixedDelay() { System.out.println(\"fixedDelay&gt;&gt;&gt;\"+new Date());}@Scheduled(initialDelay = 2000,fixedDelay = 2000)public void initialDelay() { System.out.println(\"initialDelay&gt;&gt;&gt;\"+new Date());} 首先使用 @Scheduled 注解开启一个定时任务。 fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。 fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。 initialDelay 表示首次任务启动的延迟时间。 所有时间的单位都是毫秒。 上面这是一个基本用法，除了这几个基本属性之外，@Scheduled 注解也支持 cron 表达式，使用 cron 表达式，可以非常丰富的描述定时任务的时间。cron 表达式格式如下： [秒] [分] [小时] [日] [月] [周] [年] 具体取值如下： 序号 说明 是否必填 允许填写的值 允许的通配符 1 秒 是 0-59 - * / 2 分 是 0-59 - * / 3 时 是 0-23 - * / 4 日 是 1-31 - * ? / L W 5 月 是 1-12 or JAN-DEC - * / 6 周 是 1-7 or SUN-SAT - * ? / L # 7 年 否 1970-2099 - * / 这一块需要大家注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ? 通配符含义： ? 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ? * 表示所有值，例如:在秒的字段上设置 *,表示每一秒都会触发 , 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发 - 表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发 / 用于递增触发，如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50) # 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了) 周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同 L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五” W 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“) L 和 W 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 ) 例如，在 @Scheduled 注解中来一个简单的 cron 表达式，每隔5秒触发一次，如下： 1234@Scheduled(cron = \"0/5 * * * * *\")public void cron() { System.out.println(new Date());} 上面介绍的是使用 @Scheduled 注解的方式来实现定时任务，接下来我们再来看看如何使用 Quartz 实现定时任务。 Quartz一般在项目中，除非定时任务涉及到的业务实在是太简单，使用 @Scheduled 注解来解决定时任务，否则大部分情况可能都是使用 Quartz 来做定时任务。在 Spring Boot 中使用 Quartz ，只需要在创建项目时，添加 Quartz 依赖即可： 项目创建完成后，也需要添加开启定时任务的注解： 1234567@SpringBootApplication@EnableSchedulingpublic class QuartzApplication { public static void main(String[] args) { SpringApplication.run(QuartzApplication.class, args); }} Quartz 在使用过程中，有两个关键概念，一个是JobDetail（要做的事情），另一个是触发器（什么时候做），要定义 JobDetail，需要先定义 Job，Job 的定义有两种方式： 第一种方式，直接定义一个Bean： 123456@Componentpublic class MyJob1 { public void sayHello() { System.out.println(\"MyJob1&gt;&gt;&gt;\"+new Date()); }} 关于这种定义方式说两点： 首先将这个 Job 注册到 Spring 容器中。 这种定义方式有一个缺陷，就是无法传参。 第二种定义方式，则是继承 QuartzJobBean 并实现默认的方法： 123456789101112131415161718public class MyJob2 extends QuartzJobBean { HelloService helloService; public HelloService getHelloService() { return helloService; } public void setHelloService(HelloService helloService) { this.helloService = helloService; } @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException { helloService.sayHello(); }}public class HelloService { public void sayHello() { System.out.println(\"hello service &gt;&gt;&gt;\"+new Date()); }} 和第1种方式相比，这种方式支持传参，任务启动时，executeInternal 方法将会被执行。 Job 有了之后，接下来创建类，配置 JobDetail 和 Trigger 触发器，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configurationpublic class QuartzConfig { @Bean MethodInvokingJobDetailFactoryBean methodInvokingJobDetailFactoryBean() { MethodInvokingJobDetailFactoryBean bean = new MethodInvokingJobDetailFactoryBean(); bean.setTargetBeanName(\"myJob1\"); bean.setTargetMethod(\"sayHello\"); return bean; } @Bean JobDetailFactoryBean jobDetailFactoryBean() { JobDetailFactoryBean bean = new JobDetailFactoryBean(); bean.setJobClass(MyJob2.class); JobDataMap map = new JobDataMap(); map.put(\"helloService\", helloService()); bean.setJobDataMap(map); return bean; } @Bean SimpleTriggerFactoryBean simpleTriggerFactoryBean() { SimpleTriggerFactoryBean bean = new SimpleTriggerFactoryBean(); bean.setStartTime(new Date()); bean.setRepeatCount(5); bean.setJobDetail(methodInvokingJobDetailFactoryBean().getObject()); bean.setRepeatInterval(3000); return bean; } @Bean CronTriggerFactoryBean cronTrigger() { CronTriggerFactoryBean bean = new CronTriggerFactoryBean(); bean.setCronExpression(\"0/10 * * * * ?\"); bean.setJobDetail(jobDetailFactoryBean().getObject()); return bean; } @Bean SchedulerFactoryBean schedulerFactoryBean() { SchedulerFactoryBean bean = new SchedulerFactoryBean(); bean.setTriggers(cronTrigger().getObject(), simpleTriggerFactoryBean().getObject()); return bean; } @Bean HelloService helloService() { return new HelloService(); }} 关于这个配置说如下几点： JobDetail 的配置有两种方式：MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean 。 使用 MethodInvokingJobDetailFactoryBean 可以配置目标 Bean 的名字和目标方法的名字，这种方式不支持传参。 使用 JobDetailFactoryBean 可以配置 JobDetail ，任务类继承自 QuartzJobBean ，这种方式支持传参，将参数封装在 JobDataMap 中进行传递。 Trigger 是指触发器，Quartz 中定义了多个触发器，这里向大家展示其中两种的用法，SimpleTrigger 和 CronTrigger 。 SimpleTrigger 有点类似于前面说的 @Scheduled 的基本用法。 CronTrigger 则有点类似于 @Scheduled 中 cron 表达式的用法。 全部定义完成后，启动 Spring Boot 项目就可以看到定时任务的执行了。 总结这里主要向大家展示了 Spring Boot 中整合两种定时任务的方法，整合成功之后，剩下的用法基本上就和在 SSM 中使用一致了，不再赘述。","link":"/post/582ada8b.html"},{"title":"Spring Boot 中的静态资源到底要放在哪里？","text":"当我们使用 SpringMVC 框架时，静态资源会被拦截，需要添加额外配置，之前老有小伙伴在微信上问松哥Spring Boot 中的静态资源加载问题：“松哥，我的HTML页面好像没有样式？”，今天我就通过一篇文章，来和大伙仔细聊一聊这个问题。 SSM 中的配置要讲 Spring Boot 中的问题，我们得先回到 SSM 环境搭建中，一般来说，我们可以通过 &lt;mvc:resources /&gt; 节点来配置不拦截静态资源，如下： 123&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"/&gt;&lt;mvc:resources mapping=\"/css/**\" location=\"/css/\"/&gt;&lt;mvc:resources mapping=\"/html/**\" location=\"/html/\"/&gt; 由于这是一种Ant风格的路径匹配符，/** 表示可以匹配任意层级的路径，因此上面的代码也可以像下面这样简写： 1&lt;mvc:resources mapping=\"/**\" location=\"/\"/&gt; 这种配置是在 XML 中的配置，大家知道，SpringMVC 的配置除了在XML中配置，也可以在 Java 代码中配置，如果在Java代码中配置的话，我们只需要自定义一个类，继承自WebMvcConfigurationSupport即可： 12345678@Configuration@ComponentScan(basePackages = \"org.sang.javassm\")public class SpringMVCConfig extends WebMvcConfigurationSupport { @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\").addResourceLocations(\"/\"); }} 重写 WebMvcConfigurationSupport 类中的addResourceHandlers方法，在该方法中配置静态资源位置即可，这里的含义和上面 xml 配置的含义一致，因此无需多说。这是我们传统的解决方案，在Spring Boot 中，其实配置方式和这个一脉相承，只是有一些自动化的配置了。 Spring Boot 中的配置在 Spring Boot 中，如果我们是从 https://start.spring.io 这个网站上创建的项目，或者使用 IntelliJ IDEA 中的 Spring Boot 初始化工具创建的项目，默认都会存在 resources/static 目录，很多小伙伴也知道静态资源只要放到这个目录下，就可以直接访问，除了这里还有没有其他可以放静态资源的位置呢？为什么放在这里就能直接访问了呢？这就是本文要讨论的问题了。 整体规划首先，在 Spring Boot 中，默认情况下，一共有5个位置可以放静态资源，五个路径分别是如下5个： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ / 前四个目录好理解，分别对应了resources目录下不同的目录，第5个 / 是啥意思呢？我们知道，在 Spring Boot 项目中，默认是没有 webapp 这个目录的，当然我们也可以自己添加（例如在需要使用JSP的时候），这里第5个 / 其实就是表示 webapp 目录中的静态资源也不被拦截。如果同一个文件分别出现在五个目录下，那么优先级也是按照上面列出的顺序。 不过，虽然有5个存储目录，除了第5个用的比较少之外，其他四个，系统默认创建了 classpath:/static/ ， 正常情况下，我们只需要将我们的静态资源放到这个目录下即可，也不需要额外去创建其他静态资源目录，例如我在 classpath:/static/ 目录下放了一张名为1.png 的图片，那么我的访问路径是： 1http://localhost:8080/1.png 这里大家注意，请求地址中并不需要 static，如果加上了static反而多此一举会报404错误。很多人会觉得奇怪，为什么不需要添加 static呢？资源明明放在 static 目录下。其实这个效果很好实现，例如在SSM配置中，我们的静态资源拦截配置如果是下面这样： 1&lt;mvc:resources mapping=\"/**\" location=\"/static/\"/&gt; 如果我们是这样配置的话，请求地址如果是 http://localhost:8080/1.png 实际上系统会去 /static/1.png 目录下查找相关的文件。 所以我们理所当然的猜测，在 Spring Boot 中可能也是类似的配置。 源码解读胡适之先生说：“大胆猜想，小心求证”，我们这里就通过源码解读来看看 Spring Boot 中的静态资源到底是怎么配置的。 首先我们在 WebMvcAutoConfiguration 类中看到了 SpringMVC 自动化配置的相关的内容，找到了静态资源拦截的配置，如下： 可以看到这里静态资源的定义和我们前面提到的Java配置SSM中的配置非常相似，其中，this.mvcProperties.getStaticPathPattern() 方法对应的值是 “/**”，this.resourceProperties.getStaticLocations()方法返回了四个位置，分别是：”classpath:/META-INF/resources/“, “classpath:/resources/“,”classpath:/static/“, “classpath:/public/“，然后在getResourceLocations方法中，又添加了“/”，因此这里返回值一共有5个。其中，/表示webapp目录，即webapp中的静态文件也可以直接访问。静态资源的匹配路径按照定义路径优先级依次降低。因此这里的配置和我们前面提到的如出一辙。这样大伙就知道了为什么Spring Boot 中支持5个静态资源位置，同时也明白了为什么静态资源请求路径中不需要/static，因为在路径映射中已经自动的添加上了/static了。 自定义配置当然，这个是系统默认配置，如果我们并不想将资源放在系统默认的这五个位置上，也可以自定义静态资源位置和映射，自定义的方式也有两种，可以通过 application.properties 来定义，也可以在 Java 代码中来定义，下面分别来看。 application.properties在配置文件中定义的方式比较简单，如下： 12spring.resources.static-locations=classpath:/spring.mvc.static-path-pattern=/** 第一行配置表示定义资源位置，第二行配置表示定义请求 URL 规则。以上文的配置为例，如果我们这样定义了，表示可以将静态资源放在 resources目录下的任意地方，我们访问的时候当然也需要写完整的路径，例如在resources/static目录下有一张名为1.png 的图片，那么访问路径就是 http://localhost:8080/static/1.png ,注意此时的static不能省略。 Java 代码定义当然，在Spring Boot中我们也可以通过 Java代码来自定义，方式和 Java 配置的 SSM 比较类似，如下： 1234567@Configurationpublic class WebMVCConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/aaa/\"); }} 这里代码基本和前面一致，比较简单，不再赘述。 总结这里需要提醒大家的是，松哥见到有很多人用了 Thymeleaf 之后，会将静态资源也放在 resources/templates 目录下，注意，templates 目录并不是静态资源目录，它是一个放页面模板的位置（你看到的 Thymeleaf 模板虽然后缀为 .html，其实并不是静态资源）。好了，通过上面的讲解，相信大家对 Spring Boot 中静态资源的位置有一个深刻了解了，应该不会再在项目中出错了吧！","link":"/post/d9279426.html"},{"title":"Spring Boot 中关于自定义异常处理的套路！","text":"在 Spring Boot 项目中 ，异常统一处理，可以使用 Spring 中 @ControllerAdvice 来统一处理，也可以自己来定义异常处理方案。Spring Boot 中，对异常的处理有一些默认的策略，我们分别来看。 默认情况下，Spring Boot 中的异常页面 是这样的： 我们从这个异常提示中，也能看出来，之所以用户看到这个页面，是因为开发者没有明确提供一个 /error 路径，如果开发者提供了 /error 路径 ，这个页面就不会展示出来，不过在 Spring Boot 中，提供 /error 路径实际上是下下策，Spring Boot 本身在处理异常时，也是当所有条件都不满足时，才会去找 /error 路径。那么我们就先来看看，在 Spring Boot 中，如何自定义 error 页面，整体上来说，可以分为两种，一种是静态页面，另一种是动态页面。 静态异常页面自定义静态异常页面，又分为两种，第一种 是使用 HTTP 响应码来命名页面，例如 404.html、405.html、500.html ….，另一种就是直接定义一个 4xx.html，表示400-499 的状态都显示这个异常页面，5xx.html 表示 500-599 的状态显示这个异常页面。 默认是在 classpath:/static/error/ 路径下定义相关页面： 此时，启动项目，如果项目抛出 500 请求错误，就会自动展示 500.html 这个页面，发生 404 就会展示 404.html 页面。如果异常展示页面既存在 5xx.html，也存在 500.html ，此时，发生500异常时，优先展示 500.html 页面。 动态异常页面动态的异常页面定义方式和静态的基本 一致，可以采用的页面模板有 jsp、freemarker、thymeleaf。动态异常页面，也支持 404.html 或者 4xx.html ，但是一般来说，由于动态异常页面可以直接展示异常详细信息，所以就没有必要挨个枚举错误了 ，直接定义 4xx.html（这里使用thymeleaf模板）或者 5xx.html 即可。 注意，动态页面模板，不需要开发者自己去定义控制器，直接定义异常页面即可 ，Spring Boot 中自带的异常处理器会自动查找到异常页面。 页面定义如下： 页面内容如下： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;5xx&lt;/h1&gt;&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=\"${path}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;error&lt;/td&gt; &lt;td th:text=\"${error}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;message&lt;/td&gt; &lt;td th:text=\"${message}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;timestamp&lt;/td&gt; &lt;td th:text=\"${timestamp}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;status&lt;/td&gt; &lt;td th:text=\"${status}\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 默认情况下，完整的异常信息就是这5条，展示 效果如下 ： 如果动态页面和静态页面同时定义了异常处理页面，例如 classpath:/static/error/404.html 和 classpath:/templates/error/404.html 同时存在时，默认使用动态页面。即完整的错误页面查找方式应该是这样： 发生了500错误–&gt;查找动态 500.html 页面–&gt;查找静态 500.html –&gt; 查找动态 5xx.html–&gt;查找静态 5xx.html。 自定义异常数据默认情况下，在Spring Boot 中，所有的异常数据其实就是上文所展示出来的5条数据，这5条数据定义在 org.springframework.boot.web.reactive.error.DefaultErrorAttributes 类中，具体定义在 getErrorAttributes 方法中 ： 1234567891011121314@Overridepublic Map&lt;String, Object&gt; getErrorAttributes(ServerRequest request, boolean includeStackTrace) { Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;&gt;(); errorAttributes.put(\"timestamp\", new Date()); errorAttributes.put(\"path\", request.path()); Throwable error = getError(request); HttpStatus errorStatus = determineHttpStatus(error); errorAttributes.put(\"status\", errorStatus.value()); errorAttributes.put(\"error\", errorStatus.getReasonPhrase()); errorAttributes.put(\"message\", determineMessage(error)); handleException(errorAttributes, determineException(error), includeStackTrace); return errorAttributes;} DefaultErrorAttributes 类本身则是在org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration 异常自动配置类中定义的，如果开发者没有自己提供一个 ErrorAttributes 的实例的话，那么 Spring Boot 将自动提供一个ErrorAttributes 的实例，也就是 DefaultErrorAttributes 。 基于此 ，开发者自定义 ErrorAttributes 有两种方式 ： 直接实现 ErrorAttributes 接口 继承 DefaultErrorAttributes（推荐），因为 DefaultErrorAttributes 中对异常数据的处理已经完成，开发者可以直接使用。 具体定义如下： 1234567891011@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map&lt;String, Object&gt; map = super.getErrorAttributes(webRequest, includeStackTrace); if ((Integer)map.get(\"status\") == 500) { map.put(\"message\", \"服务器内部错误!\"); } return map; }} 定义好的 ErrorAttributes 一定要注册成一个 Bean ，这样，Spring Boot 就不会使用默认的 DefaultErrorAttributes 了，运行效果如下图： 自定义异常视图异常视图默认就是前面所说的静态或者动态页面，这个也是可以自定义的，首先 ，默认的异常视图加载逻辑在 org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController 类的 errorHtml 方法中，这个方法用来返回异常页面+数据，还有另外一个 error 方法，这个方法用来返回异常数据（如果是 ajax 请求，则该方法会被触发）。 12345678910@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) { HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView != null) ? modelAndView : new ModelAndView(\"error\", model);} 在该方法中 ，首先会通过 getErrorAttributes 方法去获取异常数据（实际上会调用到 ErrorAttributes 的实例 的 getErrorAttributes 方法），然后调用 resolveErrorView 去创建一个 ModelAndView ，如果这里创建失败，那么用户将会看到默认的错误提示页面。 正常情况下， resolveErrorView 方法会来到 DefaultErrorViewResolver 类的 resolveErrorView 方法中： 123456789@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) { modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); } return modelAndView;} 在这里，首先以异常响应码作为视图名分别去查找动态页面和静态页面，如果没有查找到，则再以 4xx 或者 5xx 作为视图名再去分别查找动态或者静态页面。 要自定义异常视图解析，也很容易 ，由于 DefaultErrorViewResolver 是在 ErrorMvcAutoConfiguration 类中提供的实例，即开发者没有提供相关实例时，会使用默认的 DefaultErrorViewResolver ，开发者提供了自己的 ErrorViewResolver 实例后，默认的配置就会失效，因此，自定义异常视图，只需要提供 一个 ErrorViewResolver 的实例即可： 12345678910@Componentpublic class MyErrorViewResolver extends DefaultErrorViewResolver { public MyErrorViewResolver(ApplicationContext applicationContext, ResourceProperties resourceProperties) { super(applicationContext, resourceProperties); } @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { return new ModelAndView(\"/aaa/123\", model); }} 实际上，开发者也可以在这里定义异常数据（直接在 resolveErrorView 方法重新定义一个 model ，将参数中的model 数据拷贝过去并修改，注意参数中的 model 类型为 UnmodifiableMap，即不可以直接修改），而不需要自定义MyErrorAttributes。定义完成后，提供一个名为123的视图，如下图： 如此之后，错误试图就算定义成功了。 总结实际上也可以自定义异常控制器 BasicErrorController ，不过松哥觉得这样太大动干戈了，没必要，前面几种方式已经可以满足我们的大部分开发需求了。","link":"/post/4368b84d.html"},{"title":"Spring Boot 定义系统启动任务，你会几种方式？","text":"在 Servlet/Jsp 项目中，如果涉及到系统任务，例如在项目启动阶段要做一些数据初始化操作，这些操作有一个共同的特点，只在项目启动时进行，以后都不再执行，这里，容易想到web基础中的三大组件（ Servlet、Filter、Listener ）之一 Listener ，这种情况下，一般定义一个 ServletContextListener，然后就可以监听到项目启动和销毁，进而做出相应的数据初始化和销毁操作，例如下面这样： 12345678910public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { //在这里做数据初始化操作 } @Override public void contextDestroyed(ServletContextEvent sce) { //在这里做数据备份操作 }} 当然，这是基础 web 项目的解决方案，如果使用了 Spring Boot，那么我们可以使用更为简便的方式。Spring Boot 中针对系统启动任务提供了两种解决方案，分别是 CommandLineRunner 和 ApplicationRunner，分别来看。 CommandLineRunner使用 CommandLineRunner 时，首先自定义 MyCommandLineRunner1 并且实现 CommandLineRunner 接口： 1234567@Component@Order(100)public class MyCommandLineRunner1 implements CommandLineRunner { @Override public void run(String... args) throws Exception { }} 关于这段代码，我做如下解释： 首先通过 @Compoent 注解将 MyCommandLineRunner1 注册为Spring容器中的一个 Bean。 添加 @Order注解，表示这个启动任务的执行优先级，因为在一个项目中，启动任务可能有多个，所以需要有一个排序。@Order 注解中，数字越小，优先级越大，默认情况下，优先级的值为 Integer.MAX_VALUE，表示优先级最低。 在 run 方法中，写启动任务的核心逻辑，当项目启动时，run方法会被自动执行。 run 方法的参数，来自于项目的启动参数，即项目入口类中，main方法的参数会被传到这里。 此时启动项目，run方法就会被执行，至于参数，可以通过两种方式来传递，如果是在 IDEA 中，可以通过如下方式来配置参数： 另一种方式，则是将项目打包，在命令行中启动项目，然后启动时在命令行传入参数，如下： 1java -jar devtools-0.0.1-SNAPSHOT.jar 三国演义 西游记 注意，这里参数传递时没有key，直接写value即可，执行结果如下： ApplicationRunnerApplicationRunner 和 CommandLineRunner 功能一致，用法也基本一致，唯一的区别主要体现在对参数的处理上，ApplicationRunner 可以接收更多类型的参数（ApplicationRunner 除了可以接收 CommandLineRunner 的参数之外，还可以接收 key/value形式的参数）。 使用 ApplicationRunner ，自定义类实现 ApplicationRunner 接口即可，组件注册以及组件优先级的配置都和 CommandLineRunner 一致，如下： 123456789101112131415@Component@Order(98)public class MyApplicationRunner1 implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(\"MyApplicationRunner1&gt;&gt;&gt;\"+nonOptionArgs); Set&lt;String&gt; optionNames = args.getOptionNames(); for (String key : optionNames) { System.out.println(\"MyApplicationRunner1&gt;&gt;&gt;\"+key + \":\" + args.getOptionValues(key)); } String[] sourceArgs = args.getSourceArgs(); System.out.println(\"MyApplicationRunner1&gt;&gt;&gt;\"+Arrays.toString(sourceArgs)); }} 当项目启动时，这里的 run 方法就会被自动执行，关于 run 方法的参数 ApplicationArguments ，我说如下几点： args.getNonOptionArgs();可以用来获取命令行中的无key参数（和CommandLineRunner一样）。 args.getOptionNames();可以用来获取所有key/value形式的参数的key。 args.getOptionValues(key));可以根据key获取key/value 形式的参数的value。 args.getSourceArgs(); 则表示获取命令行中的所有参数。 ApplicationRunner 定义完成后，传启动参数也是两种方式，参数类型也有两种，第一种和 CommandLineRunner 一致，第二种则是 –key=value 的形式，在 IDEA 中定义方式如下： 或者使用 如下启动命令： 1java -jar devtools-0.0.1-SNAPSHOT.jar 三国演义 西游记 --age=99 运行结果如下： 总结整体来说 ，这两种的用法的差异不大 ，主要体现在对参数的处理上，小伙伴可以根据项目中的实际情况选择合适的解决方案。","link":"/post/70a19413.html"},{"title":"Spring Boot中的yaml配置简介","text":"搞Spring Boot的小伙伴都知道，Spring Boot中的配置文件有两种格式，properties或者yaml，一般情况下，两者可以随意使用，选择自己顺手的就行了，那么这两者完全一样吗？肯定不是啦！本文就来和大伙重点介绍下yaml配置，最后再来看看yaml和properties配置有何区别。 狡兔三窟首先application.yaml在Spring Boot中可以写在四个不同的位置，分别是如下位置： 项目根目录下的config目录中 项目根目录下 classpath下的config目录中 classpath目录下 四个位置中的application.yaml文件的优先级按照上面列出的顺序依次降低。即如果有同一个属性在四个文件中都出现了，以优先级高的为准。 那么application.yaml是不是必须叫application.yaml这个名字呢？当然不是必须的。开发者可以自己定义yaml名字，自己定义的话，需要在项目启动时指定配置文件的名字，像下面这样： 当然这是在IntelliJ IDEA中直接配置的，如果项目已经打成jar包了，则在项目启动时加入如下参数： 1java -jar myproject.jar --spring.config.name=app 这样配置之后，在项目启动时，就会按照上面所说的四个位置按顺序去查找一个名为app.yaml的文件。当然这四个位置也不是一成不变的，也可以自己定义，有两种方式，一个是使用spring.config.location属性，另一个则是使用spring.config.additional-location这个属性，在第一个属性中，表示自己重新定义配置文件的位置，项目启动时就按照定义的位置去查找配置文件，这种定义方式会覆盖掉默认的四个位置，也可以使用第二种方式，第二种方式则表示在四个位置的基础上，再添加几个位置，新添加的位置的优先级大于原本的位置。 配置方式如下： 这里要注意，配置文件位置时，值一定要以/结尾。 数组注入yaml也支持数组注入，例如 1234my: servers: - dev.example.com - another.example.com 这段数据可以绑定到一个带Bean的数组中： 12345678910@ConfigurationProperties(prefix=\"my\")@Componentpublic class Config { private List&lt;String&gt; servers = new ArrayList&lt;String&gt;(); public List&lt;String&gt; getServers() { return this.servers; }} 项目启动后，配置中的数组会自动存储到servers集合中。当然，yaml不仅可以存储这种简单数据，也可以在集合中存储对象。例如下面这种： 123456redis: redisConfigs: - host: 192.168.66.128 port: 6379 - host: 192.168.66.129 port: 6380 这个可以被注入到如下类中： 123456@Component@ConfigurationProperties(prefix = \"redis\")public class RedisCluster { private List&lt;SingleRedisConfig&gt; redisConfigs; //省略getter/setter} 优缺点不同于properties文件的无序，yaml配置是有序的，这一点在有些配置中是非常有用的，例如在Spring Cloud Zuul的配置中，当我们配置代理规则时，顺序就显得尤为重要了。当然yaml配置也不是万能的，例如，yaml配置目前不支持@PropertySource注解。","link":"/post/d15e2b9d.html"},{"title":"Spring Boot中，Redis缓存还能这么用！","text":"经过Spring Boot的整合封装与自动化配置，在Spring Boot中整合Redis已经变得非常容易了，开发者只需要引入Spring Data Redis依赖，然后简单配下redis的基本信息，系统就会提供一个RedisTemplate供开发者使用，但是今天松哥想和大伙聊的不是这种用法，而是结合Cache的用法。Spring3.1中开始引入了令人激动的Cache，在Spring Boot中，可以非常方便的使用Redis来作为Cache的实现，进而实现数据的缓存。 工程创建首先创建一个Spring Boot工程，注意创建的时候需要引入三个依赖，web、cache以及redis，如下图： 对应的依赖内容如下： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 基本配置工程创建好之后，首先需要简单配置一下Redis，Redis的基本信息，另外，这里要用到Cache，因此还需要稍微配置一下Cache，如下： 1234spring.redis.port=6380spring.redis.host=192.168.66.128spring.cache.cache-names=c1 简单起见，这里我只是配置了Redis的端口和地址，然后给缓存取了一个名字，这个名字在后文会用到。 另外，还需要在配置类上添加如下代码，表示开启缓存： 123456789@SpringBootApplication@EnableCachingpublic class RediscacheApplication { public static void main(String[] args) { SpringApplication.run(RediscacheApplication.class, args); }} 完成了这些配置之后，Spring Boot就会自动帮我们在后台配置一个RedisCacheManager，相关的配置是在org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration类中完成的。部分源码如下： 123456789101112131415161718192021@Configuration@ConditionalOnClass(RedisConnectionFactory.class)@AutoConfigureAfter(RedisAutoConfiguration.class)@ConditionalOnBean(RedisConnectionFactory.class)@ConditionalOnMissingBean(CacheManager.class)@Conditional(CacheCondition.class)class RedisCacheConfiguration { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) { RedisCacheManagerBuilder builder = RedisCacheManager .builder(redisConnectionFactory) .cacheDefaults(determineConfiguration(resourceLoader.getClassLoader())); List&lt;String&gt; cacheNames = this.cacheProperties.getCacheNames(); if (!cacheNames.isEmpty()) { builder.initialCacheNames(new LinkedHashSet&lt;&gt;(cacheNames)); } return this.customizerInvoker.customize(builder.build()); }} 看类上的注解，发现在万事俱备的情况下，系统会自动提供一个RedisCacheManager的Bean，这个RedisCacheManager间接实现了Spring中的Cache接口，有了这个Bean，我们就可以直接使用Spring中的缓存注解和接口了，而缓存数据则会被自动存储到Redis上。在单机的Redis中，这个Bean系统会自动提供，如果是Redis集群，这个Bean需要开发者来提供（后面的文章会讲到）。 缓存使用这里主要向小伙伴们介绍缓存中几个核心的注解使用。 @CacheConfig这个注解在类上使用，用来描述该类中所有方法使用的缓存名称，当然也可以不使用该注解，直接在具体的缓存注解上配置名称，示例代码如下： 1234@Service@CacheConfig(cacheNames = \"c1\")public class UserService {} @Cacheable这个注解一般加在查询方法上，表示将一个方法的返回值缓存起来，默认情况下，缓存的key就是方法的参数，缓存的value就是方法的返回值。示例代码如下： 12345@Cacheable(key = \"#id\")public User getUserById(Integer id,String username) { System.out.println(\"getUserById\"); return getUserFromDBById(id);} 当有多个参数时，默认就使用多个参数来做key，如果只需要其中某一个参数做key，则可以在@Cacheable注解中，通过key属性来指定key，如上代码就表示只使用id作为缓存的key，如果对key有复杂的要求，可以自定义keyGenerator。当然，Spring Cache中提供了root对象，可以在不定义keyGenerator的情况下实现一些复杂的效果： @CachePut这个注解一般加在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的key上，示例代码如下： 1234@CachePut(key = \"#user.id\")public User updateUserById(User user) { return user;} @CacheEvict这个注解一般加在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（condition属性）或者或者配置清除所有缓存（allEntries属性），示例代码如下： 1234@CacheEvict()public void deleteUserById(Integer id) { //在这里执行删除操作， 删除是去数据库中删除} 总结在Spring Boot中，使用Redis缓存，既可以使用RedisTemplate自己来实现，也可以使用使用这种方式，这种方式是Spring Cache提供的统一接口，实现既可以是Redis，也可以是Ehcache或者其他支持这种规范的缓存框架。从这个角度来说，Spring Cache和Redis、Ehcache的关系就像JDBC与各种数据库驱动的关系。 好了，关于这个问题就说到这里，有问题欢迎留言讨论。","link":"/post/84bacf94.html"},{"title":"Spring Boot中通过CORS解决跨域问题","text":"今天和小伙伴们来聊一聊通过CORS解决跨域问题。 同源策略很多人对跨域有一种误解，以为这是前端的事，和后端没关系，其实不是这样的，说到跨域，就不得不说说浏览器的同源策略。同源策略是由Netscape提出的一个著名的安全策略，它是浏览器最核心也最基本的安全功能，现在所有支持JavaScript的浏览器都会使用这个策略。所谓同源是指协议、域名以及端口要相同。同源策略是基于安全方面的考虑提出来的，这个策略本身没问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求，传统的跨域方案是JSONP，JSONP虽然能解决跨域但是有一个很大的局限性，那就是只支持GET请求，不支持其他类型的请求，而今天我们说的CORS（跨域源资源共享）（CORS，Cross-origin resource sharing）是一个W3C标准，它是一份浏览器技术的规范，提供了Web服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是JSONP模式的现代版。在Spring框架中，对于CORS也提供了相应的解决方案，今天我们就来看看SpringBoot中如何实现CORS。 实践接下来我们就来看看Spring Boot中如何实现这个东西。 首先创建两个普通的SpringBoot项目，这个就不用我多说，第一个命名为provider提供服务，第二个命名为consumer消费服务，第一个配置端口为8080，第二个配置配置为8081，然后在provider上提供两个hello接口，一个get，一个post，如下： 1234567891011@RestControllerpublic class HelloController { @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;hello&quot;; } @PostMapping(&quot;/hello&quot;) public String hello2() { return &quot;post hello&quot;; }} 在consumer的resources/static目录下创建一个html文件，发送一个简单的ajax请求，如下： 12345678910111213141516&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;input type=&quot;button&quot; onclick=&quot;btnClick()&quot; value=&quot;get_button&quot;&gt;&lt;input type=&quot;button&quot; onclick=&quot;btnClick2()&quot; value=&quot;post_button&quot;&gt;&lt;script&gt; function btnClick() { $.get(&apos;http://localhost:8080/hello&apos;, function (msg) { $(&quot;#app&quot;).html(msg); }); } function btnClick2() { $.post(&apos;http://localhost:8080/hello&apos;, function (msg) { $(&quot;#app&quot;).html(msg); }); }&lt;/script&gt; 然后分别启动两个项目，发送请求按钮，观察浏览器控制台如下： 1Access to XMLHttpRequest at &apos;http://localhost:8080/hello&apos; from origin &apos;http://localhost:8081&apos; has been blocked by CORS policy: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. 可以看到，由于同源策略的限制，请求无法发送成功。 使用CORS可以在前端代码不做任何修改的情况下，实现跨域，那么接下来看看在provider中如何配置。首先可以通过@CrossOrigin注解配置某一个方法接受某一个域的请求，如下： 1234567891011121314@RestControllerpublic class HelloController { @CrossOrigin(value = &quot;http://localhost:8081&quot;) @GetMapping(&quot;/hello&quot;) public String hello() { return &quot;hello&quot;; } @CrossOrigin(value = &quot;http://localhost:8081&quot;) @PostMapping(&quot;/hello&quot;) public String hello2() { return &quot;post hello&quot;; }} 这个注解表示这两个接口接受来自http://localhost:8081地址的请求，配置完成后，重启provider，再次发送请求，浏览器控制台就不会报错了，consumer也能拿到数据了。 此时观察浏览器请求网络控制台，可以看到响应头中多了如下信息： 这个表示服务端愿意接收来自http://localhost:8081的请求，拿到这个信息后，浏览器就不会再去限制本次请求的跨域了。 provider上，每一个方法上都去加注解未免太麻烦了，在Spring Boot中，还可以通过全局配置一次性解决这个问题，全局配置只需要在配置类中重写addCorsMappings方法即可，如下： 12345678910@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;http://localhost:8081&quot;) .allowedMethods(&quot;*&quot;) .allowedHeaders(&quot;*&quot;); }} /**表示本应用的所有方法都会去处理跨域请求，allowedMethods表示允许通过的请求数，allowedHeaders则表示允许的请求头。经过这样的配置之后，就不必在每个方法上单独配置跨域了。 存在的问题了解了整个CORS的工作过程之后，我们通过Ajax发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是CSRF（Cross-site request forgery）跨站请求伪造。跨站请求伪造也被称为one-click attack 或者 session riding，通常缩写为CSRF或者XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法，举个例子： 假如一家银行用以运行转账操作的URL地址如下：http://icbc.com/aa?bb=cc，那么，一个恶意攻击者可以在另一个网站上放置如下代码：&lt;img src=&quot;http://icbc.com/aa?bb=cc&quot;&gt;，如果用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会遭受损失。 基于此，浏览器在实际操作中，会对请求进行分类，分为简单请求，预先请求，带凭证的请求等，预先请求会首先发送一个options探测请求，和浏览器进行协商是否接受请求。默认情况下跨域请求是不需要凭证的，但是服务端可以配置要求客户端提供凭证，这样就可以有效避免csrf攻击。 好了，这个问题就说这么多，关于springboot中cors，还有一个小小的视频教程，加入我的知识星球免费观看。","link":"/post/ac597cdb.html"},{"title":"Spring Boot多数据源配置之JdbcTemplate","text":"多数据源配置也算是一个常见的开发需求，Spring和SpringBoot中，对此都有相应的解决方案，不过一般来说，如果有多数据源的需求，我还是建议首选分布式数据库中间件MyCat去解决相关问题，之前有小伙伴在我的知识星球上提问，他的数据根据条件的不同，可能保存在四十多个不同的数据库中，怎么办？这种场景下使用多数据源其实就有些费事了，我给的建议是使用MyCat，然后分表策略使用sharding-by-intfile。当然如果一些简单的需求，还是可以使用多数据源的，Spring Boot中，JdbcTemplate、MyBatis以及Jpa都可以配置多数据源，本文就先和大伙聊一聊JdbcTemplate中多数据源的配置（关于JdbcTemplate的用法，如果还有小伙伴不了解，可以参考我的上篇文章）。 创建工程首先是创建工程，和前文一样，创建工程时，也是选择Web、Jdbc以及MySQL驱动，如下图： 创建成功之后，一定接下来手动添加Druid依赖，由于这里一会需要开发者自己配置DataSoruce，所以这里必须要使用druid-spring-boot-starter依赖，而不是传统的那个druid依赖，因为druid-spring-boot-starter依赖提供了DruidDataSourceBuilder类，这个可以用来构建一个DataSource实例，而传统的Druid则没有该类。完整的依赖如下： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 配置数据源.接下来，在application.properties中配置数据源，不同于上文，这里的数据源需要配置两个，如下： spring.datasource.one.url=jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.one.username=root spring.datasource.one.password=root spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.two.url=jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=utf-8 spring.datasource.two.username=root spring.datasource.two.password=root spring.datasource.two.type=com.alibaba.druid.pool.DruidDataSource 这里通过one和two对数据源进行了区分，但是加了one和two之后，这里的配置就没法被SpringBoot自动加载了（因为前面的key变了），需要我们自己去加载DataSource了，此时，需要自己配置一个DataSourceConfig，用来提供两个DataSource Bean，如下： @Configuration public class DataSourceConfig { @Bean @ConfigurationProperties(prefix = \"spring.datasource.one\") DataSource dsOne() { return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasource.two\") DataSource dsTwo() { return DruidDataSourceBuilder.create().build(); } } 这里提供了两个Bean，其中@ConfigurationProperties是Spring Boot提供的类型安全的属性绑定，以第一个Bean为例，@ConfigurationProperties(prefix = &quot;spring.datasource.one&quot;)表示使用spring.datasource.one前缀的数据库配置去创建一个DataSource，这样配置之后，我们就有了两个不同的DataSource，接下来再用这两个不同的DataSource去创建两个不同的JdbcTemplate。 配置JdbcTemplate实例创建JdbcTemplateConfig类，用来提供两个不同的JdbcTemplate实例，如下： @Configuration public class JdbcTemplateConfig { @Bean JdbcTemplate jdbcTemplateOne(@Qualifier(\"dsOne\") DataSource dsOne) { return new JdbcTemplate(dsOne); } @Bean JdbcTemplate jdbcTemplateTwo(@Qualifier(\"dsTwo\") DataSource dsTwo) { return new JdbcTemplate(dsTwo); } } 每一个JdbcTemplate的创建都需要一个DataSource，由于Spring容器中现在存在两个DataSource，默认使用类型查找，会报错，因此加上@Qualifier注解，表示按照名称查找。这里创建了两个JdbcTemplate实例，分别对应了两个DataSource。 接下来直接去使用这个JdbcTemplate就可以了。 测试使用关于JdbcTemplate的详细用法大伙可以参考我的上篇文章，这里我主要演示数据源的差异，在Controller中注入两个不同的JdbcTemplate，这两个JdbcTemplate分别对应了不同的数据源，如下： @RestController public class HelloController { @Autowired @Qualifier(\"jdbcTemplateOne\") JdbcTemplate jdbcTemplateOne; @Resource(name = \"jdbcTemplateTwo\") JdbcTemplate jdbcTemplateTwo; @GetMapping(\"/user\") public List&lt;User&gt; getAllUser() { List&lt;User&gt; list = jdbcTemplateOne.query(\"select * from t_user\", new BeanPropertyRowMapper&lt;&gt;(User.class)); return list; } @GetMapping(\"/user2\") public List&lt;User&gt; getAllUser2() { List&lt;User&gt; list = jdbcTemplateTwo.query(\"select * from t_user\", new BeanPropertyRowMapper&lt;&gt;(User.class)); return list; } } 和DataSource一样，Spring容器中的JdbcTemplate也是有两个，因此不能通过byType的方式注入进来，这里给大伙提供了两种注入思路，一种是使用@Resource注解，直接通过byName的方式注入进来，另外一种就是@Autowired注解加上@Qualifier注解，两者联合起来，实际上也是byName。将JdbcTemplate注入进来之后，jdbcTemplateOne和jdbcTemplateTwo此时就代表操作不同的数据源，使用不同的JdbcTemplate操作不同的数据源，实现了多数据源配置。 好了，这个问题就先说到这里，关于这个多数据源配置，还有一个小小的视频教程，加入我的星球免费观看： 关于我的星球【Java达摩院】，大伙可以参考这篇文章推荐一个技术圈子，Java技能提升就靠它了.","link":"/post/9a408674.html"},{"title":"Spring Boot数据持久化之JdbcTemplate","text":"在Java领域，数据持久化有几个常见的方案，有Spring自带的JdbcTemplate、有MyBatis，还有JPA，在这些方案中，最简单的就是Spring自带的JdbcTemplate了，这个东西虽然没有MyBatis那么方便，但是比起最开始的Jdbc已经强了很多了，它没有MyBatis功能那么强大，当然也意味着它的使用比较简单，事实上，JdbcTemplate算是最简单的数据持久化方案了，本文就和大伙来说说这个东西的使用。 基本配置JdbcTemplate基本用法实际上很简单，开发者在创建一个SpringBoot项目时，除了选择基本的Web依赖，再记得选上Jdbc依赖，以及数据库驱动依赖即可，如下： 项目创建成功之后，记得添加Druid数据库连接池依赖（注意这里可以添加专门为Spring Boot打造的druid-spring-boot-starter，而不是我们一般在SSM中添加的Druid），所有添加的依赖如下： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 项目创建完后，接下来只需要在application.properties中提供数据的基本配置即可，如下： 1234spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.username=rootspring.datasource.password=123spring.datasource.url=jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8 如此之后，所有的配置就算完成了，接下来就可以直接使用JdbcTemplate了？咋这么方便呢？其实这就是SpringBoot的自动化配置带来的好处，我们先说用法，一会来说原理。 基本用法首先我们来创建一个User Bean，如下： public class User { private Long id; private String username; private String address; //省略getter/setter } 然后来创建一个UserService类，在UserService类中注入JdbcTemplate，如下： @Service public class UserService { @Autowired JdbcTemplate jdbcTemplate; } 好了，如此之后，准备工作就算完成了。 增JdbcTemplate中，除了查询有几个API之外，增删改统一都使用update来操作，自己来传入SQL即可。例如添加数据，方法如下： public int addUser(User user) { return jdbcTemplate.update(\"insert into user (username,address) values (?,?);\", user.getUsername(), user.getAddress()); } update方法的返回值就是SQL执行受影响的行数。 这里只需要传入SQL即可，如果你的需求比较复杂，例如在数据插入的过程中希望实现主键回填，那么可以使用PreparedStatementCreator，如下： public int addUser2(User user) { KeyHolder keyHolder = new GeneratedKeyHolder(); int update = jdbcTemplate.update(new PreparedStatementCreator() { @Override public PreparedStatement createPreparedStatement(Connection connection) throws SQLException { PreparedStatement ps = connection.prepareStatement(\"insert into user (username,address) values (?,?);\", Statement.RETURN_GENERATED_KEYS); ps.setString(1, user.getUsername()); ps.setString(2, user.getAddress()); return ps; } }, keyHolder); user.setId(keyHolder.getKey().longValue()); System.out.println(user); return update; } 实际上这里就相当于完全使用了JDBC中的解决方案了，首先在构建PreparedStatement时传入Statement.RETURN_GENERATED_KEYS，然后传入KeyHolder，最终从KeyHolder中获取刚刚插入数据的id保存到user对象的id属性中去。 你能想到的JDBC的用法，在这里都能实现，Spring提供的JdbcTemplate虽然不如MyBatis，但是比起Jdbc还是要方便很多的。 删删除也是使用update API，传入你的SQL即可： public int deleteUserById(Long id) { return jdbcTemplate.update(\"delete from user where id=?\", id); } 当然你也可以使用PreparedStatementCreator。 改public int updateUserById(User user) { return jdbcTemplate.update(\"update user set username=?,address=? where id=?\", user.getUsername(), user.getAddress(),user.getId()); } 当然你也可以使用PreparedStatementCreator。 查查询的话，稍微有点变化，这里主要向大伙介绍query方法，例如查询所有用户： public List&lt;User&gt; getAllUsers() { return jdbcTemplate.query(\"select * from user\", new RowMapper&lt;User&gt;() { @Override public User mapRow(ResultSet resultSet, int i) throws SQLException { String username = resultSet.getString(\"username\"); String address = resultSet.getString(\"address\"); long id = resultSet.getLong(\"id\"); User user = new User(); user.setAddress(address); user.setUsername(username); user.setId(id); return user; } }); } 查询的时候需要提供一个RowMapper，就是需要自己手动映射，将数据库中的字段和对象的属性一一对应起来，这样。。。。嗯看起来有点麻烦，实际上，如果数据库中的字段和对象属性的名字一模一样的话，有另外一个简单的方案，如下： public List&lt;User&gt; getAllUsers2() { return jdbcTemplate.query(\"select * from user\", new BeanPropertyRowMapper&lt;&gt;(User.class)); } 至于查询时候传参也是使用占位符，这个和前文的一致，这里不再赘述。 其他除了这些基本用法之外，JdbcTemplate也支持其他用法，例如调用存储过程等，这些都比较容易，而且和Jdbc本身都比较相似，这里也就不做介绍了，有兴趣可以留言讨论。 原理分析那么在SpringBoot中，配置完数据库基本信息之后，就有了一个JdbcTemplate了，这个东西是从哪里来的呢？源码在org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration类中，该类源码如下： @Configuration @ConditionalOnClass({ DataSource.class, JdbcTemplate.class }) @ConditionalOnSingleCandidate(DataSource.class) @AutoConfigureAfter(DataSourceAutoConfiguration.class) @EnableConfigurationProperties(JdbcProperties.class) public class JdbcTemplateAutoConfiguration { @Configuration static class JdbcTemplateConfiguration { private final DataSource dataSource; private final JdbcProperties properties; JdbcTemplateConfiguration(DataSource dataSource, JdbcProperties properties) { this.dataSource = dataSource; this.properties = properties; } @Bean @Primary @ConditionalOnMissingBean(JdbcOperations.class) public JdbcTemplate jdbcTemplate() { JdbcTemplate jdbcTemplate = new JdbcTemplate(this.dataSource); JdbcProperties.Template template = this.properties.getTemplate(); jdbcTemplate.setFetchSize(template.getFetchSize()); jdbcTemplate.setMaxRows(template.getMaxRows()); if (template.getQueryTimeout() != null) { jdbcTemplate .setQueryTimeout((int) template.getQueryTimeout().getSeconds()); } return jdbcTemplate; } } @Configuration @Import(JdbcTemplateConfiguration.class) static class NamedParameterJdbcTemplateConfiguration { @Bean @Primary @ConditionalOnSingleCandidate(JdbcTemplate.class) @ConditionalOnMissingBean(NamedParameterJdbcOperations.class) public NamedParameterJdbcTemplate namedParameterJdbcTemplate( JdbcTemplate jdbcTemplate) { return new NamedParameterJdbcTemplate(jdbcTemplate); } } } 从这个类中，大致可以看出，当当前类路径下存在DataSource和JdbcTemplate时，该类就会被自动配置，jdbcTemplate方法则表示，如果开发者没有自己提供一个JdbcOperations的实例的话，系统就自动配置一个JdbcTemplate Bean（JdbcTemplate是JdbcOperations接口的一个实现）。好了，不知道大伙有没有收获呢？ 关于JdbcTemplate，我还有一个小小视频，加入我的知识星球，免费观看： 加入我的星球，和众多大牛一起切磋技术推荐一个技术圈子，Java技能提升就靠它了。","link":"/post/b7973915.html"},{"title":"Spring Boot整合Jpa多数据源","text":"本文是Spring Boot整合数据持久化方案的最后一篇，主要和大伙来聊聊Spring Boot整合Jpa多数据源问题。在Spring Boot整合JbdcTemplate多数据源、Spring Boot整合MyBatis多数据源以及Spring Boot整合Jpa多数据源这三个知识点中，整合Jpa多数据源算是最复杂的一种，也是很多人在配置时最容易出错的一种。本文大伙就跟着松哥的教程，一步一步整合Jpa多数据源。 工程创建首先是创建一个Spring Boot工程，创建时添加基本的Web、Jpa以及MySQL依赖，如下： 创建完成后，添加Druid依赖，这里和前文的要求一样，要使用专为Spring Boot打造的Druid，大伙可能发现了，如果整合多数据源一定要使用这个依赖，因为这个依赖中才有DruidDataSourceBuilder，最后还要记得锁定数据库依赖的版本，因为可能大部分人用的还是5.x的MySQL而不是8.x。完整依赖如下： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 如此之后，工程就创建成功了。 基本配置在基本配置中，我们首先来配置多数据源基本信息以及DataSource，首先在application.properties中添加如下配置信息： 123456789101112131415161718# 数据源一spring.datasource.one.username=rootspring.datasource.one.password=rootspring.datasource.one.url=jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8spring.datasource.one.type=com.alibaba.druid.pool.DruidDataSource# 数据源二spring.datasource.two.username=rootspring.datasource.two.password=rootspring.datasource.two.url=jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=UTF-8spring.datasource.two.type=com.alibaba.druid.pool.DruidDataSource# Jpa配置spring.jpa.properties.database=mysqlspring.jpa.properties.show-sql=truespring.jpa.properties.database-platform=mysqlspring.jpa.properties.hibernate.ddl-auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect 这里Jpa的配置和上文相比key中多了properties，多数据源的配置和前文一致，然后接下来配置两个DataSource，如下： 1234567891011121314@Configurationpublic class DataSourceConfig { @Bean @ConfigurationProperties(prefix = \"spring.datasource.one\") @Primary DataSource dsOne() { return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasource.two\") DataSource dsTwo() { return DruidDataSourceBuilder.create().build(); }} 这里的配置和前文的多数据源配置基本一致，但是注意多了一个在Spring中使用较少的注解@Primary，这个注解一定不能少，否则在项目启动时会出错，@Primary表示当某一个类存在多个实例时，优先使用哪个实例。 好了，这样，DataSource就有了。 多数据源配置接下来配置Jpa的基本信息，这里两个数据源，我分别在两个类中来配置，先来看第一个配置： 123456789101112131415161718192021222324252627@Configuration@EnableJpaRepositories(basePackages = &quot;org.sang.jpa.dao&quot;,entityManagerFactoryRef = &quot;localContainerEntityManagerFactoryBeanOne&quot;,transactionManagerRef = &quot;platformTransactionManagerOne&quot;)public class JpaConfigOne { @Autowired @Qualifier(value = &quot;dsOne&quot;) DataSource dsOne; @Autowired JpaProperties jpaProperties; @Bean @Primary LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBeanOne(EntityManagerFactoryBuilder builder) { return builder.dataSource(dsOne) .packages(&quot;org.sang.jpa.model&quot;) .properties(jpaProperties.getProperties()) .persistenceUnit(&quot;pu1&quot;) .build(); } @Bean PlatformTransactionManager platformTransactionManagerOne(EntityManagerFactoryBuilder builder) { LocalContainerEntityManagerFactoryBean factoryBeanOne = localContainerEntityManagerFactoryBeanOne(builder); return new JpaTransactionManager(factoryBeanOne.getObject()); }} 首先这里注入dsOne，再注入JpaProperties，JpaProperties是系统提供的一个实例，里边的数据就是我们在application.properties中配置的jpa相关的配置。然后我们提供两个Bean，分别是LocalContainerEntityManagerFactoryBean和PlatformTransactionManager事务管理器，不同于MyBatis和JdbcTemplate，在Jpa中，事务一定要配置。在提供LocalContainerEntityManagerFactoryBean的时候，需要指定packages，这里的packages指定的包就是这个数据源对应的实体类所在的位置，另外在这里配置类上通过@EnableJpaRepositories注解指定dao所在的位置，以及LocalContainerEntityManagerFactoryBean和PlatformTransactionManager分别对应的引用的名字。 好了，这样第一个就配置好了，第二个基本和这个类似，主要有几个不同点： dao的位置不同 persistenceUnit不同 相关bean的名称不同 注意实体类可以共用。 代码如下： 1234567891011121314151617181920212223242526@Configuration@EnableJpaRepositories(basePackages = \"org.sang.jpa.dao2\",entityManagerFactoryRef = \"localContainerEntityManagerFactoryBeanTwo\",transactionManagerRef = \"platformTransactionManagerTwo\")public class JpaConfigTwo { @Autowired @Qualifier(value = \"dsTwo\") DataSource dsTwo; @Autowired JpaProperties jpaProperties; @Bean LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBeanTwo(EntityManagerFactoryBuilder builder) { return builder.dataSource(dsTwo) .packages(\"org.sang.jpa.model\") .properties(jpaProperties.getProperties()) .persistenceUnit(\"pu2\") .build(); } @Bean PlatformTransactionManager platformTransactionManagerTwo(EntityManagerFactoryBuilder builder) { LocalContainerEntityManagerFactoryBean factoryBeanTwo = localContainerEntityManagerFactoryBeanTwo(builder); return new JpaTransactionManager(factoryBeanTwo.getObject()); }} 接下来，在对应位置分别提供相关的实体类和dao即可，数据源一的dao如下： 12345678package org.sang.jpa.dao;public interface UserDao extends JpaRepository&lt;User,Integer&gt; { List&lt;User&gt; getUserByAddressEqualsAndIdLessThanEqual(String address, Integer id); @Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;,nativeQuery = true) User maxIdUser();} 数据源二的dao如下： 12345678package org.sang.jpa.dao2;public interface UserDao2 extends JpaRepository&lt;User,Integer&gt; { List&lt;User&gt; getUserByAddressEqualsAndIdLessThanEqual(String address, Integer id); @Query(value = &quot;select * from t_user where id=(select max(id) from t_user)&quot;,nativeQuery = true) User maxIdUser();} 共同的实体类如下： 1234567891011package org.sang.jpa.model;@Entity(name = &quot;t_user&quot;)public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String username; private String address; //省略getter/setter} 到此，所有的配置就算完成了，接下来就可以在Service中注入不同的UserDao，不同的UserDao操作不同的数据源。 其实整合Jpa多数据源也不算难，就是有几个细节问题，这些细节问题解决，其实前面介绍的其他多数据源整个都差不多。 好了，欢迎大家加入松哥的星球，关于我的星球【Java达摩院】，大伙可以参考这篇文章推荐一个技术圈子，Java技能提升就靠它了.","link":"/post/d09dcf13.html"},{"title":"SpringBoot整合Swagger2，再也不用维护接口文档了！","text":"前后端分离后，维护接口文档基本上是必不可少的工作。一个理想的状态是设计好后，接口文档发给前端和后端，大伙按照既定的规则各自开发，开发好了对接上了就可以上线了。当然这是一种非常理想的状态，实际开发中却很少遇到这样的情况，接口总是在不断的变化之中，有变化就要去维护，做过的小伙伴都知道这件事有多么头大！还好，有一些工具可以减轻我们的工作量，Swagger2就是其中之一，至于其他类似功能但是却收费的软件，这里就不做过多介绍了。本文主要和大伙来聊下在Spring Boot中如何整合Swagger2。 工程创建当然，首先是创建一个Spring Boot项目，加入web依赖，创建成功后，加入两个Swagger2相关的依赖，完整的依赖如下： 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; Swagger2配置Swagger2的配置也是比较容易的，在项目创建成功之后，只需要开发者自己提供一个Docket的Bean即可，如下： 1234567891011121314151617181920@Configuration@EnableSwagger2public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .pathMapping(\"/\") .select() .apis(RequestHandlerSelectors.basePackage(\"com.nvn.controller\")) .paths(PathSelectors.any()) .build().apiInfo(new ApiInfoBuilder() .title(\"SpringBoot整合Swagger\") .description(\"SpringBoot整合Swagger，详细信息......\") .version(\"9.0\") .contact(new Contact(\"啊啊啊啊\",\"blog.csdn.net\",\"aaa@gmail.com\")) .license(\"The Apache License\") .licenseUrl(\"http://www.baidu.com\") .build()); }} 这里提供一个配置类，首先通过@EnableSwagger2注解启用Swagger2，然后配置一个Docket Bean，这个Bean中，配置映射路径和要扫描的接口的位置，在apiInfo中，主要配置一下Swagger2文档网站的信息，例如网站的title，网站的描述，联系人的信息，使用的协议等等。 如此，Swagger2就算配置成功了，非常方便。 此时启动项目，输入http://localhost:8080/swagger-ui.html，能够看到如下页面，说明已经配置成功了： 创建接口接下来就是创建接口了，Swagger2相关的注解其实并不多，而且很容易懂，下面我来分别向小伙伴们举例说明： 123456789101112131415161718192021222324252627282930@RestController@Api(tags = \"用户管理相关接口\")@RequestMapping(\"/user\")public class UserController { @PostMapping(\"/\") @ApiOperation(\"添加用户的接口\") @ApiImplicitParams({ @ApiImplicitParam(name = \"username\", value = \"用户名\", defaultValue = \"李四\"), @ApiImplicitParam(name = \"address\", value = \"用户地址\", defaultValue = \"深圳\", required = true) } ) public RespBean addUser(String username, @RequestParam(required = true) String address) { return new RespBean(); } @GetMapping(\"/\") @ApiOperation(\"根据id查询用户的接口\") @ApiImplicitParam(name = \"id\", value = \"用户id\", defaultValue = \"99\", required = true) public User getUserById(@PathVariable Integer id) { User user = new User(); user.setId(id); return user; } @PutMapping(\"/{id}\") @ApiOperation(\"根据id更新用户的接口\") public User updateUserById(@RequestBody User user) { return user; }} 这里边涉及到多个API，我来向小伙伴们分别说明： @Api注解可以用来标记当前Controller的功能。 @ApiOperation注解用来标记一个方法的作用。 @ApiImplicitParam注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入。 如果有多个参数，则需要使用多个@ApiImplicitParam注解来描述，多个@ApiImplicitParam注解需要放在一个@ApiImplicitParams注解中。 需要注意的是，@ApiImplicitParam注解中虽然可以指定参数是必填的，但是却不能代替@RequestParam(required = true)，前者的必填只是在Swagger2框架内必填，抛弃了Swagger2，这个限制就没用了，所以假如开发者需要指定一个参数必填，@RequestParam(required = true)注解还是不能省略。 如果参数是一个对象（例如上文的更新接口），对于参数的描述也可以放在实体类中。例如下面一段代码： 12345678910@ApiModelpublic class User { @ApiModelProperty(value = \"用户id\") private Integer id; @ApiModelProperty(value = \"用户名\") private String username; @ApiModelProperty(value = \"用户地址\") private String address; //getter/setter} 好了，经过如上配置之后，接下来，刷新刚刚打开的页面，可以看到如下效果： 可以看到，所有的接口这里都列出来了，包括接口请求方式，接口地址以及接口的名字等，点开一个接口，可以看到如下信息： 可以看到，接口的参数，参数要求，参数默认值等等统统都展示出来了，参数类型下的query表示参数以key/value的形式传递，点击右上角的Try it out，就可以进行接口测试： 点击Execute按钮，表示发送请求进行测试。测试结果会展示在下面的Response中。 小伙伴们注意，参数类型下面的query表示参数以key/value的形式传递，这里的值也可能是body，body表示参数以请求体的方式传递，例如上文的更新接口，如下： 当然还有一种可能就是这里的参数为path，表示参数放在路径中传递，例如根据id查询用户的接口： 当然，除了这些之外，还有一些响应值的注解，都比较简单，小伙伴可以自己摸索下。 在Security中的配置如果我们的Spring Boot项目中集成了Spring Security，那么如果不做额外配置，Swagger2文档可能会被拦截，此时只需要在Spring Security的配置类中重写configure方法，添加如下过滤即可： 1234567@Overridepublic void configure(WebSecurity web) throws Exception { web.ignoring() .antMatchers(\"/swagger-ui.html\") .antMatchers(\"/v2/**\") .antMatchers(\"/swagger-resources/**\");} 如此之后，Swagger2文件就不需要认证就能访问了。不知道小伙伴们有没有看懂呢？有问题欢迎留言讨论。","link":"/post/dfe0efd6.html"},{"title":"SpringMVC 中 @ControllerAdvice 注解的三种使用场景！","text":"@ControllerAdvice ，很多初学者可能都没有听说过这个注解，实际上，这是一个非常有用的注解，顾名思义，这是一个增强的 Controller。使用这个 Controller ，可以实现三个方面的功能： 全局异常处理 全局数据绑定 全局数据预处理 灵活使用这三个功能，可以帮助我们简化很多工作，需要注意的是，这是 SpringMVC 提供的功能，在 Spring Boot 中可以直接使用，下面分别来看。 全局异常处理使用 @ControllerAdvice 实现全局异常处理，只需要定义类，添加该注解即可定义方式如下： 12345678910@ControllerAdvicepublic class MyGlobalExceptionHandler { @ExceptionHandler(Exception.class) public ModelAndView customException(Exception e) { ModelAndView mv = new ModelAndView(); mv.addObject(\"message\", e.getMessage()); mv.setViewName(\"myerror\"); return mv; }} 在该类中，可以定义多个方法，不同的方法处理不同的异常，例如专门处理空指针的方法、专门处理数组越界的方法…，也可以直接向上面代码一样，在一个方法中处理所有的异常信息。 @ExceptionHandler 注解用来指明异常的处理类型，即如果这里指定为 NullpointerException，则数组越界异常就不会进到这个方法中来。 全局数据绑定全局数据绑定功能可以用来做一些初始化的数据操作，我们可以将一些公共的数据定义在添加了 @ControllerAdvice 注解的类中，这样，在每一个 Controller 的接口中，就都能够访问导致这些数据。 使用步骤，首先定义全局数据，如下： 12345678910@ControllerAdvicepublic class MyGlobalExceptionHandler { @ModelAttribute(name = \"md\") public Map&lt;String,Object&gt; mydata() { HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"age\", 99); map.put(\"gender\", \"男\"); return map; }} 使用 @ModelAttribute 注解标记该方法的返回数据是一个全局数据，默认情况下，这个全局数据的 key 就是返回的变量名，value 就是方法返回值，当然开发者可以通过 @ModelAttribute 注解的 name 属性去重新指定 key。 定义完成后，在任何一个Controller 的接口中，都可以获取到这里定义的数据： 12345678910@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello(Model model) { Map&lt;String, Object&gt; map = model.asMap(); System.out.println(map); int i = 1 / 0; return \"hello controller advice\"; }} 全局数据预处理考虑我有两个实体类，Book 和 Author，分别定义如下： 12345678910public class Book { private String name; private Long price; //getter/setter}public class Author { private String name; private Integer age; //getter/setter} 此时，如果我定义一个数据添加接口，如下： 12345@PostMapping(\"/book\")public void addBook(Book book, Author author) { System.out.println(book); System.out.println(author);} 这个时候，添加操作就会有问题，因为两个实体类都有一个 name 属性，从前端传递时 ，无法区分。此时，通过 @ControllerAdvice 的全局数据预处理可以解决这个问题 解决步骤如下: 1.给接口中的变量取别名 12345@PostMapping(\"/book\")public void addBook(@ModelAttribute(\"b\") Book book, @ModelAttribute(\"a\") Author author) { System.out.println(book); System.out.println(author);} 2.进行请求数据预处理在 @ControllerAdvice 标记的类中添加如下代码: 12345678@InitBinder(\"b\")public void b(WebDataBinder binder) { binder.setFieldDefaultPrefix(\"b.\");}@InitBinder(\"a\")public void a(WebDataBinder binder) { binder.setFieldDefaultPrefix(\"a.\");} @InitBinder(“b”) 注解表示该方法用来处理和Book和相关的参数,在方法中,给参数添加一个 b 前缀,即请求参数要有b前缀. 3.发送请求 请求发送时,通过给不同对象的参数添加不同的前缀,可以实现参数的区分. 总结这就是松哥给大伙介绍的 @ControllerAdvice 的几个简单用法，这些点既可以在传统的 SSM 项目中使用，也可以在 Spring Boot + Spring Cloud 微服务中使用，欢迎大家有问题一起讨论。","link":"/post/2019a6c1.html"},{"title":"SpringMVC 方法四种类型返回值总结，你用过几种？","text":"SpringMVC 现在算是 Java 领域的一个基础性框架了，很多人天天用，可是对于 SpringMVC 方法的返回值，你又是否完全清楚呢？今天松哥就来和大家聊一聊 SpringMVC 中四种不同类型的返回值，看看有没有 get 到你的知识盲点？ 1. ModelAndView以前前后端不分的情况下，ModelAndView 应该是最最常见的返回值类型了，现在前后端分离后，后端都是以返回 JSON 数据为主了。后端返回 ModelAndView 这个比较容易理解，开发者可以在 ModelAndView 对象中指定视图名称，然后也可以绑定数据，像下面这样： 12345678910111213141516171819@RequestMapping(\"/book\")public ModelAndView getAllBook() { ModelAndView mv = new ModelAndView(); List&lt;Book&gt; books = new ArrayList&lt;&gt;(); Book b1 = new Book(); b1.setId(1); b1.setName(\"三国演义\"); b1.setAuthor(\"罗贯中\"); books.add(b1); Book b2 = new Book(); b2.setId(2); b2.setName(\"红楼梦\"); b2.setAuthor(\"曹雪芹\"); books.add(b2); //指定数据模型 mv.addObject(\"bs\", books); mv.setViewName(\"book\");//指定视图名 return mv;} 返回 ModelAndView ，最常见的两个操作就是指定数据模型+指定视图名 。 2. Void返回值为 void 时，可能是你真的没有值要返回，也可能是你有其他办法，松哥将之归为如下四类，大伙来看下。 2.1 没有值如果确实没有返回值，那就返回 void ，但是一定要注意，此时，方法上需要添加 @ResponseBody 注解，像下面这样： 12345@RequestMapping(\"/test2\")@ResponseBodypublic void test2(){ //你的代码} 2.2 重定向由于 SpringMVC 中的方法默认都具备 HttpServletResponse 参数，因此可以重拾 Servlet/Jsp 中的技能，可以实现重定向，像下面这样手动设置响应头： 123456@RequestMapping(\"/test1\")@ResponseBodypublic void test1(HttpServletResponse resp){ resp.setStatus(302); resp.addHeader(\"Location\",\"/aa/index\");} 也可以像下面这样直接调用重定向的方法： 12345@RequestMapping(\"/test1\")@ResponseBodypublic void test1(HttpServletResponse resp){ resp.sendRedirect(\"/aa/index\");} 当然，重定向无论你怎么写，都是 Servlet/Jsp 中的知识点，上面两种写法都相当于是重回远古时代。 2.3 服务端跳转既然可以重定向，当然也可以服务端跳转，像下面这样： 1234@GetMapping(\"/test5\")public void test5(HttpServletRequest req,HttpServletResponse resp) { req.getRequestDispatcher(\"/WEB-INF/jsp/index.jsp\").forward(req,resp);} 2.4 返回字符串当然也可以利用 HttpServletResponse 返回其他字符串数据，包括但不局限于 JSON，像下面这样： 123456789101112131415161718192021@RequestMapping(\"/test2\")@ResponseBodypublic void test2(HttpServletResponse resp) throws IOException { resp.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = resp.getWriter(); List&lt;Book&gt; books = new ArrayList&lt;&gt;(); Book b1 = new Book(); b1.setId(1); b1.setName(\"三国演义\"); b1.setAuthor(\"罗贯中\"); books.add(b1); Book b2 = new Book(); b2.setId(2); b2.setName(\"红楼梦\"); b2.setAuthor(\"曹雪芹\"); books.add(b2); String s = new Gson().toJson(books); out.write(s); out.flush(); out.close();} 这是返回值为 void 时候的情况，方法返回值为 void ，不一定就真的不返回了，可能还有其他的方式给前端数据。 3. String当 SpringMVC 方法的返回值为 String 类型时，也有几种不同情况。 3.1 逻辑视图名返回 String 最常见的是逻辑视图名，这种时候一般利用默认的参数 Model 来传递数据，像下面这样 ： 12345@RequestMapping(\"/hello\")public String aaa(Model model) { model.addAttribute(\"username\", \"张三\"); return \"hello\";} 此时返回的 hello 就是逻辑视图名，需要携带的数据放在 model 中。 3.2 重定向也可以重定向，事实上，如果在 SpringMVC 中有重定向的需求，一般采用这种方式： 1234@RequestMapping(\"/test4\")public String test4() { return \"redirect:/aa/index\";} 3.3 forward 转发也可以 forward 转发，事实上，如果在 SpringMVC 中有 forward 转发的需求，一般采用这种方式： 1234@RequestMapping(\"/test3\")public String test3() { return \"forward:/WEB-INF/jsp/order.jsp\";} 3.4 真的是 String当然，也有一种情况，就是你真的想返回一个 String ，此时，只要在方法上加上 @ResponseBody 注解即可，或者 Controller 上本身添加的是组合注解 @RestController，像下面这样： 1234567@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello provider!\"; }} 也可以像下面这样 ： 12345678@Controllerpublic class HelloController { @GetMapping(\"/hello\") @ResponseBody public String hello() { return \"hello provider!\"; }} 这是返回值为 String 的几种情况。 4. JSON返回 JSON 算是最最常见的了，现在前后端分离的趋势下，大部分后端只需要返回 JSON 即可，那么常见的 List 集合、Map，实体类等都可以返回，这些数据由 HttpMessageConverter 自动转为 JSON ，如果大家用了 Jackson 或者 Gson ，不需要额外配置就可以自动返回 JSON 了，因为框架帮我们提供了对应的 HttpMessageConverter ，如果大家使用了 Alibaba 的 Fastjson 的话，则需要自己手动提供一个相应的 HttpMessageConverter 的实例，方法的返回值像下面这样： 123456789101112131415161718192021222324@GetMapping(\"/user\")@ResponseBodypublic User getUser() { User user = new User(); List&lt;String&gt; favorites = new ArrayList&lt;&gt;(); favorites.add(\"足球\"); favorites.add(\"篮球\"); user.setFavorites(favorites); user.setUsername(\"zhagnsan\"); user.setPassword(\"123\"); return user;}@GetMapping(\"/users\")@ResponseBodypublic List&lt;User&gt; getALlUser() { List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { User e = new User(); e.setUsername(\"zhangsan:\" + i); e.setPassword(\"pwd:\" + i); users.add(e); } return users;} 总结好了，这是松哥为大伙总结的 SpringMVC 方法四种不同类型的返回值，难倒是不难！有问题欢迎大伙留言讨论。","link":"/post/c21e6afc.html"},{"title":"我来啦","text":"Hello 老铁们，写了几年博客之后，我终于建立起自己的站点了，这个 Hexo 使用起来还是挺方便的，半天时间就弄好了，以后我的文章将在我的公众号上首发，然后也会同步到这里，欢迎老铁们关注！","link":"/post/4a17b156.html"},{"title":"一个Java程序猿眼中的前后端分离以及Vue.js入门","text":"松哥的书里边，其实有涉及到 Vue，但是并没有详细说过，原因很简单，Vue 的资料都是中文的，把 Vue.js 官网的资料从头到尾浏览一遍该懂的基本就懂了，个人感觉这个是最好的 Vue.js 学习资料 ，因此在我的书里边就没有多说。但是最近总结小伙伴遇到的问题，感觉很多人对前后端分离开发还是两眼一抹黑，所以今天松哥想和大家聊一下前后端分离以及 Vue.js 的一点事，算是一个简单的入门科普吧。 前后端不分 后端模板：Jsp、FreeMarker、Velocity 前端模板：Thymeleaf 前后端不分，Jsp 是一个非常典型写法，Jsp 将 HTML 和 Java 代码结合在一起，刚开始的时候，确实提高了生产力，但是时间久了，大伙就发现 Jsp 存在的问题了，对于后端工程师来说，可能不太精通 css ，所以流程一般是这样前端设计页面–&gt;后端把页面改造成 Jsp –&gt; 后端发现问题 –&gt; 页面给前端 –&gt; 前端不会Jsp。这种方式效率低下。特别是在移动互联网兴起后，公司的业务，一般除了 PC 端，还有手机端、小程序等，通常，一套后台系统需要对应多个前端，此时就不可以继续使用前后端不分的开发方式了。 在前后端不分的开发方式中，一般来说，后端可能返回一个 ModelAndView ，渲染成 HTML 之后，浏览器当然可以展示，但是对于小程序、移动端来说，并不能很好的展示 HTML（实际上移动端也支持HTML，只不过运行效率低下）。这种时候，后端和前端数据交互，主流方案就是通过 JSON 来实现。 前后端分离前后端分离后，后端不再写页面，只提供 JSON 数据接口（XML数据格式现在用的比较少），前端可以移动端、小程序、也可以是 PC 端，前端负责 JSON 的展示，页面跳转等都是通过前端来实现的。前端后分离后，前端目前有三大主流框架： Vue 作者尤雨溪，Vue本身借鉴了 Angular，目前GitHubstar数最多，建议后端工程师使用这个，最大的原因是Vue上手容易，可以快速学会，对于后端工程师来说，能快速搭建页面解决问题即可，但是如果你是专业的前端工程师，我会推荐你三个都去学习 。就目前国内前端框架使用情况来说，Vue 算是使用最多的。而且目前来说，有大量 Vue 相关的周边产品，各种 UI 框架，开源项目，学习资料非常多。 React Facebook 的产品。是一个用于构建用户界面的 js 库，React 性能较好，代码逻辑简单。 Angular AngularJS 是一款由 Google 维护的开源 JavaScript 库，用来协助单一页面应用程序运行。它的目标是透过 MVC 模式（MVC）功能增强基于浏览器的应用，使开发和测试变得更加容易。 Vue简介Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 只关注视图层 MVVM 框架 大家在使用 jQuery 过程中，掺杂了大量的 DOM 操作，修改视图或者获取 value ，都需要 DOM 操作，MVVM 是一种视图和数据模型双向绑定的框架，即数据发生变化，视图会跟着变化，视图发生变化，数据模型也会跟着变化，开发者再也不需要操作 DOM 节点。 如下一个简单的九九乘法表让大家感受一下 MVVM ： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"num\"&gt; &lt;table border=\"1\"&gt; &lt;tr v-for=\"i in parseInt(num)\"&gt; &lt;td v-for=\"j in i\"&gt;{{j}}*{{i}}={{i*j}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue({ el: \"#app\", data: { num:9 } });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 用户修改输入框中的数据，引起变量的变化，进而实现九九乘法表的更新。 SPASPA（single page web application），单页面应用，是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。在单页应用中，所有必要的代码（ HTML、JavaScript 和 CSS ）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面。SPA 有一个缺点，因为 SPA 应用部署后只有1个页面，而且这个页面只是一堆 js 、css 引用，没有其他有效价值，因此，SPA 应用不易被搜索引擎收录，所以，一般来说，SPA 适合做大型企业后台管理系统。 Vue 使用方式大致上可以分为两大类： 直接将Vue在页面中引入，不做 SPA 应用 SPA应用 基本环境搭建首先需要安装两个东西： NodeJS npm 直接搜索下载 NodeJS 即可，安装成功之后，npm 也就有了。安装成功之后，可以 在 cmd 命令哈验证是否安装成功： NodeJS 安装成功之后，接下来安装 Vue的工具： 12345npm install -g vue-cli # 只需要第一次安装时执行vue init webpack my-project # 使用webpack模板创建一个vue项目cd my-project #进入到项目目录中npm install # 下载依赖（如果在项目创建的最后一步选择了自动执行npm install，则该步骤可以省略）npm run dev # 启动项目 启动成功后，浏览器输入 http://localhost:8080 就能看到如下页面： 执行 npm install 命令时，默认使用的是国外的下载源 ，可以通过如下代码配置为使用淘宝的镜像： 1npm config set registry https://registry.npm.taobao.org 修改完成后，就能有效提高下载的成功率。 Vue 项目结构介绍Vue 项目创建完成后，使用 Web Storm 打开项目，项目目录如下： build 文件夹，用来存放项目构建脚本 config 中存放项目的一些基本配置信息，最常用的就是端口转发 node_modules 这个目录存放的是项目的所有依赖，即 npm install 命令下载下来的文件 src 这个目录下存放项目的源码，即开发者写的代码放在这里 static 用来存放静态资源 index.html 则是项目的首页，入口页，也是整个项目唯一的HTML页面 package.json 中定义了项目的所有依赖，包括开发时依赖和发布时依赖 对于开发者来说，以后 99.99% 的工作都是在 src 中完成的，src 中的文件目录如下： assets 目录用来存放资产文件 components 目录用来存放组件（一些可复用，非独立的页面），当然开发者也可以在 components 中直接创建完整页面。 推荐在 components 中存放组件，另外单独新建一个 page 文件夹，专门用来放完整页面。 router 目录中，存放了路由的js文件 App.vue 是一个Vue组件，也是项目的第一个Vue组件 main.js相当于Java中的main方法，是整个项目的入口js main.js 内容如下： 1234567891011import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false/* eslint-disable no-new */new Vue({ el: '#app', router, components: { App }, template: '&lt;App/&gt;'}) 在main.js 中，首先导入 Vue 对象 导入 App.vue ，并且命名为 App 导入router，注意，由于router目录下路由默认文件名为 index.js ，因此可以省略 所有东西都导入成功后，创建一个Vue对象，设置要被Vue处理的节点是 ‘#app’，’#app’ 指提前在index.html 文件中定义的一个div 将 router 设置到 vue 对象中，这里是一个简化的写法，完整的写法是 router:router，如果 key/value 一模一样，则可以简写。 声明一个组件 App，App 这个组件在一开始已经导入到项目中了，但是直接导入的组件无法直接使用，必须要声明。 template 中定义了页面模板，即将 App 组件中的内容渲染到 ‘#app’ 这个div 中。 因此，可以猜测，项目启动成功后，看到的页面效果定义在 App.vue 中 123456789101112131415161718192021&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'App'}&lt;/script&gt;&lt;style&gt;#app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; App.vue 是一个vue组件，这个组件中包含三部分内容：1.页面模板（template）；2.页面脚本（script）；3.页面样式（style） 页面模板中，定义了页面的 HTML 元素，这里定义了两个，一个是一张图片，另一个则是一个 router-view 页面脚本主要用来实现当前页面数据初始化、事件处理等等操作 页面样式就是针对 template 中 HTML 元素的页面美化操作 需要额外解释的是，router-view，这个指展示路由页面的位置，可以简单理解为一个占位符，这个占位符展示的内容将根据当前具体的 URL 地址来定。具体展示的内容，要参考路由表，即 router/index.js 文件，该文件如下： 12345678910111213import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'Vue.use(Router)export default new Router({ routes: [ { path: '/', name: 'HelloWorld', component: HelloWorld } ]}) 这个文件中，首先导入了Vue对象、Router对象以及 HelloWorld 组件， 创建一个Router对象，并定义路由表 这里定义的路由表，path为 / ，对应的组件为 HelloWorld，即浏览器地址为 / 时，在router-view位置显示 HelloWorld 组件 WebStorm 中启动Vue也可以直接在 webstorm 中配置vue并启动，点击右上角进行配置： 然后配置一下脚本 ： 配置完成后，点击右上角启动按钮，就可以启动一个 Vue 项目，如下： 项目编译这么大一个前端项目，肯定没法直接发布运行，当开发者完成项目开发后，将 cmd 命令行定位到当前项目目录，然后执行如下命令对项目进行打包： 1npm run build 打包成功后，当前项目目录下会生成一个 dist 文件夹，这个文件夹中有两个文件，分别是 index.html 和 static ，index.html 页面就是我们 SPA 项目中唯一的 HTML 页面了，static 中则保存了编译后的 js、css等文件，项目发布时，可以使用 nginx 独立部署 dist 中的静态文件，也可以将静态文件拷贝到 Spring Boot 项目的 static 目录下，然后对 Spring Boot 项目进行编译打包发布。 总结因为松哥的读者以后端程序猿居多，也有少量前端程序猿，因此本文松哥想从一个后端程序猿的角度来带大家理解一下前后端分离以及 Vue 的一些基本用法，也欢迎专业的前端工程师出来拍砖。","link":"/post/8a0dbbbd.html"},{"title":"一文读懂 Spring Data Jpa！","text":"有很多读者留言希望松哥能好好聊聊 Spring Data Jpa!其实这个话题松哥以前零零散散的介绍过，在我的书里也有介绍过，但是在公众号中还没和大伙聊过，因此本文就和大家来仔细聊聊 Spring Data 和 Jpa! 故事的主角Jpa1. JPA是什么 Java Persistence API：用于对象持久化的 API Java EE 5.0 平台标准的 ORM 规范，使得应用程序以统一的方式访问持久层 2. JPA和Hibernate的关系 JPA 是 Hibernate 的一个抽象（就像JDBC和JDBC驱动的关系）； JPA 是规范：JPA 本质上就是一种 ORM 规范，不是ORM 框架，这是因为 JPA 并未提供 ORM 实现，它只是制订了一些规范，提供了一些编程的 API 接口，但具体实现则由 ORM 厂商提供实现； Hibernate 是实现：Hibernate 除了作为 ORM 框架之外，它也是一种 JPA 实现 从功能上来说， JPA 是 Hibernate 功能的一个子集 3. JPA的供应商JPA 的目标之一是制定一个可以由很多供应商实现的 API，Hibernate 3.2+、TopLink 10.1+ 以及 OpenJPA 都提供了 JPA 的实现，Jpa 供应商有很多，常见的有如下四种： HibernateJPA 的始作俑者就是 Hibernate 的作者，Hibernate 从 3.2 开始兼容 JPA。 OpenJPAOpenJPA 是 Apache 组织提供的开源项目。 TopLinkTopLink 以前需要收费，如今开源了。 EclipseLink 4. JPA的优势 标准化: 提供相同的 API，这保证了基于JPA 开发的企业应用能够经过少量的修改就能够在不同的 JPA 框架下运行。 简单易用，集成方便: JPA 的主要目标之一就是提供更加简单的编程模型，在 JPA 框架下创建实体和创建 Java 类一样简单，只需要使用 javax.persistence.Entity 进行注解；JPA 的框架和接口也都非常简单。 可媲美JDBC的查询能力: JPA的查询语言是面向对象的，JPA定义了独特的JPQL，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。 支持面向对象的高级特性: JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，最大限度的使用面向对象的模型 5. JPA包含的技术 ORM 映射元数据：JPA 支持 XML 和 JDK 5.0 注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。 JPA 的 API：用来操作实体对象，执行CRUD操作，框架在后台完成所有的事情，开发者从繁琐的 JDBC 和 SQL 代码中解脱出来。 查询语言（JPQL）：这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序和具体的 SQL 紧密耦合。 Spring DataSpring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点： SpringData 项目支持 NoSQL 存储：MongoDB （文档数据库）Neo4j（图形数据库）Redis（键/值存储）Hbase（列族数据库） SpringData 项目所支持的关系数据存储技术：JDBCJPA Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！ 框架怎么可能代替开发者实现业务逻辑呢？比如：当有一个 UserDao.findUserById() 这样一个方法声明，大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象。Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。 主角的故事Jpa 的故事为了让大伙彻底把这两个东西学会，这里我就先来介绍单纯的Jpa使用，然后我们再结合 Spring Data 来看 Jpa如何使用。 整体步骤如下： 1.使用 IntelliJ IDEA 创建项目，创建时选择 JavaEE Persistence ，如下： 2.创建成功后，添加依赖jar，由于 Jpa 只是一个规范，因此我们说用Jpa实际上必然是用Jpa的某一种实现，那么是哪一种实现呢？当然就是Hibernate了，所以添加的jar，实际上来自 Hibernate，如下： 3.添加实体类 接下来在项目中添加实体类，如下： 12345678910111213@Entity(name = \"t_book\")public class Book { private Long id; private String name; private String author; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) public Long getId() { return id; } // 省略其他getter/setter} 首先@Entity注解表示这是一个实体类，那么在项目启动时会自动针对该类生成一张表，默认的表名为类名，@Entity注解的name属性表示自定义生成的表名。@Id注解表示这个字段是一个id，@GeneratedValue注解表示主键的自增长策略，对于类中的其他属性，默认都会根据属性名在表中生成相应的字段，字段名和属性名相同，如果开发者想要对字段进行定制，可以使用@Column注解，去配置字段的名称，长度，是否为空等等。 4.创建 persistence.xml 文件 JPA 规范要求在类路径的 META-INF 目录下放置persistence.xml，文件的名称是固定的 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence xmlns=\"http://java.sun.com/xml/ns/persistence\" version=\"2.0\"&gt; &lt;persistence-unit name=\"NewPersistenceUnit\" transaction-type=\"RESOURCE_LOCAL\"&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;class&gt;org.sang.Book&lt;/class&gt; &lt;properties&gt; &lt;property name=\"hibernate.connection.url\" value=\"jdbc:mysql:///jpa01?useUnicode=true&amp;amp;characterEncoding=UTF-8\"/&gt; &lt;property name=\"hibernate.connection.driver_class\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"hibernate.connection.username\" value=\"root\"/&gt; &lt;property name=\"hibernate.connection.password\" value=\"123\"/&gt; &lt;property name=\"hibernate.archive.autodetection\" value=\"class\"/&gt; &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt; &lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt; &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"update\"/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 注意： persistence-unit 的name 属性用于定义持久化单元的名字, 必填。 transaction-type：指定 JPA 的事务处理策略。RESOURCE_LOCAL：默认值，数据库级别的事务，只能针对一种数据库，不支持分布式事务。如果需要支持分布式事务，使用JTA：transaction-type=”JTA” class节点表示显式的列出实体类 properties中的配置分为两部分：数据库连接信息以及Hibernate信息 执行持久化操作 1234567891011EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(\"NewPersistenceUnit\");EntityManager manager = entityManagerFactory.createEntityManager();EntityTransaction transaction = manager.getTransaction();transaction.begin();Book book = new Book();book.setAuthor(\"罗贯中\");book.setName(\"三国演义\");manager.persist(book);transaction.commit();manager.close();entityManagerFactory.close(); 这里首先根据配置文件创建出来一个 EntityManagerFactory ，然后再根据 EntityManagerFactory 的实例创建出来一个 EntityManager ，然后再开启事务，调用 EntityManager 中的 persist 方法执行一次持久化操作，最后提交事务，执行完这些操作后，数据库中旧多出来一个 t_book 表，并且表中有一条数据。 关于 JPQL JPQL语言，即 Java Persistence Query Language 的简称。JPQL 是一种和 SQL 非常类似的中间性和对象化查询语言，它最终会被编译成针对不同底层数据库的 SQL 查询，从而屏蔽不同数据库的差异。JPQL语言的语句可以是 select 语句、update 语句或delete语句，它们都通过 Query 接口封装执行。 Query接口封装了执行数据库查询的相关方法。调用 EntityManager 的 createQuery、create NamedQuery 及 createNativeQuery 方法可以获得查询对象，进而可调用 Query 接口的相关方法来执行查询操作。 Query接口的主要方法如下： int executeUpdate(); | 用于执行update或delete语句。 List getResultList(); | 用于执行select语句并返回结果集实体列表。 Object getSingleResult(); | 用于执行只返回单个结果实体的select语句。 Query setFirstResult(int startPosition); | 用于设置从哪个实体记录开始返回查询结果。 Query setMaxResults(int maxResult); | 用于设置返回结果实体的最大数。与setFirstResult结合使用可实现分页查询。 Query setFlushMode(FlushModeType flushMode); | 设置查询对象的Flush模式。参数可以取2个枚举值：FlushModeType.AUTO 为自动更新数据库记录，FlushMode Type.COMMIT 为直到提交事务时才更新数据库记录。 setHint(String hintName, Object value); | 设置与查询对象相关的特定供应商参数或提示信息。参数名及其取值需要参考特定 JPA 实现库提供商的文档。如果第二个参数无效将抛出IllegalArgumentException异常。 setParameter(int position, Object value); | 为查询语句的指定位置参数赋值。Position 指定参数序号，value 为赋给参数的值。 setParameter(int position, Date d, TemporalType type); | 为查询语句的指定位置参数赋 Date 值。Position 指定参数序号，value 为赋给参数的值，temporalType 取 TemporalType 的枚举常量，包括 DATE、TIME 及 TIMESTAMP 三个，，用于将 Java 的 Date 型值临时转换为数据库支持的日期时间类型（java.sql.Date、java.sql.Time及java.sql.Timestamp）。 setParameter(int position, Calendar c, TemporalType type); | 为查询语句的指定位置参数赋 Calenda r值。position 指定参数序号，value 为赋给参数的值，temporalType 的含义及取舍同前。 setParameter(String name, Object value); | 为查询语句的指定名称参数赋值。 setParameter(String name, Date d, TemporalType type); | 为查询语句的指定名称参数赋 Date 值,用法同前。 setParameter(String name, Calendar c, TemporalType type); | 为查询语句的指定名称参数设置Calendar值。name为参数名，其它同前。该方法调用时如果参数位置或参数名不正确，或者所赋的参数值类型不匹配，将抛出 IllegalArgumentException 异常。 JPQL 举例和在 SQL 中一样，JPQL 中的 select 语句用于执行查询。其语法可表示为：select_clause form_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause] 其中： from 子句是查询语句的必选子句。 select 用来指定查询返回的结果实体或实体的某些属性。 from 子句声明查询源实体类，并指定标识符变量（相当于SQL表的别名）。 如果不希望返回重复实体，可使用关键字 distinct 修饰。select、from 都是 JPQL 的关键字，通常全大写或全小写，建议不要大小写混用。 在 JPQL 中，查询所有实体的 JPQL 查询语句很简单，如下：select o from Order o 或 select o from Order as o这里关键字 as 可以省去，标识符变量的命名规范与 Java 标识符相同，且区分大小写,调用 EntityManager 的 createQuery() 方法可创建查询对象，接着调用 Query 接口的 getResultList() 方法就可获得查询结果集，如下： 123456Query query = entityManager.createQuery( \"select o from Order o\"); List orders = query.getResultList();Iterator iterator = orders.iterator();while(iterator.hasNext() ) { // 处理Order} 其他方法的与此类似，这里不再赘述。 Spring Data 的故事在 Spring Boot 中，Spring Data Jpa 官方封装了太多东西了，导致很多人用的时候不知道底层到底是怎么配置的，本文就和大伙来看看在手工的Spring环境下，Spring Data Jpa要怎么配置，配置完成后，用法和 Spring Boot 中的用法是一致的。 基本环境搭建首先创建一个普通的Maven工程，并添加如下依赖： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.2.12.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;5.2.12.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.11.3.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这里除了 Jpa 的依赖之外，就是Spring Data Jpa 的依赖了。 接下来创建一个 User 实体类，创建方式参考 Jpa中实体类的创建方式，这里不再赘述。 接下来在resources目录下创建一个applicationContext.xml文件，并配置Spring和Jpa，如下： 123456789101112131415161718192021222324252627282930&lt;context:property-placeholder location=\"classpath:db.properties\"/&gt;&lt;context:component-scan base-package=\"org.sang\"/&gt;&lt;bean class=\"com.alibaba.druid.pool.DruidDataSource\" id=\"dataSource\"&gt; &lt;property name=\"driverClassName\" value=\"${db.driver}\"/&gt; &lt;property name=\"url\" value=\"${db.url}\"/&gt; &lt;property name=\"username\" value=\"${db.username}\"/&gt; &lt;property name=\"password\" value=\"${db.password}\"/&gt;&lt;/bean&gt;&lt;bean class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\" id=\"entityManagerFactory\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"jpaVendorAdapter\"&gt; &lt;bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\"/&gt; &lt;/property&gt; &lt;property name=\"packagesToScan\" value=\"org.sang.model\"/&gt; &lt;property name=\"jpaProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.format_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/prop&gt; &lt;prop key=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQL57Dialect&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=\"org.springframework.orm.jpa.JpaTransactionManager\" id=\"transactionManager\"&gt; &lt;property name=\"entityManagerFactory\" ref=\"entityManagerFactory\"/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt;&lt;!-- 配置jpa --&gt;&lt;jpa:repositories base-package=\"org.sang.dao\" entity-manager-factory-ref=\"entityManagerFactory\"/&gt; 这里和 Jpa 相关的配置主要是三个，一个是entityManagerFactory，一个是Jpa的事务，还有一个是配置dao的位置，配置完成后，就可以在 org.sang.dao 包下创建相应的 Repository 了，如下： 123public interface UserDao extends Repository&lt;User, Long&gt; { User getUserById(Long id);} getUserById表示根据id去查询User对象，只要我们的方法名称符合类似的规范，就不需要写SQL，具体的规范一会来说。好了，接下来，创建 Service 和 Controller 来调用这个方法，如下： 12345678910111213141516@Service@Transactionalpublic class UserService { @Resource UserDao userDao; public User getUserById(Long id) { return userDao.getUserById(id); }}public void test1() { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService userService = ctx.getBean(UserService.class); User user = userService.getUserById(1L); System.out.println(user);} 这样，就可以查询到id为1的用户了。 Repository上文我们自定义的 UserDao 实现了 Repository 接口，这个 Repository 接口是什么来头呢？ 首先来看 Repository 的一个继承关系图： 可以看到，实现类不少。那么到底如何理解 Repository 呢？ Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法 public interface Repository&lt;T, ID extends Serializable&gt; { } 若我们定义的接口继承了 Repository, 则该接口会被 IOC 容器识别为一个 Repository Bean，进而纳入到 IOC 容器中，进而可以在该接口中定义满足一定规范的方法。 Spring Data可以让我们只定义接口，只要遵循 Spring Data 的规范，就无需写实现类。 与继承 Repository 等价的一种方式，就是在持久层接口上使用 @RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。像下面这样： 123456@RepositoryDefinition(domainClass = User.class, idClass = Long.class)public interface UserDao{ User findById(Long id); List&lt;User&gt; findAll();} 基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能，它的几个常用的实现类如下： CrudRepository： 继承 Repository，实现了一组 CRUD 相关的方法 PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法 JpaRepository： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法 自定义的 XxxxRepository 需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。 JpaSpecificationExecutor： 不属于Repository体系，实现一组 JPA Criteria 查询相关的方法 方法定义规范1.简单条件查询 按照 Spring Data 的规范，查询方法以 find | read | get 开头 涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写 例如：定义一个 Entity 实体类： 1234class User｛ private String firstName; private String lastName; ｝ 使用And条件连接时，条件的属性名称与个数要与参数的位置与个数一一对应，如下： 1findByLastNameAndFirstName(String lastName,String firstName); 支持属性的级联查询. 若当前类有符合条件的属性, 则优先使用, 而不使用级联属性. 若需要使用级联属性, 则属性之间使用 _ 进行连接. 查询举例：1.按照id查询 12User getUserById(Long id);User getById(Long id); 2.查询所有年龄小于90岁的人 1List&lt;User&gt; findByAgeLessThan(Long age); 3.查询所有姓赵的人 1List&lt;User&gt; findByUsernameStartingWith(String u); 4.查询所有姓赵的、并且id大于50的人 1List&lt;User&gt; findByUsernameStartingWithAndIdGreaterThan(String name, Long id); 5.查询所有姓名中包含”上”字的人 1List&lt;User&gt; findByUsernameContaining(String name); 6.查询所有姓赵的或者年龄大于90岁的 1List&lt;User&gt; findByUsernameStartingWithOrAgeGreaterThan(String name, Long age); 7.查询所有角色为1的用户 1List&lt;User&gt; findByRole_Id(Long id); 2.支持的关键字支持的查询关键字如下图： 3.查询方法流程解析为什么写上方法名，JPA就知道你想干嘛了呢？假如创建如下的查询：findByUserDepUuid()，框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，假设查询实体为Doc： 先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步； 从右往左截取第一个大写字母开头的字符串(此处为Uuid)，然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为查询实体的一个属性； 接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 “ Doc.user.depUuid” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 “Doc.user.dep.uuid” 的值进行查询。 可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图，比如 “findByUser_DepUuid()” 或者 “findByUserDep_uuid()” 还有一些特殊的参数：例如分页或排序的参数： 12Page&lt;UserModel&gt; findByName(String name, Pageable pageable); List&lt;UserModel&gt; findByName(String name, Sort sort); @Query注解有的时候，这里提供的查询关键字并不能满足我们的查询需求，这个时候就可以使用 @Query 关键字，来自定义查询 SQL，例如查询Id最大的User： 12@Query(\"select u from t_user u where id=(select max(id) from t_user)\")User getMaxIdUser(); 如果查询有参数的话，参数有两种不同的传递方式: 1.利用下标索引传参，索引参数如下所示，索引值从1开始，查询中 ”?X” 个数需要与方法定义的参数个数相一致，并且顺序也要一致： 12@Query(\"select u from t_user u where id&gt;?1 and username like ?2\")List&lt;User&gt; selectUserByParam(Long id, String name); 2.命名参数（推荐）：这种方式可以定义好参数名，赋值时采用@Param(“参数名”)，而不用管顺序： 12@Query(\"select u from t_user u where id&gt;:id and username like :name\")List&lt;User&gt; selectUserByParam2(@Param(\"name\") String name, @Param(\"id\") Long id); 查询时候，也可以是使用原生的SQL查询，如下： 12@Query(value = \"select * from t_user\",nativeQuery = true)List&lt;User&gt; selectAll(); @Modifying注解涉及到数据修改操作，可以使用 @Modifying 注解，@Query 与 @Modifying 这两个 annotation一起声明，可定义个性化更新操作，例如涉及某些字段更新时最为常用，示例如下： 123@Modifying@Query(\"update t_user set age=:age where id&gt;:id\")int updateUserById(@Param(\"age\") Long age, @Param(\"id\") Long id); 注意： 可以通过自定义的 JPQL 完成 UPDATE 和 DELETE 操作. 注意: JPQL 不支持使用 INSERT 方法的返回值应该是 int，表示更新语句所影响的行数 在调用的地方必须加事务，没有事务不能正常执行 默认情况下, Spring Data 的每个方法上有事务, 但都是一个只读事务. 他们不能完成修改操作 说到这里，再来顺便说说Spring Data 中的事务问题： Spring Data 提供了默认的事务处理方式，即所有的查询均声明为只读事务。 对于自定义的方法，如需改变 Spring Data 提供的事务默认方式，可以在方法上添加 @Transactional 注解。 进行多个 Repository 操作时，也应该使它们在同一个事务中处理，按照分层架构的思想，这部分属于业务逻辑层，因此，需要在Service 层实现对多个 Repository 的调用，并在相应的方法上声明事务。 好了，关于Spring Data Jpa 本文就先说这么多。","link":"/post/9cb710fa.html"},{"title":"你真的理解 Spring Boot 项目中的 parent 吗？","text":"前面和大伙聊了 Spring Boot 项目的三种创建方式，这三种创建方式，无论是哪一种，创建成功后，pom.xml 坐标文件中都有如下一段引用： 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt; 对于这个 parent 的作用，你是否完全理解？有小伙伴说，不就是依赖的版本号定义在 parent 里边吗？是的，没错，但是 parent 的作用可不仅仅这么简单哦！本文松哥就来和大伙聊一聊这个 parent 到底有什么作用。 基本功能当我们创建一个 Spring Boot 工程时，可以继承自一个 spring-boot-starter-parent ，也可以不继承自它，我们先来看第一种情况。先来看 parent 的基本功能有哪些？ 定义了 Java 编译版本为 1.8 。 使用 UTF-8 格式编码。 继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。 执行打包操作的配置。 自动化的资源过滤。 自动化的插件配置。 针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。 请注意，由于application.properties和application.yml文件接受Spring样式占位符 $ {...} ，因此 Maven 过滤更改为使用 @ .. @ 占位符，当然开发者可以通过设置名为 resource.delimiter 的Maven 属性来覆盖 @ .. @ 占位符。 源码分析当我们创建一个 Spring Boot 项目后，我们可以在本地 Maven 仓库中看到看到这个具体的 parent 文件，以 2.1.4 这个版本为例，松哥 这里的路径是 C:\\Users\\sang\\.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-parent\\2.1.4.RELEASE\\spring-boot-starter-parent-2.1.4.RELEASE.pom ,打开这个文件，快速阅读文件源码，基本上就可以证实我们前面说的功能，如下图： 我们可以看到，它继承自 spring-boot-dependencies ，这里保存了基本的依赖信息，另外我们也可以看到项目的编码格式，JDK 的版本等信息，当然也有我们前面提到的数据过滤信息。最后，我们再根据它的 parent 中指定的 spring-boot-dependencies 位置，来看看 spring-boot-dependencies 中的定义： 在这里，我们看到了版本的定义以及 dependencyManagement 节点，明白了为啥 Spring Boot 项目中部分依赖不需要写版本号了。 不用 parent但是并非所有的公司都需要这个 parent ，有的时候，公司里边会有自己定义的 parent ，我们的 Spring Boot 项目要继承自公司内部的 parent ，这个时候该怎么办呢？ 一个简单的办法就是我们自行定义 dependencyManagement 节点，然后在里边定义好版本号，再接下来在引用依赖时也就不用写版本号了，像下面这样： 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 这样写之后，依赖的版本号问题虽然解决了，但是关于打包的插件、编译的 JDK 版本、文件的编码格式等等这些配置，在没有 parent 的时候，这些统统要自己去配置。 总结好了，一篇简单的文章，向大伙展示一下 Spring Boot 项目中 parent 的作用，有问题欢迎留言讨论。","link":"/post/d79cd6ac.html"},{"title":"创建一个 Spring Boot 项目，你会几种方法？","text":"我最早是 2016 年底开始写 Spring Boot 相关的博客，当时使用的版本还是 1.4.x ，文章发表在 CSDN 上，阅读量最大的一篇有 42W+，如下图： 2017 年由于种种原因，就没有再继续更新 Spring Boot 相关的博客了，2018年又去写书了，也没更新，现在 Spring Boot 最新稳定版是 2.1.4 ，松哥想针对此写一个系列教程，专门讲 Spring Boot2 中相关的知识点。这个系列，就从本篇开始吧。 Spring Boot 介绍我们刚开始学习 JavaWeb 的时候，使用 Servlet/JSP 做开发，一个接口搞一个 Servlet ，很头大，后来我们通过隐藏域或者反射等方式，可以减少 Servlet 的创建，但是依然不方便，再后来，我们引入 Struts2/SpringMVC 这一类的框架，来简化我们的开发 ，和 Servlet/JSP 相比，引入框架之后，生产力确实提高了不少，但是用久了，又发现了新的问题，即配置繁琐易出错，要做一个新项目，先搭建环境，环境搭建来搭建去，就是那几行配置，不同的项目，可能就是包不同，其他大部分的配置都是一样的，Java 总是被人诟病配置繁琐代码量巨大，这就是其中一个表现。那么怎么办？Spring Boot 应运而生，Spring Boot 主要提供了如下功能： 为所有基于 Spring 的 Java 开发提供方便快捷的入门体验。 开箱即用，有自己自定义的配置就是用自己的，没有就使用官方提供的默认的。 提供了一系列通用的非功能性的功能，例如嵌入式服务器、安全管理、健康检测等。 绝对没有代码生成，也不需要XML配置。 Spring Boot 的出现让 Java 开发又回归简单，因为确确实实解决了开发中的痛点，因此这个技术得到了非常广泛的使用，松哥很多朋友出去面试 Java 工程师，从2017年年初开始，Spring Boot基本就是必问，现在流行的 Spring Cloud 微服务也是基于 Spring Boot，因此，所有的 Java 工程师都有必要掌握好 Spring Boot。 系统要求截至本文写作（2019.04.11），Spring Boot 目前最新版本是 2.1.4，要求至少 JDK8，集成的 Spring 版本是 5.1.6 ，构建工具版本要求如下： Build Tool Version Maven 3.3+ Gradle 4.4+ 内置的容器版本分别如下： Name Version Tomcat 9.0 4.0 Jetty 9.4 3.1 Undertow 2.0 4.0 三种创建方式初学者看到 Spring Boot 工程创建成功后有那么多文件就会有点懵圈，其实 Spring Boot 工程本质上就是一个 Maven 工程，从这个角度出发，松哥在这里向大家介绍三种项目创建方式。 在线创建这是官方提供的一个创建方式，实际上，如果我们使用开发工具去创建 Spring Boot 项目的话（即第二种方案），也是从这个网站上创建的，只不过这个过程开发工具帮助我们完成了，我们只需要在开发工具中进行简单的配置即可。 首先打开 https://start.spring.io 这个网站，如下： 这里要配置的按顺序分别如下： 项目构建工具是 Maven 还是 Gradle ？松哥见到有人用 Gradle 做 Java 后端项目，但是整体感觉 Gradle 在 Java 后端中使用的还是比较少，Gradle 在 Android 中使用较多，Java 后端，目前来看还是 Maven 为主，因此这里选择第一项。 开发语言，这个当然是选择 Java 了。 Spring Boot 版本，可以看到，目前最新的稳定版是 2.1.4 ，这里我们就是用最新稳定版。 既然是 Maven 工程，当然要有项目坐标，项目描述等信息了，另外这里还让输入了包名，因为创建成功后会自动创建启动类。 Packing 表示项目要打包成 jar 包还是 war 包，Spring Boot 的一大优势就是内嵌了 Servlet 容器，打成 jar 包后可以直接运行，所以这里建议打包成 jar 包，当然，开发者根据实际情况也可以选择 war 包。 然后选选择构建的 JDK 版本。 最后是选择所需要的依赖，输入关键字如 web ，会有相关的提示，这里我就先加入 web 依赖。 所有的事情全部完成后，点击最下面的 Generate Project 按钮，或者点击 Alt+Enter 按键，此时会自动下载项目，将下载下来的项目解压，然后用 IntelliJ IDEA 或者 Eclipse 打开即可进行开发。 使用开发工具创建有人觉得上面的步骤太过于繁琐，那么也可以使用 IDE 来创建，松哥这里以 IntelliJ IDEA 和 STS 为例，需要注意的是，IntelliJ IDEA 只有 ultimate 版才有直接创建 Spring Boot 项目的功能，社区版是没有此项功能的。 IntelliJ IDEA首先在创建项目时选择 Spring Initializr，如下图： 然后点击 Next ，填入 Maven 项目的基本信息，如下： 再接下来选择需要添加的依赖，如下图： 勾选完成后，点击 Next 完成项目的创建。 STS这里我再介绍下 Eclipse 派系的 STS 给大家参考， STS 创建 Spring Boot 项目，实际上也是从上一小节的那个网站上来的，步骤如下： 首先右键单击，选择 New -&gt; Spring Starter Project ，如下图： 然后在打开的页面中填入项目的相关信息，如下图： 这里的信息和前面提到的都一样，不再赘述。最后一路点击 Next ，完成项目的创建。 Maven 创建上面提到的几种方式，实际上都借助了 https://start.spring.io/ 这个网站，松哥记得在 2017 年的时候，这个网站还不是很稳定，经常发生项目创建失败的情况，从2018年开始，项目创建失败就很少遇到了，不过有一些读者偶尔还是会遇到这个问题，他们会在微信上问松哥这个问题腰怎么处理？我一般给的建议就是直接使用 Maven 来创建项目。步骤如下： 首先创建一个普通的 Maven 项目，以 IntelliJ IDEA 为例，创建步骤如下： 注意这里不用选择项目骨架（如果大伙是做练习的话，也可以去尝试选择一下，这里大概有十来个 Spring Boot 相关的项目骨架），直接点击 Next ，下一步中填入一个 Maven 项目的基本信息，如下图： 然后点击 Next 完成项目的创建。 创建完成后，在 pom.xml 文件中，添加如下依赖： 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加成功后，再在 java 目录下创建包，包中创建一个名为 App 的启动类，如下： 1234567891011@EnableAutoConfiguration@RestControllerpublic class App { public static void main(String[] args) { SpringApplication.run(App.class, args); } @GetMapping(\"/hello\") public String hello() { return \"hello\"; }} @EnableAutoConfiguration 注解表示开启自动化配置。 然后执行这里的 main 方法就可以启动一个 Spring Boot 工程了。 项目结构使用工具创建出来的项目结构大致如下图： 对于我们来说，src 是最熟悉的， Java 代码和配置文件写在这里，test 目录用来做测试，pom.xml 是 Maven 的坐标文件，就这几个。 总结本文主要向大家介绍了三种创建 Spring Boot 工程的方式，大家有更6的方法欢迎来讨论。","link":"/post/17ecf81a.html"},{"title":"干货|一个案例学会Spring Security 中使用 JWT","text":"在前后端分离的项目中，登录策略也有不少，不过 JWT 算是目前比较流行的一种解决方案了，本文就和大家来分享一下如何将 Spring Security 和 JWT 结合在一起使用，进而实现前后端分离时的登录解决方案。 1 无状态登录1.1 什么是有状态？有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如Tomcat中的Session。例如登录：用户登录后，我们把用户的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session，然后下次请求，用户携带cookie值来（这一步有浏览器自动完成），我们就能识别到对应session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下： 服务端保存大量数据，增加服务端压力 服务端保存用户状态，不支持集群化部署 1.2 什么是无状态微服务集群中的每个服务，对外提供的都使用RESTful风格的接口。而RESTful风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 那么这种无状态性有哪些好处呢？ 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署） 减小服务端存储压力 1.3.如何实现无状态无状态登录的流程： 首先客户端发送账户名/密码到服务端进行认证 认证通过后，服务端将用户信息加密并且编码成一个token，返回给客户端 以后客户端每次发送请求，都需要携带认证的token 服务端对客户端发送来的token进行解密，判断是否有效，并且获取用户登录信息 1.4 JWT1.4.1 简介JWT，全称是Json Web Token， 是一种JSON风格的轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权： JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的Java 实现是GitHub 上的开源项目 jjwt，地址如下：https://github.com/jwtk/jjwt 1.4.2 JWT数据格式JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 加密算法，自定义 我们会对头部进行Base64Url编码（可解码），得到第一部分数据。 Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息： iss (issuer)：表示签发人 exp (expiration time)：表示token过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 这部分也会采用Base64Url编码，得到第二部分数据。 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过Header中配置的加密算法生成。用于验证整个数据完整和可靠性。 生成的数据格式如下图： 注意，这里的数据通过 . 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。 1.4.3 JWT交互流程流程图： 步骤翻译： 应用程序或客户端向授权服务器请求授权 获取到授权后，授权服务器会向应用程序返回访问令牌 应用程序使用访问令牌来访问受保护资源（如API） 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了RESTful的无状态规范。 1.5 JWT 存在的问题说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下： 续签问题，这是被很多人诟病的问题之一，传统的cookie+session的方案天然的支持续签，但是jwt由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入redis，虽然可以解决问题，但是jwt也变得不伦不类了。 注销问题，由于服务端不再保存用户信息，所以一般可以通过修改secret来实现注销，服务端secret修改后，已经颁发的未过期的token就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。 密码重置，密码重置后，原本的token依然可以访问系统，这时候也需要强制修改secret。 基于第2点和第3点，一般建议不同用户取不同secret。 2 实战说了这么久，接下来我们就来看看这个东西到底要怎么用？ 2.1 环境搭建首先我们来创建一个Spring Boot项目，创建时需要添加Spring Security依赖，创建完成后，添加 jjwt 依赖，完整的pom.xml文件如下： 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; 然后在项目中创建一个简单的 User 对象实现 UserDetails 接口，如下： 12345678910111213141516171819202122232425public class User implements UserDetails { private String username; private String password; private List&lt;GrantedAuthority&gt; authorities; public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; } //省略getter/setter} 这个就是我们的用户对象，先放着备用，再创建一个HelloController，内容如下：1234567891011@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello jwt !\"; } @GetMapping(\"/admin\") public String admin() { return \"hello admin !\"; }} HelloController 很简单，这里有两个接口，设计是 /hello 接口可以被具有 user 角色的用户访问，而 /admin 接口则可以被具有 admin 角色的用户访问。 2.2 JWT 过滤器配置接下来提供两个和 JWT 相关的过滤器配置： 一个是用户登录的过滤器，在用户的登录的过滤器中校验用户是否登录成功，如果登录成功，则生成一个token返回给客户端，登录失败则给前端一个登录失败的提示。 第二个过滤器则是当其他请求发送来，校验token的过滤器，如果校验成功，就让请求继续执行。 这两个过滤器，我们分别来看，先看第一个： 1234567891011121314151617181920212223242526272829303132333435363738public class JwtLoginFilter extends AbstractAuthenticationProcessingFilter { protected JwtLoginFilter(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager) { super(new AntPathRequestMatcher(defaultFilterProcessesUrl)); setAuthenticationManager(authenticationManager); } @Override public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse resp) throws AuthenticationException, IOException, ServletException { User user = new ObjectMapper().readValue(req.getInputStream(), User.class); return getAuthenticationManager().authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword())); } @Override protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse resp, FilterChain chain, Authentication authResult) throws IOException, ServletException { Collection&lt;? extends GrantedAuthority&gt; authorities = authResult.getAuthorities(); StringBuffer as = new StringBuffer(); for (GrantedAuthority authority : authorities) { as.append(authority.getAuthority()) .append(\",\"); } String jwt = Jwts.builder() .claim(\"authorities\", as)//配置用户角色 .setSubject(authResult.getName()) .setExpiration(new Date(System.currentTimeMillis() + 10 * 60 * 1000)) .signWith(SignatureAlgorithm.HS512,\"sang@123\") .compact(); resp.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(jwt)); out.flush(); out.close(); } protected void unsuccessfulAuthentication(HttpServletRequest req, HttpServletResponse resp, AuthenticationException failed) throws IOException, ServletException { resp.setContentType(\"application/json;charset=utf-8\"); PrintWriter out = resp.getWriter(); out.write(\"登录失败!\"); out.flush(); out.close(); }} 关于这个类，我说如下几点： 自定义 JwtLoginFilter 继承自 AbstractAuthenticationProcessingFilter，并实现其中的三个默认方法。 attemptAuthentication方法中，我们从登录参数中提取出用户名密码，然后调用AuthenticationManager.authenticate()方法去进行自动校验。 第二步如果校验成功，就会来到successfulAuthentication回调中，在successfulAuthentication方法中，将用户角色遍历然后用一个 , 连接起来，然后再利用Jwts去生成token，按照代码的顺序，生成过程一共配置了四个参数，分别是用户角色、主题、过期时间以及加密算法和密钥，然后将生成的token写出到客户端。 第二步如果校验失败就会来到unsuccessfulAuthentication方法中，在这个方法中返回一个错误提示给客户端即可。 再来看第二个token校验的过滤器： 123456789101112131415public class JwtFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) servletRequest; String jwtToken = req.getHeader(\"authorization\"); System.out.println(jwtToken); Claims claims = Jwts.parser().setSigningKey(\"sang@123\").parseClaimsJws(jwtToken.replace(\"Bearer\",\"\")) .getBody(); String username = claims.getSubject();//获取当前登录用户名 List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(\"authorities\")); UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(username, null, authorities); SecurityContextHolder.getContext().setAuthentication(token); filterChain.doFilter(req,servletResponse); }} 关于这个过滤器，我说如下几点： 首先从请求头中提取出 authorization 字段，这个字段对应的value就是用户的token。 将提取出来的token字符串转换为一个Claims对象，再从Claims对象中提取出当前用户名和用户角色，创建一个UsernamePasswordAuthenticationToken放到当前的Context中，然后执行过滤链使请求继续执行下去。 如此之后，两个和JWT相关的过滤器就算配置好了。 2.3 Spring Security 配置接下来我们来配置 Spring Security,如下： 1234567891011121314151617181920212223242526272829@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication().withUser(\"admin\") .password(\"123\").roles(\"admin\") .and() .withUser(\"sang\") .password(\"456\") .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/hello\").hasRole(\"user\") .antMatchers(\"/admin\").hasRole(\"admin\") .antMatchers(HttpMethod.POST, \"/login\").permitAll() .anyRequest().authenticated() .and() .addFilterBefore(new JwtLoginFilter(\"/login\",authenticationManager()),UsernamePasswordAuthenticationFilter.class) .addFilterBefore(new JwtFilter(),UsernamePasswordAuthenticationFilter.class) .csrf().disable(); }} 简单起见，这里我并未对密码进行加密，因此配置了NoOpPasswordEncoder的实例。 简单起见，这里并未连接数据库，我直接在内存中配置了两个用户，两个用户具备不同的角色。 配置路径规则时， /hello 接口必须要具备 user 角色才能访问， /admin 接口必须要具备 admin 角色才能访问，POST 请求并且是 /login 接口则可以直接通过，其他接口必须认证后才能访问。 最后配置上两个自定义的过滤器并且关闭掉csrf保护。 2.4 测试做完这些之后，我们的环境就算完全搭建起来了，接下来启动项目然后在 POSTMAN 中进行测试，如下： 登录成功后返回的字符串就是经过 base64url 转码的token，一共有三部分，通过一个 . 隔开，我们可以对第一个 . 之前的字符串进行解码，即Header，如下： 再对两个 . 之间的字符解码，即 payload： 可以看到，我们设置信息，由于base64并不是加密方案，只是一种编码方案，因此，不建议将敏感的用户信息放到token中。 接下来再去访问 /hello 接口，注意认证方式选择 Bearer Token，Token值为刚刚获取到的值，如下： 可以看到，访问成功。 总结这就是 JWT 结合 Spring Security 的一个简单用法，讲真，如果实例允许，类似的需求我还是推荐使用 OAuth2 中的 password 模式。 不知道大伙有没有看懂呢？如果没看懂，松哥还有一个关于这个知识点的视频教程，如下： 如何获取这个视频教程呢？很简单，将本文转发到一个超过100人的微信群中(QQ群不算，松哥是群主的微信群也不算，群要为Java方向)，或者多个微信群中，只要累计人数达到100人即可，然后加松哥微信，截图发给松哥即可获取资料。","link":"/post/9027572c.html"},{"title":"提高性能，MySQL  读写分离环境搭建(一)","text":"这是松哥之前一个零散的笔记，整理出来分享给大伙！ MySQL 读写分离在互联网项目中应该算是一个非常常见的需求了。受困于 Linux 和 MySQL 版本问题，很多人经常会搭建失败，今天松哥就给大伙举一个成功的例子，后面有时间再和大家分享下使用 Docker 搭建环境，那样就 100% 成功了。 CentOS 安装 MySQL自己玩 Linux 松哥一般首选 Ubuntu，不过公司里边使用一般还是 CentOS 为主，因此这里松哥就以 CentOS 为例来向大家演示整个过程，今天这篇文章主要来看看 MySQL 的安装。 环境： CentOS7 MySQL5.7 具体的安装步骤如下： 检查是否安装了 mariadb，如果已经安装了则卸载： 1yum list installed | grep mariadb 如果执行结果如下，表示已经安装了 mariadb，将之卸载： 1mariadb-libs.x86_64 1:5.5.52-1.el7 @anaconda 卸载命令如下： 1yum -y remove mariadb* 接下来下载官方提供的 rpm 包 如果 CentOS 上没有 wget 命令，首先通过如下命令安装 wget： 1yum install wget 然后执行如下操作下载 rpm 包： 1wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm 下载完成后，安装rpm包： 1rpm -ivh mysql57-community-release-el7-11.noarch.rpm 检查 MySQL 的 yum 源是否安装成功： 1yum repolist enabled | grep &quot;mysql.*-community.*&quot; 执行结果如下表示安装成功： 安装 MySQL 1yum install mysql-server 安装完成后，启动MySQL： 1systemctl start mysqld.service 停止MySQL： 1systemctl stop mysqld.service 登录 MySQL： 1mysql -u root -p 默认无密码。有的版本有默认密码，查看默认密码，首先去 /etc/my.cnf 目录下查看 MySQL 的日志位置，然后打开日志文件，可以看到日志中有一个提示，生成了一个临时的默认密码，使用这个密码登录，登录成功后修改密码即可。 改密码 首先修改密码策略(这一步不是必须的，如果不修改密码策略，需要取一个比较复杂的密码，松哥这里简单起见，就修改下密码策略)： 1set global validate_password_policy=0; 然后重置密码： 12set password=password(&quot;123&quot;); flush privileges; 授权远程登录同方式一： 12grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;123&apos; with grant option;flush privileges; 授权远程登录同方式二： 修改 mysql 库中的 user 表，将 root 用户的 Host 字段的值改为 % ，然后重启 MySQL 即可。 关闭防火墙MySQL 要能远程访问，还需要关闭防火墙： 1systemctl stop firewalld.service 禁止firewall开机启动: 1systemctl disable firewalld.service 总结装了这么多 MySQL ，还是 Ubuntu 下 MySQL 最好弄，其他系统多多少少总有点麻烦，本文主要和大家分享了 CentOS7 中 MySQL 的安装步骤，大伙有问题欢迎留言讨论。下篇文章和大伙分享 MySQL 读写分离环境搭建。","link":"/post/cf9fa12f.html"},{"title":"提高性能，MySQL  读写分离环境搭建(二)","text":"上篇文章和大家聊了 CentOS7 安装 MySQL5.7 ，这个大家一般装在虚拟机里边，装好了，把虚拟拷贝一份，这样我们就有两个 MySQL ，就可以开始今天的主从搭建了。 准备工作我这里有一张简单的图向大伙展示 MySQL 主从的工作方式： 这里，我们准备两台机器： 主机：192.168.248.128 从机：192.168.248.139 主机配置主机的配置就三个步骤，比较容易： 1.授权给从机服务器 12GRANT REPLICATION SLAVE ON *.* to &apos;rep1&apos;@&apos;192.168.248.139&apos; identified by &apos;123&apos;;FLUSH PRIVILEGES; 这里表示配置从机登录用户名为 rep1，密码为 123，并且必须从 192.168.248.139这个地址登录，登录成功之后可以操作任意库中的任意表。其中，如果不需要限制登录地址，可以将 IP 地址更换为一个 %。 2.修改主库配置文件，开启 binlog ，并设置 server-id ，每次修改配置文件后都要重启 MySQL 服务才会生效 1vi /etc/my.cnf 修改的文件内容如下： 1234[mysqld]log-bin=/var/lib/mysql/binlogserver-id=128binlog-do-db = cmdb 如下图： log-bin：同步的日志路径及文件名，一定注意这个目录要是 MySQL 有权限写入的（我这里是偷懒了，直接放在了下面那个datadir下面）。 binlog-do-db：要同步的数据库名，当从机连上主机后，只有这里配置的数据库才会被同步，其他的不会被同步。 server-id: MySQL 在主从环境下的唯一标志符，给个任意数字，注意不能和从机重复。 配置完成后重启 MySQL 服务端： 1systemctl restart mysqld 3.查看主服务器当前二进制日志名和偏移量，这个操作的目的是为了在从数据库启动后，从这个点开始进行数据的恢复： 1show master status; 至此，主机配置完成。 从机配置从机的配置也比较简单，我们一步一步来看： 1.在/etc/my.cnf 添加下面配置： 注意从机这里只需要配置一下 server-id 即可。 注意：如果从机是从主机复制来的，即我们通过复制 CentOS 虚拟机获取了 MySQL 实例 ，此时两个 MySQL 的 uuid 一样（正常安装是不会相同的），这时需要手动修改，修改位置在 /var/lib/mysql/auto.cnf ，注意随便修改这里几个字符即可，但也不可太过于随意，例如修改了 uuid 的长度。 2.使用命令来配置从机： 1change master to master_host=&apos;192.168.248.128&apos;,master_port=3306,master_user=&apos;rep1&apos;,master_password=&apos;123&apos;,master_log_file=&apos;binlog.000001&apos;,master_log_pos=120; 这里配置了主机地址、端口以及从机登录主机的用户名和密码，注意最后两个参数要和 master 中的保持一致。 3.启动 slave 进程 1start slave; 启动之后查看从机状态： 1show slave status\\G; 4.查看 slave 的状态 主要是下面两项值都要为为 YES，则表示配置正确： 12Slave_IO_Running: YesSlave_SQL_Running: Yes 至此，配置完成，主机创建库，添加数据，从机会自动同步。 如果这两个有一个不为 YES ，表示主从环境搭建失败，此时可以阅读日志，查看出错的原因，再具体问题具体解决。 总结本文主要和大伙说了 MySQL 主从环境搭建，这几个步骤松哥反反复复操作过很多遍，小伙伴只要按照松哥的步骤一般来说都能成功，有问题欢迎留言讨论。","link":"/post/60ae3a4d.html"},{"title":"整理了八个开源的 Spring Boot 学习资源","text":"Spring Boot 算是目前 Java 领域最火的技术栈了，松哥年初出版的 《Spring Boot + Vue 全栈开发实战》迄今为止已经加印了 3 次，Spring Boot 的受欢迎程度可见一斑。经常有人问松哥有没有推荐的 Spring Boot 学习资料？当然有！买松哥书就对了，哈哈。除了书呢？当然就是开源项目了，今天松哥整理了几个优质 Spring Boot 开源项目给大家参考，希望能够帮助到正在学习 Spring Boot 的小伙伴！ spring-boot-examples star 数 14821 项目地址：https://github.com/ityouknow/spring-boot-examples 这个项目中整合了 Spring Boot 使用的各种示例，以最简单、最实用为标准，此开源项目中的每个示例都以最小依赖，最简单为标准，帮助初学者快速掌握 Spring Boot 各组件的使用。基本上涉及到了 Spring Boot 使用的方方面面。 项目部分 demo 截图： 微人事 star 数 3333 项目地址：https://github.com/lenve/vhr 微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot + Vue 开发。项目打通了前后端，并且提供了非常详尽的文档，从 Spring Boot 接口设计到前端 Vue 的开发思路，作者全部都记录在项目的 wiki 中，是不可多得的 Java 全栈学习资料。 项目效果图: 项目部分文档截图： mall star 数 12668 项目地址：https://github.com/macrozheng/mall mall 项目是一套电商系统，包括前台商城系统及后台管理系统，基于 Spring Boot + MyBatis 实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。 项目效果图： spring-boot-pay star 数 2931 项目地址：https://gitee.com/52itstyle/spring-boot-pay 这是一个支付案例，提供了包括支付宝、微信、银联在内的详细支付代码案例，对于有支付需求的小伙伴来说，这个项目再合适不过了。 项目效果图： V 部落 star 数 1060 项目地址：https://github.com/lenve/VBlog V部落是一个多用户博客管理平台，采用 Vue + SpringBoot + ElementUI 开发。这个项目最大的优势是简单，属于功能完整但是又非常简单的那种，非常非常适合初学者。 项目效果图： springboot-plus star 数 2546 项目地址：https://gitee.com/xiandafu/springboot-plus 一个基于SpringBoot 2 的管理后台系统,包含了用户管理，组织机构管理，角色管理，功能点管理，菜单管理，权限分配，数据权限分配，代码生成等功能 相比其他开源的后台系统，SpringBoot-Plus 具有一定的复杂度。系统基于Spring Boot2.1技术，前端采用了Layui2.4。数据库以MySQL/Oracle/Postgres/SQLServer为实例，理论上是跨数据库平台。 项目效果图： litemall star 数 6436 项目地址：https://github.com/linlinjava/litemall 一个商城项目，包括Spring Boot后端 + Vue管理员前端 + 微信小程序用户前端 + Vue用户移动端，功能包括、分类列表、分类详情、品牌列表、品牌详情、新品首发、人气推荐、优惠券列表、优惠券选择、团购（团购业务有待完善）、搜索、商品详情、商品评价、商品分享、购物车、下单、订单列表、订单详情、地址、收藏、足迹、意见反馈以及客服；管理平台功能包括会员管理、商城管理、商品管理、推广管理、系统管理、配置管理、统计报表等。 项目效果图： 其他另外再向大家推荐两个优质的 Spring Boot 和 Spring Cloud 学习网站，如下： http://www.springboot.wiki http://www.springcloud.wiki 总结好了，一点点整理的资源，希望能够帮助到大家。","link":"/post/1379453b.html"},{"title":"是时候了解下Spring Boot整合 Jpa啦","text":"Spring Boot中的数据持久化方案前面给大伙介绍了两种了，一个是JdbcTemplate，还有一个MyBatis，JdbcTemplate配置简单，使用也简单，但是功能也非常有限，MyBatis则比较灵活，功能也很强大，据我所知，公司采用MyBatis做数据持久化的相当多，但是MyBatis并不是唯一的解决方案，除了MyBatis之外，还有另外一个东西，那就是Jpa，松哥也有一些朋友在公司里使用Jpa来做数据持久化，本文就和大伙来说说Jpa如何实现数据持久化。 Jpa介绍首先需要向大伙介绍一下Jpa，Jpa（Java Persistence API）Java持久化API，它是一套ORM规范，而不是具体的实现，Jpa的江湖地位类似于JDBC，只提供规范，所有的数据库厂商提供实现（即具体的数据库驱动），Java领域，小伙伴们熟知的ORM框架可能主要是Hibernate，实际上，除了Hibernate之外，还有很多其他的ORM框架，例如： Batoo JPA DataNucleus (formerly JPOX) EclipseLink (formerly Oracle TopLink) IBM, for WebSphere Application Server JBoss with Hibernate Kundera ObjectDB OpenJPA OrientDB from Orient Technologies Versant Corporation JPA (not relational, object database) Hibernate只是ORM框架的一种，上面列出来的ORM框架都是支持JPA2.0规范的ORM框架。既然它是一个规范，不是具体的实现，那么必然就不能直接使用（类似于JDBC不能直接使用，必须要加了驱动才能用），我们使用的是具体的实现，在这里我们采用的实现实际上还是Hibernate。 Spring Boot中使用的Jpa实际上是Spring Data Jpa，Spring Data是Spring家族的一个子项目，用于简化SQL和NoSQL的访问，在Spring Data中，只要你的方法名称符合规范，它就知道你想干嘛，不需要自己再去写SQL。 工程创建创建Spring Boot工程，添加Web、Jpa以及MySQL驱动依赖，如下： 工程创建好之后，添加Druid依赖，完整的依赖如下： 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 如此，工程就算创建成功了。 基本配置工程创建完成后，只需要在application.properties中进行数据库基本信息配置以及Jpa基本配置，如下： 123456789101112131415# 数据库的基本配置spring.datasource.username=rootspring.datasource.password=rootspring.datasource.url=jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=UTF-8spring.datasource.type=com.alibaba.druid.pool.DruidDataSource# JPA配置spring.jpa.database=mysql# 在控制台打印SQLspring.jpa.show-sql=true# 数据库平台spring.jpa.database-platform=mysql# 每次启动项目时，数据库初始化策略spring.jpa.hibernate.ddl-auto=update# 指定默认的存储引擎为InnoDBspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL57Dialect 注意这里和JdbcTemplate以及MyBatis比起来，多了Jpa配置，Jpa配置含义我都注释在代码中了，这里不再赘述，需要强调的是，最后一行配置，默认情况下，自动创建表的时候会使用MyISAM做表的引擎，如果配置了数据库方言为MySQL57Dialect，则使用InnoDB做表的引擎。 好了，配置完成后，我们的Jpa差不多就可以开始用了。 基本用法ORM(Object Relational Mapping)框架表示对象关系映射，使用ORM框架我们不必再去创建表，框架会自动根据当前项目中的实体类创建相应的数据表。因此，我这里首先创建一个User对象，如下： 12345678910@Entity(name = \"t_user\")public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = \"name\") private String username; private String address; //省略getter/setter} 首先@Entity注解表示这是一个实体类，那么在项目启动时会自动针对该类生成一张表，默认的表名为类名，@Entity注解的name属性表示自定义生成的表名。@Id注解表示这个字段是一个id，@GeneratedValue注解表示主键的自增长策略，对于类中的其他属性，默认都会根据属性名在表中生成相应的字段，字段名和属性名相同，如果开发者想要对字段进行定制，可以使用@Column注解，去配置字段的名称，长度，是否为空等等。 做完这一切之后，启动Spring Boot项目，就会发现数据库中多了一个名为t_user的表了。 针对该表的操作，则需要我们提供一个Repository，如下： 123456public interface UserDao extends JpaRepository&lt;User,Integer&gt; { List&lt;User&gt; getUserByAddressEqualsAndIdLessThanEqual(String address, Integer id); @Query(value = \"select * from t_user where id=(select max(id) from t_user)\",nativeQuery = true) User maxIdUser();} 这里，自定义UserDao接口继承自JpaRepository，JpaRepository提供了一些基本的数据操作方法，例如保存，更新，删除，分页查询等，开发者也可以在接口中自己声明相关的方法，只需要方法名称符合规范即可，在Spring Data中，只要按照既定的规范命名方法，Spring Data Jpa就知道你想干嘛，这样就不用写SQL了，那么规范是什么呢？参考下图： 当然，这种方法命名主要是针对查询，但是一些特殊需求，可能并不能通过这种方式解决，例如想要查询id最大的用户，这时就需要开发者自定义查询SQL了，如上代码所示，自定义查询SQL，使用@Query注解，在注解中写自己的SQL，默认使用的查询语言不是SQL，而是JPQL，这是一种数据库平台无关的面向对象的查询语言，有点定位类似于Hibernate中的HQL，在@Query注解中设置nativeQuery属性为true则表示使用原生查询，即大伙所熟悉的SQL。上面代码中的只是一个很简单的例子，还有其他一些点，例如如果这个方法中的SQL涉及到数据操作，则需要使用@Modifying注解。 好了，定义完Dao之后，接下来就可以将UserDao注入到Controller中进行测试了(这里为了省事，就没有提供Service了，直接将UserDao注入到Controller中)。 1234567891011121314151617181920212223242526272829303132333435363738394041@RestControllerpublic class UserController { @Autowired UserDao userDao; @PostMapping(\"/\") public void addUser() { User user = new User(); user.setId(1); user.setUsername(\"张三\"); user.setAddress(\"深圳\"); userDao.save(user); } @DeleteMapping(\"/\") public void deleteById() { userDao.deleteById(1); } @PutMapping(\"/\") public void updateUser() { User user = userDao.getOne(1); user.setUsername(\"李四\"); userDao.flush(); } @GetMapping(\"/test1\") public void test1() { List&lt;User&gt; all = userDao.findAll(); System.out.println(all); } @GetMapping(\"/test2\") public void test2() { List&lt;User&gt; list = userDao.getUserByAddressEqualsAndIdLessThanEqual(\"广州\", 2); System.out.println(list); } @GetMapping(\"/test3\") public void test3() { User user = userDao.maxIdUser(); System.out.println(user); }} 如此之后，即可查询到需要的数据。 好了，本文的重点是Spring Boot和Jpa的整合，这个话题就先说到这里。 多说两句在和Spring框架整合时，如果用到ORM框架，大部分人可能都是首选Hibernate，实际上，在和Spring+SpringMVC整合时，也可以选择Spring Data Jpa做数据持久化方案，用法和本文所述基本是一样的，Spring Boot只是将Spring Data Jpa的配置简化了，因此，很多初学者对Spring Data Jpa觉得很神奇，但是又觉得无从下手，其实，此时可以回到Spring框架，先去学习Jpa，再去学习Spring Data Jpa，这是给初学者的一点建议。","link":"/post/17c7e4ce.html"},{"title":"最简单的SpringBoot整合MyBatis教程","text":"前面两篇文章和读者聊了Spring Boot中最简单的数据持久化方案JdbcTemplate，JdbcTemplate虽然简单，但是用的并不多，因为它没有MyBatis方便，在Spring+SpringMVC中整合MyBatis步骤还是有点复杂的，要配置多个Bean，Spring Boot中对此做了进一步的简化，使MyBatis基本上可以做到开箱即用，本文就来看看在Spring Boot中MyBatis要如何使用。 工程创建首先创建一个基本的Spring Boot工程，添加Web依赖，MyBatis依赖以及MySQL驱动依赖，如下： 创建成功后，添加Druid依赖，并且锁定MySQL驱动版本，完整的依赖如下： 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 如此，工程就算是创建成功了。读者注意，MyBatis和Druid依赖的命名和其他库的命名不太一样，是属于xxx-spring-boot-stater模式的，这表示该starter是由第三方提供的。 基本用法MyBatis的使用和JdbcTemplate基本一致，首先也是在application.properties中配置数据库的基本信息： 1234spring.datasource.url=jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=rootspring.datasource.type=com.alibaba.druid.pool.DruidDataSource 配置完成后，MyBatis就可以创建Mapper来使用了，例如我这里直接创建一个UserMapper2，如下： 12345678910111213141516171819202122232425public interface UserMapper2 { @Select(\"select * from user\") List&lt;User&gt; getAllUsers(); @Results({ @Result(property = \"id\", column = \"id\"), @Result(property = \"username\", column = \"u\"), @Result(property = \"address\", column = \"a\") }) @Select(\"select username as u,address as a,id as id from user where id=#{id}\") User getUserById(Long id); @Select(\"select * from user where username like concat('%',#{name},'%')\") List&lt;User&gt; getUsersByName(String name); @Insert({\"insert into user(username,address) values(#{username},#{address})\"}) @SelectKey(statement = \"select last_insert_id()\", keyProperty = \"id\", before = false, resultType = Integer.class) Integer addUser(User user); @Update(\"update user set username=#{username},address=#{address} where id=#{id}\") Integer updateUserById(User user); @Delete(\"delete from user where id=#{id}\") Integer deleteUserById(Integer id);} 这里是通过全注解的方式来写SQL，不写XML文件，@Select、@Insert、@Update以及@Delete四个注解分别对应XML中的select、insert、update以及delete标签，@Results注解类似于XML中的ResultMap映射文件（getUserById方法给查询结果的字段取别名主要是向小伙伴们演示下@Results注解的用法），另外使用@SelectKey注解可以实现主键回填的功能，即当数据插入成功后，插入成功的数据id会赋值到user对象的id属性上。 UserMapper2创建好之后，还要配置mapper扫描，有两种方式，一种是直接在UserMapper2上面添加@Mapper注解，这种方式有一个弊端就是所有的Mapper都要手动添加，要是落下一个就会报错，还有一个一劳永逸的办法就是直接在启动类上添加Mapper扫描，如下： 1234567@SpringBootApplication@MapperScan(basePackages = \"org.sang.mybatis.mapper\")public class MybatisApplication { public static void main(String[] args) { SpringApplication.run(MybatisApplication.class, args); }} 好了，做完这些工作就可以去测试Mapper的使用了。 mapper映射当然，开发者也可以在XML中写SQL，例如创建一个UserMapper，如下： 123456789public interface UserMapper { List&lt;User&gt; getAllUser(); Integer addUser(User user); Integer updateUserById(User user); Integer deleteUserById(Integer id);} 然后创建UserMapper.xml文件，如下： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.sang.mybatis.mapper.UserMapper\"&gt; &lt;select id=\"getAllUser\" resultType=\"org.sang.mybatis.model.User\"&gt; select * from t_user; &lt;/select&gt; &lt;insert id=\"addUser\" parameterType=\"org.sang.mybatis.model.User\"&gt; insert into user (username,address) values (#{username},#{address}); &lt;/insert&gt; &lt;update id=\"updateUserById\" parameterType=\"org.sang.mybatis.model.User\"&gt; update user set username=#{username},address=#{address} where id=#{id} &lt;/update&gt; &lt;delete id=\"deleteUserById\"&gt; delete from user where id=#{id} &lt;/delete&gt;&lt;/mapper&gt; 将接口中方法对应的SQL直接写在XML文件中。 那么这个UserMapper.xml到底放在哪里呢？有两个位置可以放，第一个是直接放在UserMapper所在的包下面： 放在这里的UserMapper.xml会被自动扫描到，但是有另外一个Maven带来的问题，就是java目录下的xml资源在项目打包时会被忽略掉，所以，如果UserMapper.xml放在包下，需要在pom.xml文件中再添加如下配置，避免打包时java目录下的XML文件被自动忽略掉： 12345678910111213&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 当然，UserMapper.xml也可以直接放在resources目录下，这样就不用担心打包时被忽略了，但是放在resources目录下，又不能自动被扫描到，需要添加额外配置。例如我在resources目录下创建mapper目录用来放mapper文件，如下： 此时在application.properties中告诉mybatis去哪里扫描mapper： 1mybatis.mapper-locations=classpath:mapper/*.xml 如此配置之后，mapper就可以正常使用了。注意第二种方式不需要在pom.xml文件中配置文件过滤。 原理分析在SSM整合中，开发者需要自己提供两个Bean，一个SqlSessionFactoryBean，还有一个是MapperScannerConfigurer，在Spring Boot中，这两个东西虽然不用开发者自己提供了，但是并不意味着这两个Bean不需要了，在org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration类中，我们可以看到Spring Boot提供了这两个Bean，部分源码如下： 1234567891011121314151617181920212223242526272829303132333435@org.springframework.context.annotation.Configuration@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })@ConditionalOnSingleCandidate(DataSource.class)@EnableConfigurationProperties(MybatisProperties.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration implements InitializingBean { @Bean @ConditionalOnMissingBean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); factory.setDataSource(dataSource); return factory.getObject(); } @Bean @ConditionalOnMissingBean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) { ExecutorType executorType = this.properties.getExecutorType(); if (executorType != null) { return new SqlSessionTemplate(sqlSessionFactory, executorType); } else { return new SqlSessionTemplate(sqlSessionFactory); } } @org.springframework.context.annotation.Configuration @Import({ AutoConfiguredMapperScannerRegistrar.class }) @ConditionalOnMissingBean(MapperFactoryBean.class) public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean { @Override public void afterPropertiesSet() { logger.debug(\"No {} found.\", MapperFactoryBean.class.getName()); } }} 从类上的注解可以看出，当当前类路径下存在SqlSessionFactory、 SqlSessionFactoryBean以及DataSource时，这里的配置才会生效，SqlSessionFactory和SqlTemplate都被提供了。为什么要看这段代码呢？下篇文章，松哥和大伙分享Spring Boot中MyBatis多数据源的配置时，这里将是一个重要的参考。 好了，欢迎加入我的星球，关于我的星球【Java达摩院】，大伙可以参考这篇文章推荐一个技术圈子，Java技能提升就靠它了.","link":"/post/ecba96ae.html"},{"title":"极简Spring Boot整合MyBatis多数据源","text":"关于多数据源的配置，前面和大伙介绍过JdbcTemplate多数据源配置，那个比较简单，本文来和大伙说说MyBatis多数据源的配置。其实关于多数据源，我的态度还是和之前一样，复杂的就直接上分布式数据库中间件，简单的再考虑多数据源。这是项目中的建议，技术上的话，当然还是各种技术都要掌握的。 工程创建首先需要创建MyBatis项目，项目创建和前文的一样，添加MyBatis、MySQL以及Web依赖： 项目创建完成后，添加Druid依赖，和JdbcTemplate一样，这里添加Druid依赖也必须是专为Spring boot打造的Druid，不能使用传统的Druid。完整的依赖如下： 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.28&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 多数据源配置接下来配置多数据源，这里基本上还是和JdbcTemplate多数据源的配置方式一致，首先在application.properties中配置数据库基本信息，然后提供两个DataSource即可，这里我再把代码贴出来，里边的道理条条框框的，大伙可以参考前面的文章，这里不再赘述。 application.properties中的配置： 123456789spring.datasource.one.url=jdbc:mysql:///test01?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.one.username=rootspring.datasource.one.password=rootspring.datasource.one.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.two.url=jdbc:mysql:///test02?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.two.username=rootspring.datasource.two.password=rootspring.datasource.two.type=com.alibaba.druid.pool.DruidDataSource 然后再提供两个DataSource，如下： 12345678910111213@Configurationpublic class DataSourceConfig { @Bean @ConfigurationProperties(prefix = \"spring.datasource.one\") DataSource dsOne() { return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasource.two\") DataSource dsTwo() { return DruidDataSourceBuilder.create().build(); }} MyBatis配置接下来则是MyBatis的配置，不同于JdbcTemplate，MyBatis的配置要稍微麻烦一些，因为要提供两个Bean，因此这里两个数据源我将在两个类中分开来配置，首先来看第一个数据源的配置： 1234567891011121314151617181920212223@Configuration@MapperScan(basePackages = \"org.sang.mybatis.mapper1\",sqlSessionFactoryRef = \"sqlSessionFactory1\",sqlSessionTemplateRef = \"sqlSessionTemplate1\")public class MyBatisConfigOne { @Resource(name = \"dsOne\") DataSource dsOne; @Bean SqlSessionFactory sqlSessionFactory1() { SqlSessionFactory sessionFactory = null; try { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dsOne); sessionFactory = bean.getObject(); } catch (Exception e) { e.printStackTrace(); } return sessionFactory; } @Bean SqlSessionTemplate sqlSessionTemplate1() { return new SqlSessionTemplate(sqlSessionFactory1()); }} 创建MyBatisConfigOne类，首先指明该类是一个配置类，配置类中要扫描的包是org.sang.mybatis.mapper1，即该包下的Mapper接口将操作dsOne中的数据，对应的SqlSessionFactory和SqlSessionTemplate分别是sqlSessionFactory1和sqlSessionTemplate1，在MyBatisConfigOne内部，分别提供SqlSessionFactory和SqlSessionTemplate即可，SqlSessionFactory根据dsOne创建，然后再根据创建好的SqlSessionFactory创建一个SqlSessionTemplate。 这里配置完成后，依据这个配置，再来配置第二个数据源即可： 1234567891011121314151617181920212223@Configuration@MapperScan(basePackages = \"org.sang.mybatis.mapper2\",sqlSessionFactoryRef = \"sqlSessionFactory2\",sqlSessionTemplateRef = \"sqlSessionTemplate2\")public class MyBatisConfigTwo { @Resource(name = \"dsTwo\") DataSource dsTwo; @Bean SqlSessionFactory sqlSessionFactory2() { SqlSessionFactory sessionFactory = null; try { SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dsTwo); sessionFactory = bean.getObject(); } catch (Exception e) { e.printStackTrace(); } return sessionFactory; } @Bean SqlSessionTemplate sqlSessionTemplate2() { return new SqlSessionTemplate(sqlSessionFactory2()); }} 好了，这样MyBatis多数据源基本上就配置好了，接下来只需要在org.sang.mybatis.mapper1和org.sang.mybatis.mapper2包中提供不同的Mapper，Service中注入不同的Mapper就可以操作不同的数据源。 mapper创建org.sang.mybatis.mapper1中的mapper： 123public interface UserMapperOne { List&lt;User&gt; getAllUser();} 对应的XML文件： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.sang.mybatis.mapper1.UserMapperOne\"&gt; &lt;select id=\"getAllUser\" resultType=\"org.sang.mybatis.model.User\"&gt; select * from t_user; &lt;/select&gt;&lt;/mapper&gt; org.sang.mybatis.mapper2中的mapper： 123public interface UserMapper { List&lt;User&gt; getAllUser();} 对应的XML文件： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.sang.mybatis.mapper2.UserMapper\"&gt; &lt;select id=\"getAllUser\" resultType=\"org.sang.mybatis.model.User\"&gt; select * from t_user; &lt;/select&gt;&lt;/mapper&gt; 接下来，在Service中注入两个不同的Mapper，不同的Mapper将操作不同的数据源。 好了，欢迎加入我的星球，关于我的星球【Java达摩院】，大伙可以参考这篇文章推荐一个技术圈子，Java技能提升就靠它了.","link":"/post/4e31756a.html"},{"title":"起早贪黑几个月，我写完了人生第一本书！","text":"今天有小伙伴在网上问了我一个问题：写书的整个过程是什么感受？想想我好像还没各位小伙伴聊过我写书的故事，只是在书出版后做过一次送书活动，其他的好像就没分享啥了，今天我想借这个机会和大伙聊聊我写书的故事，也希望我的经验能帮助到各位小伙伴。 1.缘起故事得从我大学毕业时候说起啦。大四第一学期忙着准备考研，错过了秋招，然而研究生也没考上，过完年研究生考试成绩出来后，一看不行就赶紧出来找工作，西北农村娃，不敢耗也耗不起。大学所在的城市高校不多，所以春招的时候我回到了老家西安参加春招，花了一个多礼拜，拿了三个offer，感觉差不多了又急匆匆返回学校，返校后，回忆找工作的过程，有得意也有失落，得意的是没想到找工作这么顺利，失落的是想去的公司没去成，我的学校还被一些中等公司鄙视了。 我本科学位是管理学学士，计算机是我从大二开始自学的，自学了JavaEE和Android，当时找工作时候，招Android的，招Java的我都去面，3个offer有两个是Java，一个Android。虽然找工作整体上感觉不错，不过还是有一些不如意的地方，有一个超级大的大厂，过了笔试，也过了两轮技术面，止步于最后一轮人事面，这算是找工作期间最遗憾的一件事了。也有一些不怎么大的厂，却歧视我的学校（某末流211），这让我忿忿不平，但是学校也没法改变，思来想去，决定写博客，提高自己的技术影响力，弥补专业和学校的不足，就这样，在CSDN上注册了博客账号，当年4月15号发表了第一篇博客，从此打开了一扇新大门。 博客写了一段时间，CSDN的运营梦鸽美女邀请我申请博客专家，有了title写的就更有劲了。写博客的过程中，感觉自身的技术也在不断的提高，因为刚开始学一个新技术点的时候，很多东西没太关注，只会用，没细究，写博客则是一个整理的过程，是自己思维一个锻炼的过程，博客写完了，感觉对相关知识点的认知又上升了。 刚开始写的时候，博客的访问量并不高，好在我当时也是刚毕业，不着急，就慢慢的写着，就这样，第二年刚过完年就开始有人找我写书，被我婉拒了，我的理由是刚刚毕业半年，实在没啥好写的，也不知道该写啥。不过我却发现写书好像没那么难，好像很容易，因为竟然有人找我写书。再之后，隔三差五就会有出版社的编辑找来了，电子工业出版社、人民邮电出版社、清华大学出版社等等，不过我自己从来没下定决心，虽然心里也有想法，但是总觉得还差点火候。 2018年刚过完年，那时候我搞Spring Boot+Vue也有一段时间了，自我感觉积累了一点点料，有种想和大伙分享的欲望，另一方面也觉得该为自己的职业生涯留下一点东西，不能就这么默默无闻的搬一辈子砖，在认真考虑后，决定写一本Spring Boot相关的书，刚好清华社的夏老师没过几天就加了我微信，于是一拍即合。 这是写书的第一步，先有技术积累，有博客或者公众号，圈子里有一点点名气，就会有出版社的编辑找来，因为出版社编辑比较喜欢那种在某一领域深耕多年，对相关技术有自己的看法和认识，有原创的博客，并且博客写作思路清晰，文章脉络清楚的作者。在这个阶段我觉得最难的还是坚持，写博客积累技术和名气并非一朝一夕的事，有一些超级大牛，抓住了技术的风口一下就积累了很多的关注，刚入行的小辈看到这些大牛的博客，感觉达到这样的高度太难了，所以放弃了。其实很多时候，你不用成为执牛耳的大牛，成为一个小小的小牛，就够了。 这一阶段，总结两个字：坚持。 2.写作在答应了出版社的邀请之后，就着手开始准备了。在刚开始答应的时候，需要提交一个图书选题单给出版社的老师，选题单中会列出书名，章节，作者等信息。 选题定下来之后，先和出版社签订出版合同，合同中会约定图书字数、作者、稿费计算方式等，签好合同后，和出版社的事情暂时就先告一段落了。 接下来就开始写了，细化每个章节的目录，每章大概写多少，准备写哪些内容，提纲细化之后，后面基本就不动了，主要是填内容进去。写书和写博客不一样，博客，我只需要介绍某一个知识点，解决某一个问题就行了，写书，不仅要介绍知识点解决问题，还要讲究知识点的全面，不能有遗漏，很多东西，我们可能经常用某一种方式实现，但实际上换一种方式也能实现，但是你可能就不知道，关键是你并不知道他还有另一种实现方式，这就很累了，为了不遗漏知识点，只能把官方文档反复看。有的时候卡在某一个技术点上，上班时候脑子里都是相关问题，一有解决思路就赶紧先记下来，回家后赶紧尝试。在写书之前，我在公众号上已经陆续发了Redis系列教程、MongoDB系列教程、Spring Cloud系列教程以及Git系列教程等，因此在写Spring Boot时，遇到这几方面的问题基本上都能得心应手，也算是前期准备比较充分吧（其实写这些教程的时候压根就没想到写书的事，但是掌握了，写出来的技术，总会在某一天发挥作用的）。 写书期间最大的挑战还不是来自技术，而是自信，有的时候写着写着甚至会怀疑自己，这书写出来有人看吗？但是合同签了，没人看也得硬着头皮写下去，而且得认真写。有时候一些出版的问题要和编辑老师沟通，沟通完后，又会信心满满，这一点，还是要感谢出版社编辑老师的鼓励。我自己因为不爱交流，很多问题喜欢自己瞎琢磨，其实很多出版方面的问题都可以和编辑及时沟通，避免给自己徒增烦恼（这个建议送给想要写书的小伙伴）。 那一段时间，我每天早上7点起床，写到8点半然后去上班，晚上6点下班后，差不多7点开始写，写到11点半，周末写两天，拒掉了大部分的社交活动，差不多就这样连续了几个月，交稿的时候有种高考考完的感觉，有的小伙伴可能觉得我是个假程序员，竟然不加班，老实说，敝司确实不怎么加班。稿子交到出版社之后，还要经过排版-&gt;编辑-&gt;改错-&gt;初审-&gt;复审-&gt;终审-&gt;发稿-&gt;申请书号、CIP-&gt;封面设计-&gt;出片-&gt;下厂印制-&gt;发样书-&gt;入库-&gt;上市销售，整个过程大约持续了三个多月。封面设计时候，出版社给了两个参考的封面，纠结了半天，后来选择了绿色的（可能有小伙伴要吐槽我的审美了）： 关于封面这里，也可以自己提一些设计思路给出版社去做，不过我最终还是选择了出版社的方案，想想民国时那些自己给自己设计图书封面的大佬，真是佩服的五体投地。关于书的定价，也是出版社给一个参考范围，作者自己选，现在技术图书的定价基本都是按照印张来的，作者选择的范围不大，除非是超级超级大牛，可能会额外照顾（我瞎猜的）。 到了2019年1月份的时候，有一天午休醒来，有个人加我微信，备注说是读者，我才发现书已经上市销售了，至此，2018年的工程，总算告一段落了，几个月起早贪黑，甚至打了退堂鼓，还好最终没有放弃，总算有了收货。 这一阶段的总结：不要怂，就是干。 3.收获图书出版后，感觉收获还是蛮大的。从以下三个方面来跟大伙聊聊： 技术首先就是技术了，写书是一个非常非常系统化的工程，虽然我以前也写过多个成体系的教程，但是感觉和写书还是有很大的不同，写书的过程，也是重新梳理自己知识体系的过程，对于以前不求甚解的东西都去认真研究了，还要想办法将一些复杂的东西写的浅显易懂，让读者容易上手。在不断的锤炼中，自己的技术也得到了极大的提高。 信心由于我并非科班出身，有幸在这个行业混口饭吃其实已经很满足了，计算机理论捉襟见肘，虽然我一直在努力弥补，但总是不够自信。这本书一定程度上让我更有信心在这个圈子里混下去。 圈子我自己平时不怎么出去玩，比较宅，线下的圈子不多，线上的圈子倒不少，但是很多人都是听其名，不知其人。书出版之后，加入的第一个圈子就是华为云享专家，在华为云组织的openday中，认识了很多大佬，很多人名字和人终于对上了，自己也收获了很多。还有一些由于时间原因被我推掉的活动，但总体感觉就是活动多了。其实这就是我自己一向所说的，提高自己才是最重要的，与其削尖了脑袋挤进某一个圈子，不如修炼内功，时间到了，该有的就有了。 4.一点建议其实经常会有一些读者在后台联系我，有刚毕业的大学生，也有在读的研究生，他们想知道在技术的道路上要如何选择，C\\C++\\Java\\前端，都会，但是却不精通，这里我给的建议就是苍蝇模式，因为我一开始也是自学的，我相信我曾经遇到的困惑也有后来者会遇到，那么什么是苍蝇模式呢？ 美国密歇根大学教授卡尔·韦克做过这样一个实验：把一群蜜蜂和一群苍蝇同时装进一个玻璃瓶里，将瓶子横着放平，让瓶底朝着光，小蜜蜂们会一刻不停地在瓶底附近飞舞，因为蜜蜂的复眼有更强的向光性，对阳光的敏感和偏执决定它们不肯接近黑暗的地方，哪怕是出口，蜜蜂一次次撞到瓶底，直到力竭而死，而苍蝇则在瓶子里乱撞，不一会儿，就能从瓶口逃之夭夭。 刚入行可以多了解、多打听、多去尝试慢慢找到适合自己的，自己喜欢的，选定了方向之后，就可以开始做技术积累了，积累可以从写博客开始，初期建议选个大平台，例如博客园、CSDN或者慕课网之类的，有了名气之后，可以考虑独立建站或者写公众号，慢慢打造个人品牌，个人品牌建立了，写书就是愿不愿意的事了。其实，事儿不难，难在坚持！","link":"/post/d8034cc2.html"},{"title":"跟着平台混了四年，现在要单飞了！","text":"我记得是2015年4月15在CSDN上发表了我的第一篇博客，是一个学习笔记，从那之后开启了我博客写作之路，到今天为止即将4年，这4年时间我在CSDN上发表的博客最多，共有372篇原创，CSDN是我的大本营，不过在这期间也有断断续续在其他公共平台上发过博客，例如 sf、博客园、掘金、慕课网等，但是都是非常零散，2016年的时候，利用我的 GitHub 也搭建了一个个人站点，但是只是试验了几个页面，并没有好好去维护，前两天清明节，一时心血来潮，花了半天时间搞了一个自己的独立博客 http://www.javaboy.org ，以后将在这个站点上和大伙分享技术。 实际上搭建一个个人站点并不费什么事，唯一的资金投入就是域名，一年也就几十块钱，其他的套用现成的技术即可，接下来我就来和大伙分享下独立博客搭建过程，给小伙伴一个参考。 准备工作博客搭建实际上现在搭建一个个人独立博客，可选方案很多，我这里用了久闻大名的 Hexo 来搭建，用 Hexo 搭建，要是有一点点前端 Node 的使用经验更佳，没有当然也没关系，因为与之相关的命令并不多。使用 Hexo 需要提前在电脑上安装好 Node 和 Git ，安装成功后，就可以开始 Hexo 的安装了。步骤如下： 安装 Hexo 1npm install -g hexo-cli 在本地创建一个博客目录 1hexo init blog 上面这个命令执行完后，会在本地创建一个 blog 目录，这里边就是独立博客所必须的一些文件，然后进入到这个目录中，执行 npm install 命令，安装相关的依赖。 安装完成后，会生成如下目录： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 这里几个文件/文件夹，我们先来关注其中两个 _config.yml 和 themes 目录， _config.yml 文件中，我们可以做网站的一些基本配置，例如 网站的 title，描述，关键字、图标等，这些配置大都见名知意。如下： 配置完成后，定位到 blog 目录，执行 hexo s 就可以在本地启动项目了，启动成功后，浏览器中输入 http://localhost:4000 就可以看到网站了。 说到 hexo s 命令，这里有几个常用命令需要给大家介绍下，分别是： 命令 简写 中文含义 hexo server hexo s 本地启动 hexo generate hexo g 生成静态文件 hexo deploy hexo d 部署网站 hexo clean 清除缓存和已经生成的静态文件 这四个算是松哥这两天使用最多的命令，其他的命令，大伙可以参考这里。 修改主题一般来说，主题都会自己配置一个，个人感觉 Hexo 的生态还是比较丰富的，有很多可选的主题，Hexo 默认使用的主题是 landscape ，我这里使用了 hexo-theme-next 主题。博客在本地跑起来之后，接下来就是修改主题，主题修改的第一步就是先选一个自己认为好看的主题，选好之后，首先将之克隆到 ./themes 目录下，这个目录下原本有有一个 landscape 文件夹，里边放的默认的样式，当然开发者也可以直接将主题文件下载好拷贝进来，但是我还是建议使用 clone ，使用 clone ，假如有一天这个主题更新了，只需要 pull 一下就可以获取到最新样式了。 以 hexo-theme-next 主题为例， clone 命令如下： 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 克隆成功后，修改 hexo 的 _config.yml 文件，将主题修改为 next，如下： 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 主题创建好之后，接下来就是对主题的配置了，这个比较容易，直接参考官方文档即可。配置完成后，执行如下命令，即可看到新的主题效果： 123hexo cleanhexo ghexo s 命令含义可以参考上面的表格，这里不再赘述。 绑定到 GitHub大家可能已经迫不及待想要把博客上传到 GitHub 了，绑定到 Github 步骤也很简单，首先以 自己的GitHub ID.github.io 为名创建一个 public 仓库，例如我的 ID 为 lenve，创建的仓库如下： 创建成功之后，修改 hexo 的 _config.yml 文件，配置 GitHub 地址，如下： 1234deploy: type: git repo: git@github.com:lenve/lenve.github.io.git branch: master 这里根据自己的地址来配置即可，配置完成后，执行如下命令： 12hexo ghexo d 执行完成后，就可以将数据上传到 GitHub 了（当然这里需要大家提前配置一下 GitHub 的公钥，具体可以参考Git关联远程仓库）。 上传成功后，访问 https://lenve.github.io 就可以看到自己的个人站点了。 如果你对 GitHub 提供的域名不满意，也可以自己申请一个域名，分分钟就配置好了。 域名申请域名申请建议使用国外的域名提供商，不用备案（一个字，快！不用等），松哥使用了 godaddy ，主要是因为这个服务商支持支付宝付款，域名申请就比较容易了，无需多说。 域名和 GitHub 绑定域名申请成功之后，接下来的配置，也分为两部分。 GitHub 配置首先在博客所在目录下的 source 目录中，创建一个 CNAME 文件，文件内容就是你的域名，如下： 然后执行 hexo d 命令将这个文件上传到 GitHub就可以了。 在网上看到有人直接在 GitHub 上配置这个，如下图： 这种方式也可以，这种方式会自动生成一个CNAME文件到当前仓库中，但是松哥在这里不推荐大家使用这种方式，因为如果你在本地执行了 hexo clean ，然后再去上传，就会丢失掉 CNAME 文件，然后又得重新配置。 域名解析配置域名解析这块，当时遇到了一些问题，因为是在清明节假期，也没法联系客服，后来松哥使用了 DNSPod 去做域名解析了，没有使用 godaddy 提供的域名解析。所以首先要做的，就是修改 godaddy 提供的域名解析服务，登录自己的 godaddy 账号，找到域名管理，修改域名解析服务为 DNSPod ，如下： 然后登录到 DNSPod（没有账号注册一个），然后添加自己的域名解析，如下图： 添加两条 A 记录，指向 GitHub 的 IP 地址，再添加一条 CNAME ，指向你的 GitHub 域名就可以了。 如此之后，大功告成！ 总结因为是第一次做，比较顺利，也很简单，不用花很多钱，就是一个域名的费用而已，不需要额外买服务器，hexo 的使用也很简单，有兴趣小伙伴赶快实践下吧！","link":"/post/421fc821.html"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","link":"/tags/JavaWeb/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"yaml","slug":"yaml","link":"/tags/yaml/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"JdbcTemplate","slug":"JdbcTemplate","link":"/tags/JdbcTemplate/"},{"name":"Jpa","slug":"Jpa","link":"/tags/Jpa/"},{"name":"Swagger2","slug":"Swagger2","link":"/tags/Swagger2/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"杂谈","slug":"杂谈","link":"/tags/杂谈/"},{"name":"Spring Data","slug":"Spring-Data","link":"/tags/Spring-Data/"},{"name":"JWT","slug":"JWT","link":"/tags/JWT/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"}],"categories":[{"name":"JavaWeb","slug":"JavaWeb","link":"/categories/JavaWeb/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"MyBatis","slug":"MyBatis","link":"/categories/MyBatis/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/categories/SpringMVC/"},{"name":"杂谈","slug":"杂谈","link":"/categories/杂谈/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"}]}