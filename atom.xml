<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-04-14T23:35:14.210Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</title>
    <link href="http://www.javaboy.org/2020/0414/oauth2_authorization_code.html"/>
    <id>http://www.javaboy.org/2020/0414/oauth2_authorization_code.html</id>
    <published>2020-04-13T23:15:51.000Z</published>
    <updated>2020-04-14T23:35:14.210Z</updated>
    
    <content type="html"><![CDATA[<p>昨天和小伙伴们介绍了 OAuth2 的基本概念，在讲解 Spring Cloud Security OAuth2 之前，我还是先来通过实际代码来和小伙伴们把 OAuth2 中的各个授权模式走一遍，今天我们来看最常用也最复杂的授权码模式。</p><a id="more"></a><p>本文我将通过一个<strong>完整的 Demo</strong> ，注意，是一个<strong>完整的 Demo</strong>，带领小伙伴们把授权码模式走一遍。</p><p>如果小伙伴们还没有看上篇文章可以先看下，这有助于你理解本文中的一些概念：</p><ul><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li></ul><h2 id="1-案例架构"><a href="#1-案例架构" class="headerlink" title="1.案例架构"></a>1.案例架构</h2><p>因为 OAuth2 涉及到的东西比较多，网上的案例大多都是简化的，对于很多初学者而言，简化的案例看的人云里雾里，所以松哥这次想自己搭建一个完整的测试案例，在这个案例中，主要包括如下服务：</p><ul><li>第三方应用</li><li>授权服务器</li><li>资源服务器</li><li>用户</li></ul><p>我用一个表格来给大家整理下：</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">端口</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">auth-server</td><td style="text-align:left">8080</td><td style="text-align:left">授权服务器</td></tr><tr><td style="text-align:left">user-server</td><td style="text-align:left">8081</td><td style="text-align:left">资源服务器</td></tr><tr><td style="text-align:left">client-app</td><td style="text-align:left">8082</td><td style="text-align:left">第三方应用</td></tr></tbody></table><p>就是说，我们常见的 OAuth2 授权码模式登录中，涉及到的各个角色，我都会自己提供，自己测试，这样可以最大限度的让小伙伴们了解到 OAuth2 的工作原理（文末可以下载案例源码）。</p><p>注意：小伙伴们一定先看下<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>松哥所讲的 OAuth2 授权码模式登录流程，再来学习本文。</p><p>那我们首先来创建一个空的 Maven 父工程，创建好之后，里边什么都不用加，也不用写代码。我们将在这个父工程中搭建这个子模块。</p><h2 id="2-授权服务器搭建"><a href="#2-授权服务器搭建" class="headerlink" title="2.授权服务器搭建"></a>2.授权服务器搭建</h2><p>首先我们搭建一个名为 auth-server 的授权服务，搭建的时候，选择如下三个依赖：</p><ul><li>web</li><li>spring cloud security</li><li>spirng cloud OAuth2</li></ul><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建完成后，首先提供一个 Spring Security 的基本配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">                .password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable().formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，为了代码简洁，我就不把 Spring Security 用户存到数据库中去了，直接存在内存中。</p><p>这里我创建了一个名为 sang 的用户，密码是 123，角色是 admin。同时我还配置了一个表单登录。</p><p>这段配置的目的，实际上就是配置用户。例如你想用微信登录第三方网站，在这个过程中，你得先登录微信，登录微信就要你的用户名/密码信息，那么我们在这里配置的，其实就是用户的用户名/密码/角色信息。</p><p>基本的用户信息配置完成后，接下来我们来配置授权服务器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessTokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryTokenStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthorizationServerTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DefaultTokenServices services = <span class="hljs-keyword">new</span> DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(<span class="hljs-keyword">true</span>);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">2</span>);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        security.checkTokenAccess(<span class="hljs-string">"permitAll()"</span>)</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .resourceIds(<span class="hljs-string">"res1"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>,<span class="hljs-string">"refresh_token"</span>)</span><br><span class="line">                .scopes(<span class="hljs-string">"all"</span>)</span><br><span class="line">                .redirectUris(<span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">                .tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthorizationCodeServices <span class="hljs-title">authorizationCodeServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryAuthorizationCodeServices();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有点长，我来给大家挨个解释：</p><ol><li>首先我们提供了一个 TokenStore 的实例，这个是指你生成的 Token 要往哪里存储，我们可以存在 Redis 中，也可以存在内存中，也可以结合 JWT 等等，这里，我们就先把它存在内存中，所以提供一个 InMemoryTokenStore 的实例即可。</li><li>接下来我们创建 AuthorizationServer 类继承自 AuthorizationServerConfigurerAdapter，来对授权服务器做进一步的详细配置，AuthorizationServer 类记得加上 @EnableAuthorizationServer 注解，表示开启授权服务器的自动化配置。</li><li>在 AuthorizationServer 类中，我们其实主要重写三个 configure 方法。</li><li>AuthorizationServerSecurityConfigurer 用来配置令牌端点的安全约束，也就是这个端点谁能访问，谁不能访问。checkTokenAccess 是指一个 Token 校验的端点，这个端点我们设置为可以直接访问（在后面，当资源服务器收到 Token 之后，需要去校验 Token 的合法性，就会访问这个端点）。</li><li>ClientDetailsServiceConfigurer 用来配置客户端的详细信息，在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>中，松哥和大家讲过，授权服务器要做两方面的检验，一方面是校验客户端，另一方面则是校验用户，校验用户，我们前面已经配置了，这里就是配置校验客户端。客户端的信息我们可以存在数据库中，这其实也是比较容易的，和用户信息存到数据库中类似，但是这里为了简化代码，我还是将客户端信息存在内存中，这里我们分别配置了客户端的 id，secret、资源 id、授权类型、授权范围以及重定向 uri。授权类型我在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>中和大家一共讲了四种，四种之中不包含 refresh_token 这种类型，但是在实际操作中，refresh_token 也被算作一种。</li><li>AuthorizationServerEndpointsConfigurer 这里用来配置令牌的访问端点和令牌服务。authorizationCodeServices用来配置授权码的存储，这里我们是存在在内存中，tokenServices 用来配置令牌的存储，即 access_token 的存储位置，这里我们也先存储在内存中。有小伙伴会问，授权码和令牌有什么区别？授权码是用来获取令牌的，使用一次就失效，令牌则是用来获取资源的，如果搞不清楚，建议重新阅读上篇文章恶补一下：<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li>tokenServices 这个 Bean 主要用来配置 Token 的一些基本信息，例如 Token 是否支持刷新、Token 的存储位置、Token 的有效期以及刷新 Token 的有效期等等。Token 有效期这个好理解，刷新 Token 的有效期我说一下，当 Token 快要过期的时候，我们需要获取一个新的 Token，在获取新的 Token 时候，需要有一个凭证信息，这个凭证信息不是旧的 Token，而是另外一个 refresh_token，这个 refresh_token 也是有有效期的。</li></ol><p>好了，如此之后，我们的授权服务器就算是配置完成了，接下来我们启动授权服务器。</p><h2 id="3-资源服务器搭建"><a href="#3-资源服务器搭建" class="headerlink" title="3.资源服务器搭建"></a>3.资源服务器搭建</h2><p>接下来我们搭建一个资源服务器。大家网上看到的例子，资源服务器大多都是和授权服务器放在一起的，如果项目比较小的话，这样做是没问题的，但是如果是一个大项目，这种做法就不合适了。</p><p>资源服务器就是用来存放用户的资源，例如你在微信上的图像、openid 等信息，用户从授权服务器上拿到 access_token 之后，接下来就可以通过 access_token 来资源服务器请求数据。</p><p>我们创建一个新的 Spring Boot 项目，叫做 user-server ，作为我们的资源服务器，创建时，添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建成功之后，添加如下配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">RemoteTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        RemoteTokenServices services = <span class="hljs-keyword">new</span> RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(<span class="hljs-string">"http://localhost:8080/oauth/check_token"</span>);</span><br><span class="line">        services.setClientId(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        services.setClientSecret(<span class="hljs-string">"123"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(<span class="hljs-string">"res1"</span>).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置代码很简单，我简单的说一下：</p><ol><li>tokenServices 我们配置了一个 RemoteTokenServices 的实例，这是因为资源服务器和授权服务器是分开的，资源服务器和授权服务器是放在一起的，就不需要配置 RemoteTokenServices 了。</li><li>RemoteTokenServices 中我们配置了 access_token 的校验地址、client_id、client_secret 这三个信息，当用户来资源服务器请求资源时，会携带上一个 access_token，通过这里的配置，就能够校验出 token 是否正确等。</li><li>最后配置一下资源的拦截规则，这就是 Spring Security 中的基本写法，我就不再赘述。</li></ol><p>接下来我们再来配置两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此之后，我们的资源服务器就算配置成功了。</p><h2 id="4-第三方应用搭建"><a href="#4-第三方应用搭建" class="headerlink" title="4.第三方应用搭建"></a>4.第三方应用搭建</h2><p>接下来搭建我们的第三方应用程序。</p><p>注意，第三方应用并非必须，下面所写的代码也可以用 POSTMAN 去测试，这个小伙伴们可以自行尝试。</p><p>第三方应用就是一个普通的 Spring Boot 工程，创建时加入 Thymeleaf 依赖和 Web 依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-2.png" alt></p><p>在 resources/templates 目录下，创建 index.html ，内容如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>江南一点雨<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">你好，江南一点雨！</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://localhost:8080/oauth/authorize?client_id=javaboy&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://localhost:8082/index.html"</span>&gt;</span>第三方登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;msg&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一段 Thymeleaf 模版，点击超链接就可以实现第三方登录，超链接的参数如下：</p><ul><li>client_id 客户端 ID，根据我们在授权服务器中的实际配置填写。</li><li>response_type 表示响应类型，这里是 code 表示响应一个授权码。</li><li>redirect_uri 表示授权成功后的重定向地址，这里表示回到第三方应用的首页。</li><li>scope 表示授权范围。</li></ul><p>h1 标签中的数据是来自资源服务器的，当授权服务器通过后，我们拿着 access_token 去资源服务器加载数据，加载到的数据就在 h1 标签中显示出来。</p><p>接下来我们来定义一个 HelloController：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index.html"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String code, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (code != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            MultiValueMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add(<span class="hljs-string">"code"</span>, code);</span><br><span class="line">            map.add(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"redirect_uri"</span>, <span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"authorization_code"</span>);</span><br><span class="line">            Map&lt;String,String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>, map, Map.class);</span><br><span class="line">            String access_token = resp.get(<span class="hljs-string">"access_token"</span>);</span><br><span class="line">            System.out.println(access_token);</span><br><span class="line">            HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();</span><br><span class="line">            headers.add(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer "</span> + access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(headers);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange(<span class="hljs-string">"http://localhost:8081/admin/hello"</span>, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">            model.addAttribute(<span class="hljs-string">"msg"</span>, entity.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 HelloController 中，我们定义出 /index.html 的地址。</p><p>如果 code 不为 null，也就是如果是通过授权服务器重定向到这个地址来的，那么我们做如下两个操作：</p><ol><li>根据拿到的 code，去请求 <code>http://localhost:8080/oauth/token</code> 地址去获取 Token，返回的数据结构如下：</li></ol><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"e7f223c4-7543-43c0-b5a6-5011743b5af4"</span>,</span><br><span class="line">    <span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,</span><br><span class="line">    <span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string">"aafc167b-a112-456e-bbd8-58cb56d915dd"</span>,</span><br><span class="line">    <span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">7199</span>,</span><br><span class="line">    <span class="hljs-attr">"scope"</span>: <span class="hljs-string">"all"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>access_token 就是我们请求数据所需要的令牌，refresh_token 则是我们刷新 token 所需要的令牌，expires_in 表示 token 有效期还剩多久。</p><ol start="2"><li>接下来，根据我们拿到的 access_token，去请求资源服务器，注意 access_token 通过请求头传递，最后将资源服务器返回的数据放到 model 中。</li></ol><p><strong>这里我只是举一个简单的例子，目的是和大家把这个流程走通，正常来说，access_token 我们可能需要一个定时任务去维护，不用每次请求页面都去获取，定期去获取最新的 access_token 即可。后面的文章中，松哥还会继续完善这个案例，到时候再来和大家解决这些细节问题。</strong></p><p>OK，代码写完后，我们就可以启动第三方应用开始测试了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>接下来我们去测试。</p><p>首先我们去访问 <code>http://localhost:8082/index.html</code> 页面，结果如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-3.png" alt></p><p>然后我们点击 第三方登录 这个超链接，点完之后，会进入到授权服务器的默认登录页面：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-4.png" alt></p><p>接下来我们输入在授权服务器中配置的用户信息来登录，登录成功后，会看到如下页面：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-5.png" alt></p><p>在这个页面中，我们可以看到一个提示，询问是否授权 javaboy 这个用户去访问被保护的资源，我们选择 approve(批准)，然后点击下方的 Authorize 按钮，点完之后，页面会自动跳转回我的第三方应用中：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-6.png" alt></p><p>大家注意，这个时候地址栏多了一个 code 参数，这就是授权服务器给出的授权码，拿着这个授权码，我们就可以去请求 access_token，授权码使用一次就会失效。</p><p>同时大家注意到页面多了一个 admin，这个 admin 就是从资源服务器请求到的数据。</p><p>当然，我们在授权服务器中配置了两个用户，大家也可以尝试用 javaboy/123 这个用户去登录，因为这个用户不具备 admin 角色，所以使用这个用户将无法获取到 admin 这个字符串，报错信息如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-7.png" alt></p><p>这个小伙伴们可以自己去测试，我就不再演示了。</p><p>最后在说一句，这不是终极版，只是一个雏形，后面的文章，松哥再带大家来继续完善这个案例。</p><p>好了，本文案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>如果小伙伴们觉得有用的话，记得点个在看鼓励下松哥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天和小伙伴们介绍了 OAuth2 的基本概念，在讲解 Spring Cloud Security OAuth2 之前，我还是先来通过实际代码来和小伙伴们把 OAuth2 中的各个授权模式走一遍，今天我们来看最常用也最复杂的授权码模式。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</title>
    <link href="http://www.javaboy.org/2020/0413/oauth2-info.html"/>
    <id>http://www.javaboy.org/2020/0413/oauth2-info.html</id>
    <published>2020-04-12T23:15:34.000Z</published>
    <updated>2020-04-14T23:35:28.591Z</updated>
    
    <content type="html"><![CDATA[<p>最近在更新 Spring Security 系列，不知不觉已经更新了 6 篇了，要聊 Spring Security，当然就绕不过 OAuth2，但是有很多小伙伴等不及了，不停的追问 OAuth2 的相关技能点，所以我也抽空撸几篇文章，来和大家把 OAuth2 好好的捋一捋，也顺便回顾一下松哥关于 OAuth2 的一些使用经验。</p><a id="more"></a><p>OAuth2 很多小伙伴看过千千万万遍，四种授权模式、认证流程早已烂熟于心，但是就是写不出来代码。所以松哥这次将结合自己的使用经验，再搞一个完整的配套案例，分享给大家。当然这里涉及到的条条框框可能就比较多了，所以我这里可能会分几篇文章来讲解，本文是第一篇。</p><p>当然呢，大家学习这篇文章，建议还是先把已经更新的 Spring Security 系列看一看，入个门：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li></ol><p>好了，不说废话，咱们来看 OAuth2。</p><h2 id="1-为什么需要-OAuth2"><a href="#1-为什么需要-OAuth2" class="headerlink" title="1.为什么需要 OAuth2"></a>1.为什么需要 OAuth2</h2><p>关于我们为什么需要 OAuth2 的问题，网上的文章很多，我们常见的第三方登录就是一个 OAuth2 的典型应用，阮一峰大佬之前有一篇文章非常形象的解释了这个问题，内容如下（原文地址：<a href="https://www.ruanyifeng.com/blog/2019/04/oauth_design.html）：" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2019/04/oauth_design.html）：</a></p><h3 id="1-1-快递员问题"><a href="#1-1-快递员问题" class="headerlink" title="1.1 快递员问题"></a>1.1 快递员问题</h3><p>我住在一个大型的居民小区。</p><p><img src="http://img.itboyhub.com/2020/04/oath.png" alt></p><p>小区有门禁系统。</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-2.png" alt></p><p>进入的时候需要输入密码。</p><p><img src="http://img.itboyhub.com/2020/04/oath-1-3.png" alt></p><p>我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区。</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-4.png" alt></p><p>如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。</p><p>有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？</p><h3 id="1-2-授权机制的设计"><a href="#1-2-授权机制的设计" class="headerlink" title="1.2 授权机制的设计"></a>1.2 授权机制的设计</h3><p>于是，我设计了一套授权机制。</p><p>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</p><p>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p><p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p><p>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p><p>第四步，快递员向门禁系统输入令牌，进入小区。</p><p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p><h3 id="1-3-互联网场景"><a href="#1-3-互联网场景" class="headerlink" title="1.3 互联网场景"></a>1.3 互联网场景</h3><p>我们把上面的例子搬到互联网，就是 OAuth 的设计了。</p><p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p><p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p><p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p><p>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</p><h3 id="1-4-令牌与密码"><a href="#1-4-令牌与密码" class="headerlink" title="1.4 令牌与密码"></a>1.4 令牌与密码</h3><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p><p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。 这也是为什么令牌的有效期，一般都设置得很短的原因。</p><p>OAuth2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。</p><p>这段看完，相信大家已经大概明白 OAuth2 的作用了。</p><h2 id="2-什么是-OAuth2"><a href="#2-什么是-OAuth2" class="headerlink" title="2.什么是 OAuth2"></a>2.什么是 OAuth2</h2><p>看完了阮一峰大佬的介绍，那么接下来松哥再从协议的角度来和大家聊一聊 OAuth2。</p><p>OAuth 是一个开放标准，该标准允许用户让第三方应用访问该用户在某一网站上存储的私密资源（如头像、照片、视频等），而在这个过程中无需将用户名和密码提供给第三方应用。实现这一功能是通过提供一个令牌（token），而不是用户名和密码来访问他们存放在特定服务提供者的数据。采用令牌（token）的方式可以让用户灵活的对第三方应用授权或者收回权限。</p><p>OAuth2 是 OAuth 协议的下一版本，但不向下兼容 OAuth 1.0。传统的 Web 开发登录认证一般都是基于 session 的，但是在前后端分离的架构中继续使用 session 就会有许多不便，因为移动端（Android、iOS、微信小程序等）要么不支持 cookie（微信小程序），要么使用非常不便，对于这些问题，使用 OAuth2 认证都能解决。</p><p>对于大家而言，我们在互联网应用中最常见的 OAuth2 应该就是各种第三方登录了，例如 QQ 授权登录、微信授权登录、微博授权登录、GitHub 授权登录等等。</p><h2 id="3-四种模式"><a href="#3-四种模式" class="headerlink" title="3.四种模式"></a>3.四种模式</h2><p>OAuth2 协议一共支持 4 种不同的授权模式：</p><ol><li>授权码模式：常见的第三方平台登录功能基本都是使用这种模式。</li><li>简化模式：简化模式是不需要客户端服务器参与，直接在浏览器中向授权服务器申请令牌（token），一般如果网站是纯静态页面则可以采用这种方式。</li><li>密码模式：密码模式是用户把用户名密码直接告诉客户端，客户端使用说这些信息向授权服务器申请令牌（token）。这需要用户对客户端高度信任，例如客户端应用和服务提供商就是同一家公司，我们自己做前后端分离登录就可以采用这种模式。</li><li>客户端模式：客户端模式是指客户端使用自己的名义而不是用户的名义向服务提供者申请授权，严格来说，客户端模式并不能算作 OAuth 协议要解决的问题的一种解决方案，但是，对于开发者而言，在一些前后端分离应用或者为移动端提供的认证授权服务器上使用这种模式还是非常方便的。</li></ol><h3 id="3-1-授权码模式"><a href="#3-1-授权码模式" class="headerlink" title="3.1 授权码模式"></a>3.1 授权码模式</h3><p>授权码模式是最安全并且使用最广泛的一种模式。以松哥的 <a href="www.javaboy.org">www.javaboy.org</a> 为例，假如我要引入微信登录功能，那么我的流程可能是这样：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-7.png" alt="图片源自网络"></p><p>在授权码模式中，我们分授权服务器和资源服务器，授权服务器用来派发 Token，拿着 Token 则可以去资源服务器获取资源，这两个服务器可以分开，也可以合并。</p><p>上面这张流程图的含义，具体是这样：</p><ol><li>首先，我会在我的 <a href="http://www.javaboy.org">www.javaboy.org</a> 这个网页上放一个超链接（我的网站相当于是第三方应用），用户 A （服务方的用户，例如微信用户）点击这个超链接就会去请求授权服务器（微信的授权服务器），用户点击的过程其实也就是我跟用户要授权的过程，这就是上图中的 1、2 步。</li><li>接下来的第三步，就是用户点击了超链接之后，像授权服务器发送请求，一般来说，我放在 <a href="http://www.javaboy.org">www.javaboy.org</a> 网页上的超链接可能有如下参数：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wx.qq.com/oauth/authorize?response_type=code&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all</span><br></pre></td></tr></table></figure><p>这里边有好几个参数，在后面的代码中我们都会用到，这里先和大家简单解释一下：</p><ul><li>response_type 表示授权类型，使用授权码模式的时候这里固定为 code，表示要求返回授权码（将来拿着这个授权码去获取 access_token）。</li><li>client_id 表示客户端 id，也就是我应用的 id。有的小伙伴对这个不好理解，我说一下，如果我想让我的 <a href="http://www.javaboy.org">www.javaboy.org</a> 接入微信登录功能，我肯定得去微信开放平台注册，去填入我自己应用的基本信息等等，弄完之后，微信会给我一个 APPID，也就是我这里的 client_id，所以，从这里可以看出，授权服务器在校验的时候，会做两件事：1.校验客户端的身份；2.校验用户身份。</li><li>redirect_uri 表示用户登录在成功/失败后，跳转的地址（成功登录微信后，跳转到 <a href="http://www.javaboy.org">www.javaboy.org</a> 中的哪个页面），跳转的时候，还会携带上一个授权码参数。</li><li>scope 表示授权范围，即 <a href="http://www.javaboy.org">www.javaboy.org</a> 这个网站拿着用户的 token 都能干啥（一般来说就是获取用户非敏感的基本信息）。</li></ul><ol start="3"><li>接下来第四步，<a href="http://www.javaboy.org">www.javaboy.org</a> 这个网站，拿着第三步获取到的 code 以及自己的 client_id 和 client_secret 以及其他一些信息去授权服务器请求令牌，微信的授权服务器在校验过这些数据之后，就会发送一个令牌回来。这个过程一般是在后端完成的，而不是利用 js 去完成。</li><li>接下来拿着这个 token，我们就可以去请求用户信息了。</li></ol><p>一般情况下我们认为授权码模式是四种模式中最安全的一种模式，因为这种模式我们的 access_token 不用经过浏览器或者移动端 App，是直接从我们的后台发送到授权服务器上，这样就很大程度减少了 access_token 泄漏的风险。</p><p>OK，这是我们介绍的授权码模式。</p><h3 id="3-2-简化模式"><a href="#3-2-简化模式" class="headerlink" title="3.2 简化模式"></a>3.2 简化模式</h3><p>简化模式是怎么一回事呢？</p><p>松哥之前发过两篇文章教大家搭建自己的博客：</p><ul><li><a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a></li><li><a href="https://mp.weixin.qq.com/s/_W1Ism-pyarB1u2wX-gCFw" target="_blank" rel="noopener">不花一分钱，把自己零散的知识整理成体系，制作成在线电子书</a></li></ul><p>这两种技术栈搭建的博客/电子书都是典型的纯前端应用，就是只有页面，没有后端，对于这种情况，如果我想接入微信登录该怎么办呢？这就用到了我们说的简化模式。</p><p>我们来看下简化模式的流程图：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-8.png" alt="图片源自网络"></p><p>这个流程是这样：</p><ol><li>在我 <a href="http://www.javaboy.org">www.javaboy.org</a> 网站上有一个微信登录的超链接，这个超链接类似下面这样：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wx.qq.com/oauth/authorize?response_type=token&amp;client_id=javaboy&amp;redirect_uri=www.javaboy.org&amp;scope=all</span><br></pre></td></tr></table></figure><p>这里的参数和前面授权码模式的基本相同，只有 response_type 的值不一样，这里是 token，表示要求授权服务器直接返回 access_token。</p><ol start="2"><li>用户点击我这个超链接之后，就会跳转到微信登录页面，然后用户进行登录。</li><li>用户登录成功后，微信会自动重定向到 redirect_uri 参数指定的跳转网址，同时携带上 access_token，这样用户在前端就获取到 access_token 了。</li></ol><p>简化模式的弊端很明显，因为没有后端，所以非常不安全，除非你对安全性要求不高，否则不建议使用。</p><h3 id="3-3-密码模式"><a href="#3-3-密码模式" class="headerlink" title="3.3 密码模式"></a>3.3 密码模式</h3><p>密码模式在 Spring Cloud 项目中有着非常广泛的应用，这块松哥在本系列后面的文章中会重点讲解，这里我们先来了解下密码模式是怎么一回事。</p><p>密码模式有一个前提就是你高度信任第三方应用，举个不恰当的例子：如果我要在 <a href="http://www.javaboy.org">www.javaboy.org</a> 这个网站上接入微信登录，我使用了密码模式，那你就要在 <a href="http://www.javaboy.org">www.javaboy.org</a> 这个网站去输入微信的用户名密码，这肯定是不靠谱的，所以密码模式需要你非常信任第三方应用。</p><p>微服务中有一个特殊的场景，就是服务之间的调用，用密码模式做鉴权是非常恰当不过的了。这个以后再细说。</p><p>我们来看下密码模式的流程：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-9.png" alt></p><p>密码式的流程比较简单：</p><ol><li>首先 <a href="http://www.javaboy.org">www.javaboy.org</a> 会发送一个 post 请求，类似下面这样的：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wx.qq.com/oauth/authorize?response_type=password&amp;client_id=javaboy&amp;username=江南一点雨&amp;password=123</span><br></pre></td></tr></table></figure><p>这里的参数和前面授权码模式的略有差异，response_type 的值不一样，这里是 password，表示密码式，另外多了用户名/密码参数，没有重定向的 redirect_uri ，因为这里不需要重定向。</p><ol start="2"><li>微信校验过用户名/密码之后，直接在 HTTP 响应中把 access_token 返回给客户端。</li></ol><p>OK，这就是密码模式的流程。</p><h3 id="3-4-客户端模式"><a href="#3-4-客户端模式" class="headerlink" title="3.4 客户端模式"></a>3.4 客户端模式</h3><p>有的应用可能没有前端页面，就是一个后台，例如松哥之前发的两篇公众号后台开发的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw" target="_blank" rel="noopener">Spring Boot 开发微信公众号后台，看看松哥公众号后台是怎么实现的！</a></li><li><a href="https://mp.weixin.qq.com/s/1jTl9kBeFeibjbe5EbsCzg" target="_blank" rel="noopener">Spring Boot 如何给微信公众号返回消息</a></li></ul><p>这种应用开发好了就没有后台。</p><p>我们来看一个客户端模式的流程图：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-10.png" alt></p><p>这个步骤也很简单，就两步：</p><ol><li>客户端发送一个请求到授权服务器，请求格式如下：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;client_id=APPID&amp;client_secret=APPSECRET</span><br></pre></td></tr></table></figure><p>这里有三个参数，含义如下：</p><ul><li>grant_type，获取access_token填写client_credential</li><li>client_id 和 client_secret 用来确认客户端的身份</li></ul><ol start="2"><li>授权服务器通过验证后，会直接返回 access_token 给客户端。</li></ol><p>大家发现，在这个过程中好像没有用户什么事了！是的，客户端模式给出的令牌，就是针对第三方应用的，而不是针对用户的。</p><p>在接入微信公众号后台的时候，有一个获取 Access_token 的步骤，其实就是这种模式，我截了一张微信开发平台文档的图，大家看下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-1-11.png" alt></p><p>可以看到，这其实就是客户端模式。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>其实基于微信公众号的开发，对于 OAuth2 玩的很溜，如果小伙伴们感兴趣，可以看看微信公众号的开发文档，结合松哥这篇文章，相信大家对于 OAuth2 会有一个更加深刻的认识。</p><p>微信公众平台地址：<a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html</a></p><p>好了，今天就先和大家说这么多，下篇文章，我们上代码来讲解 Spring Cloud Security OAuth2。</p><p>参考资料：</p><ol><li><a href="https://curity.io/resources/oauth/" target="_blank" rel="noopener">https://curity.io/resources/oauth/</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a></li><li><a href="https://segmentfault.com/a/1190000010540911" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010540911</a></li><li><a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在更新 Spring Security 系列，不知不觉已经更新了 6 篇了，要聊 Spring Security，当然就绕不过 OAuth2，但是有很多小伙伴等不及了，不停的追问 OAuth2 的相关技能点，所以我也抽空撸几篇文章，来和大家把 OAuth2 好好的捋一捋，也顺便回顾一下松哥关于 OAuth2 的一些使用经验。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>玩转 IDEA 之狂拽炫酷的列编辑</title>
    <link href="http://www.javaboy.org/2020/0411/idea.html"/>
    <id>http://www.javaboy.org/2020/0411/idea.html</id>
    <published>2020-04-10T23:15:17.000Z</published>
    <updated>2020-04-14T23:41:11.506Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个视频教程，视频链接：<a href="https://mp.weixin.qq.com/s/S63uFEiVtE9T7oLUmx7ISg" target="_blank" rel="noopener">—–&gt;&gt;&gt;&gt;&gt;&gt;&gt;没错，点我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个视频教程，视频链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/S63uFEiVtE9T7oLUmx7ISg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;—–&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;没错
      
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/categories/IntelliJ-IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 如何将用户数据存入数据库？</title>
    <link href="http://www.javaboy.org/2020/0409/spring-security-JdbcUserDetailsManager.html"/>
    <id>http://www.javaboy.org/2020/0409/spring-security-JdbcUserDetailsManager.html</id>
    <published>2020-04-08T23:14:58.000Z</published>
    <updated>2020-04-14T23:42:09.173Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">本文配套视频地址</a></p><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><a id="more"></a><p>以下是视频笔记。</p><p>Spring Security 介绍到现在，我们还没连上数据库呢。</p><p>真正的项目中，大部分情况下，我们都是自己设计权限数据库，例如微人事（<a href="https://github.com/lenve/vhr）项目那样。" target="_blank" rel="noopener">https://github.com/lenve/vhr）项目那样。</a></p><p>不过，Spring Security 也给我们提供了一个它自己设计好的权限数据库，这里我们先来看看这是怎么回事！先来学这个简单的，然后我们再去看复杂的。</p><p>另外，松哥最近发在公众号上的视频也都在 B 站同步了一份，B 站更方便将视频做成一个系列，像下面这样：</p><p><img src="http://img.itboyhub.com/2020/04/springsecurity-6-1.jpg" alt></p><p>大家可以来 B 站找我，B 站搜索 <strong>江南一点雨</strong> 或者扫描下面二维码就能找到。</p><p><img src="http://img.itboyhub.com/2020/04/springsecurity-6-2.png" alt></p><h2 id="1-UserDetailService"><a href="#1-UserDetailService" class="headerlink" title="1.UserDetailService"></a>1.UserDetailService</h2><p>Spring Security 支持多种不同的数据源，这些不同的数据源最终都将被封装成 UserDetailsService 的实例，在微人事（<a href="https://github.com/lenve/vhr）项目中，我们是自己来创建一个类实现" target="_blank" rel="noopener">https://github.com/lenve/vhr）项目中，我们是自己来创建一个类实现</a> UserDetailsService 接口，除了自己封装，我们也可以使用系统默认提供的 UserDetailsService 实例，例如上篇文章和大家介绍的 InMemoryUserDetailsManager 。</p><p>我们来看下 UserDetailsService 都有哪些实现类：</p><p><img src="http://img.itboyhub.com/2020/04/springsecurity-6-3.png" alt></p><p>可以看到，在几个能直接使用的实现类中，除了 InMemoryUserDetailsManager 之外，还有一个 JdbcUserDetailsManager，使用 JdbcUserDetailsManager 可以让我们通过 JDBC 的方式将数据库和 Spring Security 连接起来。</p><h2 id="2-JdbcUserDetailsManager"><a href="#2-JdbcUserDetailsManager" class="headerlink" title="2.JdbcUserDetailsManager"></a>2.JdbcUserDetailsManager</h2><p>JdbcUserDetailsManager 自己提供了一个数据库模型，这个数据库模型保存在如下位置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org/springframework/security/core/userdetails/jdbc/users.ddl</span><br></pre></td></tr></table></figure><p>这里存储的脚本内容如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">users</span>(username varchar_ignorecase(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> primary <span class="hljs-keyword">key</span>,<span class="hljs-keyword">password</span> varchar_ignorecase(<span class="hljs-number">500</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,enabled <span class="hljs-built_in">boolean</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>);</span><br><span class="line"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> authorities (username varchar_ignorecase(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,authority varchar_ignorecase(<span class="hljs-number">50</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<span class="hljs-keyword">constraint</span> fk_authorities_users <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span>(username) <span class="hljs-keyword">references</span> <span class="hljs-keyword">users</span>(username));</span><br><span class="line"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> <span class="hljs-keyword">index</span> ix_auth_username <span class="hljs-keyword">on</span> authorities (username,authority);</span><br></pre></td></tr></table></figure><p>可以看到，脚本中有一种数据类型 varchar_ignorecase，这个其实是针对 HSQLDB 数据库创建的，而我们使用的 MySQL 并不支持这种数据类型，所以这里需要大家手动调整一下数据类型，将 varchar_ignorecase 改为 varchar 即可。</p><p>修改完成后，创建数据库，执行完成后的脚本。</p><p>执行完 SQL 脚本后，我们可以看到一共创建了两张表：users 和 authorities。</p><ul><li>users 表中保存用户的基本信息，包括用户名、用户密码以及账户是否可用。</li><li>authorities 中保存了用户的角色。</li><li>authorities 和 users 通过 username 关联起来。</li></ul><p>配置完成后，接下来，我们将上篇文章中通过 InMemoryUserDetailsManager 提供的用户数据用 JdbcUserDetailsManager 代替掉，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    JdbcUserDetailsManager manager = <span class="hljs-keyword">new</span> JdbcUserDetailsManager();</span><br><span class="line">    manager.setDataSource(dataSource);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!manager.userExists(<span class="hljs-string">"javaboy"</span>)) &#123;</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!manager.userExists(<span class="hljs-string">"江南一点雨"</span>)) &#123;</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"user"</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置的含义如下：</p><ol><li>首先构建一个 JdbcUserDetailsManager 实例。</li><li>给 JdbcUserDetailsManager 实例添加一个 DataSource 对象。</li><li>调用 userExists 方法判断用户是否存在，如果不存在，就创建一个新的用户出来（因为每次项目启动时这段代码都会执行，所以加一个判断，避免重复创建用户）。</li><li>用户的创建方法和我们之前 InMemoryUserDetailsManager 中的创建方法基本一致。</li></ol><p>这里的 createUser 或者 userExists 方法其实都是调用写好的 SQL 去判断的，我们从它的源码里就能看出来（部分）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcUserDetailsManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JdbcDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsManager</span>,</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">GroupManager</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEF_USER_EXISTS_SQL = <span class="hljs-string">"select username from users where username = ?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> String userExistsSql = DEF_USER_EXISTS_SQL;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">userExists</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; users = getJdbcTemplate().queryForList(userExistsSql,</span><br><span class="line"><span class="hljs-keyword">new</span> String[] &#123; username &#125;, String.class);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (users.size() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IncorrectResultSizeDataAccessException(</span><br><span class="line"><span class="hljs-string">"More than one user found with name '"</span> + username + <span class="hljs-string">"'"</span>, <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> users.size() == <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码中就可以看出来，userExists 方法的执行逻辑其实就是调用 JdbcTemplate 来执行预定义好的 SQL 脚本，进而判断出用户是否存在，其他的判断方法都是类似，我就不再赘述。</p><h2 id="3-数据库支持"><a href="#3-数据库支持" class="headerlink" title="3.数据库支持"></a>3.数据库支持</h2><p>通过前面的代码，大家看到这里需要数据库支持，所以我们在项目中添加如下两个依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再在 application.properties 中配置一下数据库连接：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123</span><br><span class="line">spring.datasource.url=jdbc:mysql:///security?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><p>配置完成后，就可以启动项目。</p><p>项目启动成功后，我们就可以看到数据库中自动添加了两个用户进来，并且用户都配置了角色。如下图：</p><p><img src="http://img.itboyhub.com/2020/04/security-6-4.png" alt><br><img src="http://img.itboyhub.com/2020/04/security-6-5.png" alt></p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>接下来我们就可以进行测试了。</p><p>我们首先以 江南一点雨的身份进行登录：</p><p><img src="http://img.itboyhub.com/2020/04/security-5-2.png" alt></p><p>登录成功后，分别访问 <code>/hello</code>，<code>/admin/hello</code> 以及 <code>/user/hello</code> 三个接口，其中：</p><ol><li><code>/hello</code> 因为登录后就可以访问，这个接口访问成功。</li><li><code>/admin/hello</code> 需要 admin 身份，所以访问失败。</li><li><code>/user/hello</code> 需要 user 身份，所以访问成功。</li></ol><p>具体测试效果小伙伴们可以参考松哥的视频，我就不截图了。</p><p>在测试的过程中，如果在数据库中将用户的 enabled 属性设置为 false，表示禁用该账户，此时再使用该账户登录就会登录失败。</p><p>按照相同的方式，大家也可以测试 javaboy 用户。</p><p>好了，今天就和小伙伴们说这么多.</p><p><strong>感谢小伙伴们的阅读，如果觉得有用，毫不犹豫的点个在看鼓励下松哥，我会以风驰电掣般的速度快速更完这个系列～</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文配套视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 &lt;a href=&quot;https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot + Vue 系列视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>推荐七个略火的Spring Boot+Vue开源项目</title>
    <link href="http://www.javaboy.org/2020/0409/springboot-vue.html"/>
    <id>http://www.javaboy.org/2020/0409/springboot-vue.html</id>
    <published>2020-04-08T23:14:40.000Z</published>
    <updated>2020-04-14T23:37:26.090Z</updated>
    
    <content type="html"><![CDATA[<p>前后端分离已经在慢慢走进各公司的技术栈，根据松哥了解到的消息，不少公司都已经切换到这个技术栈上面了。即使贵司目前没有切换到这个技术栈上面，松哥也非常建议大家学习一下前后端分离开发，以免在公司干了两三年，SSH 框架用的滚瓜烂熟，出来却发现自己依然没有任何优势！</p><a id="more"></a><p>其实前后端分离本身并不难，后段提供接口，前端做数据展示，关键是这种思想。很多人做惯了前后端不分的开发，在做前后端分离的时候，很容易带进来一些前后端不分时候的开发思路，结果做出来的产品不伦不类，因此松哥这里给大家整理了几个开源的前后端分离项目，帮助大家快速掌握前后端分离开发技术栈。</p><h2 id="美人鱼"><a href="#美人鱼" class="headerlink" title="美人鱼"></a>美人鱼</h2><ul><li>star 数 4.2k</li><li>项目地址： <a href="https://gitee.com/mumu-osc/NiceFish" target="_blank" rel="noopener">https://gitee.com/mumu-osc/NiceFish</a></li></ul><p>听名字就知道这是个不错的项目，事实上确实不赖。NiceFish（美人鱼） 是一个系列项目，目标是示范前后端分离的开发模式:前端浏览器、移动端、Electron 环境中的各种开发模式；后端有两个版本：SpringBoot 版本和 SpringCloud 版本，前端有 Angular 、React 以及 Electron 等版本。</p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-1.png" alt></p><h2 id="微人事"><a href="#微人事" class="headerlink" title="微人事"></a>微人事</h2><ul><li>star 数 15.3k</li><li>项目地址：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li></ul><p>微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot + Vue 开发。项目打通了前后端，并且提供了非常详尽的文档，从 Spring Boot 接口设计到前端 Vue 的开发思路，作者全部都记录在项目的 wiki 中，是不可多得的 Java 全栈学习资料。</p><p>项目效果图:</p><p><img src="http://img.itboyhub.com/2020/03/fe-2.png" alt></p><p>项目部分文档截图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-3.png" alt></p><h2 id="bootshiro"><a href="#bootshiro" class="headerlink" title="bootshiro"></a>bootshiro</h2><ul><li>star 数 2.1k</li><li>项目地址： <a href="https://gitee.com/tomsun28/bootshiro" target="_blank" rel="noopener">https://gitee.com/tomsun28/bootshiro</a></li></ul><p>bootshiro 是基于 Spring Boot + Shiro + JWT 的真正 RESTful URL 资源无状态认证权限管理系统的后端,前端 usthe 。区别于一般项目，该项目提供页面可配置式的、动态的 RESTful api 安全管理支持，并且实现数据传输动态秘钥加密，jwt 过期刷新，用户操作监控等，加固应用安全。</p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-4.PNG" alt></p><h2 id="open-capacity-platform"><a href="#open-capacity-platform" class="headerlink" title="open-capacity-platform"></a>open-capacity-platform</h2><ul><li>star 数 4.1k</li><li>项目地址：<a href="https://gitee.com/owenwangwen/open-capacity-platform" target="_blank" rel="noopener">https://gitee.com/owenwangwen/open-capacity-platform</a></li></ul><p>open-capacity-platform 微服务能力开放平台，简称 ocp ，是基于 layui + springcloud 的企业级微服务框架(用户权限管理，配置中心管理，应用管理，….)，其核心的设计目标是分离前后端，快速开发部署，学习简单，功能强大，提供快速接入核心接口能力，其目标是帮助企业搭建一套类似百度能力开放平台的框架。</p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-5.png" alt></p><h2 id="V-部落"><a href="#V-部落" class="headerlink" title="V 部落"></a>V 部落</h2><ul><li>star 数 4.6k</li><li>项目地址：<a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>V部落是一个多用户博客管理平台，采用 Vue + SpringBoot + ElementUI 开发。<strong>这个项目最大的优势是简单，属于功能完整但是又非常简单的那种，非常非常适合初学者。</strong></p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-6.png" alt></p><h2 id="悟空-CRM"><a href="#悟空-CRM" class="headerlink" title="悟空 CRM"></a>悟空 CRM</h2><ul><li>star 数 1.3k</li><li>项目地址：<a href="https://gitee.com/wukongcrm/72crm-java" target="_blank" rel="noopener">https://gitee.com/wukongcrm/72crm-java</a></li></ul><p>悟空 CRM 是基于 jfinal + vue + ElementUI 的前后端分离 CRM 系统。</p><p>老实说，jfinal 了解下就行了，没必要认真研究，Vue + ElementUI 的组合可以认真学习下、前后端交互的方式可以认真学习下。</p><p><img src="http://img.itboyhub.com/2020/03/fe-7.png" alt></p><h2 id="paascloud-master"><a href="#paascloud-master" class="headerlink" title="paascloud-master"></a>paascloud-master</h2><ul><li>star 数 7.5k</li><li>项目地址：<a href="https://github.com/paascloud/paascloud-master" target="_blank" rel="noopener">https://github.com/paascloud/paascloud-master</a></li></ul><p>paascloud-master 核心技术为 SpringCloud + Vue 两个全家桶实现，采取了取自开源用于开源的目标，所以能用开源绝不用收费框架，整体技术栈只有阿里云短信服务是收费的，都是目前 java 前瞻性的框架，可以为中小企业解决微服务架构难题，可以帮助企业快速建站。由于服务器成本较高，尽量降低开发成本的原则，本项目由 10 个后端项目和 3 个前端项目共同组成。真正实现了基于 RBAC、jwt 和 oauth2 的无状态统一权限认证的解决方案，实现了异常和日志的统一管理，实现了 MQ 落地保证 100% 到达的解决方案。</p><p>项目效果图：</p><p><img src="http://img.itboyhub.com/2020/03/fe-8.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>他山之石，可以攻玉。当我们学会了很多知识点之后，需要一个项目来将这些知识点融会贯通，这些开源项目就是很好的资料。现在前后端分离开发方式日渐火热，松哥也强烈建议大家有空学习下这种开发方式。虽然我们身为 Java 工程师，可是也不能固步自封，看看前端单页面应用怎么构建，看看前端工程化是怎么回事，这些都有助于我们开发出更加合理好用的后端接口。好了，七个开源项目，助力大家在全栈的路上更进一步！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前后端分离已经在慢慢走进各公司的技术栈，根据松哥了解到的消息，不少公司都已经切换到这个技术栈上面了。即使贵司目前没有切换到这个技术栈上面，松哥也非常建议大家学习一下前后端分离开发，以免在公司干了两三年，SSH 框架用的滚瓜烂熟，出来却发现自己依然没有任何优势！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中的授权操作原来这么简单</title>
    <link href="http://www.javaboy.org/2020/0408/spring-security-authorization.html"/>
    <id>http://www.javaboy.org/2020/0408/spring-security-authorization.html</id>
    <published>2020-04-07T23:14:25.000Z</published>
    <updated>2020-04-14T23:42:41.768Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">本文配套视频地址</a></p><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><a id="more"></a><p>以下是视频笔记。</p><p>通过前面四篇文章的介绍，Spring Security 中的登录认证我们就先告一个小小段落。在本系列未来的教程中，我们还会继续涉及到 Spring Security 中的登录认证问题，这个我们以后再说。</p><p>本系列前面四篇文章给小伙伴们列一个索引出来，大家可以参考：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li></ol><p>好了，今天我们就通过一个简单的案例来看看 Spring Security 中的授权操作。</p><h2 id="1-授权"><a href="#1-授权" class="headerlink" title="1.授权"></a>1.授权</h2><p>所谓的授权，就是用户如果要访问某一个资源，我们要去检查用户是否具备这样的权限，如果具备就允许访问，如果不具备，则不允许访问。</p><h2 id="2-准备测试用户"><a href="#2-准备测试用户" class="headerlink" title="2.准备测试用户"></a>2.准备测试用户</h2><p>因为我们现在还没有连接数据库，所以测试用户还是基于内存来配置。</p><p>基于内存配置测试用户，我们有两种方式，第一种就是我们本系列前面几篇文章用的配置方式，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .withUser(<span class="hljs-string">"江南一点雨"</span>)</span><br><span class="line">            .password(<span class="hljs-string">"123"</span>)</span><br><span class="line">            .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种配置方式。</p><p>由于 Spring Security 支持多种数据源，例如内存、数据库、LDAP 等，这些不同来源的数据被共同封装成了一个 UserDetailService 接口，任何实现了该接口的对象都可以作为认证数据源。</p><p>因此我们还可以通过重写 WebSecurityConfigurerAdapter 中的 userDetailsService 方法来提供一个 UserDetailService 实例进而配置多个用户：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">    manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">    manager.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"user"</span>).build());</span><br><span class="line">    <span class="hljs-keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种基于内存定义用户的方法，大家任选一个。</p><h2 id="3-准备测试接口"><a href="#3-准备测试接口" class="headerlink" title="3.准备测试接口"></a>3.准备测试接口</h2><p>测试用户准备好了，接下来我们准备三个测试接口。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个测试接口，我们的规划是这样的：</p><ol><li>/hello 是任何人都可以访问的接口</li><li>/admin/hello 是具有 admin 身份的人才能访问的接口</li><li>/user/hello 是具有 user 身份的人才能访问的接口</li><li>所有 user 能够访问的资源，admin 都能够访问</li></ol><p><strong>注意第四条规范意味着所有具备 admin 身份的人自动具备 user 身份。</strong></p><h2 id="4-配置"><a href="#4-配置" class="headerlink" title="4.配置"></a>4.配置</h2><p>接下来我们来配置权限的拦截规则，在 Spring Security 的 configure(HttpSecurity http) 方法中，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这里的匹配规则我们采用了 Ant 风格的路径匹配符，Ant 风格的路径匹配符在 Spring 家族中使用非常广泛，它的匹配规则也非常简单：</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">**</td><td style="text-align:left">匹配多层路径</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配一层路径</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配任意单个字符</td></tr></tbody></table><p>上面配置的含义是：</p><ol><li>如果请求路径满足 <code>/admin/**</code> 格式，则用户需要具备 admin 角色。</li><li>如果请求路径满足 <code>/user/**</code> 格式，则用户需要具备 user 角色。</li><li>剩余的其他格式的请求路径，只需要认证（登录）后就可以访问。</li></ol><p>注意代码中配置的三条规则的顺序非常重要，和 Shiro 类似，Spring Security 在匹配的时候也是按照从上往下的顺序来匹配，一旦匹配到了就不继续匹配了，<strong>所以拦截规则的顺序不能写错</strong>。</p><p>另一方面，如果你强制将 anyRequest 配置在 antMatchers 前面，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .and()</span><br></pre></td></tr></table></figure><p>此时项目在启动的时候，就会报错，会提示不能在 anyRequest 之后添加 antMatchers：</p><p><img src="http://img.itboyhub.com/2020/04/security-05-01.png" alt></p><p>这从语义上很好理解，anyRequest 已经包含了其他请求了，在它之后如果还配置其他请求也没有任何意义。</p><p>从语义上理解，anyRequest 应该放在最后，表示除了前面拦截规则之外，剩下的请求要如何处理。</p><p>在拦截规则的配置类 AbstractRequestMatcherRegistry 中，我们可以看到如下一些代码（部分源码）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractRequestMatcherRegistry</span>&lt;<span class="hljs-title">C</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> anyRequestConfigured = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">anyRequest</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure anyRequest after itself"</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.anyRequestConfigured = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> configurer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">antMatchers</span><span class="hljs-params">(HttpMethod method, String... antPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure antMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(RequestMatchers.antMatchers(method, antPatterns));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">antMatchers</span><span class="hljs-params">(String... antPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure antMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(RequestMatchers.antMatchers(antPatterns));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> List&lt;MvcRequestMatcher&gt; <span class="hljs-title">createMvcMatchers</span><span class="hljs-params">(HttpMethod method,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">String... mvcPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure mvcMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> matchers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">regexMatchers</span><span class="hljs-params">(HttpMethod method, String... regexPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure regexMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(RequestMatchers.regexMatchers(method, regexPatterns));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">regexMatchers</span><span class="hljs-params">(String... regexPatterns)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure regexMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(RequestMatchers.regexMatchers(regexPatterns));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> C <span class="hljs-title">requestMatchers</span><span class="hljs-params">(RequestMatcher... requestMatchers)</span> </span>&#123;</span><br><span class="line">Assert.state(!<span class="hljs-keyword">this</span>.anyRequestConfigured, <span class="hljs-string">"Can't configure requestMatchers after anyRequest"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> chainRequestMatchers(Arrays.asList(requestMatchers));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码中，我们可以看到，在任何拦截规则之前（包括 anyRequest 自身），都会先判断 anyRequest 是否已经配置，如果已经配置，则会抛出异常，系统启动失败。</p><p>这样大家就理解了为什么 anyRequest 一定要放在最后。</p><h2 id="5-启动测试"><a href="#5-启动测试" class="headerlink" title="5.启动测试"></a>5.启动测试</h2><p>接下来，我们启动项目进行测试。</p><p>项目启动成功后，我们首先以 江南一点雨的身份进行登录：</p><p><img src="http://img.itboyhub.com/2020/04/security-5-2.png" alt></p><p>登录成功后，分别访问 <code>/hello</code>，<code>/admin/hello</code> 以及 <code>/user/hello</code> 三个接口，其中：</p><ol><li><code>/hello</code> 因为登录后就可以访问，这个接口访问成功。</li><li><code>/admin/hello</code> 需要 admin 身份，所以访问失败。</li><li><code>/user/hello</code> 需要 user 身份，所以访问成功。</li></ol><p>具体测试效果小伙伴们可以参考松哥的视频，我就不截图了。</p><p>按照相同的方式，大家也可以测试 javaboy 用户。</p><h2 id="6-角色继承"><a href="#6-角色继承" class="headerlink" title="6.角色继承"></a>6.角色继承</h2><p>在前面松哥提到过一点，所有 user 能够访问的资源，admin 都能够访问，很明显我们目前的代码还不具备这样的功能。</p><p>要实现所有 user 能够访问的资源，admin 都能够访问，这涉及到另外一个知识点，叫做角色继承。</p><p>这在实际开发中非常有用。</p><p>上级可能具备下级的所有权限，如果使用角色继承，这个功能就很好实现，我们只需要在 SecurityConfig 中添加如下代码来配置角色继承关系即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RoleHierarchyImpl hierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">    hierarchy.setHierarchy(<span class="hljs-string">"ROLE_admin &gt; ROLE_user"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> hierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在配置时，需要给角色手动加上 <code>ROLE_</code> 前缀。上面的配置表示 <code>ROLE_admin</code> 自动具备 <code>ROLE_user</code> 的权限。</p><p>配置完成后，重启项目，此时我们发现 javaboy 也能访问 <code>/user/hello</code> 这个接口了。</p><p>好了，今天就和小伙伴们说这么多.</p><p><strong>感谢小伙伴们的阅读，如果觉得有用，毫不犹豫的点个在看鼓励下松哥，我会以风驰电掣般的速度快速更完这个系列～</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文配套视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 &lt;a href=&quot;https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot + Vue 系列视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>前两天松哥收到了一份简历，10 年 Java 经验，期望薪资 25k</title>
    <link href="http://www.javaboy.org/2020/0407/25k-offer.html"/>
    <id>http://www.javaboy.org/2020/0407/25k-offer.html</id>
    <published>2020-04-06T23:14:10.000Z</published>
    <updated>2020-04-14T23:37:48.238Z</updated>
    
    <content type="html"><![CDATA[<p>工作十年，依然在一线 Coding，我觉得有 10 种人；一种是热爱，一种是无奈。</p><a id="more"></a><p>最近这行情，一个高级开发职位抛出去，都是上百份简历。在这众多简历中，有两个比较扎眼的，就是两个超 10 年经验的老哥，一个是 10 年，还有一个是 11 年，看下图。</p><p><img src="http://img.itboyhub.com/2020/04/offer-03-01.png" alt></p><p>两位老哥的简历我看了下，项目经验都是超级丰富，毕竟写了 10 年代码了，难能可贵的他们的技术栈也没有特别古老，还是紧跟潮流的。都是企业级开发中常规的技术栈，但是看来看去，总感觉哪里怪怪的。</p><p>想了半天终于想明白，这简历和只有 5、6 年经验的简历的相比好像没啥特别突出的地方，除了项目经验比较丰富，其他地方都不具备特别明显的优势。两份简历，其中一个老哥的期望薪资在 25k，另一个没写，要面谈。</p><p>老实说，十年 25k 这个薪水在深圳这个地方并不算高。名校应届生就有可能拿到这个薪水，即使是专科，只要技术不是特别差劲，脑袋灵光性格开朗，在深圳这地方拿 25k 也不用等 10 年。</p><p>大部分公司招聘在一线 Coding 的 Java 工程师一般也很少需要 10 年经验的，10 年经验基本都是架构师或者项目经理一类的岗位。</p><p>所以除非是热爱，否则在 Coding 10 年之后，还想找一个在一线 Coding 的岗位，确实蛮尴尬的，但是这种尴尬，有的人却避免不了。我们工作，即是为了赚钱，为了增长项目经验，也要不断构建自己的护城河，提高自己的核心竞争力，才有可能避免这样的尴尬。有的人觉得核心竞争力这话有点假大空，怎么提高？</p><p>我举一个刚刚发生的例子。</p><p>上周松哥发了一篇文章：<a href="https://mp.weixin.qq.com/s/hAi6Na90hhH12tlrDsH-YA" target="_blank" rel="noopener">so easy！松哥手把手带你撸一个 Redis 的 Java 客户端</a>，发文之前我反复揣度，文章可能出现的被怼的地方，都做了仔细的调整，可是没想到发文之后，还是被怼了。</p><p>发文之前我隐隐约约感觉到有人会说自己写的 Java 客户端没有 Jedis 或者 Spring Data Redis 使用方便，所以我在文章一开始就强调了，我主要是想和大家分享 RESP 协议，以及 Java 客户端是如何连接 Redis 的，同时也把一个锋芒毕露的标题改成现在这样比较中庸的标题，结果第二天一发文，还是被人怼了说这东西没用，直接用 Jedis 更方便，我瞬间感觉头一天晚上一个多小时的功夫都白费了，还是有人无法理解我的文章的目的。</p><p>Jedis、Spring Data Redis 这种工具基本上一个初级 Java 程序员都会用，人人都会的东西，你要是不会，肯定是劣势，你要是会，那也绝对不是优势，这就不是你的核心竞争力。出去面试，没人会问 Jedis 怎么用，Spring Data Redis 怎么用，问的都是原理，都是实际开发中的场景问题。</p><p>很多人会用 Jedis，但是不知道 Jedis 到底是怎么连接 Redis 服务器的，很多人也知道 Redis 有一种持久化方案叫做 AOF，他甚至把 AOF 持久化的日志都打开看过了，但是里边的字符串却一直似懂非懂，这些问题，看了松哥前面的文章就懂了。但是话说回来，这些问题即使你不懂，大部分情况下也不影响你使用 Redis，但是要因此觉得自己自己技术很厉害能够应对工作中的各种问题，未免有点夜郎自大了。</p><p>记得 2018 年底松哥的新书刚刚出版的时候，有个同事（9 年的经验的老程序员）跑来问我写博客用什么工具？我说我用 VsCode 写的 markdown，刚说完他就问了两个让我惊掉下巴的问题：1. vscode 是啥？2.markdown 又是啥？出于对前辈同事的尊重，我非常镇定并且耐心跟他解释了这两个东西。</p><p>说这两件事并不是说懂了 RESP，懂 markdown 就是大牛，不懂就是菜鸡，而是想说，程序员这个行业，需要我们不断的更新并且深化自己的技能，所有的知识不能停留在表面，也不能停留在上古时代。</p><p>核心竞争力不是说你报了某一们网课，学了某一个知识点或者一些高大上的名词就掌握了的东西。<strong>核心竞争力应该是一种骨子里的态度，永远保持钻研，保持学习的一种态度，在这样态度的驱使之下，你不可能碌碌无为。</strong> 10 年之后的自己，是 CRUD 越写越熟练了还是掌握了很多别人不具备的技能，是把 1 年重复了 10 次还是真的活了 10 年，这取决于我们今天的态度。</p><p>很多小伙伴可能知道，松哥最早是做 Android 的，记得当时 Android5.0 推出的时候，业界一片欢呼，谷歌提供了很多炫酷的 UI 组件，作为开发者再也不用写哪些复杂的事件调用了。我当时在北京出差，吃饭的时候和一位 Android 前辈说起这事，我说，虽然谷歌提供的组件越来越方便了，但是对于新手而言并不见得就是好事，他们可能只满足于调用组件，不懂原理，长此以往，他们的竞争力会越来越弱，同事笑了笑说，搞 C 的程序员也是这么看待搞 Java 的。我当时就感觉自己肤浅了，开发这条路，无论你是做底层还是做应用，永远都有学不完的东西，永远都要保持学习的心态。</p><p>真心希望松哥的读者工作 10 年之后，不用投简历找工作，也不用找只有 25k 薪水的工作。小伙伴们加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作十年，依然在一线 Coding，我觉得有 10 种人；一种是热爱，一种是无奈。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>看懂这篇文章，前后端分离再和面试官扯皮就没问题了</title>
    <link href="http://www.javaboy.org/2020/0406/springboot-vue-nginx.html"/>
    <id>http://www.javaboy.org/2020/0406/springboot-vue-nginx.html</id>
    <published>2020-04-05T23:13:54.000Z</published>
    <updated>2020-04-14T23:43:21.241Z</updated>
    
    <content type="html"><![CDATA[<p>假期一直在下雨，抽空整理了下小伙伴们问的比较多的前后端分离的部署问题。</p><a id="more"></a><h2 id="1-问题焦点"><a href="#1-问题焦点" class="headerlink" title="1.问题焦点"></a>1.问题焦点</h2><p>问题焦点主要在于跨域，开发环境和生产环境是两种完全不懂的配置思路。</p><p>如果你直接在项目中引入 Vue，像用 jQuery 那样用 Vue，那没什么问题，你应该也不会有跨域的疑问。但是如果你做的是单页面应用(SPA)，那么必然会有这样的疑问，跨域问题怎么搞！</p><p>因为在单页面应用中，前端项目可以单独通过 node 启动，它单独占用一个端口，后端项目启动后也是另外一个端口，此时从前端发送请求到后端，由于两者处于不同的端口之上，因此必然存在一个跨域问题。</p><p>但是大家想想，这个跨域有可能只是在开发环境下存在，生产环境下有可能不存在。因为当项目开发完成之后，我们对前端项目进行打包，打包后部署在 Nginx 上或者直接拷贝到后端项目中运行都可以（一般使用前者）：</p><ul><li>如果是前者，后端接口也通过 Nginx 进行映射，这个时候就不会存在跨域问题了</li><li>如果是后者，那就更简单了，部署的时候前后端代码放在一起，更不会有跨域问题了</li></ul><p>因此，解决这个所谓的 “跨域” 问题，我们不能按照传统的思路来（传统思路主要是 JSONP 或者 CORS），因为在项目真正上线后，所谓的跨域问题可能就会消失。</p><p>那么这个问题怎么解决呢？我们可以在前端 nodejs 中配置请求转发。</p><p>配置请求转发其实不难，不过 vue-cli2 和 vue-cli3 之后的写法稍有不同，我们来分别看下。</p><p>先来看开发环境配置。</p><h2 id="2-开发环境配置"><a href="#2-开发环境配置" class="headerlink" title="2.开发环境配置"></a>2.开发环境配置</h2><h3 id="2-1-vue-cli2-方案"><a href="#2-1-vue-cli2-方案" class="headerlink" title="2.1 vue-cli2 方案"></a>2.1 vue-cli2 方案</h3><p>如果我们使用的 vue-cli2 来创建的 SPA 应用，创建成功之后，在项目的 config 目录下有一个 index.js 文件，在这个文件中，我们可以进行请求转发配置，如下图：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-1.png" alt></p><p>配置内容如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  dev: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Paths</span></span><br><span class="line">    assetsSubDirectory: <span class="hljs-string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="hljs-string">'/'</span>,</span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">      <span class="hljs-string">'/'</span>: &#123;</span><br><span class="line">        target: <span class="hljs-string">'http://localhost:8082'</span>,</span><br><span class="line">        changeOrigin: <span class="hljs-literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="hljs-string">'^/'</span>: <span class="hljs-string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="hljs-string">'/ws/*'</span>: &#123;</span><br><span class="line">        target: <span class="hljs-string">'ws://127.0.0.1:8082'</span>,</span><br><span class="line">        ws: <span class="hljs-literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>proxyTable 就是我们配置的转发路由表。这个里边我们一共配置了两个规则：</p><ul><li>第一个是拦截所有 HTTP 请求，将之转发到后端服务器上（前端默认端口是 8080），后端的端口是 8082。至于拦截规则 <code>/</code> ，大家可以自定义，根据实际情况来写，例如所有的 HTTP 请求都有一个统一的前缀 api，那么这里就可以写 <code>/api</code>。</li><li>第二个是拦截所有的 websocket 请求进行转发，我这里给所有的 websocket 请求取了一个统一的前缀 <code>/ws</code></li></ul><p>如果你有更多的拦截规则，继续在这里配置就可以了，这些配置只会在开发环境下生效，当项目编译打包时，这些配置是不会打包进去的，也就是说，项目发布的时候，这些配置是失效的，这个时候我们通过 Nginx 或者将前端代码拷贝到后端，就可以解决生产环境下的跨域问题了（<strong>相当于开发时候的跨域在生产环境下不存在</strong>）。</p><p>相对来说，vue-cli2 在这里的配置还比较容易。</p><h3 id="2-2-vue-cli3-方案"><a href="#2-2-vue-cli3-方案" class="headerlink" title="2.2 vue-cli3 方案"></a>2.2 vue-cli3 方案</h3><p>vue-cli3 和 vue-cli4 的思路基本一致，以 vue-cli3 为例：</p><p>使用 vue-cli3 创建的 SPA 应用，没有 config 目录了，因此请求转发的配置我们要在 vue.config.js 这个配置文件中来配置。</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> proxyObj = &#123;&#125;;</span><br><span class="line">proxyObj[<span class="hljs-string">'/ws'</span>] = &#123;</span><br><span class="line">    ws: <span class="hljs-literal">true</span>,</span><br><span class="line">    target: <span class="hljs-string">"ws://localhost:8081"</span></span><br><span class="line">&#125;;</span><br><span class="line">proxyObj[<span class="hljs-string">'/'</span>] = &#123;</span><br><span class="line">    ws: <span class="hljs-literal">false</span>,</span><br><span class="line">    target: <span class="hljs-string">"http://localhost:8081"</span>,</span><br><span class="line">    changeOrigin: <span class="hljs-literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">        <span class="hljs-string">'^/'</span>: <span class="hljs-string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: <span class="hljs-string">'localhost'</span>,</span><br><span class="line">        port: <span class="hljs-number">8080</span>,</span><br><span class="line">        proxy: proxyObj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们创建一个 proxyObj 用来放各种代理对象，至于代理的内容这里的则和 vue-cli2 中的没有太多差异。要注意的是，HTTP 请求代理中，多了一个属性 <code>ws: false</code>，用过 vue-cli3 同学可能发现了，如果不加这个属性，浏览器控制台会一直报连不上 socket 的错，加上就没事了。</p><p>最后在 devServer 中指定项目的 host 和 port ，然后再配置一下 proxy 对象就可以啦。</p><p>这就是我们在 vue-cli3 中请求的配置。</p><p>不过这里的配置老实说没有什么难度，做过一次就会啦，要是没做过，头一次可能得折腾半天。</p><h2 id="3-生产环境配置"><a href="#3-生产环境配置" class="headerlink" title="3. 生产环境配置"></a>3. 生产环境配置</h2><p>很多人对前后端分离部署感到困惑，其实主要是困惑跨域问题怎么解决。因为前后端分离项目在开发的时候，前端通过 nodejs 来运行，需要一个单独的端口，后端通过 Tomcat 或者 Jetty 来运行，也需要端口，两个不同的端口，就造成了跨域。</p><p>但是开发完成后，我们会对前端项目编译打包，编译打包完成之后，就只剩下一堆 js、css 以及 html 文件了，我们把这些编译打包后的文件拷贝到后端项目中，这样再去运行就不存在跨域问题了。</p><p>整体上来看，生产环境的部署，我们有两种思路：</p><ul><li>一种就是将前端项目打包编译之后，放到后端项目中（例如 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下）</li><li>另外一种则是将前端打包之后的静态资源用 Nginx 来部署，后端单独部署只需要单纯的提供接口即可（推荐）。</li></ul><p>分别来看。</p><h3 id="3-1-前后端一起部署"><a href="#3-1-前后端一起部署" class="headerlink" title="3.1 前后端一起部署"></a>3.1 前后端一起部署</h3><p>这种方式比较简单，大家作为了解即可，生产环境一般采用第二种方案。</p><p>首先在前端 Vue 项目中执行 <code>npm run build</code> 命令，将前端文件进行打包。</p><p>编译打包成功后，将打包好的 js、css、html、image、fonts 等文件和文件夹拷贝到 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下，然后在 Spring Security 中对前端静态资源配置放行，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/index.html"</span>,<span class="hljs-string">"/img/**"</span>,<span class="hljs-string">"/fonts/**"</span>,<span class="hljs-string">"/favicon.ico"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将 Spring Boot 项目打包成 jar，执行命令启动即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar vhr.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><h3 id="3-2-前后端分开部署"><a href="#3-2-前后端分开部署" class="headerlink" title="3.2 前后端分开部署"></a>3.2 前后端分开部署</h3><p>分开部署就离不开 Nginx。</p><h4 id="3-2-1-Nginx-介绍"><a href="#3-2-1-Nginx-介绍" class="headerlink" title="3.2.1 Nginx 介绍"></a>3.2.1 Nginx 介绍</h4><h5 id="3-2-1-1-基本介绍"><a href="#3-2-1-1-基本介绍" class="headerlink" title="3.2.1.1 基本介绍"></a>3.2.1.1 基本介绍</h5><p><code>Nginx</code> 是一个高性能的 <code>HTTP</code> 和反向代理 <code>web</code> 服务器，同时也提供了 <code>IMAP/POP3/SMTP</code> 服务。 </p><p><code>Nginx</code> 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 <code>Rambler.ru</code> 站点开发的，第一个公开版本 <code>0.1.0</code> 发布于 <code>2004</code> 年 <code>10</code> 月 <code>4</code> 日。 </p><p><code>Nginx</code> 特点是占有内存少，并发能力强。</p><p>事实上 <code>nginx</code> 的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了 <code>Nginx</code> ，我们的项目架构可能是这样：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-3.png" alt></p><p>在这样的架构中 ， <code>Nginx</code> 所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达 <code>Nginx</code> 上，再由 <code>Nginx</code> 根据提前配置好的转发规则，将客户端发来的请求转发到某一个 <code>Tomcat</code> 上去。</p><p>那么这里涉及到两个概念：</p><ul><li>负载均衡服务器</li></ul><p>就是进行请求转发，降低某一个服务器的压力。负载均衡策略很多，也有很多层，对于一些大型网站基本上从 <code>DNS</code> 就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 <code>F5</code> 和 <code>Nginx</code> （目前 <code>Nginx</code> 已经被 <code>F5</code> 收购），早些年，也可以使用 <code>Apache</code> 来做负载均衡，但是效率不如 <code>Nginx</code> ，所以现在主流方案是 <code>Nginx</code> 。</p><ul><li>反向代理服务器：</li></ul><p>另一个概念是反向代理服务器，得先说正向代理，看下面一张图：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-4.png" alt></p><p>在这个过程中，Google 并不知道真正访问它的客户端是谁，它只知道这个中间服务器在访问它。因此，这里的代理，实际上是中间服务器代理了客户端，这种代理叫做正向代理。</p><p>那么什么是反向代理呢？看下面一张图：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-5.png" alt></p><p>在这个过程中，10086 这个号码相当于是一个代理，真正提供服务的，是话务员，但是对于客户来说，他不关心到底是哪一个话务员提供的服务，他只需要记得 10086 这个号码就行了。</p><p>所有的请求打到 10086 上，再由 10086 将请求转发给某一个话务员去处理。因此，在这里，10086 就相当于是一个代理，只不过它代理的是话务员而不是客户端，这种代理称之为反向代理。</p><h5 id="3-2-1-2-Nginx-的优势"><a href="#3-2-1-2-Nginx-的优势" class="headerlink" title="3.2.1.2 Nginx 的优势"></a>3.2.1.2 Nginx 的优势</h5><p>在 Java 开发中，Nginx 有着非常广泛的使用，随便举几点：</p><ol><li>使用 Nginx 做静态资源服务器：Java 中的资源可以分为动态和静态，动态需要经过 Tomcat 解析之后，才能返回给浏览器，例如 JSP 页面、Freemarker 页面、控制器返回的 JSON 数据等，都算作动态资源，动态资源经过了 Tomcat 处理，速度必然降低。对于静态资源，例如图片、HTML、JS、CSS 等资源，这种资源可以不必经过 Tomcat 解析，当客户端请求这些资源时，之间将资源返回给客户端就行了。此时，可以使用 Nginx 搭建静态资源服务器，将静态资源直接返回给客户端。</li><li>使用 Nginx 做负载均衡服务器，无论是使用 Dubbo 还是 Spirng Cloud ，除了使用各自自带的负载均衡策略之外，也都可以使用 Nginx 做负载均衡服务器。</li><li>支持高并发、内存消耗少、成本低廉、配置简单、运行稳定等。</li></ol><h5 id="3-2-1-3-Nginx-安装"><a href="#3-2-1-3-Nginx-安装" class="headerlink" title="3.2.1.3 Nginx 安装"></a>3.2.1.3 Nginx 安装</h5><p>由于基本上都是在 Linux 上使用 Nginx，因此松哥这里主要向大家展示 CentOS 7 安装 Nginx：</p><ol><li>首先下载 Nginx</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.17.0.tar.gz</span><br></pre></td></tr></table></figure><p>然后解压下载的目录，进入解压目录中，在编译安装之前，需要安装两个依赖：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install pcre-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure><p>然后开始编译安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>装好之后，默认安装位置在 ：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>进入到该目录的 <code>sbin</code> 目录下，执行 <code>nginx</code> 即可启动 <code>Nginx</code> ：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-6.png" alt></p><p>Nginx 启动成功之后，在浏览器中直接访问 Nginx 地址：</p><p><img src="http://img.itboyhub.com/2020/04/fe-3-7.png" alt></p><p>看到如上页面，表示 Nginx 已经安装成功了。</p><p>如果修改了 Nginx 配置，则可以通过如下命令重新加载 Nginx 配置文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><h5 id="3-2-1-4-为什么用-Nginx"><a href="#3-2-1-4-为什么用-Nginx" class="headerlink" title="3.2.1.4 为什么用 Nginx"></a>3.2.1.4 为什么用 Nginx</h5><p>结合 Nginx 来部署前后端分离项目算是目前的主流方案。一来部署方便，二来通过动静分离也可以有效提高项目的运行效率。</p><p>大家知道我们项目中的资源包含动态资源和静态资源两种，其中：</p><ul><li>动态资源就是那些需要经过容器处理的资源，例如 jsp、freemarker、各种接口等。</li><li>静态资源则是那些不需要经过容器处理，收到客户端请求就可以直接返回的资源，像 js、css、html 以及各种格式的图片，都属于静态资源。</li></ul><p>将动静资源分开部署，可以有效提高静态资源的加载速度以及整个系统的运行效率。</p><p>在前后端分离项目部署中，我们用 Nginx 来做一个反向代理服务器，它既可以代理动态请求，也可以直接提供静态资源访问。</p><p>无论是动态请求还是静态请求，都是首先到达 Nginx，再从 Nginx 上去查找页面或接口，这样，原本存在的所谓跨域问题现在就不存在了。</p><h4 id="3-2-2-部署步骤"><a href="#3-2-2-部署步骤" class="headerlink" title="3.2.2 部署步骤"></a>3.2.2 部署步骤</h4><h5 id="3-2-2-1-后端部署"><a href="#3-2-2-1-后端部署" class="headerlink" title="3.2.2.1 后端部署"></a>3.2.2.1 后端部署</h5><p>后端接口的部署，主要看项目的形式，如果就是普通的 SSM 项目，那就提前准备好 Tomcat ，在 Tomcat 中部署项目，如果是 Spring Boot 项目，可以通过命令直接启动 jar，如果是微服务项目，存在多个 jar 的话，可以结合 Docker 来部署（参考<a href="https://mp.weixin.qq.com/s/vSCQLvQBYMYoPhdlO2v3XA" target="_blank" rel="noopener">一键部署 Spring Boot 到远程 Docker 容器</a>），无论是那种形式，对于我们 Java 工程师来说，这都不是问题，我相信这一步大家都能搞定。</p><p>后端项目可以在一个非 80 端口上部署，部署成功之后，因为这个后端项目只是提供接口，所以我们并不会直接去访问他。而是通过 Nginx 请求转发来访问这个后端接口。</p><p>松哥这里以我 2018 年为一个律所的小程序为例，后端是一个 Spring Boot 工程，那么我可以通过 Docker 部署，也可以直接通过命令来启动，这里简单点，直接通过命令来启动 jar ，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar jinlu.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><p>后端启动成功之后，我并不急着直接去访问后端，而是安装并且去配置一个 Nginx，通过 Nginx 来转发请求。</p><p>这里我们在 nginx.conf 中做出如下配置：</p><p>首先配置上游服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">upstream zqq.com&#123;</span><br><span class="line">  server 127.0.0.1:9999 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里主要是配置服务端的地址，如果服务端是集群化部署，那么这里就会有多个服务端地址，然后可以通过权重或者 ip hash 等方式进行请求分发。</p><p>然后我们在 server 中配置转发规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /jinlu/ &#123;</span><br><span class="line">  proxy_pass http://zqq.com;</span><br><span class="line">  tcp_nodelay     on;</span><br><span class="line">  proxy_set_header Host            $host;</span><br><span class="line">  proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置完成后，假设我目前的域名是 javaboy.org，那么用户通过 <code>http://www.javaboy.org/jinlu/**</code> 格式的地址就可以访问到我服务端的接口。</p><h5 id="3-2-2-2-前端部署"><a href="#3-2-2-2-前端部署" class="headerlink" title="3.2.2.2 前端部署"></a>3.2.2.2 前端部署</h5><p>以 Vue 为例，如果是 SPA 应用，项目打包之后，就是一个 index.html 还有几个 js、css、images 以及 fonts ，这些都是静态文件，我们将静态文件首先上传到服务器，然后在 nginx.conf 中配置静态资源访问，具体配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|) &#123;</span><br><span class="line">   root /usr/local/nginx/html/;#所有静态文件直接读取硬盘</span><br><span class="line">   expires 30d; #缓存30天</span><br><span class="line">&#125; ​​​​</span><br></pre></td></tr></table></figure><p>当然我这里是按照资源类型来拦截的，即后缀为 js、css、ico 等的文件，统统都不进行请求分发，直接从本地的 /usr/local/nginx/html/ 目录下读取并返回到前端（我们需要将静态资源文件上传到 <code>/usr/local/nginx/html/</code> 目录下）。</p><p>如果我们的服务器上部署了多个项目，这种写法就不太合适，因为多个项目的前端静态文件肯定要分门别类，各自放好的，这个时候我们一样可以通过路径来拦截，配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /jinlu-admin/ &#123;</span><br><span class="line">   root /usr/local/nginx/html/jinlu-admin/;#所有静态文件直接读取硬盘</span><br><span class="line">   expires 30d; #缓存30天</span><br><span class="line">&#125; ​​​​</span><br></pre></td></tr></table></figure><p>这样，请求路径是 /jinlu-admin/ 格式的请求，则不会进行请求分发，而是直接从本机的 <code>/usr/local/nginx/html/jinlu-admin/</code> 目录下返回相关资源。采用这方方式配置静态资源，我们就可以部署多个项目了，多个项目的部署方式和上面的一样。</p><p>这样部署完成之后，假设我的域名是 javaboy.org ，那么用户通过 <code>http://www.javaboy.org/jinlu-admin/**</code><br>格式的请求就可以访问到前端资源了。</p><p>此时大家发现，前端的静态资源和后端的接口现在处于同一个域之中了（请求协议、域名、端口现在都一致），这样就不存在跨域问题，所以我一开始基说<strong>不</strong>必用 JSONP 或者 CORS 去解决跨域。当然可能还有一些非常特殊情况需要在 nginx 中配置跨域，这个松哥以后再和大家细聊~</p><h2 id="4-Docker-部署"><a href="#4-Docker-部署" class="headerlink" title="4. Docker 部署"></a>4. Docker 部署</h2><p>上面的部署方案实际上可以解决大部分的项目部署，如果项目的模块比较多，也可以使用 Docker 部署，公众号后台回复 Docker，可以查看松哥的自己纯手敲的 Docker 教程。</p><p>容器化部署的话，如果模块比较多的话，我们可能还需要结合 Jenkins ，这里我就单纯的从 Docker 容器的角度来说说。</p><p>Docker 部署的话，也是两种思路，直接部署或者使用 Jib。这个松哥之前发过相关文章，这里就不再赘述。</p><ul><li><a href="https://mp.weixin.qq.com/s/7DrvNHM6MGc7lwz8JDULSQ" target="_blank" rel="noopener">部署 Spring Boot 到远程 Docker 容器</a></li><li><a href="https://mp.weixin.qq.com/s/1VMWrCZjsbEJLo34K-M6dQ" target="_blank" rel="noopener">使用 Jib 部署 Spring Boot</a></li></ul><h2 id="5-相关视频"><a href="#5-相关视频" class="headerlink" title="5.相关视频"></a>5.相关视频</h2><p>松哥之前也录制过一下部署的相关视频，大家可以作为参考。</p><p><a href="https://mp.weixin.qq.com/s/VKtt9nC7PCHmiUI8oZ1CTw" target="_blank" rel="noopener">本文配套视频地址</a></p><p>好了，看些资料看完，相信小伙伴们对于前后端分离的部署已经有一个基本的认知了。觉得有收获，记得点个在看哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假期一直在下雨，抽空整理了下小伙伴们问的比较多的前后端分离的部署问题。&lt;/p&gt;
    
    </summary>
    
      <category term="前后端分离" scheme="http://www.javaboy.org/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
      <category term="前后端分离" scheme="http://www.javaboy.org/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>玩转 IDEA 之 Inject Language</title>
    <link href="http://www.javaboy.org/2020/0405/inject-language.html"/>
    <id>http://www.javaboy.org/2020/0405/inject-language.html</id>
    <published>2020-04-04T23:13:35.000Z</published>
    <updated>2020-04-14T23:40:43.245Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个视频教程，视频链接：<a href="https://mp.weixin.qq.com/s/L6ziJAqfXhrFjuZvRBNfJg" target="_blank" rel="noopener">—–&gt;&gt;&gt;&gt;&gt;&gt;&gt;没错，点我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个视频教程，视频链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/L6ziJAqfXhrFjuZvRBNfJg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;—–&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;没错
      
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/categories/IntelliJ-IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>so easy！松哥手把手带你撸一个 Redis 的 Java 客户端</title>
    <link href="http://www.javaboy.org/2020/0403/redis-java-client.html"/>
    <id>http://www.javaboy.org/2020/0403/redis-java-client.html</id>
    <published>2020-04-02T23:13:18.000Z</published>
    <updated>2020-04-14T23:43:44.813Z</updated>
    
    <content type="html"><![CDATA[<p>其实今天是想和小伙伴们聊一下 Redis 的通信协议 RESP。在搞懂这个通信协议的基础上，松哥手把手带领大家做一个 Redis 的 Java 客户端。</p><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/hAi6Na90hhH12tlrDsH-YA" target="_blank" rel="noopener">本文配套视频地址</a></p><p>以上视频节选自松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><p>以下是视频笔记。</p><p>Redis 通信使用了文本协议，文本协议比较费流量，但是 Redis 作者认为数据库的瓶颈不在于网络流量，而在于内部逻辑，所以采用了这样一个费流量的文本协议，事实证明，这个费流量的文本协议并不影响 Redis 的受欢迎程度。</p><p>这个文本协议叫做 Redis Serialization Protocol，简称 RESP。</p><p>Redis 协议将传输的数据结构分为 5 种最小单元，单元结束时，加上回车换行符 \r\n。</p><ol><li>单行字符串以 + 开始，例如 +javaboy.org\r\n</li><li>多行字符串以 $ 开始，后面加上字符串长度，例如 $11\r\njavaboy.org\r\n</li><li>整数值以: 开始，例如 :1024\r\n</li><li>错误消息以 - 开始</li><li>数组以 * 开始，后面加上数组长度。</li></ol><p>需要注意的是，如果是客户端连接服务端，只能使用第 5 种。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>做两件事情：</p><p>为了方便客户端连接 Redis，我们关闭 Redis 种的保护模式(在 redis.conf 文件中) </p><p>protected no</p><p>同时关闭密码：</p><p><code># requirepass xxxx</code></p><p>配置完成后，重启 Redis。</p><h2 id="2-实战"><a href="#2-实战" class="headerlink" title="2. 实战"></a>2. 实战</h2><p>接下来，我们通过 Socket+RESP 来定义两个最最常见的命令 set 和 get。</p><p>首先我们在构造方法中初始化一个 Socket 连接，这将是我们 Java 代码和 Redis 通信的基础。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaboyRedisClient</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Socket socket;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaboyRedisClient</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">"192.168.91.128"</span>, <span class="hljs-number">6379</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="hljs-string">"Redis 连接失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们先来定义 set 方法。</p><p>根据前面列出来的规则，Java 客户端发送到 Redis 中的数据格式是第 5 种，也就是一个数组，对于 set 命令而言，数组中应该有三项，第一项是命令名字 set，第二项和第三项则是对应的 key/value，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[set,key,value]</span><br></pre></td></tr></table></figure><p>结合第 1 小节的 5 条规则，我们可以先规划一下要发送的字符串，每行文本之后都有 <code>\r\n</code>。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*3\r\n$3\r\nset\r\n$3\r\nkey\r\n$5\r\nvalue\r\n</span><br></pre></td></tr></table></figure><p><code>*3</code> 表示数组长度为 3（规则 5），$3 表示 set 长度为 3（规则 2），后面字符串含义类似不再赘述。 </p><p>整理好思路之后，我们来看下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 执行 Redis 中的 set 命令 [set,key,value]</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@param</span> key</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@param</span> value</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(String key, String value)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">   sb.append(<span class="hljs-string">"*3"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"set"</span>.length())</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"set"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">           .append(key.getBytes().length)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(key)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">           .append(value.getBytes().length)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">           .append(value)</span><br><span class="line">           .append(<span class="hljs-string">"\r\n"</span>);</span><br><span class="line">   System.out.println(sb.toString());</span><br><span class="line">   socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">   <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">   socket.getInputStream().read(buf);</span><br><span class="line">   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的逻辑很简单，就是把我们传入的参数，处理成我们上面写好的字符串，然后再通过 socket 写出去。</p><p>同理，我们还可以定制 get 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 执行 Redis 中的 get 命令 [get,key]</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="hljs-string">"*2"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"get"</span>.length())</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"get"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">            .append(<span class="hljs-string">"$"</span>)</span><br><span class="line">            .append(key.getBytes().length)</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>)</span><br><span class="line">            .append(key)</span><br><span class="line">            .append(<span class="hljs-string">"\r\n"</span>);</span><br><span class="line">    socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">    <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">    socket.getInputStream().read(buf);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来通过如下一段代码进行测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String set = <span class="hljs-keyword">new</span> JavaboyRedisClient().set(<span class="hljs-string">"k1"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">    System.out.println(set);</span><br><span class="line">    String k1 = <span class="hljs-keyword">new</span> JavaboyRedisClient().get(<span class="hljs-string">"k1"</span>);</span><br><span class="line">    System.out.println(k1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，如此之后，我们就定义了一个简陋的 Java 客户端。具体的测试效果小伙伴们可以参考前面的视频。</p><p>好了，在理解 RESP 的基础上，我们可以非常容易的实现这样的客户端。小伙伴们也可以自己尝试定义一下其他的命令体验下。</p><p>如果觉得有用，记得点在看哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实今天是想和小伙伴们聊一下 Redis 的通信协议 RESP。在搞懂这个通信协议的基础上，松哥手把手带领大家做一个 Redis 的 Java 客户端。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</title>
    <link href="http://www.javaboy.org/2020/0402/spring-security-json.html"/>
    <id>http://www.javaboy.org/2020/0402/spring-security-json.html</id>
    <published>2020-04-01T23:12:56.000Z</published>
    <updated>2020-04-14T23:44:29.610Z</updated>
    
    <content type="html"><![CDATA[<p>这是本系列的第四篇，有小伙伴找不到之前文章，松哥给大家列一个索引出来：</p><a id="more"></a><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li></ol><p><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">本文配套视频地址</a></p><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><p>以下是视频笔记。</p><p>前两天有个小伙伴在微信上问松哥，这前后端分离开发后，认证这一块到底是使用传统的 session 还是使用像 JWT 这样的 token 来解决呢？</p><p>这确实代表了两种不同的方向。</p><p>传统的通过 session 来记录用户认证信息的方式我们可以理解为这是一种有状态登录，而 JWT 则代表了一种无状态登录。可能有小伙伴对这个概念还不太熟悉，我这里就先来科普一下有状态登录和无状态登录。</p><h2 id="1-无状态登录"><a href="#1-无状态登录" class="headerlink" title="1. 无状态登录"></a>1. 无状态登录</h2><h3 id="1-1-什么是有状态"><a href="#1-1-什么是有状态" class="headerlink" title="1.1 什么是有状态"></a>1.1 什么是有状态</h3><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h3 id="1-2-什么是无状态"><a href="#1-2-什么是无状态" class="headerlink" title="1.2 什么是无状态"></a>1.2 什么是无状态</h3><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3 如何实现无状态"></a>1.3 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="1-4-各自优缺点"><a href="#1-4-各自优缺点" class="headerlink" title="1.4 各自优缺点"></a>1.4 各自优缺点</h3><p>使用 session 最大的优点在于方便。你不用做过多的处理，一切都是默认的即可。松哥本系列前面几篇文章我们也都是基于 session 来讲的。</p><p>但是使用 session 有另外一个致命的问题就是如果你的前端是 Android、iOS、小程序等，这些 App 天然的就没有 cookie，如果非要用 session，就需要这些工程师在各自的设备上做适配，一般是模拟 cookie，从这个角度来说，在移动 App 遍地开花的今天，我们单纯的依赖 session 来做安全管理，似乎也不是特别理想。</p><p>这个时候 JWT 这样的无状态登录就展示出自己的优势了，这些登录方式所依赖的 token 你可以通过普通参数传递，也可以通过请求头传递，怎么样都行，具有很强的灵活性。</p><p>不过话说回来，如果你的前后端分离只是网页+服务端，其实没必要上无状态登录，基于 session 来做就可以了，省事又方便。</p><p>好了，说了这么多，本文我还是先来和大家说说基于 session 的认证，关于 JWT 的登录以后我会和大家细说，如果小伙伴们等不及，也可以先看看松哥之前发的关于 JWT 的教程：<a href="https://mp.weixin.qq.com/s/Sn59dxwtsEWoj2wdynQuRQ" target="_blank" rel="noopener">Spring Security 结合 Jwt 实现无状态登录</a>。</p><h2 id="2-登录交互"><a href="#2-登录交互" class="headerlink" title="2. 登录交互"></a>2. 登录交互</h2><p>在<a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">上篇文章</a>中，松哥和大家捋了常见的登录参数配置问题，对于登录成功和登录失败，我们还遗留了一个回调函数没有讲，这篇文章就来和大家细聊一下。</p><h3 id="2-1-前后端分离的数据交互"><a href="#2-1-前后端分离的数据交互" class="headerlink" title="2.1 前后端分离的数据交互"></a>2.1 前后端分离的数据交互</h3><p>在前后端分离这样的开发架构下，前后端的交互都是通过 JSON 来进行，无论登录成功还是失败，都不会有什么服务端跳转或者客户端跳转之类。</p><p>登录成功了，服务端就返回一段登录成功的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，就和后端没有关系了。</p><p>登录失败了，服务端就返回一段登录失败的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，也和后端没有关系了。</p><p>首先把这样的思路确定了，基于这样的思路，我们来看一下登录配置。</p><h3 id="2-2-登录成功"><a href="#2-2-登录成功" class="headerlink" title="2.2 登录成功"></a>2.2 登录成功</h3><p>之前我们配置登录成功的处理是通过如下两个方法来配置的：</p><ul><li>defaultSuccessUrl</li><li>successForwardUrl</li></ul><p>这两个都是配置跳转地址的，适用于前后端不分的开发。除了这两个方法之外，还有一个必杀技，那就是 successHandler。</p><p>successHandler 的功能十分强大，甚至已经囊括了 defaultSuccessUrl 和 successForwardUrl 的功能。我们来看一下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.successHandler((req, resp, authentication) -&gt; &#123;</span><br><span class="line">    Object principal = authentication.getPrincipal();</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    PrintWriter out = resp.getWriter();</span><br><span class="line">    out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(principal));</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>successHandler 方法的参数是一个 AuthenticationSuccessHandler 对象，这个对象中我们要实现的方法是 onAuthenticationSuccess。</p><p>onAuthenticationSuccess 方法有三个参数，分别是：</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>Authentication</li></ul><p>有了前两个参数，我们就可以在这里随心所欲的返回数据了。利用 HttpServletRequest 我们可以做服务端跳转，利用 HttpServletResponse 我们可以做客户端跳转，当然，也可以返回 JSON 数据。</p><p>第三个 Authentication 参数则保存了我们刚刚登录成功的用户信息。</p><p>配置完成后，我们再去登录，就可以看到登录成功的用户信息通过 JSON 返回到前端了，如下：</p><p><img src="http://img.itboyhub.com/2020/03/spring-security-4-1.png" alt></p><p>当然用户的密码已经被擦除掉了。擦除密码的问题，松哥之前和大家分享过，大家可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">手把手带你捋一遍 Spring Security 登录流程</a></p><h3 id="2-3-登录失败"><a href="#2-3-登录失败" class="headerlink" title="2.3 登录失败"></a>2.3 登录失败</h3><p>登录失败也有一个类似的回调，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.failureHandler((req, resp, e) -&gt; &#123;</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    PrintWriter out = resp.getWriter();</span><br><span class="line">    out.write(e.getMessage());</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>失败的回调也是三个参数，前两个就不用说了，第三个是一个 Exception，对于登录失败，会有不同的原因，Exception 中则保存了登录失败的原因，我们可以将之通过 JSON 返回到前端。</p><p>当然大家也看到，在微人事中，我还挨个去识别了一下异常的类型，根据不同的异常类型，我们可以给用户一个更加明确的提示：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">PrintWriter out = resp.getWriter();</span><br><span class="line">RespBean respBean = RespBean.error(e.getMessage());</span><br><span class="line"><span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"账户被锁定，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"密码过期，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"账户过期，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"账户被禁用，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"用户名或者密码输入错误，请重新输入!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><p>这里有一个需要注意的点。</p><p>我们知道，当用户登录时，用户名或者密码输入错误，我们一般只给一个模糊的提示，即<strong>用户名或者密码输入错误，请重新输入</strong>，而不会给一个明确的诸如“用户名输入错误”或“密码输入错误”这样精确的提示，但是对于很多不懂行的新手小伙伴，他可能就会给一个明确的错误提示，这会给系统带来风险。</p><p>但是使用了 Spring Security 这样的安全管理框架之后，即使你是一个新手，也不会犯这样的错误。</p><p>在 Spring Security 中，用户名查找失败对应的异常是：</p><ul><li>UsernameNotFoundException</li></ul><p>密码匹配失败对应的异常是：</p><ul><li>BadCredentialsException</li></ul><p>但是我们在登录失败的回调中，却总是看不到 UsernameNotFoundException 异常，无论用户名还是密码输入错误，抛出的异常都是 BadCredentialsException。</p><p>这是为什么呢？松哥在之前的文章<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">手把手带你捋一遍 Spring Security 登录流程</a>中介绍过，在登录中有一个关键的步骤，就是去加载用户数据，我们再来把这个方法拎出来看一下（部分）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"User '"</span> + username + <span class="hljs-string">"' not found"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> notFound;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，我们看出，在查找用户时，如果抛出了 UsernameNotFoundException，这个异常会被捕获，捕获之后，如果 hideUserNotFoundExceptions 属性的值为 true，就抛出一个 BadCredentialsException。相当于将 UsernameNotFoundException 异常隐藏了，而默认情况下，hideUserNotFoundExceptions 的值就为 true。</p><p>看到这里大家就明白了为什么无论用户还是密码写错，你收到的都是 BadCredentialsException 异常。</p><p>一般来说这个配置是不需要修改的，如果你一定要区别出来 UsernameNotFoundException 和 BadCredentialsException，我这里给大家提供三种思路：</p><ol><li>自己定义 DaoAuthenticationProvider 代替系统默认的，在定义时将 hideUserNotFoundExceptions 属性设置为 false。</li><li>当用户名查找失败时，不抛出 UsernameNotFoundException 异常，而是抛出一个自定义异常，这样自定义异常就不会被隐藏，进而在登录失败的回调中根据自定义异常信息给前端用户一个提示。</li><li>当用户名查找失败时，直接抛出 BadCredentialsException，但是异常信息为 “用户名不存在”。</li></ol><p>三种思路仅供小伙伴们参考，除非情况特殊，一般不用修改这一块的默认行为。</p><p>官方这样做的好处是什么呢？很明显可以强迫开发者给一个模糊的异常提示，这样即使是不懂行的新手，也不会将系统置于危险之中。</p><p>好了，这样配置完成后，无论是登录成功还是失败，后端都将只返回 JSON 给前端了。</p><h2 id="3-未认证处理方案"><a href="#3-未认证处理方案" class="headerlink" title="3. 未认证处理方案"></a>3. 未认证处理方案</h2><p>那未认证又怎么办呢？</p><p>有小伙伴说，那还不简单，没有认证就访问数据，直接重定向到登录页面就行了，这没错，系统默认的行为也是这样。</p><p>但是在前后端分离中，这个逻辑明显是有问题的，如果用户没有登录就访问一个需要认证后才能访问的页面，这个时候，我们不应该让用户重定向到登录页面，而是给用户一个尚未登录的提示，前端收到提示之后，再自行决定页面跳转。</p><p>要解决这个问题，就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Performs the redirect (or forward) to the login form URL.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationException authException)</span> </span>&#123;</span><br><span class="line">String redirectUrl = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (useForward) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (forceHttps &amp;&amp; <span class="hljs-string">"http"</span>.equals(request.getScheme())) &#123;</span><br><span class="line">redirectUrl = buildHttpsRedirectUrlForRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (redirectUrl == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String loginForm = determineUrlToUseForThisRequest(request, response,</span><br><span class="line">authException);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Server side forward to: "</span> + loginForm);</span><br><span class="line">&#125;</span><br><span class="line">RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);</span><br><span class="line">&#125;</span><br><span class="line">redirectStrategy.sendRedirect(request, response, redirectUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p><p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.csrf().disable().exceptionHandling()</span><br><span class="line">.authenticationEntryPoint((req, resp, authException) -&gt; &#123;</span><br><span class="line">            resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">            PrintWriter out = resp.getWriter();</span><br><span class="line">            out.write(<span class="hljs-string">"尚未登录，请先登录"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p><h2 id="4-注销登录"><a href="#4-注销登录" class="headerlink" title="4. 注销登录"></a>4. 注销登录</h2><p>最后我们再来看看注销登录的处理方案。</p><p>注销登录我们前面说过，按照前面的配置，注销登录之后，系统自动跳转到登录页面，这也是不合适的，如果是前后端分离项目，注销登录成功后返回 JSON 即可，配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.and()</span><br><span class="line">.logout()</span><br><span class="line">.logoutUrl(<span class="hljs-string">"/logout"</span>)</span><br><span class="line">.logoutSuccessHandler((req, resp, authentication) -&gt; &#123;</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    PrintWriter out = resp.getWriter();</span><br><span class="line">    out.write(<span class="hljs-string">"注销成功"</span>);</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;)</span><br><span class="line">.permitAll()</span><br><span class="line">.and()</span><br></pre></td></tr></table></figure><p>这样，注销成功之后，前端收到的也是 JSON 了：</p><p><img src="http://img.itboyhub.com/2020/03/spring-security-4-2.png" alt></p><p>好了，本文就和小伙伴们介绍下前后端分离中常见的 JSON 交互问题，<strong>小伙伴们如果觉得文章有帮助，记得点一下在看哦。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本系列的第四篇，有小伙伴找不到之前文章，松哥给大家列一个索引出来：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>奇怪，Spring Security 登录成功后总是获取不到登录用户信息？</title>
    <link href="http://www.javaboy.org/2020/0401/spring-security-securitycontext.html"/>
    <id>http://www.javaboy.org/2020/0401/spring-security-securitycontext.html</id>
    <published>2020-03-31T23:12:38.000Z</published>
    <updated>2020-04-14T23:44:54.213Z</updated>
    
    <content type="html"><![CDATA[<p>有好几位小伙伴小伙伴曾向松哥求助过这个问题。</p><p>一开始我觉得这可能是一个小概率 BUG，但是当问的人多了，我觉得这个问题对于新手来说还有一定的普遍性，有必要来写篇文章跟大家仔细聊一聊这个问题，防止小伙伴们掉坑。</p><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/qUDZdTPc4-2UtmHtFI4v-g" target="_blank" rel="noopener">本文配套视频地址</a></p><h2 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1.问题复现"></a>1.问题复现</h2><p>如果使用了 Spring Security，当我们登录成功后，可以通过如下方式获取到当前登录用户信息：</p><ol><li><code>SecurityContextHolder.getContext().getAuthentication()</code></li><li>在 Controller 的方法中，加入 Authentication 参数</li></ol><p>这两种办法，都可以获取到当前登录用户信息。具体的操作办法，大家可以看看松哥之前发布的教程：<a href="https://mp.weixin.qq.com/s/jQZx4i4-vqjpBjpoJKJF4A" target="_blank" rel="noopener">Spring Security 如何动态更新已登录用户信息？</a>。</p><p>正常情况下，我们通过如上两种方式的任意一种就可以获取到已经登录的用户信息。</p><p>异常情况，就是这两种方式中的任意一种，都返回 null。</p><p>都返回 null，意味着系统收到当前请求时并不知道你已经登录了（因为你没有在系统中留下任何有效信息），这会带来两个问题：</p><ol><li>无法获取到当前登录用户信息。</li><li>当你发送任何请求，系统都会给你返回 401。</li></ol><h2 id="2-顺藤摸瓜"><a href="#2-顺藤摸瓜" class="headerlink" title="2.顺藤摸瓜"></a>2.顺藤摸瓜</h2><p>要弄明白这个问题，我们就得明白 Spring Security 中的用户信息到底是在哪里存的？</p><p>前面说了两种数据获取方式，但是这两种数据获取方式，获取到的数据又是从哪里来的？</p><p>首先松哥之前和大家聊过，SecurityContextHolder 中的数据，本质上是保存在 <code>ThreadLocal</code> 中，<code>ThreadLocal</code> 的特点是存在它里边的数据，哪个线程存的，哪个线程才能访问到。</p><p>这样就带来一个问题，当不同的请求进入到服务端之后，由不同的 thread 去处理，按理说后面的请求就可能无法获取到登录请求的线程存入的数据，例如登录请求在线程 A 中将登录用户信息存入 <code>ThreadLocal</code>，后面的请求来了，在线程 B 中处理，那此时就无法获取到用户的登录信息。</p><p>但实际上，正常情况下，我们每次都能够获取到登录用户信息，这又是怎么回事呢？</p><p>这我们就要引入 Spring Security 中的 <code>SecurityContextPersistenceFilter</code> 了。</p><p>小伙伴们都知道，无论是 Spring Security 还是 Shiro，它的一系列功能其实都是由过滤器来完成的，在 Spring Security 中，松哥前面跟大家聊了 <code>UsernamePasswordAuthenticationFilter</code> 过滤器，在这个过滤器之前，还有一个过滤器就是 <code>SecurityContextPersistenceFilter</code>，请求在到达 <code>UsernamePasswordAuthenticationFilter</code> 之前都会先经过 <code>SecurityContextPersistenceFilter</code>。</p><p>我们来看下它的源码(部分)：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityContextPersistenceFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">HttpRequestResponseHolder holder = <span class="hljs-keyword">new</span> HttpRequestResponseHolder(request,</span><br><span class="line">response);</span><br><span class="line">SecurityContext contextBeforeChainExecution = repo.loadContext(holder);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">SecurityContext contextAfterChainExecution = SecurityContextHolder</span><br><span class="line">.getContext();</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line">repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本的方法很长，我这里列出来了比较关键的几个部分：</p><ol><li>SecurityContextPersistenceFilter 继承自 GenericFilterBean，而 GenericFilterBean 则是 Filter 的实现，所以 SecurityContextPersistenceFilter 作为一个过滤器，它里边最重要的方法就是 doFilter 了。</li><li>在 doFilter 方法中，它首先会从 repo 中读取一个 SecurityContext 出来，这里的 repo 实际上就是 HttpSessionSecurityContextRepository，读取 SecurityContext 的操作会进入到 readSecurityContextFromSession 方法中，在这里我们看到了读取的核心方法 <code>Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);</code>，这里的 springSecurityContextKey 对象的值就是 SPRING_SECURITY_CONTEXT，读取出来的对象最终会被转为一个 SecurityContext 对象。</li><li>SecurityContext 是一个接口，它有一个唯一的实现类 SecurityContextImpl，这个实现类其实就是用户信息在 session 中保存的 value。</li><li>在拿到 SecurityContext 之后，通过 SecurityContextHolder.setContext 方法将这个 SecurityContext 设置到 ThreadLocal 中去，这样，在当前请求中，Spring Security 的后续操作，我们都可以直接从 SecurityContextHolder 中获取到用户信息了。</li><li>接下来，通过 chain.doFilter 让请求继续向下走（这个时候就会进入到 <code>UsernamePasswordAuthenticationFilter</code> 过滤器中了）。</li><li>在过滤器链走完之后，数据响应给前端之后，finally 中还有一步收尾操作，这一步很关键。这里从 SecurityContextHolder 中获取到 SecurityContext，获取到之后，会把 SecurityContextHolder 清空，然后调用 repo.saveContext 方法将获取到的 SecurityContext 存入 session 中。</li></ol><p>至此，整个流程就很明了了。</p><p>每一个请求到达服务端的时候，首先从 session 中找出来 SecurityContext ，然后设置到 SecurityContextHolder 中去，方便后续使用，当这个请求离开的时候，SecurityContextHolder 会被清空，SecurityContext 会被放回 session 中，方便下一个请求来的时候获取。</p><p>搞明白这一点之后，再去解决 Spring Security 登录后无法获取到当前登录用户这个问题，就非常 easy 了。</p><h2 id="3-问题解决"><a href="#3-问题解决" class="headerlink" title="3.问题解决"></a>3.问题解决</h2><p>经过上面的分析之后，我们再来回顾一下为什么会发生登录之后无法获取到当前用户信息这样的事情？</p><p>最简单情况的就是你在一个新的线程中去执行 <code>SecurityContextHolder.getContext().getAuthentication()</code>，这肯定获取不到用户信息，无需多说。例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/menu"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Menu&gt; <span class="hljs-title">getMenusByHrId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">            System.out.println(authentication);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="hljs-keyword">return</span> menuService.getMenusByHrId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种简单的问题相信大家都能够很容易排查到。</p><p>还有一种隐藏比较深的就是在 SecurityContextPersistenceFilter 的 doFilter 方法中没能从 session 中加载到用户信息，进而导致 SecurityContextHolder 里边空空如也。</p><p>在 SecurityContextPersistenceFilter 中没能加载到用户信息，原因可能就比较多了，例如：</p><ul><li><strong>上一个请求临走的时候，没有将数据存储到 session 中去。</strong></li><li><strong>当前请求自己没走过滤器链。</strong></li></ul><p>什么时候会发生这个问题呢？有的小伙伴可能在配置 SecurityConfig#configure(WebSecurity) 方法时，会忽略掉一个重要的点。</p><p>当我们想让 Spring Security 中的资源可以匿名访问时，我们有两种办法：</p><ol><li>不走 Spring Security 过滤器链。</li><li>继续走 Spring Security 过滤器链，但是可以匿名访问。</li></ol><p>这两种办法对应了两种不同的配置方式。其中第一种配置可能会影响到我们获取登录用户信息，第二种则不影响，所以这里我们来重点看看第一种。</p><p>不想走 Spring Security 过滤器链，我们一般可以通过如下方式配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/index.html"</span>,<span class="hljs-string">"/img/**"</span>,<span class="hljs-string">"/fonts/**"</span>,<span class="hljs-string">"/favicon.ico"</span>,<span class="hljs-string">"/verifyCode"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常这样配置是没有问题的。</p><p>如果你很不巧，把登录请求地址放进来了，那就 gg 了。虽然登录请求可以被所有人访问，但是不能放在这里（而应该通过允许匿名访问的方式来给请求放行）。<strong>如果放在这里，登录请求将不走 <code>SecurityContextPersistenceFilter</code> 过滤器，也就意味着不会将登录用户信息存入 session，进而导致后续请求无法获取到登录用户信息。</strong></p><p>这也就是一开始小伙伴遇到的问题。</p><p>好了，小伙伴们如果在使用 Spring Security 时遇到类似问题，不妨按照本文提供的思路来解决一下。<strong>如果觉得有收获，记得点一下右下角在看哦</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有好几位小伙伴小伙伴曾向松哥求助过这个问题。&lt;/p&gt;
&lt;p&gt;一开始我觉得这可能是一个小概率 BUG，但是当问的人多了，我觉得这个问题对于新手来说还有一定的普遍性，有必要来写篇文章跟大家仔细聊一聊这个问题，防止小伙伴们掉坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离中，使用 JSON 格式登录原来这么简单！</title>
    <link href="http://www.javaboy.org/2020/0331/spring-security-json.html"/>
    <id>http://www.javaboy.org/2020/0331/spring-security-json.html</id>
    <published>2020-03-30T23:12:21.000Z</published>
    <updated>2020-04-14T23:45:18.593Z</updated>
    
    <content type="html"><![CDATA[<p>流程做微人事的小伙伴（<a href="https://github.com/lenve/vhr），应该都发现了在微人事中有一个极为特殊的请求，那就是登录。" target="_blank" rel="noopener">https://github.com/lenve/vhr），应该都发现了在微人事中有一个极为特殊的请求，那就是登录。</a></p><p>登录请求是一个 POST 请求，但是数据传输格式是 key/value 的形式。整个项目里就只有这一个 POST 请求是这样，其他 POST 请求都是 JSON 格式的数据。</p><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/RHoXwIn6J-O8tbVjsYIcBQ" target="_blank" rel="noopener">本文配套视频地址</a></p><p>为什么做成这个样子呢？还是懒呗。</p><p>因为 Spring Security 中默认的登录数据格式就是 key/value 的形式，一直以来懒得改。最近刚好在录 Spring Security，就抽空把这里调整了下，这样前后端就能统一起来了。</p><p>好了，我们一起来看下怎么实现。</p><h2 id="1-服务端接口调整"><a href="#1-服务端接口调整" class="headerlink" title="1.服务端接口调整"></a>1.服务端接口调整</h2><p>首先大家知道，用户登录的用户名/密码是在 <code>UsernamePasswordAuthenticationFilter</code> 类中处理的，具体的处理代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">String username = obtainUsername(request);</span><br><span class="line">String password = obtainPassword(request);</span><br><span class="line">    <span class="hljs-comment">//省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getParameter(passwordParameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getParameter(usernameParameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，我们就可以看出来为什么 Spring Security 默认是通过 key/value 的形式来传递登录参数，因为它处理的方式就是 request.getParameter。</p><p>所以我们要定义成 JSON 的，思路很简单，就是自定义来定义一个过滤器代替 <code>UsernamePasswordAuthenticationFilter</code> ，然后在获取参数的时候，换一种方式就行了。</p><p><strong>这里有一个额外的点需要注意，就是我们的微人事现在还有验证码的功能，所以如果自定义过滤器，要连同验证码一起处理掉。</strong></p><h2 id="2-自定义过滤器"><a href="#2-自定义过滤器" class="headerlink" title="2.自定义过滤器"></a>2.自定义过滤器</h2><p>接下来我们来自定义一个过滤器代替 <code>UsernamePasswordAuthenticationFilter</code> ，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!request.getMethod().equals(<span class="hljs-string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(</span><br><span class="line">                    <span class="hljs-string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">        &#125;</span><br><span class="line">        String verify_code = (String) request.getSession().getAttribute(<span class="hljs-string">"verify_code"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)) &#123;</span><br><span class="line">            Map&lt;String, String&gt; loginData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                loginData = <span class="hljs-keyword">new</span> ObjectMapper().readValue(request.getInputStream(), Map.class);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            &#125;<span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                String code = loginData.get(<span class="hljs-string">"code"</span>);</span><br><span class="line">                checkCode(response, code, verify_code);</span><br><span class="line">            &#125;</span><br><span class="line">            String username = loginData.get(getUsernameParameter());</span><br><span class="line">            String password = loginData.get(getPasswordParameter());</span><br><span class="line">            <span class="hljs-keyword">if</span> (username == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                username = <span class="hljs-string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (password == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                password = <span class="hljs-string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            username = username.trim();</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                    username, password);</span><br><span class="line">            setDetails(request, authRequest);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            checkCode(response, request.getParameter(<span class="hljs-string">"code"</span>), verify_code);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.attemptAuthentication(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkCode</span><span class="hljs-params">(HttpServletResponse resp, String code, String verify_code)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (code == <span class="hljs-keyword">null</span> || verify_code == <span class="hljs-keyword">null</span> || <span class="hljs-string">""</span>.equals(code) || !verify_code.toLowerCase().equals(code.toLowerCase())) &#123;</span><br><span class="line">            <span class="hljs-comment">//验证码不正确</span></span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"验证码不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段逻辑我们基本上是模仿官方提供的 <code>UsernamePasswordAuthenticationFilter</code> 来写的，我来给大家稍微解释下：</p><ol><li>首先登录请求肯定是 POST，如果不是 POST ，直接抛出异常，后面的也不处理了。</li><li>因为要在这里处理验证码，所以第二步从 session 中把已经下发过的验证码的值拿出来。</li><li>接下来通过 contentType 来判断当前请求是否通过 JSON 来传递参数，如果是通过 JSON 传递参数，则按照 JSON 的方式解析，如果不是，则调用 super.attemptAuthentication 方法，进入父类的处理逻辑中，也就是说，我们自定义的这个类，既支持 JSON 形式传递参数，也支持 key/value 形式传递参数。</li><li>如果是 JSON 形式的数据，我们就通过读取 request 中的 I/O 流，将 JSON 映射到一个 Map 上。</li><li>从 Map 中取出 code，先去判断验证码是否正确，如果验证码有错，则直接抛出异常。验证码的判断逻辑，大家可以参考：<a href="https://mp.weixin.qq.com/s/aaop_dS9UIOgTtQd0hl_tw" target="_blank" rel="noopener">松哥手把手教你给微人事添加登录验证码</a>。</li><li>接下来从 Map 中取出 username 和 password，构造 UsernamePasswordAuthenticationToken 对象并作校验。</li></ol><p>过滤器定义完成后，接下来用我们自定义的过滤器代替默认的 <code>UsernamePasswordAuthenticationFilter</code>，首先我们需要提供一个 LoginFilter 的实例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LoginFilter loginFilter = <span class="hljs-keyword">new</span> LoginFilter();</span><br><span class="line">    loginFilter.setAuthenticationSuccessHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">            PrintWriter out = response.getWriter();</span><br><span class="line">            Hr hr = (Hr) authentication.getPrincipal();</span><br><span class="line">            hr.setPassword(<span class="hljs-keyword">null</span>);</span><br><span class="line">            RespBean ok = RespBean.ok(<span class="hljs-string">"登录成功!"</span>, hr);</span><br><span class="line">            String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(ok);</span><br><span class="line">            out.write(s);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    loginFilter.setAuthenticationFailureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">            PrintWriter out = response.getWriter();</span><br><span class="line">            RespBean respBean = RespBean.error(exception.getMessage());</span><br><span class="line">            <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">                respBean.setMsg(<span class="hljs-string">"账户被锁定，请联系管理员!"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">                respBean.setMsg(<span class="hljs-string">"密码过期，请联系管理员!"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">                respBean.setMsg(<span class="hljs-string">"账户过期，请联系管理员!"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">                respBean.setMsg(<span class="hljs-string">"账户被禁用，请联系管理员!"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">                respBean.setMsg(<span class="hljs-string">"用户名或者密码输入错误，请重新输入!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    loginFilter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">    loginFilter.setFilterProcessesUrl(<span class="hljs-string">"/doLogin"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> loginFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们代替了 <code>UsernamePasswordAuthenticationFilter</code> 之后，原本在 SecurityConfig#configure 方法中关于 form 表单的配置就会失效，那些失效的属性，都可以在配置 LoginFilter 实例的时候配置。</p><p>另外记得配置一个 AuthenticationManager，根据 WebSecurityConfigurerAdapter 中提供的配置即可。</p><p>FilterProcessUrl 则可以根据实际情况配置，如果不配置，默认的就是 <code>/login</code>。</p><p>最后，我们用自定义的 LoginFilter 实例代替 <code>UsernamePasswordAuthenticationFilter</code>，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">        ...</span><br><span class="line">        <span class="hljs-comment">//省略</span></span><br><span class="line">    http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 addFilterAt 方法完成替换操作。</p><p>篇幅原因，我这里只展示了部分代码，完整代码小伙伴们可以在 GitHub 上看到：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>。</p><p>配置完成后，重启后端，先用 POSTMAN 测试登录接口，如下：</p><p><img src="http://img.itboyhub.com/2020/03/spring-security-json-1.png" alt></p><h2 id="3-前端修改"><a href="#3-前端修改" class="headerlink" title="3.前端修改"></a>3.前端修改</h2><p>原本我们的前端登录代码是这样的：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">this</span>.$refs.loginForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (valid) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">true</span>;</span><br><span class="line">        <span class="hljs-keyword">this</span>.postKeyValueRequest(<span class="hljs-string">'/doLogin'</span>, <span class="hljs-keyword">this</span>.loginForm).then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="line">            <span class="hljs-comment">//省略</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先我们去校验数据，在校验成功之后，通过 postKeyValueRequest 方法来发送登录请求，这个方法是我自己封装的通过 key/value 形式传递参数的 POST 请求，如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> postKeyValueRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> axios(&#123;</span><br><span class="line">        method: <span class="hljs-string">'post'</span>,</span><br><span class="line">        url: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">        data: params,</span><br><span class="line">        transformRequest: [<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">let</span> ret = <span class="hljs-string">''</span>;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> data) &#123;</span><br><span class="line">                ret += <span class="hljs-built_in">encodeURIComponent</span>(i) + <span class="hljs-string">'='</span> + <span class="hljs-built_in">encodeURIComponent</span>(data[i]) + <span class="hljs-string">'&amp;'</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> ret;</span><br><span class="line">        &#125;],</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/x-www-form-urlencoded'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> postRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> axios(&#123;</span><br><span class="line">        method: <span class="hljs-string">'post'</span>,</span><br><span class="line">        url: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">        data: params</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postKeyValueRequest 是我封装的通过 key/value 形式传递参数，postRequest 则是通过 JSON 形式传递参数。</p><p>所以，前端我们只需要对登录请求稍作调整，如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">this</span>.$refs.loginForm.validate(<span class="hljs-function">(<span class="hljs-params">valid</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (valid) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">true</span>;</span><br><span class="line">        <span class="hljs-keyword">this</span>.postRequest(<span class="hljs-string">'/doLogin'</span>, <span class="hljs-keyword">this</span>.loginForm).then(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.loading = <span class="hljs-literal">false</span>;</span><br><span class="line">            <span class="hljs-comment">//省略</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>配置完成后，再去登录，浏览器按 F12 ，就可以看到登录请求的参数形式了：</p><p><img src="http://img.itboyhub.com/2020/03/spring-security-json-2.png" alt></p><p>好啦，这就是松哥和大家介绍的 SpringSecurity+JSON+验证码登录，<strong>如果觉得还不错，记得点一下右下角在看哦。</strong></p><p>完整代码小伙伴们可以在 GitHub 上下载：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;流程做微人事的小伙伴（&lt;a href=&quot;https://github.com/lenve/vhr），应该都发现了在微人事中有一个极为特殊的请求，那就是登录。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lenve/vhr），应该都发现了在微人事中有一个极为特殊的请求，那就是登录。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登录请求是一个 POST 请求，但是数据传输格式是 key/value 的形式。整个项目里就只有这一个 POST 请求是这样，其他 POST 请求都是 JSON 格式的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="前后端分离" scheme="http://www.javaboy.org/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你定制 Spring Security 中的表单登录</title>
    <link href="http://www.javaboy.org/2020/0330/spring-security-custom-formlogin.html"/>
    <id>http://www.javaboy.org/2020/0330/spring-security-custom-formlogin.html</id>
    <published>2020-03-29T23:11:59.000Z</published>
    <updated>2020-04-14T23:45:48.337Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">本文配套视频地址</a></p><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><a id="more"></a><p>以下是视频笔记。</p><p>Spring Security 系列继续。</p><p>前面的视频+文章，松哥和大家简单聊了 Spring Security 的基本用法，并且我们一起自定义了一个登录页面，让登录看起来更炫一些！</p><p>今天我们来继续深入这个表单配置，挖掘一下这里边常见的其他配置。学习本文，强烈建议大家看一下前置知识（<a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a>），学习效果更佳。</p><h2 id="1-登录接口"><a href="#1-登录接口" class="headerlink" title="1.登录接口"></a>1.登录接口</h2><p>很多初学者分不清登录接口和登录页面，这个我也很郁闷。我还是在这里稍微说一下。</p><p>登录页面就是你看到的浏览器展示出来的页面，像下面这个：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-6.png" alt></p><p>登录接口则是提交登录数据的地方，就是登录页面里边的 form 表单的 action 属性对应的值。</p><p>在 Spring Security 中，如果我们不做任何配置，默认的登录页面和登录接口的地址都是 <code>/login</code>，也就是说，默认会存在如下两个请求：</p><ul><li>GET <a href="http://localhost:8080/login" target="_blank" rel="noopener">http://localhost:8080/login</a></li><li>POST <a href="http://localhost:8080/login" target="_blank" rel="noopener">http://localhost:8080/login</a></li></ul><p>如果是 GET 请求表示你想访问登录页面，如果是 POST 请求，表示你想提交登录数据。</p><p>在<a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">上篇文章</a>中，我们在 SecurityConfig 中自定定义了登录页面地址，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.and()</span><br><span class="line">.formLogin()</span><br><span class="line">.loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">.permitAll()</span><br><span class="line">.and()</span><br></pre></td></tr></table></figure><p>当我们配置了 loginPage 为 <code>/login.html</code> 之后，这个配置从字面上理解，就是设置登录页面的地址为 <code>/login.html</code>。</p><p>实际上它还有一个隐藏的操作，就是登录接口地址也设置成 <code>/login.html</code> 了。换句话说，新的登录页面和登录接口地址都是 <code>/login.html</code>，现在存在如下两个请求：</p><ul><li>GET <a href="http://localhost:8080/login.html" target="_blank" rel="noopener">http://localhost:8080/login.html</a></li><li>POST <a href="http://localhost:8080/login.html" target="_blank" rel="noopener">http://localhost:8080/login.html</a></li></ul><p>前面的 GET 请求用来获取登录页面，后面的 POST 请求用来提交登录数据。</p><p>有的小伙伴会感到奇怪？为什么登录页面和登录接口不能分开配置呢？</p><p>其实是可以分开配置的！</p><p>在 SecurityConfig 中，我们可以通过 loginProcessingUrl 方法来指定登录接口地址，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.and()</span><br><span class="line">.formLogin()</span><br><span class="line">.loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">.loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">.permitAll()</span><br><span class="line">.and()</span><br></pre></td></tr></table></figure><p>这样配置之后，登录页面地址和登录接口地址就分开了，各是各的。</p><p>此时我们还需要修改登录页面里边的 action 属性，改为 <code>/doLogin</code>，如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="hljs-string">"/doLogin"</span> method=<span class="hljs-string">"post"</span>&gt;</span><br><span class="line">&lt;!--省略--&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>此时，启动项目重新进行登录，我们发现依然可以登录成功。</p><p>那么为什么默认情况下两个配置地址是一样的呢？</p><p>我们知道，form 表单的相关配置在 FormLoginConfigurer 中，该类继承自 AbstractAuthenticationFilterConfigurer ，所以当 FormLoginConfigurer 初始化的时候，AbstractAuthenticationFilterConfigurer 也会初始化，在 AbstractAuthenticationFilterConfigurer 的构造方法中，我们可以看到：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractAuthenticationFilterConfigurer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">setLoginPage(<span class="hljs-string">"/login"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是配置默认的 loginPage 为 <code>/login</code>。</p><p>另一方面，FormLoginConfigurer 的初始化方法 init 方法中也调用了父类的 init 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(H http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>.init(http);</span><br><span class="line">initDefaultLoginFilter(http);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在父类的 init 方法中，又调用了 updateAuthenticationDefaults，我们来看下这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateAuthenticationDefaults</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (loginProcessingUrl == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">loginProcessingUrl(loginPage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法的逻辑中我们就可以看到，如果用户没有给 loginProcessingUrl 设置值的话，默认就使用 loginPage 作为 loginProcessingUrl。</p><p>而如果用户配置了 loginPage，在配置完 loginPage 之后，updateAuthenticationDefaults 方法还是会被调用，此时如果没有配置 loginProcessingUrl，则使用新配置的 loginPage 作为 loginProcessingUrl。</p><p>好了，看到这里，相信小伙伴就明白了为什么一开始的登录接口和登录页面地址一样了。</p><h2 id="2-登录参数"><a href="#2-登录参数" class="headerlink" title="2.登录参数"></a>2.登录参数</h2><p>说完登录接口，我们再来说登录参数。</p><p>在<a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">上篇文章</a>中，我们的登录表单中的参数是 username 和 password，注意，默认情况下，这个不能变：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login.html"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pass"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么为什么是这样呢？</p><p>还是回到 FormLoginConfigurer 类中，在它的构造方法中，我们可以看到有两个配置用户名密码的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FormLoginConfigurer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationFilter(), <span class="hljs-keyword">null</span>);</span><br><span class="line">usernameParameter(<span class="hljs-string">"username"</span>);</span><br><span class="line">passwordParameter(<span class="hljs-string">"password"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，首先 super 调用了父类的构造方法，传入了 UsernamePasswordAuthenticationFilter 实例，该实例将被赋值给父类的 authFilter 属性。</p><p>接下来 usernameParameter 方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> FormLoginConfigurer&lt;H&gt; <span class="hljs-title">usernameParameter</span><span class="hljs-params">(String usernameParameter)</span> </span>&#123;</span><br><span class="line">getAuthenticationFilter().setUsernameParameter(usernameParameter);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAuthenticationFilter 实际上是父类的方法，在这个方法中返回了 authFilter 属性，也就是一开始设置的 UsernamePasswordAuthenticationFilter 实例，然后调用该实例的 setUsernameParameter 方法去设置登录用户名的参数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsernameParameter</span><span class="hljs-params">(String usernameParameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.usernameParameter = usernameParameter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的设置有什么用呢？当登录请求从浏览器来到服务端之后，我们要从请求的 HttpServletRequest 中取出来用户的登录用户名和登录密码，怎么取呢？还是在 UsernamePasswordAuthenticationFilter 类中，有如下两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getParameter(passwordParameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getParameter(usernameParameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个时候，就用到默认配置的 username 和 password 了。</p><p>当然，这两个参数我们也可以自己配置，自己配置方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.and()</span><br><span class="line">.formLogin()</span><br><span class="line">.loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">.loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">.usernameParameter(<span class="hljs-string">"name"</span>)</span><br><span class="line">.passwordParameter(<span class="hljs-string">"passwd"</span>)</span><br><span class="line">.permitAll()</span><br><span class="line">.and()</span><br></pre></td></tr></table></figure><p>配置完成后，也要修改一下前端页面：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/doLogin"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"name"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"pass"</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"passwd"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pass"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button login"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意修改 input 的 name 属性值和服务端的对应。</p><p>配置完成后，重启进行登录测试。</p><h2 id="3-登录回调"><a href="#3-登录回调" class="headerlink" title="3.登录回调"></a>3.登录回调</h2><p>在登录成功之后，我们就要分情况处理了，大体上来说，无非就是分为两种情况：</p><ul><li>前后端分离登录</li><li>前后端不分登录</li></ul><p>两种情况的处理方式不一样。本文我们先来卡第二种前后端不分的登录，前后端分离的登录回调我在下篇文章中再来和大家细说。</p><h3 id="3-1-登录成功回调"><a href="#3-1-登录成功回调" class="headerlink" title="3.1 登录成功回调"></a>3.1 登录成功回调</h3><p>在 Spring Security 中，和登录成功重定向 URL 相关的方法有两个：</p><ul><li>defaultSuccessUrl</li><li>successForwardUrl</li></ul><p>这两个咋看没什么区别，实际上内藏乾坤。</p><p>首先我们在配置的时候，defaultSuccessUrl 和 successForwardUrl 只需要配置一个即可，具体配置哪个，则要看你的需求，两个的区别如下：</p><ol><li>defaultSuccessUrl 有一个重载的方法，我们先说一个参数的 defaultSuccessUrl 方法。如果我们在 defaultSuccessUrl 中指定登录成功的跳转页面为 <code>/index</code>，此时分两种情况，如果你是直接在浏览器中输入的登录地址，登录成功后，就直接跳转到 <code>/index</code>，如果你是在浏览器中输入了其他地址，例如 <code>http://localhost:8080/hello</code>，结果因为没有登录，又重定向到登录页面，此时登录成功后，就不会来到 <code>/index</code> ，而是来到 <code>/hello</code> 页面。</li><li>defaultSuccessUrl 还有一个重载的方法，第二个参数如果不设置默认为 false，也就是我们上面的的情况，如果手动设置第二个参数为 true，则 defaultSuccessUrl 的效果和 successForwardUrl 一致。</li><li>successForwardUrl 表示不管你是从哪里来的，登录后一律跳转到 successForwardUrl 指定的地址。例如 successForwardUrl 指定的地址为 <code>/index</code> ，你在浏览器地址栏输入 <code>http://localhost:8080/hello</code>，结果因为没有登录，重定向到登录页面，当你登录成功之后，就会服务端跳转到 <code>/index</code> 页面；或者你直接就在浏览器输入了登录页面地址，登录成功后也是来到 <code>/index</code>。</li></ol><p>相关配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.and()</span><br><span class="line">.formLogin()</span><br><span class="line">.loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">.loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">.usernameParameter(<span class="hljs-string">"name"</span>)</span><br><span class="line">.passwordParameter(<span class="hljs-string">"passwd"</span>)</span><br><span class="line">.defaultSuccessUrl(<span class="hljs-string">"/index"</span>)</span><br><span class="line">.successForwardUrl(<span class="hljs-string">"/index"</span>)</span><br><span class="line">.permitAll()</span><br><span class="line">.and()</span><br></pre></td></tr></table></figure><p><strong>注意：实际操作中，defaultSuccessUrl 和 successForwardUrl 只需要配置一个即可。</strong></p><h3 id="3-2-登录失败回调"><a href="#3-2-登录失败回调" class="headerlink" title="3.2 登录失败回调"></a>3.2 登录失败回调</h3><p>与登录成功相似，登录失败也是有两个方法：</p><ul><li>failureForwardUrl</li><li>failureUrl</li></ul><p><strong>这两个方法在设置的时候也是设置一个即可</strong>。failureForwardUrl 是登录失败之后会发生服务端跳转，failureUrl 则在登录失败之后，会发生重定向。</p><h2 id="4-注销登录"><a href="#4-注销登录" class="headerlink" title="4.注销登录"></a>4.注销登录</h2><p>注销登录的默认接口是 <code>/logout</code>，我们也可以配置。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.and()</span><br><span class="line">.logout()</span><br><span class="line">.logoutUrl(<span class="hljs-string">"/logout"</span>)</span><br><span class="line">.logoutRequestMatcher(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/logout"</span>,<span class="hljs-string">"POST"</span>))</span><br><span class="line">.logoutSuccessUrl(<span class="hljs-string">"/index"</span>)</span><br><span class="line">.deleteCookies()</span><br><span class="line">.clearAuthentication(<span class="hljs-keyword">true</span>)</span><br><span class="line">.invalidateHttpSession(<span class="hljs-keyword">true</span>)</span><br><span class="line">.permitAll()</span><br><span class="line">.and()</span><br></pre></td></tr></table></figure><p>注销登录的配置我来说一下：</p><ol><li>默认注销的 URL 是 <code>/logout</code>，是一个 GET 请求，我们可以通过 logoutUrl 方法来修改默认的注销 URL。</li><li>logoutRequestMatcher 方法不仅可以修改注销 URL，还可以修改请求方式，实际项目中，这个方法和 logoutUrl 任意设置一个即可。</li><li>logoutSuccessUrl 表示注销成功后要跳转的页面。</li><li>deleteCookies 用来清除 cookie。</li><li>clearAuthentication 和 invalidateHttpSession 分别表示清除认证信息和使 HttpSession 失效，默认可以不用配置，默认就会清除。</li></ol><p>好了，今天就先说这么多，这块还剩一些前后端分离交互的，松哥在下篇文章再来和大家细说。</p><p><strong>如果感觉有收获，记得点一下右下角在看哦</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文配套视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 &lt;a href=&quot;https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot + Vue 系列视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>玩转 IDEA 之快速定义单元测试方法</title>
    <link href="http://www.javaboy.org/2020/0328/custom-templates.html"/>
    <id>http://www.javaboy.org/2020/0328/custom-templates.html</id>
    <published>2020-03-27T23:11:41.000Z</published>
    <updated>2020-04-14T23:40:15.007Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个视频教程，视频链接：<a href="https://mp.weixin.qq.com/s/tWexMGLnQ_riyvSPK8v3Rg" target="_blank" rel="noopener">—–&gt;&gt;&gt;&gt;&gt;&gt;&gt;没错，点我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个视频教程，视频链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/tWexMGLnQ_riyvSPK8v3Rg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;—–&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;没错
      
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/categories/IntelliJ-IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/tags/IntelliJ-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手教你入门 Spring Cloud Alibaba Nacos</title>
    <link href="http://www.javaboy.org/2020/0327/spring-cloud-alibaba-nacos.html"/>
    <id>http://www.javaboy.org/2020/0327/spring-cloud-alibaba-nacos.html</id>
    <published>2020-03-27T02:08:40.000Z</published>
    <updated>2020-03-27T03:44:00.639Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Security 的问题我先说一下，视频和文章松哥都在积极准备中，因为都是业余搞，每天下班后都是火急火燎，为了给小伙伴们呈现一段完美的表演，每一个视频都要花不少时间，所以新一期的 Spring Security 估计下周能和小伙伴们见面。</p><a id="more"></a><p>今天就和小伙伴们分享一个存货–Spring Cloud Alibaba Nacos！</p><p>一起来看大屏幕（本视频节选自松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a>）：</p><p><a href="https://mp.weixin.qq.com/s/o_M3IEC4ysOHPgUAfanswA" target="_blank" rel="noopener">视频地址</a></p><p>好啦视频看完啦，如果小伙伴们觉得有收获，记得点一下右下角在看哦。</p><p>以下是视频笔记：</p><p>Nacos 主要提供了服务发现、服务配置以及服务管理。</p><p>基本特性：</p><ul><li>服务发现</li><li>动态配置</li><li>动态 DNS 服务</li><li>服务及元数据管理</li></ul><h2 id="1-安装-配置中心"><a href="#1-安装-配置中心" class="headerlink" title="1. 安装+配置中心"></a>1. 安装+配置中心</h2><ul><li>Docker 安装</li><li>下载源码自己编译安装/下载编译好的安装包</li></ul><p>首先下载安装包：<a href="https://github.com/alibaba/nacos/releases/download/1.2.0-beta.1/nacos-server-1.2.0-beta.1.tar.gz" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases/download/1.2.0-beta.1/nacos-server-1.2.0-beta.1.tar.gz</a></p><p>然后解压，解压后，如果 win，直接在 bin 目录下双击 startup.cmd 启动。<br>如果Linux，bin 目录下执行 sh startup.sh -m standalone.</p><p><strong>注意，系统一定要配置好 jdk，测试一下 java 和 javac 两个命令要存在。</strong></p><p>Nacos 启动成功后，浏览器输入：<a href="http://192.168.91.128:8848/nacos" target="_blank" rel="noopener">http://192.168.91.128:8848/nacos</a> 就能看到启动页面。</p><p>如果有登录页面，登录的默认用户名/密码都是 nacos。</p><p>先来看配置中心，类似于 Spring Cloud Config</p><p>首先在服务端配置，点击配置管理-&gt;配置列表-&gt;+</p><p>这里主要配置三个东西，Data ID、Group 以及要配置的内容。</p><p>Data Id 的格式是 <code>${prefix}-${spring.profile.active}.${file-extension}</code></p><p>${prefix} 的值，默认为 spring.application.name 的值<br>${spring.profile.active} 表示项目当前所处的和环境<br>${file-extension} 表示配置文件的扩展名</p><p>配置完成后，新建 Spring Boot 项目，加入 Nacos 依赖：</p><p><img src="http://img.itboyhub.com//2020/03/nacos-1.png" alt></p><p>然后，新建 bootstrap.properties 配置文件，配置 nacos 信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=nacos</span><br><span class="line">spring.cloud.nacos.server-addr=192.168.91.128:8848</span><br><span class="line">spring.cloud.nacos.config.file-extension=properties</span><br></pre></td></tr></table></figure><p>最后再提供一个测试 Controller：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-meta">@RefreshScope</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;name&#125;"</span>)</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-注册中心"><a href="#2-注册中心" class="headerlink" title="2. 注册中心"></a>2. 注册中心</h2><p>Nacos 做注册中心，可以代替 Eureka。</p><p>创建 Spring Boot 项目，添加依赖：</p><p><img src="http://img.itboyhub.com//2020/03/nacos-2.png" alt></p><p>添加配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=nacos01</span><br><span class="line">spring.cloud.nacos.discovery.server-addr=192.168.91.128:8848</span><br></pre></td></tr></table></figure><p>然后再提供一个测试 Controller：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    Integer port;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello:"</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再将项目打包，启动两个实例。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar nacos01-0.0.1-SNAPSHOT.jar --server.port=8080</span><br><span class="line">java -jar nacos01-0.0.1-SNAPSHOT.jar --server.port=8081</span><br></pre></td></tr></table></figure><p>这样，两个 provider 实例就启动了。</p><p>再来创建一个 consumer ，配置基本与 nacos01 一致。然后再 consumer 中访问 provider 查看负载均衡效果，具体小伙伴们参考视频，我就不重复写啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Security 的问题我先说一下，视频和文章松哥都在积极准备中，因为都是业余搞，每天下班后都是火急火燎，为了给小伙伴们呈现一段完美的表演，每一个视频都要花不少时间，所以新一期的 Spring Security 估计下周能和小伙伴们见面。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/tags/Spring-Cloud/"/>
    
      <category term="Nacos" scheme="http://www.javaboy.org/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手教你用 Redis 做延迟消息队列</title>
    <link href="http://www.javaboy.org/2020/0326/redis-delay-queue.html"/>
    <id>http://www.javaboy.org/2020/0326/redis-delay-queue.html</id>
    <published>2020-03-26T02:06:54.000Z</published>
    <updated>2020-03-27T03:39:30.995Z</updated>
    
    <content type="html"><![CDATA[<p>我们平时说到消息队列，一般都是指 RabbitMQ、RocketMQ、ActiveMQ 以及大数据里边的 Kafka，这些是我们比较常见的消息中间件，也是非常专业的消息中间件，作为专业的中间件，它里边提供了许多功能。</p><a id="more"></a><p>松哥之前也有两篇介绍的文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/aMu1qi46FbzIe0amJ4XJ7w" target="_blank" rel="noopener">我是如何在微人事项目中提高RabbitMQ消息可靠性的？</a></li><li><a href="https://mp.weixin.qq.com/s/SMPyyZlRvvKM-kSMbOOQAw" target="_blank" rel="noopener">Spring Boot 整合 RabbitMQ，消息重复消费怎么办？</a></li></ol><p>但是，当我们需要使用消息中间件的时候，并非每次都需要非常专业的消息中间件，假如我们只有一个消息队列，只有一个消费者，那就没有必要去使用上面这些专业的消息中间件，这种情况我们可以直接使用 Redis 来做消息队列。</p><p>Redis 的消息队列不是特别专业，他没有很多高级特性，适用简单的场景，如果对于消息可靠性有着极高的追求，那么不适合使用 Redis 做消息队列。</p><p>好了，我们一起来撸代码（本视频节选自松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a>）：</p><p><a href="https://mp.weixin.qq.com/s/ej_9f4iBOAEPIXxxhFcm-A" target="_blank" rel="noopener">视频地址</a></p><p>以下是视频笔记：</p><h2 id="1-消息队列"><a href="#1-消息队列" class="headerlink" title="1.消息队列"></a>1.消息队列</h2><p>Redis 做消息队列，使用它里边的 List 数据结构就可以实现，我们可以使用 lpush/rpush 操作来实现入队，然后使用 lpop/rpop 来实现出队。</p><p>回顾一下：</p><p><img src="http://img.itboyhub.com/2020/03/redis-7-1.png" alt></p><p>在客户端（例如 Java 端），我们会维护一个死循环来不停的从队列中读取消息，并处理，如果队列中有消息，则直接获取到，如果没有消息，就会陷入死循环，直到下一次有消息进入，这种死循环会造成大量的资源浪费，这个时候，我们可以使用之前讲的 blpop/brpop 。</p><h2 id="2-延迟消息队列"><a href="#2-延迟消息队列" class="headerlink" title="2.延迟消息队列"></a>2.延迟消息队列</h2><p>延迟队列可以通过 zset 来实现，因为 zset 中有一个 score，我们可以把时间作为 score，将 value 存到 redis 中，然后通过轮询的方式，去不断的读取消息出来。</p><p>首先，如果消息是一个字符串，直接发送即可，如果是一个对象，则需要对对象进行序列化，这里我们使用 JSON 来实现序列化和反序列化。</p><p>所以，首先在项目中，添加 JSON 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，构造一个消息对象：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaboyMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String id;</span><br><span class="line">    <span class="hljs-keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"JavaboyMessage&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"id='"</span> + id + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">", data="</span> + data +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来封装一个消息队列：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayMsgQueue</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="hljs-keyword">private</span> String queue;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelayMsgQueue</span><span class="hljs-params">(Jedis jedis, String queue)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="hljs-keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 消息入队</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 要发送的消息</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queue</span><span class="hljs-params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//构造一个 JavaboyMessage</span></span><br><span class="line">        JavaboyMessage msg = <span class="hljs-keyword">new</span> JavaboyMessage();</span><br><span class="line">        msg.setId(UUID.randomUUID().toString());</span><br><span class="line">        msg.setData(data);</span><br><span class="line">        <span class="hljs-comment">//序列化</span></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            String s = <span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(msg);</span><br><span class="line">            System.out.println(<span class="hljs-string">"msg publish:"</span> + <span class="hljs-keyword">new</span> Date());</span><br><span class="line">            <span class="hljs-comment">//消息发送，score 延迟 5 秒</span></span><br><span class="line">            jedis.zadd(queue, System.currentTimeMillis() + <span class="hljs-number">5000</span>, s);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 消息消费</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">            <span class="hljs-comment">//读取 score 在 0 到当前时间戳之间的消息</span></span><br><span class="line">            Set&lt;String&gt; zrange = jedis.zrangeByScore(queue, <span class="hljs-number">0</span>, System.currentTimeMillis(), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (zrange.isEmpty()) &#123;</span><br><span class="line">                <span class="hljs-comment">//如果消息是空的，则休息 500 毫秒然后继续</span></span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="hljs-number">500</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">//如果读取到了消息，则直接读取消息出来</span></span><br><span class="line">            String next = zrange.iterator().next();</span><br><span class="line">            <span class="hljs-keyword">if</span> (jedis.zrem(queue, next) &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">//抢到了，接下来处理业务</span></span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    JavaboyMessage msg = <span class="hljs-keyword">new</span> ObjectMapper().readValue(next, JavaboyMessage.class);</span><br><span class="line">                    System.out.println(<span class="hljs-string">"receive msg:"</span> + msg);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayMsgTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Redis redis = <span class="hljs-keyword">new</span> Redis();</span><br><span class="line">        redis.execute(jedis -&gt; &#123;</span><br><span class="line">            <span class="hljs-comment">//构造一个消息队列</span></span><br><span class="line">            DelayMsgQueue queue = <span class="hljs-keyword">new</span> DelayMsgQueue(jedis, <span class="hljs-string">"javaboy-delay-queue"</span>);</span><br><span class="line">            <span class="hljs-comment">//构造消息生产者</span></span><br><span class="line">            Thread producer = <span class="hljs-keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">                        queue.queue(<span class="hljs-string">"www.javaboy.org&gt;&gt;&gt;&gt;"</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="hljs-comment">//构造一个消息消费者</span></span><br><span class="line">            Thread consumer = <span class="hljs-keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                    queue.loop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="hljs-comment">//启动</span></span><br><span class="line">            producer.start();</span><br><span class="line">            consumer.start();</span><br><span class="line">            <span class="hljs-comment">//休息 7 秒后，停止程序</span></span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">7000</span>);</span><br><span class="line">                consumer.interrupt();</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，我们利用 Java 代码结合 Redis 中的 zset 就非常方便的实现了延迟消息队列。</p><p><strong>小伙伴们有没有 GET 到呢？如果感觉有收获，记得点一下右下角的在看哦</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们平时说到消息队列，一般都是指 RabbitMQ、RocketMQ、ActiveMQ 以及大数据里边的 Kafka，这些是我们比较常见的消息中间件，也是非常专业的消息中间件，作为专业的中间件，它里边提供了许多功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手带你入门 Spring Security，别再问密码怎么解密了</title>
    <link href="http://www.javaboy.org/2020/0325/spring-security-form-login.html"/>
    <id>http://www.javaboy.org/2020/0325/spring-security-form-login.html</id>
    <published>2020-03-25T02:06:39.000Z</published>
    <updated>2020-03-27T03:03:03.797Z</updated>
    
    <content type="html"><![CDATA[<p>因为之前有小伙伴在松哥群里讨论如何给微人事的密码解密，我看到聊天记录后就惊呆了。</p><p>无论如何我也得写一篇文章，带大家入门 Spring Security!当我们在一个项目中引入 Spring Security 相关依赖后，默认的就是表单登录，因此我们就从表单登录开始讲起。</p><a id="more"></a><p><strong>Spring Security 初体验</strong></p><iframe src="//player.bilibili.com/player.html?bvid=BV117411y7Wc&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p><strong>通过 Java 类定义用户</strong></p><iframe src="//player.bilibili.com/player.html?bvid=BV1m7411y7Jw&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p><strong>自定义登录表单</strong></p><iframe src="//player.bilibili.com/player.html?bvid=BV1m7411y77X&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>视频看完了，如果小伙伴们觉得松哥的视频风格还能接受，也可以看看松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a></p><p>以下是视频笔记。</p><h2 id="1-新建项目"><a href="#1-新建项目" class="headerlink" title="1.新建项目"></a>1.新建项目</h2><p>首先新建一个 Spring Boot 项目，创建时引入 Spring Security 依赖和 web 依赖，如下图：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-1.png" alt></p><p>项目创建成功后，Spring Security 的依赖就添加进来了，在 Spring Boot 中我们加入的是 <code>spring-boot-starter-security</code> ，其实主要是这两个：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-2.png" alt></p><p>项目创建成功后，我们添加一个测试的 HelloController，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来什么事情都不用做，我们直接来启动项目。</p><p>在项目启动过程中，我们会看到如下一行日志：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using generated security password: 30abfb1f-36e1-446a-a79b-f70024f589ab</span><br></pre></td></tr></table></figure><p>这就是 Spring Security 为默认用户 user 生成的临时密码，是一个 UUID 字符串。</p><p>接下来我们去访问 <code>http://localhost:8080/hello</code> 接口，就可以看到自动重定向到登录页面了：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-3.png" alt></p><p>在登录页面，默认的用户名就是 user，默认的登录密码则是项目启动时控制台打印出来的密码，输入用户名密码之后，就登录成功了，登录成功后，我们就可以访问到 /hello 接口了。</p><p>在 Spring Security 中，默认的登录页面和登录接口，都是 <code>/login</code> ，只不过一个是 get 请求（登录页面），另一个是 post 请求（登录接口）。</p><p><strong>大家可以看到，非常方便，一个依赖就保护了所有接口。</strong></p><p>有人说，你怎么知道知道生成的默认密码是一个 UUID 呢？</p><p>这个其实很好判断。</p><p>和用户相关的自动化配置类在 <code>UserDetailsServiceAutoConfiguration</code> 里边，在该类的 <code>getOrDeducePassword</code> 方法中，我们看到如下一行日志：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (user.isPasswordGenerated()) &#123;</span><br><span class="line">logger.info(String.format(&quot;%n%nUsing generated security password: %s%n&quot;, user.getPassword()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，我们在控制台看到的日志就是从这里打印出来的。打印的条件是 isPasswordGenerated 方法返回 true，即密码是默认生成的。</p><p>进而我们发现，user.getPassword 出现在 SecurityProperties 中，在 SecurityProperties 中我们看到如下定义：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Default user name.</span><br><span class="line"> */</span><br><span class="line">private String name = &quot;user&quot;;</span><br><span class="line">/**</span><br><span class="line"> * Password for the default user name.</span><br><span class="line"> */</span><br><span class="line">private String password = UUID.randomUUID().toString();</span><br><span class="line">private boolean passwordGenerated = true;</span><br></pre></td></tr></table></figure><p>可以看到，默认的用户名就是 user，默认的密码则是 UUID，而默认情况下，passwordGenerated 也为 true。</p><h2 id="2-用户配置"><a href="#2-用户配置" class="headerlink" title="2.用户配置"></a>2.用户配置</h2><p>默认的密码有一个问题就是每次重启项目都会变，这很不方便。</p><p>在正式介绍数据库连接之前，松哥先和大家介绍两种非主流的用户名/密码配置方案。</p><h3 id="2-1-配置文件"><a href="#2-1-配置文件" class="headerlink" title="2.1 配置文件"></a>2.1 配置文件</h3><p>我们可以在 application.properties 中配置默认的用户名密码。</p><p>怎么配置呢？大家还记得上一小节我们说的 SecurityProperties，默认的用户就定义在它里边，是一个静态内部类，我们如果要定义自己的用户名密码，必然是要去覆盖默认配置，我们先来看下 SecurityProperties 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.security"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityProperties</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>这就很清晰了，我们只需要以 spring.security.user 为前缀，去定义用户名密码即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=123</span><br></pre></td></tr></table></figure><p>这就是我们新定义的用户名密码。</p><p>在 properties 中定义的用户名密码最终是通过 set 方法注入到属性中去的，这里我们顺便来看下 SecurityProperties.User#setPassword 方法:</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(password)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.passwordGenerated = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以看到，application.properties 中定义的密码在注入进来之后，还顺便设置了 passwordGenerated 属性为 false，这个属性设置为 false 之后，控制台就不会打印默认的密码了。</p><p>此时重启项目，就可以使用自己定义的用户名/密码登录了。</p><h3 id="2-2-配置类"><a href="#2-2-配置类" class="headerlink" title="2.2 配置类"></a>2.2 配置类</h3><p>除了上面的配置文件这种方式之外，我们也可以在配置类中配置用户名/密码。</p><p>在配置类中配置，我们就要指定 PasswordEncoder 了，这是一个非常关键的东西。</p><p>考虑到有的小伙伴对于 PasswordEncoder 还不太熟悉，因此，我这里先稍微给大家介绍一下 PasswordEncoder 到底是干嘛用的。要说 PasswordEncoder ，就得先说密码加密。</p><h4 id="2-2-1-为什么要加密"><a href="#2-2-1-为什么要加密" class="headerlink" title="2.2.1 为什么要加密"></a>2.2.1 为什么要加密</h4><p>2011 年 12 月 21 日，有人在网络上公开了一个包含 600 万个 CSDN 用户资料的数据库，数据全部为明文储存，包含用户名、密码以及注册邮箱。事件发生后 CSDN 在微博、官方网站等渠道发出了声明，解释说此数据库系 2009 年备份所用，因不明原因泄露，已经向警方报案，后又在官网发出了公开道歉信。在接下来的十多天里，金山、网易、京东、当当、新浪等多家公司被卷入到这次事件中。整个事件中最触目惊心的莫过于 CSDN 把用户密码明文存储，由于很多用户是多个网站共用一个密码，因此一个网站密码泄露就会造成很大的安全隐患。由于有了这么多前车之鉴，我们现在做系统时，密码都要加密处理。</p><p>这次泄密，也留下了一些有趣的事情，特别是对于广大程序员设置密码这一项。人们从 CSDN 泄密的文件中，发现了一些好玩的密码，例如如下这些：</p><ul><li><code>ppnn13%dkstFeb.1st</code> 这段密码的中文解析是：娉娉袅袅十三余，豆蔻梢头二月初。</li><li><code>csbt34.ydhl12s</code> 这段密码的中文解析是：池上碧苔三四点，叶底黄鹂一两声</li><li>…</li></ul><p>等等不一而足，你会发现很多程序员的人文素养还是非常高的，让人啧啧称奇。</p><h4 id="2-2-2-加密方案"><a href="#2-2-2-加密方案" class="headerlink" title="2.2.2 加密方案"></a>2.2.2 加密方案</h4><p>密码加密我们一般会用到散列函数，又称散列算法、哈希函数，这是一种从任何数据中创建数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，重新创建一个散列值。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有 MD5 消息摘要算法、安全散列算法（Secure Hash Algorithm）。</p><p>但是仅仅使用散列函数还不够，为了增加密码的安全性，一般在密码加密过程中还需要加盐，所谓的盐可以是一个随机数也可以是用户名，加盐之后，即使密码明文相同的用户生成的密码密文也不相同，这可以极大的提高密码的安全性。但是传统的加盐方式需要在数据库中有专门的字段来记录盐值，这个字段可能是用户名字段（因为用户名唯一），也可能是一个专门记录盐值的字段，这样的配置比较繁琐。 </p><p>Spring Security 提供了多种密码加密方案，官方推荐使用 BCryptPasswordEncoder，BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。</p><p>不同于 Shiro 中需要自己处理密码加盐，在 Spring Security 中，BCryptPasswordEncoder 就自带了盐，处理起来非常方便。</p><p>而 BCryptPasswordEncoder 就是 PasswordEncoder 接口的实现类。</p><h4 id="2-2-3-PasswordEncoder"><a href="#2-2-3-PasswordEncoder" class="headerlink" title="2.2.3 PasswordEncoder"></a>2.2.3 PasswordEncoder</h4><p>PasswordEncoder 这个接口中就定义了三个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">upgradeEncoding</span><span class="hljs-params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>encode 方法用来对明文密码进行加密，返回加密之后的密文。</li><li>matches 方法是一个密码校对方法，在用户登录的时候，将用户传来的明文密码和数据库中保存的密文密码作为参数，传入到这个方法中去，根据返回的 Boolean 值判断用户密码是否输入正确。</li><li>upgradeEncoding 是否还要进行再次加密，这个一般来说就不用了。</li></ol><p>通过下图我们可以看到 PasswordEncoder 的实现类：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-4.png" alt></p><h4 id="2-2-4-配置"><a href="#2-2-4-配置" class="headerlink" title="2.2.4 配置"></a>2.2.4 配置</h4><p>预备知识讲完后，接下来我们来看具体如何配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"javaboy.org"</span>)</span><br><span class="line">                .password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先我们自定义 SecurityConfig 继承自 WebSecurityConfigurerAdapter，重写里边的 configure 方法。</li><li>首先我们提供了一个 PasswordEncoder 的实例，因为目前的案例还比较简单，因此我暂时先不给密码进行加密，所以返回 NoOpPasswordEncoder 的实例即可。</li><li>configure 方法中，我们通过 inMemoryAuthentication 来开启在内存中定义用户，withUser 中是用户名，password 中则是用户密码，roles 中是用户角色。</li><li>如果需要配置多个用户，用 and 相连。</li></ol><p>为什么用 and 相连呢？</p><blockquote><p>在没有 Spring Boot 的时候，我们都是 SSM 中使用 Spring Security，这种时候都是在 XML 文件中配置 Spring Security，既然是 XML 文件，标签就有开始有结束，现在的 and 符号相当于就是 XML 标签的结束符，表示结束当前标签，这是个时候上下文会回到 inMemoryAuthentication 方法中，然后开启新用户的配置。</p></blockquote><p>配置完成后，再次启动项目，Java 代码中的配置会覆盖掉 XML 文件中的配置，此时再去访问 /hello 接口，就会发现只有 Java 代码中的用户名/密码才能访问成功。</p><h2 id="3-自定义表单登录页"><a href="#3-自定义表单登录页" class="headerlink" title="3.自定义表单登录页"></a>3.自定义表单登录页</h2><p>默认的表单登录有点丑（实际上现在默认的表单登录比以前的好多了，以前的更丑）。</p><p>但是很多时候我们依然绝对这个登录页面有点丑，那我们可以自定义一个登录页面。</p><p>一起来看下。</p><h3 id="3-1-服务端定义"><a href="#3-1-服务端定义" class="headerlink" title="3.1 服务端定义"></a>3.1 服务端定义</h3><p>然后接下来我们继续完善前面的 SecurityConfig 类，继续重写它的 <code>configure(WebSecurity web)</code> 和 <code>configure(HttpSecurity http)</code> 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="hljs-string">"/js/**"</span>, <span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/images/**"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>web.ignoring() 用来配置忽略掉的 URL 地址，一般对于静态文件，我们可以采用此操作。</li><li>如果我们使用 XML 来配置 Spring Security ，里边会有一个重要的标签 <code>&lt;http&gt;</code>，HttpSecurity 提供的配置方法 都对应了该标签。</li><li>authorizeRequests 对应了 <code>&lt;intercept-url&gt;</code>。</li><li>formLogin 对应了 <code>&lt;formlogin&gt;</code>。</li><li>and 方法表示结束当前标签，上下文回到HttpSecurity，开启新一轮的配置。</li><li>permitAll 表示登录相关的页面/接口不要被拦截。</li><li>最后记得关闭 csrf ，关于 csrf 问题我到后面专门和大家说。</li></ol><p>当我们定义了登录页面为 /login.html 的时候，Spring Security 也会帮我们自动注册一个 /login.html 的接口，这个接口是 POST 请求，用来处理登录逻辑。</p><h3 id="3-2-前端定义"><a href="#3-2-前端定义" class="headerlink" title="3.2 前端定义"></a>3.2 前端定义</h3><p>松哥这里准备了一个还过得去的登录页面，如下：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-6.png" alt></p><p>我们将登录页面的相关静态文件拷贝到 Spring Boot 项目的 resources/static 目录下：</p><p><img src="http://img.itboyhub.com//2020/03/spring-security-2-7.png" alt></p><p>前端页面比较长，这里我把核心部分列出来（完整代码我会上传到 GitHub：<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a>）：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login.html"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"name"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"pass"</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pass"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button login"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>form 表单中，注意 action 为 <code>/login.html</code> ，其他的都是常规操作，我就不重复介绍了。</p><p>好了，配置完成后，再去重启项目，此时访问任意页面，就会自动重定向到我们定义的这个页面上来，输入用户名密码就可以重新登录了。</p><h2 id="4-小节"><a href="#4-小节" class="headerlink" title="4.小节"></a>4.小节</h2><p>这篇文章和大家简单聊一下 Spring Security 入门，表单配置还有很多细节，下篇文章我们继续。</p><p><strong>如果文章帮助到小伙伴了，记得右下角点个在看哦。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为之前有小伙伴在松哥群里讨论如何给微人事的密码解密，我看到聊天记录后就惊呆了。&lt;/p&gt;
&lt;p&gt;无论如何我也得写一篇文章，带大家入门 Spring Security!当我们在一个项目中引入 Spring Security 相关依赖后，默认的就是表单登录，因此我们就从表单登录开始讲起。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>挖一个大坑，Spring Security 开搞！</title>
    <link href="http://www.javaboy.org/2020/0324/spring-security-guide.html"/>
    <id>http://www.javaboy.org/2020/0324/spring-security-guide.html</id>
    <published>2020-03-24T02:06:13.000Z</published>
    <updated>2020-03-27T03:18:20.399Z</updated>
    
    <content type="html"><![CDATA[<p>自从 Spring Boot、Spring Cloud 火起来之后，Spring Security 也跟着沾了一把光！</p><a id="more"></a><p>其实我一直觉得 Spring Security 是一个比 Shiro 优秀很多的权限管理框架，但是重量级、配置繁琐、门槛高这些问题一直困扰着 Spring Security 的开发者，也让很多初学者望而却步。直到 Spring Boot 横空出世，这些问题统统都得到缓解。</p><p>在 Spring Boot 或者 Spring Cloud 中，如果想选择一个权限管理框架，几乎毫无疑问的选择 Spring Security，Shiro 在这个环境下已经不具备优势了。</p><p>但是市面上关于 Spring Security 成体系的教程很少，大部分都比较零散，因此，松哥就来劲了，我想把自己这几年使用 Spring Security 的经验整理一下，写一个系列教程，从基本用法，到 OAuth2 再到 Spring Social 对接，都涉及到，目前暂定是图文+视频的形式发布，会在公众号【江南一点雨】上首发，欢迎小伙伴们保持关注。</p><p>这是一个略显宏大的工程，也是松哥比较擅长的事情，因为各种系列教程已经出的太多了。当然，因为工程量比较大，因此需要小伙伴们多给松哥一点时间。</p><h2 id="1-现有资料"><a href="#1-现有资料" class="headerlink" title="1.现有资料"></a>1.现有资料</h2><p>关于 Spring Security，松哥也不是第一次写/录了，但是之前的教程都不够完整，所以我才想出一个完整的，已有的教程主要是两方面的：</p><ol><li>松哥网站上的图文教程</li></ol><p>在网站 <a href="http://www.javaboy.org">www.javaboy.org</a> 上，有一个 Spring Boot 模块，里边的安全管理一栏中，松哥大概写了十篇左右的文章来介绍 Spring Security 。当然这个教程也有离线版，大家在公众号【江南一点雨】的后台回复 SpringBoot，可以获取这个教程的 PDF 版。</p><ol start="2"><li>松哥录制的视频教程</li></ol><p>第二个就是松哥之前录制的 Spring Boot 系列视频教程里边的第十章，视频目录如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├─第 10 章 Spring Boot 安全管理</span><br><span class="line">│      01.安全管理介绍.mp4</span><br><span class="line">│      02.Spring  Security 初体验.mp4</span><br><span class="line">│      03.手工配置用户名密码.mp4</span><br><span class="line">│      04.HttpSecurity 配置.mp4</span><br><span class="line">│      05.登录表单详细配置.mp4</span><br><span class="line">│      06.注销登录配置.mp4</span><br><span class="line">│      07.多个 HttpSecurity.mp4</span><br><span class="line">│      08.密码加密.mp4</span><br><span class="line">│      09.方法安全.mp4</span><br><span class="line">│      10.基于数据库的认证.mp4</span><br><span class="line">│      11.角色继承.mp4</span><br><span class="line">│      12.动态配置权限.mp4</span><br><span class="line">│      13.OAuth2 简介.mp4</span><br><span class="line">│      14.Spring Security 结合 OAuth2.mp4</span><br><span class="line">│      15.整合 Shiro 方式一.mp4</span><br><span class="line">│      16.整合 Shiro 方式二.mp4</span><br><span class="line">│      17.Spring Security 使用 JSON 登录.mp4</span><br></pre></td></tr></table></figure><p>这个视频是为了微人事项目提供支持的，也就是做微人事项目，这系列视频里边录制的知识点够用了。如果大家对这套视频感兴趣，可以查看这里👉<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">松哥自制视频教程</a></p><p>这是松哥之前提供的 Spring Security 相关的教程。</p><h2 id="2-Spring-Security-介绍"><a href="#2-Spring-Security-介绍" class="headerlink" title="2. Spring Security 介绍"></a>2. Spring Security 介绍</h2><p>Java 领域老牌的权限管理框架当属 Shiro 了。</p><p>Shiro 有着众多的优点，例如轻量、简单、易于集成等。</p><p>当然 Shiro 也有不足，例如对 OAuth2 支持不够，在 Spring Boot 面前无法充分展示自己的优势等等，特别是随着现在 Spring Boot 和 Spring Cloud 的流行，Spring Security 正在走向舞台舞台中央。</p><h3 id="2-1-陈年旧事"><a href="#2-1-陈年旧事" class="headerlink" title="2.1 陈年旧事"></a>2.1 陈年旧事</h3><p>Spring Security 最早不叫 Spring Security ，叫 Acegi Security，叫 Acegi Security 并不是说它和 Spring 就没有关系了，它依然是为 Spring 框架提供安全支持的。事实上，Java 领域的框架，很少有框架能够脱离 Spring 框架独立存在。</p><p>Acegi Security 基于 Spring，可以帮助我们为项目建立丰富的角色与权限管理，但是最广为人诟病的则是它臃肿繁琐的配置，这一问题最终也遗传给了 Spring Security。</p><p>在 Acegi Security 时代，网上流传一句话：“每当有人要使用 Acegi Security，就会有一个精灵死去。”足见 Acegi Security 的配置是多么可怕。</p><p>当 Acegi Security 投入 Spring 怀抱之后，先把这个名字改了，这就是大家所见到的 Spring Security 了，然后配置也得到了极大的简化。</p><p>但是和 Shiro 相比，人们对 Spring Security 的评价依然中重量级、配置繁琐。</p><p>直到有一天 Spring Boot 像谜一般出现在江湖边缘，彻底颠覆了 JavaEE 的世界。一人得道鸡犬升天，Spring Security 也因此飞上枝头变凤凰。</p><p>到现在，要不要学习 Spring Security 已经不是问题了，无论是 Spring Boot 还是 Spring Cloud，你都有足够多的机会接触到 Spring Security，现在的问题是如何快速掌握 Spring Security？那么看松哥的教程就对了。</p><h3 id="2-2-核心功能"><a href="#2-2-核心功能" class="headerlink" title="2.2 核心功能"></a>2.2 核心功能</h3><p>对于一个权限管理框架而言，无论是 Shiro 还是 Spring Security，最最核心的功能，无非就是两方面：</p><ul><li>认证</li><li>授权</li></ul><p>通俗点说，认证就是我们常说的登录，授权就是权限鉴别，看看请求是否具备相应的权限。</p><p>虽然就是一个简简单单的登录，可是也能玩出很多花样来。</p><p>Spring Security 支持多种不同的认证方式，这些认证方式有的是 Spring Security 自己提供的认证功能，有的是第三方标准组织制订的，主要有如下一些：</p><p>一些比较常见的认证方式：</p><ul><li>HTTP BASIC authentication headers：基于IETF RFC 标准。</li><li>HTTP Digest authentication headers：基于IETF RFC 标准。</li><li>HTTP X.509 client certificate exchange：基于IETF RFC 标准。</li><li>LDAP：跨平台身份验证。</li><li>Form-based authentication：基于表单的身份验证。</li><li>Run-as authentication：用户用户临时以某一个身份登录。</li><li>OpenID authentication：去中心化认证。</li></ul><p>除了这些常见的认证方式之外，一些比较冷门的认证方式，Spring Security 也提供了支持。</p><ul><li>Jasig Central Authentication Service：单点登录。</li><li>Automatic “remember-me” authentication：记住我登录（允许一些非敏感操作）。</li><li>Anonymous authentication：匿名登录。</li><li>……</li></ul><p>作为一个开放的平台，Spring Security 提供的认证机制不仅仅是上面这些。如果上面这些认证机制依然无法满足你的需求，我们也可以自己定制认证逻辑。当我们需要和一些“老破旧”的系统进行集成时，自定义认证逻辑就显得非常重要了。</p><p>除了认证，剩下的就是授权了。</p><p>Spring Security 支持基于 URL 的请求授权（例如微人事）、支持方法访问授权以及对象访问授权。</p><h2 id="3-怎么学"><a href="#3-怎么学" class="headerlink" title="3.怎么学"></a>3.怎么学</h2><p>安全这一块从来都有说不完的话题，一个简单的注册登录很好做，但是你要是考虑到各种各样的攻击，XSS、CSRF 等等，一个简单的注册登录也能做的很复杂。</p><p>幸运的是，即使你对各种攻击不太熟悉，只要你用了 Spring Security，就能自动避免掉很多攻击了，因为 Spring Security 已经自动帮我们完成很多防护了。</p><p>从这个角度讲，我们学习 Spring Security，不仅仅是学习 Spring Security 的各种用法，也是去了解去熟悉各种网络攻击。</p><p>松哥在未来，将会通过文章+视频的形式来向小伙伴们逐一展示 Spring Security 的用法，从基本的注册登录，到复杂的 OAuth2、Spring Social 登录等，都会和大家介绍。</p><p>本教程会默认大家有 Spring Boot 基础，如果小伙伴们对 Spring Boot 尚不熟悉，可以在公众号【江南一点雨】后台回复 SpringBoot，获取松哥纯手敲 Spring Boot 教程。</p><p>好了，本文就当是一个引子吧，下篇文章我们就开干。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从 Spring Boot、Spring Cloud 火起来之后，Spring Security 也跟着沾了一把光！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>微人事首页加载速度提高了 5 倍，我都做了什么？</title>
    <link href="http://www.javaboy.org/2020/0324/spring-boot-vue-nginx.html"/>
    <id>http://www.javaboy.org/2020/0324/spring-boot-vue-nginx.html</id>
    <published>2020-03-24T02:05:57.000Z</published>
    <updated>2020-03-27T03:17:51.094Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文之前发过，但是比较零散，这里我把用到的方案都汇总一下，方便大家索引，有需要的小伙伴可以收藏下方便查找。里边提到的几种方案，大家都可以对照着视频试一下</strong></p><a id="more"></a><p>问题重现：</p><iframe src="//player.bilibili.com/player.html?bvid=BV1XE411c7u6&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>ElementUI 按需加载：</p><iframe src="//player.bilibili.com/player.html?bvid=BV1QE411c71o&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>SpringBoot 开启 gzip：</p><iframe src="//player.bilibili.com/player.html?bvid=BV1QE411c7Wz&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>Nginx 开启 gzip：</p><iframe src="//player.bilibili.com/player.html?bvid=BV1QE411c7NC&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>前后端分离项目如果做成 SPA（单页面）的形式，就必然面临一个首屏加载的问题，因为默认情况下首页文件比较大，可能超过 1 MB，进而带来首页加载很慢的问题。所以我们要通过优化，来提高首页的加载速度。</p><p>问题的解决，一般来说有这样几种思路：</p><ol><li>UI 组件按需加载</li><li>路由懒加载</li><li>组件重复打包</li><li>gzip</li></ol><p>这些加载方式中，UI 组件按需加载和 gzip 是两种比较常用的方案，另外两种优化方式则要结合具体的项目，看看是否具备相关条件。</p><p>所以，本文松哥就先来和大家聊一聊 UI 组件懒加载和 gzip。</p><h2 id="1-ElementUI-按需加载"><a href="#1-ElementUI-按需加载" class="headerlink" title="1. ElementUI 按需加载"></a>1. ElementUI 按需加载</h2><h3 id="1-1-问题复现"><a href="#1-1-问题复现" class="headerlink" title="1.1 问题复现"></a>1.1 问题复现</h3><p>先来看松哥录制的一段视频：</p><!--more--><p>不做任何优化，我们一般是在 main.js 中按照如下方式来引入 ElementUI 的：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line">Vue.use(ElementUI,&#123;<span class="hljs-attr">size</span>:<span class="hljs-string">'small'</span>&#125;);</span><br></pre></td></tr></table></figure><p>css 这个不用说，肯定得引入。但是按照上面这种引入方式，除了 css，其他组件全部都引入到项目中了，最新版的 ElementUI 中的组件已经接近 60 个了，但是我们项目中用的组件可能没有这么多，这些最终没用上的组件就会造成资源浪费。</p><p>在不做任何优化的情况下，我们通过如下命令对项目生成 report.html 用来帮助我们分析包内容：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue-cli-service build --report</span><br></pre></td></tr></table></figure><p>该命令执行的日志如下(截取了关键部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> warning  </span><br><span class="line"></span><br><span class="line">entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.</span><br><span class="line">Entrypoints:</span><br><span class="line">  app (1.17 MiB)</span><br><span class="line">      css/chunk-vendors.9948ce82.css</span><br><span class="line">      js/chunk-vendors.11959501.js</span><br><span class="line">      css/app.4e8a7623.css</span><br><span class="line">      js/app.ce6f575c.js</span><br><span class="line"></span><br><span class="line">  File                                    Size              Gzipped</span><br><span class="line"></span><br><span class="line">  dist/js/chunk-vendors.11959501.js       840.77 KiB        227.94 KiB</span><br><span class="line">  dist/js/app.ce6f575c.js                 99.08 KiB         30.95 KiB</span><br><span class="line">  dist/js/chunk-64435448.d0a0516e.js      26.52 KiB         5.87 KiB</span><br><span class="line">  dist/js/chunk-0c17a57a.d553638c.js      23.79 KiB         5.49 KiB</span><br><span class="line">  dist/js/chunk-a3fdbb9c.ddc4c008.js      13.30 KiB         3.45 KiB</span><br><span class="line">  dist/js/chunk-54277bc7.2882c4cd.js      10.40 KiB         2.95 KiB</span><br><span class="line">  dist/js/chunk-4e552d82.c64f4d10.js      1.78 KiB          0.63 KiB</span><br><span class="line">  dist/js/chunk-18458ebc.32fb57c9.js      1.54 KiB          0.62 KiB</span><br><span class="line">  dist/js/chunk-2d0d03c8.3a093d55.js      0.52 KiB          0.36 KiB</span><br><span class="line">  dist/js/chunk-2d237c54.0b312051.js      0.43 KiB          0.33 KiB</span><br><span class="line">  dist/css/chunk-vendors.9948ce82.css     258.19 KiB        41.36 KiB</span><br><span class="line">  dist/css/app.4e8a7623.css               3.46 KiB          1.09 KiB</span><br><span class="line">  dist/css/chunk-0c17a57a.9fe19f94.css    0.86 KiB          0.35 KiB</span><br><span class="line">  dist/css/chunk-64435448.3755e146.css    0.30 KiB          0.15 KiB</span><br></pre></td></tr></table></figure><p>从这段日志中我们可以看到，项目入口文件的大小超出了官方建议的 244KB，而这可能会影响网页的表现。</p><p>此时我们把打包后的文件拷贝到 Spring Boot 的 resources/static 目录下，启动后端项目，来看下浏览器的加载情况：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-1.png" alt></p><p>可以看到，最大的 chunk-vendors.11959501.js 文件加载用了 369ms。</p><p>同时大家注意到，此时在前端 dist 目录下还有一个文件叫做 report.html，这是生成的打包报告，我们在浏览器打开这个页面，如下：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-2.png" alt></p><p>在这个 html 页面中，通过可视化页面向我们展示了到底是谁把 js 文件撑大的，从图中我们可以看到，chunk-vendors.11959501.js 文件之所以比较大，是因为它里边的 element-ui.commons.js 这个文件比较大。</p><blockquote><p>实际上，每个模块都可以去想办法优化，但是枪打出头鸟，因为 element-ui.commons.js 实在太大了，我们就先把它给优化了。</p></blockquote><h3 id="1-2-问题解决"><a href="#1-2-问题解决" class="headerlink" title="1.2 问题解决"></a>1.2 问题解决</h3><p>优化办法其实很简单，ElementUI 官网也给出了办法，首先我们加载安装 babel-plugin-component：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure><p>然后修改 babel.config.js 文件，如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    presets: [</span><br><span class="line">        <span class="hljs-string">'@vue/app'</span>,</span><br><span class="line">        [<span class="hljs-string">'@babel/preset-env'</span>, &#123;</span><br><span class="line">            modules: <span class="hljs-literal">false</span></span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    plugins: [</span><br><span class="line">        [</span><br><span class="line">            <span class="hljs-string">"component"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-string">"libraryName"</span>: <span class="hljs-string">"element-ui"</span>,</span><br><span class="line">                <span class="hljs-string">"styleLibraryName"</span>: <span class="hljs-string">"theme-chalk"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，再去修改 main.js 文件，将我们需要用到的组件一个一个引入进来：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> &#123;</span><br><span class="line">    Button,</span><br><span class="line">    Input,</span><br><span class="line">    Table,</span><br><span class="line">    TableColumn,</span><br><span class="line">    Dialog,</span><br><span class="line">    Card,</span><br><span class="line">    Container,</span><br><span class="line">    Icon,</span><br><span class="line">    Select,</span><br><span class="line">    Form,</span><br><span class="line">    Tag,</span><br><span class="line">    Tree,</span><br><span class="line">    Pagination,</span><br><span class="line">    Badge,</span><br><span class="line">    Loading,</span><br><span class="line">    Message,</span><br><span class="line">    MessageBox,</span><br><span class="line">    Menu,</span><br><span class="line">    Tabs,</span><br><span class="line">    TabPane,</span><br><span class="line">    Breadcrumb,</span><br><span class="line">    BreadcrumbItem,</span><br><span class="line">    Dropdown,</span><br><span class="line">    Steps,</span><br><span class="line">    Tooltip,</span><br><span class="line">    Popover,</span><br><span class="line">    Collapse,</span><br><span class="line">    FormItem,</span><br><span class="line">    Checkbox,</span><br><span class="line">    Header,</span><br><span class="line">    DropdownMenu,</span><br><span class="line">    DropdownItem,</span><br><span class="line">    Aside,</span><br><span class="line">    Main,</span><br><span class="line">    MenuItem,</span><br><span class="line">    Submenu,</span><br><span class="line">    Option,</span><br><span class="line">    Col,</span><br><span class="line">    Row,</span><br><span class="line">    Upload,</span><br><span class="line">    Radio,</span><br><span class="line">    DatePicker,</span><br><span class="line">    RadioGroup,</span><br><span class="line">    CollapseItem,</span><br><span class="line">    Switch</span><br><span class="line">&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'element-ui'</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line">Vue.prototype.$ELEMENT = &#123;<span class="hljs-attr">size</span>: <span class="hljs-string">'small'</span>, <span class="hljs-attr">zIndex</span>: <span class="hljs-number">3000</span>&#125;;</span><br><span class="line">Vue.use(Switch);</span><br><span class="line">Vue.use(CollapseItem);</span><br><span class="line">Vue.use(Radio);</span><br><span class="line">Vue.use(RadioGroup);</span><br><span class="line">Vue.use(DatePicker);</span><br><span class="line">Vue.use(Upload);</span><br><span class="line">Vue.use(Row);</span><br><span class="line">Vue.use(Col);</span><br><span class="line">Vue.use(Option);</span><br><span class="line">Vue.use(Submenu);</span><br><span class="line">Vue.use(MenuItem);</span><br><span class="line">Vue.use(Header);</span><br><span class="line">Vue.use(DropdownMenu);</span><br><span class="line">Vue.use(DropdownItem);</span><br><span class="line">Vue.use(Aside);</span><br><span class="line">Vue.use(Main);</span><br><span class="line">Vue.use(Checkbox);</span><br><span class="line">Vue.use(FormItem);</span><br><span class="line">Vue.use(Collapse);</span><br><span class="line">Vue.use(Popover);</span><br><span class="line">Vue.use(Menu);</span><br><span class="line">Vue.use(Tabs);</span><br><span class="line">Vue.use(TabPane);</span><br><span class="line">Vue.use(Breadcrumb);</span><br><span class="line">Vue.use(BreadcrumbItem);</span><br><span class="line">Vue.use(Dropdown);</span><br><span class="line">Vue.use(Steps);</span><br><span class="line">Vue.use(Tooltip);</span><br><span class="line">Vue.use(Tree);</span><br><span class="line">Vue.use(Pagination);</span><br><span class="line">Vue.use(Badge);</span><br><span class="line">Vue.use(Loading);</span><br><span class="line">Vue.use(Button);</span><br><span class="line">Vue.use(Input);</span><br><span class="line">Vue.use(Table);</span><br><span class="line">Vue.use(TableColumn);</span><br><span class="line">Vue.use(Dialog);</span><br><span class="line">Vue.use(Card);</span><br><span class="line">Vue.use(Container);</span><br><span class="line">Vue.use(Icon);</span><br><span class="line">Vue.use(Select);</span><br><span class="line">Vue.use(Form);</span><br><span class="line">Vue.use(Tag);</span><br><span class="line">Vue.prototype.$alert = MessageBox.alert</span><br><span class="line">Vue.prototype.$confirm = MessageBox.confirm</span><br></pre></td></tr></table></figure><p>这里的代码倒是不难，有两个需要注意的地方：</p><ol><li>MessageBox 的引入方式和其他组件不太一样，需要注意。</li><li>给组件统一定制 size 和 zIndex 的方式有所变化。</li></ol><p>配置完成后，我们再次执行 <code>vue-cli-service build --report</code> ，查看打包结果：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">entrypoint size limit: The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.</span><br><span class="line">Entrypoints:</span><br><span class="line">  app (1.03 MiB)</span><br><span class="line">      css/chunk-vendors.26d2c5b9.css</span><br><span class="line">      js/chunk-vendors.e2a11728.js</span><br><span class="line">      css/app.4e8a7623.css</span><br><span class="line">      js/app.c5dd78e5.js</span><br><span class="line"></span><br><span class="line">  File                                    Size              Gzipped</span><br><span class="line"></span><br><span class="line">  dist/js/chunk-vendors.e2a11728.js       683.05 KiB        177.91 KiB</span><br><span class="line">  dist/js/app.c5dd78e5.js                 101.70 KiB        31.90 KiB</span><br><span class="line">  dist/js/chunk-64435448.d0a0516e.js      26.52 KiB         5.87 KiB</span><br><span class="line">  dist/js/chunk-0c17a57a.d553638c.js      23.79 KiB         5.49 KiB</span><br><span class="line">  dist/js/chunk-33b8cd94.7bbae1a0.js      13.30 KiB         3.46 KiB</span><br><span class="line">  dist/js/chunk-df7e035a.414b548f.js      10.40 KiB         2.95 KiB</span><br><span class="line">  dist/js/chunk-4e552d82.c64f4d10.js      1.78 KiB          0.63 KiB</span><br><span class="line">  dist/js/chunk-18458ebc.32fb57c9.js      1.54 KiB          0.62 KiB</span><br><span class="line">  dist/js/chunk-2d0d03c8.3a093d55.js      0.52 KiB          0.36 KiB</span><br><span class="line">  dist/js/chunk-2d237c54.0b312051.js      0.43 KiB          0.33 KiB</span><br><span class="line">  dist/css/chunk-vendors.26d2c5b9.css     262.71 KiB        42.11 KiB</span><br><span class="line">  dist/css/app.4e8a7623.css               3.46 KiB          1.09 KiB</span><br><span class="line">  dist/css/chunk-0c17a57a.9fe19f94.css    0.86 KiB          0.35 KiB</span><br><span class="line">  dist/css/chunk-64435448.3755e146.css    0.30 KiB          0.15 KiB</span><br></pre></td></tr></table></figure><p>和前面的日志比较后发现，将 ElementUI 按需引入后，还是有效果的，只是效果不太明显。这个时候我们再来打开 report.html 页面来看下：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-3.png" alt></p><p>可以看到，规模庞大的 element-ui.commons.js 已经不见了，取而代之的是一众小喽啰。相关文件大小也减少了 150kb 左右。</p><p>这感觉效果有限。</p><h2 id="2-gzip"><a href="#2-gzip" class="headerlink" title="2. gzip"></a>2. gzip</h2><p>所以，在前面代码的基础上，我们来通过 gzip 继续压缩。</p><p>通过 gzip 来压缩，我们有两种思路。这两种思路和前后端分离的两种不同部署方式有关。</p><ol><li>前端编译打包后拷贝到后端，直接部署后端项目即可</li><li>前后端分离部署，前端通过 Nginx 来部署（推荐）</li></ol><h3 id="2-1-服务端配置"><a href="#2-1-服务端配置" class="headerlink" title="2.1 服务端配置"></a>2.1 服务端配置</h3><p>如果使用第一种方式，前端可以不用做额外工作，还是之前编译后的文件。我们在后端 application.yml 中添加如下配置，开启 gzip 压缩：</p><figure class="highlight yml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">server:</span></span><br><span class="line"><span class="hljs-attr">  compression:</span></span><br><span class="line"><span class="hljs-attr">    enabled:</span> <span class="hljs-literal">true</span></span><br></pre></td></tr></table></figure><p>配置完成后，重启后端项目，访问项目首页，如下，可以看到文件基本上都被压缩了：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-6.png" alt></p><p>点开一个请求，可以看到 gzip 已经生效了：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-7.png" alt></p><h3 id="2-2-前端配置"><a href="#2-2-前端配置" class="headerlink" title="2.2 前端配置"></a>2.2 前端配置</h3><p>Nginx 中配置前端的 gzip 压缩，有两种思路：</p><ol><li>Nginx 动态压缩，静态文件还是普通文件，请求来了再压缩，然后返回给前端。</li><li>Nginx 静态压缩，提前把文件压缩成 .gz 格式，请求来了，直接返回即可。</li></ol><p>如果大家对于 Nginx 还不熟悉，可以先看看松哥这篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></li></ul><h4 id="2-2-1-Nginx-动态压缩"><a href="#2-2-1-Nginx-动态压缩" class="headerlink" title="2.2.1 Nginx 动态压缩"></a>2.2.1 Nginx 动态压缩</h4><p>动态压缩 Vue 还是使用普通的打包编译后的文件，将前端编译打包后的文件拷贝到 Nginx 的 html 目录下，然后访问 nginx：<a href="http://192.168.91.129" target="_blank" rel="noopener">http://192.168.91.129</a></p><p>确保 nginx 运行成功后，接下来对 nginx 进行配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gzip  on;  # 开启 gzip</span><br><span class="line">gzip_min_length 2k;# 超过 2kb 进行压缩</span><br><span class="line">gzip_disable msie6; # ie6 不适用 gzip</span><br><span class="line">gzip_types text/css application/javascript text/javascript image/jpeg image/png image/gif; # 需要处理的文件</span><br></pre></td></tr></table></figure><p>配置完成后，重启 Nginx：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><p>启动成功后，再去访问前端页面，就可以看到压缩效果了。</p><h4 id="2-2-2-Nginx-静态压缩"><a href="#2-2-2-Nginx-静态压缩" class="headerlink" title="2.2.2 Nginx 静态压缩"></a>2.2.2 Nginx 静态压缩</h4><p>上面的动态压缩有一个问题，就是每次请求响应的时候都要压缩，其实都是相同的文件，总是压缩有点浪费资源。</p><p>我们可以提前将文件压缩好，就保存在服务端，需要用的时候直接返回，就会方便很多。</p><p>这需要我们首先在前端安装压缩插件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install compression-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>安装成功之后，接下来在 vue.config.js 中进行配置：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> CompressionPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"compression-webpack-plugin"</span>)</span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: <span class="hljs-string">'localhost'</span>,</span><br><span class="line">        port: <span class="hljs-number">8080</span>,</span><br><span class="line">        proxy: proxyObj</span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    <span class="hljs-keyword">new</span> CompressionPlugin(&#123;</span><br><span class="line">                        test: <span class="hljs-regexp">/\.js$|\.html$|\.css/</span>,</span><br><span class="line">                        threshold: <span class="hljs-number">1024</span>,</span><br><span class="line">                        deleteOriginalAssets: <span class="hljs-literal">false</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>threshold 表示超过 1kb 的文件就进行压缩。</li><li>deleteOriginalAssets 表示压缩后是否删除原文件。</li></ul><p>配置完成后，再次执行打包命令 <code>vue-cli-service build</code>。这次打包完成后，我们可以在 js 目录下看到 .gz 文件，如下：</p><p><img src="http://img.itboyhub.com/2020/03/spring-boot-vue-5.png" alt></p><p>接下来将文件上传到 Nginx 服务器，然后对 Nginx 重新进行编译打包。想让 Nginx 返回已经压缩好的文件，需要用到 Nginx 中的 http_gzip_static_module 模块，这个模块可以发送以 <code>.gz</code> 作为文件扩展名的预压缩文件，所以我们要对 Nginx 重新进行编译打包：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_gzip_static_module</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>然后在 Nginx 配置文件中开启 gzip_static，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip_static  on;</span><br></pre></td></tr></table></figure><p>注意，开启了 gzip_static 后，gzip_types 就失效了，所以也没必要配置这个属性了。</p><p>配置完成后，重启 Nginx，再去访问，查看浏览器日志，就会发现 gzip 已经生效了。</p><p><strong>注意：</strong></p><p>静态压缩返回的 gzip 压缩文件都是提前准备好的，没有 .gz 格式的文件就会自动返回原文件。这是一种和动态压缩不同的响应策略。动态压缩是根据 Nginx 中的配置，超过配置的大小就会自动进行压缩。</p><p>好了，这一波操作下来，首屏加载速度提高了 5 倍左右。</p><p>当然，还有后招，松哥抽空再和大家聊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文之前发过，但是比较零散，这里我把用到的方案都汇总一下，方便大家索引，有需要的小伙伴可以收藏下方便查找。里边提到的几种方案，大家都可以对照着视频试一下&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="Nginx" scheme="http://www.javaboy.org/tags/Nginx/"/>
    
  </entry>
  
</feed>
