<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-03-05T01:42:11.166Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GitHub 又掉链子，我给微人事 + Spring Boot + Spring Cloud 案例找了新家</title>
    <link href="http://www.javaboy.org/2020/0202/github-vhr.html"/>
    <id>http://www.javaboy.org/2020/0202/github-vhr.html</id>
    <published>2020-02-02T01:32:32.000Z</published>
    <updated>2020-03-05T01:42:11.166Z</updated>
    
    <content type="html"><![CDATA[<p>最近又有很多小伙伴反映 GitHub 访问不了，页面打开很慢，这种情况下，想从 GitHub 上 clone 一个项目不知道有多难，可能需要失败 n 多次才可能会成功。</p><a id="more"></a><p>这里松哥给大家介绍一个小技巧，我们从 GitHub 上 down 一个项目下来的时候，有两种方式，一种就是直接利用 git clone ，另外一种就是下载 zip 压缩包，我们在 GitHub 上找到 zip 压缩包的下载路径后，拷贝到迅雷里边去下载，这样即使下载失败还能断点续传（注意这个方法不适用于码云（gitee），因为码云上下载 zip 压缩包需要先登录，而 GitHub 不需要登录就能下载 zip 压缩包）。</p><p>当然，为了小伙伴能顺利 get 到微人事，以及 Spring Boot + Spring Cloud 的各种 Demo，松哥这两天宅在家里顺便把在 GitHub 上大家可能经常需要下载的项目同步到码云上了（好吧，我也终于妥协了，接受了码云），<strong>未来我在 GitHub 上的代码仓库会和码云保持同步</strong>，小伙伴们要是从 GitHub 上下载不方便，也可以从码云上下载，相信下载成功率会提高很多。</p><p><img src="http://www.javaboy.org/images/tools/123-1.png" alt></p><p>同步的仓库主要有如下几个：</p><h2 id="微人事"><a href="#微人事" class="headerlink" title="微人事"></a>微人事</h2><ul><li><a href="https://gitee.com/lenve/vhr" target="_blank" rel="noopener">https://gitee.com/lenve/vhr</a></li></ul><p>这个项目应该就不用再介绍了吧，关注松哥的小伙伴应该都知道这个项目，一个 Spring Boot+Vue 做的前后端分离项目，这次关于 vhr，不仅仅同步了源码，我把在 GitHub 上关于 vhr 的 wiki 文档也全部都同步到 Gitee 上了，大家在 Gitee 上看文档也会方便很多，Gitee 上 vhr 的 wiki 文档地址是：<a href="https://gitee.com/lenve/vhr/wikis" target="_blank" rel="noopener">https://gitee.com/lenve/vhr/wikis</a>。</p><p><img src="http://www.javaboy.org/images/tools/123-2.png" alt></p><h2 id="V-部落"><a href="#V-部落" class="headerlink" title="V 部落"></a>V 部落</h2><p>V 部落没有像 vhr 那样丰富的文档，这里我主要是同步了源码过来，新的地址是：</p><ul><li><a href="https://gitee.com/lenve/VBlog" target="_blank" rel="noopener">https://gitee.com/lenve/VBlog</a></li></ul><h2 id="CoolMeeting"><a href="#CoolMeeting" class="headerlink" title="CoolMeeting"></a>CoolMeeting</h2><p>CoolMeeting 是一个常规的 jsp+servlet 项目，这个<strong>适合 Java 初学者</strong>，这个项目的源码里边有 html 页面，也有 jsp 页面，html 页面是原型页面，jsp 页面才是项目的页面，大家也可以在原型的基础上自己再做开发。这个项目在 Gitee 上的地址是：</p><ul><li><a href="https://gitee.com/lenve/CoolMeeting" target="_blank" rel="noopener">https://gitee.com/lenve/CoolMeeting</a></li></ul><h2 id="Spring-Boot-案例"><a href="#Spring-Boot-案例" class="headerlink" title="Spring Boot 案例"></a>Spring Boot 案例</h2><p>Spring Boot 案例有两个仓库，一个是松哥录制的视频教程的源码，无论你是否购买了付费视频，反正视频源码都是可以直接 download 的，这些源码基本上涉及到了 Spring Boot 大部分常见的知识点：</p><ul><li><a href="https://gitee.com/lenve/javaboy-video-samples" target="_blank" rel="noopener">https://gitee.com/lenve/javaboy-video-samples</a></li></ul><p><img src="http://www.javaboy.org/images/tools/123-3.png" alt></p><p>另外一个 Spring Boot 的仓库是松哥《Spring Boot+Vue 全栈开发实战》一书的案例，不过书出版到现在也一年了，对应的案例版本还是 Spring Boot2.0.4，而视频案例对应的 Spring Boot 版本都在 2.1.6 以上。</p><ul><li><a href="https://gitee.com/lenve/spring-boot-vue-samples" target="_blank" rel="noopener">https://gitee.com/lenve/spring-boot-vue-samples</a></li></ul><h2 id="Spring-Cloud-案例"><a href="#Spring-Cloud-案例" class="headerlink" title="Spring Cloud 案例"></a>Spring Cloud 案例</h2><p>Spring Cloud 案例，包含了 Eureka、Ribbon、Hystrix、Feign、Zuul、Consul、Gateway、Sluth、Spring Cloud Bus、Spring Cloud Stream、Alibaba Sentinel、Nacos 等组件的使用案例，但是这个是一个计划，仓库代码还在不断完善中，预计今年 3 月份可以全部更新完毕。</p><ul><li><a href="https://gitee.com/lenve/springcloud-video-samples" target="_blank" rel="noopener">https://gitee.com/lenve/springcloud-video-samples</a></li></ul><h2 id="公众号文章案例"><a href="#公众号文章案例" class="headerlink" title="公众号文章案例"></a>公众号文章案例</h2><p>这个是我平时写的一些公众号文章的配套案例，方便大家查看，这个仓库也处于不断更新中：</p><ul><li><a href="https://gitee.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://gitee.com/lenve/javaboy-code-samples</a></li></ul><p>除了这几个项目仓库之外，还有几个其他的仓库，比如五子棋游戏啥的，这些仓库小伙伴们关注较少，但是我也同步过来了。</p><p>老实说，码云这几年的发展还算不错，一直紧跟 GitHub 脚步，它的生态建立主要以项目为主，基础软件或者工具类软件较少，所以我们在使用的使用，可能还是得 GitHub 结合 Gitee，才能发挥出最大效果。</p><p>好了，仓库同步过来之后，接下来就剩下我的个人网站了。松哥的 <code>www.javaboy.org</code> 一直托管在 GitHub Pages 上，由于 GitHub 经常掉链子，现在个人网站我也想迁回国内，不过当时为了避免备案，域名是从国外厂商买的，现在要先把域名迁回国内，然后再去买服务器+备案，完了之后再做网站的迁移，小伙伴们静候佳音吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又有很多小伙伴反映 GitHub 访问不了，页面打开很慢，这种情况下，想从 GitHub 上 clone 一个项目不知道有多难，可能需要失败 n 多次才可能会成功。&lt;/p&gt;
    
    </summary>
    
      <category term="GitHub" scheme="http://www.javaboy.org/categories/GitHub/"/>
    
    
      <category term="GitHub" scheme="http://www.javaboy.org/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务系列第二篇，回顾 Jdbc 事务</title>
    <link href="http://www.javaboy.org/2020/0131/jdbc-transaction.html"/>
    <id>http://www.javaboy.org/2020/0131/jdbc-transaction.html</id>
    <published>2020-01-31T01:32:12.000Z</published>
    <updated>2020-03-05T01:46:58.067Z</updated>
    
    <content type="html"><![CDATA[<p>春节之前，松哥和大家说要开一个分布式事务的系列，年前发了一篇，这两天闲在家里，又撸了一篇，这是我们这个系列的第二篇。</p><a id="more"></a><p>第一篇参见：</p><ul><li><a href="https://mp.weixin.qq.com/s/70MR7N5e5hKzwM-qwm0XxQ" target="_blank" rel="noopener">分布式事务开局第一篇，从数据库事务隔离级别说起</a></li></ul><p>本文依然是一个铺垫，本文我们先来看看 Jdbc 事务。</p><p>环境：MySQL5.7</p><p><strong>注意，MySQL5.x 和 MySQL8 在驱动类的路径以及数据库连接地址上写法有一些差别。</strong></p><h2 id="1-Jdbc事务"><a href="#1-Jdbc事务" class="headerlink" title="1. Jdbc事务"></a>1. Jdbc事务</h2><h3 id="1-1-事务提交"><a href="#1-1-事务提交" class="headerlink" title="1.1 事务提交"></a>1.1 事务提交</h3><p>Jdbc 默认开启了事务，并且开启了事务的自动提交，开发者可以通过如下代码修改这种默认的策略：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAutoCommit(<span class="hljs-keyword">false</span>);</span><br></pre></td></tr></table></figure><p>然后通过如下代码手动提交或者回滚一个事务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">con.commit();</span><br><span class="line">con.rollback();</span><br></pre></td></tr></table></figure><h3 id="1-2-事务隔离级别"><a href="#1-2-事务隔离级别" class="headerlink" title="1.2 事务隔离级别"></a>1.2 事务隔离级别</h3><p>Jdbc 中默认的事务隔离级别和数据库保持一致，即如果开发者没有在 Jdbc 中设置数据库事务的隔离级别，默认的事务隔离级别就数据库的事务隔离级别，当然开发者在 Jdbc 中也可以通过如下代码修改事务隔离级别：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">con.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);</span><br><span class="line">con.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);</span><br><span class="line">con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br><span class="line">con.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);</span><br><span class="line">con.setTransactionIsolation(Connection.TRANSACTION_NONE);</span><br></pre></td></tr></table></figure><p>其中最后一个 NONE 表示不支持事务，另外四个则和数据库四个隔离级别一一对应。</p><h4 id="1-2-1-READ-COMMITTED"><a href="#1-2-1-READ-COMMITTED" class="headerlink" title="1.2.1 READ COMMITTED"></a>1.2.1 READ COMMITTED</h4><p>事务隔离级别的验证方式很简单，读者可以参考上篇文章，因为验证过程细节繁琐，本文主要向读者展示 READ COMMITTED 和 REPEATABLE READ 两种隔离级别。READ COMMITTED 具体操作步骤如下（数据源依然使用上文的数据源）：</p><p>1.创建普通的 Maven 项目，添加数据库依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.创建 DBUtils 类，提供数据库连接，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DBUtils</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> DriverManager.getConnection(<span class="hljs-string">"jdbc:mysql:///test01"</span>,<span class="hljs-string">"root"</span>,<span class="hljs-string">"root"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.接下来创建两个类 Main 和 Main2，相当于两个不同的 SQL 操作 session：</p><p>Main：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection con = DBUtils.getConnection();</span><br><span class="line">        con.setAutoCommit(<span class="hljs-keyword">false</span>);</span><br><span class="line">        String sql = <span class="hljs-string">"update user set account=888 where username='zhangsan'"</span>;</span><br><span class="line">        PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">        ps.executeUpdate();</span><br><span class="line">        con.commit();</span><br><span class="line">        ps.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main2：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection con = DBUtils.getConnection();</span><br><span class="line">        con.setAutoCommit(<span class="hljs-keyword">false</span>);</span><br><span class="line">        con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br><span class="line">        String sql = <span class="hljs-string">"select * from user where username='zhangsan'"</span>;</span><br><span class="line">        PreparedStatement ps = <span class="hljs-keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;</span><br><span class="line">            ps = con.prepareStatement(sql);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            <span class="hljs-keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="hljs-keyword">long</span> id = rs.getLong(<span class="hljs-number">1</span>);</span><br><span class="line">                String username = rs.getString(<span class="hljs-string">"username"</span>);</span><br><span class="line">                String account = rs.getString(<span class="hljs-string">"account"</span>);</span><br><span class="line">                System.out.println(<span class="hljs-string">"id:"</span> + id + <span class="hljs-string">";username:"</span> + username + <span class="hljs-string">";account:"</span> + account);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        con.commit();</span><br><span class="line">        rs.close();</span><br><span class="line">        ps.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，Main2 中有一个 for 循环，将同一个查询操作执行了 3 次，这个循环主要用来验证不可重复读问题和脏读问题。另外在 Main2 中将数据库隔离级别设置为 READ_COMMITTED。</p><p>4.在 Main2 类中 for 循环中的第一行代码处打断点，然后以 debug 方式启动 Main2，如图：</p><p><img src="http://www.javaboy.org/images/transaction/2-1.png" alt="2-1"></p><p>由上图可以看到，目前数据库中 zhangsan 账户下有 999 块钱。接下来 Main2 类保持此状态不动。</p><p>5.在 Main 类中，提交事务的方法上打断点，然后以 debug 的方式启动 Main 类中的 main 方法，如下：</p><p><img src="http://www.javaboy.org/images/transaction/2-2.png" alt="2-2"></p><p>6.接下来回到 Main2 类中，执行 for 循环的第二次遍历，结果如下：</p><p><img src="http://www.javaboy.org/images/transaction/2-3.png" alt="2-3"></p><p>可以看到，第二次查询结果与第一次是一样的，说明脏读问题已经不存在了。</p><p>7.回到 Main 类中，提交事务。</p><p>8.回到 Main2，执行第三次 for 循环，发现数据已经发生了变化，即这里发生了不可重复读问题。如下：</p><p><img src="http://www.javaboy.org/images/transaction/2-4.png" alt="2-4"></p><h4 id="1-2-2-REPEATABLE-READ"><a href="#1-2-2-REPEATABLE-READ" class="headerlink" title="1.2.2 REPEATABLE READ"></a>1.2.2 REPEATABLE READ</h4><p>REPEATABLE READ 这种隔离级别很好测试，将 Main2 中如下一行注释掉，使用 MySQL 默认的隔离级别就行了。测试步骤与上文一致，这里就不再赘述。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br></pre></td></tr></table></figure><p>其他隔离级别的测试也基本一致，这里不再赘述了。</p><h3 id="1-3-共享锁和排他锁"><a href="#1-3-共享锁和排他锁" class="headerlink" title="1.3 共享锁和排他锁"></a>1.3 共享锁和排他锁</h3><h4 id="1-3-1-共享锁"><a href="#1-3-1-共享锁" class="headerlink" title="1.3.1 共享锁"></a>1.3.1 共享锁</h4><p>共享锁又称读锁，是读取操作创建的锁。加了读锁的数据，可以被其他事务继续加读锁并发读取，但任何事务都不能对数据进行修改（也不能给事务加排他锁），直到已释放所有共享锁。<br>用法：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">SHARE</span> <span class="hljs-keyword">MODE</span>;</span><br></pre></td></tr></table></figure><p>在查询语句后面增加 <code>LOCK IN SHARE MODE</code>，MySQL 就会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p><h4 id="1-3-2-排他锁"><a href="#1-3-2-排他锁" class="headerlink" title="1.3.2 排他锁"></a>1.3.2 排他锁</h4><p>排他锁又称写锁、独占锁，如果一条数据被加上了排他锁，其他事务无法再给该数据加任何锁，而获取排他锁的事务既能读数据，又能修改数据。</p><p>用法：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> ... <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>在查询语句后面增加 FOR UPDATE，MySQL 就会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。加了排他锁的操作，有点类似 SERIALIZABLE 的隔离级别。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>OK，本文和大家回顾一下 Jdbc 事务，下篇文章我们再来看 Spring 中的事务机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;春节之前，松哥和大家说要开一个分布式事务的系列，年前发了一篇，这两天闲在家里，又撸了一篇，这是我们这个系列的第二篇。&lt;/p&gt;
    
    </summary>
    
      <category term="transaction" scheme="http://www.javaboy.org/categories/transaction/"/>
    
    
      <category term="transaction" scheme="http://www.javaboy.org/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>假期越来越长，宅在家，不妨看看这几个免费的学习网站</title>
    <link href="http://www.javaboy.org/2020/0130/video-resources.html"/>
    <id>http://www.javaboy.org/2020/0130/video-resources.html</id>
    <published>2020-01-30T01:31:53.000Z</published>
    <updated>2020-03-05T01:43:37.587Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">睡一觉起来假期延长了，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">再睡一觉，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">起来假期又延长了。。。。</a></p><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">越宅越无聊，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">那不妨看看松哥给大家整理的几个免费学习的网站，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">利用假期好好提高一下技能。</a></p><h2 id="B-站"><a href="#B-站" class="headerlink" title="B 站"></a>B 站</h2><ul><li><a href="https://www.bilibili.com" target="_blank" rel="noopener">https://www.bilibili.com</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">毫无疑问，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">B 站已经不仅仅是一个二次元网站，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">它已经成为最大的学习网站之一，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">B 站有一些是个人讲师，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">也有一些是培训机构为了招生放上去的宣传视频，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">无论哪种，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">都是免费的，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">而且 B 站的学习资源偏实战，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">大部分我们想看的技术点，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">都能在 B 站上找到，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">松哥自己也打算在 2020 年在 B 站推出一些免费的入门教程。</a></p><h2 id="网易公开课"><a href="#网易公开课" class="headerlink" title="网易公开课"></a>网易公开课</h2><ul><li><a href="http://open.163.com" target="_blank" rel="noopener">http://open.163.com</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">网易公开课算是国内做 mooc 这种模式比较早的，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">它提供了大量的国内外高校公开课免费资源。和 B 站一样，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">视频没有开场广告，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">内容免费，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">因此可以算是非常良心的网站了。</a></p><h2 id="学堂在线"><a href="#学堂在线" class="headerlink" title="学堂在线"></a>学堂在线</h2><ul><li><a href="https://next.xuetangx.com/" target="_blank" rel="noopener">https://next.xuetangx.com</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">这本来是清华大学面向本校学生提供的自产课程，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">但是目前已经向公众开放，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">而且提供了国内外众多知名大学和研究机构合作，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">提供了大量的免费课程。</a></p><h2 id="好大学在线"><a href="#好大学在线" class="headerlink" title="好大学在线"></a>好大学在线</h2><ul><li><a href="https://www.cnmooc.org/" target="_blank" rel="noopener">https://www.cnmooc.org</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">中国高水平大学慕课联盟官方网站，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">联盟是部分中国高水平大学间自愿组建的开放式合作教育平台，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">为公益性、开放式、非官方、非法人的合作组织。旨在通过交流、研讨、协商与协作等活动，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">建设具有中国特色的、高水平的大规模在线开放课程平台，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">向成员单位内部和社会提供高质量的慕课课程。</a></p><h2 id="慕课网"><a href="#慕课网" class="headerlink" title="慕课网"></a>慕课网</h2><ul><li><a href="https://www.imooc.com/" target="_blank" rel="noopener">https://www.imooc.com</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">慕课网现在有不少是付费视频，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">不过免费的也不少，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">而且大部分免费的资源质量也都 OK，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">那些由大学主办的慕课一般偏理论，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">像慕课网和 B 站这种一般偏向实战。</a></p><h2 id="可汗学院"><a href="#可汗学院" class="headerlink" title="可汗学院"></a>可汗学院</h2><ul><li><a href="https://www.khanacademy.org/" target="_blank" rel="noopener">https://www.khanacademy.org</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">这是一个国外的网站，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">大家浏览起来网速可能会稍微有一点慢。可汗学院是由萨尔曼·可汗创立的一家教育性非营利组织，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">主旨在于利用网络进行免费授课，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">现有关于数学、历史、金融、物理、化学、生物、天文学等科目的内容，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">教学视频超过2000段，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">机构的使命是加快各年龄学生的学习速度。可汗的事业得到了越来越多的社会认可。随之而来的物质支持，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">让这个免费网站更加活跃。</a></p><h2 id="coursera"><a href="#coursera" class="headerlink" title="coursera"></a>coursera</h2><ul><li><a href="https://www.coursera.org/" target="_blank" rel="noopener">https://www.coursera.org</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">Coursera 是大型公开在线课程项目，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">由美国斯坦福大学两名计算机科学教授创办。旨在同世界顶尖大学合作，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">在线提供网络公开课程。Coursera 的首批合作院校包括斯坦福大学、密歇根大学、普林斯顿大学、宾夕法尼亚大学等美国名校。</a></p><h2 id="超星尔雅"><a href="#超星尔雅" class="headerlink" title="超星尔雅"></a>超星尔雅</h2><ul><li><a href="http://erya.mooc.chaoxing.com/" target="_blank" rel="noopener">http://erya.mooc.chaoxing.com</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">超星，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">大部分的高校图书馆应该都购买了超星数据库，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">我以前读书时候，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">人文通识课程就是在超星尔雅上学的。</a></p><h2 id="课程图谱网"><a href="#课程图谱网" class="headerlink" title="课程图谱网"></a>课程图谱网</h2><ul><li><a href="http://coursegraph.com/navigation/" target="_blank" rel="noopener">http://coursegraph.com/navigation</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">这是一个导航网站，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">列出来了常见的视频平台，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">想看什么，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">可以一步导航到位。</a></p><h2 id="javaboy"><a href="#javaboy" class="headerlink" title="javaboy"></a>javaboy</h2><ul><li><a href="http://www.javaboy.org">http://www.javaboy.org</a></li></ul><p><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">这是松哥自己做的网站，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">提供了 Spring、SpringMVC、MyBatis、SpringBoot、Git、Redis、MongoDB 等 Java 领域常见技术栈的专业教程，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">小伙伴们宅在家里，</a><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">也不妨看看。</a></p><p><strong>当然，除了这些免费的网站之外，松哥也给大家准备了超 2TB 的免费 Java 视频资源，大家在公众号后台回复 2TB 可以获取相关资源。</strong></p><p>好了，希望上面这几个网站能给大家无聊的假期解解闷。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;睡一觉起来假期延长了，&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;再睡一觉，&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;起来假期又延长了。。。。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.javaboy.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://www.javaboy.org/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>肺疫面前，段子手出动，但是玩笑也要分场合</title>
    <link href="http://www.javaboy.org/2020/0128/life-1.html"/>
    <id>http://www.javaboy.org/2020/0128/life-1.html</id>
    <published>2020-01-28T01:31:35.000Z</published>
    <updated>2020-03-05T01:48:21.045Z</updated>
    
    <content type="html"><![CDATA[<p>开玩笑要分场合。</p><a id="more"></a><p>这个话题其实不太好说，因为你一说，必然有人上来喷你开不起玩笑，但是我觉得还是有必要说说这个问题。因为最近有人因为开武汉肺疫的玩笑，结果两拨人在微信群里吵起来了，大过年的，真是煞风景。</p><p>大家知道松哥本科是学管理的，当时我们有一门选修课，叫做《沟通的艺术》，一个学期就是讲和人沟通的事，分析不同人的性格（感兴趣的小伙伴我建议大家看下这本书），所以当我看到有人因为交流方式不当和别人吵起来，我就想显摆一下自己的专业知识（手动狗头。</p><p>首先，无论怎么样，在网上和人互喷肯定是不明智的，不喜欢拉黑就行了，毕竟大部分程序员还是受过高等教育的，为了一些非技术性的问题争得面红耳赤，实在没有必要。</p><p>开玩笑分场合的，这个不是说开武汉肺疫的玩笑要分场合，所有玩笑都要分场合，只是这次刚好因为肺疫的事情，有人在群里吵起来了，我就把这事拿出来说一下。</p><p>武汉肺疫发生以来，网络上的段子手集体出动，估计大家无论在微信群还是在朋友圈，都看到了不少关于肺疫的段子，现在社交网络这么发达，很多人看完之后，就想顺手把段子发给其他人看一下，这看起来没什么问题，这个春节过得这么压抑，来点幽默的段子轻松一下，但实际上是有问题的，问题就在于分享给谁。因为一个玩笑开的好不好，不在于玩笑的内容，而在于你们两人之间的关系，引用网上一段话(zhihu.com/question/59443031/answer/179767781)：</p><blockquote><p>开玩笑是一种政治。因为开玩笑必定有“差势”，开玩笑的一方是高于对方的，至少是处于主动的一方。所以玩笑能不能开，开的好不好在于你们之间的关系，女孩子都喜欢被喜欢的人调戏。而领导开玩笑不管好不好笑都得陪笑。我想你所说的开不起玩笑的人一定不想在你们的关系中处于弱势地位。好的玩笑不在内容，而是场合。说白了就是看对方愿不愿意被你“欺负”。</p></blockquote><p>日常生活中的玩笑是不是大部分都是满足上面说的。再想想，你会和你的领导、你的老板开一些过分的玩笑吗？会和长辈分享荤段子吗？不会吧。</p><p>老实说，我看到一些好玩的东西也会分享，不过我只会在一些非常熟悉的朋友群里发，可能就十来个人的群，彼此之间都非常熟悉的那种，互相之间知根知底，分享什么都没问题。</p><p>但是我几乎不会在读者群或者朋友圈里开玩笑，原因很简单，读者群里人比较多，一个群都是四五百人，每个人都有自己的想法和性格，你的玩笑发出去之后，必然会有人觉得不好笑，并因此感到不适，如果感到严重不适，可能就会因此发生口角。其实，一旦有人感到不适，说明这个人不想被你“欺负”，这个时候赶紧刹车，这事情到此为止，这是明智的，如果对方对你的玩笑不 care，这个时候你还要嘲笑对方开不起玩笑、证明自己是多么的伟光正，那一场唾沫横飞的大战怕是无法避免了。</p><p>松哥上次群里遇到的就是有人已经表明不适了，对方还反复发消息想证明自己的玩笑是多么正确，结果可想而知。。。</p><p>其实我自己是一个非常爱开玩笑的人，因为有很多读者群，每天都能看到很多好玩东西。有一个大学同学，非常熟悉，我经常和他开玩笑，他也从不生气，一来因为彼此之间很熟悉，二来玩笑也都有分寸，就是调侃一下工作啥的，但是这种是建立在非常熟悉与信任的基础上，如果和对方不是很熟悉，那还是尽量少开玩笑，或者是开一些无关痛痒的玩笑，避免尴尬。</p><p>我们常说“好看的皮囊千篇一律，有趣的灵魂万里挑一”。皮囊出生的时候就已经定下来了，但是有趣的灵魂却是可以塑造的，一个有趣的灵魂，最直接的表现就是会聊天。而一个不分场合的玩笑，很可能让你把天聊死了。我们程序员日常可能更看重技术上的提升，而忽略这些软技能的提升，其实这些也都是非常重要的技能，特别当你工作时间比较就之后，就会愈发觉得这些软技能的重要了。</p><p>好了，这几天宅在家也没事，给大家推荐一本松哥之前读的书，叫做《沟通的艺术》，大家可以在公众号后台回复 <code>沟通的艺术</code> ，获取该书电子版，这本书作者是马修·麦凯(美国)，目前最新版是第 14 版，但是网上流传的 pdf 版是第 12 版，我这里也是第 12 版，感兴趣的小伙伴可以看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开玩笑要分场合。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>肺疫面前，谣言比病毒更可怕</title>
    <link href="http://www.javaboy.org/2020/0126/life-2.html"/>
    <id>http://www.javaboy.org/2020/0126/life-2.html</id>
    <published>2020-01-26T01:31:21.000Z</published>
    <updated>2020-03-05T01:50:04.927Z</updated>
    
    <content type="html"><![CDATA[<p>这次武汉肺疫来势汹汹，我在家也宅了好几天了，看看电视，刷刷手机。实在闲的无聊，那就码码字吧。</p><a id="more"></a><p>相比于肺疫病毒，更让人揪心的是各种满天飞的谣言，因为这些谣言会加重公众的恐慌或者淡化疫情的严重性，非常不利用疫情的防控。</p><p>大约从 21 号开始，朋友圈和微信群里边关于肺疫的文章越来越多了，这一方面说明疫情受到了大家的重视，这是好事，但是我发现微信群里关于疫情的谣言比较多。</p><p>每次发生这类公共事件的时候，都是谣言集中爆发的时候。谣言一般具有较强的趣味性、轰动性，非常容易获得公众认可并且能够满足人们的好奇心，因此很多时候，我们发现谣言的传播速度远远大于真相的传播速度。特别是在目前的社交网络这么发达的情况下，从众效应和权威效应都会谣言传播有着重要的影响。</p><p>其实关于谣言的传播，一直以来，人们都有不少研究：</p><p>早在 1964 年，就有来自剑桥大学 Statistical Laboratory 的 D.J.DALEY &amp; D.G.KENDALL 发表过《Epidemics and Rumours》一文（<a href="https://www.nature.com/articles/2041118a0），提出了谣言的传播和病毒的传播具有某种相似性，当时他们就建立过谣言传播的数学模型" target="_blank" rel="noopener">https://www.nature.com/articles/2041118a0），提出了谣言的传播和病毒的传播具有某种相似性，当时他们就建立过谣言传播的数学模型</a> DK 模型（DALEY-KENDALL），对谣言的传播进行定量研究（感兴趣的小伙伴不妨趁着这几天研究一下这个数学模型）。</p><p>如果你不想了解复杂的数学模型，对于谣言的传播，传播学者克罗斯曾提出一个简单的公式：谣言=事件的重要性×事件的模糊性×公众批判能力，这说明谣言的能量有多大，既取决于真实信息的透明度，也取决于受众的判断水平，也就是说，这三个中有一个趋于零，就能扼杀住谣言。就这次武汉肺疫而言，事件的重要性无需多说，至于事件的模糊性，前期因为官方信息比较少，所以事件的模糊性较高，但是到今天，各种官方的发布会，谣言较真平台上线（<a href="https://vp.fact.qq.com" target="_blank" rel="noopener">https://vp.fact.qq.com</a>），模糊性会下降，相信谣言能够得到一定程度的遏制。</p><p>对于我们普通人，关于疫情的信息，一方面可以多多关注官方的发布平台，像人民日报、央视新闻等公众号，每天都会发布多条关于疫情的详细信息，另一方面就是丁香园的疫情实时信息播报平台(<a href="https://3g.dxy.cn/newh5/view/pneumonia" target="_blank" rel="noopener">https://3g.dxy.cn/newh5/view/pneumonia</a>);另外，腾讯也上线了一个较真平台：<a href="https://vp.fact.qq.com" target="_blank" rel="noopener">https://vp.fact.qq.com</a>，谣言与真相一目了然.</p><p><strong>疫情面前，大家除了保护好自己，不信谣，不传谣，也是为疫情防控做贡献。</strong></p><p>最后来一句马克吐温的名言：谎言跨越半个地球的时候，真相还在穿鞋。</p><blockquote><p>A lie can travel halfway around the world while the truth is putting on its shoes</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次武汉肺疫来势汹汹，我在家也宅了好几天了，看看电视，刷刷手机。实在闲的无聊，那就码码字吧。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务开局第一篇，从数据库事务隔离级别说起</title>
    <link href="http://www.javaboy.org/2020/0120/jdbc-transaction.html"/>
    <id>http://www.javaboy.org/2020/0120/jdbc-transaction.html</id>
    <published>2020-01-20T01:31:00.000Z</published>
    <updated>2020-03-05T01:51:27.200Z</updated>
    
    <content type="html"><![CDATA[<p>春节临近，松哥也有点无心撸码。不过很多时候，很多事情，我们不能由着自己的性子，还是要控制一下自己，这不，松哥最近又打算开一个坑，和大家聊一聊分布式事务，因为我们作微服务，分布式事务肯定是跳不过去的坎。这个坑有点大，年前先更几篇。</p><a id="more"></a><p>说到分布式事务，很多小伙伴可能会想到 TCC ，但是实际上，分布式事务本身是一个比较大的话题，一步一步从头开始讲，会涉及到数据库事务、Jdbc 事务、Spring 事务、消息驱动模式处理事务、事件溯源模式等等很多种。</p><p>松哥想写一个类似于 SpringBoot 那样成体系的教程，来和大家仔细的捋一捋分布式事务，今天我们就先从数据库事务开始。（另外，大家在公众号后台分别回复 <code>spring</code>、<code>springmvc</code>、<code>mybatis</code>、<code>springboot</code>、<code>maven</code> 可以下载松哥手撸的干货教程。）</p><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1. 理论"></a>1. 理论</h2><p>MySQL 中事务的隔离级别一共分为四种，分别如下：</p><ul><li>序列化（SERIALIZABLE）</li><li>可重复读（REPEATABLE READ）</li><li>提交读（READ COMMITTED）</li><li>未提交读（READ UNCOMMITTED）</li></ul><p>四种不同的隔离级别含义分别如下：</p><ol><li>SERIALIZABLE</li></ol><blockquote><p>如果隔离级别为序列化，则用户之间通过一个接一个顺序地执行当前的事务，这种隔离级别提供了事务之间最大限度的隔离。</p></blockquote><ol start="2"><li>REPEATABLE READ</li></ol><blockquote><p>在可重复读在这一隔离级别上，事务不会被看成是一个序列。不过，当前正在执行事务的变化仍然不能被外部看到，也就是说，如果用户在另外一个事务中执行同条 SELECT 语句数次，结果总是相同的。（因为正在执行的事务所产生的数据变化不能被外部看到）。</p></blockquote><ol start="3"><li>READ COMMITTED</li></ol><blockquote><p>READ COMMITTED 隔离级别的安全性比 REPEATABLE READ 隔离级别的安全性要差。处于 READ COMMITTED 级别的事务可以看到其他事务对数据的修改。也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个 SELECT 语句可能返回不同的结果。</p></blockquote><ol start="4"><li>READ UNCOMMITTED</li></ol><blockquote><p>READ UNCOMMITTED 提供了事务之间最小限度的隔离。除了容易产生虚幻的读操作和不能重复的读操作外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，这就导致了大量的数据变化。</p></blockquote><p><strong>在 MySQL 数据库种，默认的事务隔离级别是 REPEATABLE READ</strong></p><h2 id="2-实战"><a href="#2-实战" class="headerlink" title="2. 实战"></a>2. 实战</h2><p>接下来通过几条简单的 SQL 向读者验证上面的理论。</p><h3 id="2-1-查看隔离级别"><a href="#2-1-查看隔离级别" class="headerlink" title="2.1 查看隔离级别"></a>2.1 查看隔离级别</h3><p>通过如下 SQL 可以查看数据库实例默认的全局隔离级别和当前 session 的隔离级别：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> @@GLOBAL.tx_isolation, @@tx_isolation;</span><br></pre></td></tr></table></figure><p>查询结果如图： </p><p><img src="http://www.javaboy.org/images/transaction/1-1.png" alt="1-1"></p><p>可以看到，默认的隔离级别为 REPEATABLE-READ，通过如下命令可以修改隔离级别（建议开发者在修改时修改当前 session 隔离级别即可）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure><p>上面这条 SQL 表示将当前 session 的数据库隔离级别设置为 READ UNCOMMITTED，设置成功后，再次查询隔离级别，发现当前 session 的隔离级别已经变了，如图1-2：</p><p><img src="http://www.javaboy.org/images/transaction/1-2.png" alt="1-2"></p><p><strong>注意，如果只是修改了当前 session 的隔离级别，则换一个 session 之后，隔离级别又会恢复到默认的隔离级别</strong></p><h3 id="2-2-READ-UNCOMMITTED"><a href="#2-2-READ-UNCOMMITTED" class="headerlink" title="2.2 READ UNCOMMITTED"></a>2.2 READ UNCOMMITTED</h3><p>READ UNCOMMITTED 是最低隔离级别，这种隔离级别中存在脏读、不可重复读以及幻象读问题，下面分别予以介绍。</p><p>首先创建一个简单的表，预设两条数据，如下：</p><p><img src="http://www.javaboy.org/images/transaction/1-3.png" alt="1-3"></p><p>表的数据很简单，有 zhangsan 和 lisi 两个用户，两个人的账户各有 1000 人民币。现在模拟这两个用户之间的一个转账操作。</p><p><strong>注意，如果读者使用的是 Navicat 的话，不同的查询窗口就对应了不同的 session，如果读者使用了 SQLyog 的话，不同查询窗口对应同一个 session，因此如果使用 SQLyog，需要读者再开启一个新的连接，在新的连接种进行查询操作。</strong></p><h4 id="2-2-1-脏读"><a href="#2-2-1-脏读" class="headerlink" title="2.2.1 脏读"></a>2.2.1 脏读</h4><p>一个事务读到另外一个事务还没有提交的数据，称之为脏读。具体操作如下：</p><p>1.首先打开两个SQL操作窗口，假设分别为 A 和 B，在 A 窗口中输入如下几条 SQL （输入完成后不用执行）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">account</span>=<span class="hljs-keyword">account</span>+<span class="hljs-number">100</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'zhangsan'</span>;</span><br><span class="line"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">account</span>=<span class="hljs-keyword">account</span><span class="hljs-number">-100</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'lisi'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>2.在 B 窗口执行如下 SQL，修改默认的事务隔离级别为 READ UNCOMMITTED，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure><p>3.接下来在 B 窗口中输入如下 SQL，输入完成后，首先执行第一行开启事务（注意只需要执行一行即可）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>4.接下来执行 A 窗口中的前两条 SQL，即开启事务，给 zhangsan 这个账户添加 100 元。</p><p>5.进入到 B 窗口，执行 B 窗口的第二条查询 SQL（SELECT * from user;），结果如下：</p><p><img src="http://www.javaboy.org/images/transaction/1-4.png" alt="1-4"></p><p>可以看到，A 窗口中的事务，虽然还未提交，但是 B 窗口中已经可以查询到数据的相关变化了。</p><p>这就是脏读问题。</p><h4 id="2-2-2-不可重复读"><a href="#2-2-2-不可重复读" class="headerlink" title="2.2.2 不可重复读"></a>2.2.2 不可重复读</h4><p>不可重复读是指一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。具体操作步骤如下（操作之前先将两个账户的钱都恢复为1000）：</p><p>1.首先打开两个查询窗口 A 和 B ，并且将 B 的数据库事务隔离级别设置为 READ UNCOMMITTED。具体 SQL 参考上文，这里不赘述。</p><p>2.在 B 窗口中输入如下 SQL，然后只执行前两条 SQL 开启事务并查询 zhangsan 的账户：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'zhangsan'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>前两条 SQL 执行结果如下：</p><p><img src="http://www.javaboy.org/images/transaction/1-5.png" alt="1-5"></p><p>3.在 A 窗口中执行如下 SQL，给 zhangsan 这个账户添加 100 块钱，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">account</span>=<span class="hljs-keyword">account</span>+<span class="hljs-number">100</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'zhangsan'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>4.再次回到 B 窗口，执行 B 窗口的第二条 SQL 查看 zhangsan 的账户，结果如下：</p><p><img src="http://www.javaboy.org/images/transaction/1-6.png" alt="1-6"></p><p>zhangsan 的账户已经发生了变化，即前后两次查看 zhangsan 账户，结果不一致。不可重复读强调的是其他事务对数据进行了修改或者删除，这一点注意和幻象读进行区分。</p><h4 id="2-2-3-幻象读"><a href="#2-2-3-幻象读" class="headerlink" title="2.2.3 幻象读"></a>2.2.3 幻象读</h4><p>幻象读和不可重复读比较像，强调了不同方面。幻象读是指当一个事务根据条件查询数据时，另外一个事务插入一条新记录，这条新数据恰好可以满足第一个事务的查询条件，然后此时再次执行第一个事务，就会看到第二个事务插入的新记录，这个新记录就称为“幻象”。</p><p>例如，执行如下SQL查询当前表的用户数量：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>获取到的结果为 2，表示有两个用户。</p><p>此时在一个新的事务中，向表中添加新记录，然后再次执行这里第二行统计 SQL，就会查到三个用户，这个比较简单，本文就不演示了。</p><h3 id="2-3-READ-COMMITTED"><a href="#2-3-READ-COMMITTED" class="headerlink" title="2.3 READ COMMITTED"></a>2.3 READ COMMITTED</h3><p>和 READ UNCOMMITTED 相比，READ COMMITTED 主要解决了脏读的问题，对于不可重复读和幻象读则未解决。操作案例与上文一致，这里不再赘述。</p><h3 id="2-4-REPEATABLE-READ"><a href="#2-4-REPEATABLE-READ" class="headerlink" title="2.4 REPEATABLE READ"></a>2.4 REPEATABLE READ</h3><p>和 READ COMMITTED 相比，REPEATABLE READ 进一步解决了不可重复读的问题，但是幻象读则未解决。操作案例与上文一致，这里不再赘述。</p><p><strong>注意，REPEATABLE READ 也是 InnoDB 引擎的默认数据库事务隔离级别</strong></p><h3 id="2-5-SERIALIZABLE"><a href="#2-5-SERIALIZABLE" class="headerlink" title="2.5 SERIALIZABLE"></a>2.5 SERIALIZABLE</h3><p>SERIALIZABLE 提供了事务之间最大限度的隔离，在这种隔离级别中，事务一个接一个顺序的执行，不会发生脏读、可不重复读以及幻象读问题。最安全。相关操作案例与上文一致，这里不再赘述。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>总的来说，隔离级别和脏读、不可重复读以及幻象读的对应关系如下：</p><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻象读</th></tr></thead><tbody><tr><td style="text-align:left">READ UNCOMMITTED</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">READ COMMITED</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">REPEATABLE READ</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td></tr></tbody></table><p>性能关系如图：</p><p><img src="http://www.javaboy.org/images/transaction/1-7.png" alt="1-7"></p><p>好了，这篇文章就和小伙伴们先说这么多，大家不妨写几行 SQL 试一试。</p><p>松哥明天也要回家啦，祝小伙伴们新年快乐哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;春节临近，松哥也有点无心撸码。不过很多时候，很多事情，我们不能由着自己的性子，还是要控制一下自己，这不，松哥最近又打算开一个坑，和大家聊一聊分布式事务，因为我们作微服务，分布式事务肯定是跳不过去的坎。这个坑有点大，年前先更几篇。&lt;/p&gt;
    
    </summary>
    
      <category term="transaction" scheme="http://www.javaboy.org/categories/transaction/"/>
    
    
      <category term="transaction" scheme="http://www.javaboy.org/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>视频教程最佳食用姿势，顺便说说前后端分离开发 Bug 解决思路</title>
    <link href="http://www.javaboy.org/2020/0119/vhr-video.html"/>
    <id>http://www.javaboy.org/2020/0119/vhr-video.html</id>
    <published>2020-01-19T01:30:42.000Z</published>
    <updated>2020-03-05T01:53:43.201Z</updated>
    
    <content type="html"><![CDATA[<p>大家在公众号后台分别回复 <code>SpringBoot</code>、<code>Spring</code>、<code>SpringMVC</code>、<code>MyBatis</code> 以及 <code>Maven</code> 可以下载松哥手撸的技术干货。有一些小伙伴在学习这些干货的时候，遇到了一些问题，来求助松哥，虽然问题很多，但是大部分都是类似的，因此我决定写一篇文章来和大家聊一聊这个问题。</p><a id="more"></a><p>作为一个有 n 多年看视频学习经验的过来人，松哥有必要给大家传授一些技巧。</p><p>我本科学的是管理，Java 也算是半路出家自己学的，大学时候时间充裕，学习 Java 主要就是靠看视频学习的，工作之后，由于已经渐渐入行，有了自己的学习方法论，也因为时间比较紧张，就很少看视频学习了，但是大学四年积累下来的一些看视频学习的经验，我觉得有必要和大家分享一下。</p><p>其实大家现在看到的视频质量比松哥那会看的要高很多了，我刚开始看视频的时候，那会百度网盘还没流行开，视频都是通过优酷、土豆这些网站分发的，像素感人，大部分视频也都没有对应的 Demo 和课件，所以大家现在拿着更好的资料，有理由比松哥学的更好。</p><p>很多时候，当我收到小伙伴的求助，有的是看松哥自己录制的视频时遇到的问题，有的是看别人录制的视频时遇到的问题，不管是哪一类问题，从大家的提问中，我就能感觉出来有的人在解决问题方面还没形成一套自己的方法，这些方法需要自己去摸索总结，松哥就是这样一步步走过来的，按理说，自己摸索出来的方法，用着肯定更加顺手，别人传授的方法，虽然不用踩坑了，但是得有一个适应的过程。</p><p>我说几个我的思路，大家可以在自己平时学习中试试，看有没有效果。</p><h2 id="视频和文字不同"><a href="#视频和文字不同" class="headerlink" title="视频和文字不同"></a>视频和文字不同</h2><p>看视频学习和看书/看博客学习有一个很大的不同，书和博客都是写好的静态的东西，由于时间久远或者作者疏忽，文字的东西可能不完整（例如作者可能不小心漏掉了一个小细节），这种时候，当你照着无法做出效果时，要考虑的问题就非常多了。</p><p>但是视频不一样，代码是作者一行一行敲出来的（这里我们不讨论那种提前写好代码，视频里照着代码讲的，这种视频我一般拿到手顺手就扔了），所有的操作你都能看见，照着写，按理说就能看到相应的结果，学习起来相对来说要容易很多，这也是为什么对于一个新接触的知识点，我建议小伙伴们通过看视频来学习。</p><p>然而，即使这种手把手的形式，由于小伙伴们的疏忽，看的不仔细，看完之后，可能还是做不出效果来，这个时候再去寻找问题的原因要容易很多。因为作者在视频里做出来效果了，这个我们是看的清清楚楚的，至少有一点可以证明，视频里的代码没有问题，问题就在于我们自己的代码，可能哪里出了纰漏。</p><p>所以，你只要找到自己代码和视频代码不同的地方即可。</p><p>由于我们写的是 Java 代码，Java 最大的优势就是跨平台，所以一般来说，只要你的 JDK 版本与 Tomcat 版本（其他的例如 MyBatis 版本、Spring Boot 版本、Spring Cloud 版本等）和视频作者的一致，这个时候代码出问题<strong>超过 99.99% 情况下都不是环境问题，就是代码写错了</strong>，千万别甩锅给系统环境，平时在公司里甩得一手好锅，要是用到学习中，损失的还是自己。所以首先要相信自己写错了，问题才有解决思路。</p><p>为什么我要把这个话题拎出来说呢？因为很多小伙伴有一句口头禅：“我和视频里的代码一样，就是显示不出来。”、“刚才代码还是好的，吃个饭回来就运行不了了”。。。</p><p>每次看到这个，我竟无语凝噎。这句话两个意思，要么就是我的代码和视频一样，那就是我的代码没错，既然代码没错，那我觉得问题可以到此结束了，代码没错，那也就没问题呀；要么另一层含义就是视频代码有问题，但是视频里的代码可以运行出效果，这也是你亲眼所见，所以视频代码肯定是没问题的。那么问题就会陷入死循环，无解。</p><p>所以，出了问题，确认了不是版本问题，那么基本上就是自己代码问题了，相信自己代码有问题，才有可能解决问题。</p><p>松哥以前看视频也会遇到这些问题，有的时候实在找不出问题，那我会跑一遍视频作者提供的 Demo（如果有的话），如果他的 Demo 能运行，那么不用多想了，肯定不是环境问题，就是你自己代码写错了，那就认认真真检查。</p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>在检查的过程中，我常用的一个办法，我自己给它取名叫做二分法。</p><p>有的小伙伴一直不理解做算法题的意义在哪里，仅仅是为了面试？其实不是的，一些典型的算法思想，可以影响我们日常的很多事情的，就比如解决 Bug 这事。</p><p>这里我通过两个简单的栗子来给大家说明这种方法的使用。</p><h3 id="微人事登录"><a href="#微人事登录" class="headerlink" title="微人事登录"></a>微人事登录</h3><p>假如说你现在遇到了登录问题，点击前端登录按钮无法登录成功，那么原因可能有很多种。</p><p>假如这问题发生在微人事项目中，那么我们的检查顺序是下面这样的：</p><ol><li>前端 WebStorm 和后端 IDEA 控制台有没有报错？</li><li>前端浏览器控制台有没有报错？</li><li>查看浏览器发送的请求和服务端给出的响应有没有问题？</li></ol><p>如果这三处都看不出端倪来，那么就要开始分析了。因为这种前后端分离开发，问题可能出在前端也可能出在后端，我们要先去锁定问题。怎么锁定呢？我画了一张简图：</p><p><img src="http://www.javaboy.org/images/other/116-1.png" alt></p><p>按照这样的思路，我们一步步去缩小问题的范围，直到解决问题。</p><h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p>这种二分法，还有一个非常典型的场景，就是乱码问题，很多初学者遇到乱码问题，把自己懂的乱么解决方案全部试了一遍，结果发现啥用没有，我相信很多初学的小伙伴遇到可能都有遇到这样的尴尬事，这是因为乱码的原因太多了，找对原因，才能解决问题。</p><p><img src="http://www.javaboy.org/images/other/116-2.png" alt></p><p><strong>上面这两张图，主要是给大家提供一个问题解决的思路，我们把一个大的问题，不断的拆分，不断的细化，然后一个一个求证，最后就能锁定问题所在。一旦找到问题的原因，解决不过是分分钟的事情。</strong></p><h2 id="多动手"><a href="#多动手" class="headerlink" title="多动手"></a>多动手</h2><p>二分法，是给大家提供了思路，接下来就是验证了。验证其实是很容易的，Debug 或者打印日志都可以，一定要去动手验证，不能只在脑子里过一遍，想着这里没问题，那里没问题，最终得出结论我的代码没问题。</p><p>验证问题的时候有一个问题大家需要注意，要摒弃所有定势思维。不知道大家有没有这样的经历，很多时候你觉得不可能出问题的地方，就忽略检查了，结果折腾了半天，最终发现问题就出在那里。所以我们在验证问题所在的时候，不要跳跃，每一个步骤都去验证下，这样看着很慢，实际上能为大家省下不少时间。</p><p>这些思路，主要是针对新手的，如果你经验丰富，其实不用管这些条条框框，结合自己的经验，其实大部分 Bug 都是可以快速搞定的。</p><p>好了，下次小伙伴们做前后端分离开发或者看松哥视频学习时，遇到问题，不妨按照上面的思路试一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在公众号后台分别回复 &lt;code&gt;SpringBoot&lt;/code&gt;、&lt;code&gt;Spring&lt;/code&gt;、&lt;code&gt;SpringMVC&lt;/code&gt;、&lt;code&gt;MyBatis&lt;/code&gt; 以及 &lt;code&gt;Maven&lt;/code&gt; 可以下载松哥手撸的技术干货。有一些小伙伴在学习这些干货的时候，遇到了一些问题，来求助松哥，虽然问题很多，但是大部分都是类似的，因此我决定写一篇文章来和大家聊一聊这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="vhr" scheme="http://www.javaboy.org/categories/vhr/"/>
    
    
      <category term="vhr" scheme="http://www.javaboy.org/tags/vhr/"/>
    
  </entry>
  
  <entry>
    <title>不花一分钱，把自己零散的知识整理成体系，制作成在线电子书</title>
    <link href="http://www.javaboy.org/2020/0116/hexo.html"/>
    <id>http://www.javaboy.org/2020/0116/hexo.html</id>
    <published>2020-01-16T01:30:23.000Z</published>
    <updated>2020-03-05T01:40:18.293Z</updated>
    
    <content type="html"><![CDATA[<p>看过松哥个人网站的小伙伴，都知道松哥做了很多在线的电子书，把自己一些零散的知识点整理成体系：</p><a id="more"></a><ul><li><a href="http://maven.javaboy.org" target="_blank" rel="noopener">http://maven.javaboy.org</a></li></ul><p><img src="http://www.javaboy.org/images/tools/114-1.png" alt></p><ul><li><a href="http://spring.javaboy.org" target="_blank" rel="noopener">http://spring.javaboy.org</a></li></ul><p><img src="http://www.javaboy.org/images/tools/114-2.png" alt></p><ul><li><a href="http://springmvc.javaboy.org" target="_blank" rel="noopener">http://springmvc.javaboy.org</a></li></ul><p><img src="http://www.javaboy.org/images/tools/114-3.png" alt></p><ul><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li></ul><p><img src="http://www.javaboy.org/images/tools/114-4.png" alt></p><ul><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li></ul><p><img src="http://www.javaboy.org/images/tools/114-5.png" alt></p><p>很多小伙伴很好奇这些网站都是怎么做的，今天松哥就来和大家聊一聊。</p><p>首先，这些网站都是托管在 GitHub 上的，不用花一分钱，但是 GitHub 的网速一直被大家吐槽，所以如果条件允许，以后也可以考虑弄到国内的云服务器上。</p><p>好了，废话不多说，我们就来看看这里的实现方案吧。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>制作在线电子书有一个比较主流的方案，就是 gitbook，这个小伙伴们有兴趣可以自己先搜索看下，以后要是有时间我也可以和大家聊一聊 gitbook 制作方式，本文我还是先说说我目前采用的方案。</p><p>松哥之前写过一篇文章教大家搭建自己的独立博客：</p><ul><li><a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a></li></ul><p>在这篇文章中，松哥提到使用 GitHub 搭建个人博客，技术选型有两种方案：</p><ol><li>GitHub 上 结合 Jekyll 搭建的博客，Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和我们的 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。</li><li>本地渲染好 HTML 后，上传到服务端，代表作品就是 hexo。</li></ol><p>松哥自己的 <a href="http://www.javaboy.org">www.javaboy.org</a> 采用了第二种方案，上面列出来的 5 个电子书使用了第一种方案。其实电子书的也可以使用第二种方案，只是我没找到合适的主题，所以就选用了第一种方案，也就是 Jekyll。</p><p>这里需要说明一点，其实用第一种或者第二种方案都行，网站的呈现形式和你选用的 Theme 相关，和这里的方案无关。</p><p>网站主题我这里使用的是很早之前微笑哥给推荐的一个主题，叫做 jekyll-TeXt-theme（<a href="https://github.com/kitian616/jekyll-TeXt-theme）。" target="_blank" rel="noopener">https://github.com/kitian616/jekyll-TeXt-theme）。</a></p><p>这个主题有多种不同的展现形式，大家在我这里看到的左边菜单，右边内容，这只是它的展现形式之一，它的菜单也可以放在顶部等等，至于其他不同形式的玩法，大家可以参考它的文档，我这里就不多说了。</p><p>好了，接下来，我们就通过 GitHub pages+jekyll-TeXt-theme 来整理自己的电子书吧。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>这里准备工作做两件事：</p><ol><li>在 GitHub 上创建自己的网站仓库并 clone 到本地。</li><li>本地安装 Ruby 环境。</li></ol><p>第二步其实可要可不要。在网站配置的过程中，我们可能需要在本地预览效果，由于 Jekyll 基于 Ruby，这个时候就需要 Ruby 环境。但是，本地安装 Ruby 可能会遇到一些版本问题，如果你不愿意折腾，也可以不在本地安装 ruby 环境，而是配置完成后，直接将网站 push 到 GitHub 上，然后直接在线预览，这也是一个办法。</p><p>ruby 的安装就比较简单了，小伙伴们可以自行解决，我就不多说了，安装完成后，命令行输入 <code>ruby -v</code>，如果能看到如下提示，表示 ruby 已经安装成功了：</p><p><img src="http://www.javaboy.org/images/tools/114-6.png" alt></p><p><strong>强烈建议</strong></p><p>在本地预览这事，大家可能会遇到各种各样问题，在处理问题的过程中，可能会消磨掉大家制作在线电子书的兴趣，因此这块松哥建议你先不要尝试本地预览，网站配置完成后，就直接发到 GitHub 上在线预览，先看到效果。然后，再抽空安装 Ruby ，尝试本地预览。</p><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h3><p>首先，我们申请一个 GitHub 账户，然后创建一个以 <code>你的 GitHub 用户名.github.io</code> 为名称的仓库:</p><p><img src="http://www.javaboy.org/images/tools/114-7.png" alt></p><p>仓库创建成功后，点击 settings，为我们的 GitHub Pages 任意选择一个主题：</p><p><img src="http://www.javaboy.org/images/tools/114-8.png" alt></p><p>这里 Choose a theme，随便选一个就行了，然后我们的网站就自动发布了。选完之后，这里还有一个填写网站域名的地方，但是大家不要填，如果自己有购买域名的话，建议在仓库文件里配置，不要在这里配置。</p><p>仓库创建完成后，我们将仓库 clone 到本地。然后创建一个 index.html 文件，里边随便写一句 helloworld，提交到 GitHub 上，接着访问 <a href="https://javaboy666.github.io" target="_blank" rel="noopener">https://javaboy666.github.io</a> ，就可以看到我们的网站了。</p><p><img src="http://www.javaboy.org/images/tools/114-9.png" alt><br><img src="http://www.javaboy.org/images/tools/114-10.png" alt></p><h3 id="2-配置主题"><a href="#2-配置主题" class="headerlink" title="2.配置主题"></a>2.配置主题</h3><p>现在我们的网站还比较简陋，接下来我们配置主题，主题刚才说了，就是 jekyll-TeXt-theme，我们先从 GitHub 上下载下来这个主题（<a href="https://github.com/kitian616/jekyll-TeXt-theme）：" target="_blank" rel="noopener">https://github.com/kitian616/jekyll-TeXt-theme）：</a></p><p>这块，大家可以直接 Download zip 也可以 clone ，都行，拿到文件后，将文件拷贝到我们上一步 clone 下来的本地仓库中，除了 .git 文件夹之外，其他文件全部覆盖。</p><p><img src="http://www.javaboy.org/images/tools/114-11.png" alt></p><p>拷贝完成后，如果急于看效果，这个时候可以先提交一次，提交完成后，打开 <a href="https://javaboy666.github.io" target="_blank" rel="noopener">https://javaboy666.github.io</a> ，效果如下：</p><p><img src="http://www.javaboy.org/images/tools/114-12.png" alt></p><p>我们可以看到，这个时候，网站已经建成了，如果你不想使用左边导航的方式，现在就可以直接开始写文章了。文章写在 _posts 目录下，文章是 markdown 格式，文件名称和文章标题可以参考 _posts 目录已经有的两个文件。</p><p><img src="http://www.javaboy.org/images/tools/114-13.png" alt></p><p><strong>注意</strong></p><p>默认情况下，文件名中的时间将成为网站的路径，和文件名中除时间以外的字符共同组成文件访问路径，以 <code>2018-06-01-header-image.md</code> 文件为例，该文件在网络上的访问路径是 <code>https://javaboy666.github.io/2018/06/01/header-image.html</code> ，所以你在取文件名的时候，实际上也在配置这个文件的访问路径。至于文章的标题，大家打开 md 后，配置 title 属性就是标题了。</p><h3 id="3-配置导航"><a href="#3-配置导航" class="headerlink" title="3.配置导航"></a>3.配置导航</h3><p>导航的配置很简单，首先我们要找到导航的配置，在 _data/navigation.yml 文件里进行配置，这个文件中已有的配置都是国际化配置，如果大家有需要，可以自行修改。</p><p>我们这里首先在 _data/navigation.yml 文件中增加如下配置(注意 yml 配置 : 后面有一个空格)：</p><figure class="highlight yml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attr">docs-zh:</span></span><br><span class="line"><span class="hljs-attr">  - title:</span>      <span class="hljs-string">导航示例</span></span><br><span class="line"><span class="hljs-attr">    children:</span></span><br><span class="line"><span class="hljs-attr">      - title:</span> <span class="hljs-string">Welcome</span></span><br><span class="line"><span class="hljs-attr">        url:</span> <span class="hljs-attr">https://javaboy666.github.io/2018/07/01/welcome.html</span></span><br><span class="line"><span class="hljs-attr">      - title:</span> <span class="hljs-string">Post</span> <span class="hljs-string">with</span> <span class="hljs-string">Header</span> <span class="hljs-string">Image</span></span><br><span class="line"><span class="hljs-attr">        url:</span> <span class="hljs-attr">https://javaboy666.github.io/2018/06/01/header-image.html</span></span><br><span class="line"><span class="hljs-attr">      - title:</span>  <span class="hljs-string">Java</span> <span class="hljs-string">搭建</span> <span class="hljs-string">SSM</span></span><br><span class="line"><span class="hljs-attr">        url:</span>    <span class="hljs-attr">http://springboot.javaboy.org/2019/0528/javassm</span></span><br></pre></td></tr></table></figure><p>配置完成后，再分别打开 _posts 目录下的两个 md 文件，文件头中分别添加如下内容（注意，每个 md 文件都要修改）:</p><p><img src="http://www.javaboy.org/images/tools/114-14.png" alt></p><p>改完之后，内容页面的导航菜单就有了，但是首页还没有，然后我们在根目录下找到 index.html，文件中也添加上导航，如下：</p><p><img src="http://www.javaboy.org/images/tools/114-15.png" alt></p><p>改完之后，再次提交到 GitHub 上：</p><p><img src="http://www.javaboy.org/images/tools/114-16.png" alt></p><p>大功告成！</p><h3 id="4-其他配置"><a href="#4-其他配置" class="headerlink" title="4.其他配置"></a>4.其他配置</h3><p>我们的电子书的基本框架现在就算是搭建完成了。这个时候，我们可能还需要对网站的基本信息进行配置，这个配置主要在根目录下的 <code>_config.yml</code> 文件中进行配置。我这里随便配置几个给大家参考：</p><figure class="highlight yml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">## =&gt; Site Settings</span></span><br><span class="line"><span class="hljs-comment">##############################</span></span><br><span class="line"><span class="hljs-attr">text_skin:</span> <span class="hljs-string">default</span> <span class="hljs-comment"># "default" (default), "dark", "forest", "ocean", "chocolate", "orange"</span></span><br><span class="line"><span class="hljs-attr">highlight_theme:</span> <span class="hljs-string">default</span> <span class="hljs-comment"># "default" (default), "tomorrow", "tomorrow-night", "tomorrow-night-eighties", "tomorrow-night-blue", "tomorrow-night-bright"</span></span><br><span class="line"><span class="hljs-string">url</span>     <span class="hljs-string">:</span> <span class="hljs-attr">http://javaboy666.github.io</span></span><br><span class="line"><span class="hljs-string">baseurl</span> <span class="hljs-string">:</span> <span class="hljs-comment"># does not include hostname</span></span><br><span class="line"><span class="hljs-string">title</span>   <span class="hljs-string">:</span> <span class="hljs-string">江南一点雨</span></span><br><span class="line"><span class="hljs-attr">description:</span> <span class="hljs-string">电子书示例网站，关注微信公众号：江南一点雨</span> <span class="hljs-string">，回复</span> <span class="hljs-number">2</span><span class="hljs-string">TB</span> <span class="hljs-string">获取超</span> <span class="hljs-number">2</span><span class="hljs-string">TB</span> <span class="hljs-string">免费</span> <span class="hljs-string">Java</span> <span class="hljs-string">教程。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## =&gt; Language and Timezone</span></span><br><span class="line"><span class="hljs-comment">##############################</span></span><br><span class="line"><span class="hljs-attr">lang:</span> <span class="hljs-string">zh-Hans</span> <span class="hljs-comment"># the language of your site, default as "en"</span></span><br><span class="line"><span class="hljs-attr">timezone:</span> <span class="hljs-comment"># see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones for the available values</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## =&gt; Author and Social</span></span><br><span class="line"><span class="hljs-comment">##############################</span></span><br><span class="line"><span class="hljs-attr">author:</span></span><br><span class="line">  <span class="hljs-string">type</span>      <span class="hljs-string">:</span> <span class="hljs-comment"># "person" (default), "organization"</span></span><br><span class="line">  <span class="hljs-string">name</span>      <span class="hljs-string">:</span> <span class="hljs-string">江南一点雨</span></span><br><span class="line">  <span class="hljs-string">url</span>       <span class="hljs-string">:</span></span><br><span class="line">  <span class="hljs-string">avatar</span>    <span class="hljs-string">:</span> <span class="hljs-attr">https://www.javaboy.org/images/sb/javaboy.jpg</span></span><br><span class="line">  <span class="hljs-string">bio</span>       <span class="hljs-string">:</span> <span class="hljs-string">I</span> <span class="hljs-string">am</span> <span class="hljs-string">an</span> <span class="hljs-string">amazing</span> <span class="hljs-string">person.</span></span><br><span class="line">  <span class="hljs-string">email</span>     <span class="hljs-string">:</span> <span class="hljs-string">wangsong0210@gmail.com</span></span><br><span class="line">  <span class="hljs-string">zhihu</span>     <span class="hljs-string">:</span> <span class="hljs-string">wang-song-9</span> <span class="hljs-comment"># "user_name" the last part of your profile url, e.g. https://www.zhihu.com/people/user_name</span></span><br><span class="line">  <span class="hljs-string">github</span>    <span class="hljs-string">:</span> <span class="hljs-string">lenve</span> <span class="hljs-comment"># "user_name" the last part of your profile url, e.g. https://github.com/user_name</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">## =&gt; GitHub Repository (if the site is hosted by GitHub)</span></span><br><span class="line"><span class="hljs-comment">##############################</span></span><br><span class="line"><span class="hljs-attr">repository:</span> <span class="hljs-string">javaboy666/javaboy666.github.io</span></span><br><span class="line"><span class="hljs-attr">repository_tree:</span> <span class="hljs-string">master</span></span><br></pre></td></tr></table></figure><p>配置完成后，提交到 GitHub ，这个时候，我们可以看到配置已经生效。</p><p><img src="http://www.javaboy.org/images/tools/114-17.png" alt></p><p>如果配置没有生效，大概率是配置出错了，这个时候就需要仔细检查下问题所在了。配置出错时，你的 GitHub 账户邮箱会收到一封配置出错的邮件，可以根据邮件的提示来解决问题：</p><p><img src="http://www.javaboy.org/images/tools/114-18.png" alt></p><p>本篇文章结合松哥之前的 <a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a> 一起食用效果更加，因为这两个里边有很多东西是相通的。</p><p><strong>另外，如果你懒得做上面的配置，可以直接 clone 松哥这个示例仓库，提交到你的仓库上，然后直接写文章即可。示例仓库地址：<a href="https://github.com/javaboy666/javaboy666.github.io" target="_blank" rel="noopener">https://github.com/javaboy666/javaboy666.github.io</a></strong></p><p>好了，小伙伴们不妨试一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看过松哥个人网站的小伙伴，都知道松哥做了很多在线的电子书，把自己一些零散的知识点整理成体系：&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.javaboy.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://www.javaboy.org/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>274 页 pdf 文档，Spring Boot 教程也有离线版了</title>
    <link href="http://www.javaboy.org/2020/0114/springboot-pdf.html"/>
    <id>http://www.javaboy.org/2020/0114/springboot-pdf.html</id>
    <published>2020-01-14T01:29:58.000Z</published>
    <updated>2020-03-05T01:56:20.835Z</updated>
    
    <content type="html"><![CDATA[<p>上次发了篇文章说是 Spring Boot+Vue 视频杀青了，里边提到我有一个手敲 5W 余字的 SSM 教程，然后就有很多小伙伴不停在公众号后台追问 5W 余字的 SSM 教程在哪？看到这个问题我也挺郁闷的，看来前面的干货还是有很多小伙伴错过，因此今天就再说一下，大家在松哥公众号后台分别回复：<code>maven</code>、<code>spring</code>、<code>springmvc</code>、<code>mybatis</code> 可以获取松哥手敲的干货教程，当然也可以直接访问在线教程：</p><ul><li><a href="http://maven.javaboy.org" target="_blank" rel="noopener">http://maven.javaboy.org</a></li><li><a href="http://spring.javaboy.org" target="_blank" rel="noopener">http://spring.javaboy.org</a></li><li><a href="http://springmvc.javaboy.org" target="_blank" rel="noopener">http://springmvc.javaboy.org</a></li><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li></ul><p><strong>不过，从今天开始，公众号后台干货喜迎新的关键字 <code>springboot</code>。</strong></p><p>很早就有小伙伴问松哥 Spring Boot 教程有没有电子版的，其实这个我一直在准备，迟迟没有发布的原因在于我一直觉得已有的教程还不够完善，还需要补充，而 pdf 一旦发布，传播开来后，再更新的话，大家不容易及时 GET 到。</p><p>所以，我一直做的是在线电子书，在线电子书的好处是可以及时更新，这样无论什么时候大家打开在线文档，看到的就是最新的教程。</p><p>不过由于电子文档托管在 GitHub 上，GitHub 近来访问速度越来越慢，图片也经常加载不出来。另一方面，昨天整理完了 15 道 Spring Boot 面试题，然后早期博客的排版问题我也逐一整理了一遍，这个教程也算是告一段落了，阶段性收尾，于是抽空做了这个离线的 pdf 文档。</p><p><img src="http://www.javaboy.org/images/boot/51-1.png" alt><br><img src="http://www.javaboy.org/images/boot/51-2.png" alt></p><p>还是老规矩，小伙伴们在公众号后台回复 springboot，可以获取该 pdf 文档。</p><p>如果不想看离线的 pdf ，也可以看在线的教程，内容基本是一样的：</p><ul><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li></ul><p><img src="http://www.javaboy.org/images/boot/51-3.png" alt></p><p>松哥最早开始写博客的时候，对于排版技巧啥的都不太懂，导致一开始的博客排版比较丑陋，最近我基本上都挨个重新排版了一遍，所以文章看起来会更加整齐一些了。</p><p>另外松哥每一次发布的 pdf 文档教程，都是有书签的，大家点击左边的书签可以快速导航到自己想看的知识点。不过由于国内的版权环境不佳，所以松哥发布的 pdf 教程都是经过我处理的，但是这个处理并不影响阅读，该怎么看还是怎么看（建议用 Adobe 官方的 pdf 阅读器）。</p><p>好了，废话就不多说了，Spring Boot 撸起来吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上次发了篇文章说是 Spring Boot+Vue 视频杀青了，里边提到我有一个手敲 5W 余字的 SSM 教程，然后就有很多小伙伴不停在公众号后台追问 5W 余字的 SSM 教程在哪？看到这个问题我也挺郁闷的，看来前面的干货还是有很多小伙伴错过，因此今天就再说一下，大家在
      
    
    </summary>
    
      <category term="学习资源" scheme="http://www.javaboy.org/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="学习资源" scheme="http://www.javaboy.org/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>天呐，世界上还有免费的域名，赶紧抢注一个压压惊</title>
    <link href="http://www.javaboy.org/2020/0110/free-domain.html"/>
    <id>http://www.javaboy.org/2020/0110/free-domain.html</id>
    <published>2020-01-10T01:26:39.000Z</published>
    <updated>2020-01-10T02:09:14.203Z</updated>
    
    <content type="html"><![CDATA[<p>你可能想不到，这世界上还有免费的顶级域名！虽然这不是什么大新闻，可是很多小伙伴可能还不知道。</p><a id="more"></a><p>前两天刚和大家聊了不花一分钱搭建个人博客的事情（<a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a>）,在这篇文章中，你要真的一分钱都不想花，那就要接受 GitHub 提供的默认域名，GitHub 默认提供的域名是二级域名，这个默认的二级域名可能不太好记。</p><p>另一方面，有的时候大家做一些简单开发，想把自己的应用扔到服务器上去跑，这个时候，给服务器配置一个域名操作起来也会方便很多。so。。。</p><p>今天松哥再和大家透漏几个真正免费的顶级域名。虽然免费，但是注册过程还是挺麻烦的，不过好在不要钱，麻烦就麻烦吧。</p><p>为什么说注册过程麻烦呢？因为免费域名你要去网站上申请，要申请就要先网站上注册一个账户，就跟你去国内云服务厂商去买域名一样，购买之前你得先注册个账户。</p><p>这些免费域名麻烦就麻烦在注册账户非常麻烦，要注意的地方非常多，不过一个核心的指导思想就是你全程伪装成你在美帝（所以要全程开网络代理，并且代理服务器还要在美帝），否则的话，你会发现找不到注册链接，找不到购买按钮等等。</p><p>松哥亲测，虽然麻烦，但是只要你按照网上的步骤来，是可以申请成功的。</p><p>好了，废话不多说，下面我来介绍我们今天的四大主角：.ml 域名、.cf 域名、.ga 域名以及 .tk 域名。</p><h3 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h3><p>以 .ML 顶级域名为例，我们可以在 freenom 网站上进行申请。申请地址如下：</p><ul><li><a href="http://www.freenom.com/en/index.html" target="_blank" rel="noopener">http://www.freenom.com/en/index.html</a></li></ul><p>打开这个网站，我们首先会看到如下页面：</p><p><img src="http://www.javaboy.org/images/other/110-1.png" alt></p><p>然后在输入框中输入你要查询的域名，例如我这里是 javaboy：</p><p><img src="http://www.javaboy.org/images/other/110-2.png" alt></p><p>然后进入到购物车，选择右边的 12 个月免费期：</p><p><img src="http://www.javaboy.org/images/other/110-3.png" alt></p><p>选择完成后，点击 Continue 按钮进入到下一步：</p><p><img src="http://www.javaboy.org/images/other/110-4.png" alt></p><p>这里非常关键，地址信息要和你的代理服务器信息一致（如果你不知道代理服务器的具体地址，可以用 Google 随便搜索一个东西，拉到最下面，就有 IP 地址所属的位置），所有信息都用英文填写，涉及到地址，要真实可查，并且要有关联，例如你的 Address 和 Zip Code、City、Country 以及 State/Region 之间有必然关系，邮箱地址建议使用国外邮箱，手机号码可以随意填写。</p><p>购买完成后，在首页找到 My Domains ，就可以去配置 DNS 了。</p><p>另外三个申请步骤基本都差不多，要注意的事项也都差不多，只不过注册地址不一样罢了：</p><ul><li>.CF 申请地址：<a href="http://www.dot.cf" target="_blank" rel="noopener">http://www.dot.cf</a></li><li>.GA 申请地址：<a href="http://www.dot.ga" target="_blank" rel="noopener">http://www.dot.ga</a></li><li>.TK 申请地址：<a href="http://www.dot.tk" target="_blank" rel="noopener">http://www.dot.tk</a></li></ul><h3 id="域名介绍"><a href="#域名介绍" class="headerlink" title="域名介绍"></a>域名介绍</h3><p>接下来我也简单介绍一下这几个域名，为什么他们是免费的？</p><p>.ML 域名来自马里，中文有“美丽”之意，任何人都可以注册，没有任何限制，也不收取任何费用。<br>.CF 域名来自中非共和国，目前由(SOCATEL) 管理，由荷兰的 Freedom Registry 公司负责运作。<br>.GA 域名来自非洲国家加蓬。<br>.TK 域名算是一个老牌的域名了，据说目前活跃的域名超过 1600 万个，这里估计国人也贡献了不少。</p><p>这些比较奇特的顶级域名 Google 肯定会收录，百度暂不清楚。</p><p>最后，虽然这些域名不要钱，不过如果大家想正儿八经的搞一个自己的博客网站，松哥还是建议花几十块买一个 .com 域名，也不贵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你可能想不到，这世界上还有免费的顶级域名！虽然这不是什么大新闻，可是很多小伙伴可能还不知道。&lt;/p&gt;
    
    </summary>
    
      <category term="domain" scheme="http://www.javaboy.org/categories/domain/"/>
    
    
      <category term="domain" scheme="http://www.javaboy.org/tags/domain/"/>
    
  </entry>
  
  <entry>
    <title>MacBook Pro 入手一年了，到底香不香？</title>
    <link href="http://www.javaboy.org/2020/0108/mackbookpro.html"/>
    <id>http://www.javaboy.org/2020/0108/mackbookpro.html</id>
    <published>2020-01-08T01:26:24.000Z</published>
    <updated>2020-01-10T02:08:23.400Z</updated>
    
    <content type="html"><![CDATA[<p>最近又有小伙伴问到底值不值得入手一台 MacBook Pro，松哥自己在 2018 年 10 月份的时候入手了一台，到现在为止，也用了一年多了，今天就来和小伙伴们聊一聊使用感受，至于到底值不值，需要大家自行判断。</p><a id="more"></a><p>我的第一台笔记本是大一第二学期（2012 年 4 月份）入手的，是一台 Sony 的 VAIO，这台电脑现在也一直在用，给大家录制的视频教程都是用这台电脑录制了，在接近 8 年的时间里，这台笔记本一直是我的主力机，更重要的是从来没有拿去修过，质量很棒，因此当我想要换电脑的时候，首先考虑的还是 VAIO，可惜 Sony 在 2014 年将 PC 业务整体出售，VAIO 这个品牌也卖给了 JIP（Japan Industrial Partners Inc.），从此退出了笔记本电脑市场。</p><p>排除了 VAIO 之后，剩下的选项就是 MacBook Pro 了。其实很早就想入手一台 mbp 了，2016 年那会，刚毕业一年，薪水翻了三倍，我想入手一台 mbp 奖励自己，但后来还是控制住自己了，买了一个固态硬盘给我的 Windows 装上了，然后就把买 mbp 这个欲望压下来了。去年 10 月份的时候，我的第一本书刚刚交稿给出版社，还是蛮激动的，心想这下可以买一个 mbp 了吧，这次没能成功控制住自己，于是就买了，要买就买好的，于是我在 Apple 官网定制了一台 32G 内存的 mbp，当时还送了一个 beat solo 耳机。</p><p>耳机一直是女票在用，我就不多说了，我这次主要和大家说说作为一个程序员，我比较关注的开发工具的使用感受。</p><h2 id="idea-秒开"><a href="#idea-秒开" class="headerlink" title="idea 秒开"></a>idea 秒开</h2><p>第一次知道原来 IntelliJ IDEA 可以秒开。最早用 Windows 的时候，那会还不是固态硬盘，每天到公司后，先按下开机键，然后去打杯水，回来电脑刚好开机，然后点下 idea 图标，再去上个厕所，回来后 idea 也开好了，后来换了个固态硬盘，Windows 开机基本上可以控制在 10s 之内，所以每条到公司的流程也调整了下，先开机，然后等一会开机完成后，开 idea，然后再去打水，回来的时候 idea 就刚好开好。</p><p>用了 mbp 之后，idea 和 webstorm 这两个平时开发用的最多的软件，基本都可以秒开，相应的，idea 在项目编译运行的时候，也要快很多。这样开发效率提升可不是一丁半点。</p><h2 id="不用关机"><a href="#不用关机" class="headerlink" title="不用关机"></a>不用关机</h2><p>mbp 还有一个非常有用的地方就是不用关机，想想你做开发，idea、webstorm、vscode、sequel pro、postman、命令行等等开了一堆，现在下班了，全部关掉回家，明天来了再挨个打开，不是很费事么？mac 用完了，直接合上盖就可以了，下次再打开盖子，这些东西都还可以接着使用。不用再一个一个打开。</p><p>我刚开始用的时候，对这个功能很不习惯，每次用完还是习惯性的关机，后来时间久了，慢慢就接受了，现在我的 mbp 估计都快一年没关过机了，依然用着很流畅。</p><h2 id="命令行好用"><a href="#命令行好用" class="headerlink" title="命令行好用"></a>命令行好用</h2><p>mbp 里边的命令行也是非常方便，远程连接 Linux 服务器时，甚至不需要额外准备第三方工具，直接在命令行用命令连接。</p><p>但是在命令行连接远程服务器，如果 ssh 连接空闲一段时间后，就会自动断开，下次又得重新连接，我在网上看了一些方案之后，后来还是决定用一些工具得了，综合比较后，使用了 Royal TSX，既可以做远程连接，又可以方便的上传文件。</p><h2 id="Adobe-Pr-真快"><a href="#Adobe-Pr-真快" class="headerlink" title="Adobe Pr 真快"></a>Adobe Pr 真快</h2><p>因为我今年一直在录视频教程，视频要二次处理剪辑啥的，二次处理我使用了 Adobe Premiere Pro ，刚开始我是在 Windows 上处理的，但是太慢了，一个 10 分钟左右的视频，渲染起来的时间接近 20 分钟，漫长的等待实在有点受不了，后来就把视频的二次处理换到 mbp 上来处理，10 分钟的视频，大概一两分钟就可以渲染好，速度非常快。</p><p>不过在 mbp 上处理视频，也有一个问题，就是视频长的时候（10 分钟以上），可以明显的听到电脑风扇呼呼响，渲染完成后，电脑又会慢慢冷静下来，这是一个非常明显的变化。这个让我有点吃惊，因为我印象中，mbp 应该比较擅长做视频处理，但是这块实际操作起来，感觉它还是有点压力。</p><p>至于为什么不在 mbp 上使用 FINAL CUT，这是因为有的时候我还需要搭配着 Windows 使用，为了能够在 Windows 和 mbp 之间平滑切换，选择了 Adobe Pr。</p><h2 id="Docker-必备"><a href="#Docker-必备" class="headerlink" title="Docker 必备"></a>Docker 必备</h2><p>个人觉得，使用 mbp，一定安装一个 Docker，Docker 在 mbp 上安装非常方便，比 windows 省事很多，Docker 装好之后，以后的 MySQL、RabbitMQ、Redis、Nginx 等工具，都可以直接使用 Docker 来安装，方便了很多。我一直就是这样搞的。</p><p>不过 Docker 使用过程中，遇到过一次超级耗内存的情况，就是有一次突然电脑风扇呼呼响，检查之后发现是 Docker 的问题，关掉的 Docker 之后就好了，不过后来使用 Docker 没再遇到这个情况。</p><h2 id="Sequel-Pro"><a href="#Sequel-Pro" class="headerlink" title="Sequel Pro"></a>Sequel Pro</h2><p>数据库连接工具我使用了 Sequel Pro，在 Windows 上，我一直是 Navicat 和 SQLyog 两个切换着使用，mbp 上也有 Navicat ，但是搞起来比较麻烦，我就懒得去弄了，于是入乡随俗，选择了 Sequel Pro。</p><p>Sequel Pro 其实用着也没啥不方便的地方，感觉我自己的平时的需求都够用了。</p><h2 id="mbp-Vs-Ubuntu"><a href="#mbp-Vs-Ubuntu" class="headerlink" title="mbp Vs Ubuntu"></a>mbp Vs Ubuntu</h2><p>在公司做开发的时候，用 Ubuntu 做主力系统也用了很长一段时间，这也是我后来切换到 mbp 上之后，没有太多的陌生感的原因之一。个人感觉 mbp 和 Ubuntu 有很多相似的地方，相比于 Ubuntu ，mbp 最大的优势在于软件生态丰富，像 Adobe 全家桶，微信这些东西，在 mbp 上安装就不用折腾。</p><p>小伙伴们要是未来有入手 mbp 的打算，我建议现在可以在 Windows 笔记本上整一个双系统，装上 Ubuntu，这样有一天当你想切换到 mbp 上时，就可以平滑过渡。</p><h2 id="还要-Windows-系统吗"><a href="#还要-Windows-系统吗" class="headerlink" title="还要 Windows 系统吗"></a>还要 Windows 系统吗</h2><p>老实说，Windows 还是离不开。至少我这边有不少事情还是需要在 Windows 上做，例如平时给大家录制视频教程，mbp 当然也可以录，但是录出来的视频文件超级大，不利于分发和传播，所以我一直选择在 Windows 上录制。不过我不太喜欢在 mbp 上搞 Windows ，所以现在是两台笔记本，mbp 是主力，之前那台用了八年的 Windows 打辅助，两台设备切换着用。</p><p>其实在电脑上我不太喜欢折腾，一般能满足需求，我就会一直先用着。换了 mbp 之后，使用最多的软件还是那几个开发工具，其他 mbp 上的功能发掘的少，不过也在慢慢摸索。</p><p>整体来说，还是比较香的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又有小伙伴问到底值不值得入手一台 MacBook Pro，松哥自己在 2018 年 10 月份的时候入手了一台，到现在为止，也用了一年多了，今天就来和小伙伴们聊一聊使用感受，至于到底值不值，需要大家自行判断。&lt;/p&gt;
    
    </summary>
    
      <category term="MacBookPro" scheme="http://www.javaboy.org/categories/MacBookPro/"/>
    
    
      <category term="MacBookPro" scheme="http://www.javaboy.org/tags/MacBookPro/"/>
    
  </entry>
  
  <entry>
    <title>不用花一分线，松哥手把手教你上线个人博客</title>
    <link href="http://www.javaboy.org/2020/0106/hexo-blog.html"/>
    <id>http://www.javaboy.org/2020/0106/hexo-blog.html</id>
    <published>2020-01-06T01:26:07.000Z</published>
    <updated>2020-01-10T02:07:30.905Z</updated>
    
    <content type="html"><![CDATA[<p>有不少小伙伴私信松哥，打听松哥的博客是怎么做的，其实这个我之前和大家聊过，今天就再来说一说。</p><a id="more"></a><p>我记得是 2015 年 4 月 15 在CSDN上发表了我的第一篇博客，是一个学习笔记，从那之后开启了我博客写作之路，到今天为止 4 年多了。</p><p>这 4 年时间我在 CSDN 上发表的博客最多，共有 550 篇原创，CSDN 是我的大本营，不过在这期间也有断断续续在其他公共平台上发过博客，例如 sf、博客园、掘金、慕课网等，但是都是非常零散，2016 年的时候，利用我的 GitHub 也搭建了一个个人站点，但是只是试验了几个页面，并没有好好去维护。</p><p>今年搞了一个自己的独立博客 <code>http://www.javaboy.org</code> ，从四月份到现在，博客 PV 和 UV 都以肉眼可见的速度增长，我也是蛮开心的。因为大家个人独立博客最怕的就是流量，这也是我把这个事情拖了 4 年才做的原因之一，但是真正动手做之后，我发现搭建个人独立博客比想象的要容易很多，至于流量，只要内容 OK，流量也都不是事。</p><p>今天我就来和大家聊一聊如何搭建一个个人博客。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>目前静态博客站点非常流行，所以我其实不太建议大家再去搞动态博客系统，那样要操心的事情太多了。使用搭建静态博客，可以让我们把大部分精力集中在博客写作上，而不是无休止的耗费在博客搭建上（很多小伙伴搭建博客的时候兴致勃勃，搭建完成后就意兴阑珊，然后就没有然后了，空留一个博客网站摆在那里）。</p><p>静态博客选型，松哥目前接触到的主要是两种方案：</p><ol><li>GitHub 上 结合 Jekyll 搭建的博客，Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和我们的 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。</li><li>本地渲染好 HTML 后，上传到服务端，代表作品就是 hexo。</li></ol><p>简单说，第一种方式，就是我们在本地写好 markdown 之后，直接上传到服务端，服务端会自动渲染成 HTML，然后展示给用户，第二种方案则是我们在本地写好 markdown 之后，在本地将 markdown 渲染成 HTML，然后将渲染好的 HTML 上传到服务端。（markdown 小伙伴们应该都了解吧，我就不做过多介绍了）</p><p>这两种方案松哥都有用，大家见到的 <code>http://www.javaboy.org</code>，是我使用 hexo+icarus 实现的。大家见到的 <code>http://springboot.javaboy.org</code>、<code>http://spring.javaboy.org</code>、<code>http://springmvc.javaboy.org</code>、<code>http://mybatis.javaboy.org</code>、<code>http://maven.javaboy.org</code> 等，则是我使用 Jekyll 来做的，两种方案各有优缺点，这个松哥后面再和大家详述。</p><p>今天主要和大家聊一聊 <code>http://www.javaboy.org</code> 站点的搭建，也就是我采用了 hexo+icarus 来实现的。</p><p>这个博客的所有资金投入就是几十块钱买了一个域名，再就没花钱了。站点托管在 GitHub 上，评论系统也用了 GitHub 来做，如果你能接受 GitHub 提供的默认域名，那你甚至连域名都不用买了，接下来我们就来看看这个东西怎么实现。</p><blockquote><p>如果大家玩过松哥的微人事(<a href="https://github.com/lenve/vhr)或者" target="_blank" rel="noopener">https://github.com/lenve/vhr)或者</a> V 部落(<a href="https://github.com/lenve/VBlog)，那么对于" target="_blank" rel="noopener">https://github.com/lenve/VBlog)，那么对于</a> hexo 上手可能非常容易，因为这个里边也使用了 nodejs，和微人事的前段操作有很多相同的地方。</p></blockquote><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><p>用 Hexo 搭建，要是有一点点前端 Node 的使用经验更佳，没有当然也没关系，因为与之相关的命令并不多。使用 Hexo 需要提前在电脑上安装好 Node 和 Git ，安装成功后，就可以开始 Hexo 的安装了。步骤如下：</p><ol><li>安装 Hexo</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ol start="2"><li>在本地创建一个博客目录</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>上面这个命令执行完后，会在本地创建一个 blog 目录，这里边就是独立博客所必须的一些文件，然后进入到这个目录中，执行 <code>npm install</code> 命令，安装相关的依赖。</p><p>安装完成后，会生成如下目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>这里几个文件/文件夹，我们先来关注其中两个 _config.yml 和 themes 目录， _config.yml 文件中，我们可以做网站的一些基本配置，例如 网站的 title，描述，关键字、图标等，这些配置大都见名知意。如下：</p><p><img src="http://www.javaboy.org/images/other/106-1.png" alt></p><p>配置完成后，定位到 blog 目录，执行 <code>hexo s</code> 就可以在本地启动项目了，启动成功后，浏览器中输入 <code>http://localhost:4000</code> 就可以看到网站了。</p><p>说到 <code>hexo s</code> 命令，这里有几个常用命令需要给大家介绍下，分别是：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">简写</th><th style="text-align:left">中文含义</th></tr></thead><tbody><tr><td style="text-align:left">hexo server</td><td style="text-align:left">hexo s</td><td style="text-align:left">本地启动</td></tr><tr><td style="text-align:left">hexo generate</td><td style="text-align:left">hexo g</td><td style="text-align:left">生成静态文件</td></tr><tr><td style="text-align:left">hexo deploy</td><td style="text-align:left">hexo d</td><td style="text-align:left">部署网站</td></tr><tr><td style="text-align:left">hexo clean</td><td style="text-align:left"></td><td style="text-align:left">清除缓存和已经生成的静态文件</td></tr></tbody></table><p>这四个算是松哥这两天使用最多的命令，其他的命令，大伙可以参考<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a>。</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>一般来说，主题都会自己配置一个，个人感觉 Hexo 的生态还是比较丰富的，有很多可选的主题，Hexo 默认使用的主题是 landscape ，松哥最早使用了 hexo-theme-next 主题。博客在本地跑起来之后，接下来就是修改主题，主题修改的第一步就是先选一个自己认为好看的主题，选好之后，首先将之克隆到 <code>./themes</code> 目录下，这个目录下原本有有一个 landscape 文件夹，里边放的默认的样式，当然开发者也可以直接将主题文件下载好拷贝进来，但是我还是建议使用 clone ，使用 clone ，假如有一天这个主题更新了，只需要 pull 一下就可以获取到最新样式了。</p><p>以 hexo-theme-next 主题为例， clone 命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>克隆成功后，修改 hexo 的 _config.yml 文件，将主题修改为 next，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>主题创建好之后，接下来就是对主题的配置了，这个比较容易，直接参考<a href="https://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方文档</a>即可。配置完成后，执行如下命令，即可看到新的主题效果：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>命令含义可以参考上面的表格，这里不再赘述。</p><p>这个 next 主题我大概用了两三个月，现在换成了 icarus，大家在主题配置的时候，只要会配置一个，其他多个肯定也就没有问题了。</p><h2 id="绑定到-GitHub"><a href="#绑定到-GitHub" class="headerlink" title="绑定到 GitHub"></a>绑定到 GitHub</h2><p>大家可能已经迫不及待想要把博客上传到 GitHub 了，绑定到 Github 步骤也很简单，首先以 <code>自己的GitHub ID.github.io</code> 为名创建一个 public 仓库，例如我的 ID 为 lenve，创建的仓库如下：</p><p><img src="http://www.javaboy.org/images/other/23-2.png" alt></p><p>创建成功之后，修改 hexo 的 <code>_config.yml</code> 文件，配置 GitHub 地址，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lenve/lenve.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这里根据自己的地址来配置即可，配置完成后，执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>执行完成后，就可以将数据上传到 GitHub 了（当然这里需要大家提前配置一下 GitHub 的公钥，具体可以参考<a href="https://mp.weixin.qq.com/s/x5bRe4QBMoVFKv5jNl9iRw" target="_blank" rel="noopener">Git关联远程仓库</a>）。</p><p>上传成功后，访问 <code>https://lenve.github.io</code> 就可以看到自己的个人站点了，这是 GitHub 默认给我们提供的域名。</p><p>如果你对 GitHub 提供的域名不满意，也可以自己申请一个域名，分分钟就配置好了。</p><h2 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h2><p>域名申请建议使用国外的域名提供商，不用备案（一个字，快！不用等），松哥使用了 godaddy ，主要是因为这个服务商支持支付宝付款，域名申请就比较容易了，无需多说，不过类似的域名提供商其实很多，大家不一定用这个，也可以自己再看看。</p><h2 id="域名和-GitHub-绑定"><a href="#域名和-GitHub-绑定" class="headerlink" title="域名和 GitHub 绑定"></a>域名和 GitHub 绑定</h2><p>域名申请成功之后，接下来的配置，也分为两部分。</p><h3 id="GitHub-配置"><a href="#GitHub-配置" class="headerlink" title="GitHub 配置"></a>GitHub 配置</h3><p>首先在博客所在目录下的 source 目录中（<strong>注意不要放错位置了</strong>），创建一个 CNAME 文件，文件内容就是你的域名，如下：</p><p><img src="http://www.javaboy.org/images/other/23-3.png" alt></p><p>然后执行 <code>hexo d</code> 命令将这个文件上传到 GitHub 就可以了。</p><p>在网上看到有人直接在 GitHub 上配置这个，如下图：</p><p><img src="http://www.javaboy.org/images/other/23-4.png" alt></p><p>这种方式也可以，这种方式会自动生成一个 CNAME 文件到当前仓库中，但是松哥在这里不推荐大家使用这种方式，因为如果你在本地执行了 <code>hexo clean</code> ，然后再去上传，就会丢失掉 CNAME 文件，然后又得重新配置。<strong>关键是当你执行了 <code>hexo clean</code> 之后，你可能还发现不了 CNAME 文件已经丢失了。</strong></p><h3 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h3><p>域名解析这块，当时遇到了一些问题，后来松哥使用了国内的 DNSPod 去做域名解析了，没有使用 godaddy 提供的域名解析。使用 DNSPod 首先要做的，就是修改 godaddy 提供的域名解析服务，登录自己的 godaddy 账号，找到域名管理，修改域名解析服务为 DNSPod ，如下：</p><p><img src="http://www.javaboy.org/images/other/23-5.png" alt></p><p>然后登录到 DNSPod（没有账号注册一个），然后添加自己的域名解析，如下图：</p><p><img src="http://www.javaboy.org/images/other/23-6.png" alt></p><p>添加两条 A 记录，指向 GitHub 的 IP 地址，再添加一条 CNAME ，指向你的 GitHub 域名就可以了。 </p><p>如此之后，大功告成！</p><p><img src="http://www.javaboy.org/images/other/23-7.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，不知道小伙伴们有没有 GET 到呢？这个不用花很多钱，就是一个域名的费用而已（如果你不想用 GitHub 提供的域名的话），也不需要额外买服务器，hexo 的使用也很简单，有兴趣小伙伴赶快实践下吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有不少小伙伴私信松哥，打听松哥的博客是怎么做的，其实这个我之前和大家聊过，今天就再来说一说。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://www.javaboy.org/categories/blog/"/>
    
    
      <category term="blog" scheme="http://www.javaboy.org/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十八)15 道 Spring Boot 高频面试题</title>
    <link href="http://www.javaboy.org/2020/0106/springboot-interview.html"/>
    <id>http://www.javaboy.org/2020/0106/springboot-interview.html</id>
    <published>2020-01-06T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.436Z</updated>
    
    <content type="html"><![CDATA[<p>什么是面霸？就是在面试中，神挡杀神佛挡杀佛，见招拆招，面到面试官自惭形秽自叹不如！松哥希望本文能成为你面霸路上的垫脚石！</p><a id="more"></a><p>做 Java 开发，没有人敢小觑 Spring Boot 的重要性，现在出去面试，无论多小的公司 or 项目，都要跟你扯一扯 Spring Boot，扯一扯微服务，不会？没用过？ Sorry ，我们不合适！</p><p>今天松哥就给大家整理了 15 道高频 Spring Boot 面试题，希望能够帮助到刚刚走出校门的小伙伴以及准备寻找新的工作机会的小伙伴。</p><ul><li>1.什么是 Spring Boot ?</li></ul><p>传统的 SSM/SSH 框架组合配置繁琐臃肿，不同项目有很多重复、模板化的配置，严重降低了 Java 工程师的开发效率，而 Spring Boot 可以轻松创建基于 Spring 的、可以独立运行的、生产级的应用程序。通过对 Spring 家族和一些第三方库提供一系列自动化配置的 Starter，来使得开发快速搭建一个基于 Spring 的应用程序。</p><p>Spring Boot 让日益臃肿的 Java 代码又重回简洁。在配合 Spring Cloud 使用时，还可以发挥更大的威力。</p><ul><li>2.Spring Boot 有哪些特点 ?</li></ul><p>Spring Boot 主要有如下特点：</p><ol><li>为 Spring 开发提供一个更快、更广泛的入门体验。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>绝对没有代码生成，也不需要XML配置。</li></ol><ul><li>3.Spring Boot 中的 starter 到底是什么 ?</li></ul><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。</p><p>当然，开发者也可以自定义 Starter，自定义 Starter 可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486499&amp;idx=2&amp;sn=ce229938f5284e3a43e04e9f84121bd1&amp;chksm=e9c35e43deb4d75571c430f42758930f2e963df4bd692dcbc52beac0c6907f9d172ad533904a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">自定义 Spring Boot 中的 starter</a>。</p><ul><li>4.spring-boot-starter-parent 有什么用 ?</li></ul><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li>定义了 Java 编译版本为 1.8 。</li><li>使用 UTF-8 格式编码。</li><li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li><li>执行打包操作的配置。</li><li>自动化的资源过滤。</li><li>自动化的插件配置。</li><li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li></ol><p>关于这个问题，读者可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486397&amp;idx=2&amp;sn=44f4206b0431e3200fee9a058d6087f8&amp;chksm=e9c359dddeb4d0cbb9fcd7b9c5108a71900dcee28db16c91468797c92ef9678ae7d91da212f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解 spring-boot-starter-parent</a></p><ul><li>5.YAML 配置的优势在哪里 ?</li></ul><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>简洁</li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><p>关于 YAML 配置，要是大家还不熟悉，可以参考: <a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486440&amp;idx=2&amp;sn=51d96a2a11013c38b0756f634005521a&amp;chksm=e9c35988deb4d09eebd49c04088bdf7038035a454c88aaef3c62c23ccc6cef29ffe68f3d93fa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot中的 yaml 配置</a></p><ul><li>6.Spring Boot 中如何解决跨域问题 ?</li></ul><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在则是通过 @CrossOrigin 注解来解决跨域问题。关于 CORS ，小伙伴们可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486714&amp;idx=2&amp;sn=cc5164e4ee779241998c4d4173449bbc&amp;chksm=e9c35e9adeb4d78c89f70a483c4e30ac20bdfcda8715e71bd5b31706e1549eb766550bb620db&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CORS 解决跨域问题</a></p><ul><li>7.比较一下 Spring Security 和 Shiro 各自的优缺点 ?</li></ul><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p><ol><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li>Spring Security 功能强大；Shiro 功能简单</li></ol><ul><li>8.微服务中如何实现 session 共享 ?</li></ul><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。 session 共享大家可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487019&amp;idx=2&amp;sn=2bdb576650d4e493606312544c29d641&amp;chksm=e9c35c4bdeb4d55d29272bf904098345b913f517c07c35cef05c172ae0c440cda1c190b14479&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Session 共享</a></p><ul><li>9.Spring Boot 如何实现热部署 ?</li></ul><p>Spring Boot 实现热部署其实很容易，引入 devtools 依赖即可，这样当编译文件发生变化时，Spring Boot 就会自动重启。在 Eclipse 中，用户按下保存按键，就会自动编译进而重启 Spring Boot，IDEA 中由于是自动保存的，自动保存时并未编译，所以需要开发者按下 Ctrl+F9 进行编译，编译完成后，项目就自动重启了。</p><p>如果仅仅只是页面模板发生变化，Java 类并未发生变化，此时可以不用重启 Spring Boot，使用 LiveReload 插件就可以轻松实现热部署。</p><ul><li>10.Spring Boot 中如何实现定时任务 ?</li></ul><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p><p>关于定时任务这一块，大家可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486770&amp;idx=2&amp;sn=03c4d34b5497b5328444237adf049038&amp;chksm=e9c35f52deb4d6442e007665ca8d48518582c8e22cb229f1fe5b0a467aa9bcf0650f54883aac&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">定时任务的两种实现方式</a></p><ul><li>11.前后端分离，如何维护接口文档 ?</li></ul><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。关于 Swagger 的用法，大家可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486800&amp;idx=2&amp;sn=39965b130bdfc39e66a2d40a84d7ba57&amp;chksm=e9c35f30deb4d62602fd19cb12b8b755cf4be37de3e0510e2a3c7104b01446681355822947bd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringBoot 整合 Swagger2</a></p><ul><li>12.什么是 Spring Data ?</li></ul><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><ol><li>SpringData 项目支持 NoSQL 存储：</li><li>MongoDB （文档数据库）</li><li>Neo4j（图形数据库）</li><li>Redis（键/值存储）</li><li>Hbase（列族数据库）</li></ol><p>SpringData 项目所支持的关系数据存储技术：</p><ol><li>JDBC</li><li>JPA</li></ol><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><ul><li>13.Spring Boot 是否可以使用 XML 配置 ?</li></ul><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><ul><li>14.Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</li></ul><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。具体可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487374&amp;idx=2&amp;sn=e6d50ebecc5ffa67fa0999706729c53c&amp;chksm=e9c35deedeb4d4f8e7b1f9c18122b0c12173323aa5fcd505359fbd66b5bfcf74f3cd601b9f56&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 可执行 jar 分析</a></p><ul><li>15.bootstrap.properties 和 application.properties 有何区别 ?</li></ul><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>bootstrap.properties 在 application.properties 之前加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。bootstrap.properties 被 Spring ApplicationContext 的父类加载，这个类先于加载 application.properties 的 ApplicatonContext 启动。</p><p>当然，前面叙述中的 properties 也可以修改为 yaml 。</p><p>好了，本文就说到这里，欢迎小伙伴留言说说你曾经遇到过的 Spring Boot 面试题！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是面霸？就是在面试中，神挡杀神佛挡杀佛，见招拆招，面到面试官自惭形秽自叹不如！松哥希望本文能成为你面霸路上的垫脚石！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>听说你的 IDEA 昨天掉链子了？松哥给你准备了大招</title>
    <link href="http://www.javaboy.org/2020/0105/idea.html"/>
    <id>http://www.javaboy.org/2020/0105/idea.html</id>
    <published>2020-01-05T01:25:51.000Z</published>
    <updated>2020-01-10T02:05:45.614Z</updated>
    
    <content type="html"><![CDATA[<p>昨天一直在忙，中午抽空瞅了一眼技术群，天呐，竟然都在切磋 IDEA 激活码的事情，瞬间明白可能 jetbrains 又在搞事情了。</p><a id="more"></a><p>我大概了解了下，这次出事的主要是 2019 版，之前的 2018 版没有受影响。</p><p>我也是 2018 版用了好久才切换到 2019 版上面来的，刚用 2019 版的时候还没啥感觉，用久了发现 2019 版确实挺好用的，里边有很多新增的特性，这些我以后可以和大家细细的去聊，这里就不再多说。</p><p>由于国内目前的版权环境，使用正版 IDEA 的小伙伴可能并不多，正版一套其实还是蛮贵的，特别是对于一些学生党来说简直就是天价了，不过 jetbrains 公司还算是比较人性化的，提供了多种免费获取正版授权的方案。</p><p>第一种就是开源项目。如果你有一个不错的开源项目，而且一直在维护，那么你可以向 jetbrains 公司申请全家桶软件的激活码，这就是正儿八经的正版软件了。这条路看着容易，其实对大部分小伙伴来说还是有挺高的门槛的。</p><p>另一个适合在校大学生的方案就是使用一个 edu 邮箱，向 jetbrains 公司申请激活码。因为大部分学校可能都会给学生分配一个 edu 邮箱，用这个邮箱在 jetbrains 官网注册账号，然后就可以轻松获取到一个激活码。</p><p>个人感觉第二种方案其实漏洞比较大，因为获取一个 edu 邮箱太过 easy 了，即使学校不给，作为一个专业的程序员，还是有很多办法获取到一个 edu 邮箱的，我看到群里很多小伙伴都是采用了这种方案解决的。</p><p>不过如果已经工作了，自身条件也允许，其实也可以尝试一下正版 IDEA，毕竟作为一个程序员，应该是能够感受到一个好的 IDE 开发之不易的。</p><p><strong>当然，如果你既没有拿的出手的开源项目，也搞不到 edu 邮箱，不妨在松哥公众号后台回复 idea，看看松哥给你的惊喜。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天一直在忙，中午抽空瞅了一眼技术群，天呐，竟然都在切磋 IDEA 激活码的事情，瞬间明白可能 jetbrains 又在搞事情了。&lt;/p&gt;
    
    </summary>
    
      <category term="idea" scheme="http://www.javaboy.org/categories/idea/"/>
    
    
      <category term="idea" scheme="http://www.javaboy.org/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十七)Spring Boot 开发微信公众号后台(二)</title>
    <link href="http://www.javaboy.org/2020/0105/springboot-weixin.html"/>
    <id>http://www.javaboy.org/2020/0105/springboot-weixin.html</id>
    <published>2020-01-05T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.436Z</updated>
    
    <content type="html"><![CDATA[<p>hello 各位小伙伴，今天我们来继续学习如何通过 Spring Boot 开发微信公众号。还没阅读过上篇文章的小伙伴建议先看看上文，有助于理解本文：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw" target="_blank" rel="noopener">Spring Boot 开发微信公众号后台</a></li></ul><p>上篇文章中我们将微信服务器和我们自己的服务器对接起来了，并且在自己的服务器上也能收到微信服务器发来的消息，本文我们要看的就是如何给微信服务器回复消息。</p><h2 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h2><p>在讨论如何给微信服务器回复消息之前，我们需要先来了解下微信服务器发来的消息主要有哪些类型以及我们回复给微信的消息都有哪些类型。</p><p>在上文中大家了解到，微信发送来的 xml 消息中有一个 MsgType 字段，这个字段就是用来标记消息的类型。这个类型可以标记出这条消息是普通消息还是事件消息还是图文消息等。</p><p>普通消息主要是指：</p><ul><li>文本消息</li><li>图片消息</li><li>语音消息</li><li>视频消息</li><li>小视频消息</li><li>地址位置消息</li><li>链接消息</li></ul><p>不同的消息类型，对应不同的 MsgType，这里我还是以普通消息为例，如下：</p><table><thead><tr><th style="text-align:left">消息类型</th><th style="text-align:left">MsgType</th></tr></thead><tbody><tr><td style="text-align:left">文本消息</td><td style="text-align:left">text</td></tr><tr><td style="text-align:left">图片消息</td><td style="text-align:left">image</td></tr><tr><td style="text-align:left">语音消息</td><td style="text-align:left">voice</td></tr><tr><td style="text-align:left">视频消息</td><td style="text-align:left">video</td></tr><tr><td style="text-align:left">小视频消息</td><td style="text-align:left">shortvideo</td></tr><tr><td style="text-align:left">地址位置消息</td><td style="text-align:left">location</td></tr><tr><td style="text-align:left">链接消息</td><td style="text-align:left">link</td></tr></tbody></table><p>大家千万不要以为不同类型消息的格式是一样的，其实是不一样的，也就是说，MsgType 为 text 的消息和 MsgType 为 image 的消息，微信服务器发给我们的消息内容是不一样的，这样带来一个问题就是我无法使用一个 Bean 去接收不同类型的数据，因此这里我们一般使用 Map 接收即可。</p><p>这是消息的接收，除了消息的接收之外，还有一个消息的回复，我们回复的消息也有很多类型，可以回复普通消息，也可以回复图片消息，回复语音消息等，不同的回复消息我们可以进行相应的封装。因为不同的返回消息实例也是有一些共同的属性的，例如消息是谁发来的，发给谁，消息类型，消息 id 等，所以我们可以将这些共同的属性定义成一个父类，然后不同的消息再去继承这个父类。</p><h2 id="返回消息类型定义"><a href="#返回消息类型定义" class="headerlink" title="返回消息类型定义"></a>返回消息类型定义</h2><p>首先我们来定义一个公共的消息类型：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String ToUserName;</span><br><span class="line">    <span class="hljs-keyword">private</span> String FromUserName;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> CreateTime;</span><br><span class="line">    <span class="hljs-keyword">private</span> String MsgType;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> MsgId;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li>ToUserName 表示开发者的微信号</li><li>FromUserName 表示发送方账号（用户的 OpenID）</li><li>CreateTime 消息的创建时间</li><li>MsgType 表示消息的类型</li><li>MsgId 表示消息 id</li></ul><p>这是我们的基本消息类型，就是说，我们返回给用户的消息，无论是什么类型的消息，都有这几个基本属性。然后在此基础上，我们再去扩展出文本消息、图片消息 等。</p><p>我们来看下文本消息的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String Content;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文本消息在前面消息的基础上多了一个 Content 属性，因此文本消息继承自 BaseMessage ，再额外添加一个 Content 属性即可。</p><p>其他的消息类型也是类似的定义，我就不一一列举了，至于其他消息的格式，大家可以参考微信开放文档（<a href="http://1t.click/aPXK）。" target="_blank" rel="noopener">http://1t.click/aPXK）。</a></p><h2 id="返回消息生成"><a href="#返回消息生成" class="headerlink" title="返回消息生成"></a>返回消息生成</h2><p>消息类型的 Bean 定义完成之后，接下来就是将实体类生成 XML。</p><p>首先我们定义一个消息工具类，将常见的消息类型枚举出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：文本</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_TEXT = <span class="hljs-string">"text"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：音乐</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_MUSIC = <span class="hljs-string">"music"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：图文</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_NEWS = <span class="hljs-string">"news"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：图片</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Image = <span class="hljs-string">"image"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：语音</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Voice = <span class="hljs-string">"voice"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：视频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Video = <span class="hljs-string">"video"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：文本</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_TEXT = <span class="hljs-string">"text"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：图片</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_IMAGE = <span class="hljs-string">"image"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：链接</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_LINK = <span class="hljs-string">"link"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：地理位置</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_LOCATION = <span class="hljs-string">"location"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：音频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_VOICE = <span class="hljs-string">"voice"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：视频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_VIDEO = <span class="hljs-string">"video"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：推送</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_EVENT = <span class="hljs-string">"event"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：subscribe(订阅)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_SUBSCRIBE = <span class="hljs-string">"subscribe"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：unsubscribe(取消订阅)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_UNSUBSCRIBE = <span class="hljs-string">"unsubscribe"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：CLICK(自定义菜单点击事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_CLICK = <span class="hljs-string">"CLICK"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：VIEW(自定义菜单 URl 视图)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_VIEW = <span class="hljs-string">"VIEW"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：LOCATION(上报地理位置事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_LOCATION = <span class="hljs-string">"LOCATION"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：LOCATION(上报地理位置事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_SCAN = <span class="hljs-string">"SCAN"</span>;</span><br></pre></td></tr></table></figure><p>大家注意这里消息类型的定义，以 RESP 开头的表示返回的消息类型，以 REQ 表示微信服务器发来的消息类型。然后在这个工具类中再定义两个方法，用来将返回的对象转换成 XML：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">textMessageToXml</span><span class="hljs-params">(TextMessage textMessage)</span> </span>&#123;</span><br><span class="line">    xstream.alias(<span class="hljs-string">"xml"</span>, textMessage.getClass());</span><br><span class="line">    <span class="hljs-keyword">return</span> xstream.toXML(textMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> XStream xstream = <span class="hljs-keyword">new</span> XStream(<span class="hljs-keyword">new</span> XppDriver() &#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HierarchicalStreamWriter <span class="hljs-title">createWriter</span><span class="hljs-params">(Writer out)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PrettyPrintWriter(out) &#123;</span><br><span class="line">            <span class="hljs-keyword">boolean</span> cdata = <span class="hljs-keyword">true</span>;</span><br><span class="line">            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"rawtypes"</span>)</span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startNode</span><span class="hljs-params">(String name, Class clazz)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">super</span>.startNode(name, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeText</span><span class="hljs-params">(QuickWriter writer, String text)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (cdata) &#123;</span><br><span class="line">                    writer.write(<span class="hljs-string">"&lt;![CDATA["</span>);</span><br><span class="line">                    writer.write(text);</span><br><span class="line">                    writer.write(<span class="hljs-string">"]]&gt;"</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    writer.write(text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>textMessageToXML 方法用来将 TextMessage 对象转成 XML 返回给微信服务器，类似的方法我们还需要定义 imageMessageToXml、voiceMessageToXml 等，不过定义的方式都基本类似，我就不一一列出来了。</p><h2 id="返回消息分发"><a href="#返回消息分发" class="headerlink" title="返回消息分发"></a>返回消息分发</h2><p>由于用户发来的消息可能存在多种情况，我们需要分类进行处理，这个就涉及到返回消息的分发问题。因此我在这里再定义一个返回消息分发的工具类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">processMessage</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        String openid = map.get(<span class="hljs-string">"FromUserName"</span>); <span class="hljs-comment">//用户 openid</span></span><br><span class="line">        String mpid = map.get(<span class="hljs-string">"ToUserName"</span>);   <span class="hljs-comment">//公众号原始 ID</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (map.get(<span class="hljs-string">"MsgType"</span>).equals(MessageUtil.REQ_MESSAGE_TYPE_TEXT)) &#123; </span><br><span class="line">            <span class="hljs-comment">//普通文本消息</span></span><br><span class="line">            TextMessage txtmsg = <span class="hljs-keyword">new</span> TextMessage();</span><br><span class="line">            txtmsg.setToUserName(openid);</span><br><span class="line">            txtmsg.setFromUserName(mpid);</span><br><span class="line">            txtmsg.setCreateTime(<span class="hljs-keyword">new</span> Date().getTime());</span><br><span class="line">            txtmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">            txtmsg.setContent(<span class="hljs-string">"这是返回消息"</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> MessageUtil.textMessageToXml(txtmsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">processEvent</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//在这里处理事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还可以多加几个 elseif 去判断不同的消息类型，我这里因为只有普通文本消息，所以一个 if 就够用了。</p><p>在这里返回值我写死了，实际上这里需要根据微信服务端传来的 Content 去数据中查询，将查询结果返回，数据库查询这一套相信大家都能搞定，我这里就不重复介绍了。</p><p>最后在消息接收 Controller 中调用该方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(value = <span class="hljs-string">"/verify_wx_token"</span>,produces = <span class="hljs-string">"application/xml;charset=utf-8"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handler</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = MessageUtil.parseXml(request);</span><br><span class="line">    String msgType = map.get(<span class="hljs-string">"MsgType"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (MessageUtil.REQ_MESSAGE_TYPE_EVENT.equals(msgType)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageDispatcher.processEvent(map);</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageDispatcher.processMessage(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Controller 中，我们首先判断消息是否是事件，如果是事件，进入到事件处理通道，如果不是事件，则进入到消息处理通道。</p><p><strong>注意，这里需要配置一下返回消息的编码，否则可能会出现中文乱码。</strong></p><p>如此之后，我们的服务器就可以给公众号返回消息了。</p><p>上篇文章发出后，有小伙伴问松哥这个会不会开源，我可以负责任的告诉大家，肯定会开源，这个系列截稿后，我把代码处理下就上传到 GitHub。</p><p>好了，本文我们就先说到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 各位小伙伴，今天我们来继续学习如何通过 Spring Boot 开发微信公众号。还没阅读过上篇文章的小伙伴建议先看看上文，有助于理解本文：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十六)Spring Boot 开发微信公众号后台(一)</title>
    <link href="http://www.javaboy.org/2020/0104/springboot-weixin.html"/>
    <id>http://www.javaboy.org/2020/0104/springboot-weixin.html</id>
    <published>2020-01-04T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.486Z</updated>
    
    <content type="html"><![CDATA[<p>Hello 各位小伙伴，松哥今天要和大家聊一个有意思的话题，就是使用 Spring Boot 开发微信公众号后台。</p><a id="more"></a><p>很多小伙伴可能注意到松哥的个人网站（<a href="http://www.javaboy.org）前一阵子上线了一个公众号内回复口令解锁网站文章的功能，还有之前就有的公众号内回复口令获取超" target="_blank" rel="noopener">http://www.javaboy.org）前一阵子上线了一个公众号内回复口令解锁网站文章的功能，还有之前就有的公众号内回复口令获取超</a> 2TB 免费视频教程的功能（<a href="https://mp.weixin.qq.com/s/yOVbTBVk4CJy6a0lrKjLXA" target="_blank" rel="noopener">免费视频教程</a>），这两个都是松哥基于 Spring Boot 来做的，最近松哥打算通过一个系列的文章，来向小伙伴们介绍下如何通过 Spring Boot 来开发公众号后台。</p><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1. 缘起"></a>1. 缘起</h2><p>今年 5 月份的时候，我想把我自己之前收集到的一些视频教程分享给公众号上的小伙伴，可是这些视频教程大太了，无法一次分享，单次分享分享链接立马就失效了，为了把这些视频分享给大家，我把视频拆分成了很多份，然后设置了不同的口令，小伙伴们在公众号后台通过回复口令就可以获取到这些视频，口令前前后后有 100 多个，我一个一个手动的在微信后台进行配置。这么搞工作量很大，前前后后大概花了三个晚上才把这些东西搞定。</p><p>于是我就在想，该写点代码了。</p><p>上个月买了服务器，也备案了，该有的都有了，于是就打算把这些资源用代码实现下，因为大学时候搞过公众号开发，倒也没什么难度，于是说干就干。</p><h2 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2. 实现思路"></a>2. 实现思路</h2><p>其实松哥这个回复口令获取视频链接的实现原理很简单，说白了，就是一个数据查询操作而已，回复的口令是查询关键字，回复的内容则是查询结果。这个原理很简单。</p><p>另一方面大家需要明白微信公众号后台开发消息发送的一个流程，大家看下面这张图：</p><p><img src="http://www.javaboy.org/images/boot2/46-2.jpeg" alt></p><p>这是大家在公众号后台回复关键字的情况。那么这个消息是怎么样一个传递流程呢？我们来看看下面这张图：</p><p><img src="http://www.javaboy.org/images/boot2/46-1.png" alt></p><p>这张图，我给大家稍微解释下：</p><ol><li>首先 <code>javaboy4096</code> 这个字符从公众号上发送到了微信服务器</li><li>接下来微信服务器会把 <code>javaboy4096</code> 转发到我自己的服务器上</li><li>我收到 <code>javaboy4096</code> 这个字符之后，就去数据库中查询，将查询的结果，按照腾讯要求的 XML 格式进行返回</li><li>微信服务器把从我的服务器收到的信息，再发回到微信上，于是小伙伴们就看到了返回结果了</li></ol><p>大致的流程就是这个样子。</p><p>接下来我们就来看一下实现细节。</p><h2 id="3-公众号后台配置"><a href="#3-公众号后台配置" class="headerlink" title="3. 公众号后台配置"></a>3. 公众号后台配置</h2><p>开发的第一步，是微信服务器要验证我们自己的服务器是否有效。</p><p>首先我们登录微信公众平台官网后，在公众平台官网的 <strong>开发-基本设置</strong> 页面，勾选协议成为开发者，然后点击“修改配置”按钮，填写：</p><ul><li>服务器地址（URL）</li><li>Token</li><li>EncodingAESKey</li></ul><p><img src="http://www.javaboy.org/images/boot2/46-3.jpeg" alt></p><p>这里的 URL 配置好之后，我们需要针对这个 URL 开发两个接口，一个是 GET 请求的接口，这个接口用来做服务器有效性验证，另一个则是 POST 请求的接口，这个用来接收微信服务器发送来的消息。也就是说，微信服务器的消息都是通过 POST 请求发给我的。</p><p>Token 可由开发者可以任意填写，用作生成签名（该 Token 会和接口 URL 中包含的 Token 进行比对，从而验证安全性）。</p><p>EncodingAESKey 由开发者手动填写或随机生成，将用作消息体加解密密钥。</p><p>同时，开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。明文模式就是我们自己的服务器收到微信服务器发来的消息是明文字符串，直接就可以读取并且解析，安全模式则是我们收到微信服务器发来的消息是加密的消息，需要我们手动解析后才能使用。</p><h2 id="4-开发"><a href="#4-开发" class="headerlink" title="4. 开发"></a>4. 开发</h2><p>公众号后台配置完成后，接下来我们就可以写代码了。</p><h3 id="4-1-服务器有效性校验"><a href="#4-1-服务器有效性校验" class="headerlink" title="4.1 服务器有效性校验"></a>4.1 服务器有效性校验</h3><p>我们首先来创建一个普通的 Spring Boot 项目，创建时引入 <code>spring-boot-starter-web</code> 依赖，项目创建成功后，我们创建一个 Controller ，添加如下接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/verify_wx_token"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    String signature = request.getParameter(<span class="hljs-string">"signature"</span>);</span><br><span class="line">    String timestamp = request.getParameter(<span class="hljs-string">"timestamp"</span>);</span><br><span class="line">    String nonce = request.getParameter(<span class="hljs-string">"nonce"</span>);</span><br><span class="line">    String echostr = request.getParameter(<span class="hljs-string">"echostr"</span>);</span><br><span class="line">    PrintWriter out = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        out = response.getWriter();</span><br><span class="line">        <span class="hljs-keyword">if</span> (CheckUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">            out.write(echostr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这段代码，我做如下解释：</p><ol><li>首先通过 request.getParameter 方法获取到微信服务器发来的 signature、timestamp、nonce 以及 echostr 四个参数，这四个参数中：signature 表示微信加密签名，signature 结合了开发者填写的 token 参数和请求中的timestamp参数、nonce参数；timestamp 表示时间戳；nonce    表示随机数；echostr    则表示一个随机字符串。</li><li>开发者通过检验 signature 对请求进行校验，如果确认此次 GET 请求来自微信服务器，则原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。</li><li>具体的校验就是松哥这里的 CheckUtil.checkSignature 方法，在这个方法中，首先将token、timestamp、nonce 三个参数进行字典序排序，然后将三个参数字符串拼接成一个字符串进行 sha1 加密，最后开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信。</li></ol><p>校验代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckUtil</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String token = <span class="hljs-string">"123456"</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkSignature</span><span class="hljs-params">(String signature, String timestamp, String nonce)</span> </span>&#123;</span><br><span class="line">        String[] str = <span class="hljs-keyword">new</span> String[]&#123;token, timestamp, nonce&#125;;</span><br><span class="line">        <span class="hljs-comment">//排序</span></span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        <span class="hljs-comment">//拼接字符串</span></span><br><span class="line">        StringBuffer buffer = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            buffer.append(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//进行sha1加密</span></span><br><span class="line">        String temp = SHA1.encode(buffer.toString());</span><br><span class="line">        <span class="hljs-comment">//与微信提供的signature进行匹对</span></span><br><span class="line">        <span class="hljs-keyword">return</span> signature.equals(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SHA1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] HEX_DIGITS = &#123;<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>,</span><br><span class="line">            <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>&#125;;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getFormattedText</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = bytes.length;</span><br><span class="line">        StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(len * <span class="hljs-number">2</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            buf.append(HEX_DIGITS[(bytes[j] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>]);</span><br><span class="line">            buf.append(HEX_DIGITS[bytes[j] &amp; <span class="hljs-number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encode</span><span class="hljs-params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string">"SHA1"</span>);</span><br><span class="line">            messageDigest.update(str.getBytes());</span><br><span class="line">            <span class="hljs-keyword">return</span> getFormattedText(messageDigest.digest());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，完成之后，我们的校验接口就算是开发完成了。接下来就可以开发消息接收接口了。</p><h3 id="4-2-消息接收接口"><a href="#4-2-消息接收接口" class="headerlink" title="4.2 消息接收接口"></a>4.2 消息接收接口</h3><p>接下来我们来开发消息接收接口，消息接收接口和上面的服务器校验接口地址是一样的，都是我们一开始在公众号后台配置的地址。只不过消息接收接口是一个 POST 请求。</p><p>我在公众号后台配置的时候，消息加解密方式选择了明文模式，这样我在后台收到的消息直接就可以处理了。微信服务器给我发来的普通文本消息格式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">xml</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">CreateTime</span>&gt;</span>1348831860<span class="hljs-tag">&lt;/<span class="hljs-name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span>&lt;![CDATA[this is a test]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">MsgId</span>&gt;</span>1234567890123456<span class="hljs-tag">&lt;/<span class="hljs-name">MsgId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些参数含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ToUserName</td><td style="text-align:left">开发者微信号</td></tr><tr><td style="text-align:left">FromUserName</td><td style="text-align:left">发送方帐号（一个OpenID）</td></tr><tr><td style="text-align:left">CreateTime</td><td style="text-align:left">消息创建时间 （整型）</td></tr><tr><td style="text-align:left">MsgType</td><td style="text-align:left">消息类型，文本为text</td></tr><tr><td style="text-align:left">Content</td><td style="text-align:left">文本消息内容</td></tr><tr><td style="text-align:left">MsgId</td><td style="text-align:left">消息id，64位整型</td></tr></tbody></table><p>看到这里，大家心里大概就有数了，当我们收到微信服务器发来的消息之后，我们就进行 XML 解析，提取出来我们需要的信息，去做相关的查询操作，再将查到的结果返回给微信服务器。</p><p>这里我们先来个简单的，我们将收到的消息解析并打印出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/verify_wx_token"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    Map&lt;String, String&gt; parseXml = MessageUtil.parseXml(request);</span><br><span class="line">    String msgType = parseXml.get(<span class="hljs-string">"MsgType"</span>);</span><br><span class="line">    String content = parseXml.get(<span class="hljs-string">"Content"</span>);</span><br><span class="line">    String fromusername = parseXml.get(<span class="hljs-string">"FromUserName"</span>);</span><br><span class="line">    String tousername = parseXml.get(<span class="hljs-string">"ToUserName"</span>);</span><br><span class="line">    System.out.println(msgType);</span><br><span class="line">    System.out.println(content);</span><br><span class="line">    System.out.println(fromusername);</span><br><span class="line">    System.out.println(tousername);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; <span class="hljs-title">parseXml</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    InputStream inputStream = request.getInputStream();</span><br><span class="line">    SAXReader reader = <span class="hljs-keyword">new</span> SAXReader();</span><br><span class="line">    Document document = reader.read(inputStream);</span><br><span class="line">    Element root = document.getRootElement();</span><br><span class="line">    List&lt;Element&gt; elementList = root.elements();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Element e : elementList)</span><br><span class="line">        map.put(e.getName(), e.getText());</span><br><span class="line">    inputStream.close();</span><br><span class="line">    inputStream = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到其实都是一些常规代码，没有什么难度。</p><p>做完这些之后，我们将项目打成 jar 包在服务器上部署启动。启动成功之后，确认微信的后台配置也没问题，我们就可以在公众号上发一条消息了，这样我们自己的服务端就会打印出来刚刚消息的信息。</p><p>好了，篇幅限制，今天就和大家先聊这么多，后面再聊不同消息类型的解析和消息的返回问题。</p><p>不知道小伙伴们看懂没？有问题欢迎留言讨论。</p><p>参考资料：微信开放文档</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hello 各位小伙伴，松哥今天要和大家聊一个有意思的话题，就是使用 Spring Boot 开发微信公众号后台。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>2019 原创技术干货整理</title>
    <link href="http://www.javaboy.org/2020/0103/2019-article.html"/>
    <id>http://www.javaboy.org/2020/0103/2019-article.html</id>
    <published>2020-01-03T01:25:37.000Z</published>
    <updated>2020-01-10T02:05:01.448Z</updated>
    
    <content type="html"><![CDATA[<p>公众号的文章改整理一下了，老有小伙伴表示文章找不到，确实是这样，公众号的文章看过了没消化，后来再想找到有点难，有的小伙伴机智的收藏了一下，但是因为收藏夹里的东西太多了，后来还是不好找。</p><a id="more"></a><p>其实松哥公众号上的文章，大家都可以直接在松哥博客上搜索，博客右上角有一个搜索功能：</p><p><img src="http://www.javaboy.org/images/other/104-1.png" alt></p><p>好了，今天我就把 2019 年公众号上的原创干货整理出来，做成索引，方便小伙伴们查找。</p><h2 id="Spring-Boot-系列"><a href="#Spring-Boot-系列" class="headerlink" title="Spring Boot 系列"></a>Spring Boot 系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/DSbR-0Mi6fRGgPQSnL47Pg" target="_blank" rel="noopener">纯 Java 搭建 SSM 项目</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486390&amp;idx=2&amp;sn=351d689ae8e541915ab7c8fcbdb45793&amp;chksm=e9c359d6deb4d0c0afdffa191895bb09adec55625945e3f05c7a4f1528636f86915b493d5ef8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">创建 Spring Boot 项目的三种方式</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486397&amp;idx=2&amp;sn=44f4206b0431e3200fee9a058d6087f8&amp;chksm=e9c359dddeb4d0cbb9fcd7b9c5108a71900dcee28db16c91468797c92ef9678ae7d91da212f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解 spring-boot-starter-parent</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486427&amp;idx=2&amp;sn=91c4462d44f3866bc9ee4cc71feb4e89&amp;chksm=e9c359bbdeb4d0ada43758582d061da9282bb31d6911eb9aada36e61cd70c841426154549665&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解配置文件 application.properties ！</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486440&amp;idx=2&amp;sn=51d96a2a11013c38b0756f634005521a&amp;chksm=e9c35988deb4d09eebd49c04088bdf7038035a454c88aaef3c62c23ccc6cef29ffe68f3d93fa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot中的 yaml 配置</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486499&amp;idx=2&amp;sn=ce229938f5284e3a43e04e9f84121bd1&amp;chksm=e9c35e43deb4d75571c430f42758930f2e963df4bd692dcbc52beac0c6907f9d172ad533904a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">自定义 Spring Boot 中的 starter</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486535&amp;idx=2&amp;sn=2a0c95e2c10ff2d3dea883a4d0352da9&amp;chksm=e9c35e27deb4d73116f17a5105ae40dd08e25dc3393e916b270683d46f459938f263b966bdc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解自动化配置的原理</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486559&amp;idx=2&amp;sn=8a78f43c2ba9d820011ec1f953b1e9d0&amp;chksm=e9c35e3fdeb4d7292592937036e5835dbd5d4eb7c81ebc15c84b5c87950d7ccf2d9d21f24ee5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中配置 Https</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486582&amp;idx=2&amp;sn=ad1c5eac40c85b54e7545a382450a640&amp;chksm=e9c35e16deb4d700e3c3913ab1c890ad8020027113e1bfdf37578bee1e40d5e8fe03a657b780&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Thymeleaf</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486670&amp;idx=2&amp;sn=3f7d624d4dd0c3cef09c24a7616845d4&amp;chksm=e9c35eaedeb4d7b85a1e52249522fa997b3d8cdd975b8bc5fdfeefcc30ce0136867f9c1dd1cb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Freemarker</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486682&amp;idx=2&amp;sn=c3c203a006e19a18b09f768073fd37c4&amp;chksm=e9c35ebadeb4d7acb85b14f1ede981a3a212c5051164022a46cc529939051f0651aa1d0a36fd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中的静态资源配置</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486694&amp;idx=2&amp;sn=8f5b293ab5707b97ef16ddf553575b82&amp;chksm=e9c35e86deb4d7909ea7adf3a0b0507204a900088e4ec56a5efc0392f9948d660e4f29e31eb0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">@ControllerAdvice 的三种使用场景</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486703&amp;idx=2&amp;sn=3a61e9b2a9a4d2c0a6925958b6818a26&amp;chksm=e9c35e8fdeb4d7993e4ccc72565dfabf973b6b7b26acb849449504163be95ac9a89ad180b287&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中的全局异常处理</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486714&amp;idx=2&amp;sn=cc5164e4ee779241998c4d4173449bbc&amp;chksm=e9c35e9adeb4d78c89f70a483c4e30ac20bdfcda8715e71bd5b31706e1549eb766550bb620db&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CORS 解决跨域问题</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486744&amp;idx=2&amp;sn=14b4eb78b9ef8b3528a305619a5f9a66&amp;chksm=e9c35f78deb4d66e61e3dfd91943a872ba8a2afbc5e41582c9b4414f5bc2fb9fd06ca7c6c4ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">定义系统启动任务的两种方式</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486770&amp;idx=2&amp;sn=03c4d34b5497b5328444237adf049038&amp;chksm=e9c35f52deb4d6442e007665ca8d48518582c8e22cb229f1fe5b0a467aa9bcf0650f54883aac&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">定时任务的两种实现方式</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486800&amp;idx=2&amp;sn=39965b130bdfc39e66a2d40a84d7ba57&amp;chksm=e9c35f30deb4d62602fd19cb12b8b755cf4be37de3e0510e2a3c7104b01446681355822947bd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringBoot 整合 Swagger2</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486819&amp;idx=2&amp;sn=38914644e5fb688d9bf662e112f90aad&amp;chksm=e9c35f03deb4d615e7ddff95a3fccfafaeda21d5a05605de526f31f75faa0ba458200936c501&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中自定义 SpringMVC 配置</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486840&amp;idx=2&amp;sn=5d4f75a81b3d8eb02f288a92015f247c&amp;chksm=e9c35f18deb4d60eba6a3ecbe886999ef6c284ea3afce9f0f0b06a93def0dfc00ffc116f4d8b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 JdbcTemplate</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486879&amp;idx=2&amp;sn=16df1ab5688b6df3f4ae59ffa685e00a&amp;chksm=e9c35fffdeb4d6e994d15d66af1d2ab59f491c1dbe99932f4584ed025947ed1ae176b6226720&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合JdbcTemplate 多数据源</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486904&amp;idx=2&amp;sn=8168bef3766c91d65838bb2708d051cc&amp;chksm=e9c35fd8deb4d6ce4533758b6c9871a81dcfd045382623bcc1a593b8c23aacfc9440ff0e984d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">整合 MyBatis</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486912&amp;idx=3&amp;sn=425b82e363554a3fdb89cd955044a314&amp;chksm=e9c35fa0deb4d6b630a0b875cbf923b7c2e64313b74d1d827ebcdbb4cd85839e5f83e789df0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">整合 MyBatis 多数据源</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486935&amp;idx=2&amp;sn=dc8d2596d9238f27db47c7e74696bd76&amp;chksm=e9c35fb7deb4d6a1e5ccd9d6e7f4326a241c849a555b2e4c8c30a75cb902ba283460a12fb5c1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解 Spring Data Jpa</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486959&amp;idx=2&amp;sn=9d29a875d4d475267a9b7855544bdbca&amp;chksm=e9c35f8fdeb4d6991f8f89fb065be43d48f5949a26c892c3ef2a13606cf6f79e7e63b735fdc4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Redis</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486982&amp;idx=2&amp;sn=ca166f7b88d7c8e3aa16aa3742e8d2ef&amp;chksm=e9c35c66deb4d5705ed48d8d2234e38148e6a71f613e90a6fd6f93bb29aaa9be42db488c3f83&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Nginx 极简扫盲入门</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487019&amp;idx=2&amp;sn=2bdb576650d4e493606312544c29d641&amp;chksm=e9c35c4bdeb4d55d29272bf904098345b913f517c07c35cef05c172ae0c440cda1c190b14479&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Session 共享</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487052&amp;idx=2&amp;sn=21806ea097f28e30bd1ec15fb7d0ee44&amp;chksm=e9c35c2cdeb4d53a185b4a444b9c8c82f5724730ba990dca1f1c7906ac3a1461944c193e1969&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Redis</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487066&amp;idx=2&amp;sn=1e411c6543c1dbf9f80219a0db6203a4&amp;chksm=e9c35c3adeb4d52cb298a79344dec218071f429624181b6d4d603519cefbd878d5c45bb40679&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Ehcache</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487103&amp;idx=2&amp;sn=6b83609faf02d0a2a6e153c7db78a3ad&amp;chksm=e9c35c1fdeb4d5098bbc1c4093aff970dd303e3e8c7edaa5d514cfa454973a5ca3ceaa0c7bdd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 构建 RESTful 风格应用</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487130&amp;idx=2&amp;sn=5cf21ef43cc34c572a05eda61907e310&amp;chksm=e9c35cfadeb4d5ecd1be5913e366f62e7f651c4d15805641cdea9db05e3580d5e284f14edb0a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Shiro</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487146&amp;idx=3&amp;sn=ccd3d37ac7678821c9308453a6eb7f16&amp;chksm=e9c35ccadeb4d5dc2faae80c78852233735a924b0c31c8a64403b4f5fbe2df56d3adc3f5eb6d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">整合 Spring Security</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487167&amp;idx=2&amp;sn=21ca4e87814086580fbf2fd2c3ea00c7&amp;chksm=e9c35cdfdeb4d5c98730cba97f2e50fc8e3b151b48811f7f11eefa39049e4ff4626122e7c75d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Security 添加验证码</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487212&amp;idx=2&amp;sn=54d59ea55f7f9df6c7dbd0be3849ae65&amp;chksm=e9c35c8cdeb4d59ab5f26df6f389a81e4d0029a943e0aedce010716147ac6dd4b5338f6ba778&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringSecurity 使用 JSON 格式登录</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487219&amp;idx=2&amp;sn=5a90dde59f21b1ee036488350edc8c6d&amp;chksm=e9c35c93deb4d5851dd345c53c614278c0e5549c65f1db3df8088d1b407cc860952c62970ff1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringSecurity 中角色继承的坑</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487270&amp;idx=2&amp;sn=dcc3bb1660145cb2ff3ce3cecd85b012&amp;chksm=e9c35d46deb4d4500f2b918ec0d5168f4e6fe929d71be094ff5568c43d1135aad570021adb2d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Security 整合 JWT</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487283&amp;idx=2&amp;sn=1cf5dddbed5c0ea728f44fcf17e1d375&amp;chksm=e9c35d53deb4d445f38d1bcd509bbcd00f6950da83384013b2ded615ae1eed104affb264d2e7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Security 非法请求直接返回 JSON</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487291&amp;idx=2&amp;sn=d8f0b196710a06c2deb04b0d569f29cd&amp;chksm=e9c35d5bdeb4d44dd479f3f6c234110b6d7a61930382a8e7ff3da7acd594da68dfbc35afaa8d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 热部署</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487374&amp;idx=2&amp;sn=e6d50ebecc5ffa67fa0999706729c53c&amp;chksm=e9c35deedeb4d4f8e7b1f9c18122b0c12173323aa5fcd505359fbd66b5bfcf74f3cd601b9f56&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 可执行 jar 分析</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487418&amp;idx=2&amp;sn=f4afea6e7b2cf33e00819dbe54bf82ed&amp;chksm=e9c35ddadeb4d4cc10198f3c02ed4c4321c6eeac82991138f87a9d24dd8e6473c92e2113dca0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">部署 Spring Boot 到远程 Docker 容器</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487440&amp;idx=2&amp;sn=91e352ab638a63cbc126f011b4de923d&amp;chksm=e9c35db0deb4d4a668155ad4fd07004da5cb33b8a6518b3c1440973b1eacfa3d3d708d5ec101&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">使用 Jib 部署 Spring Boot</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487459&amp;idx=2&amp;sn=6d1405b414e1787d3fa08806ae096fd2&amp;chksm=e9c35d83deb4d4956f03d9e262f22f5499174db8cea3e0bb78fcff3dc260e1d4dc325fa6f6df&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 邮件发送的 5 种姿势</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487506&amp;idx=2&amp;sn=6b269e8f2c37ea55ea09850afe1f84b1&amp;chksm=e9c34272deb4cb641a2349b8ce7c43c59f33370ddcc67670648b3d468efa77bd0dac746a2922&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Session 中的 Bug</a></li><li><a href="https://mp.weixin.qq.com/s/kJou5tMWuMZpbrtGoaLrdg" target="_blank" rel="noopener">Spring Boot 2.2.0 中的 Bug</a></li><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw" target="_blank" rel="noopener">Spring Boot 开发微信公众号（一）</a></li><li><a href="https://mp.weixin.qq.com/s/1jTl9kBeFeibjbe5EbsCzg" target="_blank" rel="noopener">Spring Boot 开发微信公众号（二）</a></li><li><a href="https://mp.weixin.qq.com/s/deUN4S34y6xwaWnY4Y4jpg" target="_blank" rel="noopener">15 道 Spring Boot 面试题</a></li></ol><h2 id="前后端分离系列"><a href="#前后端分离系列" class="headerlink" title="前后端分离系列"></a>前后端分离系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/HWRYAR16vLE1XFep6_i1tA" target="_blank" rel="noopener">一个Java程序猿眼中的前后端分离以及Vue.js入门</a></li><li><a href="https://mp.weixin.qq.com/s/Qbqvlo7ftbyP6dnbuUcxrw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离，两种文件上传方式总结！</a></li><li><a href="https://mp.weixin.qq.com/s/K8ANNmm6ZrP2xMyK6LGZ_g" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，前端网络请求封装与配置</a></li><li><a href="https://mp.weixin.qq.com/s/5GsOO4QK9AnR0K6FdZixOw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，权限管理的一点思路</a></li><li><a href="https://mp.weixin.qq.com/s/f5kZM3TVZzdv1tI0THjnIg" target="_blank" rel="noopener">前后端分离时代，Java 程序员的变与不变！</a></li><li><a href="https://mp.weixin.qq.com/s/szgfT3tnYMCHSeiE3_QnpA" target="_blank" rel="noopener">学艺不精，总是掉坑！前后端分离历险记</a></li><li><a href="https://mp.weixin.qq.com/s/C7PIck3SIPPTcA3NX3ELoQ" target="_blank" rel="noopener">使用 Nginx 部署前后端分离项目，解决跨域问题</a></li><li><a href="https://mp.weixin.qq.com/s/GvqLzCZngQiMqVE_ZTafeA" target="_blank" rel="noopener">喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了</a></li><li><a href="https://mp.weixin.qq.com/s/NV7pRVnR6sLSjI2Snjl_aQ" target="_blank" rel="noopener">前后端分离开发中动态菜单的两种实现方案</a></li><li><a href="https://mp.weixin.qq.com/s/wwZDx4sRbXjVJPqccRcJvg" target="_blank" rel="noopener">前后端分离，我怎么就选择了 Spring Boot + Vue 技术栈？</a></li></ol><h2 id="MySQL-系列"><a href="#MySQL-系列" class="headerlink" title="MySQL 系列"></a>MySQL 系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/_lsNyXHrsu131mHONQi5rg" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(一)</a></li><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li><li><a href="https://mp.weixin.qq.com/s/xVJjsONasLroJrAGEiuitw" target="_blank" rel="noopener">借力 Docker ，三分钟搞定 MySQL 主从复制！</a></li><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li><li><a href="https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ" target="_blank" rel="noopener">What？Tomcat 竟然也算中间件？</a></li><li><a href="https://mp.weixin.qq.com/s/qWf5XZzhgpSuIGpE2T6iJg" target="_blank" rel="noopener">分布式数据库中间件 MyCat 搞起来！</a></li><li><a href="https://mp.weixin.qq.com/s/4DvKAKiG2sFe_vEQ0mUkeQ" target="_blank" rel="noopener">数据库分库分表，分片配置轻松入门！</a></li><li><a href="https://mp.weixin.qq.com/s/oNsTcrWCjntQefD2B0sq1A" target="_blank" rel="noopener">分布式数据库如何实现主键全局自增？</a></li><li><a href="https://mp.weixin.qq.com/s/OZ0Uqv7UCiyhhRurNdVi4A" target="_blank" rel="noopener">给数据库减负的八个思路</a></li><li><a href="https://mp.weixin.qq.com/s/3eCXo2XhhgT5ZTia3mGbKQ" target="_blank" rel="noopener">MyBatis 中 @Param 注解的四种使用场景，最后一种经常被人忽略！</a></li><li><a href="https://mp.weixin.qq.com/s/-CPpM0xPbqip6Zx6TKzCDQ" target="_blank" rel="noopener">MyBatis中主键回填的两种实现方式</a></li></ol><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ol><li><a href="https://mp.weixin.qq.com/s/Lr5CwOSqYvx-JrFCSGf_Dw" target="_blank" rel="noopener">起早贪黑几个月，我写完了人生第一本书！</a></li><li><a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a></li><li><a href="https://mp.weixin.qq.com/s/wLSM1bHK4-rjOa3WuS46CQ" target="_blank" rel="noopener">一个野生程序员的自我修养</a></li><li><a href="https://mp.weixin.qq.com/s/IJZukUhu-Rec8lF9KQseoQ" target="_blank" rel="noopener">我的第一本书，被选作大学教材了！</a></li><li><a href="https://mp.weixin.qq.com/s/Zx4jiw5QVv3CBa87_K9_Gw" target="_blank" rel="noopener">一个转行程序员的买房经历</a></li><li><a href="https://mp.weixin.qq.com/s/2tSD3U2nmIR-7L-U0sTtUQ" target="_blank" rel="noopener">当公司倒闭时，我在干什么？</a></li><li><a href="https://mp.weixin.qq.com/s/u00E39EyalzRBere_5kpOA" target="_blank" rel="noopener">跟着平台混了四年，现在要单飞了！</a></li><li><a href="https://mp.weixin.qq.com/s/d4x-kNNTfXOh9AODe0Pzzg" target="_blank" rel="noopener">每次回西安，都会动摇我继续留在深圳的决心</a></li><li><a href="https://mp.weixin.qq.com/s/BRQl02_a1FVDXckXjFsJ5Q" target="_blank" rel="noopener">1024，20个入行故事，浮世中见证着程序员的奋斗</a></li><li><a href="https://mp.weixin.qq.com/s/CGK8Labju1CjdkI3omgz-g" target="_blank" rel="noopener">搬砖不易，和大家聊聊松哥经历过的两次裁员</a></li><li><a href="https://mp.weixin.qq.com/s/Jchy_VCMPeCjpKQsfW8k-Q" target="_blank" rel="noopener">华为云 open day，带你看看别人家的公司</a></li></ol><h2 id="系列教程"><a href="#系列教程" class="headerlink" title="系列教程"></a>系列教程</h2><ol><li><a href="https://mp.weixin.qq.com/s/CyMXvY-IzY-69Q_uYxxXMA" target="_blank" rel="noopener">Maven 入门，Maven + IDEA 创建多模块项目，松哥手敲了 30 多页教程给大家送来了</a></li><li><a href="https://mp.weixin.qq.com/s/4N0qWTHM2CuUFRoBIBUHwQ" target="_blank" rel="noopener">来了，松哥纯手工打造的超 50 页 Spring 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/4v7VPjSjf5DW86I3ecptFw" target="_blank" rel="noopener">来了，松哥纯手工打造 80 多页的 SpringMVC 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/sf_ZtaZllP4RdyftZghoHQ" target="_blank" rel="noopener">MyBatis 教程来啦，松哥手码的 SSM 教程总算齐活了，小伙伴们可以下载啦</a></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><a href="https://mp.weixin.qq.com/s/XiUUgFvUQ3y8FUDSXbhEKA" target="_blank" rel="noopener">2019 Java 全栈工程师进阶路线图，一定要收藏！</a></li><li><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">快来！松哥的免费资源库更新啦！</a></li><li><a href="https://mp.weixin.qq.com/s/6PPYwrNestz-gvmB4ZkAqQ" target="_blank" rel="noopener">两步解决maven依赖导入失败问题</a></li><li><a href="https://mp.weixin.qq.com/s/3kyaY0bwoZw3D_big2F11A" target="_blank" rel="noopener">小程序开发框架WePY和mpvue使用感受</a></li><li><a href="https://mp.weixin.qq.com/s/g6D5b_YilzLeBH3pdjRnww" target="_blank" rel="noopener">干货|6个牛逼的基于Vue.js的后台控制面板，接私活必备</a></li><li><a href="https://mp.weixin.qq.com/s/CDnUVdktu1OKiR1HxFwv3Q" target="_blank" rel="noopener">Jpa VS MyBatis，你用哪个？</a></li><li><a href="https://mp.weixin.qq.com/s/HLP_9tyh_uU6XU5zJtks2A" target="_blank" rel="noopener">SpringMVC 方法三种类型返回值总结，你用过几种？</a></li><li><a href="https://mp.weixin.qq.com/s/rQGOyistMMz-X3kI0x21gQ" target="_blank" rel="noopener">天呐，我的服务器竟然也被黑客攻击了！</a></li><li><a href="https://mp.weixin.qq.com/s/OCMea0O_ussoGpMSb3R1oA" target="_blank" rel="noopener">Java 开发中到底该不该用 Lombok？</a></li><li><a href="https://mp.weixin.qq.com/s/_M0oqA9H4DXvB0xdgHjPGw" target="_blank" rel="noopener">想让自己的项目6666，可是 Chrome 不答应！</a></li><li><a href="https://mp.weixin.qq.com/s/MUPcD_-7NMF32tFLj9zhFQ" target="_blank" rel="noopener">天天吹微服务，单体应用有啥不好？</a></li><li><a href="https://mp.weixin.qq.com/s/KxyxlZoZpRWrbK3FJ7lAGA" target="_blank" rel="noopener">身边的人都说微服务好，好在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/pGpRXFqIJN7IhQ5qyNPmRw" target="_blank" rel="noopener">IDEA 神器入坑指南！17 个常用快捷键奉上！</a></li><li><a href="https://mp.weixin.qq.com/s/BwI8q9Cj3BfCbVUURc9DlA" target="_blank" rel="noopener">Spring 中用 XML 装配 Bean，竟然有五种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/PbFyhErajZoQPJ_G3osJeQ" target="_blank" rel="noopener">浏览 GitHub 太卡了？教你两招！</a></li><li><a href="https://mp.weixin.qq.com/s/yhDqHfbWJmRlPR0Nt1UUyg" target="_blank" rel="noopener">原创的离线版 Redis 教程，给力！</a></li><li><a href="https://mp.weixin.qq.com/s/F2jee_Y7J7lrOHfyXBBSvw" target="_blank" rel="noopener">微人事 star 数超 10k 啦！聊聊如何打造一个 star 数超 10k 的开源项目</a></li><li><a href="https://mp.weixin.qq.com/s/T_GIavgSPQBoJGqZ-2PJVQ" target="_blank" rel="noopener">晚十点半之前下班是耻辱？老板干嘛老爱和员工谈创业精神？</a></li><li><a href="https://mp.weixin.qq.com/s/9aMRFEXbh0-usVE96uZ8Ag" target="_blank" rel="noopener">学 Maven，看松哥这一篇就够了</a></li><li><a href="https://mp.weixin.qq.com/s/PZA4IjqXpQt1TWlCWguyvQ" target="_blank" rel="noopener">学习 Spring，看松哥这篇万余字的干货，够用了！</a></li><li><a href="https://mp.weixin.qq.com/s/Eo2RRB6zKQuPDMWlnCHDrw" target="_blank" rel="noopener">两年了，微人事项目迎来了一次重大更新</a></li><li><a href="https://mp.weixin.qq.com/s/7rvGBlfYie9A_4_J1uoqpg" target="_blank" rel="noopener">跟松哥学 SpringMVC（1/2）</a></li><li><a href="https://mp.weixin.qq.com/s/yNFFDWa8srJL0ArRE4H0oA" target="_blank" rel="noopener">跟松哥学 SpringMVC（2/2）</a></li></ol><h2 id="视频干货"><a href="#视频干货" class="headerlink" title="视频干货"></a>视频干货</h2><ol><li><a href="https://mp.weixin.qq.com/s/qN01Le434FWom0c3jqiQmA" target="_blank" rel="noopener">为了帮助前后端分离的新手，我做了一次大胆的尝试！</a></li><li><a href="https://mp.weixin.qq.com/s/sgjm09_e8ue5blXqPgeXZA" target="_blank" rel="noopener">说出来你可能不信，Spring Boot 中 Session 共享不超过 5 行代码！</a></li><li><a href="https://mp.weixin.qq.com/s/1rVPzJGCtDZKvMoA4BYzIA" target="_blank" rel="noopener">Spring Boot 整合 OAuth2，松哥手把手教你！</a></li><li><a href="https://mp.weixin.qq.com/s/Rrj7oco3K8kJBsTxEEdz9g" target="_blank" rel="noopener">Spring Boot 结合 WebSocket 实现在线聊天</a></li><li><a href="https://mp.weixin.qq.com/s/Sn59dxwtsEWoj2wdynQuRQ" target="_blank" rel="noopener">Spring Security 结合 Jwt 实现无状态登录</a></li><li><a href="https://mp.weixin.qq.com/s/qxMkC6H4XfCT4LqMrYtgsQ" target="_blank" rel="noopener">手把手教你 Spring Boot 整合 Spring Data Jpa</a></li><li><a href="https://mp.weixin.qq.com/s/OMgoUfH8lk8hDfuqWXGWTA" target="_blank" rel="noopener">Spring Boot + Vue，手把手教你做文件上传</a></li><li><a href="https://mp.weixin.qq.com/s/eun-ChD5KyN6LsbR9qFfiQ" target="_blank" rel="noopener">使用 Spring Security 实现微人事前后端分离登录接口</a></li><li><a href="https://mp.weixin.qq.com/s/rH5MeKuTnXbyaDaGsU4wNw" target="_blank" rel="noopener">Spring Boot 在后端如何控制前端 Vue 中菜单动态加载？</a></li><li><a href="https://mp.weixin.qq.com/s/7KftnJRj-3xnB3Eo-eUhbw" target="_blank" rel="noopener">手把手教你 Spring Boot 整合 Redis</a></li><li><a href="https://mp.weixin.qq.com/s/FoNVyAR1BkYfutFq9sjJNQ" target="_blank" rel="noopener">新版微人事部署教程来啦</a></li></ol><h2 id="优质投稿"><a href="#优质投稿" class="headerlink" title="优质投稿"></a>优质投稿</h2><ol><li><a href="https://mp.weixin.qq.com/s/Tup0cP2ZCdzodD8790Hr1w" target="_blank" rel="noopener">Spring Security 工作原理概览</a></li><li><a href="https://mp.weixin.qq.com/s/_szH8aN6HDR_1Z5Nyu4pmA" target="_blank" rel="noopener">MySQL复合索引和单列索引的单表查询分析</a></li><li><a href="https://mp.weixin.qq.com/s/r52hmD71TtiJjlOzQUvRlA" target="_blank" rel="noopener">干货推荐|Java并发编程核心概念一览，面试必备！</a></li><li><a href="https://mp.weixin.qq.com/s/7Dod-NcukPjYuQizGEdZdg" target="_blank" rel="noopener">面试干货 | Java 能否自定义一个类叫 java.lang.System？</a></li><li><a href="https://mp.weixin.qq.com/s/KoAUQm1-FXbi2WObrH3DOw" target="_blank" rel="noopener">Java 中的 jar ，天天见，可是你知道它的运行机制吗？</a></li><li><a href="https://mp.weixin.qq.com/s/U9WGULQoxdtWXGng_dpOdA" target="_blank" rel="noopener">干货 | 鸟瞰 MySQL，唬住面试官！</a></li><li><a href="https://mp.weixin.qq.com/s/8LhYFMQYfWfcDIti5qLMoA" target="_blank" rel="noopener">读者来稿：想和你聊聊 TCC</a></li></ol><p>好了，小伙伴们收藏好这篇文章，就不怕再也找不到松哥 2019 年的原创干货了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公众号的文章改整理一下了，老有小伙伴表示文章找不到，确实是这样，公众号的文章看过了没消化，后来再想找到有点难，有的小伙伴机智的收藏了一下，但是因为收藏夹里的东西太多了，后来还是不好找。&lt;/p&gt;
    
    </summary>
    
      <category term="2019" scheme="http://www.javaboy.org/categories/2019/"/>
    
    
      <category term="2019-article" scheme="http://www.javaboy.org/tags/2019-article/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十五)Spring Boot 2.2.0 中的 Bug</title>
    <link href="http://www.javaboy.org/2020/0103/springboot-freemarker-bug.html"/>
    <id>http://www.javaboy.org/2020/0103/springboot-freemarker-bug.html</id>
    <published>2020-01-03T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.487Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot2.2.0 这个版本发布没多久，Spring Boot2.2.1 就出来，看似不太重要的版本，却发生了一个小小变化，导致不少小伙伴掉坑了，我本来也没太在意，但是最近有快十个小伙伴在微信上问这个问题，看来我必须得写篇文章说下了，防止小伙伴们掉坑了。</p><a id="more"></a><p>到底是什么问题呢？其实就是 Freemarker 后缀变化的问题，一开始收到这个问题的时候，我以为就是小伙伴们学习不认真导致的，也没太在意：</p><p><img src="http://www.javaboy.org/images/boot2/45-1.png" alt><br><img src="http://www.javaboy.org/images/boot2/45-2.png" alt></p><p>结果最近不停有人掉坑，我觉得很有必要给各位小伙伴提个醒。</p><p>很多小伙伴可能很早就接触过 Freemarker，这个模板在 SSM 中也可以使用，只不过需要我们自己的配置东西稍微有点多。但是在之前我们使用 Freemarker 时，这个模板文件的后缀是 ftl，所以我们理所当然的认为这是标准后缀。</p><p>其实不然。</p><p>在 Freemarker 中，还有两个后缀，一个叫做 ftlh，这个用在 HTML 模板中，另一个叫做 ftlx，这个用在 XML 模板中。</p><p>Spring Boot2.2.0 之前，Freemarker 模板默认采用的后缀就是 ftl，我们可以看下 FreeMarkerProperties 类的部分源码（Spring Boot2.2.0 之前的版本）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="hljs-string">"spring.freemarker"</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">"classpath:/templates/"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".ftl"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap();</span><br><span class="line">    <span class="hljs-keyword">private</span> String[] templateLoaderPath = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"classpath:/templates/"</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> preferFileSystemAccess = <span class="hljs-keyword">true</span>;</span><br></pre></td></tr></table></figure><p>可以看到，DEFAULT_SUFFIX 变量中定义的 Freemarker 默认的后缀还是 <code>.ftl</code>。</p><p>从 Spring Boot2.2.0 开始，FreeMarkerProperties 文件内容就发生了变化，最新的 FreeMarkerProperties 文件部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="hljs-string">"spring.freemarker"</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">"classpath:/templates/"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".ftlh"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap();</span><br><span class="line">    <span class="hljs-keyword">private</span> String[] templateLoaderPath = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"classpath:/templates/"</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> preferFileSystemAccess = <span class="hljs-keyword">true</span>;</span><br></pre></td></tr></table></figure><p>可以看到，这个时候在 DEFAULT_SUFFIX 变量中定义的默认后缀变成 <code>.ftlh</code> 了。</p><p>就这样一个小小变化，就把很多初次接触 Spring Boot 的小伙伴搞晕啦。</p><p>那么这个问题如何解决呢？当大家发现了原因，应该也就能找到解决办法了，其实很简单，两个思路：</p><ul><li>将 Freemarker 模板的后缀改为 <code>.ftlh</code>，推荐这种方式</li><li>在 application.properties 中修改默认配置</li></ul><p>第一种方案，就是我们在定义 Freemarker 模板的时候，直接将原来的 ftl 改成 ftlh 就可以了，像下面这张图这样：</p><p><img src="http://www.javaboy.org/images/boot2/45-3.png" alt></p><p>这样框架就能找到相应的模板文件了。</p><p>第二种方案就是 Freemarker 模板的后缀不变，依然是 <code>ftl</code>，然后我们在 application.properties 中修改默认的后缀配置，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.freemarker.suffix=.ftl</span><br></pre></td></tr></table></figure><p>这样就是人为强行把 Freemarker 模板的后缀又改回 <code>.ftl</code> 了。</p><p>这两种方案都可以解决这个问题。</p><p><strong>其实这个问题很简单，只要你看了 FreeMarkerProperties 类的源码，这个问题一下就明了了。</strong></p><p>松哥刚开始录 Spring Boot 视频的时候，当时最新版是 2.1.6，后来随着视频录制，Spring Boot 版本一直在变化，视频里一直是跟随最新版录制，不过在讲 Freemarker 这块的时候，还是 2.1.6，所以当时还不存在上面这个问题。虽然问题不存在，但是我在视频中却是带领小伙伴们看了 FreeMarkerProperties 类的源码的，出了问题之后，有小伙伴就机智的去翻这个类的源码，然后自己顺利的把问题解决了。感觉深得松哥真传，吾心甚慰。</p><p><img src="http://www.javaboy.org/images/boot2/45-4.png" alt></p><p>好了，一个小小的坑，小伙伴们在这里遇到问题稍稍留意下就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot2.2.0 这个版本发布没多久，Spring Boot2.2.1 就出来，看似不太重要的版本，却发生了一个小小变化，导致不少小伙伴掉坑了，我本来也没太在意，但是最近有快十个小伙伴在微信上问这个问题，看来我必须得写篇文章说下了，防止小伙伴们掉坑了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十四)Spring Session 中的 Bug</title>
    <link href="http://www.javaboy.org/2020/0102/springboot-springsession.html"/>
    <id>http://www.javaboy.org/2020/0102/springboot-springsession.html</id>
    <published>2020-01-02T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.424Z</updated>
    
    <content type="html"><![CDATA[<p>真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。</p><a id="more"></a><p>如果大家没看过松哥之前写的 Spring Boot 整合 Spring Session，可以先回顾下：</p><ul><li><a href="https://mp.weixin.qq.com/s/qf-cQ7wI_Sp5pENTLlCRJw" target="_blank" rel="noopener">Spring Boot2 系列教程(二十八)Spring Boot 整合 Session 共享</a></li></ul><h2 id="第一次踩坑"><a href="#第一次踩坑" class="headerlink" title="第一次踩坑"></a>第一次踩坑</h2><p>事情是这样的，大概在今年 6 月初的时候，我在项目中使用到了 Session 共享，当时采用的方案就是 Redis+Spring Session。本来这是一个很简单的问题，我在以前的项目中也用过多次这种方案，早已轻车熟路，但是那次有点不对劲，项目启动时候报了如下错误：</p><p><img src="http://www.javaboy.org/images/boot2/44-1.png" alt></p><p>一模一样的代码，但是运行就是会出错，我感觉莫名其妙。因为在 Spring Boot 中整合 Spring Session 是一个非常简单的操作，就几行 Redis 的配置而已，我在确认了代码没问题之后，很快想到了可能是版本问题，因为当时 Spring Boot2.1.5 刚刚发布，我喜欢用最新版。于是我尝试将 Spring Boot 的版本切换到 2.1.4 ，切换回去之后，果然就 OK了，再次启动项目又不会报错了。于是基本确定这是 Spring Boot 的版本升级带来的问题。</p><p>但是当时我并没有深究，我以为就是官方出于安全考虑，让你在使用 Redis 时强制加上 Spring Security（因为根据错误提示，很容想到加上 Spring Security 依赖），加上 Spring Security 依赖之后，果然就没有问题了，我也没有多想，这件事就这样过了。​</p><h2 id="第二次踩坑"><a href="#第二次踩坑" class="headerlink" title="第二次踩坑"></a>第二次踩坑</h2><p>前两天我在给星球上的小伙伴录制 Spring Boot 视频的时候，采用了  Spring Boot 最新版 2.1.7，也是 Spring Session，但是在创建项目的时候，忘记添加 Spring Security 依赖了（第一次踩坑之后，我每次用 Spring Session 都会自觉的加上 Spring Security 依赖），运行的时候竟然没报错！我就郁闷了。</p><p>于是我去试了 Spring Boot2.1.4、Spring Boot2.1.6 发现都没有问题，在使用 Spring Session 的时候都不需要添加 Spring Security 依赖，只有 Spring Boot2.1.5 才有这个问题。于是我大概明白了，这可能是一个 Bug，而不是版本升级的新功能。</p><p>这一次，那我就打算追究一下问题的根源。</p><h2 id="源头"><a href="#源头" class="headerlink" title="源头"></a>源头</h2><p>要追究问题的源头，我们当然得从 Spring Session 的自动化配置类开始。</p><p>在 Spring Boot2.1.5 的 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类中，我看到如下源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectProvider&lt;SpringSessionRememberMeServices&gt; springSessionRememberMeServices)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//.....</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer</span><br><span class="line">.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line">springSessionRememberMeServices.ifAvailable((</span><br><span class="line">rememberMeServices) -&gt; cookieSerializer.setRememberMeRequestAttribute(</span><br><span class="line">SpringSessionRememberMeServices.REMEMBER_ME_LOGIN_ATTR));</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这一段源码中我们可以看到，这里使用到了 SpringSessionRememberMeServices ，而这个类中则用到 Spring Security 中相关的类。因此，如果不引入 Spring Security 就会报错。</p><p>我们再来看看 Spring Boot2.1.6 中 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类的源码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line"><span class="hljs-keyword">if</span> (ClassUtils.isPresent(REMEMBER_ME_SERVICES_CLASS, getClass().getClassLoader())) &#123;</span><br><span class="line"><span class="hljs-keyword">new</span> RememberMeServicesCookieSerializerCustomizer().apply(cookieSerializer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 Spring Boot2.1.6 中，这个问题已经得到修复。这里就没有 2.1.5 那么冲动了，上来了先用 <code>ClassUtils.isPresent</code> 方法判断了下 REMEMBER_ME_SERVICES_CLASS(<code>org.springframework.security.web.authentication.RememberMeServices</code>) 是否存在，存在的话，才有后面的操作。</p><p>至此，这个问题就总算弄懂了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>大家平时遇到问题，如果项目不是很赶的话，可以留意多想想，多追究一下原因，说不定你会有很多意外的收获。我这次就是一个活生生的例子，一开始没多想，后来又发现不对劲，前前后后一折腾，反而又多浪费了一些时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十三)Spring Boot 邮件发送的 5 种姿势</title>
    <link href="http://www.javaboy.org/2020/0101/springboot-mail.html"/>
    <id>http://www.javaboy.org/2020/0101/springboot-mail.html</id>
    <published>2020-01-01T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.373Z</updated>
    
    <content type="html"><![CDATA[<p>邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。</p><a id="more"></a><h1 id="邮件基础"><a href="#邮件基础" class="headerlink" title="邮件基础"></a>邮件基础</h1><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。  </p><p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。  </p><p>生活中我们投递一封邮件要经过如下几个步骤：  </p><ol><li>深圳的小王先将邮件投递到深圳的邮局  </li><li>深圳的邮局将邮件运送到上海的邮局  </li><li>上海的小张来邮局取邮件   </li></ol><p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> ：  </p><ol><li><a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器  </li><li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器  </li><li><a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 登录网易的邮件服务器查看邮件  </li></ol><p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。  </p><p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件与 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><p>最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。  </p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>目前国内大部分的邮件服务商都不允许直接使用用户名/密码的方式来在代码中发送邮件，都是要先申请授权码，这里以 QQ 邮箱为例，向大家演示授权码的申请流程：首先我们需要先登录 QQ 邮箱网页版，点击上方的设置按钮：  </p><p><img src="http://www.javaboy.org/images/boot2/43-1.jpg" alt="p266">  </p><p>然后点击账户选项卡：  </p><p><img src="http://www.javaboy.org/images/boot2/43-2.jpg" alt="p267">  </p><p>在账户选项卡中找到开启POP3/SMTP选项，如下：  </p><p><img src="http://www.javaboy.org/images/boot2/43-3.jpg" alt="p268">  </p><p>点击开启，开启相关功能，开启过程需要手机号码验证，按照步骤操作即可，不赘述。开启成功之后，即可获取一个授权码，将该号码保存好，一会使用。</p><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p>接下来，我们就可以创建项目了，Spring Boot 中，对于邮件发送提供了自动配置类，开发者只需要加入相关依赖，然后配置一下邮箱的基本信息，就可以发送邮件了。</p><ul><li>首先创建一个 Spring Boot 项目，引入邮件发送依赖：</li></ul><p><img src="http://www.javaboy.org/images/boot2/43-4.png" alt></p><p>创建完成后，项目依赖如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置邮箱基本信息</li></ul><p>项目创建成功后，接下来在 application.properties 中配置邮箱的基本信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=587</span><br><span class="line">spring.mail.username=1510161612@qq.com</span><br><span class="line">spring.mail.password=ubknfzhjkhrbbabe</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory</span><br><span class="line">spring.mail.properties.mail.debug=true</span><br></pre></td></tr></table></figure><p>配置含义分别如下：</p><ul><li>配置 SMTP 服务器地址</li><li>SMTP 服务器的端口</li><li>配置邮箱用户名</li><li>配置密码，注意，不是真正的密码，而是刚刚申请到的授权码</li><li>默认的邮件编码</li><li>配饰 SSL 加密工厂</li><li>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</li></ul><p>如果不知道 smtp 服务器的端口或者地址的的话，可以参考 腾讯的邮箱文档</p><ul><li><a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371" target="_blank" rel="noopener">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371</a></li></ul><p>做完这些之后，Spring Boot 就会自动帮我们配置好邮件发送类，相关的配置在 <code>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration</code> 类中，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; MimeMessage.class, MimeType.class, MailSender.class &#125;)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(MailSender.class)</span><br><span class="line"><span class="hljs-meta">@Conditional</span>(MailSenderCondition.class)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(MailProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，可以看到，导入了另外一个配置 <code>MailSenderPropertiesConfiguration</code> 类，这个类中，提供了邮件发送相关的工具类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mail"</span>, name = <span class="hljs-string">"host"</span>)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderPropertiesConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MailProperties properties;</span><br><span class="line">        MailSenderPropertiesConfiguration(MailProperties properties) &#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> JavaMailSenderImpl <span class="hljs-title">mailSender</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                JavaMailSenderImpl sender = <span class="hljs-keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">                applyProperties(sender);</span><br><span class="line">                <span class="hljs-keyword">return</span> sender;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里创建了一个 <code>JavaMailSenderImpl</code> 的实例， <code>JavaMailSenderImpl</code> 是 <code>JavaMailSender</code> 的一个实现，我们将使用 <code>JavaMailSenderImpl</code> 来完成邮件的发送工作。</p><p>做完如上两步，邮件发送的准备工作就算是完成了，接下来就可以直接发送邮件了。</p><p>具体的发送，有 5 种不同的方式，我们一个一个来看。</p><h2 id="发送简单邮件"><a href="#发送简单邮件" class="headerlink" title="发送简单邮件"></a>发送简单邮件</h2><p>简单邮件就是指邮件内容是一个普通的文本文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JavaMailSender javaMailSender;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSimpleMail</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();</span><br><span class="line">    message.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    message.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    message.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    message.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    message.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    message.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    message.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    javaMailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上往下，代码含义分别如下：</p><ol><li>构建一个邮件对象</li><li>设置邮件主题</li><li>设置邮件发送者</li><li>设置邮件接收者，可以有多个接收者</li><li>设置邮件抄送人，可以有多个抄送人</li><li>设置隐秘抄送人，可以有多个</li><li>设置邮件发送日期</li><li>设置邮件的正文</li><li>发送邮件</li></ol><p>最后执行该方法，就可以实现邮件的发送，发送效果图如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-5.png" alt></p><h2 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h2><p>邮件的附件可以是图片，也可以是普通文件，都是支持的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAttachFileMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    helper.addAttachment(<span class="hljs-string">"javaboy.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里在构建邮件对象上和前文有所差异，这里是通过 javaMailSender 来获取一个复杂邮件对象，然后再利用 MimeMessageHelper 对邮件进行配置，MimeMessageHelper 是一个邮件配置的辅助工具类，创建时候的 true 表示构建一个 multipart message 类型的邮件，有了 MimeMessageHelper 之后，我们针对邮件的配置都是由 MimeMessageHelper 来代劳。</p><p>最后通过 addAttachment 方法来添加一个附件。</p><p>执行该方法，邮件发送效果图如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-6.png" alt></p><h2 id="发送带图片资源的邮件"><a href="#发送带图片资源的邮件" class="headerlink" title="发送带图片资源的邮件"></a>发送带图片资源的邮件</h2><p>图片资源和附件有什么区别呢？图片资源是放在邮件正文中的，即一打开邮件，就能看到图片。但是一般来说，不建议使用这种方式，一些公司会对邮件内容的大小有限制（因为这种方式是将图片一起发送的）。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendImgResMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"&lt;p&gt;hello 大家好，这是一封测试邮件，这封邮件包含两种图片，分别如下&lt;/p&gt;&lt;p&gt;第一张图片：&lt;/p&gt;&lt;img src='cid:p01'/&gt;&lt;p&gt;第二张图片：&lt;/p&gt;&lt;img src='cid:p02'/&gt;"</span>,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p01"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>)));</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p02"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy2.png"</span>)));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的邮件 text 是一个 HTML 文本，里边涉及到的图片资源先用一个占位符占着，setText 方法的第二个参数 true 表示第一个参数是一个 HTML 文本。</p><p>setText 之后，再通过 addInline 方法来添加图片资源。</p><p>最后执行该方法，发送邮件，效果如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-7.png" alt></p><p>在公司实际开发中，第一种和第三种都不是使用最多的邮件发送方案。因为正常来说，邮件的内容都是比较的丰富的，所以大部分邮件都是通过 HTML 来呈现的，如果直接拼接 HTML 字符串，这样以后不好维护，为了解决这个问题，一般邮件发送，都会有相应的邮件模板。最具代表性的两个模板就是 <code>Freemarker</code> 模板和 <code>Thyemeleaf</code> 模板了。</p><h2 id="使用-Freemarker-作邮件模板"><a href="#使用-Freemarker-作邮件模板" class="headerlink" title="使用 Freemarker 作邮件模板"></a>使用 Freemarker 作邮件模板</h2><p>首先需要引入 Freemarker 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>resources/templates</code> 目录下创建一个 <code>mail.ftl</code> 作为邮件发送模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;salary&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，将邮件模板渲染成 HTML ，然后发送即可。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFreemarkerMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException, IOException, TemplateException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    <span class="hljs-comment">//构建 Freemarker 的基本配置</span></span><br><span class="line">    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_0);</span><br><span class="line">    <span class="hljs-comment">// 配置模板位置</span></span><br><span class="line">    ClassLoader loader = MailApplication.class.getClassLoader();</span><br><span class="line">    configuration.setClassLoaderForTemplateLoading(loader, <span class="hljs-string">"templates"</span>);</span><br><span class="line">    <span class="hljs-comment">//加载模板</span></span><br><span class="line">    Template template = configuration.getTemplate(<span class="hljs-string">"mail.ftl"</span>);</span><br><span class="line">    User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    user.setNum(<span class="hljs-number">1</span>);</span><br><span class="line">    user.setSalary((<span class="hljs-keyword">double</span>) <span class="hljs-number">99999</span>);</span><br><span class="line">    StringWriter out = <span class="hljs-keyword">new</span> StringWriter();</span><br><span class="line">    <span class="hljs-comment">//模板渲染，渲染的结果将被保存到 out 中 ，将out 中的 html 字符串发送即可</span></span><br><span class="line">    template.process(user, out);</span><br><span class="line">    helper.setText(out.toString(),<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，虽然引入了 <code>Freemarker</code> 的自动化配置，但是我们在这里是直接 <code>new Configuration</code> 来重新配置 <code>Freemarker</code> 的，所以 Freemarker 默认的配置这里不生效，因此，在填写模板位置时，值为 <code>templates</code> 。</p><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-8.png" alt></p><h2 id="使用-Thymeleaf-作邮件模板"><a href="#使用-Thymeleaf-作邮件模板" class="headerlink" title="使用 Thymeleaf 作邮件模板"></a>使用 Thymeleaf 作邮件模板</h2><p>推荐在 Spring Boot 中使用 Thymeleaf 来构建邮件模板。因为 Thymeleaf 的自动化配置提供了一个 TemplateEngine，通过 TemplateEngine 可以方便的将 Thymeleaf 模板渲染为 HTML ，同时，Thymeleaf 的自动化配置在这里是继续有效的 。</p><p>首先，引入 Thymeleaf 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，创建 <code>Thymeleaf</code> 邮件模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;username&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;num&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;salary&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来发送邮件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendThymeleafMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    Context context = <span class="hljs-keyword">new</span> Context();</span><br><span class="line">    context.setVariable(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"num"</span>,<span class="hljs-string">"000001"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"salary"</span>, <span class="hljs-string">"99999"</span>);</span><br><span class="line">    String process = templateEngine.process(<span class="hljs-string">"mail.html"</span>, context);</span><br><span class="line">    helper.setText(process,<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-8.png" alt></p><p>好了，这就是我们今天说的 5 种邮件发送姿势，不知道你掌握了没有呢？</p><p>本文案例已经上传到 GitHub：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a>。</p><p>有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
</feed>
