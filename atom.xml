<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2021-03-16T08:51:16.790Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot 中如何自定义参数解析器？</title>
    <link href="http://www.javaboy.org/2021/0316/springmvc-param-resolver.html"/>
    <id>http://www.javaboy.org/2021/0316/springmvc-param-resolver.html</id>
    <published>2021-03-16T08:48:03.000Z</published>
    <updated>2021-03-16T08:51:16.790Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 Web 请求中，参数我们无非就是放在地址栏或者请求体中，个别请求可能放在请求头中。</p><a id="more"></a><p>放在地址栏中，我们可以通过如下方式获取参数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javaboy = request.getParameter(<span class="hljs-string">"name "</span>);</span><br></pre></td></tr></table></figure><p>放在请求体中，如果是 key/value 形式，我们可以通过如下方式获取参数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javaboy = request.getParameter(<span class="hljs-string">"name "</span>);</span><br></pre></td></tr></table></figure><p>如果是 JSON 形式，我们则通过如果如下方式获取到输入流，然后解析成 JSON 字符串，再通过 JSON 工具转为对象：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(request.getInputStream()));</span><br><span class="line">String json = reader.readLine();</span><br><span class="line">reader.close();</span><br><span class="line">User user = <span class="hljs-keyword">new</span> ObjectMapper().readValue(json, User.class);</span><br></pre></td></tr></table></figure><p>如果参数放在请求头中，我们可以通过如下方式获取：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javaboy = request.getHeader(<span class="hljs-string">"name"</span>);</span><br></pre></td></tr></table></figure><p>如果你用的是 Jsp/Servlet 那一套技术栈，那么参数获取无外乎这几种方式。</p><p>如果用了 SpringMVC 框架，有的小伙伴们可能会觉得参数获取方式太丰富了，各种注解如 <code>@RequestParam</code>、<code>@RequestBody</code>、<code>@RequestHeader</code>、<code>@PathVariable</code>，参数可以是 key/value 形式，也可以是 JSON 形式，非常丰富！但是，<strong>无论多么丰富，最底层获取参数的方式无外乎上面几种。</strong></p><p>那有小伙伴要问了，SpringMVC 到底是怎么样从 request 中把参数提取出来直接给我们用的呢？例如下面这个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道 name 参数是从 HttpServletRequest 中提取出来的，到底是怎么提取出来的？这就是松哥今天要和大家分享的话题。</p><h2 id="1-自定义参数解析器"><a href="#1-自定义参数解析器" class="headerlink" title="1.自定义参数解析器"></a>1.自定义参数解析器</h2><p>为了搞清楚这个问题，我们先来自定义一个参数解析器看看。</p><p>自定义参数解析器需要实现 HandlerMethodArgumentResolver 接口，我们先来看看该接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中就两个方法：</p><ul><li>supportsParameter：该方法表示是否启用这个参数解析器，返回 true 表示启用，返回 false 表示不启用。</li><li>resolveArgument：这是具体的解析过程，就是从 request 中取出参数的过程，方法的返回值就对应了接口中参数的值。</li></ul><p>自定义参数解析器只需要实现该接口即可。</p><p>假设我现在有这样一个需求（实际上在 Spring Security 中获取当前登录用户名非常方便，这里只是为了该案例而做，勿抬杠）：</p><p>假设我现在系统安全框架使用了 Spring Security（对 Spring Security 不熟悉的小伙伴，可以在公众号江南一点雨后台回复 ss，有教程），如果我在接口的参数上添加了 @CurrentUserName 注解，那么该参数的值就是当前登录的用户名，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@CurrentUserName String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现这个功能，非常 easy，首先我们自定义一个 <code>@CurrentUserName</code> 注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CurrentUserName &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解没啥好解释的。</p><p>接下来我们自定义参数解析器 CurrentUserNameHandlerMethodArgumentResolver，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrentUserNameHandlerMethodArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> parameter.getParameterType().isAssignableFrom(String.class)&amp;&amp;parameter.hasParameterAnnotation(CurrentUserName.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="hljs-keyword">return</span> user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsParameter：如果参数类型是 String，并且参数上有 <code>@CurrentUserName</code> 注解，则使用该参数解析器。</li><li>resolveArgument：该方法的返回值就是参数的具体值，当前登录用户名从 SecurityContextHolder 中获取即可（具体参数松哥的 Spring Security 教程，公号后台回复 ss）。</li></ul><p>最后，我们再将自定义的参数解析器配置到 HandlerAdapter 中，配置方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">        resolvers.add(<span class="hljs-keyword">new</span> CurrentUserNameHandlerMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，就算配置完成了。</p><p>接下来启动项目，用户登录成功后，访问 <code>/hello</code> 接口，就可以看到返回当前登录用户数据了。</p><p>这就是我们自定义的一个参数类型解析器。可以看到，非常 Easy。</p><p>在 SpringMVC 中，默认也有很多 HandlerMethodArgumentResolver 的实现类，他们处理的问题也都类似，松哥再给大家举个例子。</p><h2 id="2-PrincipalMethodArgumentResolver"><a href="#2-PrincipalMethodArgumentResolver" class="headerlink" title="2.PrincipalMethodArgumentResolver"></a>2.PrincipalMethodArgumentResolver</h2><p>如果我们在项目中使用了 Spring Security，我们可以通过如下方式获取当前登录用户信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">(Principal principal)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span> + principal.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即直接在当前接口的参数中添加 Principal 类型的参数即可，该参数描述了当前登录用户信息，这个用过 Spring Security 的小伙伴应该都知道（不熟悉 Spring Security 的小伙伴可以在公众号【江南一点雨】后台回复 ss）。</p><p>那么这个功能是怎么实现的呢？当然就是 PrincipalMethodArgumentResolver 在起作用了！</p><p>我们一起来看下这个参数解析器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrincipalMethodArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Principal.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (request == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Current request is not of type HttpServletRequest: "</span> + webRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Principal principal = request.getUserPrincipal();</span><br><span class="line"><span class="hljs-keyword">if</span> (principal != <span class="hljs-keyword">null</span> &amp;&amp; !parameter.getParameterType().isInstance(principal)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Current user principal is not of type ["</span> +</span><br><span class="line">parameter.getParameterType().getName() + <span class="hljs-string">"]: "</span> + principal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> principal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsParameter：这个方法主要是判断参数类型是不是 Principal，如果参数类型是 Principal，就支持。</li><li>resolveArgument：这个方法的逻辑很简单，首先获取原生的请求，再从请求中获取 Principal 对象返回即可。</li></ul><p>是不是很简单，有了这个，我们就可以随时加载到当前登录用户信息了。</p><h2 id="3-RequestParamMapMethodArgumentResolver"><a href="#3-RequestParamMapMethodArgumentResolver" class="headerlink" title="3.RequestParamMapMethodArgumentResolver"></a>3.RequestParamMapMethodArgumentResolver</h2><p>松哥再给大家举个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam MultiValueMap map)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口很多小伙伴可能都写过，使用 Map 去接收前端传来的参数，那么这里用到的参数解析器就是 RequestParamMapMethodArgumentResolver。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestParamMapMethodArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="hljs-keyword">return</span> (requestParam != <span class="hljs-keyword">null</span> &amp;&amp; Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp;</span><br><span class="line">!StringUtils.hasText(requestParam.name()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ResolvableType resolvableType = ResolvableType.forMethodParameter(parameter);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (MultiValueMap.class.isAssignableFrom(parameter.getParameterType())) &#123;</span><br><span class="line"><span class="hljs-comment">// MultiValueMap</span></span><br><span class="line">Class&lt;?&gt; valueType = resolvableType.as(MultiValueMap.class).getGeneric(<span class="hljs-number">1</span>).resolve();</span><br><span class="line"><span class="hljs-keyword">if</span> (valueType == MultipartFile.class) &#123;</span><br><span class="line">MultipartRequest multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> (multipartRequest != <span class="hljs-keyword">null</span> ? multipartRequest.getMultiFileMap() : <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(<span class="hljs-number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueType == Part.class) &#123;</span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span> &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">Collection&lt;Part&gt; parts = servletRequest.getParts();</span><br><span class="line">LinkedMultiValueMap&lt;String, Part&gt; result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(parts.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">result.add(part.getName(), part);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = webRequest.getParameterMap();</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(parameterMap.size());</span><br><span class="line">parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String value : values) &#123;</span><br><span class="line">result.add(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Regular Map</span></span><br><span class="line">Class&lt;?&gt; valueType = resolvableType.asMap().getGeneric(<span class="hljs-number">1</span>).resolve();</span><br><span class="line"><span class="hljs-keyword">if</span> (valueType == MultipartFile.class) &#123;</span><br><span class="line">MultipartRequest multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> (multipartRequest != <span class="hljs-keyword">null</span> ? multipartRequest.getFileMap() : <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(<span class="hljs-number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueType == Part.class) &#123;</span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span> &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">Collection&lt;Part&gt; parts = servletRequest.getParts();</span><br><span class="line">LinkedHashMap&lt;String, Part&gt; result = CollectionUtils.newLinkedHashMap(parts.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : parts) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!result.containsKey(part.getName())) &#123;</span><br><span class="line">result.put(part.getName(), part);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = webRequest.getParameterMap();</span><br><span class="line">Map&lt;String, String&gt; result = CollectionUtils.newLinkedHashMap(parameterMap.size());</span><br><span class="line">parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (values.length &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">result.put(key, values[<span class="hljs-number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsParameter：参数类型是 Map，并且使用了 <code>@RequestParam</code> 注解，并且 <code>@RequestParam</code> 注解中没有配置 name 属性，就可以使用该参数解析器。</li><li>resolveArgument：具体解析分为两种情况：MultiValueMap 和其他 Map，前者中又分三种情况：MultipartFile、Part 或者其他普通请求，前两者可以处理文件上传，第三个就是普通参数。如果是普通 Map，则直接获取到原始请求参数放到一个 Map 集合中返回即可。</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>前面和大家聊的都是几种简单的情况，还有复杂的如 PathVariableMethodArgumentResolver 和 RequestParamMethodArgumentResolver 松哥以后再和大家详细聊。同时还有一个问题就是这些参数解析器具体是在哪里调用的，这个也会在松哥近期的 SpringMVC 源码解析系列文章中和大家分享，好啦，今天周末，就这点简单的小知识祝大家周末愉快～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个 Web 请求中，参数我们无非就是放在地址栏或者请求体中，个别请求可能放在请求头中。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 初始化流程分析</title>
    <link href="http://www.javaboy.org/2021/0315/springmvc-init.html"/>
    <id>http://www.javaboy.org/2021/0315/springmvc-init.html</id>
    <published>2021-03-15T08:47:50.000Z</published>
    <updated>2021-03-16T08:51:54.332Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>框架源码是我们 Coding 晋级中的必修课，SSM 应该算是小伙伴们日常接触最多的框架了，这其中 SpringMVC 初始化流程相对来说要简单一些，因此今天松哥就先来和大家分析一下 SpringMVC 初始化流程。</p><a id="more"></a><p>即使你没看过 SpringMVC 的源码，估计也听说过：DispatcherServlet 是 SpringMVC 的大脑，它负责整个 SpringMVC 的调度工作，是 SpringMVC 中最最核心的类，SpringMVC 整个顶层架构设计都体现在这里，所以搞明白 DispatcherServlet 的源码，基本上 SpringMVC 的工作原理也就了然于胸了。</p><p>然而 DispatcherServlet 继承自 FrameworkServlet，FrameworkServlet 又继承自 HttpServletBean，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210301214050.png" alt></p><p>因此我们的分析就从 HttpServletBean 开始。</p><h2 id="1-HttpServletBean"><a href="#1-HttpServletBean" class="headerlink" title="1.HttpServletBean"></a>1.HttpServletBean</h2><p><code>HttpServletBean</code> 继承自 <code>HttpServlet</code>，它负责将 <code>init-param</code> 中的参数注入到当前 <code>Servlet</code> 实例的属性中，同时也为子类提供了增加 <code>requiredProperties</code> 的能力，需要注意的是 <code>HttpServletBean</code> 并不依赖于 <code>Spring</code> 容器。</p><p>大家知道，HttpServlet 的初始化是从 init 方法开始的，所以我们就先从 HttpServletBean 的 init 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Set bean properties from init parameters.</span></span><br><span class="line">PropertyValues pvs = <span class="hljs-keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="hljs-keyword">this</span>.requiredProperties);</span><br><span class="line"><span class="hljs-keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="hljs-keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="hljs-keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="hljs-keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line">bw.setPropertyValues(pvs, <span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">logger.error(<span class="hljs-string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="hljs-string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里，首先获取到 Servlet 的所有配置并转为 PropertyValues，然后通过 BeanWrapper 修改目标 Servlet 的相关属性。BeanWrapper 是 Spring 中提供一个工具，使用它可以修改一个对象的属性，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        BeanWrapper beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(user);</span><br><span class="line">        beanWrapper.setPropertyValue(<span class="hljs-string">"username"</span>, <span class="hljs-string">"itboyhub"</span>);</span><br><span class="line">        PropertyValue pv = <span class="hljs-keyword">new</span> PropertyValue(<span class="hljs-string">"address"</span>, <span class="hljs-string">"www.itboyhub.com"</span>);</span><br><span class="line">        beanWrapper.setPropertyValue(pv);</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;username=&apos;itboyhub&apos;, address=&apos;www.itboyhub.com&apos;&#125;</span><br></pre></td></tr></table></figure><p>所以前面的 bw 实际上就代表当前 DispatcherServlet 对象。</p><p>通过 BeanWrapper 修改目标 Servlet 的相关属性时，有一个 initBeanWrapper 方法是空方法，开发者如有需要可以在子类中实现该方法，并且完成一些初始化操作。</p><p>属性配置完成后，最终调用 initServletBean 方法进行 Servlet 初始化，然而该方法也是一个空方法，在子类中实现。</p><p>这就是 HttpServletBean 所做的事情，比较简单，加载 Servlet 相关属性并设置给当前 Servlet 对象，然后调用 initServletBean 方法继续完成 Servlet 的初始化操作。</p><h2 id="2-FrameworkServlet"><a href="#2-FrameworkServlet" class="headerlink" title="2.FrameworkServlet"></a>2.FrameworkServlet</h2><p>从前面的介绍可知，FrameworkServlet 初始化的入口方法就是 initServletBean，因此我们就从 FrameworkServlet#initServletBean 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServletBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法原本挺长的，但是抛开日志打印异常抛出，剩下的核心代码其实就两行：</p><ol><li>initWebApplicationContext 方法用来初始化 WebApplicationContext。</li><li>initFrameworkServlet 方法用来初始化 FrameworkServlet，但是这个方法是一个空方法，没有具体的实现。本来子类可以重写该方法做一些初始化操作，但是实际上子类并没有重写该方法，所以这个方法我们就暂且忽略之，不去分析了。</li></ol><p>那么这里最为重要的其实就是 initWebApplicationContext 方法了，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">initWebApplicationContext</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.webApplicationContext != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac = <span class="hljs-keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="hljs-keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (cwac.getParent() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.publishContext) &#123;</span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑也比较清晰：</p><ol><li>首先获取 rootContext。在默认情况下，Spring 会将容器设置为 ServletContext 的一个属性，属性的 key 为 <code>org.springframework.web.context.WebApplicationContext.ROOT</code>，所以根据这个 key 就可以调用 ServletContext#getAttribute 方法获取到 rootContext 了。</li><li>获取 WebApplicationContext 实例，也就是给 wac 变量赋值的过程，这里存在三种可能性：1.如果已经通过构造方法给 webApplicationContext 赋值了，则直接将其赋给 wac 变量，同时，如果需要设置 parent 就设置，需要刷新就刷新。这种方式适用于 Servlet3.0 以后的环境，因为从 Servlet3.0 开始，才支持直接调用 ServletContext.addServlet 方法去注册 Servlet，手动注册的时候就可以使用自己提前准备好的 WebApplicationContext 了，这块松哥在我录制的 Spring Boot 视频中也讲过，感兴趣的小伙伴可以在公众号后台回复 vhr 查看视频详情；2.如果第一步没能成功给 wac 赋值，那么调用 findWebApplicationContext 方法尝试去 ServletContext 中查找 WebApplicationContext 对象，找到了就赋值给 wac；3.如果第二步没能成功给 wac 赋值，那么调用 createWebApplicationContext 方法创建一个 WebApplicationContext 对象并赋值给 wac，一般来说都是通过这种方式创建的 WebApplicationContext。这三套组合拳下来，wac 肯定是有值了。</li><li>当 ContextRefreshedEvent 事件没有触发时，调用 onRefresh 方法完成容器刷新（由于第一种和第三种获取 WebApplicationContext 的方式最终都会调用 configureAndRefreshWebApplicationContext 方法，然后发布事件，再将 refreshEventReceived 变量标记为 true，所以实际上只有第二种方式获取 wac 实例的时候，这里才会刷新，具体可以看下文分析）。</li><li>最后将 wac 保存到到 ServletContext 中。保存的时候会根据 publishContext 变量的值来决定是否保存，publishContext 可以在 web.xml 中配置 Servlet 时通过 init-param 进行配置，保存的目的是为了方便获取。</li></ol><p>上面的这些步骤中，通过 createWebApplicationContext 方法创建 WebApplicationContext 对象需要和大家细说下，因为一般情况下就是通过这种方式创建的 WebApplicationContext。我们来看一下相关的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createWebApplicationContext</span><span class="hljs-params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line"><span class="hljs-keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(</span><br><span class="line"><span class="hljs-string">"Fatal initialization error in servlet with name '"</span> + getServletName() +</span><br><span class="line"><span class="hljs-string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +</span><br><span class="line"><span class="hljs-string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">&#125;</span><br><span class="line">ConfigurableWebApplicationContext wac =</span><br><span class="line">(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">wac.setEnvironment(getEnvironment());</span><br><span class="line">wac.setParent(parent);</span><br><span class="line">String configLocation = getContextConfigLocation();</span><br><span class="line"><span class="hljs-keyword">if</span> (configLocation != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac.setConfigLocation(configLocation);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"><span class="hljs-keyword">return</span> wac;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureAndRefreshWebApplicationContext</span><span class="hljs-params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line"><span class="hljs-comment">// The application context id is still set to its original default value</span></span><br><span class="line"><span class="hljs-comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.contextId != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac.setId(<span class="hljs-keyword">this</span>.contextId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Generate default id...</span></span><br><span class="line">wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="hljs-string">'/'</span> + getServletName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wac.setServletContext(getServletContext());</span><br><span class="line">wac.setServletConfig(getServletConfig());</span><br><span class="line">wac.setNamespace(getNamespace());</span><br><span class="line">wac.addApplicationListener(<span class="hljs-keyword">new</span> SourceFilteringListener(wac, <span class="hljs-keyword">new</span> ContextRefreshListener()));</span><br><span class="line"><span class="hljs-comment">// The wac environment's #initPropertySources will be called in any case when the context</span></span><br><span class="line"><span class="hljs-comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line"><span class="hljs-comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line"><span class="hljs-keyword">if</span> (env <span class="hljs-keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">&#125;</span><br><span class="line">postProcessWebApplicationContext(wac);</span><br><span class="line">applyInitializers(wac);</span><br><span class="line">wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共涉及到两个方法：</p><p><strong>createWebApplicationContext</strong></p><p>首先获取到创建类型，并检查创建类型，没问题的话调用 instantiateClass 方法完成创建工作，然后给创建好的 wac 对象配置各种属性，配置的 configLocation 就是我们在 web.xml 文件中配置的 SpringMVC 配置文件路径，默认的文件路径是 <code>/WEB-INF/[servletName]-servlet.xml</code>。</p><p><strong>configureAndRefreshWebApplicationContext</strong></p><p>configureAndRefreshWebApplicationContext 方法主要也是配置&amp;刷新 WebApplicationContext，在这个方法里会调用 addApplicationListener 为 wac 添加一个监听器，监听的是 ContextRefreshedEvent 事件，当收到该事件后，会调用 FrameworkServlet 的 onApplicationEvent 方法，并在该方法中调用 onRefresh 方法完成刷新，刷新之后，会将 refreshEventReceived 变量标记为 true。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.refreshEventReceived = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">onRefresh(event.getApplicationContext());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 FrameworkServlet#initServletBean 方法的大致工作逻辑。这里涉及到了 onRefresh 方法，但是这是一个空方法，在子类 DispatcherServlet 中实现了，所以接下来我们就来看 DispatcherServlet。</p><h2 id="3-DispatcherServlet"><a href="#3-DispatcherServlet" class="headerlink" title="3.DispatcherServlet"></a>3.DispatcherServlet</h2><p>这里我们就不废话了，直接来看 onRefresh 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 onRefresh 方法中调用了 initStrategies 进行初始化操作。initStrategies 的内容其实很简单，就是九个组件的初始化。九个的初始化流程比较类似，这里我们以常见的视图解析器的初始化方法 initViewResolvers 为例，来一起看看初始化流程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initViewResolvers</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detectAllViewResolvers) &#123;</span><br><span class="line"><span class="hljs-comment">// Find all ViewResolvers in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">Map&lt;String, ViewResolver&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line"><span class="hljs-comment">// We keep ViewResolvers in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="hljs-keyword">this</span>.viewResolvers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// Ignore, we'll add a default ViewResolver later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Ensure we have at least one ViewResolver, by registering</span></span><br><span class="line"><span class="hljs-comment">// a default ViewResolver if no other resolvers are found.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"No ViewResolvers declared for servlet '"</span> + getServletName() +</span><br><span class="line"><span class="hljs-string">"': using default strategies from DispatcherServlet.properties"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始的 viewResolvers 变量是一个集合，解析出来的视图解析器对象都将放入这个集合中。</p><p>首先判断 detectAllViewResolvers 变量是否为 true，如果为 true，则直接去查找 Spring 容器中的所有视图解析器，将查找结果赋值给 viewResolvers，然后进行排序。默认情况下 detectAllViewResolvers 变量的值为 true，如果有需要，可以在 web.xml 中进行配置，像下面这样：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>detectAllViewResolvers<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 detectAllViewResolvers 的值为 false，那么接下来就会去 Spring 容器中查找一个名为 viewResolver 的视图解析器，此时查找到的就是一个单独的视图解析器。</p><p>一般来说，我们并不需要在 web.xml 中去配置 detectAllViewResolvers 的值，视图解析器有多少个就加载多少个。</p><p>举个简单例子，我们在 SpringMVC 的配置文件中可能像下面这样配置视图解析器：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，这个 bean 的 id 有没有都行，如果有，取什么值都可以，反正最终都是通过类型而不是 id 去查找的视图解析器。但是如果你在 web.xml 中将 detectAllViewResolvers 修改为 false，那么这个 bean 的 id 取值就比较重要了，就一定要是 viewResolver。</p><p>如果在 Spring 容器中通过这两种方式（通过类型查找或通过 id 查找）都没有找到 ViewResolver 实例，那么会调用 getDefaultStrategies 方法去获取一个默认的 ViewResolver 实例。默认实例的获取方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">getDefaultStrategies</span><span class="hljs-params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (defaultStrategies == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Load default strategy implementations from properties file.</span></span><br><span class="line"><span class="hljs-comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line"><span class="hljs-comment">// by application developers.</span></span><br><span class="line">ClassPathResource resource = <span class="hljs-keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</span><br><span class="line">defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="hljs-string">"': "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String key = strategyInterface.getName();</span><br><span class="line">String value = defaultStrategies.getProperty(key);</span><br><span class="line"><span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span><br><span class="line">List&lt;T&gt; strategies = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(classNames.length);</span><br><span class="line"><span class="hljs-keyword">for</span> (String className : classNames) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span><br><span class="line">Object strategy = createDefaultStrategy(context, clazz);</span><br><span class="line">strategies.add((T) strategy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInitializationException(</span><br><span class="line"><span class="hljs-string">"Could not find DispatcherServlet's default strategy class ["</span> + className +</span><br><span class="line"><span class="hljs-string">"] for interface ["</span> + key + <span class="hljs-string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInitializationException(</span><br><span class="line"><span class="hljs-string">"Unresolvable class definition for DispatcherServlet's default strategy class ["</span> +</span><br><span class="line">className + <span class="hljs-string">"] for interface ["</span> + key + <span class="hljs-string">"]"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> strategies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实也比较简单，就是通过反射去获取默认的视图解析器。</p><p>首先给 defaultStrategies 赋值，defaultStrategies 的值实际上就是从 DispatcherServlet.properties 文件中加载到的，我们来看下这个文件内容：</p><p><img src="http://img.itboyhub.com/2021/02/20210303202947.png" alt></p><p>可以看到，这里一共定义了 8 个默认的键值对，有的值是一个，有的值是多个。前面 initStrategies 方法中一共要初始化九个组件，这里默认只定义了 8 个，少了一个 MultipartResolver，这也好理解，并非所有的项目都有文件上传，而且即使有文件上传，用哪一个具体的 MultipartResolver 也不好确定，还是要开发者自己决定。</p><p>defaultStrategies 其实加载到的就是这 8 个键值对，其中视图解析器对应的是 org.springframework.web.servlet.view.InternalResourceViewResolver，通过反射创建该类的实例，当 Spring 容器中不存在任何视图解析器的时候，默认的视图解析器即此。</p><p>这就是 initViewResolvers 的工作流程，另外 8 个也和它差不多，唯一不同的是 initMultipartResolver，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMultipartResolver</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartResolver = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它只是根据 bean 的名字去查找 bean 实例，没有去查找默认的 MultipartResolver。</p><p>说到这里，松哥和大家多说一句 SpringMVC 配置中的小细节，</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"multipartResolver"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个关于视图解析器和文件上传解析器的配置，不知道小伙伴们有没有注意过，视图解析器的 id 可有可无，而文件上传解析器的 id 必须是 multipartResolver，回顾我们上面的源码分析，你就知道为啥了！</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，这就是松哥和小伙伴们分享的 SpringMVC 的初始化流程，主要涉及到了 HttpServletBean、FrameworkServlet 以及 DispatcherServlet 三个实例，HttpServletBean 主要是加载 Servlet 配置的各种属性并设置到 Servlet 上；FrameworkServlet 则主要是初始化了 WebApplicationContext；DispatcherServlet 则主要是初始化了自身的九个组件。</p><p>这只是初始化的流程，那么当请求到来之后，请求的流程又是怎么样的呢？这个松哥下篇文章来和大家分享～好啦，今天就先和小伙伴们聊这么多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;框架源码是我们 Coding 晋级中的必修课，SSM 应该算是小伙伴们日常接触最多的框架了，这其中 SpringMVC 初始化流程相对来说要简单一些，因此今天松哥就先来和大家分析一下 SpringMVC 初始化流程。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的实现 Spring Boot 接口参数加密解密?</title>
    <link href="http://www.javaboy.org/2021/0309/springboot-encrypt-decrypt.html"/>
    <id>http://www.javaboy.org/2021/0309/springboot-encrypt-decrypt.html</id>
    <published>2021-03-09T06:15:49.000Z</published>
    <updated>2021-03-09T06:16:56.735Z</updated>
    
    <content type="html"><![CDATA[<p>因为有小伙伴刚好问到这个问题，松哥就抽空撸一篇文章和大家聊聊这个话题。</p><a id="more"></a><p>加密解密本身并不是难事，问题是在何时去处理？定义一个过滤器，将请求和响应分别拦截下来进行处理也是一个办法，这种方式虽然粗暴，但是灵活，因为可以拿到一手的请求参数和响应数据。不过 SpringMVC 中给我们提供了 ResponseBodyAdvice 和 RequestBodyAdvice，利用这两个工具可以对请求和响应进行预处理，非常方便。</p><p>所以今天这篇文章有两个目的：</p><ul><li>分享参数/响应加解密的思路。</li><li>分享 ResponseBodyAdvice 和 RequestBodyAdvice 的用法。</li></ul><p>好了，那么接下来就不废话了，我们一起来看下。</p><h2 id="1-开发加解密-starter"><a href="#1-开发加解密-starter" class="headerlink" title="1.开发加解密 starter"></a>1.开发加解密 starter</h2><p>为了让我们开发的这个工具更加通用，也为了复习一下自定义 Spring Boot Starter，这里我们就将这个工具做成一个 stater，以后在 Spring Boot 项目中直接引用就可以。</p><p>首先我们创建一个 Spring Boot 项目，引入 spring-boot-starter-web 依赖：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>因为我们这个工具是为 Web 项目开发的，以后必然使用在 Web 环境中，所以这里添加依赖时 scope 设置为 provided。</p><p>依赖添加完成后，我们先来定义一个加密工具类备用，加密这块有多种方案可以选择，对称加密、非对称加密，其中对称加密又可以使用 AES、DES、3DES 等不同算法，这里我们使用 Java 自带的 Cipher 来实现对称加密，使用 AES 算法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AES_ALGORITHM = <span class="hljs-string">"AES/ECB/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 获取 cipher</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cipher <span class="hljs-title">getCipher</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] key, <span class="hljs-keyword">int</span> model)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="hljs-keyword">new</span> SecretKeySpec(key, <span class="hljs-string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);</span><br><span class="line">        cipher.init(model, secretKeySpec);</span><br><span class="line">        <span class="hljs-keyword">return</span> cipher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// AES加密</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cipher cipher = getCipher(key, Cipher.ENCRYPT_MODE);</span><br><span class="line">        <span class="hljs-keyword">return</span> Base64.getEncoder().encodeToString(cipher.doFinal(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// AES解密</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] decrypt(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key) <span class="hljs-keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = getCipher(key, Cipher.DECRYPT_MODE);</span><br><span class="line">        <span class="hljs-keyword">return</span> cipher.doFinal(Base64.getDecoder().decode(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工具类比较简单，不需要多解释。需要说明的是，加密后的数据可能不具备可读性，因此我们一般需要对加密后的数据再使用 Base64 算法进行编码，获取可读字符串。换言之，上面的 AES 加密方法的返回值是一个 Base64 编码之后的字符串，AES 解密方法的参数也是一个 Base64 编码之后的字符串，先对该字符串进行解码，然后再解密。</p><p>接下来我们封装一个响应工具类备用，这个大家如果经常看松哥视频已经很了解了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RespBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer status;</span><br><span class="line">    <span class="hljs-keyword">private</span> String msg;</span><br><span class="line">    <span class="hljs-keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">ok</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">200</span>, msg, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">ok</span><span class="hljs-params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">200</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">error</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">500</span>, msg, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">error</span><span class="hljs-params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">500</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RespBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RespBean</span><span class="hljs-params">(Integer status, String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.status = status;</span><br><span class="line">        <span class="hljs-keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="hljs-keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">setStatus</span><span class="hljs-params">(Integer status)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.status = status;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">setMsg</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObj</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">setObj</span><span class="hljs-params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.obj = obj;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们定义两个注解 <code>@Decrypt</code> 和 <code>@Encrypt</code>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(&#123;ElementType.METHOD,ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Decrypt &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Encrypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个注解就是两个标记，在以后使用的过程中，哪个接口方法添加了 @Encrypt 注解就对哪个接口的数据加密返回，哪个接口/参数添加了 @Decrypt 注解就对哪个接口/参数进行解密。这个定义也比较简单，没啥好说的，需要注意的是 <code>@Decrypt</code> 比 <code>@Encrypt</code> 多了一个使用场景就是 <code>@Decrypt</code> 可以用在参数上。</p><p>考虑到用户可能会自己配置加密的 key，因此我们再来定义一个 EncryptProperties 类来读取用户配置的 key：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.encrypt"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String DEFAULT_KEY = <span class="hljs-string">"www.itboyhub.com"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> String key = DEFAULT_KEY;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setKey</span><span class="hljs-params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我设置了默认的 key 是 <code>www.itboyhub.com</code>，key 是 16 位字符串，松哥这个网站地址刚好满足。以后如果用户想自己配置 key，只需要在 application.properties 中配置 <code>spring.encrypt.key=xxx</code> 即可。</p><p>所有准备工作做完了，接下来就该正式加解密了。</p><p>因为松哥这篇文章一个很重要的目的是想和大家分享 ResponseBodyAdvice 和 RequestBodyAdvice 的用法，RequestBodyAdvice 在做解密的时候倒是没啥问题，而 ResponseBodyAdvice 在做加密的时候则会有一些局限，不过影响不大，还是我前面说的，如果想非常灵活的掌控一切，那还是自定义过滤器吧。这里我就先用这两个工具来实现了。</p><p>另外还有一点需要注意，ResponseBodyAdvice 在你使用了 @ResponseBody 注解的时候才会生效，RequestBodyAdvice 在你使用了 @RequestBody 注解的时候才会生效，换言之，前后端都是 JSON 交互的时候，这两个才有用。不过一般来说接口加解密的场景也都是前后端分离的时候才可能有的事。</p><p>先来看接口加密：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(EncryptProperties.class)</span><br><span class="line"><span class="hljs-meta">@ControllerAdvice</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptResponse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResponseBodyAdvice</span>&lt;<span class="hljs-title">RespBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    EncryptProperties encryptProperties;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> returnType.hasMethodAnnotation(Encrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">beforeBodyWrite</span><span class="hljs-params">(RespBean body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] keyBytes = encryptProperties.getKey().getBytes();</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (body.getMsg()!=<span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                body.setMsg(AESUtils.encrypt(body.getMsg().getBytes(),keyBytes));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (body.getObj() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                body.setObj(AESUtils.encrypt(om.writeValueAsBytes(body.getObj()), keyBytes));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自定义 EncryptResponse 类实现 ResponseBodyAdvice<respbean> 接口，泛型表示接口的返回类型，这里一共要实现两个方法：</respbean></p><ol><li>supports：这个方法用来判断什么样的接口需要加密，参数 returnType 表示返回类型，我们这里的判断逻辑就是方法是否含有 <code>@Encrypt</code> 注解，如果有，表示该接口需要加密处理，如果没有，表示该接口不需要加密处理。</li><li>beforeBodyWrite：这个方法会在数据响应之前执行，也就是我们先对响应数据进行二次处理，处理完成后，才会转成 json 返回。我们这里的处理方式很简单，RespBean 中的 status 是状态码就不用加密了，另外两个字段重新加密后重新设置值即可。</li><li>另外需要注意，自定义的 ResponseBodyAdvice 需要用 <code>@ControllerAdvice</code> 注解来标记。</li></ol><p>再来看接口解密：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(EncryptProperties.class)</span><br><span class="line"><span class="hljs-meta">@ControllerAdvice</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecryptRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestBodyAdviceAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    EncryptProperties encryptProperties;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> methodParameter.hasMethodAnnotation(Decrypt.class) || methodParameter.hasParameterAnnotation(Decrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HttpInputMessage <span class="hljs-title">beforeBodyRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] body = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inputMessage.getBody().available()];</span><br><span class="line">        inputMessage.getBody().read(body);</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">byte</span>[] decrypt = AESUtils.decrypt(body, encryptProperties.getKey().getBytes());</span><br><span class="line">            <span class="hljs-keyword">final</span> ByteArrayInputStream bais = <span class="hljs-keyword">new</span> ByteArrayInputStream(decrypt);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpInputMessage() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getBody</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> bais;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> HttpHeaders <span class="hljs-title">getHeaders</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> inputMessage.getHeaders();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先大家注意，DecryptRequest 类我们没有直接实现 <code>RequestBodyAdvice</code> 接口，而是继承自 RequestBodyAdviceAdapter 类，该类是 RequestBodyAdvice 接口的子类，并且实现了接口中的一些方法，这样当我们继承自 RequestBodyAdviceAdapter 时，就只需要根据自己实际需求实现某几个方法即可。</li><li>supports：该方法用来判断哪些接口需要处理接口解密，我们这里的判断逻辑是方法上或者参数上含有 <code>@Decrypt</code> 注解的接口，处理解密问题。</li><li>beforeBodyRead：这个方法会在参数转换成具体的对象之前执行，我们先从流中加载到数据，然后对数据进行解密，解密完成后再重新构造 HttpInputMessage 对象返回。</li></ol><p>接下来，我们再来定义一个自动化配置类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"org.javaboy.encrypt.starter"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也没啥好说的，比较简单。</p><p>最后，resources 目录下定义 META-INF，然后再定义 spring.factories 文件，内容如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=org.javaboy.encrypt.starter.autoconfig.EncryptAutoConfiguration</span><br></pre></td></tr></table></figure><p>这样当项目启动时，就会自动加载该配置类。</p><p>至此，我们的 starter 就开发完成啦。</p><h2 id="2-打包发布"><a href="#2-打包发布" class="headerlink" title="2.打包发布"></a>2.打包发布</h2><p>我们可以将项目安装到本地仓库，也可以发布到线上供他人使用。</p><h3 id="2-1-安装到本地仓库"><a href="#2-1-安装到本地仓库" class="headerlink" title="2.1 安装到本地仓库"></a>2.1 安装到本地仓库</h3><p>安装到本地仓库比较简单，直接 <code>mvn install</code>，或者在 IDEA 中，点击右边的 Maven，然后双击 install，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210309110308.png" alt></p><h3 id="2-2-发布到线上"><a href="#2-2-发布到线上" class="headerlink" title="2.2 发布到线上"></a>2.2 发布到线上</h3><p>发不到线上我们可以使用 JitPack 来做。</p><p>首先我们在 GitHub 上创建一个仓库，将我们的代码上传上去，这个过程应该不用我多说吧。</p><p>上传成功后，点击右边的 <code>Create a new release</code> 按钮，发布一个正式版，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210309111015.png" alt></p><p><img src="http://img.itboyhub.com/2021/02/20210309115344.png" alt></p><p>发布成功后，打开 jitpack，输入仓库的完整路径，点击 lookup 按钮，查找到之后，再点击 <code>Get it</code> 按钮完成构建，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210309115450.png" alt></p><p>构建成功后，JitPack 上会给出项目引用方式：</p><p><img src="http://img.itboyhub.com/2021/02/20210309111839.png" alt></p><p>注意引用时将 tag 改成你具体的版本号。</p><p>至此，我们的工具就已经成功发布了！小伙伴们可以通过如下方式引用这个 starter：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.lenve<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>encrypt-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jitpack.io<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://jitpack.io<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h2><p>我们创建一个普通的 Spring Boot 项目，引入 web 依赖，再引入我们刚刚的 starter 依赖，如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.github.lenve&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;encrypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;jitpack.io&lt;/id&gt;</span><br><span class="line">        &lt;url&gt;https:<span class="hljs-comment">//jitpack.io&lt;/url&gt;</span></span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure><p>然后再创建一个实体类备用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-meta">@Encrypt</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setId((<span class="hljs-keyword">long</span>) <span class="hljs-number">99</span>);</span><br><span class="line">        user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"ok"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">addUser</span><span class="hljs-params">(@RequestBody @Decrypt User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"ok"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个接口使用了 <code>@Encrypt</code> 注解，所以会对该接口的数据进行加密（如果不使用该注解就不加密），第二个接口使用了 <code>@Decrypt</code> 所以会对上传的参数进行解密，注意 <code>@Decrypt</code> 注解既可以放在方法上也可以放在参数上。</p><p>接下来启动项目进行测试。</p><p>首先测试 get 请求接口：</p><p><img src="http://img.itboyhub.com/2021/02/20210309120433.png" alt></p><p>可以看到，返回的数据已经加密。</p><p>再来测试 post 请求：</p><p><img src="http://img.itboyhub.com/2021/02/20210309120520.png" alt></p><p>可以看到，参数中的加密数据已经被还原了。</p><p>如果用户想要修改加密密钥，可以在 application.properties 中添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.encrypt.key=1234567890123456</span><br></pre></td></tr></table></figure><p>加密数据到了前端，前端也有一些 js 工具来处理加密数据，这个松哥后面有空再和大家说说 js 的加解密。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天这篇文章主要是想和大家聊聊 ResponseBodyAdvice 和 RequestBodyAdvice 的用法，一些加密思路，当然 ResponseBodyAdvice 和 RequestBodyAdvice 还有很多其他的使用场景，小伙伴们可以自行探索～本文使用了对称加密中的 AES 算法，大家也可以尝试改成非对称加密。</p><p>好啦，今天就聊这么多，小伙伴们可以去试试啦～公号后台回复 20210309 可以下载本文案例～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为有小伙伴刚好问到这个问题，松哥就抽空撸一篇文章和大家聊聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring5 里边的新玩法！这种 URL 请求让我涨见识了！</title>
    <link href="http://www.javaboy.org/2021/0307/springmvc-pathpattern.html"/>
    <id>http://www.javaboy.org/2021/0307/springmvc-pathpattern.html</id>
    <published>2021-03-07T14:41:20.000Z</published>
    <updated>2021-03-07T15:16:07.570Z</updated>
    
    <content type="html"><![CDATA[<p>Spring5 也已经出来好久了，里边有一些新玩法也需要我们去慢慢揭开面纱，这不，松哥最近在研究 SpringMVC 源码的时候，就看到这样一段代码：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">initLookupPath</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (usesPathPatterns()) &#123;</span><br><span class="line">request.removeAttribute(UrlPathHelper.PATH_ATTRIBUTE);</span><br><span class="line">RequestPath requestPath = ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">String lookupPath = requestPath.pathWithinApplication().value();</span><br><span class="line"><span class="hljs-keyword">return</span> UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getUrlPathHelper().resolveAndCacheLookupPath(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是 Spring5 里边出来的，以前是没有这个方法的。在旧的 SpringMVC 中，当我们需要获取当前请求地址的时候，直接通过如下方式获取：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String lookupPath = <span class="hljs-keyword">this</span>.getUrlPathHelper().getLookupPathForRequest(request);</span><br></pre></td></tr></table></figure><p>但是现在变了，现在获取当前请求 URL 地址时，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String lookupPath = initLookupPath(request);</span><br></pre></td></tr></table></figure><p>两种方式相比，主要是 initLookupPath 方法中多了 usesPathPatterns 选项，这是 Spring5 中的新玩意，所以今天松哥就通过一篇简单的文章来和大家分享一下 usesPathPatterns 到底是什么，该怎么玩！</p><p>这可不是一个小变化哦！特别是如果你在项目中使用了 WebFlux，那么这个东西就显得尤为重要了！</p><h2 id="AntPathMatcher"><a href="#AntPathMatcher" class="headerlink" title="AntPathMatcher"></a>AntPathMatcher</h2><p>当我们使用 @RequestMapping 注解去标记请求接口的时候（或者使用它的类似方法如 @GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping），我们可以使用一些通配符去匹配 URL 地址，举个简单例子，假设我有下面五个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello/**/hello"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/hello/**/hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/h?llo"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/h?llo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/**/*.html"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/**/*.html"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello/&#123;p1&#125;/&#123;p2&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello4</span><span class="hljs-params">(@PathVariable String p1, @PathVariable String p2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"p1 = "</span> + p1);</span><br><span class="line">    System.out.println(<span class="hljs-string">"p2 = "</span> + p2);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/hello/&#123;p1&#125;/&#123;p2&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(@PathVariable String name, @PathVariable String version, @PathVariable String ext)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    System.out.println(<span class="hljs-string">"version = "</span> + version);</span><br><span class="line">    System.out.println(<span class="hljs-string">"ext = "</span> + ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解释接口的含义之前，先来说说这几个通配符的含义：</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>**</code></td><td style="text-align:left">匹配0个或者多个目录</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配0个或者多个字符</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配任意单个字符</td></tr></tbody></table><p>了解了通配符的含义，我们再来说说各个接口都能接收哪些请求：</p><ul><li>第一个接口，可以接收诸如 <code>/hello/123/123/hello</code>、<code>/hello/a/hello</code> 以及 <code>/hello/hello</code> 这样的请求，因为中间的 <code>**</code> 代表 0 个或者多个目录。</li><li>第二个接口，可以接收诸如 <code>/hallo</code>、<code>/hello</code>、<code>/hMllo</code> 之类的请求，注意它不能接收 <code>/haallo</code> 或者 <code>/hllo</code>，因为 <code>?</code> 表示一个字符。</li><li>第三个接口可以接收任意以 <code>.html</code> 为后缀的请求，例如 <code>/aaa/bb/cc.html</code>、<code>/aa.html</code> 或者 <code>/aa/aa.html</code>。</li><li>第四个接口估计大家都比较熟悉，在 RESTful 风格的接口设计中估计大家都用过，它接收的请求格式类似于 <code>/hello/aa/bb</code>，其中参数 p1 就对应 aa，参数 p2 对应 bb。</li><li>第五个接口则用到了正则，name、version 以及 ext 三个参数格式用正则表达出来，它可以接收诸如 <code>/spring-web-3.0.5.jar</code> 格式的请求，最终的参数 name 就是 <code>spring-web</code>，version 就是 <code>3.0.5</code>，ext 则是 <code>.jar</code>。</li></ul><p>这是 SpringMVC 中之前就存在的功能，不管你用没用过，反正它一致存在。</p><p>那么是谁支撑了这个功能呢？那就是 AntPathMatcher。</p><p>AntPathMatcher 是一个实现了 Ant 风格的路径匹配器，Ant 风格的路径规则实际上就是我们前面给大家介绍的那三种路径匹配符，很 Easy。这种路径匹配规则源自 Apache Ant 项目（<a href="https://ant.apache.org），Apache" target="_blank" rel="noopener">https://ant.apache.org），Apache</a> Ant 我们现在其实已经很少会用到了，它的替代品就是大家所熟知的 Maven，如果你有幸维护一些 2010 年之前的老项目的话，有可能会接触到 Ant。</p><p>AntPathMatcher 实际上在 SpringMVC 中有非常广泛的应用，不仅仅是在 @RequestMapping 中定义接口用到，在其他一些涉及到地址匹配的地方也会用到，例如我们在 SpringMVC 的配置文件中配置静态资源过滤时，也是 Ant 风格路径匹配：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/**"</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>另外像拦截器里的拦截路径注册、跨域处理时的路径匹配等等，都会用到 Ant 风格的路径匹配符。</p><p>整体上来说，AntPathMatcher 是 Spring 中一种比较原始的路径匹配解决方案，虽然比较简单，但是它的效率很低，并且在处理 URL 编码的时候也很不方便。</p><p>因此，才有了 Spring5 中的 PathPattern。</p><h2 id="PathPattern"><a href="#PathPattern" class="headerlink" title="PathPattern"></a>PathPattern</h2><p>PathPattern 专为 Web 应用设计，它与之前的 AntPathMatcher 功能大部分比较类似，当然也有一些细微差异，这个松哥后面会说。</p><p>如果是 Servlet 应用，目前官方推荐的 URL 匹配解决方案就是 PathPattern（当然你也可以选择较早的 AntPathMatcher），虽然官方推荐的是 PathPattern，但实际上默认使用的依然是 AntPathMatcher；如果你用的是 WebFlux，PathPattern 就是唯一解决方案了。</p><blockquote><p>注意，PathPattern 是一个非常新鲜的玩艺，目前 Spring 最新版是 5.3.4，在 Spring5.3 之前，我们在 Servlet 应用中，也只能选择 AntPathMatcher，从 Spring5.3 之后，我们才可以使用 PathPattern 了。</p></blockquote><p>PathPattern 会将 URL 规则预解析为 PathContainer，它对 URL 地址匹配的处理更加快速，PathPattern 与 AntPathMatcher 的差异主要体现在两个方面：</p><p>第一，PathPattern 只支持结尾部分使用 <code>**</code>，如果在路径的中间使用 <code>**</code> 就会报错，上文中第一个和第三个接口，在 PathPattern 模式下会报错，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210306174530.png" alt></p><p>因为在中间或者开始使用 <code>**</code> 极易造成混乱，因此 PathPattern 只支持在结尾使用 <code>**</code>。</p><p>第二，PathPattern 支持使用诸如 <code>{*path}</code> 的方式进行路径匹配，这种写法也可以匹配到多层路径，并且将匹配到的值赋值给 path 变量，例如如下一个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/javaboy/&#123;*path&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello6</span><span class="hljs-params">(@PathVariable String path)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"path = "</span> + path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果请求路径是 <code>http://localhost:8080/javaboy/aa</code>，那么参数 path 的值就是 <code>/aa</code>；</p><p>如果请求路径是 <code>http://localhost:8080/javaboy/aa/bb/cc/dd</code>，那么参数 path 的值就是 <code>/aa/bb/cc/dd</code>；</p><p>这个写法也比较新颖，因为之前的 AntPathMatcher 里边没有这个。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>默认情况下，SpringMVC 中使用的还是 AntPathMatcher，那么如何开启 PathPattern 呢？很简单，在 SpringBoot 项目中只需要添加如下配置即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.setPatternParser(<span class="hljs-keyword">new</span> PathPatternParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了这个配置后，在我们文章一开始贴出来的代码里，就会进入到 if 分支中，进而使用 PathPattern 去解析请求 URL。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好啦，今天就和小伙伴们聊这么多，大家可以体验一把这个东东，不过注意选择 Spring 的版本哦，一定选择 5.3 之上的版本～大家周末愉快哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring5 也已经出来好久了，里边有一些新玩法也需要我们去慢慢揭开面纱，这不，松哥最近在研究 SpringMVC 源码的时候，就看到这样一段代码：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>来啦来啦，松哥的免费视频教程来啦！</title>
    <link href="http://www.javaboy.org/2021/0304/mybatis-video.html"/>
    <id>http://www.javaboy.org/2021/0304/mybatis-video.html</id>
    <published>2021-03-04T14:41:04.000Z</published>
    <updated>2021-03-07T15:08:10.346Z</updated>
    
    <content type="html"><![CDATA[<p>ssm 系列的最后一个专题 MyBatis 总算录完了，念叨了两年的 ssm 教程总算搞定了，其实真的认真做花不了多少时间，就是拖延症太可怕了。松哥亲身经历劝诫各位小伙伴，今日事今日毕，拖了一天就有可能拖一个月拖一年。。。</p><a id="more"></a><p>不说了，看干货吧，松哥最近加班加点录的，自认为讲的还比较详细，除了 MyBatis 最基本的用法，还带手把手教大家开发 MyBatis 插件，除了教大家用开源的 MyBatis 逆向工程，还手把手教大家自己开发 MyBatis 逆向工程，不废话了，赶紧来看看目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">├── 01.MyBatis 视频介绍.mp4</span><br><span class="line">├── 02.MyBatis 简单介绍.mp4</span><br><span class="line">├── 03.HelloWorld.mp4</span><br><span class="line">├── 04.SqlSessionFactory单例模式.mp4</span><br><span class="line">├── 05.通过 Log4j 查看 MyBatis 运行日志.mp4</span><br><span class="line">├── 06.MyBatis 增删改查.mp4</span><br><span class="line">├── 07.MyBatis 引入 Mapper.mp4</span><br><span class="line">├── 08.# 和 $ 的区别.mp4</span><br><span class="line">├── 09.Mapper 中多个参数如何处理.mp4</span><br><span class="line">├── 10.@Param 注解源码解析.mp4</span><br><span class="line">├── 11.Mapper 中使用实体类做参数.mp4</span><br><span class="line">├── 12.Mapper 中使用 Map 做参数.mp4</span><br><span class="line">├── 13.MyBatis 两种主键回填方式.mp4</span><br><span class="line">├── 14.resultType 玩法.mp4</span><br><span class="line">├── 15.resultMap 使用详解.mp4</span><br><span class="line">├── 16.【动态 SQL】之 if.mp4</span><br><span class="line">├── 17.【动态 SQL】之 choose.mp4</span><br><span class="line">├── 18.【动态 SQL】之 where.mp4</span><br><span class="line">├── 19.【动态 SQL】之 set.mp4</span><br><span class="line">├── 20.【动态 SQL】之 trim.mp4</span><br><span class="line">├── 21.【动态 SQL】之 foreach.mp4</span><br><span class="line">├── 22.【动态 SQL】之 bind.mp4</span><br><span class="line">├── 23.MyBatis 多数据库支持.mp4</span><br><span class="line">├── 24.查询结果一对一映射【1】.mp4</span><br><span class="line">├── 25.查询结果一对一映射【2】.mp4</span><br><span class="line">├── 26.查询结果一对一映射【3】.mp4</span><br><span class="line">├── 27.查询结果一对一映射【懒加载】.mp4</span><br><span class="line">├── 28.查询结果一对多映射.mp4</span><br><span class="line">├── 29.查询结果一对多映射【懒加载】.mp4</span><br><span class="line">├── 30.鉴别映射器.mp4</span><br><span class="line">├── 31.自定义类型转换器.mp4</span><br><span class="line">├── 32.MyBatis 一级缓存.mp4</span><br><span class="line">├── 33.MyBatis 二级缓存.mp4</span><br><span class="line">├── 34.MyBatis 使用 Redis 做缓存.mp4</span><br><span class="line">├── 35.MyBatis 内存分页.mp4</span><br><span class="line">├── 36.自定义 MyBatis 插件【1】.mp4</span><br><span class="line">├── 37.自定义 MyBatis 插件【2】.mp4</span><br><span class="line">├── 38.自定义 MyBatis 分页插件.mp4</span><br><span class="line">├── 39.MyBatis 逆向工程使用.mp4</span><br><span class="line">└── 40.SSM 整合.mp4</span><br><span class="line">├── 41.【自定义逆向工具】项目介绍.mp4</span><br><span class="line">├── 42.【自定义逆向工具】数据库连接.mp4</span><br><span class="line">├── 43.【自定义逆向工具】加载数据表信息.mp4</span><br><span class="line">├── 44.【自定义逆向工具】生成 Model.mp4</span><br><span class="line">├── 45.【自定义逆向工具】生成其他类.mp4</span><br></pre></td></tr></table></figure><p>视频的笔记、案例这次也会一并分享给大家，小伙伴们在公众号【江南一点雨】后台回复 <strong>mybatis</strong>，获取视频播放链接以及笔记、案例的下载链接。</p><p>Spring 和 SpringMVC 的免费视频松哥之前也已经发过了，大家可以在公众号【江南一点雨】后台回复 <strong>ssm</strong> 获取整个系列的学习资料～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ssm 系列的最后一个专题 MyBatis 总算录完了，念叨了两年的 ssm 教程总算搞定了，其实真的认真做花不了多少时间，就是拖延症太可怕了。松哥亲身经历劝诫各位小伙伴，今日事今日毕，拖了一天就有可能拖一个月拖一年。。。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 中的参数还能这么传递？涨姿势了！</title>
    <link href="http://www.javaboy.org/2021/0302/springmvc-flashmap.html"/>
    <id>http://www.javaboy.org/2021/0302/springmvc-flashmap.html</id>
    <published>2021-03-02T14:40:10.000Z</published>
    <updated>2021-03-07T15:08:16.098Z</updated>
    
    <content type="html"><![CDATA[<p>今天来聊一个 JavaWeb 中简单的话题，但是感觉却比较稀罕，因为这个技能点，有的小伙伴们可能没听过！</p><a id="more"></a><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1.缘起"></a>1.缘起</h2><p>说到 Web 请求参数传递，大家能想到哪些参数传递方式？</p><p>参数可以放在地址栏中，不过地址栏参数的长度有限制，并且在有的场景下我们可能不希望参数暴漏在地址栏中。参数可以放在请求体中，这个没啥好说的。</p><p>小伙伴们试想这样一个场景：</p><p>在一个电商项目中，有一个提交订单的请求，这个请求是一个 POST 请求，请求参数都在请求体中。当用户提交成功后，为了防止用户刷新浏览器页面造成订单请求重复提交，我们一般会将用户重定向到一个显示订单的页面，这样即使用户刷新页面，也不会造成订单请求重复提交。</p><p>大概的代码就像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">order</span><span class="hljs-params">(OrderInfo orderInfo)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//其他处理逻辑</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/orderlist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码我相信大家都懂吧！如果不懂可以看看松哥录制的免费的 SpringMVC 入门教程（<a href="https://mp.weixin.qq.com/s/KONEIdt_c3Di1zMlXGLxuw" target="_blank" rel="noopener">硬核！松哥又整了一套免费视频，搞起！</a>）。</p><p>但是这里有一个问题：如果我想传递参数怎么办？</p><p>如果是服务器端跳转，我们可以将参数放在 request 对象中，跳转完成后还能拿到参数，但是如果是客户端跳转我们就只能将参数放在地址栏中了，像上面这个方法的返回值我们可以写成：<code>return &quot;redirect:/orderlist?xxx=xxx&quot;;</code>，这种传参方式有两个缺陷：</p><ul><li>地址栏的长度是有限的，也就意味着能够放在地址栏中的参数是有限的。</li><li>不想将一些特殊的参数放在地址栏中。</li></ul><p>那该怎么办？还有办法传递参数吗？</p><p>有！这就是今天松哥要和大家介绍的 flashMap，专门用来解决重定向时参数的传递问题。</p><h2 id="2-flashMap"><a href="#2-flashMap" class="headerlink" title="2.flashMap"></a>2.flashMap</h2><p>在重定向时，如果需要传递参数，但是又不想放在地址栏中，我们就可以通过 flashMap 来传递参数，松哥先来一个简单的例子大家看看效果：</p><p>首先我们定义一个简单的页面，里边就一个 post 请求提交按钮，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/order"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在服务端接收该请求，并完成重定向：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">order</span><span class="hljs-params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        FlashMap flashMap = (FlashMap) req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE);</span><br><span class="line">        flashMap.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/orderlist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/orderlist"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">orderList</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (String) model.getAttribute(<span class="hljs-string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在 order 接口中，获取到 flashMap 属性，然后存入需要传递的参数，这些参数最终会被 SpringMVC 自动放入重定向接口的 Model 中，这样我们在 orderlist 接口中，就可以获取到该属性了。</p><p>当然，这是一个比较粗糙的写法，我们还可以通过 RedirectAttributes 来简化这一步骤：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">order</span><span class="hljs-params">(RedirectAttributes attr)</span> </span>&#123;</span><br><span class="line">        attr.addFlashAttribute(<span class="hljs-string">"site"</span>, <span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        attr.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"微信公众号：江南一点雨"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/orderlist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/orderlist"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">orderList</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (String) model.getAttribute(<span class="hljs-string">"site"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedirectAttributes 中有两种添加参数的方式：</p><ul><li>addFlashAttribute：将参数放到 flashMap 中。</li><li>addAttribute：将参数放到 URL 地址中。</li></ul><p>经过前面的讲解，现在小伙伴们应该大致明白了 flashMap 的作用了，就是在你进行重定向的时候，不通过地址栏传递参数。</p><p>很多小伙伴可能会有疑问，重定向其实就是浏览器发起了一个新的请求，这新的请求怎么就获取到上一个请求保存的参数呢？这我们就要来看看 SpringMVC 的源码了。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><p>首先这里涉及到一个关键类叫做 FlashMapManager，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlashMapManager</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">FlashMap <span class="hljs-title">retrieveAndUpdate</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveOutputFlashMap</span><span class="hljs-params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法含义一眼就能看出来：</p><ul><li>retrieveAndUpdate：这个方法用来恢复参数，并将恢复过的的参数和超时的参数从保存介质中删除。</li><li>saveOutputFlashMap：将参数保存保存起来。</li></ul><p>FlashMapManager 的实现类如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210301173455.png" alt></p><p>从这个继承类中，我们基本上就能确定默认的保存介质时 session。具体的保存逻辑则是在 AbstractFlashMapManager 类中。</p><p>整个参数传递的过程可以分为三大步：</p><p>第一步，首先我们将参数设置到 outputFlashMap 中，有两种设置方式：我们前面的代码 <code>req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE)</code> 就是直接获取 outputFlashMap 对象然后把参数放进去；第二种方式就是通过在接口中添加 RedirectAttributes 参数，然后把需要传递的参数放入 RedirectAttributes 中，这样当处理器处理完毕后，会自动将其设置到 outputFlashMap 中，具体逻辑在 RequestMappingHandlerAdapter#getModelAndView 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title">getModelAndView</span><span class="hljs-params">(ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (model <span class="hljs-keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (request != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果 model 是 RedirectAttributes 的实例的话，则通过 getOutputFlashMap 方法获取到 outputFlashMap 属性，然后相关的属性设置进去。</p><p>这是第一步，就是将需要传递的参数，先保存到 flashMap 中。</p><p>第二步，重定向对应的视图是 RedirectView，在它的 renderMergedOutputModel 方法中，会调用 FlashMapManager 的 saveOutputFlashMap 方法，将 outputFlashMap 保存到 session 中，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renderMergedOutputModel</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String targetUrl = createTargetUrl(model, request);</span><br><span class="line">targetUrl = updateTargetUrl(targetUrl, model, request, response);</span><br><span class="line"><span class="hljs-comment">// Save flash attributes</span></span><br><span class="line">RequestContextUtils.saveOutputFlashMap(targetUrl, request, response);</span><br><span class="line"><span class="hljs-comment">// Redirect</span></span><br><span class="line">sendRedirect(request, response, targetUrl, <span class="hljs-keyword">this</span>.http10Compatible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestContextUtils.saveOutputFlashMap 方法最终就会调用到 FlashMapManager 的 saveOutputFlashMap 方法，将 outputFlashMap 保存下来。我们来大概看一下保存逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveOutputFlashMap</span><span class="hljs-params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(flashMap)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String path = decodeAndNormalizePath(flashMap.getTargetRequestPath(), request);</span><br><span class="line">flashMap.setTargetRequestPath(path);</span><br><span class="line">flashMap.startExpirationPeriod(getFlashMapTimeout());</span><br><span class="line">Object mutex = getFlashMapsMutex(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (mutex != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line">allFlashMaps = (allFlashMaps != <span class="hljs-keyword">null</span> ? allFlashMaps : <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;());</span><br><span class="line">allFlashMaps.add(flashMap);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line">allFlashMaps = (allFlashMaps != <span class="hljs-keyword">null</span> ? allFlashMaps : <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>));</span><br><span class="line">allFlashMaps.add(flashMap);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的逻辑也很简单，保存之前会给 flashMap 设置两个属性，一个是重定向的 url 地址，另一个则是过期时间，过期时间默认 180 秒，这两个属性在第三步加载 flashMap 的时候会用到。然后将 flashMap 放入集合中，并调用 updateFlashMaps 方法存入 session 中。</p><p>第三步，当重定向请求到达 DispatcherServlet#doService 方法后，此时会调用 FlashMapManager#retrieveAndUpdate 方法从 Session 中获取 outputFlashMap 并设置到 Request 属性中备用（最终会被转化到 Model 中的属性），相关代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里获取出来的 outputFlashMap 换了一个名字，变成了 inputFlashMap，其实是同一个东西。</p><p>我们可以大概看一下获取的逻辑 AbstractFlashMapManager#retrieveAndUpdate：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> FlashMap <span class="hljs-title">retrieveAndUpdate</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(allFlashMaps)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;FlashMap&gt; mapsToRemove = getExpiredFlashMaps(allFlashMaps);</span><br><span class="line">FlashMap match = getMatchingFlashMap(allFlashMaps, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (match != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mapsToRemove.add(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!mapsToRemove.isEmpty()) &#123;</span><br><span class="line">Object mutex = getFlashMapsMutex(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (mutex != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (allFlashMaps != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">allFlashMaps.removeAll(mapsToRemove);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">allFlashMaps.removeAll(mapsToRemove);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用 retrieveFlashMaps 方法从 session 中获取到所有的 FlashMap。</li><li>调用 getExpiredFlashMaps 方法获取所有过期的 FlashMap，FlashMap 默认的过期时间是 180s。</li><li>获取和当前请求匹配的 getMatchingFlashMap，具体的匹配逻辑就两点：重定向地址要和当前请求地址相同；预设参数要相同。一般来说我们不需要配置预设参数，所以这一条可以忽略。如果想要设置，则首先给 flashMap 设置，像这样：<code>flashMap.addTargetRequestParam(&quot;aa&quot;, &quot;bb&quot;);</code>，然后在重定向的地址栏也加上这个参数：<code>return &quot;redirect:/orderlist?aa=bb&quot;;</code> 即可。</li><li>将获取到的匹配的 FlashMap 对象放入 mapsToRemove 集合中（这个匹配到的 FlashMap 即将失效，放入集合中一会被清空）。</li><li>将 allFlashMaps 集合中的所有 mapsToRemove 数据清空，同时调用 updateFlashMaps 方法更新 session 中的 FlashMap。</li><li>最终将匹配到的 flashMap 返回。</li></ul><p>这就是整个获取 flashMap 的方法，整体来看还是非常 easy 的，并没有什么难点。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和小伙伴们分享了一下 SpringMVC 中的 flashMap，不知道大家有没有在工作中用到这个东西？如果刚好碰到松哥前面所说的需求，用 FlashMap 真的还是蛮方便的。如果需要下载本文案例，小伙伴们可以在公众号后台回复 <code>20210302</code>，好啦，今天就和大家聊这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来聊一个 JavaWeb 中简单的话题，但是感觉却比较稀罕，因为这个技能点，有的小伙伴们可能没听过！&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你开发 MyBatis 插件</title>
    <link href="http://www.javaboy.org/2021/0226/mybatis-plugin.html"/>
    <id>http://www.javaboy.org/2021/0226/mybatis-plugin.html</id>
    <published>2021-02-26T14:39:55.000Z</published>
    <updated>2021-03-07T15:08:01.401Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴们元宵节快乐，记得吃元宵哦～</p><a id="more"></a><p>在日常开发中，小伙伴们多多少少都有用过 MyBatis 插件，松哥猜测大家用的最多的就是 MyBatis 的分页插件！不知道小伙伴们有没有想过有一天自己也来开发一个 MyBatis 插件？</p><p>其实自己动手撸一个 MyBatis 插件并不难，今天松哥就把手带大家撸一个 MyBatis 插件！</p><h2 id="1-MyBatis-插件接口"><a href="#1-MyBatis-插件接口" class="headerlink" title="1.MyBatis 插件接口"></a>1.MyBatis 插件接口</h2><p>即使你没开发过 MyBatis 插件，估计也能猜出来，MyBatis 插件是通过拦截器来起作用的，MyBatis 框架在设计的时候，就已经为插件的开发预留了相关接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中就三个方法，第一个方法必须实现，后面两个方法都是可选的。三个方法作用分别如下：</p><ol><li><p>intercept：这个就是具体的拦截方法，我们自定义 MyBatis 插件时，一般都需要重写该方法，我们插件所完成的工作也都是在该方法中完成的。</p></li><li><p>plugin：这个方法的参数 target 就是拦截器要拦截的对象，一般来说我们不需要重写该方法。Plugin.wrap 方法会自动判断拦截器的签名和被拦截对象的接口是否匹配，如果匹配，才会通过动态代理拦截目标对象。</p></li><li><p>setProperties：这个方法用来传递插件的参数，可以通过参数来改变插件的行为。我们定义好插件之后，需要对插件进行配置，在配置的时候，可以给插件设置相关属性，设置的属性可以通过该方法获取到。插件属性设置像下面这样：</p></li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"org.javaboy.mybatis03.plugin.CamelInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"xxx"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-MyBatis-拦截器签名"><a href="#2-MyBatis-拦截器签名" class="headerlink" title="2.MyBatis 拦截器签名"></a>2.MyBatis 拦截器签名</h2><p>拦截器定义好了后，拦截谁？</p><p>这个就需要拦截器签名来完成了！</p><p>拦截器签名是一个名为 @Intercepts 的注解，该注解中可以通过 @Signature 配置多个签名。@Signature 注解中则包含三个属性：</p><ul><li>type: 拦截器需要拦截的接口，有 4 个可选项，分别是：Executor、ParameterHandler、ResultSetHandler 以及 StatementHandler。</li><li>method: 拦截器所拦截接口中的方法名，也就是前面四个接口中的方法名，接口和方法要对应上。</li><li>args: 拦截器所拦截方法的参数类型，通过方法名和参数类型可以锁定唯一一个方法。</li></ul><p>一个简单的签名可能像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Intercepts</span>(<span class="hljs-meta">@Signature</span>(</span><br><span class="line">        type = ResultSetHandler.class,</span><br><span class="line">        method = <span class="hljs-string">"handleResultSets"</span>,</span><br><span class="line">        args = &#123;Statement.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CamelInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-被拦截的对象"><a href="#3-被拦截的对象" class="headerlink" title="3.被拦截的对象"></a>3.被拦截的对象</h2><p>根据前面的介绍，被拦截的对象主要有如下四个：</p><p><strong>Executor</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ResultHandler NO_RESULT_HANDLER = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(MappedStatement ms, Object parameter)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">Cursor&lt;E&gt; <span class="hljs-title">queryCursor</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">List&lt;BatchResult&gt; <span class="hljs-title">flushStatements</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> required)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> required)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">CacheKey <span class="hljs-title">createCacheKey</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCached</span><span class="hljs-params">(MappedStatement ms, CacheKey key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearLocalCache</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deferLoad</span><span class="hljs-params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Transaction <span class="hljs-title">getTransaction</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceRollback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isClosed</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setExecutorWrapper</span><span class="hljs-params">(Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>update：该方法会在所有的 INSERT、 UPDATE、 DELETE 执行时被调用，如果想要拦截这些操作，可以通过该方法实现。</li><li>query：该方法会在 SELECT 查询方法执行时被调用，方法参数携带了很多有用的信息，如果需要获取，可以通过该方法实现。</li><li>queryCursor：当 SELECT 的返回类型是 Cursor 时，该方法会被调用。</li><li>flushStatements：当 SqlSession 方法调用 flushStatements 方法或执行的接口方法中带有 @Flush 注解时该方法会被触发。</li><li>commit：当 SqlSession 方法调用 commit 方法时该方法会被触发。</li><li>rollback：当 SqlSession 方法调用 rollback 方法时该方法会被触发。</li><li>getTransaction：当 SqlSession 方法获取数据库连接时该方法会被触发。</li><li>close：该方法在懒加载获取新的 Executor 后会被触发。</li><li>isClosed：该方法在懒加载执行查询前会被触发。</li></ul><p><strong>ParameterHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ParameterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Object <span class="hljs-title">getParameterObject</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParameters</span><span class="hljs-params">(PreparedStatement ps)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>getParameterObject：在执行存储过程处理出参的时候该方法会被触发。</li><li>setParameters：设置 SQL 参数时该方法会被触发。</li></ul><p><strong>ResultSetHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">handleResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">Cursor&lt;E&gt; <span class="hljs-title">handleCursorResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleOutputParameters</span><span class="hljs-params">(CallableStatement cs)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>handleResultSets：该方法会在所有的查询方法中被触发（除去返回值类型为 Cursor<e> 的查询方法），一般来说，如果我们想对查询结果进行二次处理，可以通过拦截该方法实现。</e></li><li>handleCursorResultSets：当查询方法的返回值类型为 Cursor<e> 时，该方法会被触发。</e></li><li>handleOutputParameters：使用存储过程处理出参的时候该方法会被调用。</li></ul><p><strong>StatementHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Statement <span class="hljs-title">prepare</span><span class="hljs-params">(Connection connection, Integer transactionTimeout)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parameterize</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">batch</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">Cursor&lt;E&gt; <span class="hljs-title">queryCursor</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">BoundSql <span class="hljs-title">getBoundSql</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">ParameterHandler <span class="hljs-title">getParameterHandler</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>prepare：该方法在数据库执行前被触发。</li><li>parameterize：该方法在 prepare 方法之后执行，用来处理参数信息。</li><li>batch：如果 MyBatis 的全剧配置中配置了 <code>defaultExecutorType=”BATCH”</code>，执行数据操作时该方法会被调用。</li><li>update：更新操作时该方法会被触发。</li><li>query：该方法在 SELECT 方法执行时会被触发。</li><li>queryCursor：该方法在 SELECT 方法执行时，并且返回值为 Cursor 时会被触发。</li></ul><p>在开发一个具体的插件时，我们应当根据自己的需求来决定到底拦截哪个方法。</p><h2 id="4-开发分页插件"><a href="#4-开发分页插件" class="headerlink" title="4.开发分页插件"></a>4.开发分页插件</h2><h3 id="4-1-内存分页"><a href="#4-1-内存分页" class="headerlink" title="4.1 内存分页"></a>4.1 内存分页</h3><p>MyBatis 中提供了一个不太好用的内存分页功能，就是一次性把所有数据都查询出来，然后在内存中进行分页处理，这种分页方式效率很低，基本上没啥用，但是如果我们想要自定义分页插件，就需要对这种分页方式有一个简单了解。</p><p>内存分页的使用方式如下，首先在 Mapper 中添加 RowBounds 参数，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsersByPage</span><span class="hljs-params">(RowBounds rowBounds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中定义相关 SQL：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUsersByPage"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.mybatis03.model.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在 SQL 定义时，压根不用管分页的事情，MyBatis 会查询到所有的数据，然后在内存中进行分页处理。</p><p>Mapper 中方法的调用方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class);</span><br><span class="line">    RowBounds rowBounds = <span class="hljs-keyword">new</span> RowBounds(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.getAllUsersByPage(rowBounds);</span><br><span class="line">    <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建 RowBounds 时传入两个参数，分别是 offset 和 limit，对应分页 SQL 中的两个参数。也可以通过 RowBounds.DEFAULT 的方式构建一个 RowBounds 实例，这种方式构建出来的 RowBounds 实例，offset 为 0，limit 则为 Integer.MAX_VALUE，也就相当于不分页。</p><p>这就是 MyBatis 中提供的一个很不实用的内存分页功能。</p><p>了解了 MyBatis 自带的内存分页之后，接下来我们就可以来看看如何自定义分页插件了。</p><h3 id="4-2-自定义分页插件"><a href="#4-2-自定义分页插件" class="headerlink" title="4.2 自定义分页插件"></a>4.2 自定义分页插件</h3><p>首先要声明一下，这里松哥带大家自定义 MyBatis 分页插件，主要是想通过这个东西让小伙伴们了解自定义 MyBatis 插件的一些条条框框，了解整个自定义插件的流程，分页插件并不是我们的目的，自定义分页插件只是为了让大家的学习过程变得有趣一些而已。</p><p>接下来我们就来开启自定义分页插件之旅。</p><p>首先我们需要自定义一个 RowBounds，因为 MyBatis 原生的 RowBounds 是内存分页，并且没有办法获取到总记录数（一般分页查询的时候我们还需要获取到总记录数），所以我们自定义 PageRowBounds，对原生的 RowBounds 功能进行增强，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageRowBounds</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RowBounds</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long total;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageRowBounds</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageRowBounds</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTotal</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotal</span><span class="hljs-params">(Long total)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们自定义的 PageRowBounds 中增加了 total 字段，用来保存查询的总记录数。</p><p>接下来我们自定义拦截器 PageInterceptor，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Intercepts</span>(<span class="hljs-meta">@Signature</span>(</span><br><span class="line">        type = Executor.class,</span><br><span class="line">        method = <span class="hljs-string">"query"</span>,</span><br><span class="line">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line">        MappedStatement ms = (MappedStatement) args[<span class="hljs-number">0</span>];</span><br><span class="line">        Object parameterObject = args[<span class="hljs-number">1</span>];</span><br><span class="line">        RowBounds rowBounds = (RowBounds) args[<span class="hljs-number">2</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span> (rowBounds != RowBounds.DEFAULT) &#123;</span><br><span class="line">            Executor executor = (Executor) invocation.getTarget();</span><br><span class="line">            BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">            Field additionalParametersField = BoundSql.class.getDeclaredField(<span class="hljs-string">"additionalParameters"</span>);</span><br><span class="line">            additionalParametersField.setAccessible(<span class="hljs-keyword">true</span>);</span><br><span class="line">            Map&lt;String, Object&gt; additionalParameters = (Map&lt;String, Object&gt;) additionalParametersField.get(boundSql);</span><br><span class="line">            <span class="hljs-keyword">if</span> (rowBounds <span class="hljs-keyword">instanceof</span> PageRowBounds) &#123;</span><br><span class="line">                MappedStatement countMs = newMappedStatement(ms, Long.class);</span><br><span class="line">                CacheKey countKey = executor.createCacheKey(countMs, parameterObject, RowBounds.DEFAULT, boundSql);</span><br><span class="line">                String countSql = <span class="hljs-string">"select count(*) from ("</span> + boundSql.getSql() + <span class="hljs-string">") temp"</span>;</span><br><span class="line">                BoundSql countBoundSql = <span class="hljs-keyword">new</span> BoundSql(ms.getConfiguration(), countSql, boundSql.getParameterMappings(), parameterObject);</span><br><span class="line">                Set&lt;String&gt; keySet = additionalParameters.keySet();</span><br><span class="line">                <span class="hljs-keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">                    countBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Object&gt; countQueryResult = executor.query(countMs, parameterObject, RowBounds.DEFAULT, (ResultHandler) args[<span class="hljs-number">3</span>], countKey, countBoundSql);</span><br><span class="line">                Long count = (Long) countQueryResult.get(<span class="hljs-number">0</span>);</span><br><span class="line">                ((PageRowBounds) rowBounds).setTotal(count);</span><br><span class="line">            &#125;</span><br><span class="line">            CacheKey pageKey = executor.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">            pageKey.update(<span class="hljs-string">"RowBounds"</span>);</span><br><span class="line">            String pageSql = boundSql.getSql() + <span class="hljs-string">" limit "</span> + rowBounds.getOffset() + <span class="hljs-string">","</span> + rowBounds.getLimit();</span><br><span class="line">            BoundSql pageBoundSql = <span class="hljs-keyword">new</span> BoundSql(ms.getConfiguration(), pageSql, boundSql.getParameterMappings(), parameterObject);</span><br><span class="line">            Set&lt;String&gt; keySet = additionalParameters.keySet();</span><br><span class="line">            <span class="hljs-keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">                pageBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">            List list = executor.query(ms, parameterObject, RowBounds.DEFAULT, (ResultHandler) args[<span class="hljs-number">3</span>], pageKey, pageBoundSql);</span><br><span class="line">            <span class="hljs-keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//不需要分页，直接返回结果</span></span><br><span class="line">        <span class="hljs-keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> MappedStatement <span class="hljs-title">newMappedStatement</span><span class="hljs-params">(MappedStatement ms, Class&lt;Long&gt; longClass)</span> </span>&#123;</span><br><span class="line">        MappedStatement.Builder builder = <span class="hljs-keyword">new</span> MappedStatement.Builder(</span><br><span class="line">                ms.getConfiguration(), ms.getId() + <span class="hljs-string">"_count"</span>, ms.getSqlSource(), ms.getSqlCommandType()</span><br><span class="line">        );</span><br><span class="line">        ResultMap resultMap = <span class="hljs-keyword">new</span> ResultMap.Builder(ms.getConfiguration(), ms.getId(), longClass, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">0</span>)).build();</span><br><span class="line">        builder.resource(ms.getResource())</span><br><span class="line">                .fetchSize(ms.getFetchSize())</span><br><span class="line">                .statementType(ms.getStatementType())</span><br><span class="line">                .timeout(ms.getTimeout())</span><br><span class="line">                .parameterMap(ms.getParameterMap())</span><br><span class="line">                .resultSetType(ms.getResultSetType())</span><br><span class="line">                .cache(ms.getCache())</span><br><span class="line">                .flushCacheRequired(ms.isFlushCacheRequired())</span><br><span class="line">                .useCache(ms.isUseCache())</span><br><span class="line">                .resultMaps(Arrays.asList(resultMap));</span><br><span class="line">        <span class="hljs-keyword">if</span> (ms.getKeyProperties() != <span class="hljs-keyword">null</span> &amp;&amp; ms.getKeyProperties().length &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            StringBuilder keyProperties = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="hljs-keyword">for</span> (String keyProperty : ms.getKeyProperties()) &#123;</span><br><span class="line">                keyProperties.append(keyProperty).append(<span class="hljs-string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            keyProperties.delete(keyProperties.length() - <span class="hljs-number">1</span>, keyProperties.length());</span><br><span class="line">            builder.keyProperty(keyProperties.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们今天定义的核心代码，涉及到的知识点松哥来给大家一个一个剖析。</p><ol><li>首先通过 @Intercepts 注解配置拦截器签名，从 @Signature 的定义中我们可以看到，拦截的是 Executor#query 方法，该方法有一个重载方法，通过 args 指定了方法参数，进而锁定了重载方法（实际上该方法的另一个重载方法我们没法拦截，那个是 MyBatis 内部调用的，这里不做讨论）。</li><li>将查询操作拦截下来之后，接下来我们的操作主要在 PageInterceptor#intercept 方法中完成，该方法的参数重包含了拦截对象的诸多信息。</li><li>通过 <code>invocation.getArgs()</code> 获取拦截方法的参数，获取到的是一个数组，正常来说这个数组的长度为 4。数组第一项是一个 MappedStatement，我们在 Mapper.xml 中定义的各种操作节点和 SQL，都被封装成一个个的 MappedStatement 对象了；数组第二项就是所拦截方法的具体参数，也就是你在 Mapper 接口中定义的方法参数；数组的第三项是一个 RowBounds 对象，我们在 Mapper 接口中定义方法时不一定使用了 RowBounds 对象，如果我们没有定义 RowBounds 对象，系统会给我们提供一个默认的 RowBounds.DEFAULT；数组第四项则是一个处理返回值的 ResultHandler。</li><li>接下来判断上一步提取到的 rowBounds 对象是否不为 RowBounds.DEFAULT，如果为 RowBounds.DEFAULT，说明用户不想分页；如果不为 RowBounds.DEFAULT，则说明用户想要分页，如果用户不想分页，则直接执行最后的 <code>return invocation.proceed();</code>，让方法继续往下走就行了。</li><li>如果需要进行分页，则先从 invocation 对象中取出执行器 Executor、BoundSql 以及通过反射拿出来 BoundSql 中保存的额外参数（如果我们使用了动态 SQL，可能会存在该参数）。BoundSql 中封装了我们执行的 Sql 以及相关的参数。</li><li>接下来判断 rowBounds 是否是 PageRowBounds 的实例，如果是，说明除了分页查询，还想要查询总记录数，如果不是，则说明 rowBounds 可能是 RowBounds 实例，此时只要分页即可，不用查询总记录数。</li><li>如果需要查询总记录数，则首先调用 newMappedStatement 方法构造出一个新的 MappedStatement 对象出来，这个新的 MappedStatement 对象的返回值是 Long 类型的。然后分别创建查询的 CacheKey、拼接查询的 countSql，再根据 countSql 构建出 countBoundSql，再将额外参数添加进 countBoundSql 中。最后通过 executor.query 方法完成查询操作，并将查询结果赋值给 PageRowBounds 中的 total 属性。</li><li>接下来进行分页查询，有了第七步的介绍之后，分页查询就很简单了，这里就不细说了，唯一需要强调的是，当我们启动了这个分页插件之后，MyBatis 原生的 RowBounds 内存分页会变成物理分页，原因就在这里我们修改了查询 SQL。</li><li>最后将查询结果返回。</li></ol><p>在前面的代码中，我们一共在两个地方重新组织了 SQL，一个是查询总记录数的时候，另一个则是分页的时候，都是通过 boundSql.getSql() 获取到 Mapper.xml 中的 SQL 然后进行改装，有的小伙伴在 Mapper.xml 中写 SQL 的时候不注意，结尾可能加上了 <code>;</code>，这会导致分页插件重新组装的 SQL 运行出错，这点需要注意。松哥在 GitHub 上看到的其他 MyBatis 分页插件也是一样的，Mapper.xml 中 SQL 结尾不能有 <code>;</code>。</p><p>如此之后，我们的分页插件就算是定义成功了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>接下来我们对我们的分页插件进行一个简单测试。</p><p>首先我们需要在全局配置中配置分页插件，配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"org.javaboy.mybatis03.plugin.PageInterceptor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们在 Mapper 中定义查询接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsersByPage</span><span class="hljs-params">(RowBounds rowBounds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义 UserMapper.xml，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUsersByPage"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.mybatis03.model.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后我们进行测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; list = userMapper.getAllUsersByPage(<span class="hljs-keyword">new</span> RowBounds(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));</span><br><span class="line">    <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在查询时，我们使用了 RowBounds 对象，就只会进行分页，而不会统计总记录数。需要注意的时，此时的分页已经不是内存分页，而是物理分页了，这点我们从打印出来的 SQL 中也能看到，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210224164138.png" alt></p><p>可以看到，查询的时候就已经进行了分页了。</p><p>当然，我们也可以使用 PageRowBounds 进行测试，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class);</span><br><span class="line">    PageRowBounds pageRowBounds = <span class="hljs-keyword">new</span> PageRowBounds(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.getAllUsersByPage(pageRowBounds);</span><br><span class="line">    <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="hljs-string">"pageRowBounds.getTotal() = "</span> + pageRowBounds.getTotal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时通过 pageRowBounds.getTotal() 方法我们就可以获取到总记录数。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好啦，今天主要和小伙伴们分享了我们如何自己开发一个 MyBatis 插件，插件功能其实都是次要的，最主要是希望小伙伴们能够理解 MyBatis 的工作流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴们元宵节快乐，记得吃元宵哦～&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
      <category term="Plugin" scheme="http://www.javaboy.org/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>硬核！松哥又整了一套免费视频，搞起！</title>
    <link href="http://www.javaboy.org/2021/0223/springmvc-video.html"/>
    <id>http://www.javaboy.org/2021/0223/springmvc-video.html</id>
    <published>2021-02-23T14:39:41.000Z</published>
    <updated>2021-03-07T15:09:02.697Z</updated>
    
    <content type="html"><![CDATA[<p>不知道小伙伴们过年期间玩的好不好，松哥刚回家拿两天还蛮舒服的，时间久了又觉得无聊了，作为程序员，解决无聊的办法就是 Coding！于是，一个拖延很久的计划终于被松哥拾起来了，录一套<strong>免费的</strong> SSM 视频。</p><a id="more"></a><p>松哥从大二开始自学 Java，大学毕业后顺利入坑，自学之路还是蛮艰辛的。所以我深知大家在自学时面临的两个问题：</p><ol><li>学习顺序</li><li>学习资料</li></ol><p>首先是不知道学什么，这个我之前已经总结了 Java 升级路线图（<a href="https://mp.weixin.qq.com/s/rBRFL2UcDKWB-bHp324mCw" target="_blank" rel="noopener">Java 打怪升级路线图</a>），大家可以参考。</p><p>第二个就是学习资料的问题，虽然现在网上的资料多如牛毛，但是很多时候我们缺的不是一个资料，<strong>我们缺的是一个从头到尾连贯的、系统的资料</strong>，经常是这个人讲的看了一点，那个人讲的看了一点，想头到尾看一个人讲，发现几乎没有这样的资源。</p><p>如果是一个人来讲，知识是连贯的，什么东西讲过，什么东西没讲过，他心里有数，这样大家的学习的时候就不会觉得突兀，比如突然蹦出来一个你从来没听说过的知识点，一个人讲的话，就不会发生这种事情，学习体验也会好很多，也会更加容易构建自己的知识体系。</p><p>所以松哥很早就想根据自己整理的 Java 学习路线图（公号后台回复 <code>进阶路线</code> 获取 Java 进阶路线图）录一套 Java 视频教程，可是由于拖延症一直进展缓慢。在 2021 年，希望能把这项工作扎实推进，也希望小伙伴们对继续保持关注，录制好的视频我会第一时间在公众号上告诉大家。</p><p>现在这套 SSM 视频，在去年 6 月份已经发布了 Spring 部分，相关链接参见：</p><p><a href="https://mp.weixin.qq.com/s/aj9Bt1TE1pb8ZPVCpDKI8A" target="_blank" rel="noopener">我为什么要出一套免费视频教程</a></p><p>这次休假期间，我主要是录制了 SpringMVC 部分，一共录制了三十多集约 6 个小时的视频教程，教程目录如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">├── 01.SpringMVC 免费视频录制计划.mp4</span><br><span class="line">├── 02.SpringMVC 简单介绍.mp4</span><br><span class="line">├── 03.SpringMVC 之 HelloWorld.mp4</span><br><span class="line">├── 04.SpringMVC 组件简单介绍.mp4</span><br><span class="line">├── 05.DispatcherServlet 配置细节.mp4</span><br><span class="line">├── 06.Spring+SpringMVC 分开配置.mp4</span><br><span class="line">├── 07.Spring 容器和 SpringMVC 容器.mp4</span><br><span class="line">├── 08.处理器映射器与处理器适配器.mp4</span><br><span class="line">├── 09.处理器映射器与处理器适配器最佳实践.mp4</span><br><span class="line">├── 10.@RequestMapping 注解使用细节.mp4</span><br><span class="line">├── 11.Controller 中接口方法各种返回值类型.mp4</span><br><span class="line">├── 12.【Spring MVC参数绑定】默认参数.mp4</span><br><span class="line">├── 13.【Spring MVC参数绑定】基本类型参数.mp4</span><br><span class="line">├── 14.【Spring MVC参数绑定】对象参数.mp4</span><br><span class="line">├── 15.【Spring MVC参数绑定】自定义参数类型转换器.mp4</span><br><span class="line">├── 16.【Spring MVC参数绑定】数组类型.mp4</span><br><span class="line">├── 17.【Spring MVC参数绑定】List 集合类型.mp4</span><br><span class="line">├── 18.【Spring MVC参数绑定】Map 集合类型.mp4</span><br><span class="line">├── 19.SpringMVC 文件上传【上古方案】.mp4</span><br><span class="line">├── 20.SpringMVC 文件上传【最新方案】.mp4</span><br><span class="line">├── 21.SpringMVC 多文件上传.mp4</span><br><span class="line">├── 22.SpringMVC 全局异常处理.mp4</span><br><span class="line">├── 23.SpringMVC 数据校验.mp4</span><br><span class="line">├── 24.SpringMVC 数据分组校验.mp4</span><br><span class="line">├── 25.手动数据回显.mp4</span><br><span class="line">├── 26.自动数据回显.mp4</span><br><span class="line">├── 27.@ModelAttribute注解用法.mp4</span><br><span class="line">├── 28.SpringMVC+Jackson生成 JSON 数据.mp4</span><br><span class="line">├── 29.SpringMVC+Gson生成 JSON 数据.mp4</span><br><span class="line">├── 30.SpringMVC+FastJson生成 JSON 数据.mp4</span><br><span class="line">├── 31.SpringMVC 接收 JSON 类型参数.mp4</span><br><span class="line">├── 32.SpringMVC 开发 RESTful 接口.mp4</span><br><span class="line">├── 33.SpringMVC 静态资源访问.mp4</span><br><span class="line">└── 34.SpringMVC 中使用拦截器.mp4</span><br></pre></td></tr></table></figure><p>视频的笔记、案例这次我都一并分享给小伙伴们，大家在公众号后台回复 <code>springmvc</code> 就可以获取视频播放链接、视频笔记以及视频案例。</p><p>下一步就是 MyBatis 了，最近也在抽空录制了，估计很快会和小伙伴们见面，敬请期待～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道小伙伴们过年期间玩的好不好，松哥刚回家拿两天还蛮舒服的，时间久了又觉得无聊了，作为程序员，解决无聊的办法就是 Coding！于是，一个拖延很久的计划终于被松哥拾起来了，录一套&lt;strong&gt;免费的&lt;/strong&gt; SSM 视频。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>小伙伴们提的这个问题，我今天必须解决了！</title>
    <link href="http://www.javaboy.org/2021/0221/itboyhub.html"/>
    <id>http://www.javaboy.org/2021/0221/itboyhub.html</id>
    <published>2021-02-21T14:39:27.000Z</published>
    <updated>2021-03-07T15:08:58.059Z</updated>
    
    <content type="html"><![CDATA[<p>hello 小伙伴们新年好～给大家拜个晚年～</p><a id="more"></a><p>今年虽然倡导就地过年，松哥还是溜回家过年去了，回家那是真舒服啊，公众号都荒废了两周了～</p><p>不过过年期间也不是一点事没干，过年期间终于抽空把小伙伴们反映很久的一个问题解决了～</p><p><img src="http://img.itboyhub.com/2021/02/20210220-181045.jpg" alt></p><p>每次小伙伴们反映 <code>www.javaboy.org</code> 很慢，我都很焦虑，但是这个网站我暂时没办法解决慢的问题，我说说原因。</p><p><code>javaboy.org</code> 是我从国外服务商那里买的域名，当时选择这个的原因是不用备案，当天买当天网站就能上线，很快。服务器我也没有自己搭建，选择了 GitHub Pages 的服务再结合 Hexo 做的网站，所以这个网站肯定是不会挂的，除非 GitHub Pages 自己挂掉了。</p><p>刚开始的时候网站访问量不大也没发现啥弊端，后来慢慢访问的人多了，小伙伴们就开始反映网站访问慢。</p><p>刚开始收到小伙伴们的反馈的时候，我最直观的想法就是把 <code>javaboy.org</code> 这个域名转回到国内，然后买服务器，备案，走正常的流程，后来一查才发现，国内 <code>.org</code> 域名在国内无法备案，这就意味着我要是把这个域名转回到国内连用都用不了了。所以导致这个网站目前处于一个比较尴尬的位置，当然如果你能顺利访问 Google，那么可以把这个域名也添加到代理名单中，这样访问速度会略微好一点。</p><p>既然 <code>www.javaboy.org</code> 的问题没法根治，那就只能另起炉灶，我又重新在国内的服务商处买了个 <code>itboyhub.com</code> 的域名，又买了服务器，然后重新搭建网站。重新搭建的网站依然采用了 Hexo+Nginx 来做，但是效果并不好，为此我还专门又买了 CDN 加速服务，但是感觉提速效果都不太明显，再后来工作比较忙就懒得折腾了。</p><p>过年期间，我想把这个问题好好梳理一下，彻底解决小伙伴们一直反映的访问慢的问题。首先确认了服务器的配置没问题，因为我有一个相同配置的服务器跑着另外的服务，网速就很好。既然不是服务器的配置问题，那就应该是我采用的技术栈的问题了，网上搜了下，果然看到很多人反映 Hexo 加载慢的问题，用了两年的 Hexo 也有点腻了，换个新玩意试试。于是瞄准了 wordpress，三下五除二用 wordpress 重新搭建了一个站点，速度还不错。</p><p><img src="http://img.itboyhub.com/2021/02/20210220193819.png" alt></p><p>这次没上 CDN 加速服务了，用工具测了一下网速基本上也都是全绿，nice！</p><p>到目前为止，我已经把之前发过的大部分系列教程腾挪上去了，并且进行了分类，小伙伴们都可以很方便的查看：</p><p><img src="http://img.itboyhub.com/2021/02/20210220200037.png" alt></p><p>可以在右边的分类目录中查看不同分类下的文章。</p><p>这个问题解决了总算了却了一桩心事，小伙伴们可以畅快的访问 <a href="http://www.itboyhub.com" target="_blank" rel="noopener">www.itboyhub.com</a> 了，松哥所有的文章/教程都会同步上去，小伙伴也可以点击阅读原文体验一把新网站加载速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 小伙伴们新年好～给大家拜个晚年～&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>这得多老的项目才会有这么奇葩的需求</title>
    <link href="http://www.javaboy.org/2021/0204/springmvc-resolver.html"/>
    <id>http://www.javaboy.org/2021/0204/springmvc-resolver.html</id>
    <published>2021-02-04T14:39:12.000Z</published>
    <updated>2021-03-07T15:09:56.325Z</updated>
    
    <content type="html"><![CDATA[<p>维护老项目的时候，我们总会遇到一些奇奇怪怪的需求，解决这些奇葩问题可能才是我们开发的常态。</p><a id="more"></a><p>这不，最近就有小伙伴问了这样一个问题：</p><p><img src="http://img.itboyhub.com/2021/02/20210202172051.png" alt></p><p>这个小伙伴想在 Spring Boot 中同时使用多个视图解析器，一般来说我们正常设计一个项目时，肯定不会搞成这样，要么前后端分离不需要视图解析器，要么前后端不分需要视图解析器，但是即使需要一般也只会使用一种视图解析器，而不会多种视图解析器混在一起使用。</p><p>不过现在既然小伙伴提出了这个问题，我们就来看看这个需求能不能做！先说结论：技术上来说这个当然是可以实现的，而且实现方式不难。</p><p>不过要把这个问题理解透彻，这就涉及到到 SpringMVC 的工作原理了，今天松哥就来和大家把这个问题稍微梳理下。</p><h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>在 SpringMVC 中我们可以配置多个视图解析器，这些视图解析器最终会在 DispatcherServlet#initViewResolvers 方法中完成加载，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initViewResolvers</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detectAllViewResolvers) &#123;</span><br><span class="line"><span class="hljs-comment">// Find all ViewResolvers in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">Map&lt;String, ViewResolver&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line"><span class="hljs-comment">// We keep ViewResolvers in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="hljs-keyword">this</span>.viewResolvers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// Ignore, we'll add a default ViewResolver later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Ensure we have at least one ViewResolver, by registering</span></span><br><span class="line"><span class="hljs-comment">// a default ViewResolver if no other resolvers are found.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑很清楚：</p><ul><li>首先将 viewResolvers 变量置空，这个变量将存储所有的视图解析器。</li><li>接下来根据 detectAllViewResolvers 的变量值来决定是否要加载所有的视图解析器，该变量默认为 true，表示加载所有的视图解析器，加载所有的视图解析器就是去 Spring 容器中查找到所有的 ViewResolver 实例，然后给这些 ViewResolver 实例按照 Order 优先级进行排序。如果 detectAllViewResolvers 的变量值为 false，表示只加载名为 viewResolver 的视图解析器。</li><li>经过前面的步骤，如果 viewResolvers 还是为 null，表示用户压根就没有配置视图解析器，此时调用 getDefaultStrategies 方法加载一个默认的视图解析器，以确保我们的系统中至少有一个视图解析器。</li></ul><p>一般来说，在一个 SSM 项目中，如果我们在 SpringMVC 的配置文件中，没有做任何关于视图解析器的配置，那么就会走入第三步。</p><p>initViewResolvers 方法的主要目的就是初始化视图解析器，并对视图解析器进行排序。从这里我们也可以大概看出来 SpringMVC 中是支持多个视图解析器同时存在的。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>上面是视图解析器的初始化过程。</p><p>接下来我们来看看视图解析器具体是如何发挥作用的。</p><p>小伙伴们知道，一个请求进入 DispatcherServlet 之后，执行的方法流程依次是 service-&gt;processRequest-&gt;doService-&gt;doDispatch-&gt;processDispatchResult-&gt;render-&gt;resolveViewName-&gt;…</p><p>进入 render 方法就差不多进入正题了，我们的页面渲染将在这个方法中完成。render 方法中包含如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">View view;</span><br><span class="line">String viewName = mv.getViewName();</span><br><span class="line"><span class="hljs-keyword">if</span> (viewName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// We need to resolve the view name.</span></span><br><span class="line">view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Could not resolve view with name '"</span> + mv.getViewName() +</span><br><span class="line"><span class="hljs-string">"' in servlet with name '"</span> + getServletName() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">view = mv.getView();</span><br><span class="line"><span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"ModelAndView ["</span> + mv + <span class="hljs-string">"] neither contains a view name nor a "</span> +</span><br><span class="line"><span class="hljs-string">"View object in servlet with name '"</span> + getServletName() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里获取到视图的名字之后，接下来调用 resolveViewName 方法去获取一个具体的视图。在 resolveViewName 方法中，将根据视图名称以及现有的视图解析器找到对应的视图。</p><p>那么这里就存在一个问题，现有的视图解析器如果有多个，究竟该以哪个为准呢？</p><p>我们来看下 resolveViewName 方法中的执行逻辑。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, @Nullable Map&lt;String, Object&gt; model,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Locale locale, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就是遍历所有的 ViewResolver，调用其 resolveViewName 方法去找到对应的 View，找到后就返回了。</p><p>ViewResolver 就是我们常说的视图解析器，我们用 JSP、Thymeleaf、Freemarker 等，都有对应的视图解析器，从下面一张图中就可以看出 ViewResolver 的继承类：</p><p><img src="http://img.itboyhub.com/2021/02/20210202193709.png" alt></p><p>不过在 Spring Boot 中，我们并不会直接使用这些视图解析器，而是使用一个名为 ContentNegotiatingViewResolver 的视图解析器，这个是 Spring3.0 中引入的的视图解析器，它不负责具体的视图解析，而是根据当前请求的 MIME 类型，从上下文中选择一个合适的视图解析器，并将请求工作委托给它。</p><p>所以这里我们就先来看看 ContentNegotiatingViewResolver#resolveViewName 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">RequestAttributes attrs = RequestContextHolder.getRequestAttributes();</span><br><span class="line">List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());</span><br><span class="line"><span class="hljs-keyword">if</span> (requestedMediaTypes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);</span><br><span class="line">View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);</span><br><span class="line"><span class="hljs-keyword">if</span> (bestView != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bestView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useNotAcceptableStatusCode) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> NOT_ACCEPTABLE_VIEW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码逻辑也比较简单：</p><ul><li>首先是获取到当前的请求对象，可以直接从 RequestContextHolder 中获取。然后从当前请求对象中提取出 MediaType。</li><li>如果 MediaType 不为 null，则根据 MediaType，找到合适的视图解析器，并将解析出来的 View 返回。</li><li>如果 MediaType 为 null，则为两种情况，如果 useNotAcceptableStatusCode 为 true，则返回 NOT_ACCEPTABLE_VIEW 视图，这个视图其实是一个 406 响应，表示客户端错误，服务器端无法提供与 Accept-Charset 以及 Accept-Language 消息头指定的值相匹配的响应；如果 useNotAcceptableStatusCode 为 false，则返回 null。</li></ul><p>现在问题的核心其实就变成 getCandidateViews 方法和 getBestView 方法了，看名字就知道，前者是获取所有的候选 View，后者则是从这些候选 View 中选择一个最佳的 View，我们一个一个来看。</p><p>先来看 getCandidateViews：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;View&gt; <span class="hljs-title">getCandidateViews</span><span class="hljs-params">(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;View&gt; candidateViews = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">candidateViews.add(view);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (MediaType requestedMediaType : requestedMediaTypes) &#123;</span><br><span class="line">List&lt;String&gt; extensions = <span class="hljs-keyword">this</span>.contentNegotiationManager.resolveFileExtensions(requestedMediaType);</span><br><span class="line"><span class="hljs-keyword">for</span> (String extension : extensions) &#123;</span><br><span class="line">String viewNameWithExtension = viewName + <span class="hljs-string">'.'</span> + extension;</span><br><span class="line">view = viewResolver.resolveViewName(viewNameWithExtension, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">candidateViews.add(view);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.defaultViews)) &#123;</span><br><span class="line">candidateViews.addAll(<span class="hljs-keyword">this</span>.defaultViews);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> candidateViews;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取所有的候选 View 分为两个步骤：</p><ol><li>调用各个 ViewResolver 中的 resolveViewName 方法去加载出对应的 View 对象。</li><li>根据 MediaType 提取出扩展名，再根据扩展名去加载 View 对象，在实际应用中，这一步我们都很少去配置，所以一步基本上是加载不出来 View 对象的，主要靠第一步。</li></ol><p>第一步去加载 View 对象，其实就是根据你的 viewName，再结合 ViewResolver 中配置的 prefix、suffix、templateLocation 等属性，找到对应的 View，方法执行流程依次是 resolveViewName-&gt;createView-&gt;loadView。</p><p>具体执行的方法我就不一一贴出来了，<strong>唯一需要说的一个重点就是最后的 loadView 方法</strong>，我们来看下这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">loadView</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractUrlBasedView view = buildView(viewName);</span><br><span class="line">View result = applyLifecycleMethods(viewName, view);</span><br><span class="line"><span class="hljs-keyword">return</span> (view.checkResource(locale) ? result : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，View 加载出来后，会调用其 checkResource 方法判断 View 是否存在，如果存在就返回 View，不存在就返回 null。</p><p>这是一个非常关键的步骤，但是我们常用的视图对此的处理却不尽相同：</p><ul><li>FreeMarkerView：会老老实实检查。</li><li>ThymeleafView：没有检查这个环节（Thymeleaf 的整个 View 体系不同于 FreeMarkerView 和 JstlView）。</li><li>JstlView：检查结果总是返回 true。</li></ul><p>至此，我们就找到了所有的候选 View，但是大家需要注意，这个候选 View 不一定存在，在有 Thymeleaf 的情况下，返回的候选 View 不一定可用，在 JstlView 中，候选 View 也不一定真的存在。</p><p>接下来调用 getBestView 方法，从所有的候选 View 中找到最佳的 View。getBestView 方法的逻辑比较简单，就是查找看所有 View 的 MediaType，然后和请求的 MediaType 数组进行匹配，第一个匹配上的就是最佳 View，这个过程它不会检查视图是否真的存在，所以就有可能选出来一个压根没有的视图，最终导致 404。</p><p>这就是整个 View 的加载过程。</p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p>如果是单个视图，这套加载流程没什么问题，但是如果是多个视图解析器同时存在，就可能会有问题。</p><p>松哥一个一个来说明。</p><p>第一种情况：</p><p>FreeMarkerView、ThymeleafView 以及 JstlView 在项目中只存在任意一个，这种情况没任何问题，这也是小伙伴们日常常见的使用场景。</p><p>第二种情况：</p><p>FreeMarkerView+ThymeleafView 组合。如果项目中同时存在这两种视图解析器，由于 FreeMarkerView 会老老实实检查视图是否存在，而 ThymeleafView 不会检查，所以需要确保 FreeMarkerViewResolver 的优先级高于 ThymeleafViewResolver 的优先级。这样就能够确保视图加载的时候先去加载 FreeMarkerView（FreeMarkerView 如果不存在，则不会列为候选 View），再去加载 ThymeleafView，这样无论是 FreeMarkerView 还是 ThymeleafView，都能够正常加载到（回顾前面所讲 getBestView 方法逻辑）。假如 ThymeleafViewResolver 的优先级高于 FreeMarkerViewResolver，那么就会出现如下情况：用户请求一个 Freemarker 视图，结果在 getCandidateViews 方法中返回了两个视图，依次是 ThymeleafView 和 FreeMarkerView，但是实际上 ThymeleafView 中的视图是不存在的，结果在 getBestView 方法中，按顺序直接匹配到 ThymeleafView，最终导致运行出错。</p><p>在 Spring Boot 中，如果我们引入了 Freemarker 和 Thyemeleaf 的 starter，默认情况下，Freemarker 和 Thymeleaf 的优先级相同，都是 <code>Ordered.LOWEST_PRECEDENCE - 5</code>，但是由于 Freemarker 总是被优先加载，而排序时由于两者优先级相同所以位置不变，所以在具体代码实践中，FreeMarkerViewResolver 总是排在 ThymeleafViewResolver 前面，FreeMarkerView 会自动检查视图是否存在，所以这样的排序刚刚恰到好处。在具体代码实践中，如果我们在项目中同时引入了 Freemarker 和 Thymeleaf，可以不用做任何配置直接同时使用这两种视图解析器。</p><p>这里要吐槽一下，网上看多人说默认情况下 Freemarker 优先级高于 Thymeleaf，不知道谁抄谁的，反正都说错了，还是要严谨呀！</p><p>第三种情况：</p><p>Freemarker+Jsp 组合，如果项目中同时使用了这两种视图解析器，则只需要对 jsp 进行常规配置即可，不需要额外配置。所谓的常规配置就是首先引入所需依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后配置一下 jsp 视图的前缀后缀啥的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.jsp(<span class="hljs-string">"/"</span>, <span class="hljs-string">".jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就可以了。</p><p>为什么这个组合这么简单呢？原因如下：</p><ol><li>在 Spring 设计中，InternalResourceView 其实就是兜底的，所以它不会检查视图是否真的存在，它的优先级也是最低的。</li><li>由于 InternalResourceView 的优先级最低，排在 Freemarker 后面，而 Freemarker 会自动检查视图是否存在，所以对于这个组合我们不需要额外配置。</li></ol><p>第四种情况：</p><p>Thymeleaf+Jsp 组合。这个组合稍微有点麻烦，因为 Thymeleaf 和 InternalResourceView 都不会去检查视图是否存在，而 Thymeleaf 的优先级高于 Jsp，所以 Thymeleaf 会“吞掉” Jsp 视图的请求。</p><p>想要这两个视图解析器同时存在，必须要有一个视图解析器具备检查视图是否存在的能力。Jsp 在这块的配置相对容易一些，所以我们选择对 InternalResourceView 做一些定制。</p><p>具体办法如下，首先定义类继承自 InternalResourceView 并重写 checkResource 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandleResourceViewExists</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InternalResourceView</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkResource</span><span class="hljs-params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-keyword">this</span>.getServletContext().getRealPath(<span class="hljs-string">"/"</span>) + getUrl());</span><br><span class="line">        <span class="hljs-comment">//判断页面是否存在</span></span><br><span class="line">        <span class="hljs-keyword">return</span> file.exists();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InternalResourceView 默认的 checkResource 方法总是返回 true，现在我们稍微修改一下，让它去判断一下视图文件是否存在，如果存在，返回 true，否则返回 false。</p><p>配置完成后，将新的 HandleResourceViewExists 重新配置，同时修改优先级，使之优先级大于 ThymeleafViewResolver，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.jsp(<span class="hljs-string">"/"</span>, <span class="hljs-string">".jsp"</span>).viewClass(HandleResourceViewExists.class);</span><br><span class="line">        registry.order(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此之后，这两个视图解析器就可以同时存在了。</p><p>第五种情况：</p><p>Freemarker+Thymeleaf+Jsp，看了前面四种，第五种情况应该就不用我多说了吧～</p><p>好啦，这个问题从原理到应用，都给大伙捋了一遍了，感兴趣的小伙伴赶紧试试哦～</p><p>对了，这个问题松哥也录制了相关的视频，感兴趣的小伙伴可以在公众号后台回复 <strong>vhr</strong> 查看视频详情。</p><p><img src="http://img.itboyhub.com/2021/02/20210204083251.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;维护老项目的时候，我们总会遇到一些奇奇怪怪的需求，解决这些奇葩问题可能才是我们开发的常态。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="ViewResolver" scheme="http://www.javaboy.org/tags/ViewResolver/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 应用监控常见方案梳理</title>
    <link href="http://www.javaboy.org/2021/0203/springboot-actuator.html"/>
    <id>http://www.javaboy.org/2021/0203/springboot-actuator.html</id>
    <published>2021-02-03T14:38:58.000Z</published>
    <updated>2021-03-07T15:09:50.227Z</updated>
    
    <content type="html"><![CDATA[<p>应用监控是我们在生产环境下一个非常重要的东西，运维人员不可能 24 小时盯着应用，应用挂了及时解决，这不现实。我们需要能够实时掌握应用的运行数据，以便提早发现问题，同时在应用挂掉的时候还能够自动报警，这样才能解放开发人员。</p><a id="more"></a><p>Spring Boot 中也提供了生产级的应用监控方案，对于单体应用、微服务应用都有相应的解决方案，今天松哥就想来和大家捋一捋 Spring Boot 中的应用监控方案都有哪些。</p><p>首先我们来捋一下应用监控都需要哪些东西？其实就两点：</p><ol><li>信息采集器</li><li>数据可视化 UI</li></ol><p>信息采集器会收集应用的健康、审计、指标、HTTP 请求等信息，并将之暴露出来，数据可视化 UI 则会通过仪表盘、图形等展示这些数据，并对数据进行分析、报警等处理。我们分别来看。</p><h2 id="Spring-Boot-Actuator"><a href="#Spring-Boot-Actuator" class="headerlink" title="Spring Boot Actuator"></a>Spring Boot Actuator</h2><p>在 Spring Boot 项目中，我们使用的信息采集器主要就是 Spring Boot Actuator，这个模块由 Spring Boot 官方提供，它包含了许多生产级别的功能，例如健康检查、审计、指标收集、HTTP 请求追踪等，Spring Boot Actuator 将这些信息收集起来后，通过 HTTP 和 JMX 两种方式暴露给外部模块。例如 Spring Boot Actuator 通过 <code>/health</code> 端点（endpoints）提供了应用的健康信息，开发者只需要访问该端点就可以看到应用的健康信息，但是这些端点返回的数据是 JSON 格式的，不方便查看，也不方便分析，所以一般情况下，Spring Boot Actuator 都是和一些外部模块一起使用。</p><p>Spring Boot Actuator 支持的端点主要有如下一些：</p><p><img src="http://img.itboyhub.com/2021/02/20210201202406.png" alt></p><p>如果是 Web 应用，则再次基础上还支持如下端点：</p><p><img src="http://img.itboyhub.com/2021/02/20210201202855.png" alt></p><p>提到 Spring Boot Actuator，就还有一个东西需要和大家介绍，那就是 Micrometer，从 Spring Boot2.0 开始，Actuator 底层改为了 Micrometer。</p><p>当我们在一个 Spring Boot 项目中引入 Actuator 依赖之后，我们会发现它里边包含了 Micrometer：</p><p><img src="http://img.itboyhub.com/2021/01/spring-cloud/20210201162644.png" alt></p><p>这个依赖又是干什么的呢？</p><p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标即可，而 Micrometer 则会负责完成与不同监控系统的适配工作，类似于一个 Adapter，有了这个 Adapter，切换监控系统就变得非常容易。同时 Micrometer 还支持推送数据到多个不同的监控系统。</p><p>而 Spring Boot Actuator 使用 Micrometer 与外部应用监视系统进行集成，这样一来，开发者只需要稍微配置一下就可以使其和外部应用监视系统进行整合了。Micrometer 支持的监控系统有：</p><ul><li>AppOptics</li><li>Atlas</li><li>Datadog</li><li>Dynatrace</li><li>Elastic</li><li>Ganglia</li><li>Graphite</li><li>Humio</li><li>Influx</li><li>JMX</li><li>KairosDB</li><li>New Relic</li><li>Prometheus</li><li>SignalFx</li><li>Simple (in-memory)</li><li>StatsD</li><li>Wavefront</li></ul><p>信息采集器这块，老实说松哥见到的大部分项目都是用的 Spring Boot Actuator，似乎没有其他更好的选择。如果小伙伴们有用到其他方案，也可以留言讨论。</p><p>接下来我们来看看一些常用的应用监控可视化工具。</p><h2 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h2><p>这个算是 Spring Boot 中最最正宗的应用监控可视化工具了，看名字就知道有多正宗，当我们创建一个 Spring Boot 项目时，选择依赖时候就有这个选项：</p><p><img src="http://img.itboyhub.com/2021/02/20210201173448.png" alt></p><p>如果是<strong>单体应用</strong>很多人可能会选择 Spring Boot Admin 作为监控数据可视化工具，不过它也支持微服务应用的(可以通过 Eureka、Consul 等注册中心获取应用信息)，只不过在微服务中，我们可能会更多的选择 Grafana+Prometheus 组合。</p><p>Spring Boot Admin 主要包含如下功能：</p><ul><li>显示应用健康信息。</li><li>显示应用运行的详细信息，例如 JVM 和内存指标、数据源指标、缓存指标等等。</li><li>显示应用的构建信息。</li><li>查看 JVM 系统和环境属性</li><li>查看 Spring Boot 配置属性</li><li>支持 Spring Cloud 中的端点刷新功能 /refresh-endpoint</li><li>方便的日志级别管理功能</li><li>可以与 JMX-beans 进行交互</li><li>查看 Thread dump</li><li>查看 http 请求</li><li>查看计划任务</li><li>查看和删除活动会话</li><li>查看 Flyway/Liquibase 数据库迁移</li><li>下载 heapdump</li><li>状态更改通知</li><li>…</li></ul><p>可以看到，Spring Boot Admin 不仅仅是将 Actuator 接口中的数据进行可视化，还在此基础上提供了分析、报警等功能。</p><p>Spring Boot Admin 的显示界面如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210201181913.png" alt></p><h2 id="Grafana-Prometheus"><a href="#Grafana-Prometheus" class="headerlink" title="Grafana+Prometheus"></a>Grafana+Prometheus</h2><p>这个组合在微服务项目中比较常见，松哥之前录制的 Spring Cloud 视频里边也有讲到（公号后台回复 vhr 有视频详细介绍）。</p><p><img src="http://img.itboyhub.com/2021/02/20210201182618.png" alt></p><p>Prometheus 是一款开源的监控 + 时序数据库 + 报警软件，由SoundCloud 公司开发的，在 CNCF 基金会托管并已成功孵化，不过这个 Prometheus 的 UI 比较简单，用户体验不怎么好，现在都流行大屏监控页面，上面展示各种炫酷的图表。所以在实际应用中，Prometheus 一般都是结合 Grafana 一起来使用，Grafana 也是一个开源的跨平台度量分析和可视化 + 告警工具，它支持多种数据源，包括 Prometheus，Grafana 的 UI 就比较炫酷，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210201200600.png" alt></p><p>当然，使用这套组合也离不开 Spring Boot Actuator。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>前面跟小伙伴们分享了 Spring Boot 应用监控的主流方案，没说具体用法，后面抽空松哥会和大家聊一聊具体用法。除了这些主流的方案之后，还有很多小众的方案，松哥也见到有极少数项目团队自研应用监控方案。不过对于大多数的项目而言，这些现成的成熟方案无疑是最佳选择。</p><p>好啦，今天就先和小伙伴们聊这么多，后面我们再来看具体用法～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用监控是我们在生产环境下一个非常重要的东西，运维人员不可能 24 小时盯着应用，应用挂了及时解决，这不现实。我们需要能够实时掌握应用的运行数据，以便提早发现问题，同时在应用挂掉的时候还能够自动报警，这样才能解放开发人员。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Actuator" scheme="http://www.javaboy.org/tags/Actuator/"/>
    
  </entry>
  
  <entry>
    <title>Swagger3.0，你所不知道的新变化！</title>
    <link href="http://www.javaboy.org/2021/0129/springboot-swagger3.html"/>
    <id>http://www.javaboy.org/2021/0129/springboot-swagger3.html</id>
    <published>2021-01-29T14:38:24.000Z</published>
    <updated>2021-03-07T15:09:45.200Z</updated>
    
    <content type="html"><![CDATA[<p>在社区的推动下，Springfox3.0 去年 7 月份就发布了，最近终于得空和小伙伴们聊一聊新版本的新变化。这次的版本升级估计小伙伴们都翘首以待好久了，毕竟上一次发版已经是两年前的事情了。</p><a id="more"></a><p><img src="http://img.itboyhub.com/2021/01/docker/20210128112402.png" alt></p><p>新版本还是有很多好玩的地方，我们一起来看下。</p><h2 id="支持-OpenAPI"><a href="#支持-OpenAPI" class="headerlink" title="支持 OpenAPI"></a>支持 OpenAPI</h2><p>什么是 OpenAPI？</p><p>OpenAPI 规范其实就是以前的 Swagger 规范，它是一种 REST API 的描述格式，通过既定的规范来描述文档接口，它是业界真正的 API 文档标准，可以通过 YAML 或者 JSON 来描述。它包括如下内容：</p><ul><li>接口（/users）和每个接口的操作（GET /users，POST /users）</li><li>输入参数和响应内容</li><li>认证方法</li><li>一些必要的联系信息、license 等。</li></ul><p>关于 OpenAPI 的更多内容，感兴趣的小伙伴可以在 GitHub 上查看：<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md" target="_blank" rel="noopener">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md</a></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>以前在使用 2.9.2 这个版本的时候，一般来说我们可能需要添加如下两个依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两个，一个用来生成接口文档（JSON 数据），另一个用来展示将 JSON 可视化。</p><p>在 3.0 版本中，我们不需要这么麻烦了，一个 starter 就可以搞定：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和 Spring Boot 中的其他 starter 一样，springfox-boot-starter 依赖可以实现零配置以及自动配置支持。也就是说，如果你没有其他特殊需求，加一个这个依赖就行了，接口文档就自动生成了。</p><h2 id="接口地址"><a href="#接口地址" class="headerlink" title="接口地址"></a>接口地址</h2><p>3.0 中的接口地址也和之前有所不同，以前在 2.9.2 中我们主要访问两个地址：</p><ul><li>文档接口地址：<a href="http://localhost:8080/v2/api-docs" target="_blank" rel="noopener">http://localhost:8080/v2/api-docs</a></li><li>文档页面地址：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></li></ul><p>现在在 3.0 中，这两个地址也发生了变化：</p><ul><li>文档接口地址：<a href="http://localhost:8080/v3/api-docs" target="_blank" rel="noopener">http://localhost:8080/v3/api-docs</a></li><li>文档页面地址：<a href="http://localhost:8080/swagger-ui/index.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui/index.html</a></li></ul><p>特别是文档页面地址，如果用了 3.0，而去访问之前的页面，会报 404。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>旧的注解还可以继续使用，不过在 3.0 中还提供了一些其他注解。</p><p>例如我们可以使用 @EnableOpenApi 代替以前旧版本中的 @EnableSwagger2。</p><p>话是这么说，不过松哥在实际体验中，感觉 @EnableOpenApi 注解的功能不明显，加不加都行。翻了下源码，@EnableOpenApi 注解主要功能是为了导入 OpenApiDocumentationConfiguration 配置类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(value = &#123;java.lang.annotation.ElementType.TYPE&#125;)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Import</span>(OpenApiDocumentationConfiguration.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableOpenApi &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我又看了下自动化配置类 OpenApiAutoConfiguration，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(SpringfoxConfigurationProperties.class)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(value = <span class="hljs-string">"springfox.documentation.enabled"</span>, havingValue = <span class="hljs-string">"true"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123;</span><br><span class="line">    OpenApiDocumentationConfiguration.class,</span><br><span class="line">    SpringDataRestConfiguration.class,</span><br><span class="line">    BeanValidatorPluginsConfiguration.class,</span><br><span class="line">    Swagger2DocumentationConfiguration.class,</span><br><span class="line">    SwaggerUiWebFluxConfiguration.class,</span><br><span class="line">    SwaggerUiWebMvcConfiguration.class</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-meta">@AutoConfigureAfter</span>(&#123; WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,</span><br><span class="line">    HttpMessageConvertersAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenApiAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，自动化配置类里边也导入了 OpenApiDocumentationConfiguration。</p><p>所以在正常情况下，实际上不需要添加 @EnableOpenApi 注解。</p><p>根据 OpenApiAutoConfiguration 上的 @ConditionalOnProperty 条件注解中的定义，我们发现，如果在 application.properties 中设置 <code>springfox.documentation.enabled=false</code>，即关闭了 swagger 功能，此时自动化配置类就不执行了，这个时候可以通过 @EnableOpenApi 注解导入 OpenApiDocumentationConfiguration 配置类。技术上来说逻辑是这样，不过应用中暂未发现这样的需求（即在 application.properties 中关闭 swagger，再通过 @EnableOpenApi 注解开启）。</p><p>对于 @EnableOpenApi 注解的使用场景，小伙伴们要是有自己的见解，欢迎留言讨论。</p><p>另外，以前我们用的 @ApiResponses/@ApiResponse 注解，在 3.0 中名字没变，但是所在的包变了，小伙伴们使用时注意导包问题哦。</p><p>另外，我们之前用的 @ApiOperation 注解在 3.0 中可以使用 @Operation 代替。</p><p>另外还有一些新注解如 @Parameter、Parameters、@Schema 等，松哥尝试了下，感觉不太好用，不如旧的用的舒服，这些新注解小伙伴们可以自行尝试下。</p><p>好啦，今天主要和小伙伴们分享了 Swagger3.0 带来的一些新变化，如果还没用过 Swagger，可以在公众号后台回复 666，有一个松哥原创的 Spring Boot 入门教程，里边有讲 Swagger 的用法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在社区的推动下，Springfox3.0 去年 7 月份就发布了，最近终于得空和小伙伴们聊一聊新版本的新变化。这次的版本升级估计小伙伴们都翘首以待好久了，毕竟上一次发版已经是两年前的事情了。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Swagger3" scheme="http://www.javaboy.org/tags/Swagger3/"/>
    
  </entry>
  
  <entry>
    <title>Maven 聚合工程的几个小细节</title>
    <link href="http://www.javaboy.org/2021/0127/maven.html"/>
    <id>http://www.javaboy.org/2021/0127/maven.html</id>
    <published>2021-01-27T14:38:10.000Z</published>
    <updated>2021-03-07T15:10:01.015Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 作为我们 Java 开发领域最最基础的工具，估计每个小伙伴每天都在用。但是对于新手而言，Maven 中有一些基本的概念似乎很容易搞混，例如继承、聚合、集成等等。所以今天我们就来简单聊聊这个话题。</p><a id="more"></a><h2 id="为什么需要分模块"><a href="#为什么需要分模块" class="headerlink" title="为什么需要分模块"></a>为什么需要分模块</h2><p>松哥在 vhr(<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>) 项目中也用到了聚合工程，那么为什么用聚合工程？直接一个工程分包不行吗？</p><p>如果只是一个小 case，分包当然是可以的，但是如果项目越来越大，分包的弊端就会逐步展现出来：</p><ul><li>pom.xml 中引用的依赖非常多以至于难以维护。</li><li>同时在修改 dao 层的代码，结果改错了，你在 service 层编译不通过，烦躁。</li><li>项目越来越大，build 等待时间也越来越长。</li><li>有一个新的项目想要复用你的 utils 工具包，结果你只能去拷贝代码。</li></ul><p>这样高度耦和的代码实际上并不符合我们的设计规范，所以我们需要对代码进行拆分，做成不同的模块。</p><h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><p>经过模块划分后，我们的 Maven 项目结构可能是这样的：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">└── vhr-parent</span><br><span class="line">    ├── vhr-dao</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   └── src</span><br><span class="line">    │       ├── main</span><br><span class="line">    │       │   ├── java</span><br><span class="line">    │       │   └── resources</span><br><span class="line">    │       └── test</span><br><span class="line">    │           └── java</span><br><span class="line">    ├── vhr-service</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   └── src</span><br><span class="line">    │       ├── main</span><br><span class="line">    │       │   ├── java</span><br><span class="line">    │       │   └── resources</span><br><span class="line">    │       └── test</span><br><span class="line">    │           └── java</span><br><span class="line">    └── vhr-web</span><br><span class="line">        ├── pom.xml</span><br><span class="line">        └── src</span><br><span class="line">            ├── main</span><br><span class="line">            │   ├── java</span><br><span class="line">            │   └── resources</span><br><span class="line">            └── test</span><br><span class="line">                └── java</span><br></pre></td></tr></table></figure><p>先说下代码组织形式，可以是父子形式，就像上面这样，父工程是一个目录，子工程的目录在父工程目录中。也可以是平铺的形式，即父子工程在同一目录下。两种形式皆可，但是在配置上会略有差异，这个松哥后面会说，这里我们先按照上面这种代码组织形式来讲。</p><p>service 依赖 dao，web 依赖 service，默认情况下，依赖是可以传递的，所以你在 web 中也可以使用 dao。一些特殊的情况下，如果我们不希望依赖传递，则可以使用 scope 节点进行配置。</p><p>一般来说，dao、service 都是打包成 jar、web 打包成 war，parent 的 packaging 类型则是一个 pom。</p><p>按照模块划分之后，上面我们所提到的问题，现在都解决了：</p><ul><li>首先，项目变大之后，build 等待时间并不会飞速增长，各个模块都可以独自 build。</li><li>拆分之后，pom.xml 文件中的依赖也不再凌乱。</li><li>如果其他项目有需要，可以方便的将某一个模块提供给其他项目使用。</li><li>依赖版本可以使用 depencencyManagement 节点进行统一管理。spring-boot 中的 parent 就是这么干的。</li></ul><h2 id="配置细节"><a href="#配置细节" class="headerlink" title="配置细节"></a>配置细节</h2><p>首先我们来看下 vhr-parent 中的配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前面我们说过了，parent 的 packaging 节点要为 pom，这个是固定的，只要有子模块，packaging 就是 pom。</p><p>另外我们还在 parent 的 pom.xml 中配置了 modules，将其所包含的所有子模块都列出来，当我们在 parent 处进行打包时，Maven 会自动梳理子模块之间的依赖关系，整理出来一个 build 顺序，然后进行编译打包。</p><p>再来看看子模块的 pom.xml 配置，以 vhr-service 为例：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块中需要配置 parent，这样 vhr-service 就继承了 parent 的一切，包括依赖、插件、坐标、版本号等等，有了来自 parent 的一大堆东西之后，vhr-service 自己的 pom.xml 中只需要简单配置一下 artifactId 即可。依赖的版本号则可以通过 ${project.version} 变量引用项目的版本号。</p><p>这里没有配置 packaging，默认就是 jar，所以可以省略，如果是 web 模块，则还需要配置 packaging 为 war。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>聚合工程，听名字就知道是很多工程聚在一起组成一个完整的项目，所以打包的时候，也是一起打包。直接在 parent 处执行 <code>mvn package</code> 命令，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sang-3:vhr-parent sang$ mvn package</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Build Order:</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] vhr-parent                                                         [pom]</span><br><span class="line">[INFO] vhr-dao                                                            [jar]</span><br><span class="line">[INFO] vhr-service                                                        [jar]</span><br><span class="line">[INFO] vhr-web                                                            [jar]</span><br><span class="line">[INFO] </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Summary for vhr-parent 1.0-SNAPSHOT:</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] vhr-parent ......................................... SUCCESS [  0.004 s]</span><br><span class="line">[INFO] vhr-dao ............................................ SUCCESS [  0.867 s]</span><br><span class="line">[INFO] vhr-service ........................................ SUCCESS [  0.038 s]</span><br><span class="line">[INFO] vhr-web ............................................ SUCCESS [  0.025 s]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  1.021 s</span><br><span class="line">[INFO] Finished at: 2021-01-26T12:50:42+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>可以看到整个打包过程，各个聚合工程都被打包了。打包完成后，在不同模块的目录下都可以看到一个 target 目录，里边就有刚刚打包好的 jar 或者 war。</p><p>如果你使用的是 IntelliJ IDEA，也可以在工具右侧找到 Maven-&gt;LifeCycle-&gt;Package，双击进行打包。</p><p><img src="http://img.itboyhub.com/2021/springboot2/20210126125328.png" alt></p><h2 id="目录问题"><a href="#目录问题" class="headerlink" title="目录问题"></a>目录问题</h2><p>在前面的案例中，我们的代码结构使用了父子目录的形式，但是在实际应用中，有的时候我们可能会采用平铺的形式，像下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">└── vhr</span><br><span class="line">    ├── parent</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    ├── vhr-dao</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   ├── src</span><br><span class="line">    │   │   ├── main</span><br><span class="line">    │   │   │   ├── java</span><br><span class="line">    │   │   │   └── resources</span><br><span class="line">    │   │   └── test</span><br><span class="line">    │   │       └── java</span><br><span class="line">    ├── vhr-service</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   ├── src</span><br><span class="line">    │   │   ├── main</span><br><span class="line">    │   │   │   ├── java</span><br><span class="line">    │   │   │   └── resources</span><br><span class="line">    │   │   └── test</span><br><span class="line">    │   │       └── java</span><br><span class="line">    └── vhr-web</span><br><span class="line">        ├── pom.xml</span><br><span class="line">        ├── src</span><br><span class="line">        │   ├── main</span><br><span class="line">        │   │   ├── java</span><br><span class="line">        │   │   └── resources</span><br><span class="line">        │   └── test</span><br><span class="line">        │       └── java</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/springboot2/20210126132625.png" alt></p><p>可以看到，parent 和各个子模块处于同一目录下，这个时候，无论是 parent 的 pom.xml 还是子模块的 pom.xml，写法都会和之前略有差异。</p><p>先来看 parent 的 pom.xml：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 module 中定义的是子模块名称，所以，当子模块和父模块处于同一目录下时，需要明确指出子模块的位置，因此这里用到了相对路径。</p><p>同理，在子模块中也需要明确指定父模块的 pom.xml，以 vhr-service 为例，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在 parnet 节点中多了 relativePath 用来指定父模块的 pom.xml。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maven 作为我们 Java 开发领域最最基础的工具，估计每个小伙伴每天都在用。但是对于新手而言，Maven 中有一些基本的概念似乎很容易搞混，例如继承、聚合、集成等等。所以今天我们就来简单聊聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://www.javaboy.org/categories/Maven/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
      <category term="Maven" scheme="http://www.javaboy.org/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>我要再吹一把 Docker</title>
    <link href="http://www.javaboy.org/2021/0125/docker.html"/>
    <id>http://www.javaboy.org/2021/0125/docker.html</id>
    <published>2021-01-25T14:37:56.000Z</published>
    <updated>2021-03-07T15:08:53.492Z</updated>
    
    <content type="html"><![CDATA[<p>临近年底，最近工作中又折腾上 Docker 了，用完之后，不得不说，真香！</p><a id="more"></a><p>事情的起因很简单，有个刚入行不久小伙伴需要在一个现有的 Java 服务器上部署一个 PHP 应用，这个 Java 服务器上目前就跑了一个 Spring Boot 应用，然后用 Nginx 做了反向代理。部署 PHP 其实也没什么难度，但是如果你运气不好，那就有的折腾了。</p><p>我大概跟他说了下思路：</p><p>首先安装 PHP 环境，这块注意兼容性问题即可。然后就是 PHP 服务器的选择，可以选择 Nginx 也可以选择 Apache。</p><p>如果使用 Nginx 做服务器，Nginx 本身没有解析 PHP 脚本的功能，还需要安装 php-fpm 去解析 PHP，然后配置 Nginx 作为反向代理，将请求的 PHP 脚本交给 php-fpm 去解析。Nginx 和 php-fpm 通信有两种方式，直接配置一个 <a href="http://www.sock" target="_blank" rel="noopener">www.sock</a> 或者使用 tcp 通信，前者需要注意权限问题。</p><p>如果使用 Apache 做服务器就没有这么多事，Apache 服务器自己可以搞定 PHP 脚本的解析问题，我们只需要将 PHP 脚本放在 Apache 服务器正确的位置上即可。</p><p>由于服务器上已经安装了 Nginx，因此建议采用第一种方案。</p><p>大概就是这样的思路，说完之后小伙伴就自己去搞了。</p><p>两天之后，小伙伴又哼哧哼哧的找来了，还没部署成功，各种方案都试了，各种 BUG 都遇到了，搞的很头大，问我还有没有其他好办法。</p><p>我手头上事情多忙不开，没法帮他排查问题，于是顺手扔给他一个 Docker 命令去试下。几分钟后，小伙伴说你怎么不早说 Docker 命令，这也太爽了，一个命令就搞定了。</p><p>老实说，Docker 确实很香。特别是在当下云原生技术火热的情况下，容器技术作为云原生中的重要一环，作用异常重要。</p><p>松哥大概是在三年前开始接触容器技术，Docker、Docker-Compose 到后来的 K8s 都有涉猎。不过老实说，如果你只是做常规的企业应用开发，工作中用到 Docker 的场景可能并不多，最常见的场景可能就是安装一些环境而已。对运维来说这些可就是神器了，容器技术极大的简化了运维的工作量，如果公司里上了 DevOps，你可能会看到一个整天无所事事的运维在到处晃悠，再看看自己还在苦逼的搬砖，真是人比人气死人呀。松哥身边有个小伙伴不止一次的说想去搞运维，开发太累了。上了 DevOps 之后，大部分情况下运维的工作是挺爽的。</p><p>现在我 Mac 上的 MySql、Redis、RabbitMQ、MongoDB 等等都是使用 Docker 来安装，方便省事，用完了不想要了，一个命令就删除了，不留任何痕迹。</p><p><img src="http://img.itboyhub.com/2021/springboot2/20210125111206.png" alt></p><p>当然作为 Java 工程师，我们还是有必要学习一下 Docker 容器技术的，无论是追赶时髦的云原生还是自己平时安装个环境啥的，会点 Docker 总是没错的。松哥之前在学习 Docker 时，还写了一个 Docker 入门教程，有的小伙伴已经下载了，还有小伙伴可能还不知道，今天再给大家安利一下，在公众号后台回复 <strong>docker</strong> 可以下载这个教程。</p><p><img src="http://img.itboyhub.com/2021/springboot2/20210125095506.png" alt></p><p>这个文字的教程我也写的蛮久了，最近还在想要是有空录制一个 Docker 入门的视频教程，等录好了会告诉大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;临近年底，最近工作中又折腾上 Docker 了，用完之后，不得不说，真香！&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://www.javaboy.org/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://www.javaboy.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>年底小偷也要冲业绩，小伙伴们看好自己的手机呀！</title>
    <link href="http://www.javaboy.org/2021/0119/life.html"/>
    <id>http://www.javaboy.org/2021/0119/life.html</id>
    <published>2021-01-19T14:37:34.000Z</published>
    <updated>2021-03-07T15:08:49.345Z</updated>
    
    <content type="html"><![CDATA[<p>在一线城市呆久了，或者在学校里呆久了，可能会有一种错觉，这年头还有人偷手机吗？</p><a id="more"></a><p>当然有！</p><p>老母亲最近就在西安的一个菜市场丢了一部华为手机，冬天穿的衣服厚，小偷偷手机时不易察觉，口袋里的东西就容易被人顺走。</p><p>小偷各个地方都会有，就是多与少的问题。如果一个地方没有能够吸引大量就业人口的低端产业，类似于盗窃这样的治安问题发生频率就要高一些。特别是过年前这段时间，小偷也要冲业绩回家过年，小伙伴们一定要看好自己的手机。</p><p>2012 年冬天在海口，有一个周末，女票的笔记本坏了我帮忙送去售后维修，在返程的时候，从海口明珠广场那里的天桥上下来后，感觉右边上衣的口袋怪怪的，一回头，发现小偷的夹子已经伸到我的口袋了，第一次遇到这种事我都懵了。看到我回头，小偷自己也愣了一下，忙收回夹子，悻悻离去。我回过神来，发现天桥底下一众摆摊的小贩都在静静地观赏着刚才发生的事情，我理解他们不吭声提醒的难处，自己的东西还是要靠自己保管好。</p><p>要是我没有回头，那真是光天化日众目睽睽之下，钱包被小偷夹走了。想想真是后怕，那时候也没什么钱，但是钱包里有身份证，要是丢了就麻烦了。</p><p>2015 年春招的时候，我在西安呆了十多天，小偷和骗子都被我遇上了。</p><p>先说小偷，有一次我在路上接到面试官的电话，面试完了手机随手放在口袋里，然后继续走路，突然感觉身后有很急促的呼吸声，持续时间有点长，我感到奇怪，一回头，好家伙，小偷跟在我身后都快踩到我的脚了，空旷的路上就我们俩人，可以断定是小偷无疑，不知道是我走路有点快他跟不上还是即将得手内心有点激动，他急促的呼吸出卖了他！感觉这个小偷的业务水平比我在海口遇到的小偷业务水平稍逊一筹。</p><p>再说骗子，骗子是我在大学城参加完招聘后，回家路上遇到的。一个胖胖的中年男子，旁边跟着一个女的抱着小孩，男子表示来西安找朋友，但是现在没找到，钱也没了。。。吧啦吧啦，我没听他说完就走开了。整个过程有一个细节比较有意思，男的说话的时候故意抬起他的右手捏鼻子，亮出了一个黄灿灿的大戒指，我觉得他的潜台词是你看我其实不差钱，就是当前缺点钱而已。这样的伎俩我当然不会上当，大学城附近这样的骗子太多了，2016 年我去西北工大找女票的时候，校门口也遇到了类似的骗子，套路都差不多。</p><p>当然我也并非总是这么幸运，大学的时候丢过自行车，这个估计很多小伙伴们都有类似经历，大学里边最容易丢的就是自行车了，反而手机不易丢。个人猜测是因为学校里学生都善恶分明，要是有人把手伸到你口袋里准备偷手机，被其他人看到肯定会喊出来，不会像社会上看到了也装作没看到。而偷自行车就不会这么麻烦（个人瞎猜）。</p><p>现在临近过年，各路小偷骗子也要冲业绩了，小伙伴们要看好自己的手机呀～手机可能不值几个钱，但是丢了真的很麻烦，丢了之后要赶紧号码挂失、补卡、找回各种账号，真的头大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一线城市呆久了，或者在学校里呆久了，可能会有一种错觉，这年头还有人偷手机吗？&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>腾讯程序员怎么写代码？看看读者麻瓜大佬怎么说！</title>
    <link href="http://www.javaboy.org/2021/0109/tencent.html"/>
    <id>http://www.javaboy.org/2021/0109/tencent.html</id>
    <published>2021-01-09T14:37:10.000Z</published>
    <updated>2021-03-07T15:07:57.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由读者 muggle 投稿，muggle 是一位具备极客精神的 90 后单身老实猿，目前在腾讯云担任研发工程师。</p></blockquote><a id="more"></a><h1 id="代码混乱的常见问题"><a href="#代码混乱的常见问题" class="headerlink" title="代码混乱的常见问题"></a>代码混乱的常见问题</h1><p>很多时候我们项目迭代到后期，项目会变得很混乱，往往只有少数人能知道某段代码是干嘛的和该如何去改，或者是干脆谁都不知道，只能靠通过注释去猜测这段代码可能的作用。原因有可能是因为团队内部的人事变动，导致原先写这段代码的人不再管理这段代码了，并且代码写的实在是屎没人捋的清。往往我们称这类代码为“祖传代码”，就像祖宗传下来的代码一样，没人懂没人敢动。祖传代码一多，这个项目就变成了屎一样，开发人员再这基础上迭代就如同屎海翻腾，恶心别人也恶心自己。这是一个很可怕的恶心循环，我们如何去避免这种事情发生呢？先让我们分析下这类代码的通病</p><h2 id="代码又臭又长"><a href="#代码又臭又长" class="headerlink" title="代码又臭又长"></a>代码又臭又长</h2><p>我见过最长的方法是5000多行，那段代码没人敢动，只敢往下加 if else，每次需要改这段代码的开发都战战兢兢，生怕出现什么莫名其妙的bug。java 可是一门面向对象的语言，一个方法里面有5000多行可以说是很可恶的事情了。我想一开始代码长度可能没这么夸张，是什么导致这种结果的？一个是当初写这段代码的人本身写的是直来直去的方法，一堆if else ；后面迭代的开发，面对这么长的代码瞬间失去了从头读到尾的耐心，直接继续在后面加 if else 迭代，最后这个方法就变成了一个缝合怪一样的玩意。</p><p>好的 sql 可以很大程度上简化代码的复杂程度，但是太过复杂sql 本身就会给后来的开发人员造成阅读困难，结果又是变成一条无人敢动的祖传代码，我想这应该是不少公司极度抵制存储过程的原因之一。当然不少银行应用开发还是大量使用存储过程，存储过程有用武之地的，但是一个又臭又长的存储过程就等着变成祖传代码吧。当年我见到一个60多个join的sql，看到第一眼就惊为天人从此难以忘怀，当然那段sql也成了没人敢去动的代码了。</p><h2 id="代码逻辑不明所以"><a href="#代码逻辑不明所以" class="headerlink" title="代码逻辑不明所以"></a>代码逻辑不明所以</h2><p>代码逻辑不明所以是我们开发很容易去犯的毛病，是一个不致命却烦人的毛病。在代码上的体现是，逻辑判断写的比较反人类各种双重否定是肯定，不把你绕晕不罢休。或者是写起代码来东一榔头西一棒槌，让人不知道你想干嘛。导致这个的原因有可能是开发人员在需求理解上出现偏差，做到后面发现不对劲，再回去改又不大可能了，只能硬着头皮往下写，结果就是代码弯弯绕绕；还有很重要的锅是在产品经理，任意变更需求，想一出是一出，开发人员无奈只能跟着想一出写一出。还用可能是开发人员方法或者类命名太艺术了，什么四川方言拼音这种没有十年脑血栓想不出的命名咱就不说了。就说那种国产凌凌漆式的无厘头命名——这看上去是个刮胡刀实际上是个吹风机，就这种不知道让人说什么好。</p><h1 id="规划代码的核心思想"><a href="#规划代码的核心思想" class="headerlink" title="规划代码的核心思想"></a>规划代码的核心思想</h1><p>吐槽了一堆代码规范问题，接下来我们说说如何去规范我们的代码以及如何做到就算开发人员更换了，或者项目转手给他人了，仍然可以让后面的开发可以无碍的去阅读代码修改代码。当然各个公司/团队都有自己的一套代码规范，比如项目的结构、代码命名风格、代码格式等等。不同团队有不同的风格，但核心思想是大同小异的。接下来我就我个人的开发经验来分享一下一些代码规范的思想。</p><h2 id="花叶论"><a href="#花叶论" class="headerlink" title="花叶论"></a>花叶论</h2><p>就我个人而言，这个理解是我代码规范中最浅显也是最核心的思想，只要稍微动动脑子就能想出这个思路出来。或许我们做业务开发的时候，大部分都在写crud，感觉似乎这部分代码没什么规范好说的，其实不然。对一段业务代码而言，我们可以将其分为四类：</p><ul><li>数据校验</li><li>业务逻辑</li><li>数据转换</li><li>数据库交互（查询与持久化）</li></ul><p>大部分时候我们最关心的是逻辑判断相关的代码，其次是数据库交互，对于远程调用的方法，我们就视其为一个普通的方法以简化模型，方法调用算业务逻辑部分的代码，对于读代码的人而言基本上不关心数据校验和数据的转换（DTO转VO等）。因此，代码应该分出一个主次，应该尽量把主逻辑给凸显出来，最好一眼看去就能让人明白这个方法或者这个类干了啥，步骤是什么样的。对于那些不重要但必要的代码我称其为叶，对于那些主要的代码我称其为花。叶是为了衬托花的，因此我们应该将那些叶子代码精简或者隐藏起来。</p><p>隐藏叶子代码，突出主干逻辑的一些手法</p><p>1）Converter（转换器）</p><p>大部分时候我们使用 bean 拷贝使用的是 <code>BeanUtils</code> 这个类来完成，然而一些稍微复杂的实体转换，这个类就无法胜任了，这个时候我们只能手动的 get set ,往往就是这些get set 方法掩盖了主干逻辑，让代码结构不清晰。因此我建议在你的业务逻辑代码中引入 <code>1）Converter</code> 这个角色来专门负责数据的传递与转换。</p><p>2）manager 层</p><p>无论我们使用的持久层框架是哪一种，jpa 或者 mybatis 我觉得我们都应该对持久层的部分方法进行简单封装一下，这也是阿里规范里面提倡的。这样做好处是明显的，我们做一个查询时往往要 set 一些查询条件或者对查询结果进行一些简单的判断，往往这类操作在业务代码可能有比较高的重复性。如果把这些代码放到业务逻辑代码里面，少量还好，多了的话就显得很臃肿了。如果把这种代码移到manager层里面去，不仅主业务逻辑代码不会被干扰，还能提高一定的代码复用率。</p><p>3）方法简单封装<br>假设我们一个方法要完成一端逻辑要分成三大步，而每一个步骤又分成几个小步骤，那我们就可以将这个方法拆分成三个方法，然后在这三个方法里面完成各自的步骤。这手法是很简单的，想必大家都能想到，但是我这里要介绍的是简化复杂方法封装的神器——函数式编程，我这里指的函数式编程不仅仅是 stream 流和 lambda 表达式的使用。函数式编程封装适用的场景是：整个流程比较固定，但是某几个步骤变化是不确定的。我们可以去看看 <code>java.util.function</code> 这个包的源码，你会发现这个包下面全是接口，这些接口被称为函数式接口。这些函数式接口总体上分为四类：</p><ul><li>Function 类型：传入一个bean 返回另外一个bean</li><li>Consumer 类型：传入一个bean 无返回值</li><li>Predicate 类型：传入一个bean 返回布尔值</li><li>Supplier 类型：没有入参，有出参</li></ul><p>以 Consumer 的使用为例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(Consumer&lt;User&gt; consumer)</span></span>&#123;</span><br><span class="line">    User user=<span class="hljs-keyword">new</span> User();</span><br><span class="line">    consumer.accept(user);</span><br><span class="line">    user=userMapper.getUser(user);</span><br><span class="line">    <span class="hljs-keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething1</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    User user=getUser(user-&gt;&#123;user.setId(<span class="hljs-number">1L</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething2</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    User user=getUser(user-&gt;&#123;user.setName(<span class="hljs-string">"xxx"</span>)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式编程的想象空间很大，使用的得当必定会简化你的代码，提高代码复用率。但是在多线程中使用函数式要留意数据的可见性问题。</p><h2 id="日志和注释的一些个人经验"><a href="#日志和注释的一些个人经验" class="headerlink" title="日志和注释的一些个人经验"></a>日志和注释的一些个人经验</h2><p>1）日志</p><p>首先我们要明白日志是给人看的，你加这段日志时要考虑清楚，有没有人会去查这段日志，这段日志有没有用。然后我们查阅日志的时候，一般会通过关键词去搜索；因此我们打的日志一定要有关键词，而且这个关键词不要和其他日志重复，不要过长，便于搜索才是王道。大部分情况我们查看日志都是为了追溯bug，那么一个基本原则就是能通过日志分析出业务逻辑或者流程的走向，对此我建议打日志的地方：</p><ul><li>数据更新：我们有必要知道写库的数据是不是正确的数据；</li><li>条件分支：便于我们分析业务走的哪一条逻辑；</li><li>批量写库：打上数据量大小的日志，便于我们分析性能瓶颈。</li></ul><p>并不是所有的这些地方都应该打上日志，有的时候我们可能只需要通过一两条日志就能分析出整个流程的问题点在哪，这个时候其他的日志就显得多余了。还有我们打完日志之后应该在本地环境追溯一下，看看这些日志自己是否能读懂，是否有必要，是否少了重要参数。</p><p>2）注释</p><p>最基本的两个注释——类注释，方法注释相关规范阿里开发手册上就有，我这里就不复述了，我分享下我写注释的个人习惯。<br>方法注释上除了基本的注释，我还会将产品需求的原文贴重要的部分上去再写上日期，这样做的好处是让别人明白产品需求要求干啥这个方法该干啥，而且产品经理偷偷改需求你还能有追查的根据，有个小本本偷偷记录他的罪行。</p><p>代码注释我分享一个我偷师来的小技巧：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">pulic <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-comment">/** 1. 从excel 获取 vo*/</span></span><br><span class="line">    Workbook workBook = getWorkBook(wookbookStream);</span><br><span class="line">    <span class="hljs-comment">//获取成员信息</span></span><br><span class="line">    Sheet userSheet = workBook.getSheetAt(<span class="hljs-number">3</span>);</span><br><span class="line">     Map&lt;String, UserVO&gt; userVOMap = getUserForExcel(file, userSheet);</span><br><span class="line">    <span class="hljs-comment">// 获取项目vo</span></span><br><span class="line">    Sheet projectSheet = workBook.getSheetAt(<span class="hljs-number">0</span>);</span><br><span class="line">    ProjectVO projectVO = getProjectForExcel(file, isInsert, userVOMap);</span><br><span class="line">    <span class="hljs-comment">// 获取任务vo</span></span><br><span class="line">    Sheet taskSheet = workBook.getSheetAt(<span class="hljs-number">1</span>);</span><br><span class="line">    Map&lt;String, TaskVO&gt; taskVOMap = getTaskListForExcel(file, taskSheet, userVOMap);</span><br><span class="line">    <span class="hljs-comment">/** 2. 插入数据 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (isInsert.get())&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="hljs-comment">/** 3.写入异常信息 */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!isInsert.get()) &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，对于主干的步骤 我用 <code>/** 1. */</code>  <code>/** 2. */</code> javadoc的注释来标注了，而普通的注释我用 <code>//</code> 标注，因为idea 在纯黑主题下会给 <code>/**</code> 这样的注释配上绿色，会比较显眼。我通过这种方式来强调我代码那些是花，哪些是叶子。当然这种方式实际上是不大符合代码规范的，小伙伴们理性取舍，这种手法未必好。</p><h2 id="六大基本原则"><a href="#六大基本原则" class="headerlink" title="六大基本原则"></a>六大基本原则</h2><p>对于面向对象的的语言，六大基本是很重要的开发准则，但似乎大部分人在写代码的时候都不大在意这个，这也是导致一个方法变得又臭又长的一个重要原因之一。对于类的复杂度我们应该遵循单一职责原则——一个类或者方法承担的职责越多，它被复用的可能性就越小，重构或者修改起来就会变得困难重重，我们应该尽量让一个方法只去做一件事情。</p><p>对于许多代码我们只要通过一些简单的手法就能很好的提高其扩展性，比如通过接口去实现类与类之间的协作就能提前解决掉许多未知隐患，而且运用得当的情况下还能满足开闭原则与里氏替换原则，其实service层的设计就有那么点味道了，而且spring的特性也支持接口注入List和map，然而许多开发多年的同学都不知道这个特性，这个特性在许多场景下可以提高代码的扩展性，众所周知，map可以减少代码的 if else 分支。</p><h2 id="方法命名-‘潜规则’"><a href="#方法命名-‘潜规则’" class="headerlink" title="方法命名 ‘潜规则’"></a>方法命名 ‘潜规则’</h2><p>很多时候，好的方法命名本身就是对代码的一种注释，我这里好的方法命名是指大家约定俗成的命名规则。如果你多留心各个开源框架的代码都会发现一些特定的命名规则。阿里开发手册里面也列举不少命名前缀与后缀的规范，其实各个团队可以根据自己的实际情况规定一些命名规则，降低团队内部的代码阅读的成本。关于我的文章   <a href="https://mp.weixin.qq.com/s/k6utPTmuDmdLwSM9U-f4tA" target="_blank" rel="noopener">设计模式杂谈</a></p><p>介绍过部分命名规则，感兴趣的小伙伴可以去看看。</p><h2 id="代码提交及版本控制"><a href="#代码提交及版本控制" class="headerlink" title="代码提交及版本控制"></a>代码提交及版本控制</h2><p>正确代码提交日志格式可以帮助开发人员及时的缕清代码的修改历史，从而快速的定位问题。以git为例，我们大部分人提交日志就是几个字而已，当然你能够通过日志去定位到自己的修改历史的话，这样做也没什么大问题，但是对于团队而言，你的修改日志要让别人能看懂就得按一定的格式来写了。Git Commit message的 Angular规范中定义的 commit message 格式有3个内容：</p><ul><li>Header Header部分有3个字段： type(必需), scope(可选), subject(必需)</li><li>Body 部分是对本次 commit 的详细描述，可以分成多行。</li><li>Footer不常用，可为空 包括不兼容变动、关闭issue。</li></ul><p>这里由于篇幅问题不细说，感兴趣的小伙伴可以百度查查资料。我们团队不一定要按照这么严格的规则来，但是可以制定一个类似的规范来管理提交日志。</p><p>对于团队而言，gitflow 是一个很不错的开发流程。可以很大程度上管理好我们的分支代码，避免团队的人由于误操作而导致某个重要分支出现问题。下面贴出gitflow 流程图，对于其具体内容同样不会介绍太多，感兴趣小伙伴去百度吧</p><p><img src="http://img.itboyhub.com/2020/20210108160529.png" alt></p><h1 id="帮助代码规范的工具"><a href="#帮助代码规范的工具" class="headerlink" title="帮助代码规范的工具"></a>帮助代码规范的工具</h1><p>本节主要介绍提高代码质量的idea插件和框架，当然大名鼎鼎的 阿里代码规范插件咱就不介绍了，想必大家多少了解。不过本人感觉这个插件并不适合一些团队，一是感觉这个规范太过严格，对开发人员素质要求太高，二是有的团队有自己的规范规则，而且有可能和阿里规范冲突，不适用于这个插件。下面介绍的插件可能不适合一些小伙伴。我列举出来大家自己寻思吧。</p><h2 id="mapstruct"><a href="#mapstruct" class="headerlink" title="mapstruct"></a>mapstruct</h2><p>对于我而言是很喜欢这个东西的，这个框架解决的问题其实就是我上文提到的花叶论中的 “数据转换” 的问题。其实不少公司也有类似的概念——定义一个工具类作用是将 DO转VO 或者 VO转DTO等，一般这类类都是以 <code>converter</code> 结尾。而mapstruct这个框架通过编译期生成字节码来自动的生成bean的转换类。我们想将一个bean的数据赋值给另外一个bean只需要去定义接口即可。这样既减轻了开发人员的工作量还将无意义的get和set方法从逻辑代码块中剔除出去。这个框架的缺点是字节码缓存问题，用过类似自动生成字节码工具的小伙伴应该知道——mapstruct 是根据接口去自动生成类的，当我们更新了接口的时候，这个类有可能没重新生成，当然这只有用idea调试的时候才会有的问题，所以也不必太担心。</p><h2 id="checkStyle"><a href="#checkStyle" class="headerlink" title="checkStyle"></a>checkStyle</h2><p>idea checkStyle 插件可以通过自定义配置文件来统一团队的代码风格和代码规范，降低团队的交流成本，一般配合 save actions Reborn 食用更佳。关于checkStyle的配置文件网上也不少，这里也不贴出来占篇幅了。</p><h2 id="git-flow"><a href="#git-flow" class="headerlink" title="git flow"></a>git flow</h2><p>前文提到过git flow 给团队带来的好处，idea也有对应的插件——git Flow Integration，可以通过这个插件来规范我们的流程：</p><p><img src="http://img.itboyhub.com/2020/20210108160614.png" alt></p><p>开发新功能选择 start Feature 拉取分支，修复bug 选择 Start Bugfix 拉取分支，等等。此外还有 push on finish等功能，小伙伴如果感兴趣可以百度。</p><h2 id="Git-Commit-Template"><a href="#Git-Commit-Template" class="headerlink" title="Git Commit Template"></a>Git Commit Template</h2><p>这个主要是用来规范git commit 的一个idea插件小工具了，github上也有类似的开源插件。团队内部也可以自己开发一个类似插件，比较简单，成本也不高。</p><p>代码规范的一些个人看法就聊到这了，喜欢的小伙伴可以分享一下哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文由读者 muggle 投稿，muggle 是一位具备极客精神的 90 后单身老实猿，目前在腾讯云担任研发工程师。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="Tencent" scheme="http://www.javaboy.org/tags/Tencent/"/>
    
      <category term="腾讯" scheme="http://www.javaboy.org/tags/%E8%85%BE%E8%AE%AF/"/>
    
  </entry>
  
  <entry>
    <title>2020 原创干货汇总，小伙伴们要的文章索引来啦！</title>
    <link href="http://www.javaboy.org/2021/0104/2020-article.html"/>
    <id>http://www.javaboy.org/2021/0104/2020-article.html</id>
    <published>2021-01-04T14:36:43.000Z</published>
    <updated>2021-03-07T15:08:43.671Z</updated>
    
    <content type="html"><![CDATA[<p>特意去找了下 2019 年的文章汇总：</p><ul><li><a href="https://mp.weixin.qq.com/s/KApZpgmsx-ZsLOdcsvbm4g" target="_blank" rel="noopener">2019 ，117 篇原创技术干货整理</a></li></ul><p>松哥最近抽空也整理了 2020 年的原创文章，整理完一数，我自己都惊呆了！</p><p>小伙伴们可以在公众号后台分别回复 <strong>2019</strong>、<strong>2020</strong> 关键字获取不同年度的文章索引。</p><a id="more"></a><p>以下是 2020 年文章索引。</p><p><strong>注：加 * 的是【视频+图文】教程。</strong></p><p>【<a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">松哥要升级 SpringBoot 视频了，看看新增了哪些内容！</a>】</p><h2 id="1-微人事相关"><a href="#1-微人事相关" class="headerlink" title="1.微人事相关"></a>1.微人事相关</h2><p>这个系列是松哥 2020 年陆陆续续写的/录制的一些关于微人事项目以及前后端分离架构的一些文章/视频。</p><ol><li>*<a href="https://mp.weixin.qq.com/s/aMu1qi46FbzIe0amJ4XJ7w" target="_blank" rel="noopener">我是如何在微人事项目中提高RabbitMQ消息可靠性的？</a></li><li>*<a href="https://mp.weixin.qq.com/s/SMPyyZlRvvKM-kSMbOOQAw" target="_blank" rel="noopener">Spring Boot 整合 RabbitMQ，消息重复消费怎么办？</a></li><li>*<a href="https://mp.weixin.qq.com/s/dcJv6BIVFPnokI8nBf4IrQ" target="_blank" rel="noopener">微人事常见部署问题汇总</a></li><li>*<a href="https://mp.weixin.qq.com/s/aaop_dS9UIOgTtQd0hl_tw" target="_blank" rel="noopener">松哥手把手教你给微人事添加登录验证码</a></li><li>*<a href="https://mp.weixin.qq.com/s/tIFyi2EiQRhdaOZi7bMoGw" target="_blank" rel="noopener">Spring Boot+Vue+FastDFS 实现前后端分离文件上传</a></li><li>*<a href="https://mp.weixin.qq.com/s/rXhXFXDhyYDP4F47Uat1DQ" target="_blank" rel="noopener">Spring Boot+Vue前后端分离，如何避免前端页面 404</a></li><li>*<a href="https://mp.weixin.qq.com/s/vIhnSwG06PRcU9-AhiI1Gg" target="_blank" rel="noopener">如何提高Spring Boot+Vue前后端分离项目首页加载速度</a></li><li>*<a href="https://mp.weixin.qq.com/s/NuTmEUQU5L69is53bCauKA" target="_blank" rel="noopener">Nginx 动态压缩与静态压缩，显著提高前后端分离项目响应速度！</a></li><li>*<a href="https://mp.weixin.qq.com/s/rzlALs0kW2PDzQ8OSPQMlA" target="_blank" rel="noopener">微人事首页加载速度提高了 5 倍，我都做了什么？</a></li><li>*<a href="https://mp.weixin.qq.com/s/RHoXwIn6J-O8tbVjsYIcBQ" target="_blank" rel="noopener">前后端分离中，使用 JSON 格式登录原来这么简单！</a></li><li>*<a href="https://mp.weixin.qq.com/s/VKtt9nC7PCHmiUI8oZ1CTw" target="_blank" rel="noopener">看懂这篇文章，前后端分离再和面试官扯皮就没问题了</a></li><li>*<a href="https://mp.weixin.qq.com/s/KWBtHi_au_1pH70OYptjfA" target="_blank" rel="noopener">手把手教你部署前后端分离项目，再也不用担心跨域问题了</a></li><li><a href="https://mp.weixin.qq.com/s/yabpyA90D1yUtWRNr330yA" target="_blank" rel="noopener">简化微人事部署，Flyway 搞起来</a></li><li>*<a href="https://mp.weixin.qq.com/s/KAhdOpNGj0KNhbWD9VSR-A" target="_blank" rel="noopener">从 45MB 到 2MB，微人事的减肥瘦身路，瘦成一道闪电！</a></li><li>*<a href="https://mp.weixin.qq.com/s/rUde6XSGSG0jKuy0Wgf1Mw" target="_blank" rel="noopener">微人事一键生成数据库文档！炫！</a></li><li><a href="https://mp.weixin.qq.com/s/ge8nWbVsj1-6d24l2SXMAw" target="_blank" rel="noopener">推荐三个 Vue 后台管理模版，配合 Spring Boot 使用真香！</a></li><li>*<a href="https://mp.weixin.qq.com/s/Jx8Hnyvtm5zYrLc7rvD-Ag" target="_blank" rel="noopener">Spring Boot+Vue 文件上传，如何携带令牌信息？</a></li><li><a href="https://mp.weixin.qq.com/s/se7kTvW1BBl1Z_jtROevoA" target="_blank" rel="noopener">前后端分离开发中动态菜单的两种实现方案</a></li><li><a href="https://mp.weixin.qq.com/s/qxy_KZk5wOgwNta21_Hrew" target="_blank" rel="noopener">前后端分离开发，Vue 如何处理跨域问题？</a></li><li>*<a href="https://mp.weixin.qq.com/s/Ki6sJbAS-24OPn9YcnrZhQ" target="_blank" rel="noopener">SpringBoot+Vue实现文件上传+预览</a></li></ol><h2 id="2-SpringBoot-拾遗"><a href="#2-SpringBoot-拾遗" class="headerlink" title="2.SpringBoot 拾遗"></a>2.SpringBoot 拾遗</h2><p>为什么要加上拾遗呢？因为松哥在 2019 年其实写过完整的 Spring Boot 教程，2020 年又在之前的基础上补充了一些内容。之前的教程大家可以在公众号后台回复 666 获取 PDF 下载链接。</p><ol><li><a href="https://mp.weixin.qq.com/s/4RABulz1wDbLPjJSNgI0Qw" target="_blank" rel="noopener">Spring Boot 要怎么学？要学哪些东西？要不要先学 SSM？松哥说说看法</a></li><li><a href="https://mp.weixin.qq.com/s/x8-G789jiWo5MgGLoOmhbQ" target="_blank" rel="noopener">274 页 pdf 文档，Spring Boot 教程也有离线版了</a></li><li>*<a href="https://mp.weixin.qq.com/s/bDiPhqPjEyCbXhmAx1btpg" target="_blank" rel="noopener">Spring Boot 国际化踩坑指南</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li><li>*<a href="https://mp.weixin.qq.com/s/3gu8tuJduFp--AyDsnH0yg" target="_blank" rel="noopener">手把手教你 Spring Boot 自定义注解</a></li><li>*<a href="https://mp.weixin.qq.com/s/rkM1MssHolLgTPoY0gOV_w" target="_blank" rel="noopener">自定义注解的两种姿势！</a></li><li>*<a href="https://mp.weixin.qq.com/s/ye4kgzTB-IpK6cRWwws1yw" target="_blank" rel="noopener">手把手教大家撸一个 Spring Boot Starter！</a></li><li>*<a href="https://mp.weixin.qq.com/s/Mm1-eGNqutA8Ey7fSSqzyQ" target="_blank" rel="noopener">和大家聊聊 Spring Boot 日志</a></li><li>*<a href="https://mp.weixin.qq.com/s/njln6ZcrntLCbzZgvDCm0g" target="_blank" rel="noopener">如何将自己开发的 starter 分享到公网？</a></li><li>*<a href="https://mp.weixin.qq.com/s/bC9alOXrTiXA9VVphJolTw" target="_blank" rel="noopener">@Configuration和@Component可以混用吗</a></li><li>*<a href="https://mp.weixin.qq.com/s/8ee39iQmGC0mcCGAFLsUDw" target="_blank" rel="noopener">SpringBoot 启动注解详解</a></li><li><a href="https://mp.weixin.qq.com/s/kkp2PTC3rbmHlXHnF95FLw" target="_blank" rel="noopener">Spring Boot 日志各种使用姿势，是时候捋清楚了！</a></li><li><a href="https://mp.weixin.qq.com/s/Uvv1q3iQn2IwAB1crHWS1g" target="_blank" rel="noopener">细品 Spring Boot+Thymeleaf，还有这么多好玩的细节！</a></li><li>*<a href="https://mp.weixin.qq.com/s/-WFR5KFG9VD_90fpNwbphA" target="_blank" rel="noopener">详解SpringBoot内嵌Tomcat日志配置</a></li><li><a href="https://mp.weixin.qq.com/s/1TZfOBMtrTJ7qKHEduLUEw" target="_blank" rel="noopener">Spring Boot + Freemarker 中的弯弯绕！</a></li><li>*<a href="https://mp.weixin.qq.com/s/2Ovqwn1hd40D7FtKE60HKw" target="_blank" rel="noopener">代码自动生成很难吗？松哥手把手教大家整一个！</a></li><li>*<a href="https://mp.weixin.qq.com/s/2m3cGlYmNOBe-1s5TT5DjA" target="_blank" rel="noopener">手把手教大家整一个代码自动生成工具（二）</a></li><li>*<a href="https://mp.weixin.qq.com/s/sNr1mnNhQyVBkFbEXWtLHQ" target="_blank" rel="noopener">Spring Boot 处理跨域的 四 种方式！</a></li></ol><h2 id="3-SpringSecurity-系列"><a href="#3-SpringSecurity-系列" class="headerlink" title="3.SpringSecurity 系列"></a>3.SpringSecurity 系列</h2><p>Spring Security 系列是 2020 年的重头戏，写了不少。</p><ol><li>*<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a></li><li>*<a href="https://mp.weixin.qq.com/s/jQZx4i4-vqjpBjpoJKJF4A" target="_blank" rel="noopener">Spring Security 如何动态更新已登录用户信息？</a></li><li>*<a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li>*<a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li>*<a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li>*<a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li>*<a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li>*<a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li>*<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li>*<a href="https://mp.weixin.qq.com/s/qUDZdTPc4-2UtmHtFI4v-g" target="_blank" rel="noopener">奇怪，Spring Security 登录成功后总是获取不到登录用户信息？</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li><li>*<a href="https://mp.weixin.qq.com/s/p9S07M7VV4eQOiUpwslPPg" target="_blank" rel="noopener">微人事如何像 QQ 一样实现登录互踢？松哥手把手教大家</a></li><li><a href="https://mp.weixin.qq.com/s/uWib5RtH1aEC7p5VK4S1Ig" target="_blank" rel="noopener">Spring Boot+CAS 默认登录页面太丑了，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/LvMOKeX09liTvujZi6XO3Q" target="_blank" rel="noopener">用 Swagger 测试接口，怎么在请求头中携带 Token？</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li><li><a href="https://mp.weixin.qq.com/s/7T5XA1zxQkhMvffMxHKVvQ" target="_blank" rel="noopener">Spring Boot 中如何实现 HTTP 认证？</a></li><li><a href="https://mp.weixin.qq.com/s/7cm99q5ZM4qUkekx0Xa0YQ" target="_blank" rel="noopener">Spring Security 中的四种权限控制方式</a></li><li><a href="https://mp.weixin.qq.com/s/_iau1jsnc50vs794_ib0IA" target="_blank" rel="noopener">Spring Security 多种加密方案共存，老破旧系统整合利器！</a></li><li><a href="https://mp.weixin.qq.com/s/edtYkmgx_SnYoqsy-yFmsQ" target="_blank" rel="noopener">神奇！自己 new 出来的对象一样也可以被 Spring 容器管理！</a></li><li><a href="https://mp.weixin.qq.com/s/42-rjiZShvZXYM_ULQt0YQ" target="_blank" rel="noopener">Spring Security 配置中的 and 到底该怎么理解？</a></li><li><a href="https://mp.weixin.qq.com/s/f1teXTEuDR7S0j_Ml2qL8g" target="_blank" rel="noopener">一文搞定 Spring Security 异常处理机制！</a></li><li><a href="https://mp.weixin.qq.com/s/dm2SmUzb7vQZA3C0NFp86A" target="_blank" rel="noopener">写了这么多年代码，这样的登录方式还是头一回见！</a></li><li><a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a></li><li><a href="https://mp.weixin.qq.com/s/sF4vPZQv7rtBYhBhmONJ5w" target="_blank" rel="noopener">Spring Security 可以同时对接多个用户表？</a></li><li><a href="https://mp.weixin.qq.com/s/4dcQ6lohB3sEcnkAXxdZwg" target="_blank" rel="noopener">在 Spring Security 中，我就想从子线程获取用户登录信息，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/EZsChg5YG0TBadU4q_CAnA" target="_blank" rel="noopener">深入理解 FilterChainProxy【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/PWIM9jgEB-F-m4Ove470wg" target="_blank" rel="noopener">深入理解 SecurityConfigurer 【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/LBgZu-mBifPG_-azCG7Lcg" target="_blank" rel="noopener">花式玩 Spring Security ，这样的用户定义方式你可能没见过！</a></li><li><a href="https://mp.weixin.qq.com/s/vP-QGm9GNxMInIeGSZvWwQ" target="_blank" rel="noopener">深入理解 WebSecurityConfigurerAdapter【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/d2o9QpK1EfBMRR8zfHhv2g" target="_blank" rel="noopener">盘点 Spring Security 框架中的八大经典设计模式</a></li><li><a href="https://mp.weixin.qq.com/s/D0weIKPto4lcuwl9DQpmvQ" target="_blank" rel="noopener">Spring Security 初始化流程梳理</a></li><li><a href="https://mp.weixin.qq.com/s/0WOefpO6-aYSIRNiNnijyg" target="_blank" rel="noopener">为什么你使用的 Spring Security OAuth 过期了？松哥来和大家捋一捋！</a></li><li><a href="https://mp.weixin.qq.com/s/-kDQbP1htEfn_8n7ZfKqmA" target="_blank" rel="noopener">一个诡异的登录问题</a></li><li><a href="https://mp.weixin.qq.com/s/9yK32E44UnIep-5iX0s2Ow" target="_blank" rel="noopener">什么是计时攻击？Spring Boot 中该如何防御？</a></li><li><a href="https://mp.weixin.qq.com/s/1ZWyD41R827FhghiCHY-Sw" target="_blank" rel="noopener">Spring Security 中如何让上级拥有下级的所有权限？</a></li><li><a href="https://mp.weixin.qq.com/s/sU97RQjQq2-XXQt49LkSeQ" target="_blank" rel="noopener">Spring Security 权限管理的投票器与表决机制</a></li><li><a href="https://mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw" target="_blank" rel="noopener">Spring Security 中的 hasRole 和 hasAuthority 有区别吗？</a></li><li><a href="https://mp.weixin.qq.com/s/Q9lfrJ3iioUpYEO9elCtsw" target="_blank" rel="noopener">Spring Security 中如何细化权限粒度？</a></li><li><a href="https://mp.weixin.qq.com/s/98CIxDVrhAiE14EXvgf7Vw" target="_blank" rel="noopener">一个案例演示 Spring Security 中粒度超细的权限控制！</a></li><li><a href="https://mp.weixin.qq.com/s/B03cDEE1i3gT0yDhIxGATw" target="_blank" rel="noopener">Spring Security 中最流行的权限管理模型！</a></li><li><a href="https://mp.weixin.qq.com/s/FzNpjyjbi6bQEEkUDRsnXA" target="_blank" rel="noopener">我又发现 Spring Security 中一个小秘密！</a></li><li><a href="https://mp.weixin.qq.com/s/K5YDMBREzObp2yrmLtGdjw" target="_blank" rel="noopener">聊一个 GitHub 上开源的 RBAC 权限管理系统，很6！</a></li><li><a href="https://mp.weixin.qq.com/s/obLTxCddhJ0kqTqoVN-Axg" target="_blank" rel="noopener">RBAC 案例解读【2】</a></li></ol><h2 id="4-OAuth2-系列"><a href="#4-OAuth2-系列" class="headerlink" title="4.OAuth2 系列"></a>4.OAuth2 系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li><li><a href="https://mp.weixin.qq.com/s/aOXsHSPowmR2zLkF41wPlQ" target="_blank" rel="noopener">和大家分享一点微服务架构中的安全管理思路</a></li><li><a href="https://mp.weixin.qq.com/s/EyAMTbKPqNNnEtZACIsMVw" target="_blank" rel="noopener">Spring Boot+OAuth2，一个注解搞定单点登录！</a></li><li>*<a href="https://mp.weixin.qq.com/s/Zm-K7R1UGEaIKtwdnw6JuQ" target="_blank" rel="noopener">松哥手把手教你玩转 OAuth2 授权码模式|视频版</a></li><li><a href="https://mp.weixin.qq.com/s/tq4Q306J3hJFEtGL1EpOBA" target="_blank" rel="noopener">分分钟让自己的网站接入 GitHub 第三方登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/lnuAejqGqh_8W_-GHEq5gA" target="_blank" rel="noopener">Spring Boot+OAuth2，如何自定义返回的 Token 信息？</a></li><li><a href="https://mp.weixin.qq.com/s/0WOefpO6-aYSIRNiNnijyg" target="_blank" rel="noopener">为什么你使用的 Spring Security OAuth 过期了？松哥来和大家捋一捋！</a></li><li><a href="https://mp.weixin.qq.com/s/xJSyPVRq0EwvTi_TBjCI1g" target="_blank" rel="noopener">OAuth2，想说懂你不容易</a></li><li>*<a href="https://mp.weixin.qq.com/s/IvknutwE-mIA8cPlJ1UWHA" target="_blank" rel="noopener">第三方登录从未如此简单～</a></li></ol><h2 id="5-ElasticSearch-系列"><a href="#5-ElasticSearch-系列" class="headerlink" title="5.ElasticSearch 系列"></a>5.ElasticSearch 系列</h2><p>Es 系列是年底在连载的一个系列，都是视频+图文的形式，目前还没连载完，已经更新的内容索引如下：</p><ol><li><a href="https://mp.weixin.qq.com/s/JmHu5rUX9nskCWbKmBFG6w" target="_blank" rel="noopener">打算出一个 ElasticSearch 教程，谁赞成，谁反对？</a></li><li><a href="https://mp.weixin.qq.com/s/QnBqoaptV5-xKIpOBKSfHQ" target="_blank" rel="noopener">ElasticSearch 从安装开始</a></li><li><a href="https://mp.weixin.qq.com/s/heSNVTPHaCTTjek0RqkSqA" target="_blank" rel="noopener">ElasticSearch 第三弹，核心概念介绍</a></li><li><a href="https://mp.weixin.qq.com/s/wpLeWIgq6yQEolKcv_P8hA" target="_blank" rel="noopener">ElasticSearch 中的中文分词器该怎么玩？</a></li><li><a href="https://mp.weixin.qq.com/s/2Hz-5gwMO_G-py8_F3xvmg" target="_blank" rel="noopener">ElasticSearch 索引基本操作</a></li><li><a href="https://mp.weixin.qq.com/s/k6cDNSjD8j7OK_E4-sNgXA" target="_blank" rel="noopener">ElasticSearch 文档的添加、获取以及更新</a></li><li><a href="https://mp.weixin.qq.com/s/FzX8BvtN7m4BvE6QgAEX7g" target="_blank" rel="noopener">ElasticSearch 文档的删除和批量操作</a></li><li><a href="https://mp.weixin.qq.com/s/tcnM81Td1pquzk5NYkq0cw" target="_blank" rel="noopener">ElasticSearch 文档路由，你的数据到底存在哪一个分片上？</a></li><li><a href="https://mp.weixin.qq.com/s/plbetxvP3SD3t6MMGFeX-w" target="_blank" rel="noopener">ElasticSearch 并发的处理方式：锁和版本控制</a></li><li><a href="https://mp.weixin.qq.com/s/x0WHs6uvzt-W1xvjLNf5rg" target="_blank" rel="noopener">ElasticSearch 中的倒排索引到底是什么？</a></li><li><a href="https://mp.weixin.qq.com/s/IFqsn1q_NIS38cb2W3Wmgg" target="_blank" rel="noopener">ElasticSearch 动态映射与静态映射</a></li><li><a href="https://mp.weixin.qq.com/s/SWHb-fFE2RWEU_oI38u_vg" target="_blank" rel="noopener">ElasticSearch 四种字段类型详解</a></li><li><a href="https://mp.weixin.qq.com/s/vRc2j5F5cCZnrZ1qBsvrcw" target="_blank" rel="noopener">ElasticSearch 中的地理类型和特殊类型</a></li><li><a href="https://mp.weixin.qq.com/s/4EjotbmTfB-inqV6zK1lpg" target="_blank" rel="noopener">ElasticSearch 23 种映射参数详解</a></li><li><a href="https://mp.weixin.qq.com/s/WAj8v6XNax-3SB5VzX8KOg" target="_blank" rel="noopener">ElasticSearch 如何配置某个字段的权重？</a></li><li><a href="https://mp.weixin.qq.com/s/QjY0dDMyawOwovFxjOETYg" target="_blank" rel="noopener">ElasticSearch 23 种映射参数详解【3】</a></li><li><a href="https://mp.weixin.qq.com/s/3rFq29_SkT5vxZfZbKog-g" target="_blank" rel="noopener">ElasticSearch 映射模版</a></li><li><a href="https://mp.weixin.qq.com/s/WVInd3kCciTVa1nzOgeEAQ" target="_blank" rel="noopener">ElasticSearch 搜索入门</a></li><li><a href="https://mp.weixin.qq.com/s/1L2sJoqTAxk46WulZZtKGw" target="_blank" rel="noopener">ElasticSearch 全文搜索怎么玩？</a></li><li><a href="https://mp.weixin.qq.com/s/ReiCivwDINsE8S5kwUWb5w" target="_blank" rel="noopener">ElasticSearch 打错字还能搜索到？试试 fuzzy query！</a></li><li><a href="https://mp.weixin.qq.com/s/59D8ouXbTMlh4swb6eY2zA" target="_blank" rel="noopener">ElasticSearch 复合查询，理解 Es 中的文档评分策略！</a></li><li><a href="https://mp.weixin.qq.com/s/AGKF8S3FVMPTzgVVG42W4Q" target="_blank" rel="noopener">想搜索附近评分较高的餐厅，ElasticSearch 大显身手！</a></li><li><a href="https://mp.weixin.qq.com/s/SDRI7GmZmmO7bLvhCgUDCg" target="_blank" rel="noopener">ElasticSearch 如何像 MySQL 一样做多表联合查询？</a></li><li><a href="https://mp.weixin.qq.com/s/SiwN5_-jjPbPyd86XK5-dg" target="_blank" rel="noopener">ElasticSearch 地理位置查询与特殊查询</a></li><li><a href="https://mp.weixin.qq.com/s/pxHjq0ejT0Fy9v7-dpg0Tw" target="_blank" rel="noopener">ElasticSearch 搜索高亮与排序</a></li><li><a href="https://mp.weixin.qq.com/s/h5sOm7Xzk2XUxmMzTok7xg" target="_blank" rel="noopener">ElasticSearch 指标聚合</a></li><li><a href="https://mp.weixin.qq.com/s/kEDmfVzIOldM6EkwiEIdoQ" target="_blank" rel="noopener">ElasticSearch 桶聚合</a></li><li><a href="https://mp.weixin.qq.com/s/pOCeltC8nhoFGQtgm8uC0Q" target="_blank" rel="noopener">ElasticSearch 管道聚合</a></li></ol><h2 id="6-Spring-源码解读"><a href="#6-Spring-源码解读" class="headerlink" title="6.Spring 源码解读"></a>6.Spring 源码解读</h2><p>Spring 源码解读系列比较遗憾，因为中间有段时间非常忙给落下来了，现在更新了 13 篇，2021 继续更新剩余部分。</p><ol><li><a href="https://mp.weixin.qq.com/s/1ImVkjdmcllArzPOSksNoA" target="_blank" rel="noopener">Spring 源码解读计划</a></li><li><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a></li><li><a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">Spring 源码第二弹！XML 文件解析流程</a></li><li><a href="https://mp.weixin.qq.com/s/vXD79ucsRjbQWbogrzdq9g" target="_blank" rel="noopener">Spring 源码第三弹！EntityResolver 是个什么鬼？</a></li><li><a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a></li><li>*<a href="https://mp.weixin.qq.com/s/8WnRZtHmstum23Ut5EXAug" target="_blank" rel="noopener">Spring源码分析环境搭建</a></li><li><a href="https://mp.weixin.qq.com/s/plNmM_MA8tcPIu9Dpw7VmA" target="_blank" rel="noopener">手把手教你搭建 Spring 源码分析环境（视频笔记）</a></li><li><a href="https://mp.weixin.qq.com/s/vQatn3w9BvdSdOY05yQa0Q" target="_blank" rel="noopener">Spring 源码第六弹！松哥和大家聊聊容器的始祖 DefaultListableBeanFactory</a></li><li><a href="https://mp.weixin.qq.com/s/dDX7ijnhkrMwlkUcCqOlnw" target="_blank" rel="noopener">Spring 源码解读第七弹！bean 标签的解析</a></li><li><a href="https://mp.weixin.qq.com/s/JB1U28-oVZKTuOqFT1L_tg" target="_blank" rel="noopener">Spring 中四个冷门属性，你可能没用过，挑战看一下！</a></li><li><a href="https://mp.weixin.qq.com/s/_FG7qePUVO42Vh2Pfhj-rg" target="_blank" rel="noopener">Spring 源码第 8 篇，各种属性的解析</a></li><li><a href="https://mp.weixin.qq.com/s/uNmbDpiAZ1Lku1GQz7IqDQ" target="_blank" rel="noopener">Spring 源码第 9 篇，深入分析 FactoryBean</a></li><li><a href="https://mp.weixin.qq.com/s/PfLZn-Ir6ejKg1LeH5s2PQ" target="_blank" rel="noopener">Spring 源码系列之容器概览～</a></li></ol><h2 id="7-Spring-Cloud"><a href="#7-Spring-Cloud" class="headerlink" title="7.Spring Cloud"></a>7.Spring Cloud</h2><p>这个不是一个系列，只是随手记的一些东西。不过松哥 2020 年录制了 Spring Cloud 视频，感兴趣的小伙伴公号后台回复 <strong>vhr</strong> 可以查看视频介绍。</p><ol><li>*<a href="https://mp.weixin.qq.com/s/jjV4C6LgBMniGFDg2_0LnQ" target="_blank" rel="noopener">手把手讲解Spring中的Http请求神器RestTemplate</a></li><li>*<a href="https://mp.weixin.qq.com/s/o_M3IEC4ysOHPgUAfanswA" target="_blank" rel="noopener">松哥手把手教你入门 Spring Cloud Alibaba Nacos!</a></li><li><a href="https://mp.weixin.qq.com/s/Hy5kk-0i07a0syGdBg_ucA" target="_blank" rel="noopener">Eureka 都挂了，微服务还能调通吗？</a></li><li><a href="https://mp.weixin.qq.com/s/RpkkbAeUZADdiUDx244eJw" target="_blank" rel="noopener">微服务项目搭建，到底要不要聚合工程？</a></li><li><a href="https://mp.weixin.qq.com/s/GWMBhxXPwYyaQy5RvYD71g" target="_blank" rel="noopener">在微服务项目中，Maven 真的适合管理公共代码库吗？</a></li><li><a href="https://mp.weixin.qq.com/s/PFCzERnFUS7MzMIIMvwA3A" target="_blank" rel="noopener">来一个简单的，微服务项目中如何管理依赖版本号？</a></li></ol><h2 id="8-Redis"><a href="#8-Redis" class="headerlink" title="8.Redis"></a>8.Redis</h2><p>这个也不是一个系列，节选自松哥录制的 Redis 系列视频教程中的三个。</p><ol><li>*<a href="https://mp.weixin.qq.com/s/NKiLt2Ebofa1Wq1k5sFscA" target="_blank" rel="noopener">Redis 做分布式锁你会几种姿势？松哥来给大家介绍两种</a></li><li>*<a href="https://mp.weixin.qq.com/s/ej_9f4iBOAEPIXxxhFcm-A" target="_blank" rel="noopener">松哥手把手教你用 Redis 做延迟消息队列</a></li><li>*<a href="https://mp.weixin.qq.com/s/hAi6Na90hhH12tlrDsH-YA" target="_blank" rel="noopener">so easy！松哥手把手带你撸一个 Redis 的 Java 客户端</a></li></ol><h2 id="9-学习资源"><a href="#9-学习资源" class="headerlink" title="9.学习资源"></a>9.学习资源</h2><ol><li><a href="https://mp.weixin.qq.com/s/zaiqCHNYwghatNd6tcrocg" target="_blank" rel="noopener">推荐七个略火的Spring Boot+Vue开源项目</a></li><li><a href="https://mp.weixin.qq.com/s/1KYqWOjsnoqhwj9KrM8GBg" target="_blank" rel="noopener">松哥搜刮了 2TB 免费 Java 学习资源，记得收藏哦</a></li><li><a href="https://mp.weixin.qq.com/s/CyMXvY-IzY-69Q_uYxxXMA" target="_blank" rel="noopener">Maven 入门，Maven + IDEA 创建多模块项目，松哥手敲了 30 多页教程给大家送来了</a></li><li><a href="https://mp.weixin.qq.com/s/4N0qWTHM2CuUFRoBIBUHwQ" target="_blank" rel="noopener">来了，松哥纯手工打造的超 50 页 Spring 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/4v7VPjSjf5DW86I3ecptFw" target="_blank" rel="noopener">松哥纯手工打造 80 多页的 SpringMVC 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/sf_ZtaZllP4RdyftZghoHQ" target="_blank" rel="noopener">MyBatis 教程来啦，松哥手码的 SSM 教程总算齐活了，小伙伴们可以下载啦</a></li><li><a href="https://mp.weixin.qq.com/s/h59gk0euA6O3Blf8Kpup3Q" target="_blank" rel="noopener">不知不觉松哥已经撸了 8 个原创电子书了，今天打包下载！</a></li><li>*<a href="https://mp.weixin.qq.com/s/aj9Bt1TE1pb8ZPVCpDKI8A" target="_blank" rel="noopener">我为什么要出一套免费视频教程</a></li><li>*<a href="https://mp.weixin.qq.com/s/8N4ZGUwQYo51i1zEQZ6f9Q" target="_blank" rel="noopener">松哥憋了个大招！手把手教你做 SSM 项目！</a></li></ol><h2 id="10-IntelliJ-IDEA-技巧系列"><a href="#10-IntelliJ-IDEA-技巧系列" class="headerlink" title="10.IntelliJ IDEA 技巧系列"></a>10.IntelliJ IDEA 技巧系列</h2><ol><li>*<a href="https://mp.weixin.qq.com/s/7lKrU8jcKRDpdxqm3EdBnw" target="_blank" rel="noopener">松哥再来传授两个IDEA技巧，让编码速度飞起来</a></li><li>*<a href="https://mp.weixin.qq.com/s/_ZL7q87PglBvnKiiWMuxaQ" target="_blank" rel="noopener">玩转 IDEA 之 Postfix Completion</a></li><li>*<a href="https://mp.weixin.qq.com/s/h-Up7RVAMkCxokG_ExZV2A" target="_blank" rel="noopener">玩转 IDEA 之 Maven 依赖自动提示</a></li><li>*<a href="https://mp.weixin.qq.com/s/tWexMGLnQ_riyvSPK8v3Rg" target="_blank" rel="noopener">玩转 IDEA 之快速定义单元测试方法</a></li><li>*<a href="https://mp.weixin.qq.com/s/L6ziJAqfXhrFjuZvRBNfJg" target="_blank" rel="noopener">玩转 IDEA 之 Inject Language</a></li><li>*<a href="https://mp.weixin.qq.com/s/S63uFEiVtE9T7oLUmx7ISg" target="_blank" rel="noopener">玩转 IDEA 之狂拽炫酷的列编辑</a></li><li><a href="https://mp.weixin.qq.com/s/ij3x3UyAamvvyb9VE4qz-A" target="_blank" rel="noopener">懒人必备，IntelliJ IDEA中代码一键生成</a></li></ol><h2 id="11-其他"><a href="#11-其他" class="headerlink" title="11.其他"></a>11.其他</h2><p>一些不方便归类的内容。</p><ol><li><a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a></li><li><a href="https://mp.weixin.qq.com/s/LA8_FPp19MumWNdLg9ljtQ" target="_blank" rel="noopener">MacBook Pro 入手一年了，到底香不香？</a></li><li><a href="https://mp.weixin.qq.com/s/_W1Ism-pyarB1u2wX-gCFw" target="_blank" rel="noopener">不花一分钱，把自己零散的知识整理成体系，制作成在线电子书</a></li><li><a href="https://mp.weixin.qq.com/s/mo4IV1Q20x8H3zdNBcWi2Q" target="_blank" rel="noopener">视频教程最佳食用姿势，顺便说说前后端分离开发 Bug 解决思路</a></li><li><a href="https://mp.weixin.qq.com/s/70MR7N5e5hKzwM-qwm0XxQ" target="_blank" rel="noopener">分布式事务开局第一篇，从数据库事务隔离级别说起</a></li><li><a href="https://mp.weixin.qq.com/s/-JorqG-gPTEWZflCFywIrw" target="_blank" rel="noopener">分布式事务系列第二篇，回顾 Jdbc 事务</a></li><li><a href="https://mp.weixin.qq.com/s/XnIi5ylwTO0pkR-7WDBcAA" target="_blank" rel="noopener">分布式事务系列第三篇，Spring 事务概述</a></li><li><a href="https://mp.weixin.qq.com/s/yvJXiX70iNSdd2mbSQbUCQ" target="_blank" rel="noopener">GitHub 又掉链子，我给微人事 + Spring Boot + Spring Cloud 案例找了新家</a></li><li><a href="https://mp.weixin.qq.com/s/NfZNa1Zn7rSUGFO7by4i1A" target="_blank" rel="noopener">年后跳槽高峰季，关于简历制作，松哥有话说</a></li><li><a href="https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA" target="_blank" rel="noopener">如果你没写过博客，现在就是你写博客的最佳时机</a></li><li><a href="https://mp.weixin.qq.com/s/u1Wng-vJjzIrx0hb3gARsA" target="_blank" rel="noopener">新年新气象，接个私活赚点生活费？恐怕事情没有这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/k3GHndxqb7XexwVs_hs5mg" target="_blank" rel="noopener">写博客必备！手把手教大家搭建免费图床，真香！</a></li><li><a href="https://mp.weixin.qq.com/s/T31D4vI3alj9lnvouGQaXg" target="_blank" rel="noopener">程序员写书到底赚钱吗</a></li><li><a href="https://mp.weixin.qq.com/s/av3DADdBT8jXShccmicmIw" target="_blank" rel="noopener">前两天松哥收到了一份简历，10 年 Java 经验，期望薪资 25k</a></li><li><a href="https://mp.weixin.qq.com/s/sOMSATOaM-ltTUOWqcO_RQ" target="_blank" rel="noopener">今天我要给公众号新出的这个功能点赞！</a></li><li><a href="https://mp.weixin.qq.com/s/3eFdML9FCOB_b9--b4SbsQ" target="_blank" rel="noopener">一台笔记本用多久就可以拿去换脸盆了？</a></li><li><a href="https://mp.weixin.qq.com/s/hhUxT_mQxfZE3ZRiNrWxeA" target="_blank" rel="noopener">怎么样写好一篇技术文章？经验贴速来围观！</a></li><li><a href="https://mp.weixin.qq.com/s/Iumnk14YcBqOmsFfMfLMmg" target="_blank" rel="noopener">松哥读者开发的 Spring Boot 脚手架，速速围观！</a></li><li><a href="https://mp.weixin.qq.com/s/3ZdeAz9-SEpAO98ubE67wA" target="_blank" rel="noopener">“看来真的只有自身强大起来，别人才会理你”</a></li><li><a href="https://mp.weixin.qq.com/s/9PNRu4wqIDzlY-2vNuwImA" target="_blank" rel="noopener">写代码靠天赋还是靠苦功夫？</a></li><li><a href="https://mp.weixin.qq.com/s/Erz8LIx2awuC5DBykcAOIg" target="_blank" rel="noopener">GET 新技能！自己的网站突然就不香了</a></li><li><a href="https://mp.weixin.qq.com/s/jzoDc-JMrrxLVOgm08I47w" target="_blank" rel="noopener">JavaWeb 乱码问题终极解决方案！</a></li><li>*<a href="https://mp.weixin.qq.com/s/LsLnJRFlvAvU2qcKPJ1tCQ" target="_blank" rel="noopener">手把手教你参与开源项目</a></li><li>*<a href="https://mp.weixin.qq.com/s/H5q1DGHX4jIr4fmdyxgDPA" target="_blank" rel="noopener">松哥手把手教大家几个 GitHub 小技巧</a></li><li><a href="https://mp.weixin.qq.com/s/tQLZk0iF_OiiGj3NCdk8hw" target="_blank" rel="noopener">有没有必要报个培训班？</a></li><li><a href="https://mp.weixin.qq.com/s/kLjafHZ55JIOnp0M-bFhcw" target="_blank" rel="noopener">微人事被某培训机构盗去拉人头了，小伙伴们擦亮眼睛别上钩！</a></li><li><a href="https://mp.weixin.qq.com/s/gyEkP650z5_T_MD5ambsWQ" target="_blank" rel="noopener">告别深圳，开启新的旅程</a></li><li>*<a href="https://mp.weixin.qq.com/s/yRLVRu_GMMD8zeajxX4IjA" target="_blank" rel="noopener">GitHub 这样玩才过瘾</a></li><li><a href="https://mp.weixin.qq.com/s/qRrZuKRkDS6CgAPFTqGhKA" target="_blank" rel="noopener">为了避免“内卷”，松哥跑去上海见世面了</a></li><li><a href="https://mp.weixin.qq.com/s/wZLq4qCCmSJi7gyYQKSAWA" target="_blank" rel="noopener">刚过保修期的 MacBook 电池鼓包了。。。怎么就不香了！</a></li><li><a href="https://mp.weixin.qq.com/s/wsjtQxXu59wFEwQ9PZVV3A" target="_blank" rel="noopener">接了两个私活，都是血汗钱</a></li><li><a href="https://mp.weixin.qq.com/s/V39MsjxuStDEiLaWghSyBA" target="_blank" rel="noopener">想做个项目练练手却不知道做啥？松哥准备了 50 个热门需求文档给大家！</a></li><li><a href="https://mp.weixin.qq.com/s/qA4tAi3xBuMzGWS9a-khFg" target="_blank" rel="noopener">Bug 要这样处理才专业！</a></li><li><a href="https://mp.weixin.qq.com/s/N20mYUnHPhdc76K5MayjFQ" target="_blank" rel="noopener">手把手教你用 FastDFS 构建分布式文件管理系统</a></li><li>*<a href="https://mp.weixin.qq.com/s/onZmdgi9kZw0JdAtrNYmow" target="_blank" rel="noopener">听说你 FastDFS 老安装失败，这能忍？松哥一定要帮你搞定！</a></li></ol><p>完结。</p><hr><p>如果觉得松哥的教程还蛮有诚意，也可以看看付费内容哦<a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">松哥要升级 SpringBoot 视频了，看看新增了哪些内容！</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;特意去找了下 2019 年的文章汇总：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KApZpgmsx-ZsLOdcsvbm4g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2019 ，117 篇原创技术干货整理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;松哥最近抽空也整理了 2020 年的原创文章，整理完一数，我自己都惊呆了！&lt;/p&gt;
&lt;p&gt;小伙伴们可以在公众号后台分别回复 &lt;strong&gt;2019&lt;/strong&gt;、&lt;strong&gt;2020&lt;/strong&gt; 关键字获取不同年度的文章索引。&lt;/p&gt;
    
    </summary>
    
      <category term="资料" scheme="http://www.javaboy.org/categories/%E8%B5%84%E6%96%99/"/>
    
    
      <category term="干货汇总" scheme="http://www.javaboy.org/tags/%E5%B9%B2%E8%B4%A7%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>2020最后一天，给自己打个广告</title>
    <link href="http://www.javaboy.org/2020/1231/javaboy-video.html"/>
    <id>http://www.javaboy.org/2020/1231/javaboy-video.html</id>
    <published>2020-12-31T14:36:28.000Z</published>
    <updated>2021-03-07T15:08:35.332Z</updated>
    
    <content type="html"><![CDATA[<p>先来说一下昨天视频的答案：</p><p>昨天视频中和小伙伴们分享了 Spring Boot 跨域的三种方式，留下一种由小伙伴们自由发挥。留言中有一个小伙伴说出了答案，WebFilter。</p><a id="more"></a><p>视频中和大家分享了 Spring Boot 处理跨域的三种方案，其实无论哪种方案，最终目的都是修改响应头，向响应头中添加浏览器所要求的数据，进而实现跨域。既然如此，我们当然可以自定义一个 Web Filter，自己去手动修改响应头。</p><hr><p>今天是 2020 的最后一天，得说点什么。</p><p>之前有小伙伴在群里说松哥最近怎么光发技术文章，不聊点其他的。其实有时候也想和小伙伴们分享下身边的开发之外的好玩的事情，但是老实说，今年疫情影响，每个人可能压力都很大，松哥也是一样，每次想聊点其他的事情，但是打开电脑却码不下去，我不想传播一些负面情绪。。。最终发现还是写技术文章畅快，不带感情，技术点讲清楚就可以了，小伙伴们也能因此有所收获。</p><p>今年整了不少教程，松哥最近会抽空把今年的文章整理成一个索引发出来，估计有 100+ 篇文章/视频。工作之余整了这些教程还是蛮有成就感的，但是相对于浩如烟海的 Java 知识体系来说，这不过是九牛一毛。</p><p>2020 年初的时候，我给自己制定了一个出教程的计划，计划写的教程，有的完工了，还有的没有完工。没有完工主要有两方面的原因：一是 6 月到 10 月底一直处于一个非常忙碌的状态，有很多事情要处理，有点忙不过来，写文章和录视频的步伐都放缓了；二是免费的视频/教程发出来后，总会遇到一些喷子，拖慢了我的更新速度。对于喷子，我几乎没有回复过，但凡动过一点对喷的念头，我觉得我就已经输了。刚开始遇到喷子的时候想不通，以为自己哪里没有做好，后来发现不是的，喷不需要理由，张嘴就来，否则也就不叫喷了。</p><p>明年也还有一些教程计划，小伙伴们如果有哪方面的知识点需求，也可以留言说明，松哥肯定会认真考虑大伙的意见的。不过我毕竟是一个人在慢慢的搞，速度肯定会慢一些。如果小伙伴们对某一个技术点有自己的心得，也欢迎投稿原创未发表过的文章哦。</p><p><img src="http://img.itboyhub.com/2020/20201230210745.png" alt></p><p>今年最后一天，还是想再向小伙伴们推一把松哥的视频教程，<a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">Spring Boot+Vue+微人事+Redis+Spring Cloud</a>。</p><p>我觉得这套视频还是蛮有诚意的。以其中的 Spring Cloud 为例，去年松哥和纯洁的微笑大佬在国内某平台上一起出了一套 Spring Cloud 课程，单套课程在平台上售价 ¥88，现在松哥的视频中也完整的包含了该套课程的内容，而且是基于新的 Spring Cloud H 版录制的视频教程。这只是四套教程中的一部分，另外还有 Spring Boot+Vue+微人事项目+Redis，总共约 70 小时的课程，加在一起只要 ¥199，感觉比网上任何机构课程都要实在。</p><p>这套视频中，最早录制的是 Spring Boot，当时基于 Spring Boot2.1.6 录制，其实也不算老，不过年底松哥稍微空闲一点，还是对 Spring Boot 部分进行了升级，基于目前最新的 2.4.1 版本录制，同时增加了新的内容，之前购买了四套视频的小伙伴，也可以免费学习升级后的 Spring Boot 视频。</p><p>总之，就是很实在。关于视频的更多信息，可以&gt;&gt;&gt;<strong><a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">戳这里</a></strong>。</p><p>感兴趣的小伙伴可以加下面这个微信了解情况：</p><p><img src="http://img.itboyhub.com/2020/20201231102454.png" alt></p><p><strong>最后，提前祝小伙伴们元旦快乐～</strong></p><p><img src="http://img.itboyhub.com/2020/2021-yuandan.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来说一下昨天视频的答案：&lt;/p&gt;
&lt;p&gt;昨天视频中和小伙伴们分享了 Spring Boot 跨域的三种方式，留下一种由小伙伴们自由发挥。留言中有一个小伙伴说出了答案，WebFilter。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>手把手教大家整一个代码自动生成工具（二）</title>
    <link href="http://www.javaboy.org/2020/1224/mybatis-generator.html"/>
    <id>http://www.javaboy.org/2020/1224/mybatis-generator.html</id>
    <published>2020-12-24T14:36:02.000Z</published>
    <updated>2021-03-07T15:09:28.255Z</updated>
    
    <content type="html"><![CDATA[<p>前天发了一篇文章，和大家分享了代码自动生成工具的制作，当时松哥的视频主要讲了数据库连接和读取表信息，今天我们来看下如何自动生成代码。</p><a id="more"></a><p>如果大家还没看前面的介绍，可以先看看这里：</p><ul><li><a href="https://mp.weixin.qq.com/s/2Ovqwn1hd40D7FtKE60HKw" target="_blank" rel="noopener">代码自动生成很难吗？松哥手把手教大家整一个！</a></li></ul><p>如果大家对 Freemarker 的使用尚不熟悉，可以先看看这里：</p><ul><li><a href="https://mp.weixin.qq.com/s/1TZfOBMtrTJ7qKHEduLUEw" target="_blank" rel="noopener">Spring Boot + Freemarker 中的弯弯绕！</a></li></ul><p>如果都已经了解，我们来看看今天的内容，代码到底是怎么样自动生成的：</p><p><a href="https://www.bilibili.com/video/BV1Vo4y1Z7af" target="_blank" rel="noopener">告别 CRUD，手把手教你实现代码自动生成，酷！【视频】</a></p><p>好啦，结合之前的 <a href="https://mp.weixin.qq.com/s/2Ovqwn1hd40D7FtKE60HKw" target="_blank" rel="noopener">代码自动生成很难吗？松哥手把手教大家整一个！</a> 一文，松哥已经带领大家手把手做了代码自动生成工具。小伙伴们照着视频完成后，欢迎给松哥的项目提交 pr，添加更多的模版方法哦～</p><p>项目地址：</p><ul><li>GitHub：<a href="https://github.com/lenve/generate_code" target="_blank" rel="noopener">https://github.com/lenve/generate_code</a></li><li>Gitee：<a href="https://gitee.com/lenve/generate_code" target="_blank" rel="noopener">https://gitee.com/lenve/generate_code</a></li></ul><p>好啦，今天就先和大家分享这么多。如果小伙伴们觉得视频风格还不错，也可以看看松哥的 <a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前天发了一篇文章，和大家分享了代码自动生成工具的制作，当时松哥的视频主要讲了数据库连接和读取表信息，今天我们来看下如何自动生成代码。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
      <category term="逆向工程" scheme="http://www.javaboy.org/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot + Freemarker 中的弯弯绕！</title>
    <link href="http://www.javaboy.org/2020/1223/springboot-freemarker.html"/>
    <id>http://www.javaboy.org/2020/1223/springboot-freemarker.html</id>
    <published>2020-12-23T14:35:31.000Z</published>
    <updated>2021-03-07T15:09:39.867Z</updated>
    
    <content type="html"><![CDATA[<p>昨天说手把手教大家整一个代码自动生成工具，用到了 Freemarker，结果有不少小伙伴表示对 Freemarker 不熟悉，这不，松哥赶紧整一个 Spring Boot+Freemarker 的教程出来，和大家分享下 Freemarker 中的常见操作。</p><a id="more"></a><p>[TOC]</p><p>大家在网上可能都看到过一些代码生成工具，很酷！MyBatis、Service、Controller、Model 全部都可以自动生成。</p><p>这些工具的实现其实非常 Easy，只要熟悉 JDBC API 和任意一种页面模版就可以实现。今天松哥就尝试使用 Freemarker 做一个简单的案例，带大家揭开代码生成工具的神秘面纱。</p><p>我们先来看看 Spring Boot 整合 Freemarker，然后再来看看如何实现自动生成代码。</p><h2 id="1-Freemarker-简介"><a href="#1-Freemarker-简介" class="headerlink" title="1. Freemarker 简介"></a>1. Freemarker 简介</h2><p>这是一个相当老牌的开源的免费的模版引擎，基于Apache许可证2.0版本发布。</p><p>通过 Freemarker 模版，我们可以将数据渲染成 HTML 网页、电子邮件、配置文件以及源代码等。Freemarker 不是面向最终用户的，而是一个 Java 类库，我们可以将之作为一个普通的组件嵌入到我们的产品中。</p><p>来看一张来自 Freemarker 官网的图片：</p><p><img src="http://img.itboyhub.com/2020/10-1.png" alt></p><p>可以看到，Freemarker 可以将模版和数据渲染成 HTML 。</p><p>Freemarker 模版后缀为 <code>.ftlh</code>(FreeMarker Template Language)。FTL 是一种简单的、专用的语言，它不是像 Java 那样成熟的编程语言。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。</p><h2 id="2-整合-Spring-Boot"><a href="#2-整合-Spring-Boot" class="headerlink" title="2. 整合 Spring Boot"></a>2. 整合 Spring Boot</h2><p>在 SSM 中整合 Freemarker ，所有的配置文件加起来，前前后后大约在 50 行左右，Spring Boot 中要几行配置呢？ 0 行！</p><h3 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1 创建工程"></a>2.1 创建工程</h3><p>首先创建一个 Spring Boot 工程，引入 Freemarker 依赖，如下图：</p><p><img src="http://img.itboyhub.com/2020/20201217125112.png" alt></p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>工程创建完成后，在 <code>org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration</code> 类中，可以看到关于 Freemarker 的自动化配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class &#125;)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(FreeMarkerProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class,</span><br><span class="line">FreeMarkerNonWebConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，当 <code>classpath</code> 下存在 <code>freemarker.template.Configuration</code> 以及 <code>FreeMarkerConfigurationFactory</code> 时，配置才会生效，也就是说当我们引入了 <code>Freemarker</code> 之后，配置就会生效。但是这里的自动化配置只做了模板位置检查，其他配置则是在导入的 <code>FreeMarkerServletWebConfiguration</code> 配置中完成的。那么我们再来看看 <code>FreeMarkerServletWebConfiguration</code> 类，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet.class, FreeMarkerConfigurer.class &#125;)</span><br><span class="line"><span class="hljs-meta">@AutoConfigureAfter</span>(WebMvcAutoConfiguration.class)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFreeMarkerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span><span class="hljs-params">(FreeMarkerProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(properties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(FreeMarkerConfig.class)</span><br><span class="line"><span class="hljs-function">FreeMarkerConfigurer <span class="hljs-title">freeMarkerConfigurer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">FreeMarkerConfigurer configurer = <span class="hljs-keyword">new</span> FreeMarkerConfigurer();</span><br><span class="line">applyProperties(configurer);</span><br><span class="line"><span class="hljs-keyword">return</span> configurer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line">freemarker.template.<span class="hljs-function">Configuration <span class="hljs-title">freeMarkerConfiguration</span><span class="hljs-params">(FreeMarkerConfig configurer)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> configurer.getConfiguration();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(name = <span class="hljs-string">"freeMarkerViewResolver"</span>)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(name = <span class="hljs-string">"spring.freemarker.enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-function">FreeMarkerViewResolver <span class="hljs-title">freeMarkerViewResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">FreeMarkerViewResolver resolver = <span class="hljs-keyword">new</span> FreeMarkerViewResolver();</span><br><span class="line">getProperties().applyToMvcViewResolver(resolver);</span><br><span class="line"><span class="hljs-keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnEnabledResourceChain</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingFilterBean</span>(ResourceUrlEncodingFilter.class)</span><br><span class="line"><span class="hljs-function">FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; <span class="hljs-title">resourceUrlEncodingFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">FilterRegistrationBean&lt;ResourceUrlEncodingFilter&gt; registration = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;(</span><br><span class="line"><span class="hljs-keyword">new</span> ResourceUrlEncodingFilter());</span><br><span class="line">registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ERROR);</span><br><span class="line"><span class="hljs-keyword">return</span> registration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来简单看下这段源码：</p><ol><li>@ConditionalOnWebApplication 表示当前配置在 web 环境下才会生效。</li><li>ConditionalOnClass 表示当前配置在存在 Servlet 和 FreeMarkerConfigurer 时才会生效。</li><li>@AutoConfigureAfter 表示当前自动化配置在 WebMvcAutoConfiguration 之后完成。</li><li>代码中，主要提供了 FreeMarkerConfigurer 和 FreeMarkerViewResolver。</li><li>FreeMarkerConfigurer 是 Freemarker 的一些基本配置，例如 templateLoaderPath、defaultEncoding 等</li><li>FreeMarkerViewResolver 则是视图解析器的基本配置，包含了viewClass、suffix、allowRequestOverride、allowSessionOverride 等属性。</li></ol><p>另外还有一点，在这个类的构造方法中，注入了 FreeMarkerProperties：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.freemarker"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">"classpath:/templates/"</span>;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">""</span>;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".ftlh"</span>;</span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * Well-known FreeMarker keys which are passed to FreeMarker's Configuration.</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeMarkerProperties 中则配置了 Freemarker 的基本信息，例如模板位置在 <code>classpath:/templates/</code> ，再例如模板后缀为 <code>.ftlh</code>，那么这些配置我们以后都可以在 application.properties 中进行修改。</p><p>如果我们在 SSM 的 XML 文件中自己配置 Freemarker ，也不过就是配置这些东西。现在，这些配置由  FreeMarkerServletWebConfiguration 帮我们完成了。</p><h3 id="2-2-创建类"><a href="#2-2-创建类" class="headerlink" title="2.2 创建类"></a>2.2 创建类</h3><p>首先我们来创建一个 User 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来创建 <code>UserController</code>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">            user.setId((<span class="hljs-keyword">long</span>) i);</span><br><span class="line">            user.setUsername(<span class="hljs-string">"javaboy&gt;&gt;&gt;&gt;"</span> + i);</span><br><span class="line">            user.setAddress(<span class="hljs-string">"www.javaboy.org&gt;&gt;&gt;&gt;"</span> + i);</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"users"</span>, users);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 freemarker 中渲染数据：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户编号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">users</span> <span class="hljs-attr">as</span> <span class="hljs-attr">user</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="http://img.itboyhub.com/2020/10-3.png" alt></p><h3 id="2-3-其他配置"><a href="#2-3-其他配置" class="headerlink" title="2.3 其他配置"></a>2.3 其他配置</h3><p>如果我们要修改模版文件位置等，可以在 application.properties 中进行配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.freemarker.allow-request-override=false</span><br><span class="line">spring.freemarker.allow-session-override=false</span><br><span class="line">spring.freemarker.cache=false</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line">spring.freemarker.check-template-location=true</span><br><span class="line">spring.freemarker.content-type=text/html</span><br><span class="line">spring.freemarker.expose-request-attributes=false</span><br><span class="line">spring.freemarker.expose-session-attributes=false</span><br><span class="line">spring.freemarker.suffix=.ftl</span><br><span class="line">spring.freemarker.template-loader-path=classpath:/templates/</span><br></pre></td></tr></table></figure><p>配置文件按照顺序依次解释如下：</p><ol><li>HttpServletRequest的属性是否可以覆盖controller中model的同名项</li><li>HttpSession的属性是否可以覆盖controller中model的同名项</li><li>是否开启缓存</li><li>模板文件编码</li><li>是否检查模板位置</li><li>Content-Type的值</li><li>是否将HttpServletRequest中的属性添加到Model中</li><li>是否将HttpSession中的属性添加到Model中</li><li>模板文件后缀</li><li>模板文件位置</li></ol><p>好了，整合完成之后，Freemarker 的更多用法，就和在 SSM 中使用 Freemarker 一样了。</p><h2 id="3-Freemarker-使用细节"><a href="#3-Freemarker-使用细节" class="headerlink" title="3. Freemarker 使用细节"></a>3. Freemarker 使用细节</h2><h3 id="3-1-插值与表达式"><a href="#3-1-插值与表达式" class="headerlink" title="3.1 插值与表达式"></a>3.1 插值与表达式</h3><h4 id="3-1-1-直接输出值"><a href="#3-1-1-直接输出值" class="headerlink" title="3.1.1 直接输出值"></a>3.1.1 直接输出值</h4><p><strong>字符串</strong></p><p>可以直接输出一个字符串：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;"hello，我是直接输出的字符串"&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;"我的文件保存在C:\\盘"&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>\ 需要进行转义。</p><p>如果感觉转义太麻烦，可以在目标字符串的引号前增加 r 标记,在 r 标记后的文本内容将会直接输出，像下面这样：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;r"我的文件保存在C:\盘"&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>数字</strong></p><p>在 FreeMarker 中使用数值需要注意以下几点:</p><ol><li>数值不能省略小数点前面的0，所以”.5”是错误的写法。</li><li>数值 8 , +8 , 8.00 都是相同的。</li></ol><p>数字还有一些其他的玩法：</p><ul><li>将数字以钱的形式展示：</li></ul><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">num</span>=<span class="hljs-string">99</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;num?string.currency&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;#assign num=99&gt;</code> 表示定义了一个变量 num，值为 99。最终的展示形式是在数字前面出现了一个人民币符号：</p><p><img src="http://img.itboyhub.com/2020/20201217155655.png" alt></p><ul><li>将数字以百分数的形式展示：</li></ul><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;num?string.percent&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>展示效果如下：</p><p><img src="http://img.itboyhub.com/2020/20201217160444.png" alt></p><p><strong>布尔</strong></p><p>布尔类型可以直接定义，不需要引号，像下面这样：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">flag</span>=<span class="hljs-string">true</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;flag?string("a","b")&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先使用 <code>&lt;#assign flag=true&gt;</code> 定义了一个 Boolean 类型的变量，然后在 div 中展示，如果 flag 为 true，则输出 a，否则输出 b。</p><p><strong>集合</strong></p><p>集合也可以现场定义现场输出，例如如下方式定义一个 List 集合并显示出来：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> ["星期一", "星期二", "星期三", "星期四", "星期五", "星期六", "星期天"] <span class="hljs-attr">as</span> <span class="hljs-attr">x</span>&gt;</span></span><br><span class="line">    $&#123;x&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>x 代表集合中的每一个元素，最终显示效果如下：</p><p><img src="http://img.itboyhub.com/2020/20201217161426.png" alt></p><p>集合中的元素也可以是一个表达式：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> [<span class="hljs-attr">2</span>+<span class="hljs-attr">2</span>,"<span class="hljs-attr">javaboy</span>"] <span class="hljs-attr">as</span> <span class="hljs-attr">x</span>&gt;</span></span><br><span class="line">    $&#123;x&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>集合中的第一个元素就是 2+2 的结果，即 4。</p><p>也可以用 <code>1..5</code> 表示 1 到 5，<code>5..1</code> 表示 5 到 1，例如：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">5..1</span> <span class="hljs-attr">as</span> <span class="hljs-attr">x</span>&gt;</span></span><br><span class="line">    $&#123;x&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">1..5</span> <span class="hljs-attr">as</span> <span class="hljs-attr">x</span>&gt;</span></span><br><span class="line">    $&#123;x&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以定义 Map 集合，Map 集合用一个 <code>{}</code> 来描述：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> &#123;"<span class="hljs-attr">name</span>"<span class="hljs-attr">:</span>"<span class="hljs-attr">javaboy</span>","<span class="hljs-attr">address</span>"<span class="hljs-attr">:</span>"<span class="hljs-attr">www.javaboy.org</span>"&#125;?<span class="hljs-attr">keys</span> <span class="hljs-attr">as</span> <span class="hljs-attr">x</span>&gt;</span></span><br><span class="line">$&#123;x&#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#list</span> &#123;"<span class="hljs-attr">name</span>"<span class="hljs-attr">:</span>"<span class="hljs-attr">javaboy</span>","<span class="hljs-attr">address</span>"<span class="hljs-attr">:</span>"<span class="hljs-attr">www.javaboy.org</span>"&#125;?<span class="hljs-attr">values</span> <span class="hljs-attr">as</span> <span class="hljs-attr">x</span>&gt;</span></span><br><span class="line">$&#123;x&#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面两个循环分别表示遍历 Map 中的 key 和 values。</p><h4 id="3-1-2-输出变量"><a href="#3-1-2-输出变量" class="headerlink" title="3.1.2 输出变量"></a>3.1.2 输出变量</h4><p>创建一个 HelloController，然后添加如下方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            User u = <span class="hljs-keyword">new</span> User();</span><br><span class="line">            u.setUsername(<span class="hljs-string">"javaboy:"</span> + i);</span><br><span class="line">            u.setAddress(<span class="hljs-string">"www.javaboy.org:"</span> + i);</span><br><span class="line">            users.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Object&gt; info = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        info.put(<span class="hljs-string">"site"</span>, <span class="hljs-string">"http://www.itboyhub.com"</span>);</span><br><span class="line">        info.put(<span class="hljs-string">"wechat"</span>, <span class="hljs-string">"a_java_boy"</span>);</span><br><span class="line">        info.put(<span class="hljs-string">"github"</span>, <span class="hljs-string">"https://github.com/lenve"</span>);</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"users"</span>, users);</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"info"</span>, info);</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们在模版文件中对这里的普通变量、List 集合以及 Map 分别进行展示。</p><p><strong>普通变量</strong></p><p>普通变量的展示很容易，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>集合</strong></p><p>集合的展示就有很多不同的玩法了。</p><p>直接遍历：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">users</span> <span class="hljs-attr">as</span> <span class="hljs-attr">u</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出集合中第三个元素：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    $&#123;users[3].username&#125;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出集合中第 4-6 个元素，即子集合：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">users</span>[<span class="hljs-attr">3..5</span>] <span class="hljs-attr">as</span> <span class="hljs-attr">u</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>遍历时，可以通过 <code>变量_index</code> 获取遍历的下标：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">users</span>[<span class="hljs-attr">3..5</span>] <span class="hljs-attr">as</span> <span class="hljs-attr">u</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;u_index&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Map</strong></p><p>直接获取 Map 中的值有不同的写法，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;info.wechat&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;info['site']&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>获取 Map 中的所有 key，并根据 key 获取 value：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">info</span>?<span class="hljs-attr">keys</span> <span class="hljs-attr">as</span> <span class="hljs-attr">key</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;key&#125;--$&#123;info[key]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>获取 Map 中的所有 value：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">info</span>?<span class="hljs-attr">values</span> <span class="hljs-attr">as</span> <span class="hljs-attr">value</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;value&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-字符串操作"><a href="#3-1-3-字符串操作" class="headerlink" title="3.1.3 字符串操作"></a>3.1.3 字符串操作</h4><p>字符串的拼接有两种方式：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;"hello $&#123;name&#125;"&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;"hello "+ name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以从字符串中截取子串：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;name[0]&#125;$&#123;name[1]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;name[0..2]&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终显示效果如下：</p><p><img src="http://img.itboyhub.com/2020/20201217200637.png" alt></p><h4 id="3-1-4-集合操作"><a href="#3-1-4-集合操作" class="headerlink" title="3.1.4 集合操作"></a>3.1.4 集合操作</h4><p>集合或者 Map 都可以相加。</p><p>集合相加：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> ["星期一","星期二","星期三"] + ["星期四","星期五","星期六","星期天"] <span class="hljs-attr">as</span> <span class="hljs-attr">x</span>&gt;</span></span><br><span class="line">        $&#123;x&#125;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Map 相加：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> (<span class="hljs-attr">info</span>+&#123;"<span class="hljs-attr">gitee</span>"<span class="hljs-attr">:</span>"<span class="hljs-attr">https:</span>//<span class="hljs-attr">gitee.com</span>/<span class="hljs-attr">lenve</span>"&#125;)?<span class="hljs-attr">keys</span> <span class="hljs-attr">as</span> <span class="hljs-attr">key</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;key&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-5-算术运算符"><a href="#3-1-5-算术运算符" class="headerlink" title="3.1.5 算术运算符"></a>3.1.5 算术运算符</h4><p><code>+</code>、<code>—</code>、<code>*</code>、<code>/</code>、<code>%</code> 运算都是支持的。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">age</span>=<span class="hljs-string">99</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;age*99/99+99-1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-6-比较运算"><a href="#3-1-6-比较运算" class="headerlink" title="3.1.6 比较运算"></a>3.1.6 比较运算</h4><p>比较运算和 Thymeleaf 比较类似:</p><ol><li>= 或者 == 判断两个值是否相等。</li><li>!= 判断两个值是否不等。</li><li><code>&gt;</code> 或者 gt 判断左边值是否大于右边值。</li><li><code>&gt;=</code> 或者 gte 判断左边值是否大于等于右边值。</li><li><code>&lt;</code> 或者 lt 判断左边值是否小于右边值。</li><li><code>&lt;=</code> 或者 lte 判断左边值是否小于等于右边值。</li></ol><p>可以看到，带 <code>&lt;</code> 或者 <code>&gt;</code> 的符号，也都有别名，建议使用别名。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">age</span>=<span class="hljs-string">99</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">age</span>=<span class="hljs-string">99</span>&gt;</span>age=99<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">age</span> <span class="hljs-attr">gt</span> <span class="hljs-attr">99</span>&gt;</span>age gt 99<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">age</span> <span class="hljs-attr">gte</span> <span class="hljs-attr">99</span>&gt;</span>age gte 99<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">age</span> <span class="hljs-attr">lt</span> <span class="hljs-attr">99</span>&gt;</span>age lt 99<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">age</span> <span class="hljs-attr">lte</span> <span class="hljs-attr">99</span>&gt;</span>age lte 99<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">age</span>!=<span class="hljs-string">99</span>&gt;</span>age!=99<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">age</span>==<span class="hljs-string">99</span>&gt;</span>age==99<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-7-逻辑运算"><a href="#3-1-7-逻辑运算" class="headerlink" title="3.1.7 逻辑运算"></a>3.1.7 逻辑运算</h4><p>逻辑运算符有三个:</p><ul><li>逻辑与 <code>&amp;&amp;</code></li><li>逻辑或 <code>||</code></li><li>逻辑非 <code>!</code></li></ul><p>逻辑运算符只能作用于布尔值,否则将产生错误。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">age</span>=<span class="hljs-string">99</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">age</span>=<span class="hljs-string">99</span> &amp;&amp; <span class="hljs-attr">1</span>==<span class="hljs-string">1</span>&gt;</span>age=99 &amp;&amp; 1==1<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">age</span>=<span class="hljs-string">99</span> || <span class="hljs-attr">1</span>==<span class="hljs-string">0</span>&gt;</span>age=99 || 1==0<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> !(<span class="hljs-attr">age</span> <span class="hljs-attr">gt</span> <span class="hljs-attr">99</span>)&gt;</span>!(age gt 99)<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-8-空值处理"><a href="#3-1-8-空值处理" class="headerlink" title="3.1.8 空值处理"></a>3.1.8 空值处理</h4><p>为了处理缺失变量,Freemarker 提供了两个运算符:</p><ol><li><code>!</code>：指定缺失变量的默认值</li><li><code>??</code>：判断某个变量是否存在</li></ol><p>如果某个变量不存在，则设置其为 javaboy，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!"javaboy"&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果某个变量不存在，则设置其为空字符串，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即，<code>!</code> 后面的东西如果省略了，默认就是空字符串。</p><p>判断某个变量是否存在：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!"javaboy"&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;aaa!&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">#if</span> <span class="hljs-attr">aaa</span>??&gt;</span>aaa<span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-内建函数"><a href="#3-2-内建函数" class="headerlink" title="3.2 内建函数"></a>3.2 内建函数</h3><p>内建函数涉及到的东西比较多，可以参考官方文档:<a href="http://freemarker.foofun.cn/ref_builtins.html" target="_blank" rel="noopener">http://freemarker.foofun.cn/ref_builtins.html</a>。</p><p>这里仅说一些比较常用的内建函数。</p><p><strong>cap_first</strong></p><p>使字符串第一个字母大写：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;"hello"?cap_first&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>lower_case</strong></p><p>将字符串转换成小写：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;"HELLO"?lower_case&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>upper_case</strong></p><p>将字符串转换成大写：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;"hello"?upper_case&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>trim</strong></p><p>去掉字符串前后的空白字符：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;" hello"?trim&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>size</strong></p><p>获取序列中元素的个数：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;users?size&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>int</strong></p><p>取得数字的整数部分,结果带符号：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;3.14?int&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>日期格式化</strong></p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>$&#123;birthday?string("yyyy-MM-dd")&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-常用指令"><a href="#3-2-常用指令" class="headerlink" title="3.2 常用指令"></a>3.2 常用指令</h3><h4 id="3-2-1-if-else"><a href="#3-2-1-if-else" class="headerlink" title="3.2.1 if/else"></a>3.2.1 if/else</h4><p>分支控制指令，作用类似于 Java 语言中的 if：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">age</span>=<span class="hljs-string">23</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#if</span> (<span class="hljs-attr">age</span>&gt;</span>60)&gt;老年人</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> (<span class="hljs-attr">age</span>&gt;</span>40)&gt;中年人</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#elseif</span> (<span class="hljs-attr">age</span>&gt;</span>20)&gt;青年人</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#else</span>&gt;</span> 少年人</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">#if</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比较符号中用了 <code>()</code>，因此不用转义。</p><h4 id="3-2-2-switch"><a href="#3-2-2-switch" class="headerlink" title="3.2.2 switch"></a>3.2.2 switch</h4><p>分支指令，类似于 Java 中的 switch：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">age</span>=<span class="hljs-string">99</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#switch</span> <span class="hljs-attr">age</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">#case</span> <span class="hljs-attr">23</span>&gt;</span>23<span class="hljs-tag">&lt;<span class="hljs-name">#break</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">#case</span> <span class="hljs-attr">24</span>&gt;</span>24<span class="hljs-tag">&lt;<span class="hljs-name">#break</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">#default</span>&gt;</span>9999</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">#switch</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;#break&gt;</code> 是提前退出，也可以用在 <code>&lt;#list&gt;</code> 中。</p><h4 id="3-2-3-include"><a href="#3-2-3-include" class="headerlink" title="3.2.3 include"></a>3.2.3 include</h4><p>include 可以包含一个外部页面进来。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#include</span> "<span class="hljs-attr">.</span>/<span class="hljs-attr">javaboy.ftlh</span>"&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-4-macro"><a href="#3-2-4-macro" class="headerlink" title="3.2.4 macro"></a>3.2.4 macro</h4><p>macro 用来定义一个宏。</p><p>我们可以自定义一个名为 book 的宏，并引用它：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#macro</span> <span class="hljs-attr">book</span>&gt;</span></span><br><span class="line">    三国演义</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#macro</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">@book</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>最终页面中会输出宏中所定义的内容。</p><p>在定义宏的时候，也可以传入参数，那么引用时，也需要传入参数：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#macro</span> <span class="hljs-attr">book</span> <span class="hljs-attr">bs</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">bs</span> <span class="hljs-attr">as</span> <span class="hljs-attr">b</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;b&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#macro</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">@book</span> ["三国演义","水浒传"]/&gt;</span></span><br></pre></td></tr></table></figure><p>bs 就是需要传入的参数。可以通过传入多个参数，多个参数跟在 bs 后面即可，中间用空格隔开。</p><p>还可以使用 <code>&lt;#nested&gt;</code> 引入用户自定义指令的标签体，像下面这样：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#macro</span> <span class="hljs-attr">book</span> <span class="hljs-attr">bs</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">bs</span> <span class="hljs-attr">as</span> <span class="hljs-attr">b</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;b&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#nested</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#macro</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">@book</span> ["三国演义","水浒传"]&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello javaboy!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">@book</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在宏定义的时候，<code>&lt;#nested&gt;</code> 相当于是一个占位符，在调用的时候，<code>&lt;@book&gt;</code> 标签中的内容会出现在 <code>&lt;#nested&gt;</code> 位置。</p><p>前面的案例中，宏都是定义在当前页面中，宏也可以定义在一个专门的页面中。新建 myjavaboy.ftlh 页面，内容如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#macro</span> <span class="hljs-attr">book</span> <span class="hljs-attr">bs</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">bs</span> <span class="hljs-attr">as</span> <span class="hljs-attr">b</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;b&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#nested</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#macro</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，需要先通过 <code>&lt;#import&gt;</code> 标签导入宏，然后才能调用，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#import</span> "<span class="hljs-attr">.</span>/<span class="hljs-attr">myjavaboy.ftlh</span>" <span class="hljs-attr">as</span> <span class="hljs-attr">com</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">@com.book</span> <span class="hljs-attr">bs</span>=<span class="hljs-string">[</span>"三国演义","水浒传"]&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello javaboy!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">@com.book</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-5-noparse"><a href="#3-2-5-noparse" class="headerlink" title="3.2.5 noparse"></a>3.2.5 noparse</h4><p>如果想在页面展示一些 Freemarker 语法而不被渲染，则可以使用 noparse 标签，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#noparse</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">#import</span> "<span class="hljs-attr">.</span>/<span class="hljs-attr">myjavaboy.ftlh</span>" <span class="hljs-attr">as</span> <span class="hljs-attr">com</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">@com.book</span> <span class="hljs-attr">bs</span>=<span class="hljs-string">[</span>"三国演义","水浒传"]&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello javaboy!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">@com.book</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">#noparse</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果如下：</p><p><img src="http://img.itboyhub.com/2020/20201217214402.png" alt></p><h2 id="4-自动生成代码实践"><a href="#4-自动生成代码实践" class="headerlink" title="4. 自动生成代码实践"></a>4. 自动生成代码实践</h2><p>松哥录制了一个利用 Freemarker 自动生成代码的视频，感兴趣的小伙伴可以参考：</p><p><a href="https://mp.weixin.qq.com/s/2Ovqwn1hd40D7FtKE60HKw" target="_blank" rel="noopener">代码自动生成很难吗？松哥手把手教大家整一个！</a></p><h2 id="5-项目实践"><a href="#5-项目实践" class="headerlink" title="5. 项目实践"></a>5. 项目实践</h2><p>今年 6 月份我还录制了一个 SSM+Freemarker 的项目，感兴趣的小伙伴可以参考：</p><p><a href="https://mp.weixin.qq.com/s/8N4ZGUwQYo51i1zEQZ6f9Q" target="_blank" rel="noopener">松哥憋了个大招！一套免费的视频教程又出炉啦！</a></p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>本文和大家简单聊一聊 Spring Boot 整合 Freemarker，算是对 Spring Boot2 教程的一个补充（后面还会有一些补充），有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天说手把手教大家整一个代码自动生成工具，用到了 Freemarker，结果有不少小伙伴表示对 Freemarker 不熟悉，这不，松哥赶紧整一个 Spring Boot+Freemarker 的教程出来，和大家分享下 Freemarker 中的常见操作。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Freemarker" scheme="http://www.javaboy.org/tags/Freemarker/"/>
    
  </entry>
  
</feed>
