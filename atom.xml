<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-07-02T01:35:43.124Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GET 新技能！自己的网站突然就不香了</title>
    <link href="http://www.javaboy.org/2020/0702/vuepress-blog.html"/>
    <id>http://www.javaboy.org/2020/0702/vuepress-blog.html</id>
    <published>2020-07-02T01:06:53.000Z</published>
    <updated>2020-07-02T01:35:43.124Z</updated>
    
    <content type="html"><![CDATA[<p>松哥自己的网站有两大类：</p><p>一个就是大家看到的 <a href="http://www.javaboy.org，这个网站是基于" target="_blank" rel="noopener">www.javaboy.org，这个网站是基于</a> GitHub Pages 做的，使用的技术栈是 hexo+icarus，公众号上的所有文章我都会同步到这个网站上去。</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/20200701105938.png" alt></p><p>还有一类就是电子书网站，这个就比较多了：</p><ul><li><a href="http://maven.javaboy.org" target="_blank" rel="noopener">http://maven.javaboy.org</a></li><li><a href="http://spring.javaboy.org" target="_blank" rel="noopener">http://spring.javaboy.org</a></li><li><a href="http://springmvc.javaboy.org" target="_blank" rel="noopener">http://springmvc.javaboy.org</a></li><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li><li><a href="http://vhr.javaboy.org" target="_blank" rel="noopener">http://vhr.javaboy.org</a></li></ul><p>这一类电子书网站技术栈是 <code>Jekyll</code> + <code>jekyll-TeXt-theme</code>，这个松哥在之前的文章中已经介绍过了，具体小伙伴们可以参考：<a href="https://mp.weixin.qq.com/s/_W1Ism-pyarB1u2wX-gCFw" target="_blank" rel="noopener">不花一分钱，把自己零散的知识整理成体系，制作成在线电子书</a>。</p><p>最近看别人用 vuepress 搭建博客网站，突然感觉自己的网站就不香了。。。</p><p>那就再撸一个吧！</p><h2 id="1-vuepress-介绍"><a href="#1-vuepress-介绍" class="headerlink" title="1.vuepress 介绍"></a>1.vuepress 介绍</h2><p>类似于大家所熟知的 hexo，vuepress 也可以用来生成静态网页。如果大家做过 vue 开发，或者了解过松哥的微人事（<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>），你会发现 vuepress 非常亲切，想要做定制也非常容易，不像 hexo 定制那样陌生。</p><p>根据 vuepress 官网的介绍，VuePress 由两部分组成：第一部分是一个极简静态网站生成器，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。</p><p>每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue 将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。所以大家不用担心自己网站无法被搜索引擎爬虫。</p><p>无论是 hexo 还是 vuepress，一个核心目的就是让我们专注于内容而不是网站建设，从这个角度来说，其实两个都不错，只不过对于有 vue 开发经验的小伙伴，vuepress 更加容易上手和定制。</p><p>相比于其他的电子书网站，vue 显然更具备优势，例如：</p><h3 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h3><p>VuePress 能做的事情，Nuxt 理论上确实能够胜任，但 Nuxt 是为构建应用程序而生的，而 VuePress 则专注在以内容为中心的静态网站上，同时提供了一些为技术文档定制的开箱即用的特性。</p><h3 id="Docsify-Docute"><a href="#Docsify-Docute" class="headerlink" title="Docsify / Docute"></a>Docsify / Docute</h3><p>这两个项目同样都是基于 Vue，然而它们都是完全的运行时驱动，因此对 SEO 不够友好。如果你并不关注 SEO，同时也不想安装大量依赖，它们仍然是非常好的选择！</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>Hexo 一直驱动着 Vue 的文档 —— 事实上，在把我们的主站从 Hexo 迁移到 VuePress 之前，我们可能还有很长的路要走。Hexo 最大的问题在于他的主题系统太过于静态以及过度地依赖纯字符串，而我们十分希望能够好好地利用 Vue 来处理我们的布局和交互，同时，Hexo 的 Markdown 渲染的配置也不是最灵活的。</p><h3 id="GitBook"><a href="#GitBook" class="headerlink" title="GitBook"></a>GitBook</h3><p>我们的子项目文档一直都在使用 GitBook。GitBook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 Vue 驱动的。GitBook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。</p><h2 id="2-搭建"><a href="#2-搭建" class="headerlink" title="2.搭建"></a>2.搭建</h2><h3 id="2-1-项目创建"><a href="#2-1-项目创建" class="headerlink" title="2.1 项目创建"></a>2.1 项目创建</h3><p>具体的搭建其实很容易。</p><p>首先确保电脑本地安装了 nodejs（如果本地的 vue 开发环境齐全的话，就不用额外准备了，如果对 vue 不熟悉，不妨看看松哥的<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">微人事视频教程</a>）。</p><p>环境准备好之后，接下来开始创建项目。</p><p>首先准备一个新的目录：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir java-guide</span><br><span class="line">cd java-guide</span><br></pre></td></tr></table></figure><p>接下来对目录进行初始化：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>初始化的过程中会有一些询问，需要配置就配置一下，不需要配置就直接回车，最终选择 yes 即可。</p><p><img src="http://img.itboyhub.com/2020/20200701114339.png" alt></p><p>接下来安装 vuepress 依赖：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D vuepress</span><br></pre></td></tr></table></figure><p>准备好之后，接下来我们就可以创建第一篇文章了。</p><p>在一开始创建的 java-guide 目录下创建 docs 目录（目录名随意），然后在目录中创建一个 README.md 文件，这个将是我们网站的首页，README.md 中随便写一行作为测试内容。</p><p><img src="http://img.itboyhub.com/2020/20200701114801.png" alt></p><p>接下来修改 package.json，添加两行脚本：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",</span><br><span class="line">  "docs:dev": "vuepress dev docs",</span><br><span class="line">  "docs:build": "vuepress build docs"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>docs:dev 是开发环境下运行，docs:build 则是项目编译。</p><p>所有工作都准备好之后，接下来就可以启动项目了，启动命令如下：</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run docs:dev</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/20200701151652.png" alt></p><p>项目启动成功后，浏览器地址栏输入 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 就可以看到启动效果。当然现在的效果比较简单，就一个 hello javaboy！</p><p><img src="http://img.itboyhub.com/2020/20200701151921.png" alt></p><h3 id="2-2-首页配置"><a href="#2-2-首页配置" class="headerlink" title="2.2 首页配置"></a>2.2 首页配置</h3><p>现在的页面太简单了，我们可以对项目首页进行配置，打开 docs/README.md 文件，添加如下内容：</p><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">home: true</span><br><span class="line">heroImage: https://open.weixin.qq.com/qr/code?username=a_javaboy</span><br><span class="line">heroText: 江南一点雨</span><br><span class="line">tagline: Java 修炼手册</span><br><span class="line">actionText: 开始学习 →</span><br><span class="line">actionLink: /springboot/</span><br><span class="line">features:</span><br><span class="line"><span class="hljs-bullet">- </span>title: 纯原创</span><br><span class="line">  details: 不做互联网的搬运工，松哥纯手敲，纯原创教程。</span><br><span class="line"><span class="hljs-bullet">- </span>title: 成系列</span><br><span class="line">  details: 成系列的教程合集，告别碎片化学习，Java 学习一步到位！</span><br><span class="line"><span class="hljs-bullet">- </span>title: 有案例</span><br><span class="line">  details: 文章都有配套案例，部分系列有配套视频，扫码关注微信公众号【江南一点雨】，及时获取文档更新通知！</span><br><span class="line">footer: 关注微信公众号【江南一点雨】，回复 888 ，领取 Spring Boot+Vue 项目实战资料！</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>修改完成后，项目不用重启，和 vue 一样，会自动热更新，浏览器会自动刷新，此时的首页展示效果如下：</p><p><img src="http://img.itboyhub.com/2020/20200701152439.png" alt></p><h3 id="2-3-导航页配置"><a href="#2-3-导航页配置" class="headerlink" title="2.3 导航页配置"></a>2.3 导航页配置</h3><p>导航页的配置需要新建 docs/.vuepress/config.js 配置文件，文件内容如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    title: <span class="hljs-string">'江南一点雨'</span>,</span><br><span class="line">    head: [</span><br><span class="line">        [<span class="hljs-string">'link'</span>, &#123;<span class="hljs-attr">rel</span>: <span class="hljs-string">'icon'</span>, <span class="hljs-attr">href</span>: <span class="hljs-string">'https://open.weixin.qq.com/qr/code?username=a_javaboy'</span>&#125;]</span><br><span class="line">    ],</span><br><span class="line">    themeConfig: &#123;</span><br><span class="line">        logo: <span class="hljs-string">'https://open.weixin.qq.com/qr/code?username=a_javaboy'</span>,</span><br><span class="line">        nav: [ </span><br><span class="line">            &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'首页'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'/'</span>&#125;,</span><br><span class="line">            &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'国际站'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'http://www.javaboy.org'</span>&#125;,</span><br><span class="line">            &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'国内站'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'http://www.itboyhub.com'</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        sidebar: <span class="hljs-string">'auto'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>head 中配置的是浏览器的角标，logo 则是浏览器导航栏的 logo。</p><p>配置完成后，显示效果如下：</p><p><img src="http://img.itboyhub.com/2020/20200701153624.png" alt></p><p>大家看到，上面多了导航栏。</p><p>在 themeConfig.nav 中配置导航栏，link 是导航栏链接的地址，可以将 link 替换成一个 items ，items 是一个数组，items 会通过下拉框的形式展示出来，例如：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nav: [</span><br><span class="line">    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'首页'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'/'</span>&#125;,</span><br><span class="line">    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'国际站'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'http://www.javaboy.org'</span>&#125;,</span><br><span class="line">    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'国内站'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'http://www.itboyhub.com'</span>&#125;,</span><br><span class="line">    &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'其他'</span>, <span class="hljs-attr">items</span>: [</span><br><span class="line">        &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'国际站'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'http://www.javaboy.org'</span>&#125;,</span><br><span class="line">        &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'国内站'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'http://www.itboyhub.com'</span>&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/20200701154432.png" alt></p><h3 id="2-4-侧边栏配置"><a href="#2-4-侧边栏配置" class="headerlink" title="2.4 侧边栏配置"></a>2.4 侧边栏配置</h3><p>侧边栏的配置其实就是左边菜单的配置。</p><p>使用 vuepress ，我们写文章可能会对文件进行分类，例如像下面这样：</p><p><img src="http://img.itboyhub.com/2020/20200701155341.png" alt></p><p>java 目录放 Java 文章，python 目录放 python 文章。我们随便向目录放几篇文章进来。</p><p>目录结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java-guide</span><br><span class="line">├─package-lock.json</span><br><span class="line">├─package.json</span><br><span class="line">├─docs</span><br><span class="line">|  ├─README.md</span><br><span class="line">|  ├─python</span><br><span class="line">|  |   ├─README.md</span><br><span class="line">|  |   ├─python-1.md</span><br><span class="line">|  |   └python-2.md</span><br><span class="line">|  ├─java</span><br><span class="line">|  |  ├─README.md</span><br><span class="line">|  |  ├─java-1.md</span><br><span class="line">|  |  └java-2.md</span><br><span class="line">|  ├─.vuepress</span><br><span class="line">|  |     └config.js</span><br></pre></td></tr></table></figure><p>python 和 java 目录下，对应文章的访问路径分别是：</p><ul><li><a href="http://localhost:8080/java/java-1" target="_blank" rel="noopener">http://localhost:8080/java/java-1</a></li><li><a href="http://localhost:8080/java/java-2" target="_blank" rel="noopener">http://localhost:8080/java/java-2</a></li><li><a href="http://localhost:8080/python/python-1" target="_blank" rel="noopener">http://localhost:8080/python/python-1</a></li><li><a href="http://localhost:8080/python/python-2" target="_blank" rel="noopener">http://localhost:8080/python/python-2</a></li></ul><p>注意，每篇文章顶部需要标明文章的标题（当然也有其他方式配置文章标题，松哥推荐这种方式），以 java-1.md 为例，文章顶部内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Java01</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>同时，java 和 python 目录下都还有一个 README.md 文件，这个文件的访问路径是 </p><ul><li><a href="http://localhost:8080/java/" target="_blank" rel="noopener">http://localhost:8080/java/</a></li></ul><p>或者：</p><ul><li><a href="http://localhost:8080/python/" target="_blank" rel="noopener">http://localhost:8080/python/</a></li></ul><p>这样大家先把文件目录的访问路径搞清楚。</p><p>接下来，我们在 docs/.vuepress/config.js 中配置侧边栏导航，如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sidebar: [</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="hljs-string">'Java'</span>,</span><br><span class="line">        path: <span class="hljs-string">'/java/'</span>,</span><br><span class="line">        collapsable: <span class="hljs-literal">false</span>,</span><br><span class="line">        sidebarDepth: <span class="hljs-number">2</span>,</span><br><span class="line">        children: [</span><br><span class="line">            <span class="hljs-string">'/java/java-1'</span>,</span><br><span class="line">            <span class="hljs-string">'/java/java-2'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="hljs-string">'Python'</span>,</span><br><span class="line">        path: <span class="hljs-string">'/python/'</span>,</span><br><span class="line">        collapsable: <span class="hljs-literal">false</span>,</span><br><span class="line">        sidebarDepth: <span class="hljs-number">2</span>,</span><br><span class="line">        children: [</span><br><span class="line">            <span class="hljs-string">'/python/python-1'</span>,</span><br><span class="line">            <span class="hljs-string">'/python/python-2'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>配置完成后，效果如下：</p><p><img src="http://img.itboyhub.com/2020/20200701161959.png" alt></p><p>当然，具体配置方式有很多种，松哥这里结合自己的使用方式先介绍一种，其他的配置方式小伙伴们可以参考官网。</p><h2 id="3-部署"><a href="#3-部署" class="headerlink" title="3.部署"></a>3.部署</h2><h3 id="3-1-通用型"><a href="#3-1-通用型" class="headerlink" title="3.1 通用型"></a>3.1 通用型</h3><p>和 hexo 一样，vuepress 最终也是编译成静态文件扔到服务器，所以如果你是自己的服务器，那么很简单，首先执行如下命令进行编译：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run docs:build</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/20200701163503.png" alt></p><p>编译成功后会生成如下目录结构：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">java-guide</span><br><span class="line">├─docs</span><br><span class="line">|  ├─.vuepress</span><br><span class="line">|  |     ├─dist</span><br><span class="line">|  |     |  ├─404.html</span><br><span class="line">|  |     |  ├─index.html</span><br><span class="line">|  |     |  ├─python</span><br><span class="line">|  |     |  |   ├─index.html</span><br><span class="line">|  |     |  |   ├─python-1.html</span><br><span class="line">|  |     |  |   └python-2.html</span><br><span class="line">|  |     |  ├─java</span><br><span class="line">|  |     |  |  ├─index.html</span><br><span class="line">|  |     |  |  ├─java-1.html</span><br><span class="line">|  |     |  |  └java-2.html</span><br><span class="line">|  |     |  ├─assets</span><br><span class="line">|  |     |  |   ├─js</span><br><span class="line">|  |     |  |   | ├─10.fd63f6ac.js</span><br><span class="line">|  |     |  |   | ├─11.919333a2.js</span><br><span class="line">|  |     |  |   | ├─2.5618c3b9.js</span><br><span class="line">|  |     |  |   | ├─3.01385c65.js</span><br><span class="line">|  |     |  |   | ├─4.7d5f245c.js</span><br><span class="line">|  |     |  |   | ├─5.5e19538d.js</span><br><span class="line">|  |     |  |   | ├─6.6523d9fe.js</span><br><span class="line">|  |     |  |   | ├─7.6182cc1a.js</span><br><span class="line">|  |     |  |   | ├─8.5aa56f7e.js</span><br><span class="line">|  |     |  |   | ├─9.c492a2c2.js</span><br><span class="line">|  |     |  |   | └app.803870cb.js</span><br><span class="line">|  |     |  |   ├─img</span><br><span class="line">|  |     |  |   |  └search.83621669.svg</span><br><span class="line">|  |     |  |   ├─css</span><br><span class="line">|  |     |  |   |  └0.styles.3f949b7f.css</span><br></pre></td></tr></table></figure><p>dist 目录下的文件就是我们要扔到服务器上的静态文件，直接扔到 nginx 对应的目录下即可。</p><h3 id="3-2-GitHub-Pages"><a href="#3-2-GitHub-Pages" class="headerlink" title="3.2 GitHub Pages"></a>3.2 GitHub Pages</h3><p>当然，也可以利用 GitHub Pages 部署，省事！</p><p>GitHub Pages 我就不做过多介绍了，不了解的小伙伴可以参考这两篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a></li><li><a href="https://mp.weixin.qq.com/s/_W1Ism-pyarB1u2wX-gCFw" target="_blank" rel="noopener">不花一分钱，把自己零散的知识整理成体系，制作成在线电子书</a></li></ul><p>准备好 GitHub 仓库之后，在项目根目录下创建一个脚本文件 deploy.sh ，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env sh</span><br><span class="line"></span><br><span class="line"># 确保脚本抛出遇到的错误</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line"># 生成静态文件</span><br><span class="line">npm run docs:build</span><br><span class="line"></span><br><span class="line"># 进入生成的文件夹</span><br><span class="line">cd docs/.vuepress/dist</span><br><span class="line"></span><br><span class="line"># 如果是发布到自定义域名</span><br><span class="line">echo &apos;docs.javaboy.org&apos; &gt; CNAME</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add -A</span><br><span class="line">git commit -m &apos;deploy&apos;</span><br><span class="line"></span><br><span class="line"># 如果发布到 https://&lt;USERNAME&gt;.github.io</span><br><span class="line">git push -f git@github.com:onedocs/onedocs.github.io.git master</span><br><span class="line"></span><br><span class="line">cd -</span><br></pre></td></tr></table></figure><p>这个有两个地方需要根据自己的实际情况修改，一个是如果需要自定义域名，改成自己的域名；另一个是 GitHub 账户，改成自己的。</p><p>最后，执行该脚本即可。执行完成后，项目就上线了。</p><p>如果是 Windows 系统，按照这个脚本中的命令自行执行即可，都是比较简单的命令，我就不再赘述。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天主要向小伙伴们介绍了 vuepress，前前后后大家个人博客已经向大家安利了三种技术栈了：</p><ul><li>hexo+icarus</li><li><code>Jekyll</code> + <code>jekyll-TeXt-theme</code></li><li>vuepress</li></ul><p>感兴趣的小伙伴不妨试试哦～</p><p>如果觉得有收获，记得点个在看鼓励下松哥～</p><p>参考：</p><ol><li><a href="https://vuepress.vuejs.org/zh/guide" target="_blank" rel="noopener">https://vuepress.vuejs.org/zh/guide</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥自己的网站有两大类：&lt;/p&gt;
&lt;p&gt;一个就是大家看到的 &lt;a href=&quot;http://www.javaboy.org，这个网站是基于&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.javaboy.org，这个网站是基于&lt;/a&gt; GitHub Pages 做的，使用的技术栈是 hexo+icarus，公众号上的所有文章我都会同步到这个网站上去。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://www.javaboy.org/categories/blog/"/>
    
    
      <category term="blog" scheme="http://www.javaboy.org/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>一文搞定 Spring Security 异常处理机制！</title>
    <link href="http://www.javaboy.org/2020/0630/springsecurity-exception.html"/>
    <id>http://www.javaboy.org/2020/0630/springsecurity-exception.html</id>
    <published>2020-06-30T01:28:36.000Z</published>
    <updated>2020-06-30T01:46:17.514Z</updated>
    
    <content type="html"><![CDATA[<p>今天来和小伙伴们聊一聊 Spring Security 中的异常处理机制。</p><a id="more"></a><p>在 Spring Security 的过滤器链中，ExceptionTranslationFilter 过滤器专门用来处理异常，在 ExceptionTranslationFilter 中，我们可以看到，异常被分为了两大类：认证异常和授权异常，两种异常分别由不同的回调函数来处理，今天松哥就来和大家分享一下这里的条条框框。</p><h2 id="1-异常分类"><a href="#1-异常分类" class="headerlink" title="1.异常分类"></a>1.异常分类</h2><p>Spring Security 中的异常可以分为两大类，一种是认证异常，一种是授权异常。</p><p>认证异常就是 AuthenticationException，它有众多的实现类：</p><p><img src="http://img.itboyhub.com/2020/06/AuthenticationException--123.png" alt></p><p>可以看到，这里的异常实现类还是蛮多的，都是都是认证相关的异常，也就是登录失败的异常。这些异常，有的松哥在之前的文章中都和大家介绍过了，例如下面这段代码(节选自：<a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a>)：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">PrintWriter out = resp.getWriter();</span><br><span class="line">RespBean respBean = RespBean.error(e.getMessage());</span><br><span class="line"><span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> LockedException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"账户被锁定，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> CredentialsExpiredException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"密码过期，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> AccountExpiredException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"账户过期，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"账户被禁用，请联系管理员!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">    respBean.setMsg(<span class="hljs-string">"用户名或者密码输入错误，请重新输入!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure><p>另一类就是授权异常 AccessDeniedException，授权异常的实现类比较少，因为授权失败的可能原因比较少。</p><p><img src="http://img.itboyhub.com/2020/06/AccessDeniedException222.png" alt></p><h2 id="2-ExceptionTranslationFilter"><a href="#2-ExceptionTranslationFilter" class="headerlink" title="2.ExceptionTranslationFilter"></a>2.ExceptionTranslationFilter</h2><p>ExceptionTranslationFilter 是 Spring Security 中专门负责处理异常的过滤器，默认情况下，这个过滤器已经被自动加载到过滤器链中。</p><p>有的小伙伴可能不清楚是怎么被加载的，我这里和大家稍微说一下。</p><p>当我们使用 Spring Security 的时候，如果需要自定义实现逻辑，都是继承自 WebSecurityConfigurerAdapter 进行扩展，WebSecurityConfigurerAdapter 中本身就进行了一部分的初始化操作，我们来看下它里边 HttpSecurity 的初始化过程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> HttpSecurity <span class="hljs-title">getHttp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (http != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> http;</span><br><span class="line">&#125;</span><br><span class="line">AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();</span><br><span class="line">localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class="line">AuthenticationManager authenticationManager = authenticationManager();</span><br><span class="line">authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class="line">Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects();</span><br><span class="line">http = <span class="hljs-keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class="line">sharedObjects);</span><br><span class="line"><span class="hljs-keyword">if</span> (!disableDefaults) &#123;</span><br><span class="line">http</span><br><span class="line">.csrf().and()</span><br><span class="line">.addFilter(<span class="hljs-keyword">new</span> WebAsyncManagerIntegrationFilter())</span><br><span class="line">.exceptionHandling().and()</span><br><span class="line">.headers().and()</span><br><span class="line">.sessionManagement().and()</span><br><span class="line">.securityContext().and()</span><br><span class="line">.requestCache().and()</span><br><span class="line">.anonymous().and()</span><br><span class="line">.servletApi().and()</span><br><span class="line">.apply(<span class="hljs-keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class="line">.logout();</span><br><span class="line">ClassLoader classLoader = <span class="hljs-keyword">this</span>.context.getClassLoader();</span><br><span class="line">List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =</span><br><span class="line">SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);</span><br><span class="line"><span class="hljs-keyword">for</span> (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;</span><br><span class="line">http.apply(configurer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">configure(http);</span><br><span class="line"><span class="hljs-keyword">return</span> http;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 getHttp 方法的最后，调用了 <code>configure(http);</code>，我们在使用 Spring Security 时，自定义配置类继承自 WebSecurityConfigurerAdapter 并重写的 configure(HttpSecurity http) 方法就是在这里调用的，换句话说，当我们去配置 HttpSecurity 时，其实它已经完成了一波初始化了。</p><p>在默认的 HttpSecurity 初始化的过程中，调用了 exceptionHandling 方法，这个方法会将 ExceptionHandlingConfigurer 配置进来，最终调用 ExceptionHandlingConfigurer#configure 方法将 ExceptionTranslationFilter 添加到 Spring Security 过滤器链中。</p><p>我们来看下 ExceptionHandlingConfigurer#configure 方法源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(H http)</span> </span>&#123;</span><br><span class="line">AuthenticationEntryPoint entryPoint = getAuthenticationEntryPoint(http);</span><br><span class="line">ExceptionTranslationFilter exceptionTranslationFilter = <span class="hljs-keyword">new</span> ExceptionTranslationFilter(</span><br><span class="line">entryPoint, getRequestCache(http));</span><br><span class="line">AccessDeniedHandler deniedHandler = getAccessDeniedHandler(http);</span><br><span class="line">exceptionTranslationFilter.setAccessDeniedHandler(deniedHandler);</span><br><span class="line">exceptionTranslationFilter = postProcess(exceptionTranslationFilter);</span><br><span class="line">http.addFilter(exceptionTranslationFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里构造了两个对象传入到 ExceptionTranslationFilter 中：</p><ul><li>AuthenticationEntryPoint 这个用来处理认证异常。</li><li>AccessDeniedHandler 这个用来处理授权异常。</li></ul><p>具体的处理逻辑则在 ExceptionTranslationFilter 中，我们来看一下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionTranslationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExceptionTranslationFilter</span><span class="hljs-params">(AuthenticationEntryPoint authenticationEntryPoint,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">RequestCache requestCache)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.authenticationEntryPoint = authenticationEntryPoint;</span><br><span class="line"><span class="hljs-keyword">this</span>.requestCache = requestCache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">Throwable[] causeChain = throwableAnalyzer.determineCauseChain(ex);</span><br><span class="line">RuntimeException ase = (AuthenticationException) throwableAnalyzer</span><br><span class="line">.getFirstThrowableOfType(AuthenticationException.class, causeChain);</span><br><span class="line"><span class="hljs-keyword">if</span> (ase == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">ase = (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(</span><br><span class="line">AccessDeniedException.class, causeChain);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ase != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Unable to handle the Spring Security Exception because the response is already committed."</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">handleSpringSecurityException(request, response, chain, ase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> ServletException) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> (ServletException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleSpringSecurityException</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, FilterChain chain, RuntimeException exception)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">sendStartAuthentication(request, response, chain,</span><br><span class="line">(AuthenticationException) exception);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccessDeniedException) &#123;</span><br><span class="line">Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"><span class="hljs-keyword">if</span> (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) &#123;</span><br><span class="line">sendStartAuthentication(</span><br><span class="line">request,</span><br><span class="line">response,</span><br><span class="line">chain,</span><br><span class="line"><span class="hljs-keyword">new</span> InsufficientAuthenticationException(</span><br><span class="line">messages.getMessage(</span><br><span class="line"><span class="hljs-string">"ExceptionTranslationFilter.insufficientAuthentication"</span>,</span><br><span class="line"><span class="hljs-string">"Full authentication is required to access this resource"</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">accessDeniedHandler.handle(request, response,</span><br><span class="line">(AccessDeniedException) exception);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendStartAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, FilterChain chain,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationException reason)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(<span class="hljs-keyword">null</span>);</span><br><span class="line">requestCache.saveRequest(request, response);</span><br><span class="line">logger.debug(<span class="hljs-string">"Calling Authentication entry point."</span>);</span><br><span class="line">authenticationEntryPoint.commence(request, response, reason);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExceptionTranslationFilter 的源码比较长，我这里列出来核心的部分和大家分析：</p><ol><li>过滤器最核心的当然是 doFilter 方法，我们就从 doFilter 方法看起。这里的 doFilter 方法中过滤器链继续向下执行，ExceptionTranslationFilter 处于 Spring Security 过滤器链的倒数第二个，最后一个是 FilterSecurityInterceptor，FilterSecurityInterceptor 专门处理授权问题，在处理授权问题时，就会发现用户未登录、未授权等，进而抛出异常，抛出的异常，最终会被 ExceptionTranslationFilter#doFilter 方法捕获。</li><li>当捕获到异常之后，接下来通过调用 <code>throwableAnalyzer.getFirstThrowableOfType</code> 方法来判断是认证异常还是授权异常，判断出异常类型之后，进入到 handleSpringSecurityException 方法进行处理；如果不是 Spring Security 中的异常类型，则走 ServletException 异常类型的处理逻辑。</li><li>进入到 handleSpringSecurityException 方法之后，还是根据异常类型判断，如果是认证相关的异常，就走 sendStartAuthentication 方法，最终被 authenticationEntryPoint.commence 方法处理；如果是授权相关的异常，就走 accessDeniedHandler.handle 方法进行处理。</li></ol><p>AuthenticationEntryPoint 的默认实现类是 LoginUrlAuthenticationEntryPoint，因此默认的认证异常处理逻辑就是 LoginUrlAuthenticationEntryPoint#commence 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">String redirectUrl = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (useForward) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (forceHttps &amp;&amp; <span class="hljs-string">"http"</span>.equals(request.getScheme())) &#123;</span><br><span class="line">redirectUrl = buildHttpsRedirectUrlForRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (redirectUrl == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String loginForm = determineUrlToUseForThisRequest(request, response,</span><br><span class="line">authException);</span><br><span class="line">RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);</span><br><span class="line">&#125;</span><br><span class="line">redirectStrategy.sendRedirect(request, response, redirectUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，就是重定向，重定向到登录页面（即当我们未登录就去访问一个需要登录才能访问的资源时，会自动重定向到登录页面）。</p><p>AccessDeniedHandler 的默认实现类则是 AccessDeniedHandlerImpl，所以授权异常默认是在 AccessDeniedHandlerImpl#handle 方法中处理的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AccessDeniedException accessDeniedException)</span> <span class="hljs-keyword">throws</span> IOException,</span></span><br><span class="line"><span class="hljs-function">ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!response.isCommitted()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (errorPage != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(WebAttributes.ACCESS_DENIED_403,</span><br><span class="line">accessDeniedException);</span><br><span class="line">response.setStatus(HttpStatus.FORBIDDEN.value());</span><br><span class="line">RequestDispatcher dispatcher = request.getRequestDispatcher(errorPage);</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">response.sendError(HttpStatus.FORBIDDEN.value(),</span><br><span class="line">HttpStatus.FORBIDDEN.getReasonPhrase());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就是服务端跳转返回 403。</p><h2 id="3-自定义处理"><a href="#3-自定义处理" class="headerlink" title="3.自定义处理"></a>3.自定义处理</h2><p>前面和大家介绍了 Spring Security 中默认的处理逻辑，实际开发中，我们可以需要做一些调整，很简单，在 exceptionHandling 上进行配置即可。</p><p>首先自定义认证异常处理类和授权异常处理类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAuthenticationEntryPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationEntryPoint</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.getWriter().write(<span class="hljs-string">"login failed:"</span> + authException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAccessDeniedHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDeniedHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        response.setStatus(<span class="hljs-number">403</span>);</span><br><span class="line">        response.getWriter().write(<span class="hljs-string">"Forbidden:"</span> + accessDeniedException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 SecurityConfig 中进行配置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(myAuthenticationEntryPoint)</span><br><span class="line">                .accessDeniedHandler(myAccessDeniedHandler)</span><br><span class="line">                .and()</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，重启项目，认证异常和授权异常就会走我们自定义的逻辑了。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天主要和小伙伴们分享了 Spring Security 中的异常处理机制，感兴趣的小伙伴可以试一试哦～</p><p>文中代码下载地址：<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>小伙伴们如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来和小伙伴们聊一聊 Spring Security 中的异常处理机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码第三弹！EntityResolver 是个什么鬼？</title>
    <link href="http://www.javaboy.org/2020/0629/entityresolver.html"/>
    <id>http://www.javaboy.org/2020/0629/entityresolver.html</id>
    <published>2020-06-29T01:28:21.000Z</published>
    <updated>2020-06-30T01:46:24.986Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">上篇文章</a>和小伙伴们说了 Spring 源码中 XML 文件的解析流程，本来可以继续往下走看加载核心类了，但是松哥还是希望能够慢一点，既然要学就学懂，在 XML 文件解析的过程中还涉及到一些其他的类和概念，因此我就先用几篇文章介绍一下这些涉及到的概念或者类，然后我们再继续往下看。</p><a id="more"></a><p>本文要和大家介绍的是<a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">上篇文章</a>中涉及到的 EntityResolver 类，看看这个类到底是干嘛用的。</p><p>本文是 Spring 源码系列第四篇，阅读前面文章有助于更好理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/1ImVkjdmcllArzPOSksNoA" target="_blank" rel="noopener">Spring 源码解读计划</a></li><li><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a></li><li><a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">Spring 源码第二弹！XML 文件解析流程</a></li></ol><p>先来回顾下，在 EntityResolver 这个类在<a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">上篇文章</a>哪里出现了。</p><p>我们在讲到 doLoadDocument 方法时，在该方法中调用 loadDocument 方法时，传递的第二个参数就是一个 EntityResolver 实例，当时我们说这个是用来处理文件的验证方式的，但是到底是怎么处理的，今天我们就来看下。</p><h2 id="1-XML-验证模式"><a href="#1-XML-验证模式" class="headerlink" title="1.XML 验证模式"></a>1.XML 验证模式</h2><p>要了解 EntityResolver，就得先来看看 XML 文件验证模式。</p><p>现在我们大多数情况下可能都是使用 JSON 传递数据，XML 使用较少，可能有的小伙伴对 XML 文件的一些规则还不太熟悉，我这里稍微说一下。</p><p>XML 是指可扩展标记语言(eXtensible Markup Language)，它是一种标记语言，类似 HTML；XML 标签没有被预定义，需要用户自行定义标签，也就是 XML 文件中的节点都是用户自定义的。XML 文件从设计之初就是为了传输数据，而非显示数据。</p><p>一般来说，一个 XML 文件由六个部分组成：</p><ul><li>文档生命</li><li>元素</li><li>属性</li><li>注释</li><li>CDATA 区</li><li>处理指令</li></ul><p>虽然说 XML 文件本身是没有预定义 XML 标签，但是当 XML 文件作为框架的配置时，对于 XML 标签还是要有一定的约束，否则每个人都按照自己的喜好定义 XML 标签，框架就没法读取这样的 XML 文件了。</p><p>在 XML 技术中，开发者可以通过一个文档来约束一个 XML 的文档中的标签，这个文档称之为约束。遵循 XML 语法的 XML 我们称之为格式良好的 XML，而遵循 XML 约束的 XML 我们称之为有效的 XML。XML 约束文档主要定义了在 XML 中允许出现的元素名称、属性及元素出现的顺序等等。</p><p>要想约束 XML 标签，有两种方式：</p><ol><li>DTD</li><li>Schema</li></ol><p>DTD(Document Type Definition)，全称为文档类型定义，一个 DTD 约束文件我们既可以定义在 XML 文件内部，也可以定义一个本地文件，也可以引用一个网络上的公共的 DTD。</p><p>XML Schema 也是一种用于定义和描述 XML 文档结构与内容的模式语言，相比于 DTD，Schema 对于名称空间的支持更加友好，同时也支持更多的数据类型，而且它的约束能力也比较强大，另外还有非常重要的一点是，Schema 文档本身也是 XML 文档，而不是像 DTD 一样使用自成一体的语法。</p><p>所以，Schema 目前在 XML 约束这块更具备优势，也在逐渐替代 DTD。</p><p>大家在日常开发中，这两种约束可能都见过，但是有的人可能没注意。我给大家简单举一个例子。</p><p>早期的 Spring 配置头部是这样的(Spring2.x)，这就是 DTD 约束：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="hljs-meta">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"  </span></span><br><span class="line"><span class="hljs-meta">"http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;</span>  </span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在大家看到的 Spring 配置头部一般都是这样，这就是 Schema 约束：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>schema 约束对命名空间有着很好的支持，命名空间可以防止命名冲突，schema 中的名称空间和约束文件都是成对出现的。</p><p>有了约束，XML 文件中该写什么不该写什么就固定下来了，这样框架才能成功解析出 XML 文件。</p><p>但是大家同时也发现了一个新的问题，无论是 DTD 还是 Schema 约束，给出的约束文件地址都是一个在线地址，这就意味着项目启动时必须能够访问到该在线地址，才能加载到约束文件，如果访问在线约束文件失败，那么项目启动也会失败。</p><p>为了解决这个问题，框架一般都是将约束文件放在本地的，在本地哪里呢？实际上就在你下载的 jar 包里。以 spring-beans 为例，在下载的 jar 包里有如下两个文件：</p><p><img src="http://img.itboyhub.com/2020/06/20200624103413.png" alt></p><p>spring.handlers 文件内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/c=org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler</span><br></pre></td></tr></table></figure><p>这其实一个映射配置，每一个名称空间对应的处理类在这里进行配置。</p><p>spring.schemas 文件内容如下（部分）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/beans/spring-beans-2.0.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-2.5.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-3.0.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-3.1.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-3.2.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-4.0.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-4.1.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-4.2.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans-4.3.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br><span class="line">http\://www.springframework.org/schema/beans/spring-beans.xsd=org/springframework/beans/factory/xml/spring-beans.xsd</span><br></pre></td></tr></table></figure><p>可以看到，各种版本以及没有版本号的约束文件，都对应了同一个文件，就是 org/springframework/beans/factory/xml/spring-beans.xsd，打开这个文件目录，我们就可以看到约束文件：</p><p><img src="http://img.itboyhub.com/2020/06/20200624104130.png" alt></p><p><strong>所以我们虽然在 Spring 的 XML 配置中看到的约束文件是一个在线地址，实际上约束文件是从本地 jar 中读取的。</strong></p><h2 id="2-两种解析器"><a href="#2-两种解析器" class="headerlink" title="2.两种解析器"></a>2.两种解析器</h2><p>EntityResolver 就是用来处理 XML 验证的。我们先来看下 EntityResolver 接口的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EntityResolver</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> InputSource <span class="hljs-title">resolveEntity</span> <span class="hljs-params">(String publicId,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                               String systemId)</span></span></span><br><span class="line"><span class="hljs-function">        <span class="hljs-keyword">throws</span> SAXException, IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中就只有一个方法，就是加载约束文件。在 Spring 中，EntityResolver 的实现类是 DelegatingEntityResolver：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingEntityResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EntityResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DTD_SUFFIX = <span class="hljs-string">".dtd"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String XSD_SUFFIX = <span class="hljs-string">".xsd"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EntityResolver dtdResolver;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EntityResolver schemaResolver;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelegatingEntityResolver</span><span class="hljs-params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.dtdResolver = <span class="hljs-keyword">new</span> BeansDtdResolver();</span><br><span class="line"><span class="hljs-keyword">this</span>.schemaResolver = <span class="hljs-keyword">new</span> PluggableSchemaResolver(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelegatingEntityResolver</span><span class="hljs-params">(EntityResolver dtdResolver, EntityResolver schemaResolver)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.dtdResolver = dtdResolver;</span><br><span class="line"><span class="hljs-keyword">this</span>.schemaResolver = schemaResolver;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> InputSource <span class="hljs-title">resolveEntity</span><span class="hljs-params">(@Nullable String publicId, @Nullable String systemId)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> SAXException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (systemId != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (systemId.endsWith(DTD_SUFFIX)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dtdResolver.resolveEntity(publicId, systemId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (systemId.endsWith(XSD_SUFFIX)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.schemaResolver.resolveEntity(publicId, systemId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"EntityResolver delegating "</span> + XSD_SUFFIX + <span class="hljs-string">" to "</span> + <span class="hljs-keyword">this</span>.schemaResolver +</span><br><span class="line"><span class="hljs-string">" and "</span> + DTD_SUFFIX + <span class="hljs-string">" to "</span> + <span class="hljs-keyword">this</span>.dtdResolver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 DelegatingEntityResolver 类中：</p><ol><li>首先通过两种不同的后缀来区分不同的约束。</li><li>然后定义了 dtdResolver 和 schemaResolver 两个不同的变量，对应的类型分别是 BeansDtdResolver 和 PluggableSchemaResolver，也就是 dtd 和 schema 的约束验证分别由这两个类来处理。</li><li>在 resolveEntity 方法中，根据解析出来不同的后缀，分别交由不同的 EntityResolver 来处理。resolveEntity 解析中有两个参数，如果是 dtd 解析的话，publicId 是有值的，如果是 schema 解析，publicId 为 null，而 systemId 则始终指向具体的约束文件。</li></ol><p>由于现在大部分都是 schema 约束，所以这里我们就来重点看下 PluggableSchemaResolver 类的实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PluggableSchemaResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EntityResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SCHEMA_MAPPINGS_LOCATION = <span class="hljs-string">"META-INF/spring.schemas"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Log logger = LogFactory.getLog(PluggableSchemaResolver.class);</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader classLoader;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String schemaMappingsLocation;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String, String&gt; schemaMappings;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PluggableSchemaResolver</span><span class="hljs-params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.classLoader = classLoader;</span><br><span class="line"><span class="hljs-keyword">this</span>.schemaMappingsLocation = DEFAULT_SCHEMA_MAPPINGS_LOCATION;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PluggableSchemaResolver</span><span class="hljs-params">(@Nullable ClassLoader classLoader, String schemaMappingsLocation)</span> </span>&#123;</span><br><span class="line">Assert.hasText(schemaMappingsLocation, <span class="hljs-string">"'schemaMappingsLocation' must not be empty"</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.classLoader = classLoader;</span><br><span class="line"><span class="hljs-keyword">this</span>.schemaMappingsLocation = schemaMappingsLocation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> InputSource <span class="hljs-title">resolveEntity</span><span class="hljs-params">(@Nullable String publicId, @Nullable String systemId)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Trying to resolve XML entity with public id ["</span> + publicId +</span><br><span class="line"><span class="hljs-string">"] and system id ["</span> + systemId + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (systemId != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String resourceLocation = getSchemaMappings().get(systemId);</span><br><span class="line"><span class="hljs-keyword">if</span> (resourceLocation == <span class="hljs-keyword">null</span> &amp;&amp; systemId.startsWith(<span class="hljs-string">"https:"</span>)) &#123;</span><br><span class="line">resourceLocation = getSchemaMappings().get(<span class="hljs-string">"http:"</span> + systemId.substring(<span class="hljs-number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (resourceLocation != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Resource resource = <span class="hljs-keyword">new</span> ClassPathResource(resourceLocation, <span class="hljs-keyword">this</span>.classLoader);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">InputSource source = <span class="hljs-keyword">new</span> InputSource(resource.getInputStream());</span><br><span class="line">source.setPublicId(publicId);</span><br><span class="line">source.setSystemId(systemId);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Found XML schema ["</span> + systemId + <span class="hljs-string">"] in classpath: "</span> + resourceLocation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Could not find XML schema ["</span> + systemId + <span class="hljs-string">"]: "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, String&gt; <span class="hljs-title">getSchemaMappings</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Map&lt;String, String&gt; schemaMappings = <span class="hljs-keyword">this</span>.schemaMappings;</span><br><span class="line"><span class="hljs-keyword">if</span> (schemaMappings == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">schemaMappings = <span class="hljs-keyword">this</span>.schemaMappings;</span><br><span class="line"><span class="hljs-keyword">if</span> (schemaMappings == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Properties mappings =</span><br><span class="line">PropertiesLoaderUtils.loadAllProperties(<span class="hljs-keyword">this</span>.schemaMappingsLocation, <span class="hljs-keyword">this</span>.classLoader);</span><br><span class="line">schemaMappings = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(mappings.size());</span><br><span class="line">CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);</span><br><span class="line"><span class="hljs-keyword">this</span>.schemaMappings = schemaMappings;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"Unable to load schema mappings from location ["</span> + <span class="hljs-keyword">this</span>.schemaMappingsLocation + <span class="hljs-string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> schemaMappings;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"EntityResolver using schema mappings "</span> + getSchemaMappings();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在这个类中，一上来先通过 DEFAULT_SCHEMA_MAPPINGS_LOCATION 变量定义了 spring.schemas 文件的位置。</li><li>getSchemaMappings 方法则是将 spring.schemas 文件中的内容读取成一个 Map 加载进来。</li><li>在 resolveEntity 方法中，根据 systemId 找到文件路径，systemId 是 <code>http\://www.springframework.org/schema/beans/spring-beans.xsd</code> 格式，文件路径则是 <code>org/springframework/beans/factory/xml/spring-beans.xsd</code>，如果第一次没有加载到，就把用户的 <code>https:</code> 替换成 <code>http:</code> 再去加载。</li><li>有了文件路径，接下来调用 ClassPathResource 去获取一个 Resource 对象，这块可以参考本系列<a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">第二篇</a>，这里我就不再赘述。</li><li>最后构造一个 InputSource 返回即可。</li></ol><p>在<a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">上篇文章</a>中，我们获取 EntityResolver 是通过 getEntityResolver 方法来获取的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> EntityResolver <span class="hljs-title">getEntityResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.entityResolver == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Determine default EntityResolver to use.</span></span><br><span class="line">ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line"><span class="hljs-keyword">if</span> (resourceLoader != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.entityResolver = <span class="hljs-keyword">new</span> ResourceEntityResolver(resourceLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.entityResolver = <span class="hljs-keyword">new</span> DelegatingEntityResolver(getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.entityResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终返回的是 ResourceEntityResolver，ResourceEntityResolver 继承自 DelegatingEntityResolver，当调用 resolveEntity 方法时，也是先调用父类的该方法，进行处理，如果父类方法处理成功了，就直接返回父类方法给出的结果，如果父类方法处理失败了，则在 ResourceEntityResolver 中通过资源的相对路径再次尝试加载。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，经过上面的介绍，相信大家对于 XMl 约束和 EntityResolver 都有一定的了解啦。</p><p><strong>后记</strong></p><p>本文刚写完，微信群里就有小伙伴问了一个一模一样的问题：</p><p><img src="http://img.itboyhub.com/2020/06/20200628201502.png" alt></p><p>松哥不禁感叹，<strong>源码并非离我们很远的东西，阅读源码可以有效解决我们日常开发中一些实实在在的问题！</strong></p><p>如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;和小伙伴们说了 Spring 源码中 XML 文件的解析流程，本来可以继续往下走看加载核心类了，但是松哥还是希望能够慢一点，既然要学就学懂，在 XML 文件解析的过程中还涉及到一些其他的类和概念，因此我就先用几篇文章介绍一下这些涉及到的概念或者类，然后我们再继续往下看。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解读" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>写代码靠天赋还是靠苦功夫？</title>
    <link href="http://www.javaboy.org/2020/0628/life.html"/>
    <id>http://www.javaboy.org/2020/0628/life.html</id>
    <published>2020-06-28T01:28:06.000Z</published>
    <updated>2020-06-30T01:46:28.563Z</updated>
    
    <content type="html"><![CDATA[<p>有天赋就靠天赋，没天赋难道要坐以待毙？</p><a id="more"></a><p>其实不管什么行业，如果你具备别人不具备的天赋，那你可能比别人更容易获得成功。但是每个行业中的所有从业者，不可能都是该行业有天赋的人，还有很多没有天赋的人，他们难道就不活了吗？</p><p>IT 行业也是一样，有天赋就靠天赋，那你更容易走向金字塔的顶端；没天赋就下苦工夫，可能走的比别人慢一些，但是也能达到终点。不过老实说，IT 行业的人才短缺，以至于涌进来很多转行的小伙伴，我见到的大部分转行的小伙伴都是可以胜任当前工作的，不过也有很小一小部分并不是特别适合这个行业，这一类人不在本文讨论范围内。</p><h2 id="1-苦功夫"><a href="#1-苦功夫" class="headerlink" title="1.苦功夫"></a>1.苦功夫</h2><p>先不说别人，我觉得自己一直是靠苦功夫，不是我喜欢吃苦，而是因为没有天赋。</p><p>上高中之前，我是蜜汁自信，但是上高中之后，我发现身边突然多了学习很聪明的人，我们一起生活在学校的住校部，别人回来从来不做作业，但是每次考试就是名列前茅，别人向他请教数学问题，他能一下把问题讲的很清晰透彻。特别是在高中那样一个特别压抑，大家都忙着做练习题的年代，这样的人特别容易让人佩服。</p><p>我的自信心受到了暴捶，再也不敢嚣张了。我没有那样的天赋，但是我也想上大学，那我只能自己下苦功夫了，后来总算勉勉强强上了一个 211。</p><p>上大学之后，从管理转行做开发，刚开始两眼一抹黑，不知道从何下手，但是总不能停滞不前，得行动起来，那就啃书吧！啃了半年吧，把 JavaSE 搞定了。</p><p>这段时间是最辛苦的，看书很多专业的名词不懂，很多抽象概念想很久才能想明白，那个时候，刚开始的时候身边也没有人指导，不过好在大学时间很充足，除了上课，都是业余时间。那时遇到问题了，就是闷头苦想，很多东西都是自己想了很久才想明白的，这样的好处是一旦学会了某个知识点就会印象深刻，同时也让我明白自己在这方面可能并没有多少天赋，还是得下苦工夫去学习去练习。</p><p>等搞定了 JavaSE 才发现网上有视频教程可以学习，于是又开始看视频教程。在刚入行的时候，看视频要比看书理解的快很多。但是看视频也是一个需要下功夫的事情，相信很多小伙伴网盘里都保存了不少视频，不过这不是关键，关键是要看！</p><p>就这样从大二到大四搞了三年，毕业之后顺利转行，工作之后也是非常顺利，无论是薪水涨幅还是在工作第二年从 Android 顺利切换到 Java ，表面上看着很顺利，实际上是无数个日日夜夜 coding 积累的结果。</p><p>即使在今天也依然不敢松懈，见识到厉害的人太多了，自己稍微松懈一下可能就落后了。</p><h2 id="2-没有捷径"><a href="#2-没有捷径" class="headerlink" title="2.没有捷径"></a>2.没有捷径</h2><p>之前松哥发了篇文章，<a href="https://mp.weixin.qq.com/s/3ZdeAz9-SEpAO98ubE67wA" target="_blank" rel="noopener">“看来真的只有自身强大起来，别人才会理你”</a>，那篇文章我主要是想说人微言轻的时候，还是要修炼自己，让自己变得强大。虽然我们可能觉得这个世界很势利，但它就是这样，抱怨解决不了问题，只有努力修炼提高自己才能解决问题。</p><p>有个小伙伴给出了这样一条评论：</p><p><img src="http://img.itboyhub.com/2020/06/20200626184258.png" alt></p><p>我理解这位小伙伴的意思是得到上乘的武功秘籍（学习方法/大牛指引等）就可以让自己变的强大，但是很多时候我们可能并不需要一本上乘的武功秘籍，可能仅仅一套军体拳就能干倒一大片了，问题在于很多人可能不屑于练军体拳。</p><p>写代码在外行人看来似乎是一个拼智商的行业，但是看文章的小伙伴们应该明白，大部分情况下，你所做的工作都没到拼智商的地步，只要稍微努力一点点，就能搞定！</p><blockquote><p>松哥的读者基本上都是搞 Java 的，可能做 AI/NLP/算法 的比较少，Java 技术栈生态比较完善，大部分场景又都是业务驱动开发，所以很多时候都没到拼智商的地步，只要平时勤快一点，多学点东西，就能搞定大部分工作了。</p></blockquote><p>很多小伙伴加松哥微信，想问一下要怎么学习？有没有捷径？这种问题经常让我感觉很难回答，我说没有，有的人不相信，我说有，其实真没有，我也讲不出个 123 来！</p><p>我的学习办法都是笨办法，所以我平时才需要花大把的时间在技术上，否则我就像高中那位小伙伴一样，下班后我就不研究代码了，那多潇洒～</p><p>虽然我花的时间可能比别人多，但是很明显，最终的效果还可以，所以这是值得的。</p><p>有天赋可以走的更高更远，没天赋，下点苦功夫，也能做的很好！<strong>关键是行动起来！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有天赋就靠天赋，没天赋难道要坐以待毙？&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 配置中的 and 到底该怎么理解？</title>
    <link href="http://www.javaboy.org/2020/0624/httpsecurity-and.html"/>
    <id>http://www.javaboy.org/2020/0624/httpsecurity-and.html</id>
    <published>2020-06-24T01:27:49.000Z</published>
    <updated>2020-06-30T01:46:34.054Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来看一个简单的配置：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .logout()</span><br><span class="line">            .logoutUrl(<span class="hljs-string">"/logout"</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的配置在 Spring Security 中很常见，通过 and 方法，可以将所有的配置连接在一起，一条线下来，所有的东西都配置好了。</p><p>但是有小伙伴对这里的 and 表示很迷，不知道什么时候 and 方法该出场，什么时候 and 不该出场！</p><p>所以今天松哥就花点时间来和大家聊一下这里的 and 方法，希望大家看完完整后，能够明白 and 到底怎么玩！</p><p>本文是 Spring Security 系列第 33 篇，阅读前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/uWib5RtH1aEC7p5VK4S1Ig" target="_blank" rel="noopener">Spring Boot+CAS 默认登录页面太丑了，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/LvMOKeX09liTvujZi6XO3Q" target="_blank" rel="noopener">用 Swagger 测试接口，怎么在请求头中携带 Token？</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li><li><a href="https://mp.weixin.qq.com/s/7T5XA1zxQkhMvffMxHKVvQ" target="_blank" rel="noopener">Spring Boot 中如何实现 HTTP 认证？</a></li><li><a href="https://mp.weixin.qq.com/s/7cm99q5ZM4qUkekx0Xa0YQ" target="_blank" rel="noopener">Spring Security 中的四种权限控制方式</a></li><li><a href="https://mp.weixin.qq.com/s/_iau1jsnc50vs794_ib0IA" target="_blank" rel="noopener">Spring Security 多种加密方案共存，老破旧系统整合利器！</a></li><li><a href="https://mp.weixin.qq.com/s/edtYkmgx_SnYoqsy-yFmsQ" target="_blank" rel="noopener">神奇！自己 new 出来的对象一样也可以被 Spring 容器管理！</a></li></ol><h2 id="1-原始配置"><a href="#1-原始配置" class="headerlink" title="1.原始配置"></a>1.原始配置</h2><p>在 Spring Boot 出现之前，我们使用 Spring Security ，都是通过 XML 文件来配置 Spring Security 的，即使现在大家在网上搜索 Spring Security 的文章，还是能够找到很多 XML 配置的。</p><p>但是小伙伴们明白，无论是 XML 配置还是 Java 配置，只是在用不同的方式描述同一件事情，从这里角度来看，我们现在所使用的 Java 配置，和以前使用的 XML 配置，应该有某种异曲同工之妙。</p><p>可能有小伙伴没见过 XML 配置的 Spring Security，我在这里给大家简单举几个例子：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">http</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">intercept-url</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">access</span>=<span class="hljs-string">"permitAll"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">form-login</span> <span class="hljs-attr">login-page</span>=<span class="hljs-string">"/login"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">http-basic</span> /&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">http</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段 XML 大家稍微瞅一眼大概就能明白其中的含义：</p><ol><li>intercept-url 相当于配置拦截规则</li><li>form-login 是配置表单登录</li><li>http-basic 是配置 HttpBasic 认证</li></ol><p>如果我们使用了 Java 配置，这些 XML 配置都有对应的写法，例如 <code>.anyRequest().authenticated()</code> 就是配置拦截规则的，<code>.formLogin()</code> 是配置表单登录细节的。</p><p>仅仅从语义层面来理解，and 有点类似于 XML 中的结束标签，每当 and 出现，当前的配置项就结束了，可以开启下一个配置了。</p><p>那么从代码层面上，这个要如何理解呢？</p><h2 id="2-代码层面的理解"><a href="#2-代码层面的理解" class="headerlink" title="2.代码层面的理解"></a>2.代码层面的理解</h2><p>小伙伴们知道，Spring Security 中的功能是由一系列的过滤器来实现的，默认的过滤器一共有 15 个，这 15 个过滤器松哥以后会和大家挨个介绍。</p><p>每一个过滤器都有一个对应的 configurer 来对其进行配置，例如我们常见的 UsernamePasswordAuthenticationFilter 过滤器就是通过 AbstractAuthenticationFilterConfigurer 来进行配置的。</p><p>这些 configure 都有一个共同的父类，那就是 SecurityConfigurer，给大家大致看一下 SecurityConfigurer 的继承关系图：</p><p><img src="http://img.itboyhub.com/2020/06/20200612204122.png" alt></p><p>可以看到，它的实现类还是蛮多的。</p><p>SecurityConfigurer 的源码很简单：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt;&gt; </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就两个方法，第一个 init 用来做初始化操作，第二个 configure 用来做具体的配置。</p><p>在 Spring Security 框架初始化的时候，会把所有的这些 xxxConfigurer 收集起来，然后再统一调用每一个 xxxConfigurer 里边的 init 和 configure 方法（松哥在以后的文章中会和大家详细讨论这个过程），调用完成后，Spring Security 默认的过滤器链就形成了。</p><p>这就是我们所说的 xxxConfigurer 的作用！</p><p>在文章一开始，松哥列出来的示例代码中，HttpSecurity 中其实就是在配置各种各样的 xxxConfigurer。</p><p>SecurityConfigurer 有一个重要的实现类就是 SecurityConfigurerAdapter，默认的 15 个过滤器的 Configurer 类都是继承自它！而在 SecurityConfigurerAdapter 中就多出来一个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt;&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">and</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getBuilder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，就是大家所熟知的 and 方法。and 方法的返回值是一个 SecurityBuilder 的子类，其实就是 HttpSecurity，也就是 and 方法总是让我们回到 HttpSecurity，从而开启新一轮的 xxxConfigurer 配置。</p><p>我们再来瞅一眼 HttpSecurity 中到底都有啥方法（方法比较多，我这里仅列举一部分）：</p><p><img src="http://img.itboyhub.com/2020/06/20200612210454.png" alt></p><p>可以看到，每一个类型的配置，都有一个对应的返回 Configure 的方法，例如 OpenIDLoginConfigurer、HeadersConfigurer、CorsConfigurer 等等，大家注意，每一个 configure 方法都有一个 HttpSecurity 作为泛型，这实际上就指定了 and 方法的返回类型。</p><p>我再举个例子，大家可能更清楚一些，以 HttpSecurity 中 RememberME 的配置为例，有两个方法：</p><ul><li>RememberMeConfigurer<httpsecurity> rememberMe()</httpsecurity></li><li>HttpSecurity rememberMe(Customizer&lt;RememberMeConfigurer<httpsecurity>&gt; rememberMeCustomizer)</httpsecurity></li></ul><ol><li>第一个 rememberMe 方法没有参数，但是返回值是一个 RememberMeConfigurer，我们可以在这个 RememberMeConfigurer 上继续配置 RememberME 相关的其他属性，配置完成后，通过 and 方法重新回到 HttpSecurity 对象，松哥前面文章基本上都是采用这种方式配置的，这里我就不重复举例子了。</li><li>第二个 rememberMe 方法有参数，参数是一个 Customizer ，但是带着一个 RememberMeConfigurer 泛型。其实 Customizer 就是一个接口，我们可以通过匿名内部类的方式来实现该接口，这个接口中就一个实例方法，而且该方法的参数还是你传入的泛型，即 RememberMeConfigurer，其实也就是我们换了个地方去配置 RememberMeConfigurer 了，配置完成后，这个方法会直接返回 HttpSecurity，此时就不再需要 and 方法了。配置示例如下（注意配置完成后不需要 and 方法就能继续后面的配置了）：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .rememberMe(<span class="hljs-keyword">new</span> Customizer&lt;RememberMeConfigurer&lt;HttpSecurity&gt;&gt;() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(RememberMeConfigurer&lt;HttpSecurity&gt; httpSecurityRememberMeConfigurer)</span> </span>&#123;</span><br><span class="line">                    httpSecurityRememberMeConfigurer.key(<span class="hljs-string">"123"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们在 configure(HttpSecurity http) 方法中的配置过程。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>通过前面的讲解，不知道小伙伴们有没有看懂呢？我再给大家总结下。</p><p>Spring Security 的功能主要是通过各种各样的过滤器来实现的，各种各样的过滤器都由对应的 xxxConfigurer 来进行配置，我们在 configure(HttpSecurity http) 中所做的配置其实就是在配置 xxxConfigurer，也是在间接的配置过滤器，每一个 and 方法会将我们带回到 HttpSecurity 实例中，从而开启新一轮的配置。</p><p>大致就是这样！</p><p>小伙伴们如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们先来看一个简单的配置：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>神奇！自己 new 出来的对象一样也可以被 Spring 容器管理！</title>
    <link href="http://www.javaboy.org/2020/0623/objectpostprocess.html"/>
    <id>http://www.javaboy.org/2020/0623/objectpostprocess.html</id>
    <published>2020-06-23T01:27:38.000Z</published>
    <updated>2020-06-30T01:46:38.329Z</updated>
    
    <content type="html"><![CDATA[<p>按理说自己 new 出来的对象和容器是没有关系的，但是在 Spring Security 框架中也 new 了很多对象出来，一样也可以被容器管理，那么它是怎么做到的？</p><a id="more"></a><p>今天来和大家聊一个略微冷门的话题，Spring Security 中的 ObjectPostProcessor 到底是干嘛用的？</p><p>本文是 Spring Security 系列第 32 篇，阅读前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/uWib5RtH1aEC7p5VK4S1Ig" target="_blank" rel="noopener">Spring Boot+CAS 默认登录页面太丑了，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/LvMOKeX09liTvujZi6XO3Q" target="_blank" rel="noopener">用 Swagger 测试接口，怎么在请求头中携带 Token？</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li><li><a href="https://mp.weixin.qq.com/s/7T5XA1zxQkhMvffMxHKVvQ" target="_blank" rel="noopener">Spring Boot 中如何实现 HTTP 认证？</a></li><li><a href="https://mp.weixin.qq.com/s/7cm99q5ZM4qUkekx0Xa0YQ" target="_blank" rel="noopener">Spring Security 中的四种权限控制方式</a></li><li><a href="https://mp.weixin.qq.com/s/_iau1jsnc50vs794_ib0IA" target="_blank" rel="noopener">Spring Security 多种加密方案共存，老破旧系统整合利器！</a></li></ol><p>如果大家研究过松哥的微人事项目，就会发现里边的动态权限配置有这样一行代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                    <span class="hljs-meta">@Override</span></span><br><span class="line">                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                        object.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);</span><br><span class="line">                        <span class="hljs-keyword">return</span> object;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .and()</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 withObjectPostProcessor 到底该如何理解？</p><p>今天松哥就来和大家揭开谜题。</p><h2 id="1-ObjectPostProcessor-的作用"><a href="#1-ObjectPostProcessor-的作用" class="headerlink" title="1.ObjectPostProcessor 的作用"></a>1.ObjectPostProcessor 的作用</h2><p>我们先来看下 ObjectPostProcessor 到底有啥作用，先来看一下这个接口的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> org.springframework.security.config.annotation;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ObjectPostProcessor</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">&lt;O extends T&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中就只有一个 postProcess 方法。</p><p>我们再来看看 ObjectPostProcessor 的继承关系：</p><p><img src="http://img.itboyhub.com/2020/06/ObjectPostProcessor.png" alt></p><p>两个比较重要的实现类，其中 AutowireBeanFactoryObjectPostProcessor 值得一说，来看下 AutowireBeanFactoryObjectPostProcessor 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutowireBeanFactoryObjectPostProcessor</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">ObjectPostProcessor</span>&lt;<span class="hljs-title">Object</span>&gt;, <span class="hljs-title">DisposableBean</span>, <span class="hljs-title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line">AutowireBeanFactoryObjectPostProcessor(</span><br><span class="line">AutowireCapableBeanFactory autowireBeanFactory) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.autowireBeanFactory = autowireBeanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">postProcess</span><span class="hljs-params">(T object)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">T result = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">result = (T) <span class="hljs-keyword">this</span>.autowireBeanFactory.initializeBean(object,</span><br><span class="line">object.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">Class&lt;?&gt; type = object.getClass();</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(</span><br><span class="line"><span class="hljs-string">"Could not postProcess "</span> + object + <span class="hljs-string">" of type "</span> + type, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.autowireBeanFactory.autowireBean(object);</span><br><span class="line"><span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> DisposableBean) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.disposableBeans.add((DisposableBean) result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.smartSingletons.add((SmartInitializingSingleton) result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutowireBeanFactoryObjectPostProcessor 的源码很好理解：</p><ol><li>首先在构建 AutowireBeanFactoryObjectPostProcessor 对象时，传入了一个 AutowireCapableBeanFactory 对象，看过 Spring 源码的小伙伴就知道，AutowireCapableBeanFactory 可以帮助我们手动的将一个实例注册到 Spring 容器中。</li><li>在 postProcess 方法中，就是具体的注册逻辑了，都很简单，我就不再赘述。</li></ol><p>由此可见，ObjectPostProcessor 的主要作用就是手动注册实例到 Spring 容器中去（并且让实例走一遍 Bean 的生命周期）。</p><p>正常来说，我们项目中的 Bean 都是通过自动扫描注入到 Spring 容器中去的，然而在 Spring Security 框架中，有大量的代码不是通过自动扫描注入到 Spring 容器中去的，而是直接 new 出来的，这样做的本意是为了简化项目配置。</p><p>这些直接 new 出来的代码，如果想被 Spring 容器管理该怎么办呢？那就得 ObjectPostProcessor 出场了。</p><h2 id="2-框架举例"><a href="#2-框架举例" class="headerlink" title="2.框架举例"></a>2.框架举例</h2><p>接下来我随便举几个框架中对象 new 的例子，大家看一下 ObjectPostProcessor 的作用：</p><p>HttpSecurity 初始化代码（WebSecurityConfigurerAdapter#getHttp）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> HttpSecurity <span class="hljs-title">getHttp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (http != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> http;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">http = <span class="hljs-keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class="line">sharedObjects);</span><br><span class="line">...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebSecurity 初始化代码（WebSecurityConfiguration#setFilterChainProxySecurityConfigurer）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFilterChainProxySecurityConfigurer</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Value(<span class="hljs-string">"#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;"</span>)</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">webSecurity = objectPostProcessor</span><br><span class="line">.postProcess(<span class="hljs-keyword">new</span> WebSecurity(objectPostProcessor));</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 框架源码中，随处可见手动装配。Spring Security 中，过滤器链中的所有过滤器都是通过对应的 xxxConfigure 来进行配置的，而所有的 xxxConfigure 都是继承自 SecurityConfigurerAdapter，如下：</p><p><img src="http://img.itboyhub.com/2020/06/20200611163924.png" alt></p><p>而在这些 xxxConfigure 的 configure 方法中，无一例外的都会让他们各自配置的管理器去 Spring 容器中走一圈，例如 AbstractAuthenticationFilterConfigurer#configure 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">    ...</span><br><span class="line">F filter = postProcess(authFilter);</span><br><span class="line">http.addFilter(filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的 xxxConfigurer#configure 方法也都有类似的实现，小伙伴们可以自行查看，我就不再赘述了。</p><h2 id="3-为什么这样"><a href="#3-为什么这样" class="headerlink" title="3.为什么这样"></a>3.为什么这样</h2><p>直接将 Bean 通过自动扫描注册到 Spring 容器不好吗？为什么要搞成这个样子？</p><p>在 Spring Security 中，由于框架本身大量采用了 Java 配置，并且没有将对象的各个属性都暴露出来，这样做的本意是为了简化配置。然而这样带来的一个问题就是需要我们手动将 Bean 注册到 Spring 容器中去，ObjectPostProcessor 就是为了解决该问题。</p><p>一旦将 Bean 注册到 Spring 容器中了，我们就有办法去增强一个 Bean 的功能，或者需修改一个 Bean 的属性。</p><p>例如一开始提到的动态权限配置代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                    <span class="hljs-meta">@Override</span></span><br><span class="line">                    <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                        object.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);</span><br><span class="line">                        <span class="hljs-keyword">return</span> object;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .and()</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>权限管理本身是由 FilterSecurityInterceptor 控制的，系统默认的 FilterSecurityInterceptor 已经创建好了，而且我也没办法修改它的属性，那么怎么办呢？我们可以利用 withObjectPostProcessor 方法，去修改 FilterSecurityInterceptor 中的相关属性。</p><p>上面这个配置生效的原因之一是因为 FilterSecurityInterceptor 在创建成功后，会重走一遍 postProcess 方法，这里通过重写 postProcess 方法就能实现属性修改，我们可以看下配置 FilterSecurityInterceptor 的方法（AbstractInterceptUrlConfigurer#configure）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractInterceptUrlConfigurer</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractInterceptUrlConfigurer</span>&lt;<span class="hljs-title">C</span>, <span class="hljs-title">H</span>&gt;, <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">H</span>&gt;&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractHttpConfigurer</span>&lt;<span class="hljs-title">C</span>, <span class="hljs-title">H</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(H http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">FilterInvocationSecurityMetadataSource metadataSource = createMetadataSource(http);</span><br><span class="line"><span class="hljs-keyword">if</span> (metadataSource == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">FilterSecurityInterceptor securityInterceptor = createFilterSecurityInterceptor(</span><br><span class="line">http, metadataSource, http.getSharedObject(AuthenticationManager.class));</span><br><span class="line"><span class="hljs-keyword">if</span> (filterSecurityInterceptorOncePerRequest != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">securityInterceptor</span><br><span class="line">.setObserveOncePerRequest(filterSecurityInterceptorOncePerRequest);</span><br><span class="line">&#125;</span><br><span class="line">securityInterceptor = postProcess(securityInterceptor);</span><br><span class="line">http.addFilter(securityInterceptor);</span><br><span class="line">http.setSharedObject(FilterSecurityInterceptor.class, securityInterceptor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，securityInterceptor 对象创建成功后，还是会去 postProcess 方法中走一遭。</p><p>看懂了上面的代码，接下来我再举一个例子小伙伴们应该一下就能明白：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                ...</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;UsernamePasswordAuthenticationFilter&gt;() &#123;</span><br><span class="line">                    <span class="hljs-meta">@Override</span></span><br><span class="line">                    <span class="hljs-keyword">public</span> &lt;O extends UsernamePasswordAuthenticationFilter&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                        object.setUsernameParameter(<span class="hljs-string">"name"</span>);</span><br><span class="line">                        <span class="hljs-keyword">return</span> object;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我把配置好的 UsernamePasswordAuthenticationFilter 过滤器再拎出来，修改一下用户名的 key（正常来说，修改用户名的 key 不用这么麻烦，这里主要是给大家演示 ObjectPostProcessor 的效果），修改完成后，以后用户登录时，用户名就不是 username 而是 name 了。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好了，只要小伙伴们掌握了上面的用法，以后在 Spring Security 中，如果想修改某一个对象的属性，但是却不知道从哪里下手，那么不妨试试 withObjectPostProcessor！</p><p>小伙伴们如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按理说自己 new 出来的对象和容器是没有关系的，但是在 Spring Security 框架中也 new 了很多对象出来，一样也可以被容器管理，那么它是怎么做到的？&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码第二弹！XML 文件解析流程</title>
    <link href="http://www.javaboy.org/2020/0622/xml.html"/>
    <id>http://www.javaboy.org/2020/0622/xml.html</id>
    <published>2020-06-22T01:27:24.000Z</published>
    <updated>2020-06-30T01:46:44.089Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 源码继续开整！</p><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">上篇文章</a>中，松哥和大家分享了 Spring 中配置文件的加载方式，如果小伙伴们还没看过，一定先看一下，这有助于更好的理解本文，传送门：<a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a>。</p><p><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">上篇文章</a>和大家分享了 Spring 中是如何加载本地配置文件的，如何将加载到的本地配置文件通过一个 InputStream 返回。了解到这一点之后，接下来就是对 InputStream 的解析了。</p><p>本文我们就来看一下整个解析流程是什么样子的。</p><h2 id="1-XmlBeanDefinitionReader"><a href="#1-XmlBeanDefinitionReader" class="headerlink" title="1.XmlBeanDefinitionReader"></a>1.XmlBeanDefinitionReader</h2><p>在<a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">上篇文章</a>中，小伙伴们可以看到，XmlBeanFactory 中加载 XML 文件流的对象是 XmlBeanDefinitionReader，因此关于 XML 的解析我们就从 XmlBeanDefinitionReader 开始讲起。</p><p>先来看一张 XmlBeanDefinitionReader 的继承关系图：</p><p><img src="http://img.itboyhub.com/2020/06/XmlBeanDefinitionReader.png" alt></p><p>这张继承关系图中涉及到了几个接口，我这里和大家说一下：</p><ol><li>BeanDefinitionReader：这个接口主要定义了资源文件的读取并将资源转为 BeanDefinition。</li><li>EnvironmentCapable：这个接口定义了获取 Environment 的方法。</li><li>AbstractBeanDefinitionReader：实现了 BeanDefinitionReader 和 EnvironmentCapable 接口中所定义的方法。同时，AbstractBeanDefinitionReader 中多了一个比较关键的属性叫做 ResourceLoader，ResourceLoader 可以根据给定的资源返回对应的 Resource。</li><li>XmlBeanDefinitionReader 则在 AbstractBeanDefinitionReader 的基础上继续扩展了它的功能。</li></ol><p>这是 XmlBeanDefinitionReader 的继承关系。</p><p>打开 XmlBeanDefinitionReader 的源码，我们发现还有两个关键的对象：</p><ul><li>BeanDefinitionDocumentReader：BeanDefinitionDocumentReader 接口只有一个实现类就是 DefaultBeanDefinitionDocumentReader ，在这里定义了对 Document 对象的读取并将读取到的属性转为 BeanDefinition。</li><li>DocumentLoader：将资源文件转为 Document 对象。</li></ul><blockquote><p>担心有的小伙伴可能不知道 Document 是啥，我这里再稍微说两句。Document 就是 XML 解析时获取到的文档对象，Document 对象代表了一个 XML 文档的模型树，所有的其他 Node 都以一定的顺序包含在 Document 对象之内，排列成一个树状结构，以后对 XML 文档的所有操作都与解析器无关，直接在这个 Document 对象上进行操作即可。主流的 XML 解析方式有 SAX 解析、DOM 解析以及 Pull 解析。如果大家对于 XML 文件解析不熟悉的话，可以自行复习，松哥这里就不再啰嗦了。</p></blockquote><p>好了，了解了 XmlBeanDefinitionReader 的继承关系以及里边定义的两个关键类之后，我们来大概梳理一下 XmlBeanDefinitionReader 的功能：</p><ol><li>首先 XmlBeanDefinitionReader 继承自 AbstractBeanDefinitionReader，利用 AbstractBeanDefinitionReader 中的 ResourceLoader 将配置文件路径转为对应的 Resource。</li><li>接下来，利用 DocumentLoader 将 Resource 转为 Document。</li><li>最后，利用 BeanDefinitionDocumentReader 去解析 Document。</li></ol><p>把这些先搞清楚之后，接下来我们来走流程。</p><h2 id="2-走流程"><a href="#2-走流程" class="headerlink" title="2.走流程"></a>2.走流程</h2><p>不知道还记不记得上篇文章中松哥给出的一个简单案例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    XmlBeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"beans.xml"</span>));</span><br><span class="line">    User user = factory.getBean(User.class);</span><br><span class="line">    System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就跟着 XmlBeanFactory 的构造方法来走一遍。</p><p>先来看 XmlBeanFactory 的构造方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> XmlBeanDefinitionReader reader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(<span class="hljs-keyword">this</span>);</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">XmlBeanFactory</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>(resource, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">XmlBeanFactory</span><span class="hljs-params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(parentBeanFactory);</span><br><span class="line"><span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XmlBeanFactory 的源码很简单，其实它的主要功能都在 DefaultListableBeanFactory 中实现了，松哥后面会专门写一篇文章来介绍 DefaultListableBeanFactory，这里我们先不做过多展开。</p><p>XmlBeanFactory 中定义了 XmlBeanDefinitionReader 用来读取 Resource，默认情况下，parentBeanFactory 为 null，具体的读取操作则是由 XmlBeanDefinitionReader#loadBeanDefinitions 方法提供的，我们来看下该方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"><span class="hljs-keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="hljs-string">"Detected cyclic loading of "</span> + encodedResource + <span class="hljs-string">" - check your import definitions!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">InputSource inputSource = <span class="hljs-keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="hljs-string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="hljs-keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 loadBeanDefinitions 方法中，首先会将传入的 Resource 转为一个 EncodedResource，也就是对传入的资源进行编码，所谓的编码大家不要想的过于复杂，其实就是在将来读取资源的时候添加一个编码格式的参数，具体可以参见 EncodedResource#getReader 方法，因为比较简单，我这里就不贴出来了。</li><li>继续调用另外一个重载的 loadBeanDefinitions 方法，传入编码后的资源。</li><li>首先将当前资源添加到一个 ThreadLocal 中，这样可以避免重复加载。</li><li>将 XML 配置文件的 IO 流转为一个 InputSource 对象，InputSource 是 XML 文件解析的起点，XML 文件解析这块大家自己复习下，松哥就不做过多介绍了。</li><li>如果资源有编码格式，那就给 inputSource 对象也设置上编码格式。</li><li>调用 doLoadBeanDefinitions 方法做进一步的解析操作。</li><li>最后从集合中移除资源。</li></ol><p>在上面第 6 步的时候，调用了 doLoadBeanDefinitions 方法，这个方法要做的事情就是去将资源文件解析成 Document 对象，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="hljs-keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line"><span class="hljs-keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"Line "</span> + ex.getLineNumber() + <span class="hljs-string">" in XML document from "</span> + resource + <span class="hljs-string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"XML document from "</span> + resource + <span class="hljs-string">" is invalid"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line"><span class="hljs-string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就是调用 doLoadDocument 进行资源解析，最终获取到一个 Document 对象。</p><p>我们来看一下 doLoadDocument 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Document <span class="hljs-title">doLoadDocument</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="hljs-keyword">this</span>.errorHandler,</span><br><span class="line">getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里最终调用的是 documentLoader#loadDocument 方法，documentLoader 也就是松哥在第一小节和大家介绍的 DefaultDocumentLoader 对象。</p><p>该方法的调用，一共需要五个参数：</p><ol><li>第一个 InputSource 不用多说，这是要调用的资源文件。</li><li>第二个 EntityResolver 主要是处理文件的验证方式的。</li><li>第三个 ErrorHandler 是一个错误处理器。</li><li>第四个 validationMode 是指 XML 文件的验证模式。</li><li>第五个 namespaceAware 表示是否开启自动感知名称空间。</li></ol><p>具体的调用如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Document <span class="hljs-title">loadDocument</span><span class="hljs-params">(InputSource inputSource, EntityResolver entityResolver,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ErrorHandler errorHandler, <span class="hljs-keyword">int</span> validationMode, <span class="hljs-keyword">boolean</span> namespaceAware)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Using JAXP provider ["</span> + factory.getClass().getName() + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line"><span class="hljs-keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我就不做过多解释了，基本上到了 XML 解析的范畴了。小伙伴们自行复习一下 Java 中 XML 的解析方式。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>本文松哥主要和大家介绍了在 Spring 中，我们如何获取到一个 Document 对象，拿到 Document 对象，接下来解析 Document 对象，获取各种属性，就能定义出 BeanDefinition 了。</p><p>但是如果大家从来没有研究过 Spring 源码，相信本文中可能还有很多让你疑惑的地方，例如 EntityResolver 到底是干嘛用的？ValidationMode 又是啥？那么小伙伴们不要着急，这些东西松哥会在接下来的文章中像大家挨个介绍。</p><p>好啦，今天就先说这么多，如果大家觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 源码继续开整！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解读" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>“看来真的只有自身强大起来，别人才会理你”</title>
    <link href="http://www.javaboy.org/2020/0620/life.html"/>
    <id>http://www.javaboy.org/2020/0620/life.html</id>
    <published>2020-06-20T01:27:09.000Z</published>
    <updated>2020-06-30T01:46:48.129Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个小伙伴发给松哥的，老实说，这话触动我了，我一直想写篇文章说说我的感受。</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/06/20200618104617.png" alt></p><p>松哥微信上加了很多人，已经达到微信的好友上限了，所以每天微信上的消息都有很多，当我要坐下来开始工作或者认认真真码字写文章或者录视频，我就会把手机放一边去，否则不停的有消息来根本就没法工作没法码字，这样带来的一个问题就是消息回复不及时，之前有个小伙伴买视频，因为我回复消息晚了，等我回复的时候发现被对方删好友了：</p><p><img src="http://img.itboyhub.com/2020/06/20200618104353.png" alt></p><p>其实这还算好的，因为我只回复了两个字，损失不大。</p><p>有一次晚上十点多下班后看到有人发的消息咨询 vhr 技术问题，我用手机编辑了一大段消息，点击发送却发现被删除好友了，从那以后，要是有人发送的消息我很晚才看到，我一般就不会直接回复，先发一个 <code>?</code> 确认一下有没有被删好友，然后再看问题。</p><p>老实说，无论是写文章还是录视频还是做开源项目，这只是我的一个业余爱好而已，无论从规模还是从收入都无法上升到主业的高度，当然也无法做到 <code>7*24</code> 小时实时响应。</p><p>不过我觉得大部分小伙伴其实都是理解的，由于回复消息慢而被删好友这种事从 2018 年到现在在我身上也就发生了前面说的这两次。</p><p>回到一开始的问题，发消息的老哥是一个公众号主（这也是我没有被删除好友的原因，我发现公众号主普遍不会主动删人，包括我自己），一开始问我微信群的事情，因为我没有在他期望的时间窗内回复消息，所以悠悠的说了句“看来真的只有自身强大起来，别人才会理你”，看到他的消息后，在确认没有被删好友后，我就赶紧回复了。</p><p>但是这位老哥的话，却让我一直印象深刻。</p><p>因为这个世界就是这样。</p><p>你越有能力，所有资源越向你倾斜，越没有能力，所有人都会躲的远远的。虽然不喜欢，但是不得不承认，生活就是这样，我们唯一能做的，就是不断让自己变得强大。</p><p>我从小生活在农村，上学前班的时候，因为 10 块钱的课本费我就学会了撒谎。学校要补交 10 块钱的课本费，连续好几天老师找到我的时候，我总是告诉老师我忘了跟家里要，实际上学校通知的头一天我就告诉家里了，可是没钱怎么办？我只能自己想办法去搪塞老师。这种时候想有人帮你岂不是做梦，这样的穷光蛋大家巴不得躲的远远的。</p><p>那个时候最喜欢过年，学校会在那个时候发一次奖状（学校也没钱，一年只发一次奖状），拿到奖状后，那是我一年中最昂首挺胸的时刻，长辈的夸奖、小伙伴的羡慕，那真是一年中最高光的时刻，虚荣心在那一刻得到了满足。</p><p>所以我从小就明白要让自己强大，别人才会把你当回事。读书时候的强大就是考试考个好成绩，上个好大学；工作时候的强大，就是赚钱，因为赚钱能力在一定程度上能够体现出这个社会对你的认可。</p><p>我 2015 年大学毕业，女票继续在西安读研，我当时的 offer 有西安的，也有广州深圳的，我后来还是选择了广州钱多的。我可以选择西安的工作，这样就不用和女票异地了，但是我还是去了广州，因为我觉得爱她就应该将更好的自己呈现给她。事实证明我的做法是正确的，今年是和女票在一起的第 9 个年头，中间还有三年异地。</p><p>工作一年的时候，薪水差不多翻了三倍，也攒够了买房上车的钱，果断上车；第二年比较动荡，公司的事比较多，我自己也从 Android 转到 Java（那年年底做了 vhr）；第三年的时候写了一本书（Spring Boot+Vue 全栈开发实战）；第四年开始做公众号、录视频（117篇原创技术文章+200多集视频）；现在是第五年了。</p><p>每年都要搞点事情，心里才会踏实一点。特别是我的第一本书出版之后，有很多意料之外的收获，更加让我坚信，只有自己强大，别人才会把你当回事。</p><p>从小的经历让我没有安全感，没有安全感带来的就是焦虑，大家看我天天在公众号上写文章、录视频，其实这都是焦虑的产物，只有不停的写，我才会感觉到一点点安全，才会感觉到我还没被这个技术日新月异的世界抛弃。</p><p>我们可能会抱怨公司抱怨老板，这个时候想一想，你所遭受的“不公”是否因为自己不够强大导致的？想明白这个，也就知道该怎么做了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个小伙伴发给松哥的，老实说，这话触动我了，我一直想写篇文章说说我的感受。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>花式玩 Spring Boot！过滤器竟有 N 种注册方式！松哥手把手教你</title>
    <link href="http://www.javaboy.org/2020/0619/filter-registry.html"/>
    <id>http://www.javaboy.org/2020/0619/filter-registry.html</id>
    <published>2020-06-19T01:26:55.000Z</published>
    <updated>2020-06-30T01:46:52.986Z</updated>
    
    <content type="html"><![CDATA[<p>要说在 Spring Boot 中注册过滤器有三种方式，你都能想到哪些呢？今天松哥就来和大家聊一聊 Spring Boot 中注册过滤器的三种方式！</p><a id="more"></a><p>其实本来是想和大家聊 Spring Security 过滤器链的问题的，结果看源码看着看着就跑题了，索性就先和大家聊一聊 Spring Boot 中注册过滤器的三种方式，算是给 后面的 Spring Security 打一点基础。</p><h2 id="1-WebFilter"><a href="#1-WebFilter" class="headerlink" title="1.@WebFilter"></a>1.@WebFilter</h2><p>通过 @WebFilter 注解来标记一个过滤器，这种方式相信大家很容易想到。这是将 Servlet 中的那一套东西直接拿到 Spring Boot 上用。</p><p>具体做法就是通过 @WebFilter 注解来标记一个 Filter，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebFilter</span>(urlPatterns = <span class="hljs-string">"/*"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"-----doFilter-----"</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 @WebFilter 注解中可以配置过滤器的拦截规则。这个注解要生效，还需要我们在项目启动类上配置 @ServletComponentScan 注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span></span><br><span class="line"><span class="hljs-meta">@ServletComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterdemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FilterdemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ServletComponentScan 注解虽然名字带了 Servlet，但是实际上它不仅仅可以扫描项目中的 Servlet 容器，也可以扫描 Filter 和 Listener。</p><p>这是我们在 Spring Boot 中使用过滤器的第一种方式，在实际项目中，这种方式使用较少，因为这种方式有一个很大的弊端就是无法指定 Filter 的优先级，如果存在多个 Filter 时，无法通过 @Order 指定优先级。</p><h2 id="2-Bean"><a href="#2-Bean" class="headerlink" title="2.@Bean"></a>2.@Bean</h2><p>第二种方式就是将过滤器配置成 Bean，注册到 Spring 容器中去。这种方法不再需要 @ServletComponentScan 注解，只要一个 Bean 即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"-----doFilter-----"</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式看起来很方便，一个注解将 Filter 纳入到 Spring 容器中即可。而且这种方式还有一个优势，就是如果存在多个 Filter，可以通过 @Order 注解指定多个 Filter 的优先级，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Order</span>(-<span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"-----doFilter-----"</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然解决了优先级问题，但是大家发现这种方式好像没有办法设置 Filter 的拦截规则！是的，直接定义 Bean 的话，默认的拦截规则就是 <code>/*</code> 即拦截所有请求，开发者无法进行自定义配置。</p><p>那么有没有办法即配置拦截规则，又配置优先级呢？接下来介绍的第三种方案可以鱼与熊掌兼得。</p><h2 id="3-FilterRegistrationBean"><a href="#3-FilterRegistrationBean" class="headerlink" title="3.FilterRegistrationBean"></a>3.FilterRegistrationBean</h2><p>第三种方案还是将 Filter 封装成一个 Bean，但这个 Bean 是 FilterRegistrationBean，通过 FilterRegistrationBean 我们既可以配置 Filter 的优先级，也可以配置 Filter 的拦截规则。</p><p>一般在项目中，我们都是使用 FilterRegistrationBean 来配置过滤器，一起来看一个案例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">FilterRegistrationBean&lt;MyFilter&gt; <span class="hljs-title">myFilterFilterRegistrationBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyFilter&gt; bean = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        bean.setFilter(<span class="hljs-keyword">new</span> MyFilter());</span><br><span class="line">        bean.setOrder(-<span class="hljs-number">1</span>);</span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/*"</span>));</span><br><span class="line">        <span class="hljs-keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">FilterRegistrationBean&lt;MyFilter2&gt; <span class="hljs-title">myFilterFilterRegistrationBean2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;MyFilter2&gt; bean = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        bean.setFilter(<span class="hljs-keyword">new</span> MyFilter2());</span><br><span class="line">        bean.setOrder(-<span class="hljs-number">2</span>);</span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/hello"</span>));</span><br><span class="line">        <span class="hljs-keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4.扩展"></a>4.扩展</h2><p>FilterRegistrationBean 到底是什么来头呢？这里也和大家分享下。</p><p>Spring Boot 为了方便大家向 Servlet 容器中注册 Servlet、Filter 以及 Listener，提供了一个 Bean 注册的抽象类 RegistrationBean，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegistrationBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextInitializer</span>, <span class="hljs-title">Ordered</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> order = Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enabled = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">String description = getDescription();</span><br><span class="line"><span class="hljs-keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">logger.info(StringUtils.capitalize(description) + <span class="hljs-string">" was not registered (disabled)"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">register(description, servletContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(String description, ServletContext servletContext)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEnabled</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.enabled = enabled;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.enabled;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> order)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.order = order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>RegistrationBean 实现了 ServletContextInitializer 接口，在 Servlet 启动时，RegistrationBean#onStartup 方法会被调用，进而完成 Filter、Servlet 以及 Listener 的注册。</li><li>enabled 属性可以理解为一个开关，设置为 false 相当于关闭组件注册。</li></ol><p>RegistrationBean 有众多的实现类，我们之前使用的 FilterRegistrationBean 只是其中之一：</p><p><img src="http://img.itboyhub.com/2020/06/RegistrationBean.png" alt></p><p>实现类的作用一目了然：</p><ol><li>ServletListenerRegistrationBean 用来注册监听器。</li><li>ServletRegistrationBean 用来注册 Servlet。</li><li>DispatcherServletRegistrationBean 用来注册 DispatcherServlet。</li><li>FilterRegistrationBean 用来注册过滤器。</li><li>DelegatingFilterProxyRegistrationBean 则用来注册 DelegatingFilterProxy，DelegatingFilterProxy 在 Spring Security、Spring Session、Shiro 等整合时非常有用。</li></ol><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>今天就和小伙伴们分享一下 Spring Boot 中过滤器的三种注册方式，顺带和大家分享了一下 FilterRegistrationBean 的继承体系，小伙伴们可以根据 FilterRegistrationBean 的继承体系中的实现类，自行尝试一下 Servlet 和 Listener 的注册方式～本文案例下载地址：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></p><p>好啦，如果大家觉得有收获的话，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要说在 Spring Boot 中注册过滤器有三种方式，你都能想到哪些呢？今天松哥就来和大家聊一聊 Spring Boot 中注册过滤器的三种方式！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 多种加密方案共存，老破旧系统整合利器！</title>
    <link href="http://www.javaboy.org/2020/0618/passwordencoder.html"/>
    <id>http://www.javaboy.org/2020/0618/passwordencoder.html</id>
    <published>2020-06-18T01:26:40.000Z</published>
    <updated>2020-06-30T01:46:58.229Z</updated>
    
    <content type="html"><![CDATA[<p>关于密码加密的问题，松哥之前已经和大家聊过了，参考：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li></ul><p>这篇文章中，松哥给大家介绍了两种密码加密方案，但是两种都是独立使用的！能不能在同一个项目中同时存在多种密码加密方案呢？答案是肯定的！</p><p>今天松哥就来和大家聊一聊，如何在 Spring Security 中，让多种不同的密码加密方案并存。</p><p>本文是 Spring Security 系列第 31 篇，阅读前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/uWib5RtH1aEC7p5VK4S1Ig" target="_blank" rel="noopener">Spring Boot+CAS 默认登录页面太丑了，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/LvMOKeX09liTvujZi6XO3Q" target="_blank" rel="noopener">用 Swagger 测试接口，怎么在请求头中携带 Token？</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li><li><a href="https://mp.weixin.qq.com/s/7T5XA1zxQkhMvffMxHKVvQ" target="_blank" rel="noopener">Spring Boot 中如何实现 HTTP 认证？</a></li><li><a href="https://mp.weixin.qq.com/s/7cm99q5ZM4qUkekx0Xa0YQ" target="_blank" rel="noopener">Spring Security 中的四种权限控制方式</a></li></ol><p>为什么要加密？常见的加密算法等等这些问题我就不再赘述了，大家可以参考之前的：<a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a>，咱们直接来看今天的正文。</p><h2 id="1-PasswordEncoder"><a href="#1-PasswordEncoder" class="headerlink" title="1.PasswordEncoder"></a>1.PasswordEncoder</h2><p>在 Spring Security 中，跟密码加密/校验相关的事情，都是由 PasswordEncoder 来主导的，PasswordEncoder 拥有众多的实现类：</p><p><img src="http://img.itboyhub.com/2020/05/PasswordEncoder.png" alt></p><p>这些实现类，有的已经过期了，有的用处不大。对于我们而言，最常用的莫过于 BCryptPasswordEncoder。</p><p>PasswordEncoder 本身是一个接口，里边只有三个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">upgradeEncoding</span><span class="hljs-params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>encode 方法用来对密码进行加密。</li><li>matches 方法用来对密码进行比对。</li><li>upgradeEncoding 表示是否需要对密码进行再次加密以使得密码更加安全，默认为 false。</li></ul><p>PasswordEncoder 的实现类，则具体实现了这些方法。</p><h2 id="2-PasswordEncoder-在哪里起作用"><a href="#2-PasswordEncoder-在哪里起作用" class="headerlink" title="2.PasswordEncoder 在哪里起作用"></a>2.PasswordEncoder 在哪里起作用</h2><p>对于我们开发者而言，我们通常都是在 SecurityConfig 中配置一个 PasswordEncoder 的实例，类似下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的事情，都是由系统调用的。今天我们就来揭开系统调用的神秘面纱！我们一起来看下系统到底是怎么调用的！</p><p>首先，松哥在前面的文章中和大家提到过，Spring Security 中，如果使用用户名/密码的方式登录，密码是在 DaoAuthenticationProvider 中进行校验的，大家可以参考：<a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a>。</p><p>我们来看下 DaoAuthenticationProvider 中密码是如何校验的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additionalAuthenticationChecks</span><span class="hljs-params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authentication.getCredentials() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"><span class="hljs-keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，密码校验就是通过 passwordEncoder.matches 方法来完成的。</p><p>那么 DaoAuthenticationProvider 中的 passwordEncoder 从何而来呢？是不是就是我们一开始在 SecurityConfig 中配置的那个 Bean 呢？</p><p>我们来看下 DaoAuthenticationProvider 中关于 passwordEncoder 的定义，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoAuthenticationProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractUserDetailsAuthenticationProvider</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DaoAuthenticationProvider</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">setPasswordEncoder(PasswordEncoderFactories.createDelegatingPasswordEncoder());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPasswordEncoder</span><span class="hljs-params">(PasswordEncoder passwordEncoder)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.passwordEncoder = passwordEncoder;</span><br><span class="line"><span class="hljs-keyword">this</span>.userNotFoundEncodedPassword = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> PasswordEncoder <span class="hljs-title">getPasswordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> passwordEncoder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中可以看到，在 DaoAuthenticationProvider 创建之时，就指定了 PasswordEncoder，似乎并没有用到我们一开始配置的 Bean？其实不是的！在 DaoAuthenticationProvider 创建之时，会制定一个默认的 PasswordEncoder，如果我们没有配置任何 PasswordEncoder，将使用这个默认的 PasswordEncoder，如果我们自定义了 PasswordEncoder 实例，那么会使用我们自定义的 PasswordEncoder 实例！</p><p>从何而知呢？</p><p>我们再来看看 DaoAuthenticationProvider 是怎么初始化的。</p><p>DaoAuthenticationProvider 的初始化是在 InitializeUserDetailsManagerConfigurer#configure 方法中完成的，我们一起来看下该方法的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (auth.isConfigured()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">UserDetailsService userDetailsService = getBeanOrNull(</span><br><span class="line">UserDetailsService.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (userDetailsService == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PasswordEncoder passwordEncoder = getBeanOrNull(PasswordEncoder.class);</span><br><span class="line">UserDetailsPasswordService passwordManager = getBeanOrNull(UserDetailsPasswordService.class);</span><br><span class="line">DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">provider.setUserDetailsService(userDetailsService);</span><br><span class="line"><span class="hljs-keyword">if</span> (passwordEncoder != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">provider.setPasswordEncoder(passwordEncoder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (passwordManager != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">provider.setUserDetailsPasswordService(passwordManager);</span><br><span class="line">&#125;</span><br><span class="line">provider.afterPropertiesSet();</span><br><span class="line">auth.authenticationProvider(provider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中我们可以看到：</p><ol><li>首先去调用 getBeanOrNull 方法获取一个 PasswordEncoder 实例，getBeanOrNull 方法实际上就是去 Spring 容器中查找对象。</li><li>接下来直接 new 一个 DaoAuthenticationProvider 对象，大家知道，在 new 的过程中，DaoAuthenticationProvider 中默认的 PasswordEncoder 已经被创建出来了。</li><li>如果一开始从 Spring 容器中获取到了 PasswordEncoder 实例，则将之赋值给 DaoAuthenticationProvider 实例，否则就是用 DaoAuthenticationProvider 自己默认创建的 PasswordEncoder。</li></ol><p>至此，就真相大白了，我们配置的 PasswordEncoder 实例确实用上了。</p><h2 id="3-默认的是什么？"><a href="#3-默认的是什么？" class="headerlink" title="3.默认的是什么？"></a>3.默认的是什么？</h2><p>同时大家看到，如果我们不进行任何配置，默认的 PasswordEncoder 也会被提供，那么默认的 PasswordEncoder 是什么呢？我们就从这个方法看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DaoAuthenticationProvider</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">setPasswordEncoder(PasswordEncoderFactories.createDelegatingPasswordEncoder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PasswordEncoderFactories</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">createDelegatingPasswordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">String encodingId = <span class="hljs-string">"bcrypt"</span>;</span><br><span class="line">Map&lt;String, PasswordEncoder&gt; encoders = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">encoders.put(encodingId, <span class="hljs-keyword">new</span> BCryptPasswordEncoder());</span><br><span class="line">encoders.put(<span class="hljs-string">"ldap"</span>, <span class="hljs-keyword">new</span> org.springframework.security.crypto.password.LdapShaPasswordEncoder());</span><br><span class="line">encoders.put(<span class="hljs-string">"MD4"</span>, <span class="hljs-keyword">new</span> org.springframework.security.crypto.password.Md4PasswordEncoder());</span><br><span class="line">encoders.put(<span class="hljs-string">"MD5"</span>, <span class="hljs-keyword">new</span> org.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="hljs-string">"MD5"</span>));</span><br><span class="line">encoders.put(<span class="hljs-string">"noop"</span>, org.springframework.security.crypto.password.NoOpPasswordEncoder.getInstance());</span><br><span class="line">encoders.put(<span class="hljs-string">"pbkdf2"</span>, <span class="hljs-keyword">new</span> Pbkdf2PasswordEncoder());</span><br><span class="line">encoders.put(<span class="hljs-string">"scrypt"</span>, <span class="hljs-keyword">new</span> SCryptPasswordEncoder());</span><br><span class="line">encoders.put(<span class="hljs-string">"SHA-1"</span>, <span class="hljs-keyword">new</span> org.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="hljs-string">"SHA-1"</span>));</span><br><span class="line">encoders.put(<span class="hljs-string">"SHA-256"</span>, <span class="hljs-keyword">new</span> org.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="hljs-string">"SHA-256"</span>));</span><br><span class="line">encoders.put(<span class="hljs-string">"sha256"</span>, <span class="hljs-keyword">new</span> org.springframework.security.crypto.password.StandardPasswordEncoder());</span><br><span class="line">encoders.put(<span class="hljs-string">"argon2"</span>, <span class="hljs-keyword">new</span> Argon2PasswordEncoder());</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(encodingId, encoders);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">PasswordEncoderFactories</span><span class="hljs-params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>在 PasswordEncoderFactories 中，首先构建了一个 encoders，然后给所有的编码方式都取了一个名字，再把名字做 key，编码方式做 value，统统存入 encoders 中。</li><li>最后返回了一个 DelegatingPasswordEncoder 实例，同时传入默认的 encodingId 就是 bcrypt，以及 encoders 实例，DelegatingPasswordEncoder 看名字应该是一个代理对象。</li></ol><p>我们来看下 DelegatingPasswordEncoder 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingPasswordEncoder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PREFIX = <span class="hljs-string">"&#123;"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SUFFIX = <span class="hljs-string">"&#125;"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String idForEncode;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PasswordEncoder passwordEncoderForEncode;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, PasswordEncoder&gt; idToPasswordEncoder;</span><br><span class="line"><span class="hljs-keyword">private</span> PasswordEncoder defaultPasswordEncoderForMatches = <span class="hljs-keyword">new</span> UnmappedIdPasswordEncoder();</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelegatingPasswordEncoder</span><span class="hljs-params">(String idForEncode,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Map&lt;String, PasswordEncoder&gt; idToPasswordEncoder)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (idForEncode == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"idForEncode cannot be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!idToPasswordEncoder.containsKey(idForEncode)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"idForEncode "</span> + idForEncode + <span class="hljs-string">"is not found in idToPasswordEncoder "</span> + idToPasswordEncoder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (String id : idToPasswordEncoder.keySet()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (id == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (id.contains(PREFIX)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"id "</span> + id + <span class="hljs-string">" cannot contain "</span> + PREFIX);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (id.contains(SUFFIX)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"id "</span> + id + <span class="hljs-string">" cannot contain "</span> + SUFFIX);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.idForEncode = idForEncode;</span><br><span class="line"><span class="hljs-keyword">this</span>.passwordEncoderForEncode = idToPasswordEncoder.get(idForEncode);</span><br><span class="line"><span class="hljs-keyword">this</span>.idToPasswordEncoder = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(idToPasswordEncoder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDefaultPasswordEncoderForMatches</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">PasswordEncoder defaultPasswordEncoderForMatches)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (defaultPasswordEncoderForMatches == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"defaultPasswordEncoderForMatches cannot be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.defaultPasswordEncoderForMatches = defaultPasswordEncoderForMatches;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> PREFIX + <span class="hljs-keyword">this</span>.idForEncode + SUFFIX + <span class="hljs-keyword">this</span>.passwordEncoderForEncode.encode(rawPassword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String prefixEncodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (rawPassword == <span class="hljs-keyword">null</span> &amp;&amp; prefixEncodedPassword == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">String id = extractId(prefixEncodedPassword);</span><br><span class="line">PasswordEncoder delegate = <span class="hljs-keyword">this</span>.idToPasswordEncoder.get(id);</span><br><span class="line"><span class="hljs-keyword">if</span> (delegate == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultPasswordEncoderForMatches</span><br><span class="line">.matches(rawPassword, prefixEncodedPassword);</span><br><span class="line">&#125;</span><br><span class="line">String encodedPassword = extractEncodedPassword(prefixEncodedPassword);</span><br><span class="line"><span class="hljs-keyword">return</span> delegate.matches(rawPassword, encodedPassword);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">extractId</span><span class="hljs-params">(String prefixEncodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (prefixEncodedPassword == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> start = prefixEncodedPassword.indexOf(PREFIX);</span><br><span class="line"><span class="hljs-keyword">if</span> (start != <span class="hljs-number">0</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> end = prefixEncodedPassword.indexOf(SUFFIX, start);</span><br><span class="line"><span class="hljs-keyword">if</span> (end &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> prefixEncodedPassword.substring(start + <span class="hljs-number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">upgradeEncoding</span><span class="hljs-params">(String prefixEncodedPassword)</span> </span>&#123;</span><br><span class="line">String id = extractId(prefixEncodedPassword);</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.idForEncode.equalsIgnoreCase(id)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">String encodedPassword = extractEncodedPassword(prefixEncodedPassword);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.idToPasswordEncoder.get(id).upgradeEncoding(encodedPassword);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">extractEncodedPassword</span><span class="hljs-params">(String prefixEncodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> start = prefixEncodedPassword.indexOf(SUFFIX);</span><br><span class="line"><span class="hljs-keyword">return</span> prefixEncodedPassword.substring(start + <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnmappedIdPasswordEncoder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"encode is not supported"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">String prefixEncodedPassword)</span> </span>&#123;</span><br><span class="line">String id = extractId(prefixEncodedPassword);</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"There is no PasswordEncoder mapped for the id \""</span> + id + <span class="hljs-string">"\""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码比较长，我来和大家挨个解释下：</p><ol><li>DelegatingPasswordEncoder 也是实现了 PasswordEncoder 接口，所以它里边的核心方法也是两个：encode 方法用来对密码进行编码，matches 方法用来校验密码。</li><li>在 DelegatingPasswordEncoder 的构造方法中，通过 通过传入的两个参数 encodingId 和 encoders ，获取到默认的编码器赋值给 passwordEncoderForEncode，默认的编码器实际上就是 BCryptPasswordEncoder。</li><li>在 encode 方法中对密码进行编码，但是编码的方式加了前缀，前缀是 <code>{编码器名称}</code> ，例如如果你使用 BCryptPasswordEncoder 进行编码，那么生成的密码就类似 <code>{bcrypt}$2a$10$oE39aG10kB/rFu2vQeCJTu/V/v4n6DRR0f8WyXRiAYvBpmadoOBE.</code>。这样有什么用呢？每种密码加密之后，都会加上一个前缀，这样看到前缀，就知道该密文是使用哪个编码器生成的了。</li><li>最后 matches 方法的逻辑就很清晰了，先从密文中提取出来前缀，再根据前缀找到对应的 PasswordEncoder，然后再调用 PasswordEncoder 的 matches 方法进行密码比对。</li><li>如果根据提取出来的前缀，找不到对应的 PasswordEncoder，那么就会调用 UnmappedIdPasswordEncoder#matches 方法，进行密码比对，该方法实际上并不会进行密码比对，而是直接抛出异常。</li></ol><p>OK，至此，相信大家都明白了 DelegatingPasswordEncoder 的工作原理了。</p><p>如果我们想同时使用多个密码加密方案，看来使用 DelegatingPasswordEncoder 就可以了，而 DelegatingPasswordEncoder 默认还不用配置。</p><h2 id="4-体验"><a href="#4-体验" class="headerlink" title="4.体验"></a>4.体验</h2><p>接下来我们稍微体验一下 DelegatingPasswordEncoder 的用法。</p><p>首先我们来生成三个密码作为测试密码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, PasswordEncoder&gt; encoders = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    encoders.put(<span class="hljs-string">"bcrypt"</span>, <span class="hljs-keyword">new</span> BCryptPasswordEncoder());</span><br><span class="line">    encoders.put(<span class="hljs-string">"MD5"</span>, <span class="hljs-keyword">new</span> org.springframework.security.crypto.password.MessageDigestPasswordEncoder(<span class="hljs-string">"MD5"</span>));</span><br><span class="line">    encoders.put(<span class="hljs-string">"noop"</span>, org.springframework.security.crypto.password.NoOpPasswordEncoder.getInstance());</span><br><span class="line">    DelegatingPasswordEncoder encoder1 = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-string">"bcrypt"</span>, encoders);</span><br><span class="line">    DelegatingPasswordEncoder encoder2 = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-string">"MD5"</span>, encoders);</span><br><span class="line">    DelegatingPasswordEncoder encoder3 = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-string">"noop"</span>, encoders);</span><br><span class="line">    String e1 = encoder1.encode(<span class="hljs-string">"123"</span>);</span><br><span class="line">    String e2 = encoder2.encode(<span class="hljs-string">"123"</span>);</span><br><span class="line">    String e3 = encoder3.encode(<span class="hljs-string">"123"</span>);</span><br><span class="line">    System.out.println(<span class="hljs-string">"e1 = "</span> + e1);</span><br><span class="line">    System.out.println(<span class="hljs-string">"e2 = "</span> + e2);</span><br><span class="line">    System.out.println(<span class="hljs-string">"e3 = "</span> + e3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e1 = &#123;bcrypt&#125;$2a$10$Sb1gAUH4wwazfNiqflKZve4Ubh.spJcxgHG8Cp29DeGya5zsHENqi</span><br><span class="line">e2 = &#123;MD5&#125;&#123;Wucj/L8wMTMzFi3oBKWsETNeXbMFaHZW9vCK9mahMHc=&#125;4d43db282b36d7f0421498fdc693f2a2</span><br><span class="line">e3 = &#123;noop&#125;123</span><br></pre></td></tr></table></figure><p>接下来，我们把这三个密码拷贝到 SecurityConfig 中去：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(<span class="hljs-string">"aaa"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;bcrypt&#125;$2a$10$Sb1gAUH4wwazfNiqflKZve4Ubh.spJcxgHG8Cp29DeGya5zsHENqi"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"sang"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"&#123;MD5&#125;&#123;Wucj/L8wMTMzFi3oBKWsETNeXbMFaHZW9vCK9mahMHc=&#125;4d43db282b36d7f0421498fdc693f2a2"</span>).roles(<span class="hljs-string">"user"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里三个用户使用三种不同的密码加密方式。</p><p>配置完成后，重启项目，分别使用 javaboy/123、sang/123 以及 江南一点雨/123 进行登录，发现都能登录成功。</p><h2 id="5-意义何在？"><a href="#5-意义何在？" class="headerlink" title="5.意义何在？"></a>5.意义何在？</h2><p>为什么我们会有这种需求？想在项目种同时存在多种密码加密方案？其实这个主要是针对老旧项目改造用的，密码加密方式一旦确定，基本上没法再改了（你总不能让用户重新注册一次吧），但是我们又想使用最新的框架来做密码加密，那么无疑，DelegatingPasswordEncoder 是最佳选择。</p><p>好啦，这就是今天和小伙伴们分享的多种密码加密方案问题，感兴趣的小伙伴记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于密码加密的问题，松哥之前已经和大家聊过了，参考：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中的四种权限控制方式</title>
    <link href="http://www.javaboy.org/2020/0617/authorize-springsecurity.html"/>
    <id>http://www.javaboy.org/2020/0617/authorize-springsecurity.html</id>
    <published>2020-06-17T01:26:28.000Z</published>
    <updated>2020-06-30T01:47:03.552Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Security 中对于权限控制默认已经提供了很多了，但是，一个优秀的框架必须具备良好的扩展性，恰好，Spring Security 的扩展性就非常棒，我们既可以使用 Spring Security 提供的方式做授权，也可以自定义授权逻辑。一句话，你想怎么玩都可以！</p><a id="more"></a><p>今天松哥来和大家介绍一下 Spring Security 中四种常见的权限控制方式。</p><ul><li>表达式控制 URL 路径权限</li><li>表达式控制方法权限</li><li>使用过滤注解</li><li>动态权限</li></ul><p>四种方式，我们分别来看。</p><p>本文是 Spring Security 系列第 30 篇，阅读前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/uWib5RtH1aEC7p5VK4S1Ig" target="_blank" rel="noopener">Spring Boot+CAS 默认登录页面太丑了，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/LvMOKeX09liTvujZi6XO3Q" target="_blank" rel="noopener">用 Swagger 测试接口，怎么在请求头中携带 Token？</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li><li><a href="https://mp.weixin.qq.com/s/7T5XA1zxQkhMvffMxHKVvQ" target="_blank" rel="noopener">Spring Boot 中如何实现 HTTP 认证？</a></li></ol><h2 id="1-表达式控制-URL-路径权限"><a href="#1-表达式控制-URL-路径权限" class="headerlink" title="1.表达式控制 URL 路径权限"></a>1.表达式控制 URL 路径权限</h2><p>首先我们来看第一种，就是通过表达式控制 URL 路径权限，这种方式松哥在之前的文章中实际上和大家讲过，这里我们再来稍微复习一下。</p><p>Spring Security 支持在 URL 和方法权限控制时使用 SpEL 表达式，如果表达式返回值为 true 则表示需要对应的权限，否则表示不需要对应的权限。提供表达式的类是 SecurityExpressionRoot：</p><p><img src="http://img.itboyhub.com/2020/06/SecurityExpressionRoot.png" alt></p><p>可以看到，SecurityExpressionRoot 有两个实现类，表示在应对 URL 权限控制和应对方法权限控制时，分别对 SpEL 所做的拓展，例如在基于 URL 路径做权限控制时，增加了 hasIpAddress 选项。</p><p>我们来看下 SecurityExpressionRoot 类中定义的最基本的 SpEL 有哪些：</p><p><img src="http://img.itboyhub.com/2020/06/20200608160811.png" alt></p><p>可以看到，这些都是该类对应的表达式，这些表达式我来给大家稍微解释下：</p><table><thead><tr><th style="text-align:left">表达式</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">hasRole</td><td style="text-align:left">用户具备某个角色即可访问资源</td></tr><tr><td style="text-align:left">hasAnyRole</td><td style="text-align:left">用户具备多个角色中的任意一个即可访问资源</td></tr><tr><td style="text-align:left">hasAuthority</td><td style="text-align:left">类似于 hasRole</td></tr><tr><td style="text-align:left">hasAnyAuthority</td><td style="text-align:left">类似于 hasAnyRole</td></tr><tr><td style="text-align:left">permitAll</td><td style="text-align:left">统统允许访问</td></tr><tr><td style="text-align:left">denyAll</td><td style="text-align:left">统统拒绝访问</td></tr><tr><td style="text-align:left">isAnonymous</td><td style="text-align:left">判断是否匿名用户</td></tr><tr><td style="text-align:left">isAuthenticated</td><td style="text-align:left">判断是否认证成功</td></tr><tr><td style="text-align:left">isRememberMe</td><td style="text-align:left">判断是否通过记住我登录的</td></tr><tr><td style="text-align:left">isFullyAuthenticated</td><td style="text-align:left">判断是否用户名/密码登录的</td></tr><tr><td style="text-align:left">principle</td><td style="text-align:left">当前用户</td></tr><tr><td style="text-align:left">authentication</td><td style="text-align:left">从 SecurityContext 中提取出来的用户对象</td></tr></tbody></table><p>这是最基本的，在它的继承类中，还有做一些拓展，我这个我就不重复介绍了。</p><p>如果是通过 URL 进行权限控制，那么我们只需要按照如下方式配置即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/user/**"</span>).hasAnyRole(<span class="hljs-string">"admin"</span>, <span class="hljs-string">"user"</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里表示访问 <code>/admin/**</code> 格式的路径需要 admin 角色，访问 <code>/user/**</code> 格式的路径需要 admin 或者 user 角色。</p><h2 id="2-表达式控制方法权限"><a href="#2-表达式控制方法权限" class="headerlink" title="2.表达式控制方法权限"></a>2.表达式控制方法权限</h2><p>当然，我们也可以通过在方法上添加注解来控制权限。</p><p>在方法上添加注解控制权限，需要我们首先开启注解的使用，在 Spring Security 配置类上添加如下内容：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>,securedEnabled = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置开启了三个注解，分别是：</p><ul><li>@PreAuthorize：方法执行前进行权限检查</li><li>@PostAuthorize：方法执行后进行权限检查</li><li>@Secured：类似于 @PreAuthorize</li></ul><p>这三个结合 SpEL 之后，用法非常灵活，这里和大家稍微分享几个 Demo。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"principal.username.equals('javaboy')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasRole('admin')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Secured</span>(&#123;<span class="hljs-string">"ROLE_user"</span>&#125;)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"#age&gt;98"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> String.valueOf(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一个 hello 方法，注解的约束是，只有当前登录用户名为 javaboy 的用户才可以访问该方法。</li><li>第二个 admin 方法，表示访问该方法的用户必须具备 admin 角色。</li><li>第三个 user 方法，表示方法该方法的用户必须具备 user 角色，但是注意 user 角色需要加上 <code>ROLE_</code> 前缀。</li><li>第四个 getAge 方法，表示访问该方法的 age 参数必须大于 98，否则请求不予通过。</li></ol><p>可以看到，这里的表达式还是非常丰富，如果想引用方法的参数，前面加上一个 <code>#</code> 即可，既可以引用基本类型的参数，也可以引用对象参数。</p><p>缺省对象除了 principal ，还有 authentication（参考第一小节）。</p><h2 id="3-使用过滤注解"><a href="#3-使用过滤注解" class="headerlink" title="3.使用过滤注解"></a>3.使用过滤注解</h2><p>Spring Security 中还有两个过滤函数 @PreFilter 和 @PostFilter，可以根据给出的条件，自动移除集合中的元素。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostFilter</span>(<span class="hljs-string">"filterObject.lastIndexOf('2')!=-1"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getAllUser</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">        users.add(<span class="hljs-string">"javaboy:"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@PreFilter</span>(filterTarget = <span class="hljs-string">"ages"</span>,value = <span class="hljs-string">"filterObject%2==0"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAllAge</span><span class="hljs-params">(List&lt;Integer&gt; ages,List&lt;String&gt; users)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"ages = "</span> + ages);</span><br><span class="line">    System.out.println(<span class="hljs-string">"users = "</span> + users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 getAllUser 方法中，对集合进行过滤，只返回后缀为 2 的元素，filterObject 表示要过滤的元素对象。</li><li>在 getAllAge 方法中，由于有两个集合，因此使用 filterTarget 指定过滤对象。</li></ul><h2 id="4-动态权限"><a href="#4-动态权限" class="headerlink" title="4.动态权限"></a>4.动态权限</h2><p>动态权限主要通过重写拦截器和决策器来实现，这个我在 vhr 的文档中有过详细介绍，大家在公众号【江南一点雨】后台回复 888 可以获取文档，我就不再赘述了。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天就喝小伙伴们稍微聊了一下 Spring Security 中的授权问题，当然这里还有很多细节，后面松哥再和大家一一细聊。</p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Security 中对于权限控制默认已经提供了很多了，但是，一个优秀的框架必须具备良好的扩展性，恰好，Spring Security 的扩展性就非常棒，我们既可以使用 Spring Security 提供的方式做授权，也可以自定义授权逻辑。一句话，你想怎么玩都可以！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中如何实现 HTTP 认证？</title>
    <link href="http://www.javaboy.org/2020/0616/http-springsecurity.html"/>
    <id>http://www.javaboy.org/2020/0616/http-springsecurity.html</id>
    <published>2020-06-16T01:26:15.000Z</published>
    <updated>2020-06-30T01:47:07.590Z</updated>
    
    <content type="html"><![CDATA[<p>HttpBasic 认证有一定的局限性与安全隐患，因此在实际项目中使用并不多，但是，有的时候为了测试方便，开启 HttpBasic 认证能方便很多。</p><a id="more"></a><p>因此松哥今天还是来和大家简单聊一聊 Spring Security 中的 HttpBasic 认证。</p><p>本文是 Spring Security 系列第 29 篇，阅读前面文章有助于更好理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/uWib5RtH1aEC7p5VK4S1Ig" target="_blank" rel="noopener">Spring Boot+CAS 默认登录页面太丑了，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/LvMOKeX09liTvujZi6XO3Q" target="_blank" rel="noopener">用 Swagger 测试接口，怎么在请求头中携带 Token？</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li></ol><h2 id="1-什么是-HttpBasic"><a href="#1-什么是-HttpBasic" class="headerlink" title="1.什么是 HttpBasic"></a>1.什么是 HttpBasic</h2><p>Http Basic 认证是 Web 服务器和客户端之间进行认证的一种方式，最初是在 HTTP1.0 规范（RFC 1945）中定义，后续的有关安全的信息可以在 HTTP 1.1 规范（RFC 2616）和 HTTP 认证规范（RFC 2617）中找到。</p><p>HttpBasic 最大的优势在于使用非常简单，没有复杂的页面交互，只需要在请求头中携带相应的信息就可以认证成功，而且它是一种无状态登录，也就是 session 中并不会记录用户的登录信息。</p><p>HttpBasic 最大的问题在于安全性，因为用户名/密码只是简单的通过 Base64 编码之后就开始传送了，很容易被工具嗅探到，进而暴露用户信息。</p><p>Spring Security 中既支持基本的 HttpBasic 认证，也支持 Http 摘要认证，Http 摘要认证是在 HttpBasic 认证的基础上，提高了信息安全管理，但是代码复杂度也提高了不少，所以 Http 摘要认证使用并不多。</p><p>这里，松哥将和大家分享 Spring Security 中的这两种认证方式。</p><h2 id="2-HttpBasic-认证"><a href="#2-HttpBasic-认证" class="headerlink" title="2.HttpBasic 认证"></a>2.HttpBasic 认证</h2><p>我们先来看实现，再来分析它的认证流程。</p><p>首先创建一个 Spring Boot 项目，引入 Web 和 Spring Security 依赖，如下：</p><p><img src="http://img.itboyhub.com/2020/06/20200603210151.png" alt></p><p>接下来创建一个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再开启 HttpBasic 认证：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再在 application.properties 中配置基本的用户信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.password=123</span><br><span class="line">spring.security.user.name=javaboy</span><br></pre></td></tr></table></figure><p>配置完成后，启动项目，访问 <code>/hello</code> 接口，此时浏览器中会有弹出框，让我们输入用户名/密码信息：</p><p><img src="http://img.itboyhub.com/2020/06/20200603210650.png" alt></p><p>此时我们查看请求响应头，如下：</p><p><img src="http://img.itboyhub.com/2020/06/20200603210753.png" alt></p><p>可以看到，浏览器响应了 401，同时还携带了一个 WWW-Authenticate 响应头，这个是用来描述认证形式的，如果我们使用的是 HttpBasic 认证，默认响应头格式如图所示。</p><p>接下来我们输入用户名密码，点击 Sign In 进行登录，登录成功后，就可以成功访问到 <code>/hello</code> 接口了。</p><p>我们查看第二次的请求，如下：</p><p><img src="http://img.itboyhub.com/2020/06/20200603211746.png" alt></p><p>大家可以看到，在请求头中，多了一个 Authorization 字段，该字段的值为 <code>Basic amF2YWJveToxMjM=</code>，</p><p><code>amF2YWJveToxMjM=</code> 是一个经过 Base64 编码之后的字符串，我们将该字符串解码之后发现，结果如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="hljs-keyword">new</span> String(Base64.getDecoder().decode(<span class="hljs-string">"amF2YWJveToxMjM="</span>), <span class="hljs-string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p>解码结果如下：</p><p><img src="http://img.itboyhub.com/2020/06/20200603213237.png" alt></p><p>可以看到，这就是我们的用户名密码信息。用户名/密码只是经过简单的 Base64 编码之后就开始传递了，所以说，这种认证方式比较危险⚠️。</p><p>我们再来稍微总结一下 HttpBasic 认证的流程：</p><ol><li>浏览器发出请求，说要访问 <code>/hello</code> 接口。</li><li>服务端返回 401，表示未认证。同时在响应头中携带 WWW-Authenticate 字段来描述认证形式。</li><li>浏览器收到 401 响应之后，弹出对话框，要求用户输入用户名/密码，用户输入完用户名/密码之后，浏览器会将之进行 Base64 编码，编码完成后，发送到服务端。</li><li>服务端对浏览器传来的信息进行解码，并校验，当没问题的时候，给客户端作出响应。</li></ol><p>大致的流程就是这样。</p><h2 id="3-Http-摘要认证"><a href="#3-Http-摘要认证" class="headerlink" title="3.Http 摘要认证"></a>3.Http 摘要认证</h2><p>Http 摘要认证与 HttpBasic 认证基本兼容，但是要复杂很多，这个复杂不仅体现在代码上，也体现在请求过程中。</p><p>Http 摘要认证最重要的改进是他不会在网络上发送明文密码。它的整个认证流程是这样的：</p><ol><li>浏览器发出请求，说要访问 <code>/hello</code> 接口。</li><li>服务端返回 401，表示未认证，同时在响应头中携带 WWW-Authenticate 字段来描述认证形式。不同的是，这次服务端会计算出一个随机字符串，一同返回前端，这样可以防止重放攻击（所谓重放攻击就是别人嗅探到你的摘要信息，把摘要当成密码一次次发送服务端，加一个会变化的随机字符串，生成的摘要信息就会变化，就可以防止重放攻击），如下：</li></ol><p><img src="http://img.itboyhub.com/2020/06/20200603234153.png" alt></p><p>同时，服务端返回的字段还有一个 qop，表示保护级别，auth 表示只进行身份验证；auth-int 表示还要校验内容。</p><p>nonce 是服务端生成的随机字符串，这是一个经过 Base64 编码的字符串，经过解码我们发现，它是由过期时间和密钥组成的。在以后的请求中 nonce 会原封不动的再发回给服务端。</p><ol start="3"><li>客户端选择一个算法，根据该算法计算出密码以及其他数据的摘要，如下：</li></ol><p><img src="http://img.itboyhub.com/2020/06/20200603234829.png" alt></p><p>可以看到，客户端发送到服务端的数据比较多。</p><ul><li>nonce 就是服务端发来的随机字符串。</li><li>response 是生成的摘要信息。</li><li>nc 表示请求此时，可以防止重放攻击。</li><li>cnonce 表示客户端发送给服务端的随机字符串。</li></ul><ol start="4"><li>服务端根据客户端发送来的用户名，可以查询出用户密码，再根据用户密码可以计算出摘要信息，再将摘要信息和客户端发送来的摘要信息进行对比，就能确认用户身份。</li></ol><p>这就是整个流程。</p><p><strong>一言以蔽之，原本的用户密码被摘要信息代替了，为了安全，摘要信息会根据服务端返回的随机字符串而发生变化，服务端根据用户密码，同样算出密码的摘要信息，再和客户端传来的摘要信息进行对比，没问题的话，用户就算认证成功了。当然，在此基础上还加了一些过期限制、重放攻击防范机制等。</strong></p><p>好了，那这个在 Spring Security 代码中该怎么实现呢？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(digestAuthenticationEntryPoint())</span><br><span class="line">                .and()</span><br><span class="line">                .addFilter(digestAuthenticationFilter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DigestAuthenticationEntryPoint <span class="hljs-title">digestAuthenticationEntryPoint</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DigestAuthenticationEntryPoint entryPoint = <span class="hljs-keyword">new</span> DigestAuthenticationEntryPoint();</span><br><span class="line">        entryPoint.setKey(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        entryPoint.setRealmName(<span class="hljs-string">"myrealm"</span>);</span><br><span class="line">        entryPoint.setNonceValiditySeconds(<span class="hljs-number">1000</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> entryPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DigestAuthenticationFilter <span class="hljs-title">digestAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DigestAuthenticationFilter filter = <span class="hljs-keyword">new</span> DigestAuthenticationFilter();</span><br><span class="line">        filter.setAuthenticationEntryPoint(digestAuthenticationEntryPoint());</span><br><span class="line">        filter.setUserDetailsService(userDetailsService());</span><br><span class="line">        <span class="hljs-keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置无非就是两方面，一方面是服务端随机字符串的生成，另一方面就是客户端摘要信息的校验。</p><ol><li>首先提供 DigestAuthenticationEntryPoint 的实例，配置服务端随机数生成的一写参数，例如 nonce 有效期（多长时间会变），realm 的名字，以及生成 nonce 时所需要的 key。nonce 的具体生成逻辑在 DigestAuthenticationEntryPoint#commence 方法中：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">HttpServletResponse httpResponse = response;</span><br><span class="line"><span class="hljs-keyword">long</span> expiryTime = System.currentTimeMillis() + (nonceValiditySeconds * <span class="hljs-number">1000</span>);</span><br><span class="line">String signatureValue = DigestAuthUtils.md5Hex(expiryTime + <span class="hljs-string">":"</span> + key);</span><br><span class="line">String nonceValue = expiryTime + <span class="hljs-string">":"</span> + signatureValue;</span><br><span class="line">String nonceValueBase64 = <span class="hljs-keyword">new</span> String(Base64.getEncoder().encode(nonceValue.getBytes()));</span><br><span class="line">String authenticateHeader = <span class="hljs-string">"Digest realm=\""</span> + realmName + <span class="hljs-string">"\", "</span></span><br><span class="line">+ <span class="hljs-string">"qop=\"auth\", nonce=\""</span> + nonceValueBase64 + <span class="hljs-string">"\""</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> NonceExpiredException) &#123;</span><br><span class="line">authenticateHeader = authenticateHeader + <span class="hljs-string">", stale=\"true\""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"WWW-Authenticate header sent to user agent: "</span></span><br><span class="line">+ authenticateHeader);</span><br><span class="line">&#125;</span><br><span class="line">httpResponse.addHeader(<span class="hljs-string">"WWW-Authenticate"</span>, authenticateHeader);</span><br><span class="line">httpResponse.sendError(HttpStatus.UNAUTHORIZED.value(),</span><br><span class="line">HttpStatus.UNAUTHORIZED.getReasonPhrase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，首先获取到过期时间，然后给过期时间和 key 一起计算出消息摘要，再将 nonce 和消息摘要共同作为 value，计算出一个 Base64 编码字符，再将该编码字符写回到前端。</p><ol start="2"><li>配置 DigestAuthenticationFilter 过滤器，主要用来处理前端请求。过滤器的源码比较长，我这里就不贴出来了，一个核心的思路就是从前端拿到用户请求的摘要信息，服务端也根据一直的信息算出来一个摘要，再根据传过来的摘要信息进行比对，进而确认用户身份。</li></ol><p>配置完成后，重启服务端进行测试。</p><p>测试效果其实和 HttpBasic 认证是一样的，所有的变化，只是背后的实现有所变化而已，用户体验是一样的。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>Http 摘要认证的效果虽然比 HttpBasic 安全，但是其实大家看到，整个流程下来解决的安全问题其实还是非常有限。而且代码也麻烦了很多，因此这种认证方式并未广泛流行开来。</p><p>Http 认证小伙伴们作为一个了解即可，里边的有一些思想还是挺有意思的，可以激发我们解决其他问题的思路，例如对于重放攻击的的解决办法，我们如果想自己防御重放攻击，就可以参考这里的实现思路。</p><p>好啦，小伙伴们如果有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HttpBasic 认证有一定的局限性与安全隐患，因此在实际项目中使用并不多，但是，有的时候为了测试方便，开启 HttpBasic 认证能方便很多。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码第一篇开整！配置文件是怎么加载的？</title>
    <link href="http://www.javaboy.org/2020/0615/loadxml.html"/>
    <id>http://www.javaboy.org/2020/0615/loadxml.html</id>
    <published>2020-06-15T01:25:59.000Z</published>
    <updated>2020-06-30T01:47:14.149Z</updated>
    
    <content type="html"><![CDATA[<p>松哥给最近连载的 Spring Security 系列也录制了视频教程，感兴趣的小伙伴请戳这里-&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a>（Spring Boot 第十章就是 Spring Security）。</p><a id="more"></a><p>上周把话撂出来，看起来小伙伴们都挺期待的，其实松哥也迫不及待想要开启一个全新的系列。</p><p>但是目前的 Spring Security 系列还在连载中，还没写完。连载这事，一鼓作气，再而衰三而竭，一定要一次搞定，Spring Security 如果这次放下来，以后就很难再拾起来了。</p><p>所以目前的更新还是 Spring Security 为主，<strong>同时 Spring 源码解读每周至少更新一篇</strong>，等 Spring Security 系列更新完毕后，就开足马力更新 Spring 源码。其实 Spring Security 中也有很多和 Spring 相通的地方，Spring Security 大家文章认真看，松哥不会让大家失望的！</p><h2 id="1-从何说起"><a href="#1-从何说起" class="headerlink" title="1.从何说起"></a>1.从何说起</h2><p>Spring 要从何说起呢？这个问题我考虑了很长时间。</p><p>因为 Spring 源码太繁杂了，一定要选择一个合适的切入点，否则一上来就把各位小伙伴整懵了，那剩下的文章估计就不想看了。</p><p>想了很久之后，我决定就先从配置文件加载讲起，在逐步展开，配置文件加载也是我们在使用 Spring 时遇到的第一个问题，今天就先来说说这个话题。</p><h2 id="2-简单的案例"><a href="#2-简单的案例" class="headerlink" title="2.简单的案例"></a>2.简单的案例</h2><p>先来一个简单的案例，大家感受一下，然后我们顺着案例讲起。</p><p>首先我们创建一个普通的 Maven 项目，引入 spring-beans 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们创建一个实体类，再添加一个简单的配置文件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resources 目录下创建配置文件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.loadxml.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后去加载这个配置文件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    XmlBeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"beans.xml"</span>));</span><br><span class="line">    User user = factory.getBean(User.class);</span><br><span class="line">    System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了展示数据的读取过程，我就先用这个已经过期的 XmlBeanFactory 来加载，这并不影响我们阅读源码。</p><p>上面这个是一个非常简单的 Spring 入门案例，相信很多小伙伴在第一次接触 Spring 的时候，写出来的可能都是这个 Demo。</p><p>在上面这段代码执行过程中，首先要做的事情就是先把 XML 配置文件加载到内存中，再去解析它，再去。。。。。</p><p>一步一步来吧，先来看 XML 文件如何被加入到内存中去。</p><h2 id="3-文件读取"><a href="#3-文件读取" class="headerlink" title="3.文件读取"></a>3.文件读取</h2><p>文件读取在 Spring 中很常见，也算是一个比较基本的功能，而且 Spring 提供的文件加载方式，不仅仅在 Spring 框架中可以使用，我们在项目中有其他文件加载需求也可以使用。</p><p>首先，Spring 中使用 Resource 接口来封装底层资源，Resource 接口本身实现自 InputStreamSource 接口：</p><p><img src="http://img.itboyhub.com/2020/06/InputStreamSource.png" alt></p><p>我们来看下这两个接口的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InputStreamSource</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">InputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Resource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InputStreamSource</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">exists</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReadable</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> exists();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOpen</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFile</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function">URL <span class="hljs-title">getURL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="hljs-function">URI <span class="hljs-title">getURI</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="hljs-function">File <span class="hljs-title">getFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> ReadableByteChannel <span class="hljs-title">readableChannel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Channels.newChannel(getInputStream());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">contentLength</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">lastModified</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="hljs-function">Resource <span class="hljs-title">createRelative</span><span class="hljs-params">(String relativePath)</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getFilename</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码倒不难，我来稍微解释下：</p><ol><li>InputStreamSource 类只提供了一个 getInputStream 方法，该方法返回一个 InputStream，也就是说，InputStreamSource 会将传入的 File 等资源，封装成一个 InputStream 再重新返回。</li><li>Resource 接口实现了 InputStreamSource 接口，并且封装了 Spring 内部可能会用到的底层资源，如 File、URL 以及 classpath 等。</li><li>exists 方法用来判断资源是否存在。</li><li>isReadable 方法用来判断资源是否可读。</li><li>isOpen 方法用来判断资源是否打开。</li><li>isFile 方法用来判断资源是否是一个文件。</li><li>getURL/getURI/getFile/readableChannel 分别表示获取资源对应的 URL/URI/File 以及将资源转为 ReadableByteChannel 通道。</li><li>contentLength 表示获取资源的大小。</li><li>lastModified 表示获取资源的最后修改时间。</li><li>createRelative 表示根据当前资源创建一个相对资源。</li><li>getFilename 表示获取文件名。</li><li>getDescription 表示在资源出错时，详细打印出出错的文件。</li></ol><p>当我们加载不同资源时，对应了 Resource 的不同实现类，来看下 Resource 的继承关系：</p><p><img src="http://img.itboyhub.com/2020/06/Resource.png" alt></p><p>可以看到，针对不同类型的数据源，都有各自的实现，我们这里来重点看下 ClassPathResource 的实现方式。</p><p>ClassPathResource 源码比较长，我这里挑一些关键部分来和大家分享：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassPathResource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFileResolvingResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String path;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> Class&lt;?&gt; clazz;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathResource</span><span class="hljs-params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>(path, (ClassLoader) <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathResource</span><span class="hljs-params">(String path, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">Assert.notNull(path, <span class="hljs-string">"Path must not be null"</span>);</span><br><span class="line">String pathToUse = StringUtils.cleanPath(path);</span><br><span class="line"><span class="hljs-keyword">if</span> (pathToUse.startsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">pathToUse = pathToUse.substring(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.path = pathToUse;</span><br><span class="line"><span class="hljs-keyword">this</span>.classLoader = (classLoader != <span class="hljs-keyword">null</span> ? classLoader : ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathResource</span><span class="hljs-params">(String path, @Nullable Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">Assert.notNull(path, <span class="hljs-string">"Path must not be null"</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.path = StringUtils.cleanPath(path);</span><br><span class="line"><span class="hljs-keyword">this</span>.clazz = clazz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">getPath</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title">getClassLoader</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.clazz != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.clazz.getClassLoader() : <span class="hljs-keyword">this</span>.classLoader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exists</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (resolveURL() != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> URL <span class="hljs-title">resolveURL</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.clazz != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.clazz.getResource(<span class="hljs-keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.classLoader != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.classLoader.getResource(<span class="hljs-keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ClassLoader.getSystemResource(<span class="hljs-keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">InputStream is;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.clazz != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">is = <span class="hljs-keyword">this</span>.clazz.getResourceAsStream(<span class="hljs-keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.classLoader != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">is = <span class="hljs-keyword">this</span>.classLoader.getResourceAsStream(<span class="hljs-keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">is = ClassLoader.getSystemResourceAsStream(<span class="hljs-keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (is == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(getDescription() + <span class="hljs-string">" cannot be opened because it does not exist"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> URL <span class="hljs-title">getURL</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">URL url = resolveURL();</span><br><span class="line"><span class="hljs-keyword">if</span> (url == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FileNotFoundException(getDescription() + <span class="hljs-string">" cannot be resolved to URL because it does not exist"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Resource <span class="hljs-title">createRelative</span><span class="hljs-params">(String relativePath)</span> </span>&#123;</span><br><span class="line">String pathToUse = StringUtils.applyRelativePath(<span class="hljs-keyword">this</span>.path, relativePath);</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.clazz != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> ClassPathResource(pathToUse, <span class="hljs-keyword">this</span>.clazz) :</span><br><span class="line"><span class="hljs-keyword">new</span> ClassPathResource(pathToUse, <span class="hljs-keyword">this</span>.classLoader));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFilename</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> StringUtils.getFilename(<span class="hljs-keyword">this</span>.path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"class path resource ["</span>);</span><br><span class="line">String pathToUse = <span class="hljs-keyword">this</span>.path;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.clazz != <span class="hljs-keyword">null</span> &amp;&amp; !pathToUse.startsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">builder.append(ClassUtils.classPackageAsResourcePath(<span class="hljs-keyword">this</span>.clazz));</span><br><span class="line">builder.append(<span class="hljs-string">'/'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (pathToUse.startsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">pathToUse = pathToUse.substring(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">builder.append(pathToUse);</span><br><span class="line">builder.append(<span class="hljs-string">']'</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，ClassPathResource 的构造方法有四个，一个已经过期的方法我这里没有列出来。另外三个，我们一般调用一个参数的即可，也就是传入文件路径即可，它内部会调用另外一个重载的方法，给 classloader 赋上值（因为在后面要通过 classloader 去读取文件）。</li><li>在 ClassPathResource 初始化的过程中，会先调用 StringUtils.cleanPath 方法对传入的路径进行清理，所谓的路径清理，就是处理路径中的相对地址、Windows 系统下的 \\ 变为 / 等。</li><li>getPath 方法用来返回文件路径，这是一个相对路径，不包含 classpath。</li><li>resolveURL 方法表示返回资源的 URL，返回的时候优先用 Class.getResource 加载，然后才会用 ClassLoader.getResource 加载，关于 Class.getResource 和 ClassLoader.getResource 的区别，又能写一篇文章出来，我这里就大概说下，Class.getResource 最终还是会调用 ClassLoader.getResource，只不过 Class.getResource 会先对路径进行处理。</li><li>getInputStream 读取资源，并返回 InputStream 对象。</li><li>createRelative 方法是根据当前的资源，再创建一个相对资源。</li></ol><p>这是 ClassPathResource，另外一个大家可能会接触到的 FileSystemResource ，小伙伴们可以自行查看其源码，比 ClassPathResource 简单。</p><p>如果不是使用 Spring，我们仅仅想自己加载 resources 目录下的资源，也可以采用这种方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource resource = <span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"beans.xml"</span>);</span><br><span class="line">InputStream inputStream = resource.getInputStream();</span><br></pre></td></tr></table></figure><p>拿到 IO 流之后自行解析即可。</p><p>在 Spring 框架，构造出 Resource 对象之后，接下来还会把 Resource 对象转为 EncodedResource，这里会对资源进行编码处理，编码主要体现在 getReader 方法上，在获取 Reader 对象时，如果有编码，则给出编码格式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Reader <span class="hljs-title">getReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.charset != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">this</span>.resource.getInputStream(), <span class="hljs-keyword">this</span>.charset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.encoding != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">this</span>.resource.getInputStream(), <span class="hljs-keyword">this</span>.encoding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">this</span>.resource.getInputStream());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有这一切搞定之后，接下来就是通过 XmlBeanDefinitionReader 去加载 Resource 了。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天主要和小伙伴们分享一下 Spring 中的资源加载问题，这是容器启动的起点，下篇文章我们来看 XML 文件的解析。</p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥给最近连载的 Spring Security 系列也录制了视频教程，感兴趣的小伙伴请戳这里-&amp;gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot+Vue+微人事视频教程&lt;/a&gt;（Spring Boot 第十章就是 Spring Security）。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解读" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中三种跨域场景总结</title>
    <link href="http://www.javaboy.org/2020/0611/cors-springsecurity.html"/>
    <id>http://www.javaboy.org/2020/0611/cors-springsecurity.html</id>
    <published>2020-06-11T01:25:00.000Z</published>
    <updated>2020-06-30T01:47:23.678Z</updated>
    
    <content type="html"><![CDATA[<p>跨域这个问题松哥之前写过文章，但是最近收到小伙伴们的一些问题，让我发现之前的总结不够全面，因此打算再写一篇文章，来和大家分享一下 Spring Boot 中的跨域问题。</p><a id="more"></a><p>这次我把 Spring Boot 中的跨域问题分为了三个场景：</p><ul><li>普通跨域</li><li>Spring Security 跨域</li><li>OAuth2 跨域</li></ul><p>分为三种并非多此一举，主要是因为这三种场景的配置都不太一样，而这三种场景又都是非常常见的场景，所以这里和大家再来专门分享下。</p><h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1.什么是跨域"></a>1.什么是跨域</h2><p>很多人对跨域有一种误解，以为这是前端的事，和后端没关系，其实不是这样的，说到跨域，就不得不说说浏览器的同源策略。</p><p>同源策略是由 Netscape 提出的一个著名的安全策略，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略。所谓同源是指协议、域名以及端口要相同。</p><p>同源策略是基于安全方面的考虑提出来的，这个策略本身没问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求，传统的跨域方案是 JSONP，JSONP 虽然能解决跨域但是有一个很大的局限性，那就是只支持 GET 请求，不支持其他类型的请求，在 RESTful 时代这几乎就没什么用。</p><p>而今天我们说的 CORS（跨域源资源共享）（CORS，Cross-origin resource sharing）是一个 W3C 标准，它是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是 JSONP 模式的现代版。</p><p>在 Spring 框架中，对于 CORS 也提供了相应的解决方案，在 Spring Boot 中，这一方案得倒了简化，无论是单纯的跨域，还是结合 Spring Security 之后的跨域，都变得非常容易了。</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>首先创建两个普通的 Spring Boot 项目，这个就不用我多说，第一个命名为 provider 提供服务，第二个命名为 consumer 消费服务，第一个配置端口为 8080，第二个配置配置为 8081，然后在 provider 上提供两个 hello 接口，一个 get，一个 post，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"post hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 consumer 的 resources/static 目录下创建一个 html 文件，发送一个简单的 ajax 请求，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"btnClick()"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"get_button"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"btnClick2()"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"post_button"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">btnClick</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">        $.<span class="hljs-keyword">get</span>('http://localhost:8080/hello', function (msg) &#123;</span></span><br><span class="line"><span class="hljs-javascript">            $(<span class="hljs-string">"#app"</span>).html(msg);</span></span><br><span class="line"><span class="hljs-undefined">        &#125;);</span></span><br><span class="line"><span class="hljs-undefined">    &#125;</span></span><br><span class="line"><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">btnClick2</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">        $.post(<span class="hljs-string">'http://localhost:8080/hello'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">            $(<span class="hljs-string">"#app"</span>).html(msg);</span></span><br><span class="line"><span class="hljs-undefined">        &#125;);</span></span><br><span class="line"><span class="hljs-undefined">    &#125;</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后分别启动两个项目，发送请求按钮，观察浏览器控制台如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &apos;http://localhost:8080/hello&apos; from origin &apos;http://localhost:8081&apos; has been blocked by CORS policy: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>可以看到，由于同源策略的限制，请求无法发送成功。</p><p>使用 CORS 可以在前端代码不做任何修改的情况下，实现跨域，那么接下来看看在 provider 中如何配置。首先可以通过 <code>@CrossOrigin</code> 注解配置某一个方法接受某一个域的请求，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@CrossOrigin</span>(value = <span class="hljs-string">"http://localhost:8081"</span>)</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@CrossOrigin</span>(value = <span class="hljs-string">"http://localhost:8081"</span>)</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"post hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解表示这两个接口接受来自 <code>http://localhost:8081</code> 地址的请求，配置完成后，重启 provider ，再次发送请求，浏览器控制台就不会报错了，consumer 也能拿到数据了。</p><p>此时观察浏览器请求网络控制台，可以看到响应头中多了如下信息：</p><p><img src="http://img.itboyhub.com/2020/06/20200602175129.png" alt></p><p>这个表示服务端愿意接收来自 <code>http://localhost:8081</code> 的请求，拿到这个信息后，浏览器就不会再去限制本次请求的跨域了。</p><p>provider 上，每一个方法上都去加注解未免太麻烦了，有的小伙伴想到可以讲注解直接加在 Controller 上，不过每个 Controller 都要加还是麻烦，在 Spring Boot 中，还可以通过全局配置一次性解决这个问题，全局配置只需要在 SpringMVC 的配置类中重写 addCorsMappings 方法即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="hljs-string">"/**"</span>)</span><br><span class="line">        .allowedOrigins(<span class="hljs-string">"http://localhost:8081"</span>)</span><br><span class="line">        .allowedMethods(<span class="hljs-string">"*"</span>)</span><br><span class="line">        .allowedHeaders(<span class="hljs-string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/**</code> 表示本应用的所有方法都会去处理跨域请求，allowedMethods 表示允许通过的请求数，allowedHeaders 则表示允许的请求头。经过这样的配置之后，就不必在每个方法上单独配置跨域了。</p><h3 id="2-1-存在的问题"><a href="#2-1-存在的问题" class="headerlink" title="2.1 存在的问题"></a>2.1 存在的问题</h3><p>了解了整个 CORS 的工作过程之后，我们通过 Ajax 发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是 CSRF（Cross-site request forgery）跨站请求伪造。跨站请求伪造也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p><p>关于 CSRF 攻击的具体介绍和防御办法，大家可以参考松哥之前的文章，这里就不重复介绍了：</p><ul><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li></ul><h2 id="3-SpringSecurity"><a href="#3-SpringSecurity" class="headerlink" title="3.SpringSecurity"></a>3.SpringSecurity</h2><p>如果使用了 Spring Security，上面的跨域配置会失效，因为请求被 Spring Security 拦截了。</p><p>当引入了 Spring Security 的时候，我们有两种办法开启 Spring Security 对跨域的支持。</p><h3 id="3-1-方式一"><a href="#3-1-方式一" class="headerlink" title="3.1 方式一"></a>3.1 方式一</h3><p>方式一就是在上一小节的基础上，添加 Spring Security 对于 CORS 的支持，只需要添加如下配置即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .cors()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 <code>.cors</code> 就开启了 Spring Security 对 CORS 的支持。</p><h3 id="3-2-方式二"><a href="#3-2-方式二" class="headerlink" title="3.2 方式二"></a>3.2 方式二</h3><p>方式二则是去除第二小节的跨域配置，直接在 Spring Security 中做全局配置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .cors()</span><br><span class="line">                .configurationSource(corsConfigurationSource())</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">CorsConfigurationSource <span class="hljs-title">corsConfigurationSource</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration configuration = <span class="hljs-keyword">new</span> CorsConfiguration();</span><br><span class="line">        configuration.setAllowCredentials(<span class="hljs-keyword">true</span>);</span><br><span class="line">        configuration.setAllowedOrigins(Arrays.asList(<span class="hljs-string">"*"</span>));</span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="hljs-string">"*"</span>));</span><br><span class="line">        configuration.setAllowedHeaders(Arrays.asList(<span class="hljs-string">"*"</span>));</span><br><span class="line">        configuration.setMaxAge(Duration.ofHours(<span class="hljs-number">1</span>));</span><br><span class="line">        source.registerCorsConfiguration(<span class="hljs-string">"/**"</span>,configuration);</span><br><span class="line">        <span class="hljs-keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 CorsConfigurationSource 实例对跨域信息作出详细配置，例如允许的请求来源、允许的请求方法、允许通过的请求头、探测请求的有效期、需要处理的路径等等。</p><p><strong>使用这种方式就可以去掉第二小节的跨域配置了。</strong></p><h2 id="4-OAuth2"><a href="#4-OAuth2" class="headerlink" title="4.OAuth2"></a>4.OAuth2</h2><p>还有一种情况就是 OAuth2 允许跨域，如果用户要访问 OAuth2 端点，例如 <code>/oauth/token</code> ，出现了跨域该怎么配置呢？</p><p>这个解决方案松哥在之前的 【<a href>用 Swagger 测试接口，怎么在请求头中携带 Token？</a>】 一文中已经有过介绍，主要是配置一个 CorsFilter，大家可以参考该篇文章，我这里就把核心配置类列出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="hljs-keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="hljs-keyword">true</span>);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="hljs-string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="hljs-string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="hljs-string">"*"</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 SecurityConfig 中开启跨域支持：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .requestMatchers().antMatchers(HttpMethod.OPTIONS, <span class="hljs-string">"/oauth/**"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable().formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .cors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天主要和小伙伴们总结了一下 Spring Boot 中三种跨域的场景，不知道大家有没有 GET 到呢？如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域这个问题松哥之前写过文章，但是最近收到小伙伴们的一些问题，让我发现之前的总结不够全面，因此打算再写一篇文章，来和大家分享一下 Spring Boot 中的跨域问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码解读计划</title>
    <link href="http://www.javaboy.org/2020/0610/spring-source-code.html"/>
    <id>http://www.javaboy.org/2020/0610/spring-source-code.html</id>
    <published>2020-06-10T01:24:47.000Z</published>
    <updated>2020-06-30T01:47:28.729Z</updated>
    
    <content type="html"><![CDATA[<p>松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><a id="more"></a><p>来看今天的正文。</p><p>前面松哥说最近有出免费视频的计划，在免费视频的第三阶段，我将来和大家聊一聊 Spring 的源码（<a href="https://mp.weixin.qq.com/s/aj9Bt1TE1pb8ZPVCpDKI8A" target="_blank" rel="noopener">我为什么要出一套免费视频教程</a>）。</p><p>SSM 作为 Java 开发领域的经典框架组合，作为一个有追求的技术人，都是有必要认真去走一遍 Spring 源码的，搞懂 Spring 源码，不仅仅是为了掌握 Spring，也是为了学习其中优秀的设计思想。</p><p>可以这么说，如果你看懂了 Spring 源码，再去看 MyBatis、Spring Security 源码，你会发现这些源码都非常容易，稍微瞅几眼就懂了。</p><p>然而源码的学习是一个枯燥的过程，源码解读也是一个枯燥的过程，但是一旦你把源码搞懂了，技术上的提升也绝对是肉眼可见的，所以，去折腾一下源码绝对是有必要的，这也是你和同行拉开差距的方式之一。</p><p>松哥自己在 Spring 源码这块前前后后也折腾了很久了，有一些心得一直想和大家分享，但却总下不了决心，因为现在已经很忙了，再加塞一个任务进来，怕是吃不消，但是很多时候，我们总得逼自己一把，才能成长，不能总是躺在舒适区。于是下定决心，这次一定要把 Spring 源码解析的视频录出来。</p><p>然而视频录制是一个非常费时费力的事情，有的人可能不太理解为什么视频会更加费时间，松哥来给大家举几个例子：</p><ol><li>视频的案例，需要提前准备，不是讲的时候边讲边写，那样是不负责任的，对自己不负责，对读者也不负责。录视频和写博客一样，案例都是要先经过设计的：<code>这个知识点，我用一个什么样的 Demo 才能让读者更好的理解它？</code></li><li>视频可能还需要准备一个配套的文档，文档的撰写跟写博客一样，得不少时间。</li><li>视频录完之后，一般都要二次处理一下，去噪音等等，二次处理耗时和计算机性能有很大关系，这也是一个耗时操作。</li></ol><p>所以要把一个自己懂的东西讲出来，同时还要让听讲的人听懂，这并非一件容易的事情。</p><p>松哥思来想去，决定在视频开始录制之前，先出一系列源码解读的文章，通过图文的形式先带领大家进入 Spring 源码的世界，然后再抽时间录视频，这样感觉更稳一些。</p><p>所以今天这篇文章，我主要和大家说一下我的 Spring 源码解读计划，大概从哪几个方面入手。</p><h2 id="1-Spring-架构"><a href="#1-Spring-架构" class="headerlink" title="1.Spring 架构"></a>1.Spring 架构</h2><p>先来看一张 Spring 整体架构图：</p><p><img src="http://img.itboyhub.com/2020/06/2020-06-07-19-42-07.png" alt></p><p>从这张图中，我们可以看到，Spring Framework 中包含的东西还是非常多的，虽然东西很多，但是主次其实很明显。</p><p>我们在学习 Spring 的时候，有两个非常重要的地方：</p><ol><li>Core Container</li><li>AOP</li></ol><p>这两个是核心，也是我们到时候源码分析的重点，其他的 Data Access 、Web 等，基本都是以这两个为基础扩展出来的功能。</p><p>我来给大家挨个介绍一下。</p><h2 id="2-Spring-模块"><a href="#2-Spring-模块" class="headerlink" title="2.Spring 模块"></a>2.Spring 模块</h2><h3 id="2-1-Core-Container"><a href="#2-1-Core-Container" class="headerlink" title="2.1 Core Container"></a>2.1 Core Container</h3><p>Core Container 是 Spring 容器的核心模块，里边主要包含四个模块：Beans、Core、Context 以及 Expression Language，我们所熟知的 IoC/DI 就是由 Beans 和 Core 来提供。</p><p>我来分别介绍一下这几个模块的作用。</p><ul><li>Core：这个是 Spring 的核心模块，它里边主要是 Spring 框架的一些基础工具类，比如一些序列化工具、类型转换器、我们常用的优先级注解等等，都是它提供的。</li><li>Beans：Beans 就没啥好说的，我们所熟知的 IoC/DI 就是由它提供的。</li><li>Context：Context 虽然不像前两个模块那么基础，因为它是基于 Core 和 Beans 构建的，但是 Context 也是我们在 Web 项目中必不可少的工具，资源加载、Event 等等都需要 Context。</li><li>Expression Language：SpEL 虽然归类于 Core Container，但是在目前前后端分离的背景下，其实 SpEL 的使用场景大大缩水。SpEL 是一个支持查询并在运行时可以操纵一个对象图的表达式语言，它的语法类似于统一 EL，但提供了更多的功能，而且它可以独立使用。</li></ul><h3 id="2-2-AOP"><a href="#2-2-AOP" class="headerlink" title="2.2 AOP"></a>2.2 AOP</h3><p>AOP 也是 Spring 中一个非常重要的功能模块，其实小伙伴们从平时的面试中应该就能感觉出来 AOP 的分量，可以说，如果没有 AOP，你就见不到 Spring 中很多令人惊叹的功能。像我们熟知的 Spring 中的事务管理，就离不开 Spring AOP。关于 AOP 的更多介绍，大家可以参考已经录制的 【Spring 基础篇】的视频，我就不再赘述。</p><h3 id="2-3-Data-Access"><a href="#2-3-Data-Access" class="headerlink" title="2.3 Data Access"></a>2.3 Data Access</h3><p>Data Access 模块中，主要是封装了一些数据库持久化相关的操作。比如 JDBC、ORM、OXM、JMS 以及事务。</p><ul><li>JDBC：这个是对传统的 JDBC 的封装，传统的 JDBC 里边有很多冗余代码，Spring 利用自身特性对其进行封装，简化了数据库访问。</li><li>ORM：ORM 为我们常见的 ORM 框架（如 Hibernate、MyBatis 等）提供了一个交互层。</li><li>OXM：OXM 模块抽象了对象和 XML 之间的转换，O 是 Object，X 是 XML。</li><li>JMS：JMS 主要是对消息中间件的消息发送/消费提供封装。</li></ul><h3 id="2-4-Web"><a href="#2-4-Web" class="headerlink" title="2.4 Web"></a>2.4 Web</h3><p>Web 模块里边包含几个部分，不过对于我们而言，使用更多的是 webmvc，也就是我们常说的 SpringMVC。</p><p>Web 主要包含如下模块：</p><ul><li>Web：提供基础的 Web 功能，构建 Web 上下文、提供文件上传等功能。</li><li>WebMVC：提供 MVC 支持。</li><li>其他一些冷门的模块我就不多做介绍了。</li></ul><h3 id="2-5-Test"><a href="#2-5-Test" class="headerlink" title="2.5 Test"></a>2.5 Test</h3><p>对测试功能提供支持。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，今天就先和大家稍微聊一下 Spring 中的各个模块，接下来松哥将按照本文的顺序和大家逐步剖析 Spring 源码，其中 Ioc/DI、AOP 将是分析的重点。</p><p>欢迎大家保持关注～喜欢的话，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&amp;gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot+Vue+微人事视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解读" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>用 Swagger 测试接口，怎么在请求头中携带 Token？</title>
    <link href="http://www.javaboy.org/2020/0609/swagger-springsecurity.html"/>
    <id>http://www.javaboy.org/2020/0609/swagger-springsecurity.html</id>
    <published>2020-06-09T01:24:19.000Z</published>
    <updated>2020-06-30T01:47:34.197Z</updated>
    
    <content type="html"><![CDATA[<p>松哥周末抽空给 Spring Security 系列也录制了一套视频，目录如下：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/05/springboot/20200531234416.png" alt></p><p>感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><p>来自一个小伙伴在微信上的提问：</p><p><img src="http://img.itboyhub.com/2020/05/springboot/20200601154945.png" alt></p><p>看到这个问题，松哥忽然想到我自己之前写过 Spring Boot+Swagger 的用法：</p><ul><li><a href="https://mp.weixin.qq.com/s/7cgHqmtynaxctPakq7RLcg" target="_blank" rel="noopener">SpringBoot 整合 Swagger2</a></li></ul><p>也写过 OAuth2 + Jwt 的用法：</p><ul><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li></ul><p>但是还没有将这两个结合在一起写过，所以小伙伴们对此有了疑问，想一想这还是一个非常常见的问题，因为现在使用令牌登录的场景越来越多，在这种情况下，如果使用 Swagger 来测试接口，要怎么在请求头中携带 Token 呢？今天松哥就来和大家聊一聊。</p><h2 id="1-项目规划"><a href="#1-项目规划" class="headerlink" title="1.项目规划"></a>1.项目规划</h2><p>如果小伙伴们没有看过松哥之前发的 OAuth2 系列文章，建议一定先看下（公众号江南一点雨后台回复 OAuth2 获取），再来看本文内容，否则接下来的内容可能会犯迷糊。</p><p>这里松哥搭建一个 OAuth2+JWT 的环境来做演示。一共搭建两个服务：</p><table><thead><tr><th style="text-align:left">服务名</th><th style="text-align:left">端口</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">auth-server</td><td style="text-align:left">8080</td><td style="text-align:left">授权服务器</td></tr><tr><td style="text-align:left">user-server</td><td style="text-align:left">8081</td><td style="text-align:left">资源服务器</td></tr></tbody></table><p>我稍微解释一下：</p><ul><li>auth-server 就是我的资源服务器，用来颁发 JWT 令牌。</li><li>user-server 则是资源服务器，访问 user-server 上的资源，都需要携带令牌才能访问。</li><li>swagger 则用来给 user-server 上的接口生成文档。</li></ul><p>OK，这是我们项目的一个大致规划。</p><h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h2><p>接下来我们来搭建 OAuth2 测试环境。</p><h3 id="2-1-授权服务器搭建"><a href="#2-1-授权服务器搭建" class="headerlink" title="2.1 授权服务器搭建"></a>2.1 授权服务器搭建</h3><p>首先我们搭建一个名为 auth-server 的授权服务，搭建的时候，选择如下三个依赖：</p><ul><li>Web</li><li>Spring Cloud Security</li><li>Spirng Cloud OAuth2</li></ul><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建完成后，首先提供一个 Spring Security 的基本配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable().formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，为了代码简洁，我就不把 Spring Security 用户存到数据库中去了，直接存在内存中。</p><p>这里我创建了一个名为 sang 的用户，密码是 123，角色是 admin。同时我还配置了一个表单登录。</p><p>这段配置的目的，实际上就是配置用户。例如你想用微信登录第三方网站，在这个过程中，你得先登录微信，登录微信就要你的用户名/密码信息，那么我们在这里配置的，其实就是用户的用户名/密码/角色信息。</p><p><strong>需要注意的是，在当前案例中，我将采用 OAuth2 中的 password 模式进行登录，因此这里还需要明确的提供一个 AuthenticationManager 的 Bean。</strong></p><p>基本的用户信息配置完成后，接下来我们来配置授权服务器。</p><p>首先来配置 TokenStore：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessTokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        converter.setSigningKey(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>TokenStore 我们使用 JwtTokenStore 这个实例。使用了 JWT，access_token 实际上就不用存储了（无状态登录，服务端不需要保存信息），因为用户的所有信息都在 jwt 里边，所以这里配置的 JwtTokenStore 本质上并不是做存储。</li><li>另外我们还提供了一个 JwtAccessTokenConverter，这个 JwtAccessTokenConverter 可以实现将用户信息和 JWT 进行转换（将用户信息转为 jwt 字符串，或者从 jwt 字符串提取出用户信息）。</li><li>另外，在 JWT 字符串生成的时候，我们需要一个签名，这个签名需要自己保存好。</li></ol><p>接下来对授权服务器进行详细配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    ClientDetailsService clientDetailsService;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    PasswordEncoder passwordEncoder;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthorizationServerTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DefaultTokenServices services = <span class="hljs-keyword">new</span> DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(<span class="hljs-keyword">true</span>);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">2</span>);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>);</span><br><span class="line">        TokenEnhancerChain tokenEnhancerChain = <span class="hljs-keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtAccessTokenConverter));</span><br><span class="line">        services.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        security.allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .secret(passwordEncoder.encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .resourceIds(<span class="hljs-string">"res1"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="hljs-string">"password"</span>, <span class="hljs-string">"refresh_token"</span>)</span><br><span class="line">                .scopes(<span class="hljs-string">"all"</span>)</span><br><span class="line">                .redirectUris(<span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints</span><br><span class="line">                .authenticationManager(authenticationManager)</span><br><span class="line">                .tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有点长，我来给大家挨个解释：</p><ol><li>创建 AuthorizationServer 类继承自 AuthorizationServerConfigurerAdapter，来对授权服务器做进一步的详细配置，AuthorizationServer 类记得加上 @EnableAuthorizationServer 注解，表示开启授权服务器的自动化配置。</li><li>在 AuthorizationServer 类中，我们其实主要重写三个 configure 方法。</li><li>AuthorizationServerSecurityConfigurer 用来配置令牌端点的安全约束，也就是这个端点谁能访问，谁不能访问。</li><li>ClientDetailsServiceConfigurer 用来配置客户端的详细信息，在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">之前文章</a>中，松哥和大家讲过，授权服务器要做两方面的检验，一方面是校验客户端，另一方面则是校验用户，校验用户，我们前面已经配置了，这里就是配置校验客户端。客户端的信息我们可以存在数据库中，这其实也是比较容易的，和用户信息存到数据库中类似，但是这里为了简化代码，我还是将客户端信息存在内存中，这里我们分别配置了客户端的 id，secret、资源 id、授权类型、授权范围以及重定向 uri。授权类型我在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">之前文章</a>中和大家一共讲了四种，四种之中不包含 refresh_token 这种类型，但是在实际操作中，refresh_token 也被算作一种。</li><li>AuthorizationServerEndpointsConfigurer 这里用来配置令牌的访问端点和令牌服务。</li><li>tokenServices 这个 Bean 主要用来配置 Token 的一些基本信息，例如 Token 是否支持刷新、Token 的存储位置、Token 的有效期以及刷新 Token 的有效期等等。Token 有效期这个好理解，刷新 Token 的有效期我说一下，当 Token 快要过期的时候，我们需要获取一个新的 Token，在获取新的 Token 时候，需要有一个凭证信息，这个凭证信息不是旧的 Token，而是另外一个 refresh_token，这个 refresh_token 也是有有效期的。</li></ol><p>好了，如此之后，我们的授权服务器就算是配置完成了，接下来我们启动授权服务器。</p><p><strong>如果小伙伴们对于上面的配置感到迷糊，可以在公众号后台回复 OAuth2，先系统的学习一下松哥的 OAuth2 教程。</strong></p><h3 id="2-2-资源服务器搭建"><a href="#2-2-资源服务器搭建" class="headerlink" title="2.2 资源服务器搭建"></a>2.2 资源服务器搭建</h3><p>接下来我们搭建一个资源服务器。大家网上看到的例子，资源服务器大多都是和授权服务器放在一起的，如果项目比较小的话，这样做是没问题的，但是如果是一个大项目，这种做法就不合适了。</p><p>资源服务器就是用来存放用户的资源，例如你在微信上的图像、openid 等信息，用户从授权服务器上拿到 access_token 之后，接下来就可以通过 access_token 来资源服务器请求数据。</p><p>我们创建一个新的 Spring Boot 项目，叫做 user-server ，作为我们的资源服务器，创建时，添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建成功之后，先把前面的 AccessTokenConfig 拷贝到资源服务器上，然后添加如下配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(<span class="hljs-string">"res1"</span>).tokenStore(tokenStore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置代码很简单，我简单的说一下：</p><ol><li>首先在 configure 方法中配置资源 ID 和 TokenStore，这里配置好之后，会自动调用 JwtAccessTokenConverter 将 jwt 解析出来，jwt 里边就包含了用户的基本信息，所以就不用远程校验 access_token 了。</li><li>最后配置一下资源的拦截规则，这就是 Spring Security 中的基本写法，我就不再赘述。</li></ol><p>接下来我们再来配置两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此之后，我们的资源服务器就算配置成功了。</p><h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h3><p>分别启动授权服务器和资源服务器，先访问授权服务器获取 access_token：</p><p><img src="http://img.itboyhub.com/2020/05/springboot/20200601180037.png" alt></p><p>再利用拿到的 access_token 去访问资源服务器：</p><p><img src="http://img.itboyhub.com/2020/05/springboot/20200601180137.png" alt></p><p>OK，测试没问题。</p><h2 id="3-整合-Swagger"><a href="#3-整合-Swagger" class="headerlink" title="3.整合 Swagger"></a>3.整合 Swagger</h2><p>接下来，我们在 user-server 中加入 swagger 功能，首先我们加入 swagger 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里加入的依赖有两个，一个用来生成接口数据，另一个 swagger-ui 用来做数据展示。</p><h3 id="3-1-认证方式一"><a href="#3-1-认证方式一" class="headerlink" title="3.1 认证方式一"></a>3.1 认证方式一</h3><p>请求头加参数，这里给大家介绍两种，先来看第一种。</p><p>先配置一个 Docket 实例，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableSwagger</span>2</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Config</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"org.javaboy.oauth2.res.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .securityContexts(Arrays.asList(securityContexts()))</span><br><span class="line">                .securitySchemes(Arrays.asList(securitySchemes()))</span><br><span class="line">                .apiInfo(<span class="hljs-keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                        .description(<span class="hljs-string">"接口文档的描述信息"</span>)</span><br><span class="line">                        .title(<span class="hljs-string">"微人事项目接口文档"</span>)</span><br><span class="line">                        .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"javaboy"</span>,<span class="hljs-string">"http://www.javaboy.org"</span>,<span class="hljs-string">"wangsong0210@gmail.com"</span>))</span><br><span class="line">                        .version(<span class="hljs-string">"v1.0"</span>)</span><br><span class="line">                        .license(<span class="hljs-string">"Apache2.0"</span>)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> SecurityScheme <span class="hljs-title">securitySchemes</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApiKey(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"header"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> SecurityContext <span class="hljs-title">securityContexts</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> SecurityContext.builder()</span><br><span class="line">                        .securityReferences(defaultAuth())</span><br><span class="line">                        .forPaths(PathSelectors.any())</span><br><span class="line">                        .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;SecurityReference&gt; <span class="hljs-title">defaultAuth</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        AuthorizationScope authorizationScope = <span class="hljs-keyword">new</span> AuthorizationScope(<span class="hljs-string">"xxx"</span>, <span class="hljs-string">"描述信息"</span>);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = <span class="hljs-keyword">new</span> AuthorizationScope[<span class="hljs-number">1</span>];</span><br><span class="line">        authorizationScopes[<span class="hljs-number">0</span>] = authorizationScope;</span><br><span class="line">        <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-keyword">new</span> SecurityReference(<span class="hljs-string">"Authorization"</span>, authorizationScopes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的配置稍微有点长，我来给大家解释下：</p><ul><li>首先通过 @EnableSwagger2 注解启用 Swagger2。</li><li>配置一个 Docket Bean，这个 Bean 中，配置映射路径和要扫描的接口的位置。</li><li>在 apiInfo 中，主要配置一下 Swagger2 文档网站的信息，例如网站的 title，网站的描述，联系人的信息，使用的协议等等。</li><li>通过 securitySchemes 来配置全局参数，这里的配置是一个名为 Authorization 的请求头（OAuth2 中需要携带的请求头）。</li><li>securityContexts 则用来配置有哪些请求需要携带 Token，这里我们配置了所有请求。</li></ul><p>配置完成后，我们还需要给 swagger-ui 放行，否则 swagger-ui 相关的静态资源会被 Spring Security 拦截下来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="hljs-string">"/swagger-ui.html"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/webjars/**"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/v2/**"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/swagger-resources/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，重启 user-server，浏览器输入 <a href="http://localhost:8081/swagger-ui.html，结果如下：" target="_blank" rel="noopener">http://localhost:8081/swagger-ui.html，结果如下：</a></p><p><img src="http://img.itboyhub.com/2020/05/springboot/20200601204303.png" alt></p><p>大家可以看到，页面中多了一个 Authorize 按钮，点击该按钮，输入 <code>Bearer ${token}</code>，如下：</p><p><img src="http://img.itboyhub.com/2020/05/springboot/20200601204440.png" alt></p><p>输入完成后，点击 Authorize 按钮，完成认证，接下来，user-server 中的各种接口就可以直接调用测试了。</p><p>上面这种方式比较通用，不仅仅适用于 OAuth2，也适用于其他一些自定义的 token 登录方式。</p><p>但是这种方式需要开发者先通过其他途径获取到 access_token，有的人会觉得这样有点麻烦，那么有没有更好的办法呢？请看方式二。</p><h3 id="3-2-认证方式二"><a href="#3-2-认证方式二" class="headerlink" title="3.2 认证方式二"></a>3.2 认证方式二</h3><p>认证方式二就是直接在 Swagger 中填入认证信息，这样就不用从外部去获取 access_token 了，效果如下：</p><p><img src="http://img.itboyhub.com/2020/05/springboot/20200602104112.png" alt><br><img src="http://img.itboyhub.com/2020/05/springboot/20200602104026.png" alt></p><p>我们来看下这个怎么配置。</p><p>由于 swagger 去请求 <code>/oauth/token</code> 接口会跨域，所以我们首先要修改 auth-server ，使之支持跨域：</p><p>主要是两方面的修改，首先是配置 CorsFilter，允许跨域，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="hljs-keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="hljs-keyword">true</span>);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="hljs-string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="hljs-string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="hljs-string">"*"</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 SecurityConfig 中开启跨域支持：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .requestMatchers().antMatchers(HttpMethod.OPTIONS, <span class="hljs-string">"/oauth/**"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable().formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .cors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这两步的配置，服务端的跨域支持就开启了。</p><p>接下来我们在 user-server 中修改关于 Docket bean 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableSwagger</span>2</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Swagger2Config</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">"org.javaboy.oauth2.res.controller"</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .securityContexts(Arrays.asList(securityContext()))</span><br><span class="line">                .securitySchemes(Arrays.asList(securityScheme()))</span><br><span class="line">                .apiInfo(<span class="hljs-keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                        .description(<span class="hljs-string">"接口文档的描述信息"</span>)</span><br><span class="line">                        .title(<span class="hljs-string">"微人事项目接口文档"</span>)</span><br><span class="line">                        .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">"javaboy"</span>,<span class="hljs-string">"http://www.javaboy.org"</span>,<span class="hljs-string">"wangsong0210@gmail.com"</span>))</span><br><span class="line">                        .version(<span class="hljs-string">"v1.0"</span>)</span><br><span class="line">                        .license(<span class="hljs-string">"Apache2.0"</span>)</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> AuthorizationScope[] scopes() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthorizationScope[]&#123;</span><br><span class="line">                <span class="hljs-keyword">new</span> AuthorizationScope(<span class="hljs-string">"all"</span>, <span class="hljs-string">"all scope"</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> SecurityScheme <span class="hljs-title">securityScheme</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        GrantType grant = <span class="hljs-keyword">new</span> ResourceOwnerPasswordCredentialsGrant(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> OAuthBuilder().name(<span class="hljs-string">"OAuth2"</span>)</span><br><span class="line">                .grantTypes(Arrays.asList(grant))</span><br><span class="line">                .scopes(Arrays.asList(scopes()))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> SecurityContext <span class="hljs-title">securityContext</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> SecurityContext.builder()</span><br><span class="line">                .securityReferences(Arrays.asList(<span class="hljs-keyword">new</span> SecurityReference(<span class="hljs-string">"OAuth2"</span>, scopes())))</span><br><span class="line">                .forPaths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置跟前面的类似，主要是 SecurityScheme 不同。这里采用了 OAuthBuilder 来构建，构建时即得配置 token 的获取地址。</p><p>好了，配置完成，重启 auth-server 和 user-server 进行测试。测试效果就是松哥前面给出的图片，不再赘述。</p><p>这种方式最大的好处就是不用通过其他途径获取 access_token，直接在 swagger-ui 页面输入 password 模式的认证参数即可。非常方便，仅限于 OAuth2 模式。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好了，今天就和小伙伴们介绍了在 Swagger 请求中，如何修改请求头的问题，感兴趣的小伙伴可以下来试试哦～</p><p>本文案例下载地址：<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>好啦，小伙伴们如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥周末抽空给 Spring Security 系列也录制了一套视频，目录如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+CAS 默认登录页面太丑了，怎么办？</title>
    <link href="http://www.javaboy.org/2020/0608/cas-login-page.html"/>
    <id>http://www.javaboy.org/2020/0608/cas-login-page.html</id>
    <published>2020-06-08T01:38:14.000Z</published>
    <updated>2020-06-08T01:39:59.236Z</updated>
    
    <content type="html"><![CDATA[<p>松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><a id="more"></a><p>最近的又一头扎进 Spring Security+CAS 上面了，CAS 单点登录已经连续写了四篇了，小伙伴们一定按顺序阅读哦，这样后面的文章才好理解。</p><p><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">上篇文章</a>和大家分享了 CAS Server 接入数据库的问题，今天我们来看下如何在 CAS Server 上自定义登录页面，因为正常来说，我们是不会直接用官方给出的登录页面的。</p><p>本文是 Spring Security 系列第 26 篇，阅读前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li></ol><h2 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h2><p>CAS Server 对于自定义登录页面其实提供了很好的支持，可以从多个角度来实现，松哥分别来和大家介绍。</p><p>CAS Server 上提供的登录页面，早期是用 jsp 写的，我们用的 5.3.2 版本里是用 Thymeleaf 写的，所以现在自定义登录页面也是用 Thymeleaf 来写。</p><p>想要自定义登录页面，我们有两种不同的方式：</p><ol><li>直接修改源码，位置在 overlays/org.apereo.cas.cas-server-webapp-tomcat-5.3.14/WEB-INF/classes/templates/casLoginView.html，直接就在它的源码基础上改，这个可以实现需求，但是一般不推荐。</li><li>把自定义的登录页面当成 theme 来开发，然后在配置文件中配置 theme，这种方式就很灵活，而且既可以配置全局主题，也可以配置局部主题。全局主题就是所有的登录页面都使用自定义的登录页面，局部主题则是可以根据不同的 CAS Client 来配置，不同的 CAS Client 将看到不同的登录页面。</li></ol><p>松哥在这里主要和大家介绍第二种方式。</p><h2 id="2-自定义登录页面"><a href="#2-自定义登录页面" class="headerlink" title="2.自定义登录页面"></a>2.自定义登录页面</h2><p>首先我们需要提前准备好自己的登录页面，松哥这里还是使用我本系列前面用过的登录页面：</p><p><img src="http://img.itboyhub.com/2020/05/20200528161117.png" alt></p><p>这个大家可以在文末下载页面模版，也可以自己找一个喜欢的登录页面模版，是在找不到，随便写个表单也行，只要实现了自定义的效果即可。</p><p>自定义的登录页面准备好之后，接下来，我们创建一个新的目录 src/main/resources/static/themes/mylogin，将自定义页面涉及到的静态资源文件拷贝进去，这里的 themes 目录下专门放置各种自定义登录页面的静态资源，mylogin 相当于是我当前使用的主题名称：</p><p><img src="http://img.itboyhub.com/2020/05/20200528161516.png" alt></p><p>接下来创建 src/main/resources/mylogin.properties 文件，将登录页面中的一些 js、css 引用配置进去，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylogin.css.style=/themes/mylogin/css/style.css</span><br><span class="line">mylogin.css.fa=/themes/mylogin/css/font-awesome-4.7.0/css/font-awesome.min.css</span><br><span class="line">mylogin.js.jq=/themes/mylogin/js/jquery.min.js</span><br><span class="line">mylogin.js.index=/themes/mylogin/js/index.js</span><br></pre></td></tr></table></figure><p>我的自定义登录页面里边就这四个引用，如果你有更多的引用，就在这里多配置即可，这里的 key 可以自定义，value 就是静态资源的位置。</p><p>接下来，创建 src/main/resources/templates/mylogin/casLoginView.html 文件，casLoginView.html 就是你的登录页面，注意文件名不能写错。Thymeleaf 模版默认是在 templates 目录下，所以我们要在 resources 目录下新建 templates 目录，templates 目录下再新建 mylogin 目录。</p><p>casLoginView.html 页面内容如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>江南一点雨<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;$&#123;#themes.code('mylogin.css.fa')&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;$&#123;#themes.code('mylogin.css.style')&#125;&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"materialContainer"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>统一认证中心<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">"$&#123;credential&#125;"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"login"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"username"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"username"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"password"</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"password"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"execution"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;flowExecutionKey&#125;"</span>/&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"_eventId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"submit"</span>/&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"geolocation"</span>/&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button login"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pass-forgot"</span>&gt;</span>忘记密码？<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"overbox"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"material-button alt-2"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"shape"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>江南一点雨-注册<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"regname"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"regname"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"regname"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"regpass"</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"regpass"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"regpass"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"reregpass"</span>&gt;</span>确认密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"reregpass"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"reregpass"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;$&#123;#themes.code('mylogin.js.jq')&#125;&#125;"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;$&#123;#themes.code('mylogin.js.index')&#125;&#125;"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就是一个普通的登录页面，我只是把 js 和 css 的引用修改了下而已，所以这里也就不做过多介绍。</p><p>OK，如此之后，我们的登录页面就算定义好了，接下来就是登录页面的引用了。</p><p>登录页面引用，我们有两种方式：</p><p>第一种是全剧配置，直接在 application.properties 中添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas.theme.defaultThemeName=mylogin</span><br></pre></td></tr></table></figure><p>mylogin 就是我们在前面反复出现的目录，相当于是我的主题名。这个配置完成后，以后不管是直接在 CAS Server 上登录，还是从 CAS Client 跳转到 CAS Server 上登录，看到的都是自定义登录页面。</p><p>第二种方式则是局部配置，局部配置针对某一个 CAS Client 的配置，所以我们可以在 src/main/resources/services/client1-99.json 文件中（复习前面文章就知道该文件怎么来的）添加 theme 配置：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"@class"</span>: <span class="hljs-string">"org.apereo.cas.services.RegexRegisteredService"</span>,</span><br><span class="line">  <span class="hljs-attr">"serviceId"</span>: <span class="hljs-string">"^(https|http)://.*"</span>,</span><br><span class="line">  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"client1"</span>,</span><br><span class="line">  <span class="hljs-attr">"id"</span>: <span class="hljs-number">99</span>,</span><br><span class="line">  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"应用1 的定义信息"</span>,</span><br><span class="line">  <span class="hljs-attr">"evaluationOrder"</span>: <span class="hljs-number">1</span>,</span><br><span class="line">  <span class="hljs-attr">"theme"</span>: <span class="hljs-string">"mylogin"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，以后如果是通过<strong>该</strong> CAS Client 跳转到 CAS Server 上登录，则会看到自定义登录页面，如果通过其他 CAS Client 或者直接就在 CAS Server 上登录，则看到的还是默认登录页面，当然我们也可以给其他 CAS Client 再去定义它自己的登录页面。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好了，这就是松哥和大家介绍的 CAS 单点登录自定义登录页面的问题，感兴趣的小伙伴可以试试～</p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&amp;gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot+Vue+微人事视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="CAS" scheme="http://www.javaboy.org/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>我为什么要出一套免费视频教程</title>
    <link href="http://www.javaboy.org/2020/0607/ssm-video.html"/>
    <id>http://www.javaboy.org/2020/0607/ssm-video.html</id>
    <published>2020-06-07T01:37:50.000Z</published>
    <updated>2020-06-08T01:40:28.374Z</updated>
    
    <content type="html"><![CDATA[<p>是的，你没看错，松哥要推出一套<strong>免费视频</strong>教程了。</p><a id="more"></a><p>新出的免费视频估计有的小伙伴可能已经看上了，有的小伙伴可能还不知道，因此今天我就在这里和大家聊一下。</p><p>做免费视频的想法由来已久，但是迟迟没有下定决心，主要有以下两方面的原因：</p><ol><li>工作比较忙，每天还要写原创技术文章，剩下的时间非常有限，而视频的录制需要前期准备、录制、后期剪辑等等，还是一个很耗时的事情。</li><li>网络上批小将太多，免费视频没有门槛，会招致更多的批小将，因此一直比较犹豫。</li></ol><p>由于这两方面的原因，做免费视频的事被我从过年一直拖到现在。中途也曾一度录过一两集，但是因为实在忙不过来后期基本上都烂尾了。所以最近作出这个决定我下了很大决心，今天把话撂在这，也算是给自己一点压力，免费视频争取不要烂尾。</p><h3 id="1-我为什么要录免费视频"><a href="#1-我为什么要录免费视频" class="headerlink" title="1.我为什么要录免费视频"></a>1.我为什么要录免费视频</h3><p>松哥从大二开始自学 Java，大学毕业后顺利入坑，自学之路还是蛮艰辛的。所以我深知大家在自学时面临的两个问题：</p><ol><li>学习顺序</li><li>学习资料</li></ol><p>首先是不知道学什么，这个我之前已经总结了 Java 升级路线图（<a href="https://mp.weixin.qq.com/s/rBRFL2UcDKWB-bHp324mCw" target="_blank" rel="noopener">Java 打怪升级路线图</a>），大家可以参考。</p><p>第二个就是学习资料的问题，虽然现在网上的资料多如牛毛，但是很多时候我们缺的不是一个资料，<strong>我们缺的是一个从头到尾连贯的、系统的资料</strong>，经常是这个人讲的看了一点，那个人讲的看了一点，想头到尾看一个人讲，发现几乎没有这样的资源。</p><p>如果是一个人来讲，知识是连贯的，什么东西讲过，什么东西没讲过，他心里有数，这样大家的学习的时候就不会觉得突兀，比如突然蹦出来一个你从来没听说过的知识点，一个人讲的话，就不会发生这种事情。</p><p>而我从去年七月份开始录制视频以来，被小伙伴们一顿夸，夸的我有点膨胀，所以一直想自己搞一套成体系的课程。松哥之前在网上搜集了超 2TB 的 Java 学习资源（公众号后台回复 2TB 可以获取），但是这些都是别人录制的，现在我也想自己录制一套连贯的、成体系的课程，因为我有信心能够做的更好。</p><h3 id="2-免费视频都录啥"><a href="#2-免费视频都录啥" class="headerlink" title="2.免费视频都录啥"></a>2.免费视频都录啥</h3><p>考虑到松哥之前已经有付费视频了（<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">松哥自制四套视频教程已经杀青，视频常见问题梳理</a>），所以这次的免费视频内容不会和付费视频内容有交叉，也不会重叠，也就是说，免费视频和<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">付费视频</a>内容上不会冲突，这点请大家放心。</p><p>我目前的计划是这样：</p><ol><li>针对刚刚入门的小伙伴出一套<strong>入门级</strong>的 SSM 课程，这套视频会相当简单，只要你有 Java Web 基础就能学。</li><li>出一个入门级的项目（非前后端分离），大概率是以我 GitHub 上的 CoolMeeting(<a href="https://github.com/lenve/CoolMeeting" target="_blank" rel="noopener">https://github.com/lenve/CoolMeeting</a>) 为例来讲解。</li><li>前两个讲完之后，接下来会出一个进阶的课程，进阶课程主要是讲解 Spring 的源码，这块我已经研究了很长时间了，是时候和大家见面了。</li><li>前三个讲完之后。。。再说吧，现在还没想好，一步一步来。</li></ol><p>这就是目前暂定的视频录制计划。<strong>前期的视频主要面向初学者，源码解读会面向有开发经验的小伙伴。</strong></p><p>那么目前已经更新了哪些视频呢？Spring 【基础篇】刚刚制作完毕！给大家看一下目录：</p><p><img src="http://img.itboyhub.com/2020/06/20200606211611.png" alt></p><p>免费视频我会上传到年轻人的学习圣地 B 站上，大家在 B 站搜索<strong>江南一点雨</strong>就可以看到，或者扫描下面的二维码找到松哥：</p><p><img src="http://img.itboyhub.com/2020/06/20200606212723.png" alt></p><p>松哥毕竟是一个人利用业余时间做这件事，没有团队，宣传力度也不能跟一些公司比，但是这些不足并不会影响视频的内容，我还是会认认真真做一套对初学者有用的课程。小伙伴们如果身边有人想学习 Java ，不妨推荐一下松哥的视频给他们，我一定不会让大家失望！</p><p>大家看了免费的视频，如果觉得松哥的讲课风格还能接受，也可以考虑一下付费视频哦：<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">松哥自制四套视频教程已经杀青，视频常见问题梳理</a>。松哥上周末为最近连载的 Spring Security 系列也录制了一套视频，放在 Spring Boot 第十章安全管理里边，感兴趣的小伙伴不要错过呀。</p><p>点击文末的阅读原文，开启 coding 之路吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是的，你没看错，松哥要推出一套&lt;strong&gt;免费视频&lt;/strong&gt;教程了。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
      <category term="视频" scheme="http://www.javaboy.org/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+CAS 单点登录，如何对接数据库？</title>
    <link href="http://www.javaboy.org/2020/0605/springsecurity-cas-mysql.html"/>
    <id>http://www.javaboy.org/2020/0605/springsecurity-cas-mysql.html</id>
    <published>2020-06-05T14:47:22.000Z</published>
    <updated>2020-06-05T15:08:59.876Z</updated>
    
    <content type="html"><![CDATA[<p>松哥给最近连载的 Spring Security 系列也录制了视频教程，感兴趣的小伙伴请戳这里-&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a>（Spring Boot 第十章就是 Spring Security）。</p><a id="more"></a><p>在前面的两篇文章中，松哥和大家分享了 CAS Server 的搭建以及如何使用 Spring Security 搭建 CAS Client。</p><p>但是前面的案例有一个问题，就是登录用户是在 CAS Server 配置文件中写死的，没有对接数据库，实际项目中，这里肯定要对接数据库，所以今天，松哥就来和大家聊一聊 CAS Server 如何对接数据库。</p><p>松哥最近和 Spring Security 杠上了，这是 Spring Security 系列的第 25 篇：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li></ol><h2 id="1-整体思路"><a href="#1-整体思路" class="headerlink" title="1.整体思路"></a>1.整体思路</h2><p>先来看整体思路。</p><p>我们用 CAS Server 做单点登录，CAS Server 主要是负责认证的，也就是它主要解决登录问题。登录成功之后，还有一个权限处理的问题，权限的问题则交由各个 CAS Client 自行处理，并不在 CAS Server 中完成。</p><p>在上篇文章中，松哥有教过大家定义 UserDetailsService，不知道大家是否还记得如下代码（忘记了可以参考上篇文章：<a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a>）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Primary</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(s, <span class="hljs-string">"123"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>,</span><br><span class="line">                AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_user"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是在什么时候执行呢？</p><p>如果我们没有使用 CAS 这一套的话，这段代码当然是在用户登录的时候执行，用户登录时，从数据库中查询用户的信息，然后做校验（参考本系列前面文章就懂）。</p><p>如果我们使用 CAS 这一套，用户登录的校验将在 CAS Server 上执行，CAS Client 就不用做校验工作了，但是为什么我们还需要定义 UserDetailsService 呢？这是为了当用户在 CAS Server 上登录成功之后，拿着用户名回到 CAS Client，然后我们再去数据库中根据用户名获取用户的详细信息，包括用户的角色等，进而在后面的鉴权中用上角色。</p><p>好了，这是我们一个大致的思路，接下来我们来看具体实现。</p><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><p>接下来的配置在 <a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a> 一文的基础上完成，所以还没看前面文章的小伙伴建议先看一下哦。</p><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><p>首先我们先在数据库中准备一下用户表、角色表以及用户角色关联表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`t_role`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`name_zh`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`t_user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`account_non_expired`</span> <span class="hljs-built_in">bit</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`account_non_locked`</span> <span class="hljs-built_in">bit</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`credentials_non_expired`</span> <span class="hljs-built_in">bit</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`enabled`</span> <span class="hljs-built_in">bit</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`password`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`t_user_roles`</span> (</span><br><span class="line">  <span class="hljs-string">`t_user_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`roles_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`FKj47yp3hhtsoajht9793tbdrp4`</span> (<span class="hljs-string">`roles_id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`FK7l00c7jb4804xlpmk1k26texy`</span> (<span class="hljs-string">`t_user_id`</span>),</span><br><span class="line">  <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-string">`FK7l00c7jb4804xlpmk1k26texy`</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`t_user_id`</span>) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">`t_user`</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-string">`FKj47yp3hhtsoajht9793tbdrp4`</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`roles_id`</span>) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">`t_role`</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`t_role`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`name_zh`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">'ROLE_admin'</span>,<span class="hljs-string">'管理员'</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">'ROLE_user'</span>,<span class="hljs-string">'普通用户'</span>);</span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`t_user`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`account_non_expired`</span>, <span class="hljs-string">`account_non_locked`</span>, <span class="hljs-string">`credentials_non_expired`</span>, <span class="hljs-string">`enabled`</span>, <span class="hljs-string">`password`</span>, <span class="hljs-string">`username`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,<span class="hljs-string">'123'</span>,<span class="hljs-string">'javaboy'</span>),(<span class="hljs-number">2</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,<span class="hljs-string">'123'</span>,<span class="hljs-string">'江南一点雨'</span>);</span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`t_user_roles`</span> (<span class="hljs-string">`t_user_id`</span>, <span class="hljs-string">`roles_id`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-CAS-Server"><a href="#2-2-CAS-Server" class="headerlink" title="2.2 CAS Server"></a>2.2 CAS Server</h3><p>然后我们要在 CAS Server 的 pom.xml 文件中添加两个依赖：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cas-server-support-jdbc-drivers&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cas-server-support-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注意这里不用添加数据库驱动，系统会自动解决。</p><p>添加完成之后，再在 src/main/resources/application.properties 文件中添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cas.authn.jdbc.query[0].url=jdbc:mysql://127.0.0.1:3306/withjpa?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;useSSL=false</span><br><span class="line">cas.authn.jdbc.query[0].user=root</span><br><span class="line">cas.authn.jdbc.query[0].password=123</span><br><span class="line">cas.authn.jdbc.query[0].sql=select * from t_user where username=?</span><br><span class="line">cas.authn.jdbc.query[0].fieldPassword=password</span><br><span class="line">cas.authn.jdbc.query[0].driverClass=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><ul><li>前三行配置是数据库基本连接配置，这个无需我多说。</li><li>第四行表示配置用户查询 sql，根据用户名查询出用户的所有信息。</li><li>第五行表示数据库中密码的字段名字是什么。</li><li>第六行是数据库驱动。</li></ul><p>OK，配置完成后，接下来我们就来重启 CAS Server：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh run</span><br></pre></td></tr></table></figure><p>启动成功后，浏览器输入 <a href="https://cas.javaboy.org:8443/cas/login" target="_blank" rel="noopener">https://cas.javaboy.org:8443/cas/login</a> 就可以进入登录页面了（注意是 https 哦）：</p><p><img src="http://img.itboyhub.com/2020/05/20200523220157.png" alt></p><p>此时登录用户名就是 javaboy，密码是 123。</p><h3 id="2-3-CAS-Client"><a href="#2-3-CAS-Client" class="headerlink" title="2.3 CAS Client"></a>2.3 CAS Client</h3><p>接下来我们再来看看 CAS Client 要做哪些完善。</p><p>接下来的配置在 <a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a> 一文的基础上完成，所以还没看前面文章的小伙伴建议先看一下哦。</p><p>同时，为了案例简洁，我这里使用 JPA 来操作数据库，要是大家不熟悉这块的操作，可以参考本系列之前的文章：<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a>。</p><p>CAS Client 中的对接主要是实现 UserDetailsService 接口。这里要用到数据库查询，所以我们首先添加数据库相关依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 application.properties 中配置数据库连接信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="hljs-number">123</span></span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="hljs-comment">///withjpa?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">spring.jpa.database=mysql</span><br><span class="line">spring.jpa.database-platform=mysql</span><br><span class="line">spring.jpa.hibernate.ddl-auto=update</span><br><span class="line">spring.jpa.show-sql=<span class="hljs-keyword">true</span></span><br><span class="line">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect</span><br></pre></td></tr></table></figure><p>都是常规配置，我们就不再重复解释了。</p><p>接下来我们创建两个实体类，分别表示用户角色了用户类：</p><p>用户角色：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Entity</span>(name = <span class="hljs-string">"t_role"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> String nameZh;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实体类用来描述用户角色信息，有角色 id、角色名称（英文、中文），@Entity 表示这是一个实体类，项目启动后，将会根据实体类的属性在数据库中自动创建一个角色表。</p><p>用户实体类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Entity</span>(name = <span class="hljs-string">"t_user"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> accountNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> accountNonLocked;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> credentialsNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enabled;</span><br><span class="line">    <span class="hljs-meta">@ManyToMany</span>(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST)</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (Role role : getRoles()) &#123;</span><br><span class="line">            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> accountNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> accountNonLocked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> credentialsNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//省略其他 get/set 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户实体类主要需要实现  UserDetails 接口，并实现接口中的方法。</p><p>这里的字段基本都好理解，几个特殊的我来稍微说一下：</p><ol><li>accountNonExpired、accountNonLocked、credentialsNonExpired、enabled 这四个属性分别用来描述用户的状态，表示账户是否没有过期、账户是否没有被锁定、密码是否没有过期、以及账户是否可用。</li><li>roles 属性表示用户的角色，User 和 Role 是多对多关系，用一个 @ManyToMany 注解来描述。</li><li>getAuthorities 方法返回用户的角色信息，我们在这个方法中把自己的 Role 稍微转化一下即可。</li></ol><p>数据模型准备好之后，我们再来定义一个 UserDao：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">findUserByUsername</span><span class="hljs-params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的东西很简单，我们只需要继承 JpaRepository 然后提供一个根据 username 查询 user 的方法即可。如果小伙伴们不熟悉 Spring Data Jpa 的操作，可以在公众号后台回复 springboot 获取松哥手敲的 Spring Boot 教程，里边有 jpa 相关操作，也可以看看松哥录制的视频教程：<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a>。</p><p>在接下来定义 UserService ，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Primary</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        User user = userDao.findUserByUsername(username);</span><br><span class="line">        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自己定义的 UserDetailsServiceImpl 需要实现 UserDetailsService 接口，实现该接口，就要实现接口中的方法，也就是 loadUserByUsername。</p><p>OK ，如此之后，我们的 CAS Client 现在就开发完成了，接下来启动 CAS Client，启动成功后，浏览器输入 <code>http://client1.cas.javaboy.org:8080/user/hello</code> 访问 hello 接口，此时会自动跳转到 CAS Server 上登录，登录的用户名密码就是我们存储在数据库中的用户名密码。登录成功之后，经过两个重定向，会重新回到 hello 接口。</p><p>hello 接口访问成功之后，再去访问 <code>/user/hello</code> 接口，就会发现权限配置也生效了。</p><p>这里比较简单，我就不给大家截图了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，今天主要和小伙伴们分享了一下 Spring Security + CAS 单点登录中，如何使用本地数据库。一个核心的思路是，认证由 CAS Server 来做，权限相关的操作，则还是由 Spring Security 来完成。</p><p>好了 ，本文就说到这里，本文相关案例我已经上传到 GitHub ，大家可以自行下载:<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>好啦，小伙伴们如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥给最近连载的 Spring Security 系列也录制了视频教程，感兴趣的小伙伴请戳这里-&amp;gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot+Vue+微人事视频教程&lt;/a&gt;（Spring Boot 第十章就是 Spring Security）。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="CAS" scheme="http://www.javaboy.org/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 实现单点登录的第三种方案！</title>
    <link href="http://www.javaboy.org/2020/0604/springsecurity-cas.html"/>
    <id>http://www.javaboy.org/2020/0604/springsecurity-cas.html</id>
    <published>2020-06-04T14:47:12.000Z</published>
    <updated>2020-06-05T15:08:50.033Z</updated>
    
    <content type="html"><![CDATA[<p>松哥周末抽空给 Spring Security 系列也录制了一套视频，目录如下：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/05/springboot/20200531234416.png" alt></p><p>感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><p>来看今天的文章。</p><p>前面松哥发过两篇文章，也是两种方案，讲到单点登录问题：</p><ul><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">OAuth2+JWT 方案</a></li><li><a href="https://mp.weixin.qq.com/s/EyAMTbKPqNNnEtZACIsMVw" target="_blank" rel="noopener">@EnableOAuth2Sso 注解方案</a></li></ul><p>今天再来和大家介绍第三种方案，使用 Spring Security 开发 CAS 单点登录系统客户端。</p><p><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">上篇文章</a>讲了 CAS 单点登录以及 CAS Server 的搭建问题，CAS Server 搭建好了，接下来我们要搭建具体的应用，本文我们就来看看 Spring Security+CAS 如何实现单点登录。</p><p>本文在<a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">上篇文章</a>的基础上继续完成，如果小伙伴们的 CAS Server 还没搭建成功，可以参考<a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">上篇文章</a>。</p><p>本文是 Spring Security 系列第 24 篇，阅读本系列前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">聊一聊 Spring Boot 中的 CAS 单点登录</a></li></ol><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>准备工作主要做两件事。</p><h3 id="1-1-服务记录"><a href="#1-1-服务记录" class="headerlink" title="1.1 服务记录"></a>1.1 服务记录</h3><p>某一个 Client 需要接入 CAS Server 进行验证，则该 Client 必须提前在 CAS Server 上配置其信息。</p><p>这个信息既可以动态添加，也可以通过 JSON 来配置，后面松哥会教搭建如何动态添加，这里方便起见，我们还是通过 JSON 来进行配置。</p><p>具体配置方式如下，在 CAS Server 中创建如下目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/main/resources/services</span><br></pre></td></tr></table></figure><p>在该目录下创建一个名为 client1-99.json 的文件，client1 表示要接入的 client 的名字，99 表示要接入的 client 的 id，json 文件内容如下（这个配置可以参考官方给出的模版：overlays/org.apereo.cas.cas-server-webapp-tomcat-5.3.14/WEB-INF/classes/services/Apereo-10000002.json）：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"@class"</span>: <span class="hljs-string">"org.apereo.cas.services.RegexRegisteredService"</span>,</span><br><span class="line">  <span class="hljs-attr">"serviceId"</span>: <span class="hljs-string">"^(https|http)://.*"</span>,</span><br><span class="line">  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"client1"</span>,</span><br><span class="line">  <span class="hljs-attr">"id"</span>: <span class="hljs-number">99</span>,</span><br><span class="line">  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"应用1 的定义信息"</span>,</span><br><span class="line">  <span class="hljs-attr">"evaluationOrder"</span>: <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段 JSON 配置含义如下：</p><ol><li>@calss 指定注册服务类，这个是固定的org.apereo.cas.services.RegexRegisteredService。</li><li>serviceId 则通过正则表达式用来匹配具体的请求。</li><li>name 是接入的 client 的名称。</li><li>id 是接入的 client 的 id。</li><li>description 是接入的 client 的描述信息。</li><li>evaluationOrder 则指定了执行的优先级。</li></ol><p>接下来再在 src/main/resources/application.properties 文件中配置刚刚 json 的信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cas.serviceRegistry.json.location=classpath:/services</span><br><span class="line">cas.serviceRegistry.initFromJson=true</span><br></pre></td></tr></table></figure><p>这里有两行配置：</p><ol><li>指定配置 JSON 文件的位置。</li><li>开启 JSON 识别。</li></ol><p>OK，配置完成后，重启 CAS Server。</p><p>CAS Server 启动成功后，我们在控制台看到如下日志，表示 JSON 配置已经加载成功了：</p><p><img src="http://img.itboyhub.com/2020/05/20200524112747.png" alt></p><h3 id="1-2-JDK-证书"><a href="#1-2-JDK-证书" class="headerlink" title="1.2 JDK 证书"></a>1.2 JDK 证书</h3><p>第二个要提前准备的东西就是 JDK 证书。</p><p>在实际开发中，这一步可以忽略，但是因为我们现在用的自己生成的 SSL 证书，所以我们要将自己生成的证书导入到 JDK 中，否则在使用 Spring Security 接入 CAS 单点登录时，会抛出如下错误：</p><p><img src="http://img.itboyhub.com/2020/05/20200526162719.png" alt></p><p>将 SSL 证书导入 JDK 中的命令其实也很简单，两个步骤，第一个导出 <code>.cer</code> 文件，第二步，导入 JDK，命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -trustcacerts -alias casserver -file ./cas.cer -keystore ./keystore</span><br><span class="line">sudo keytool -import -trustcacerts -alias casserver -file ./cas.cer -keystore /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home/lib/security/cacerts</span><br></pre></td></tr></table></figure><p>注意，在执行 export 导出命令时，需要输入密钥口令，这个口令就是自己一开始创建 SSL 证书时设置的。在执行 import 导入命令时，也需要输入口令，这个口令是 changeit，注意，不是自己一开始设置的。</p><p>密钥库的位置在 JDK 目录下的 <code>/lib/security/cacerts</code>，小伙伴们根据自己实际情况来修改（在 JDK9 之前，位置在 <code>jre/lib/security/cacerts</code>）。</p><p>我们在本地测试一定要导入证书到 JDK 证书库中，否则后面的测试会出现上图中的错误，证书导入 JDK 证书库之后，要确保之后的开发中，使用的是本地的 JDK。</p><p><strong>注意，JDK 证书导入之后，CASServer 需要重启一下。</strong></p><h3 id="1-3-修改-hosts"><a href="#1-3-修改-hosts" class="headerlink" title="1.3 修改 hosts"></a>1.3 修改 hosts</h3><p>另外，我们还需要修改电脑 hosts 文件，因为前面关于 CAS Server，关于 SSL 证书的配置都涉及到域名，所以后面的访问我们将通过域名的形式访问，hosts 文件中添加如下两条记录：</p><p><img src="http://img.itboyhub.com/2020/05/20200526192403.png" alt></p><p>第一个是 CAS Server 的请求域名，第二个是 CAS Client 的请求域名。</p><h2 id="2-开发-Client"><a href="#2-开发-Client" class="headerlink" title="2.开发 Client"></a>2.开发 Client</h2><p>在使用 Spring Security 开发 CAS Client 之前，有一个基本问题需要先和小伙伴们捋清楚：用户登录是在 CAS Server 上登录，所以 Spring Security 中虽然依旧存在用户的概念，但是对于用户的处理逻辑会和前面的有所不同。</p><p>好了，接下来我们来看下具体步骤。</p><p>首先我们来创建一个普通的 Spring Boot 项目，加入 Web 依赖 和 Spring Security 依赖，如下：</p><p><img src="http://img.itboyhub.com/2020/05/20200526192109.png" alt></p><p>项目创建成功后，我们再来手动加入 cas 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-cas<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，在 application.properties 中配置 CAS Server 和 CAS Client 的请求地址信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cas.server.prefix=https://cas.javaboy.org:8443/cas</span><br><span class="line">cas.server.login=$&#123;cas.server.prefix&#125;/login</span><br><span class="line">cas.server.logout=$&#123;cas.server.prefix&#125;/logout</span><br><span class="line"></span><br><span class="line">cas.client.prefix=http://client1.cas.javaboy.org:8080</span><br><span class="line">cas.client.login=$&#123;cas.client.prefix&#125;/login/cas</span><br><span class="line">cas.client.logoutRelative=/logout/cas</span><br><span class="line">cas.client.logout=$&#123;cas.client.prefix&#125;$&#123;cas.client.logoutRelative&#125;</span><br></pre></td></tr></table></figure><p>这些配置都是自定义配置，所以配置的 key 可以自己随意定义。至于配置的含义都好理解，分别配置了 CAS Server 和 CAS Client 的登录和注销地址。</p><p>配置好之后，我们需要将这些配置注入到实体类中使用，这里就用到了类型安全的属性绑定（参见：<a href="https://mp.weixin.qq.com/s/vd6MR-UXi-OK2Z-uR15BTQ" target="_blank" rel="noopener">Spring Boot2 系列教程(四)理解配置文件 application.properties ！</a>）。</p><p>这里我创建两个类分别用来接收 CAS Server 和 CAS Client 的配置文件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"cas.server"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASServerProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String prefix;</span><br><span class="line">    <span class="hljs-keyword">private</span> String login;</span><br><span class="line">    <span class="hljs-keyword">private</span> String logout;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"cas.client"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASClientProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String prefix;</span><br><span class="line">    <span class="hljs-keyword">private</span> String login;</span><br><span class="line">    <span class="hljs-keyword">private</span> String logoutRelative;</span><br><span class="line">    <span class="hljs-keyword">private</span> String logout;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外记得在启动类上面添加 <code>@ConfigurationPropertiesScan</code> 注解来扫描这两个配置类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span></span><br><span class="line"><span class="hljs-meta">@ConfigurationPropertiesScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client1Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Client1Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里配置完成后，我们一会将在配置文件中来使用。</p><p>接下来创建 CAS 的配置文件，略长：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CasSecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    CASClientProperties casClientProperties;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    CASServerProperties casServerProperties;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserDetailsService userDetailService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">ServiceProperties <span class="hljs-title">serviceProperties</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        ServiceProperties serviceProperties = <span class="hljs-keyword">new</span> ServiceProperties();</span><br><span class="line">        serviceProperties.setService(casClientProperties.getLogin());</span><br><span class="line">        <span class="hljs-keyword">return</span> serviceProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-meta">@Primary</span></span><br><span class="line">    <span class="hljs-function">AuthenticationEntryPoint <span class="hljs-title">authenticationEntryPoint</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        CasAuthenticationEntryPoint entryPoint = <span class="hljs-keyword">new</span> CasAuthenticationEntryPoint();</span><br><span class="line">        entryPoint.setLoginUrl(casServerProperties.getLogin());</span><br><span class="line">        entryPoint.setServiceProperties(serviceProperties());</span><br><span class="line">        <span class="hljs-keyword">return</span> entryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TicketValidator <span class="hljs-title">ticketValidator</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cas20ProxyTicketValidator(casServerProperties.getPrefix());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">CasAuthenticationProvider <span class="hljs-title">casAuthenticationProvider</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        CasAuthenticationProvider provider = <span class="hljs-keyword">new</span> CasAuthenticationProvider();</span><br><span class="line">        provider.setServiceProperties(serviceProperties());</span><br><span class="line">        provider.setTicketValidator(ticketValidator());</span><br><span class="line">        provider.setUserDetailsService(userDetailService);</span><br><span class="line">        provider.setKey(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">CasAuthenticationFilter <span class="hljs-title">casAuthenticationFilter</span><span class="hljs-params">(AuthenticationProvider authenticationProvider)</span> </span>&#123;</span><br><span class="line">        CasAuthenticationFilter filter = <span class="hljs-keyword">new</span> CasAuthenticationFilter();</span><br><span class="line">        filter.setServiceProperties(serviceProperties());</span><br><span class="line">        filter.setAuthenticationManager(<span class="hljs-keyword">new</span> ProviderManager(authenticationProvider));</span><br><span class="line">        <span class="hljs-keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SingleSignOutFilter <span class="hljs-title">singleSignOutFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        SingleSignOutFilter sign = <span class="hljs-keyword">new</span> SingleSignOutFilter();</span><br><span class="line">        sign.setIgnoreInitConfiguration(<span class="hljs-keyword">true</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">LogoutFilter <span class="hljs-title">logoutFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        LogoutFilter filter = <span class="hljs-keyword">new</span> LogoutFilter(casServerProperties.getLogout(), <span class="hljs-keyword">new</span> SecurityContextLogoutHandler());</span><br><span class="line">        filter.setFilterProcessesUrl(casClientProperties.getLogoutRelative());</span><br><span class="line">        <span class="hljs-keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件略长，但是并不难，我来和大家挨个解释：</p><ol><li>首先一进来注入三个对象，这三个中，有两个是我们前面写的配置类的实例，另外一个则是 UserDetailsService，关于 UserDetailsService，我想我也不必多做解释，大家参考本系列前面的文章就知道 UserDetailsService 的作用（<a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a>），一会我会给出 UserDetailsService 的实现。</li><li>接下来配置 ServiceProperties，ServiceProperties 中主要配置一下 Client 的登录地址即可，这个地址就是在 CAS Server 上登录成功后，重定向的地址。</li><li>CasAuthenticationEntryPoint 则是 CAS 验证的入口，这里首先设置 CAS Server 的登录地址，同时将前面的 ServiceProperties 设置进去，这样当它登录成功后，就知道往哪里跳转了。</li><li>TicketValidator 这是配置 ticket 校验地址，CAS Client 拿到 ticket 要去 CAS Server 上校验，默认校验地址是：<a href="https://cas.javaboy.org:8443/cas/proxyValidate?ticket=xxx" target="_blank" rel="noopener">https://cas.javaboy.org:8443/cas/proxyValidate?ticket=xxx</a></li><li>CasAuthenticationProvider 主要用来处理 CAS 验证逻辑，关于 AuthenticationProvider 松哥在前面的文章中和大家分享过（<a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a>），当时就说，想要自定义认证逻辑，如短信登录等，都可以通过扩展 AuthenticationProvider 来实现，这里的 CAS 登录当然也不例外，这里虽然设置了一个 userDetailService，但是目的不是为了从数据库中查询数据做校验，因为登录是在 CAS Server 中进行的，这个的作用，我在后面会做介绍。</li><li>CasAuthenticationFilter 则是 CAS 认证的过滤器，过滤器将请求拦截下来之后，交由 CasAuthenticationProvider 来做具体处理。</li><li>SingleSignOutFilter 表示接受 CAS Server 发出的注销请求，所有的注销请求都将从 CAS Client 转发到 CAS Server，CAS Server 处理完后，会通知所有的 CAS Client 注销登录。</li><li>LogoutFilter 则是配置将注销请求转发到 CAS Server。</li></ol><p>接下来我再来给大家看下我定义的 UserDetailsService：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Primary</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(s, <span class="hljs-string">"123"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>,</span><br><span class="line">                AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_user"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是单点登录，也就是用户是在 CAS Server 上登录的，这里的 UserDetailsService 意义在哪里呢？</p><p>用户虽然在 CAS Server 上登录，但是，登录成功之后，CAS Client 还是要获取用户的基本信息、角色等，以便做进一步的权限控制，所以，这里的 loadUserByUsername 方法中的参数，实际上就是你从 CAS Server 上登录成功后获取到的用户名，拿着这个用户名，去数据库中查询用户的相关信心并返回，方便 CAS Client 在后续的鉴权中做进一步的使用，这里我为了方便，就没有去数据库中查询了，而是直接创建了一个 User 对象返回。</p><p>接下来，我们再来看看 Spring Security 的配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationProvider authenticationProvider;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    SingleSignOutFilter singleSignOutFilter;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    LogoutFilter logoutFilter;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    CasAuthenticationFilter casAuthenticationFilter;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.authenticationProvider(authenticationProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().antMatchers(<span class="hljs-string">"/user/**"</span>)</span><br><span class="line">                .hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/login/cas"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                .and()</span><br><span class="line">                .addFilter(casAuthenticationFilter)</span><br><span class="line">                .addFilterBefore(singleSignOutFilter, CasAuthenticationFilter.class)</span><br><span class="line">                .addFilterBefore(logoutFilter, LogoutFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的配置就简单很多了：</p><ol><li>首先配置 authenticationProvider，这个 authenticationProvider 实际上就是一开始配置的 CasAuthenticationProvider。</li><li>接下来配置 <code>/user/**</code> 格式的路径需要有 user 角色才能访问，登录路径 <code>/login/cas</code> 可以直接访问，剩余接口都是登录成功之后才能访问。</li><li>最后把 authenticationEntryPoint 配置进来，再把自定义的过滤器加进来，这些都比较容易我就不多说了。</li></ol><p>最后，再提供两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK ，如此之后，我们的 CAS Client 现在就开发完成了，接下来启动 CAS Client，启动成功后，浏览器输入 <code>http://client1.cas.javaboy.org:8080/user/hello</code> 访问 hello 接口，此时会自动跳转到 CAS Server 上登录，登录成功之后，经过两个重定向，会重新回到 hello 接口。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>OK，这就是松哥和大家介绍的 Spring Security + CAS 单点登录，当然，这个案例中还有很多需要完善的地方，松哥会在后面的文章中继续和大家分享完善的方案。</p><p>好了 ，本文就说到这里，本文相关案例我已经上传到 GitHub ，大家可以自行下载:<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>好啦，小伙伴们如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥周末抽空给 Spring Security 系列也录制了一套视频，目录如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="CAS" scheme="http://www.javaboy.org/tags/CAS/"/>
    
  </entry>
  
</feed>
