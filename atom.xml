<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-03-12T09:01:43.673Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 做分布式锁你会几种姿势？松哥来给大家介绍两种</title>
    <link href="http://www.javaboy.org/2020/0312/redis-distribute.html"/>
    <id>http://www.javaboy.org/2020/0312/redis-distribute.html</id>
    <published>2020-03-12T08:55:29.000Z</published>
    <updated>2020-03-12T09:01:43.673Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 简简单单的几种数据类型，一个 key/value 数据库，现在又是分布式锁、又是限流工具、又是消息队列……，感觉都要被玩坏了。不过话说回来，Redis 在这么多场合被开发者们喜欢，还是得益于它极高的性能与使用的简洁性。</p><a id="more"></a><p>在面试的时候，说到 Redis ，很多人第一反应就是缓存，其实除了缓存，Redis 还有非常多丰富的使用场景，这些使用场景，松哥在未来都会和大家一一分享。</p><p>今天就先来看一个简单的，用 Redis 做分布式锁。</p><h2 id="1-什么是分布式锁"><a href="#1-什么是分布式锁" class="headerlink" title="1.什么是分布式锁"></a>1.什么是分布式锁</h2><p>首先我们来看一个问题场景：</p><blockquote><p>例如一个简单的用户操作，一个线程去修改用户的状态，首先从数据库中读出用户的状态，然后在内存中进行修改，修改完成后，再存回去。在单线程中，这个操作没有问题，但是在多线程中，由于读取、修改、存 这是三个操作，不是原子操作，所以在多线程中，这样会出问题。</p></blockquote><p>解决这个问题，我们就需要锁，对于锁，大家应该不会陌生，在 Java 中的 synchronized 以及 ReentrantLock 可重入锁都是我们比较常见的，但是这种锁都是本地锁，现在微服务、分布式系统思想大行其道，在这样的系统中，本地锁显然是不够用的，于是大家纷纷想办法，如何在分布式环境下解决锁的问题。想出来的办法很多，我们可以通过 MySQL、可以通过 ZK、也可以通过 Redis ，都可以用来解决分布式锁的问题，这里我们主要来看看如何通过 Redis 解决分布式锁问题。</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><h3 id="2-1-整体思路"><a href="#2-1-整体思路" class="headerlink" title="2.1 整体思路"></a>2.1 整体思路</h3><p><strong>分布式锁实现的思路很简单，就是进来一个线城先占位，当别的线城进来操作时，发现已经有人占位了，就会放弃或者稍后再试。</strong></p><p>在 Redis 中，占位一般使用 setnx 指令，先进来的线程先占位，线程的操作执行完成后，再调用 del 指令释放位子。同时为了防止死锁，我们一般还要给锁加一个过期时间，到期了自动释放。</p><p>基于这样的思路，我们来看两种不同的实现方式：</p><h3 id="2-2-解决方案一"><a href="#2-2-解决方案一" class="headerlink" title="2.2 解决方案一"></a>2.2 解决方案一</h3><p>基于我们前面所说的思路，可以使用 setnx 和 expire 实现分布式锁，但是 setnx 和设置过期时间 expire 这是两个操作，这两个操作一起的话就不具备原子性（除非自己写 Lua 脚本），为了解决这个问题，从 Redis2.8 开始，setnx 和 expire 可以通过一个命令一起来执行了，这个命令就是 set，set 中多了一个参数:</p><p><img src="http://img.itboyhub.com/2020/03/dis-redis-1.png" alt></p><p>从图中大家可以看到，在 key/value 之后，还有一个 EX 5 表示以秒计的过期时间（PX 表示以毫秒计的过期时间），最后的 NX 就是说如果 k1 不存在，这条命令执行成功，否则执行失败，这就相当于 setnx 的效果了。</p><p>因此，我们封装的锁如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Redis redis = <span class="hljs-keyword">new</span> Redis();</span><br><span class="line">        redis.execute(jedis-&gt;&#123;</span><br><span class="line">            String set = jedis.set(<span class="hljs-string">"k1"</span>, <span class="hljs-string">"v1"</span>, <span class="hljs-keyword">new</span> SetParams().nx().ex(<span class="hljs-number">5</span>));</span><br><span class="line">            <span class="hljs-keyword">if</span> (set !=<span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-string">"OK"</span>.equals(set)) &#123;</span><br><span class="line">                <span class="hljs-comment">//没人占位</span></span><br><span class="line">                jedis.set(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">                String name = jedis.get(<span class="hljs-string">"name"</span>);</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                jedis.del(<span class="hljs-string">"k1"</span>);<span class="hljs-comment">//释放资源</span></span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                <span class="hljs-comment">//有人占位，停止/暂缓 操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这段代码，大家重点看思路，不必深究代码细节：</p><ol><li>首先构造一个 Redis 实例，然后调用 execute 方法，这个是我自己封装的方法，目的是为了配置 Jedis 连接池并及时回收使用过的资源。这一块小伙伴们测试的时候可以直接使用自己创建的 Jedis 实例，效果是一样的。</li><li>调用 jedis 中的 set 方法，注意第三个参数，我们设置了 nx 同时 设置了过期时间为 5 秒，这就相当于 setnx 和 expire 两个命令的结合体。</li><li>如果成功执行了 set 命令，在 if 中就可以去写自己的业务了。如果没能抢到锁，则可以进入到一个延迟消息队列中，停一会再去尝试（用 Redis 实现延迟消息队列，松哥会在后面的文章中向大家介绍）。</li></ol><p>但是这样的封装，又带来了一个新的问题，那就是超时问题，关于超时问题，松哥通过一个视频教程来和大家分享（本视频节选自松哥自制的 <a href="https://mp.weixin.qq.com/s/8FmgtWyz6HUIbF4smXQOwQ" target="_blank" rel="noopener">Spring Boot+Vue+Spring Cloud+Redis 系列视频教程</a>）：</p><p><img src="https://mp.weixin.qq.com/s/NKiLt2Ebofa1Wq1k5sFscA" alt="视频地址"></p><h3 id="2-3-解决方案二"><a href="#2-3-解决方案二" class="headerlink" title="2.3 解决方案二"></a>2.3 解决方案二</h3><p>上面的代码写着还是蛮长的，那么有没有简单一点的办法呢？当然是有的！那就是 Redisson。</p><p>相对于 Jedis 这种原生态的应用，Redisson 对 Redis 请求做了较多的封装，对于锁，也提供了对应的方法可以直接使用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="hljs-keyword">new</span> Config();</span><br><span class="line"><span class="hljs-comment">//配置 Redis 基本连接信息</span></span><br><span class="line">config.useSingleServer().setAddress(<span class="hljs-string">"redis://127.0.0.1:6379"</span>).setPassword(<span class="hljs-string">"123"</span>);</span><br><span class="line"><span class="hljs-comment">//获取一个 RedissonClient 对象</span></span><br><span class="line">RedissonClient redisson = Redisson.create(config);</span><br><span class="line"><span class="hljs-comment">//获取一个锁对象实例</span></span><br><span class="line">RLock lock = redisson.getLock(<span class="hljs-string">"lock"</span>); </span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//获取锁</span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> b = lock.tryLock(<span class="hljs-number">500</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="hljs-keyword">if</span> (b) &#123;</span><br><span class="line">        <span class="hljs-comment">//获取到锁了，开始写业务</span></span><br><span class="line">        RBucket&lt;Object&gt; bucket = redisson.getBucket(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        bucket.set(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        Object o = bucket.get();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"没拿到锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//释放锁</span></span><br><span class="line">    lock.unlock(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，核心的就是 <code>lock.tryLock(500, 1000, TimeUnit.MILLISECONDS);</code>，第一个参数是尝试加锁的等待时间为 500 毫秒，第二个参数表示锁的超时时间为 1000 毫秒，也就是这个锁在 1000 毫秒后会自动失效。</p><p>小伙伴们发现，这和我们在方案一里边配置的参数是一样的，其实思路是不变的，Redisson 只不过是将我们写的和锁相关的方法封装起来了而已。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>当然，这里我只是先简单介绍下加锁的思路以及在 Redis 单机中如何加锁，后面松哥再和大家分享 Redis 集群中如何加锁。如果小伙伴们对于 Redis 的基本用法还不太熟悉的话，可以在松哥公众号后台回复 redis，获取松哥手敲的 Redis 入门教程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 简简单单的几种数据类型，一个 key/value 数据库，现在又是分布式锁、又是限流工具、又是消息队列……，感觉都要被玩坏了。不过话说回来，Redis 在这么多场合被开发者们喜欢，还是得益于它极高的性能与使用的简洁性。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
      <category term="分布式锁" scheme="http://www.javaboy.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>听说你 FastDFS 老安装失败，这能忍？松哥一定要帮你搞定！</title>
    <link href="http://www.javaboy.org/2020/0312/springboot-fastdfs.html"/>
    <id>http://www.javaboy.org/2020/0312/springboot-fastdfs.html</id>
    <published>2020-03-12T08:32:02.452Z</published>
    <updated>2020-03-12T08:53:10.682Z</updated>
    
    <content type="html"><![CDATA[<p>本文上周日发过，但是有小伙伴看了之后表示 FastDFS 老是安装失败！松哥这犟脾气，绝对不能忍，一定要教会大家，这不赶紧抽空录了一个视频手把手教大家安装 FastDFS，并且实现通过 Java 代码上传/下载文件的功能。小伙伴们一起来看下，这次一定要学会呀！</p><a id="more"></a><p>FastDFS 介绍：</p><iframe src="//player.bilibili.com/player.html?aid=95352488&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>安装 FastDFS 并实现文件上传：</p><iframe src="//player.bilibili.com/player.html?aid=95353225&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>安装 Nginx 模块并实现文件访问：</p><iframe src="//player.bilibili.com/player.html?aid=95353463&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>解决文件安全管理问题：</p><iframe src="//player.bilibili.com/player.html?aid=95353728&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>说起分布式文件管理系统，大家可能很容易想到 HDFS、GFS 等系统，前者是 Hadoop 的一部分，后者则是 Google 提供的分布式文件管理系统。除了这些之外，国内淘宝和腾讯也有自己的分布式文件管理系统，都叫 TFS（<code>Taobao File System</code> 和 <code>Tencent File System</code>）。</p><p>相对于上面提到的这些分布式文件管理系统而言，FastDFS 可能离我们 Java 工程师更近一些，因为文件上传这个功能太常见了，而想要搭建独立的分布式文件管理系统，FastDFS+Nginx 组合无疑是最佳方案。因此，松哥今天就来和大家简单聊一聊这个问题。</p><p>如果小伙伴们还不懂在传统的开发环境下如何进行文件上传，可以参考松哥之前发的文件上传教程：</p><ul><li><a href="https://mp.weixin.qq.com/s/OMgoUfH8lk8hDfuqWXGWTA" target="_blank" rel="noopener">Spring Boot + Vue，手把手教你做文件上传</a></li></ul><h2 id="1-什么是-FastDFS"><a href="#1-什么是-FastDFS" class="headerlink" title="1.什么是 FastDFS"></a>1.什么是 FastDFS</h2><h3 id="1-1-FastDFS-简介"><a href="#1-1-FastDFS-简介" class="headerlink" title="1.1 FastDFS 简介"></a>1.1 FastDFS 简介</h3><p>FastDFS 由淘宝的余庆大佬在 2008 年开源的一款轻量级分布式文件管理系统，FastDFS 用 C 语言实现，支持 Linux、FreeBSD、MacOS 等类 UNIX 系统。FastDFS 类似 google FS，属于应用级文件系统，不是通用的文件系统，只能通过专有 API 访问，目前提供了 C 和 Java SDK ，以及 PHP 扩展 SDK。</p><p>这款开源软件从发布至今，历经数十年，这款开源软件的生命力依然旺盛，在业界依然备受推崇，当然这也得益于作者一直在不断完善该软件。</p><p>FastDFS 专为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性，它可以看做是基于文件的 key/value 存储系统，key 为文件 ID，value 为文件内容，因此称作分布式文件存储服务更为合适。</p><h3 id="1-2-为什么需要-FastDFS"><a href="#1-2-为什么需要-FastDFS" class="headerlink" title="1.2 为什么需要 FastDFS"></a>1.2 为什么需要 FastDFS</h3><p>传统的企业级开发对于高并发要求不是很高，而且数据量可能也不大，在这样的环境下文件管理可能非常 Easy。</p><p>但是互联网应用访问量大、数据量大，在互联网应用中，我们必须考虑解决文件大容量存储和高性能访问的问题，而 FastDFS 就特别适合干这件事情，常见的图片存储、视频存储、文档存储等等我们都可以采用 FastDFS 来做。</p><h3 id="1-3-FastDFS-架构"><a href="#1-3-FastDFS-架构" class="headerlink" title="1.3 FastDFS 架构"></a>1.3 FastDFS 架构</h3><p>作为一款分布式文件管理系统，FastDFS 主要包括四个方面的功能：</p><ul><li>文件存储</li><li>文件同步</li><li>文件上传</li><li>文件下载</li></ul><p>这个方面的功能，基本上就能搞定我们常见的文件管理需求了。</p><p>下面这是一张来自 FastDFS 官网的系统架构图：</p><p><img src="http://img.itboyhub.com/2020/03/fastdfs-1.png" alt></p><p>从上面这张图中我们可以看到，FastDFS 架构包括 Tracker 和 Storage 两部分，看名字大概就能知道，Tracker 用来追踪文件，相当于是文件的一个索引，而 Storage 则用来保存文件。</p><p>我们上传文件的文件最终保存在 Storage 上，文件的元数据信息保存在 Tracker 上，通过 Tracker 可以实现对 Storage 的负载均衡。</p><p>Storage 一般会搭建成集群，一个 Storage Cluster 可以由多个组构成，不同的组之间不进行通信，一个组又相当于一个小的集群，组由多个 Storage Server 组成，组内的 Storage Server 会通过连接进行文件同步来保证高可用。</p><h2 id="2-FastDFS-安装"><a href="#2-FastDFS-安装" class="headerlink" title="2.FastDFS 安装"></a>2.FastDFS 安装</h2><p>介绍完 FastDFS 之后，相信小伙伴已经摩拳擦掌跃跃欲试了，接下来我们就来看下 FastDFS 的安装。</p><p>我这里为了测试方便，就不开启多台虚拟机了，Tracker 和 Storage 我将安装在同一台服务器上。</p><p>图片上传我们一般使用 FastDFS，图片上传成功之后，接下来的图片访问我们一般采用 Nginx，所以这里的安装我将从三个方面来介绍：</p><ul><li>Tracker 安装</li><li>Storage 安装</li><li>Nginx 安装</li></ul><h3 id="2-1-Tracker-安装"><a href="#2-1-Tracker-安装" class="headerlink" title="2.1 Tracker 安装"></a>2.1 Tracker 安装</h3><p>安装，我们首先需要准备一个环境两个库以及一个安装包。</p><p><strong>1.一个环境</strong></p><p>先来看一个环境，由于 FastDFS 采用 C 语言开发，所以在安装之前，如果没有 gcc 环境，需要先安装，安装命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><p><strong>2.两个库</strong></p><p>再来看两个库，由于 FastDFS 依赖 libevent 库，安装命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install libevent</span><br></pre></td></tr></table></figure><p>另一个库是 libfastcommon，这是 FastDFS 官方提供的，它包含了 FastDFS 运行所需要的一些基础库。</p><p>libfastcommon 下载地址：<a href="https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz" target="_blank" rel="noopener">https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz</a></p><blockquote><p>考虑到 GitHub 访问较慢，松哥已经把安装文件下载好了，放在百度网盘上，小伙伴们可以在松哥公众号后台回复 fastdfs 获取下载链接。</p></blockquote><p>将下载好的 libfastcommon 拷贝至 /usr/local/ 目录下，然后依次执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf V1.0.43.tar.gz</span><br><span class="line">cd libfastcommon-1.0.43/</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br></pre></td></tr></table></figure><p><strong>3.一个安装包</strong></p><p>接下来我们下载 Tracker，注意，由于 Tracker 和 Storage 是相同的安装包，所以下载一次即可（2.2 小节中不用再次下载）。</p><p>安装文件可以从 FastDFS 的 GitHub 仓库上下载，下载地址：<a href="https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz</a></p><blockquote><p>考虑到 GitHub 访问较慢，松哥已经把安装文件下载好了，放在百度网盘上，小伙伴们可以在松哥公众号后台回复 fastdfs 获取下载链接。</p></blockquote><p>下载成功后，将下载文件拷贝到 /usr/local 目录下，然后依次执行如下命令安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf V6.06.tar.gz</span><br><span class="line">cd fastdfs-6.06/</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br></pre></td></tr></table></figure><p>安装成功后，执行如下命令，将安装目录内 conf 目录下的配置文件拷贝到 /etc/fdfs 目录下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd conf/</span><br><span class="line">cp ./* /etc/fdfs/</span><br></pre></td></tr></table></figure><p><strong>4.配置</strong></p><p>接下来进入 /etc/fdfs/ 目录下进行配置：</p><p>打开 tracker.conf 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi tracker.conf</span><br></pre></td></tr></table></figure><p>修改如下配置：</p><p><img src="http://img.itboyhub.com/2020/03/fastdfs-2.png" alt></p><p>默认端口是 22122，可以根据实际需求修改，我这里就不改了。然后下面配置一下元数据的保存目录（注意目录要存在）。</p><p><strong>5.启动</strong></p><p>接下来执行如下命令启动 Tracker：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start</span><br></pre></td></tr></table></figure><p>如此之后，我们的 Tracker 就算安装成功了。</p><h3 id="2-2-Storage-安装"><a href="#2-2-Storage-安装" class="headerlink" title="2.2 Storage 安装"></a>2.2 Storage 安装</h3><p>简单起见，这里我们搭建一个 Storage 实例即可。Storage 安装也需要 libevent 和 libfastcommon，这两个库的安装参考上文，这里我不在细说。</p><p>Storage 本身的安装，也和 Tracker 一致，执行命令也都一样，因为我这里将 Tracker 和 Storage 安装在同一台服务器上，所以不用再执行安装命令了（相当于安装 Tracker 时已经安装了 Storage 了）。</p><p>唯一要做的，就是进入到 /etc/fdfs 目录下，配置 Storage：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi storage.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-3.png" alt></p><p>这里一共配置三个地方，分别是 base_path、store_path0 以及 tracker_server ，tracker_server 模板有两个地址，我们这里只有一个，配置完成后，记得注释掉另外一个不用的。</p><p>配置完成后，执行如下命令启动 Storage：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start</span><br></pre></td></tr></table></figure><p>这两个启动完成后，现在就可以做文件的上传了，但是一般如果是图片文件，我们还需要提供一个图片的访问功能，目前来说最佳方案当然是 Nginx 了，所以我们这里连同 Nginx 一起配置好，再来做测试。</p><h3 id="2-3-Nginx-安装"><a href="#2-3-Nginx-安装" class="headerlink" title="2.3 Nginx 安装"></a>2.3 Nginx 安装</h3><p>Nginx 可以算是 FastDFS 的重要搭档。</p><p>Nginx 的安装分为两个步骤：</p><ul><li>安装 Nginx</li><li>首先在 Storage 下安装 fastdfs-nginx-module</li></ul><p>第一步简单，松哥之前专门写过一篇文章扫盲 Nginx，所以 Nginx 安装大家直接参考这里：<a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></p><p>接下来看第二步。</p><p>首先下载 fastdfs-nginx-module，下载地址：<a href="https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz</a></p><blockquote><p>考虑到 GitHub 访问较慢，松哥已经把安装文件下载好了，放在百度网盘上，小伙伴们可以在松哥公众号后台回复 fastdfs 获取下载链接。</p></blockquote><p>下载完成后，将下载的文件拷贝到 /usr/local 目录下。然后进入 /usr/local 目录，分别执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf V1.22.tar.gz</span><br></pre></td></tr></table></figure><p>然后将 <code>/usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf</code> 文件拷贝到 <code>/etc/fdfs/</code> 目录下，并修改该文件的内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fdfs/mod_fastdfs.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-4.png" alt></p><p>接下来，回到第一步下载的 nginx 安装文件的解压目录中，执行如下命令，重新配置编译安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-module=/usr/local/fastdfs-nginx-module-1.22/src</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装完成后，修改 nginx 的配置文件，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-5.png" alt></p><p>在这里配置 nginx 请求转发。</p><p>配置完成后，启动 nginx，看到如下日志，表示 nginx 启动成功：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_fastdfs_set pid=9908</span><br></pre></td></tr></table></figure><p><strong>疑问：fastdfs-nginx-module 有啥用</strong></p><p>看了整个安装过程之后，很多小伙伴有疑问，到头来还是 nginx 本身直接找到了图片文件目录，fastdfs-nginx-module 到底有啥用？</p><p>前面我们说过，Storage 由很多组构成，每个组又是一个小的集群，在每一个组里边，数据会进行同步，但是如果数据还没同步，这个时候就有请求发来了，该怎么办？此时fastdfs-nginx-module 会帮助我们直接从源 Storage 上获取文件。</p><p>安装成功了。</p><h2 id="3-Java-客户端调用"><a href="#3-Java-客户端调用" class="headerlink" title="3.Java 客户端调用"></a>3.Java 客户端调用</h2><p>安装成功后，接下来我们就用 Java 客户端来测试一下文件上传下载。</p><p>首先我们来创建一个普通的 Maven 工程，添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.oschina.zcx7878<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastdfs-client-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.27.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在项目的 resources 目录下添加 FastDFS 的配置文件 fastdfs-client.properties，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fastdfs.connect_timeout_in_seconds = 5</span><br><span class="line">fastdfs.network_timeout_in_seconds = 30</span><br><span class="line">fastdfs.charset = UTF-8</span><br><span class="line">fastdfs.http_anti_steal_token = false</span><br><span class="line">fastdfs.http_secret_key = FastDFS1234567890</span><br><span class="line">fastdfs.http_tracker_http_port = 80</span><br><span class="line">fastdfs.tracker_servers = 192.168.91.128:22122</span><br><span class="line">fastdfs.connection_pool.enabled = true</span><br><span class="line">fastdfs.connection_pool.max_count_per_entry = 500</span><br><span class="line">fastdfs.connection_pool.max_idle_time = 3600</span><br><span class="line">fastdfs.connection_pool.max_wait_time_in_ms = 1000</span><br></pre></td></tr></table></figure><p>这里的配置基本上都能见名知义，我就不挨个解释了。这里先配置下 fastdfs.tracker_servers，这是 Tracker 的地址，根据实际情况配置即可。</p><p>fastdfs.http_secret_key 配置这里先不用管它，后面我会跟大家解释。</p><h3 id="3-1-文件上传"><a href="#3-1-文件上传" class="headerlink" title="3.1 文件上传"></a>3.1 文件上传</h3><p>配置完成后，先来看文件上传，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testUpload</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        ClientGlobal.initByProperties(<span class="hljs-string">"fastdfs-client.properties"</span>);</span><br><span class="line">        TrackerClient tracker = <span class="hljs-keyword">new</span> TrackerClient();</span><br><span class="line">        TrackerServer trackerServer = tracker.getConnection();</span><br><span class="line">        StorageServer storageServer = <span class="hljs-keyword">null</span>;</span><br><span class="line">        StorageClient1 client = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">        NameValuePair nvp[] = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-comment">//上传到文件系统</span></span><br><span class="line">        String fileId = client.upload_file1(<span class="hljs-string">"C:\\Users\\javaboy\\Pictures\\picpick\\1.png"</span>, <span class="hljs-string">"png"</span>,</span><br><span class="line">                nvp);</span><br><span class="line">        logger.info(fileId);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，首先加载配置文件，然后构造一个 TrackerClient 对象，接着再根据这个对象获取到一个 TrackerServer，然后创建一个 StorageClient1 实例。NameValuePair 中保存的是文件的元数据信息，如果有的话，就以 key/value 的方式来设置，如果没有的话，直接给一个 null 即可。</p><p>最后，调用 client 的 upload_file1 方法上传文件，第一个参数是文件路径，第二个参数是文件的扩展名，第三个参数就是文件的元数据信息，这个方法的返回值，就是上传文件的访问路径。执行该方法，打印日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-02-29 17:46:03.017  INFO 6184 --- [           main] o.j.fastdfs.FastdfsApplicationTests      : group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png</span><br></pre></td></tr></table></figure><p>group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png 就是文件的路径，此时，在浏览器中输入 <a href="http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png" target="_blank" rel="noopener">http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png</a> 就可以看到上传的图片了。</p><h3 id="3-2-文件下载"><a href="#3-2-文件下载" class="headerlink" title="3.2 文件下载"></a>3.2 文件下载</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testDownload</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        ClientGlobal.initByProperties(<span class="hljs-string">"fastdfs-client.properties"</span>);</span><br><span class="line">        TrackerClient tracker = <span class="hljs-keyword">new</span> TrackerClient();</span><br><span class="line">        TrackerServer trackerServer = tracker.getConnection();</span><br><span class="line">        StorageServer storageServer = <span class="hljs-keyword">null</span>;</span><br><span class="line">        StorageClient1 client = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] bytes = client.download_file1(<span class="hljs-string">"group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\javaboy\\Pictures\\picpick\\666.png"</span>));</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就很好理解了，直接调用 download_file1 方法获取到一个 byte 数组，然后通过 IO 流写出到本地文件即可。</p><h2 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4.安全问题"></a>4.安全问题</h2><p>现在，任何人都可以访问我们服务器上传文件，这肯定是不行的，这个问题好解决，加一个上传时候的令牌即可。</p><p>首先我们在服务端开启令牌校验：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fdfs/http.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-6.png" alt></p><p>配置完成后，记得重启服务端：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure><p>接下来，在前端准备一个获取令牌的方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ts = (<span class="hljs-keyword">int</span>) Instant.now().getEpochSecond();</span><br><span class="line">    String token = ProtoCommon.getToken(<span class="hljs-string">"M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png"</span>, ts, <span class="hljs-string">"FastDFS1234567890"</span>);</span><br><span class="line">    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="hljs-string">"?token="</span>).append(token);</span><br><span class="line">    sb.append(<span class="hljs-string">"&amp;ts="</span>).append(ts);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们主要是根据 ProtoCommon.getToken 方法来获取令牌，注意这个方法的第一个参数是你要访问的文件 id，<strong>注意，这个地址里边不包含 group，千万别搞错了；</strong>第二个参数是时间戳，第三个参数是密钥，密钥要和服务端的配置一致。</p><p>将生成的字符串拼接，追加到访问路径后面，如：<code>http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png?token=7e329cc50307000283a3ad3592bb6d32&amp;ts=1582975854</code>。<strong>此时访问路径里边如果没有令牌，会访问失败。</strong></p><p>好了，大功告成！下次和大家讲我如何在 Spring Boot 中玩这个东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文上周日发过，但是有小伙伴看了之后表示 FastDFS 老是安装失败！松哥这犟脾气，绝对不能忍，一定要教会大家，这不赶紧抽空录了一个视频手把手教大家安装 FastDFS，并且实现通过 Java 代码上传/下载文件的功能。小伙伴们一起来看下，这次一定要学会呀！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="FastDFS" scheme="http://www.javaboy.org/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>程序员写书到底赚钱吗</title>
    <link href="http://www.javaboy.org/2020/0311/book.html"/>
    <id>http://www.javaboy.org/2020/0311/book.html</id>
    <published>2020-03-11T08:55:17.000Z</published>
    <updated>2020-03-12T11:02:25.220Z</updated>
    
    <content type="html"><![CDATA[<p>年前的时候松哥发了一篇文章，说新书交稿后入手了一台 MacBook Pro（<a href="https://mp.weixin.qq.com/s/LA8_FPp19MumWNdLg9ljtQ" target="_blank" rel="noopener">MacBook Pro 入手一年了，到底香不香？</a>），于是有小伙伴问松哥，出书是不是赚翻了？</p><a id="more"></a><p>老实说，这本书到现在赚的钱，买一台 MacBook Pro 肯定是够了，但是你要说赚翻了，我想这里肯定存在一些误解。今天我就来和大家聊一聊程序员的出书流程，收入结算，以及如果你也想在未来有一天自己的书摆在大学的图书馆，你现在该做些什么。</p><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><p>出书这个事情，绝非一日之功。如果你有这方面的计划，那么现在就开始写博客吧。写博客有两方面的好处：</p><ol><li>自己做技术积累，文字积累，写作功底积累</li><li>打造个人品牌，被出版社的编辑发掘</li></ol><p>技术积累，这个好说，你要写书，你首先肚子里得有货，那这就是一个长期积累的过程。写作功底的积累，这个不是说要写的多么优美，毕竟写技术图书不是写散文，把一个复杂的技术点，能够清晰明了的讲出来，让读者一看就懂，这才是关键。我记得我在 2016 年写过一个读书笔记，有个读者给了下面一句评论：</p><p><img src="http://img.itboyhub.com/2020/03/book-1.png" alt></p><p>这个评价我看到还是蛮开心的，技术上的事，自己懂是一回事，教会别人又是另一回事。所以如果你打算未来也能有一本自己的书，那么就开始写博客吧，学着去把一个复杂的知识点细化，然后把它讲清楚，让别人能够看懂看明白。</p><p>写博客的另外一个好处，就是打造个人品牌，使自己更易被出版社编辑发掘。</p><p>现在的出版社基本上都是自负盈亏的，所以对出版社来说，他肯定会考虑一本书是否能够盈利，一本书要能够盈利，那么他在选作者的时候，会重点关注两方面：</p><ol><li>作者是否在某一个技术领域深耕多年，对该领域有一些自己的见解</li><li>作者是否自带流量</li></ol><p>这两点中，第一点比第二点重要。那么如何让出版社的编辑知道你在某一领域深耕多年呢？这就要看平时的日常积累了，其实也就是你的博客。至于第二点，如果作者自带流量，那么书出版之后，销售压力要小很多，所以这也算是一个优势吧。我 2018 年写书的时候，公众号还被我晾在一边，根本就没有流量，但是最终书也出版了，所以第二点是锦上添花。</p><h2 id="如何让出版社找到我"><a href="#如何让出版社找到我" class="headerlink" title="如何让出版社找到我"></a>如何让出版社找到我</h2><p>家有梧桐树，引得凤凰来。</p><p>各大出版社的编辑，就像侦探一样，潜伏在各大博客平台上，像 CSDN、博客园、慕课手记、sf 等，你在这些平台上写博客，就会被各大出版社的编辑注意到，如果没联系你，可能时机还未成熟，也可能是你火候未到。不过只要你坚持写下去，机会肯定是有的，你要是不写，那机会几乎为 0 了。</p><p>除了出版社的编辑潜伏在博客平台之外，还有一些第三方的出书公司也潜伏在博客平台，出书公司我没合作过，也不太懂他们的流程。他们相当于是中介，最终也是和出版社合作的，只不过你自己不用接触出版社，直接和他们对接即可，他们大多潜伏在慕课手记上。但是我不太建议和第三方公司合作，辛辛苦苦大半年，到头来竟然是和一个中介合作。</p><p>所以这个问题大家不用担心，只要你坚持写博客做积累，该来的总会来的。</p><h2 id="稿费怎么算"><a href="#稿费怎么算" class="headerlink" title="稿费怎么算"></a>稿费怎么算</h2><p>稿费这块，有多种结算方式，给大家看看我当时签订的合同：</p><p><img src="http://img.itboyhub.com/2020/03/book-3.png" alt></p><p>可以看到，稿费有多种结算方式，但是一般来说，大部分都是选择第一种。</p><p>其实稿费这块，我觉得作者议价空间很有限，大部分出版社给到作者的稿酬都是 8%。有的小伙伴可能觉得这也太低了，但是目前的图书市场就是这样。作为一个参考，1991 年北京三联书店签下金庸 15 部武侠小说在内地 10 年的出版权，当时的版税率是 15%。</p><p>现在写书你只要写就行了，写完之后，剩下的事情都是交给出版社去做，三审三校、排版印刷、物流、铺货，销售渠道、营销等等，这些都要花钱，而这些你都不用管，出版社会做好。</p><p>所以，一本售价 ¥70 的书，到作者手上就是 ¥5.6 ，这还不算个人所得税，除去个人所得税，这个数字还要更低一些。</p><p>现在技术图书，特别是一些热点技术相关的图书，销量过万基本上就算是畅销书了，这样算下来，一本书的稿费可能就是程序员一两个月的薪水而已。</p><p>所以，如果为了赚钱，还不如去平台上开网课（例如 GitChat 之类），这种虽然平台也要抽成，但是作者的收益可能还略高于出书。</p><h2 id="出版要多久"><a href="#出版要多久" class="headerlink" title="出版要多久"></a>出版要多久</h2><p>写作的时间这个不好说，每个人的效率都不太一样，我这里主要说交稿之后的时间。正常来说交稿之后，出版社那边的流程大概要走 3 个月左右，然后书就可以上市销售了，一些特殊情况，出版社可能会赶工，这样出版时间可能还会压缩至两个月左右。</p><h2 id="出版社的选择"><a href="#出版社的选择" class="headerlink" title="出版社的选择"></a>出版社的选择</h2><p>国内虽然出版社众多，不过每家出版社都有自己擅长的领域，技术图书一般就是清华大学出版社、机械工业出版社、电子工业出版社、人民邮电出版社等几家，在这些出版社中，清华社的教材渠道做的很好，也就是说他打通了和学校之间的渠道，在清华社出版的书容易被高校选做教材，其他出版社这方面稍弱，当然这只是相对而言，每家出版社都有自己擅长的地方，你所了解的一些大名鼎鼎的书，一方面和书的质量有关，另一方面也和出版社的营销力度有关。</p><h2 id="大致的出版流程"><a href="#大致的出版流程" class="headerlink" title="大致的出版流程"></a>大致的出版流程</h2><p>一般出版的流程是这样，首先作者提交选题单（选题单包含作者信息登记表、书的目录大纲以及样章等），然后出版社那边的流程主要有<strong>选题论证-&gt;选题审批-&gt;签订出版合同-&gt;自己写作-&gt;交稿-&gt;排版-&gt;三审三校-&gt;书稿送作者审校与统稿-&gt;出版</strong>。</p><p>说了这么多，其实前两点是最重要的，做好前面两点，后面都是很容易的事情了。感兴趣的小伙伴可以看看，即使不出书，感受一把被约稿也是不错的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不过老实说，写书的意义不在于赚钱。仅仅从赚钱的角度来说，出网课可能更划算一些。但是如果想给自己的职业生涯留点东西，写书意义大于出网课。最后，建议小伙伴们看看松哥之前这篇文章：<a href="https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA" target="_blank" rel="noopener">如果你没写过博客，现在就是你写博客的最佳时机</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;年前的时候松哥发了一篇文章，说新书交稿后入手了一台 MacBook Pro（&lt;a href=&quot;https://mp.weixin.qq.com/s/LA8_FPp19MumWNdLg9ljtQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MacBook Pro 入手一年了，到底香不香？&lt;/a&gt;），于是有小伙伴问松哥，出书是不是赚翻了？&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="程序员" scheme="http://www.javaboy.org/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手带你捋一遍 Spring Security 登录流程</title>
    <link href="http://www.javaboy.org/2020/0310/springsecurity-login.html"/>
    <id>http://www.javaboy.org/2020/0310/springsecurity-login.html</id>
    <published>2020-03-10T08:55:04.000Z</published>
    <updated>2020-03-12T10:32:30.812Z</updated>
    
    <content type="html"><![CDATA[<p>为什么想和大家捋一捋 Spring Security 登录流程呢？这是因为之前小伙伴们的一个提问：如何在 Spring Security 中动态修改用户信息？</p><a id="more"></a><p>如果你搞清楚了 Spring Security 登录流程，这其实不是问题。但是在很多新手小伙伴多次询问之后，松哥还是决定来和大家仔细捋一捋这个问题。</p><p>我们先来大致描述一下问题场景：</p><blockquote><p>你在服务端的安全管理使用了 Spring Security，用户登录成功之后，Spring Security 帮你把用户信息保存在 Session 里，但是具体保存在哪里，要是不深究你可能就不知道， 这带来了一个问题，如果用户在前端操作修改了当前用户信息，在不重新登录的情况下，如何获取到最新的用户信息？这就是松哥今天要和搭建介绍的问题。</p></blockquote><h2 id="1-无处不在的-Authentication"><a href="#1-无处不在的-Authentication" class="headerlink" title="1.无处不在的 Authentication"></a>1.无处不在的 Authentication</h2><p>玩过 Spring Security 的小伙伴都知道，在 Spring Security 中有一个非常重要的对象叫做 Authentication，我们可以在任何地方注入 Authentication 进而获取到当前登录用户信息，Authentication 本身是一个接口，它有很多实现类：</p><p><img src="http://img.itboyhub.com/2020/03/authentication-1.png" alt></p><p>在这众多的实现类中，我们最常用的就是 UsernamePasswordAuthenticationToken 了，但是当我们打开这个类的源码后，却发现这个类平平无奇，他只有两个属性、两个构造方法以及若干个 get/set 方法；当然，他还有更多属性在它的父类上。</p><p>但是从它仅有的这两个属性中，我们也能大致看出，这个类就保存了我们登录用户的基本信息。那么我们的登录信息是如何存到这两个对象中的？这就要来梳理一下登录流程了。</p><h2 id="2-登录流程"><a href="#2-登录流程" class="headerlink" title="2.登录流程"></a>2.登录流程</h2><p>在 Spring Security 中，认证与授权的相关校验都是在一系列的过滤器链中完成的，在这一系列的过滤器链中，和认证相关的过滤器就是 UsernamePasswordAuthenticationFilter，篇幅问题，我这里列出来该类中几个重要方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> <span class="hljs-keyword">extends</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/login"</span>, <span class="hljs-string">"POST"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">String username = obtainUsername(request);</span><br><span class="line">String password = obtainPassword(request);</span><br><span class="line">UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">username, password);</span><br><span class="line">setDetails(request, authRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainPassword</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getParameter(passwordParameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainUsername</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getParameter(usernameParameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;</span><br><span class="line">authRequest.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这段源码我们可以看出：</p><ol><li>首先通过 obtainUsername 和 obtainPassword 方法提取出请求里边的用户名/密码出来，提取方式就是 request.getParameter ，这也是为什么 Spring Security 中默认的表单登录要通过 key/value 的形式传递参数，而不能传递 JSON 参数，如果像传递 JSON 参数，修改这里的逻辑即可。</li><li>获取到请求里传递来的用户名/密码之后，接下来就构造一个 UsernamePasswordAuthenticationToken 对象，传入 username 和 password，username 对应了 UsernamePasswordAuthenticationToken 中的 principal 属性，而 password 则对应了它的 credentials 属性。</li><li>接下来 setDetails 方法给 details 属性赋值，UsernamePasswordAuthenticationToken 本身是没有 details 属性的，这个属性在它的父类 AbstractAuthenticationToken 中。details 是一个对象，这个对象里边放的是 WebAuthenticationDetails 实例，该实例主要描述了两个信息，请求的 remoteAddress 以及请求的 sessionId。</li><li>最后一步，就是调用 authenticate 方法去做校验了。</li></ol><p>好了，从这段源码中，大家可以看出来请求的各种信息基本上都找到了自己的位置，找到了位置，这就方便我们未来去获取了。</p><p>接下来我们再来看请求的具体校验操作。</p><p>在前面的 attemptAuthentication 方法中，该方法的最后一步开始做校验，校验操作首先要获取到一个 AuthenticationManager，这里拿到的是 ProviderManager ，所以接下来我们就进入到 ProviderManager 的 authenticate 方法中，当然这个方法也比较长，我这里仅仅摘列出来几个重要的地方：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line"><span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">copyDetails(authentication, result);</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span> &amp;&amp; parent != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">result = parentResult = parent.authenticate(authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">&amp;&amp; (result <span class="hljs-keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (parentResult == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> lastException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就比较魔幻了，因为几乎关于认证的重要逻辑都将在这里完成：</p><ol><li>首先获取 authentication 的 Class，判断当前 provider 是否支持该 authentication。</li><li>如果支持，则调用 provider 的 authenticate 方法开始做校验，校验完成后，会返回一个新的 Authentication。一会来和大家捋这个方法的具体逻辑。</li><li>这里的 provider 可能有多个，如果 provider 的 authenticate 方法没能正常返回一个 Authentication，则调用 provider 的 parent 的 authenticate 方法继续校验。</li><li>copyDetails 方法则用来把旧的 Token 的 details 属性拷贝到新的 Token 中来。</li><li>接下来会调用 eraseCredentials 方法擦除凭证信息，也就是你的密码，这个擦除方法比较简单，就是将 Token 中的 credentials 属性置空。</li><li>最后通过 publishAuthenticationSuccess 方法将登录成功的事件广播出去。</li></ol><p>大致的流程，就是上面这样，在 for 循环中，第一次拿到的 provider 是一个 AnonymousAuthenticationProvider，这个 provider 压根就不支持 UsernamePasswordAuthenticationToken，也就是会直接在 provider.supports 方法中返回 false，结束 for 循环，然后会进入到下一个 if 中，直接调用 parent 的 authenticate 方法进行校验。</p><p>而 parent 就是 ProviderManager，所以会再次回到这个 authenticate 方法中。再次回到 authenticate 方法中，provider 也变成了 DaoAuthenticationProvider，这个 provider 是支持 UsernamePasswordAuthenticationToken 的，所以会顺利进入到该类的 authenticate 方法去执行，而 DaoAuthenticationProvider 继承自 AbstractUserDetailsAuthenticationProvider 并且没有重写 authenticate 方法，所以 我们最终来到 AbstractUserDetailsAuthenticationProvider#authenticate 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">String username = (authentication.getPrincipal() == <span class="hljs-keyword">null</span>) ? <span class="hljs-string">"NONE_PROVIDED"</span></span><br><span class="line">: authentication.getName();</span><br><span class="line">user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line">Object principalToReturn = user;</span><br><span class="line"><span class="hljs-keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">principalToReturn = user.getUsername();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑就比较简单了：</p><ol><li>首先从 Authentication 提取出登录用户名。</li><li>然后通过拿着 username 去调用 retrieveUser 方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的 loadUserByUsername 方法，所以这里返回的 user 其实就是你的登录对象，可以参考微人事的 org/javaboy/vhr/service/HrService.java#L34。</li><li>接下来调用 preAuthenticationChecks.check 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等。</li><li>additionalAuthenticationChecks 方法则是做密码比对的，好多小伙伴好奇 Spring Security 的密码加密之后，是如何进行比较的，看这里就懂了，因为比较的逻辑很简单，我这里就不贴代码出来了。</li><li>最后在 postAuthenticationChecks.check 方法中检查密码是否过期。</li><li>接下来有一个 forcePrincipalAsString 属性，这个是是否强制将 Authentication 中的 principal 属性设置为字符串，这个属性我们一开始在 UsernamePasswordAuthenticationFilter 类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多。</li><li>最后，通过 createSuccessAuthentication 方法构建一个新的 UsernamePasswordAuthenticationToken。</li></ol><p>好了，那么登录的校验流程现在就基本和大家捋了一遍了。那么接下来还有一个问题，登录的用户信息我们去哪里查找？</p><h2 id="3-用户信息保存"><a href="#3-用户信息保存" class="headerlink" title="3.用户信息保存"></a>3.用户信息保存</h2><p>要去找登录的用户信息，我们得先来解决一个问题，就是上面我们说了这么多，这一切是从哪里开始被触发的？</p><p>我们来到 UsernamePasswordAuthenticationFilter 的父类 AbstractAuthenticationProcessingFilter 中，这个类我们经常会见到，因为很多时候当我们想要在 Spring Security 自定义一个登录验证码或者将登录参数改为 JSON 的时候，我们都需自定义过滤器继承自 AbstractAuthenticationProcessingFilter ，毫无疑问，UsernamePasswordAuthenticationFilter#attemptAuthentication 方法就是在 AbstractAuthenticationProcessingFilter 类的 doFilter 方法中被触发的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">Authentication authResult;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看到，当 attemptAuthentication 方法被调用时，实际上就是触发了 UsernamePasswordAuthenticationFilter#attemptAuthentication 方法，当登录抛出异常的时候，unsuccessfulAuthentication 方法会被调用，而当登录成功的时候，successfulAuthentication 方法则会被调用，那我们就来看一看 successfulAuthentication 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"><span class="hljs-comment">// Fire event</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(</span><br><span class="line">authResult, <span class="hljs-keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有一段很重要的代码，就是 <code>SecurityContextHolder.getContext().setAuthentication(authResult);</code> ，登录成功的用户信息被保存在这里，也就是说，在任何地方，如果我们想获取用户登录信息，都可以从 <code>SecurityContextHolder.getContext()</code> 中获取到，想修改，也可以在这里修改。</p><p>最后大家还看到有一个 successHandler.onAuthenticationSuccess，这就是我们在 SecurityConfig 中配置登录成功回调方法，就是在这里被触发的，这块大家也可以参考微人事里边的配置 <code>org/javaboy/vhr/config/SecurityConfig</code>。</p><p>真相大白！</p><h2 id="4-视频讲解"><a href="#4-视频讲解" class="headerlink" title="4.视频讲解"></a>4.视频讲解</h2><p>最后，松哥也录了一个简单的视频教程，来和大家捋一捋：</p><p>并且基于这个知识点，我给微人事添加了一个个人中心的功能，一起来看下：</p><iframe src="//player.bilibili.com/player.html?aid=95352488&cid=162784593&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>好了，不知道小伙伴们有没有学会呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么想和大家捋一捋 Spring Security 登录流程呢？这是因为之前小伙伴们的一个提问：如何在 Spring Security 中动态修改用户信息？&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+Vue+FastDFS 实现前后端分离文件上传</title>
    <link href="http://www.javaboy.org/2020/0309/springboot-vue-fastdfs.html"/>
    <id>http://www.javaboy.org/2020/0309/springboot-vue-fastdfs.html</id>
    <published>2020-03-09T08:54:49.000Z</published>
    <updated>2020-03-12T11:10:36.542Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring Boot 前后端分离环境下做文件上传，这个松哥之前在公众号上发过一篇文章来和大家介绍，但是在之前的文章中，为了省事，文件我是直接保存在本地临时目录下的，这带来了另外一个问题，就是项目重启之后，临时目录失效，之前上传的文件又访问不到了。</p><a id="more"></a><p>很显然在实际开发中我们不会这么搞！在生产环境中，我们可以搭建独立的文件服务器，结合 FastDFS 还可以搭建独立的分布式文件服务系统，这样文件管理服务器不仅方便管理还易于扩展，也解决了前面所说的临时目录失效的问题。</p><p>今天松哥想和大家聊一下在微人事中，我是如何通过 Spring Boot + Vue + FastDFS 来实现前后端分离文件上传的。</p><p>学习本文需要大家先搞定 FastDFS，如果大家对于 FastDFS 还不太熟悉，可以先看看松哥之前发的视频教程：</p><ul><li><a href="https://mp.weixin.qq.com/s/onZmdgi9kZw0JdAtrNYmow" target="_blank" rel="noopener">听说你 FastDFS 老安装失败，这能忍？松哥一定要帮你搞定！</a></li></ul><p>如果大家搞定了 FastDFS ，就直接来看今天的文件上传吧：</p><iframe src="//player.bilibili.com/player.html?aid=94847558&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width:800px;height:600px"> </iframe><p>好了，不知道小伙伴们有没有看懂呢？视频中的代码我已经提交到 GitHub 了：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>。赶紧试一把！如果大家对松哥录制的完整的微人事视频教程感兴趣，可以戳这里：<a href="https://mp.weixin.qq.com/s/8FmgtWyz6HUIbF4smXQOwQ" target="_blank" rel="noopener">Spring Boot + Vue 视频教程喜迎大结局，西交大的老师竟然都要来一套！</a></p><p>视频看完了，松哥再把理论也和大家捋一捋。</p><p>在 Vue.js 中，如果网络请求使用 axios ，并且使用了 ElementUI 库，那么一般来说，文件上传有两种不同的实现方案：</p><ol><li>通过 Ajax 实现文件上传</li><li>通过 ElementUI 里边的 Upload 组件实现文件上传</li></ol><p>两种方案，各有优缺点，我们分别来看。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>首先我们需要一点点准备工作，就是在后端提供一个文件上传接口，这是一个普通的 Spring Boot 项目，如下（视这里来个简单的服务端代码，视频中的代码大家可以从 GitHub 上获取）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"/yyyy/MM/dd/"</span>);</span><br><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/import"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">importData</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/upload"</span>) + format;</span><br><span class="line">    File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String oldName = file.getOriginalFilename();</span><br><span class="line">    String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">    file.transferTo(<span class="hljs-keyword">new</span> File(folder,newName));</span><br><span class="line">    String url = req.getScheme() + <span class="hljs-string">"://"</span> + req.getServerName() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/upload"</span> + format + newName;</span><br><span class="line">    System.out.println(url);</span><br><span class="line">    <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"上传成功!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的文件上传比较简单，上传的文件按照日期进行归类，使用 UUID 给文件重命名。</p><p><strong>这里为了简化代码，我省略掉了异常捕获，上传结果直接返回成功，后端代码大伙可根据自己的实际情况自行修改。</strong></p><h2 id="2-Ajax-上传"><a href="#2-Ajax-上传" class="headerlink" title="2.Ajax 上传"></a>2.Ajax 上传</h2><p>在 Vue 中，通过 Ajax 实现文件上传，方案和传统 Ajax 实现文件上传基本上是一致的，唯一不同的是查找元素的方式。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"myfile"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"importData"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"success"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"mini"</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">"el-icon-upload2"</span>&gt;</span>导入数据<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，首先提供一个文件导入 input 组件，再来一个导入按钮，在导入按钮的事件中来完成导入的逻辑。</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">importData() &#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> myfile = <span class="hljs-keyword">this</span>.$refs.myfile;</span><br><span class="line">  <span class="hljs-keyword">let</span> files = myfile.files;</span><br><span class="line">  <span class="hljs-keyword">let</span> file = files[<span class="hljs-number">0</span>];</span><br><span class="line">  <span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> FormData();</span><br><span class="line">  formData.append(<span class="hljs-string">"file"</span>, file);</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadFileRequest(<span class="hljs-string">"/system/basic/jl/import"</span>,formData).then(<span class="hljs-function"><span class="hljs-params">resp</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (resp) &#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(resp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这段上传核心逻辑，解释如下：</p><ol><li>首先利用 Vue 中的 $refs 查找到存放文件的元素。</li><li>type 为 file 的 input 元素内部有一个 files 数组，里边存放了所有选择的 file，由于文件上传时，文件可以多选，因此这里拿到的 files 对象是一个数组。</li><li>从 files 对象中，获取自己要上传的文件，由于这里是单选，所以其实就是数组中的第一项。</li><li>构造一个 FormData ，用来存放上传的数据,FormData 不可以像 Java 中的 StringBuffer 使用链式配置。</li><li>构造好 FromData 后，就可以直接上传数据了，FormData 就是要上传的数据。</li><li>文件上传注意两点：1. 请求方法为 post，2. 设置 <code>Content-Type</code> 为  <code>multipart/form-data</code> 。</li></ol><p>这种文件上传方式，实际上就是传统的 Ajax 上传文件，和大家常见的 jQuery 中写法不同的是，这里元素查找的方式不一样（实际上元素查找也可以按照JavaScript 中原本的写法来实现），其他写法一模一样。这种方式是一个通用的方式，和使用哪一种前端框架无关。最后再和大家来看下封装的上传方法：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> uploadFileRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> axios(&#123;</span><br><span class="line">    method: <span class="hljs-string">'post'</span>,</span><br><span class="line">    url: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">    data: params,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'multipart/form-data'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这几步的配置后，前端就算上传完成了，可以进行文件上传了。</p><h2 id="3-使用-Upload-组件"><a href="#3-使用-Upload-组件" class="headerlink" title="3.使用 Upload 组件"></a>3.使用 Upload 组件</h2><p>如果使用 Upload ，则需要引入 ElementUI，所以一般建议，如果使用了 ElementUI 做 UI 控件的话，则可以考虑使用 Upload 组件来实现文件上传，如果没有使用 ElementUI 的话，则不建议使用 Upload 组件，至于其他的 UI 控件，各自都有自己的文件上传组件，具体使用可以参考各自文档。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">el-upload</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">style</span>=<span class="hljs-string">"display: inline"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:show-file-list</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:on-success</span>=<span class="hljs-string">"onSuccess"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:on-error</span>=<span class="hljs-string">"onError"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:before-upload</span>=<span class="hljs-string">"beforeUpload"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">action</span>=<span class="hljs-string">"/system/basic/jl/import"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"mini"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"success"</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">"!enabledUploadBtn"</span> <span class="hljs-attr">:icon</span>=<span class="hljs-string">"uploadBtnIcon"</span>&gt;</span>&#123;&#123;btnText&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>show-file-list 表示是否展示上传文件列表，默认为 true，这里设置为不展示。</li><li>before-upload 表示上传之前的回调，可以在该方法中，做一些准备工作，例如展示一个进度条给用户 。</li><li>on-success 和 on-error 分别表示上传成功和失败时候的回调，可以在这两个方法中，给用户一个相应的提示，如果有进度条，还需要在这两个方法中关闭进度条。</li><li>action 指文件上传地址。</li><li>上传按钮的点击状态和图标都设置为变量 ，在文件上传过程中，修改上传按钮的点击状态为不可点击，同时修改图标为一个正在加载的图标 loading。</li><li>上传的文本也设为变量，默认上传 button 的文本是 <code>数据导入</code> ，当开始上传后，将找个 button 上的文本修改为 <code>正在导入</code>。</li></ol><p>相应的回调如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onSuccess(response, file, fileList) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.enabledUploadBtn = <span class="hljs-literal">true</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadBtnIcon = <span class="hljs-string">'el-icon-upload2'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.btnText = <span class="hljs-string">'数据导入'</span>;</span><br><span class="line">&#125;,</span><br><span class="line">onError(err, file, fileList) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.enabledUploadBtn = <span class="hljs-literal">true</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadBtnIcon = <span class="hljs-string">'el-icon-upload2'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.btnText = <span class="hljs-string">'数据导入'</span>;</span><br><span class="line">&#125;,</span><br><span class="line">beforeUpload(file) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.enabledUploadBtn = <span class="hljs-literal">false</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadBtnIcon = <span class="hljs-string">'el-icon-loading'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.btnText = <span class="hljs-string">'正在导入'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在文件开始上传时，修改上传按钮为不可点击，同时修改上传按钮的图标和文本。</li><li>文件上传成功或者失败时，修改上传按钮的状态为可以点击，同时恢复上传按钮的图标和文本。</li></ol><p>上传效果图如下：</p><p><img src="http://img.itboyhub.com/2020/03/springboot-vue-fastdfs-1.png" alt> </p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>两种上传方式各有优缺点：</p><ol><li>第一种方式最大的优势是通用，一招鲜吃遍天，到哪里都能用，但是对于上传过程的监控，进度条的展示等等逻辑都需要自己来实现。</li><li>第二种方式不够通用，因为它是 ElementUI 中的组件，得引入 ElementUI 才能使用，不过这种方式很明显有需多比较方便的回调，可以实现非常方便的处理常见的各种上传问题。</li><li>常规的上传需求第二种方式可以满足，但是如果要对上传的方法进行定制，则还是建议使用第一种上传方案。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Spring Boot 前后端分离环境下做文件上传，这个松哥之前在公众号上发过一篇文章来和大家介绍，但是在之前的文章中，为了省事，文件我是直接保存在本地临时目录下的，这带来了另外一个问题，就是项目重启之后，临时目录失效，之前上传的文件又访问不到了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="FastDFS" scheme="http://www.javaboy.org/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 国际化踩坑指南</title>
    <link href="http://www.javaboy.org/2020/0305/springboot-i18n.html"/>
    <id>http://www.javaboy.org/2020/0305/springboot-i18n.html</id>
    <published>2020-03-05T02:19:10.000Z</published>
    <updated>2020-03-05T02:43:53.095Z</updated>
    
    <content type="html"><![CDATA[<p>国际化，也叫 i18n，为啥叫这个名字呢？因为国际化英文是 internationalization ，在 i 和 n 之间有 18 个字母，所以叫 i18n。我们的应用如果做了国际化就可以在不同的语言环境下，方便的进行切换，最常见的就是中文和英文之间的切换，国际化这个功能也是相当的常见。</p><a id="more"></a><p>在 Spring 中，就通过 AcceptHeaderLocaleResolver 对国际化提供了支持，开发者通过简单配置，就可以在项目中直接使用国际化功能了。</p><p>这一支持，在 Spring Boot 中得到进一步的简化，在 Spring Boot 中，我们也可以通过寥寥数行代码就能方便的实现国际化功能，接下来松哥就来和大家说一说 Spring Boot 中的国际化。</p><p>首先，需要给大家先说明一点，项目中的国际化我们往往需要多方面的支持，例如后端做国际化、前端页面也要做国际化，共同搭配，才能真正实现国际化的功能。本文我先来和各位小伙伴们介绍 Spring Boot 中的国际化，后面我们再来介绍 Vue 的国际化，最后，再把这两个结合应用到我们的 vhr 项目中，所以前后一共可能有三篇文章，本文是第一篇。</p><p><a href="https://mp.weixin.qq.com/s/bDiPhqPjEyCbXhmAx1btpg" target="_blank" rel="noopener">本文对应的视频教程链接</a></p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><p>Spring Boot 和 Spring 一脉相承，对于国际化的支持，默认是通过 AcceptHeaderLocaleResolver 解析器来完成的，这个解析器，默认是通过请求头的 Accept-Language 字段来判断当前请求所属的环境的，进而给出合适的响应。</p><p>所以在 Spring Boot 中做国际化，这一块我们可以不用配置，直接就开搞。</p><p>首先创建一个普通的 Spring Boot 项目，添加 web 依赖即可。项目创建成功后，默认的国际化配置文件放在 resources 目录下，所以我们直接在该目录下创建四个测试文件，如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-1.png" alt></p><ul><li>我们的 message 文件是直接创建在 resources 目录下的，IDEA 在展示的时候，会多出一个 Resource Bundle，这个大家不用管，千万别手动去创建这个目录。</li><li>messages.properties 这个是默认的配置，其他的则是不同语言环境下的配置，en_US 是英语(美国)，zh_CN 是中文简体，zh_TW 是中文繁体（文末附录里边有一个完整的语言简称表格）。</li></ul><p>四个文件创建好之后，第一个默认的我们可以先空着，另外三个分别填入以下内容：</p><p>messages_zh_CN.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=江南一点雨</span><br></pre></td></tr></table></figure><p>messages_zh_TW.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=江南壹點雨</span><br></pre></td></tr></table></figure><p>messages_en_US.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=javaboy</span><br></pre></td></tr></table></figure><p>配置完成后，我们就可以直接开始使用了。在需要使用值的地方，直接注入 MessageSource 实例即可。</p><blockquote><p>在 Spring 中需要配置的 MessageSource 现在不用配置了，Spring Boot 会通过 <code>org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration</code> 自动帮我们配置一个 MessageSource 实例。</p></blockquote><p>创建一个 HelloController ，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageSource.getMessage(<span class="hljs-string">"user.name"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HelloController 中我们可以直接注入 MessageSource 实例，然后调用该实例中的 getMessage 方法去获取变量的值，第一个参数是要获取变量的 key，第二个参数是如果 value 中有占位符，可以从这里传递参数进去，第三个参数传递一个 Locale 实例即可，这相当于当前的语言环境。</p><p>接下来我们就可以直接去调用这个接口了。</p><p>默认情况下，在接口调用时，通过请求头的 Accept-Language 来配置当前的环境，我这里通过 POSTMAN 来进行测试，结果如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-2.png" alt></p><p>小伙伴们看到，我在请求头中设置了 Accept-Language 为 zh-CN，所以拿到的就是简体中文；如果我设置了 zh-TW，就会拿到繁体中文：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-3.png" alt></p><p>是不是很 Easy？</p><h2 id="2-自定义切换"><a href="#2-自定义切换" class="headerlink" title="2.自定义切换"></a>2.自定义切换</h2><p>有的小伙伴觉得切换参数放在请求头里边好像不太方便，那么也可以自定义解析方式。例如参数可以当成普通参数放在地址栏上，通过如下配置可以实现我们的需求。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        LocaleChangeInterceptor interceptor = <span class="hljs-keyword">new</span> LocaleChangeInterceptor();</span><br><span class="line">        interceptor.setParamName(<span class="hljs-string">"lang"</span>);</span><br><span class="line">        registry.addInterceptor(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        SessionLocaleResolver localeResolver = <span class="hljs-keyword">new</span> SessionLocaleResolver();</span><br><span class="line">        localeResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);</span><br><span class="line">        <span class="hljs-keyword">return</span> localeResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段配置中，我们首先提供了一个 SessionLocaleResolver 实例，这个实例会替换掉默认的 AcceptHeaderLocaleResolver，不同于 AcceptHeaderLocaleResolver 通过请求头来判断当前的环境信息，SessionLocaleResolver 将客户端的 Locale 保存到 HttpSession 对象中，并且可以进行修改（这意味着当前环境信息，前端给浏览器发送一次即可记住，只要 session 有效，浏览器就不必再次告诉服务端当前的环境信息）。</p><p>另外我们还配置了一个拦截器，这个拦截器会拦截请求中 key 为 lang 的参数（不配置的话是 locale），这个参数则指定了当前的环境信息。</p><p>好了，配置完成后，启动项目，访问方式如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-4.png?aa=123" alt></p><p>我们通过在请求中添加 lang 来指定当前环境信息。这个指定只需要一次即可，也就是说，在 session 不变的情况下，下次请求可以不必带上 lang 参数，服务端已经知道当前的环境信息了。</p><h2 id="3-其他自定义"><a href="#3-其他自定义" class="headerlink" title="3.其他自定义"></a>3.其他自定义</h2><p>默认情况下，我们的配置文件放在 resources 目录下，如果大家想自定义，也是可以的，例如定义在 resources/i18n 目录下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-5.png" alt></p><p>但是这种定义方式系统就不知道去哪里加载配置文件了，此时还需要 application.properties 中进行额外配置(注意这是一个相对路径)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.basename=i18n/messages</span><br></pre></td></tr></table></figure><p>另外还有一些编码格式的配置等，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.cache-duration=3600</span><br><span class="line">spring.messages.encoding=UTF-8</span><br><span class="line">spring.messages.fallback-to-system-locale=true</span><br></pre></td></tr></table></figure><p>spring.messages.cache-duration 表示 messages 文件的缓存失效时间，如果不配置则缓存一直有效。</p><p>spring.messages.fallback-to-system-locale 属性则略显神奇，网上竟然看不到一个明确的答案，后来翻了一会源码才看出端倪。</p><p>这个属性的作用在 <code>org.springframework.context.support.AbstractResourceBasedMessageSource#getDefaultLocale</code> 方法中生效：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Locale <span class="hljs-title">getDefaultLocale</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaultLocale != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fallbackToSystemLocale) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Locale.getDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码可以看出，在找不到当前系统对应的资源文件时，如果该属性为 true，则会默认查找当前系统对应的资源文件，否则就返回 null，返回 null 之后，最终又会调用到系统默认的 messages.properties 文件。</p><h2 id="4-附录"><a href="#4-附录" class="headerlink" title="4.附录"></a>4.附录</h2><p>搜刮了一个语言简称表，分享给各位小伙伴：</p><table><thead><tr><th style="text-align:left">语言</th><th style="text-align:left">简称</th></tr></thead><tbody><tr><td style="text-align:left">简体中文(中国)</td><td style="text-align:left">zh_CN</td></tr><tr><td style="text-align:left">繁体中文(中国台湾)</td><td style="text-align:left">zh_TW</td></tr><tr><td style="text-align:left">繁体中文(中国香港)</td><td style="text-align:left">zh_HK</td></tr><tr><td style="text-align:left">英语(中国香港)</td><td style="text-align:left">en_HK</td></tr><tr><td style="text-align:left">英语(美国)</td><td style="text-align:left">en_US</td></tr><tr><td style="text-align:left">英语(英国)</td><td style="text-align:left">en_GB</td></tr><tr><td style="text-align:left">英语(全球)</td><td style="text-align:left">en_WW</td></tr><tr><td style="text-align:left">英语(加拿大)</td><td style="text-align:left">en_CA</td></tr><tr><td style="text-align:left">英语(澳大利亚)</td><td style="text-align:left">en_AU</td></tr><tr><td style="text-align:left">英语(爱尔兰)</td><td style="text-align:left">en_IE</td></tr><tr><td style="text-align:left">英语(芬兰)</td><td style="text-align:left">en_FI</td></tr><tr><td style="text-align:left">芬兰语(芬兰)</td><td style="text-align:left">fi_FI</td></tr><tr><td style="text-align:left">英语(丹麦)</td><td style="text-align:left">en_DK</td></tr><tr><td style="text-align:left">丹麦语(丹麦)</td><td style="text-align:left">da_DK</td></tr><tr><td style="text-align:left">英语(以色列)</td><td style="text-align:left">en_IL</td></tr><tr><td style="text-align:left">希伯来语(以色列)</td><td style="text-align:left">he_IL</td></tr><tr><td style="text-align:left">英语(南非)</td><td style="text-align:left">en_ZA</td></tr><tr><td style="text-align:left">英语(印度)</td><td style="text-align:left">en_IN</td></tr><tr><td style="text-align:left">英语(挪威)</td><td style="text-align:left">en_NO</td></tr><tr><td style="text-align:left">英语(新加坡)</td><td style="text-align:left">en_SG</td></tr><tr><td style="text-align:left">英语(新西兰)</td><td style="text-align:left">en_NZ</td></tr><tr><td style="text-align:left">英语(印度尼西亚)</td><td style="text-align:left">en_ID</td></tr><tr><td style="text-align:left">英语(菲律宾)</td><td style="text-align:left">en_PH</td></tr><tr><td style="text-align:left">英语(泰国)</td><td style="text-align:left">en_TH</td></tr><tr><td style="text-align:left">英语(马来西亚)</td><td style="text-align:left">en_MY</td></tr><tr><td style="text-align:left">英语(阿拉伯)</td><td style="text-align:left">en_XA</td></tr><tr><td style="text-align:left">韩文(韩国)</td><td style="text-align:left">ko_KR</td></tr><tr><td style="text-align:left">日语(日本)</td><td style="text-align:left">ja_JP</td></tr><tr><td style="text-align:left">荷兰语(荷兰)</td><td style="text-align:left">nl_NL</td></tr><tr><td style="text-align:left">荷兰语(比利时)</td><td style="text-align:left">nl_BE</td></tr><tr><td style="text-align:left">葡萄牙语(葡萄牙)</td><td style="text-align:left">pt_PT</td></tr><tr><td style="text-align:left">葡萄牙语(巴西)</td><td style="text-align:left">pt_BR</td></tr><tr><td style="text-align:left">法语(法国)</td><td style="text-align:left">fr_FR</td></tr><tr><td style="text-align:left">法语(卢森堡)</td><td style="text-align:left">fr_LU</td></tr><tr><td style="text-align:left">法语(瑞士)</td><td style="text-align:left">fr_CH</td></tr><tr><td style="text-align:left">法语(比利时)</td><td style="text-align:left">fr_BE</td></tr><tr><td style="text-align:left">法语(加拿大)</td><td style="text-align:left">fr_CA</td></tr><tr><td style="text-align:left">西班牙语(拉丁美洲)</td><td style="text-align:left">es_LA</td></tr><tr><td style="text-align:left">西班牙语(西班牙)</td><td style="text-align:left">es_ES</td></tr><tr><td style="text-align:left">西班牙语(阿根廷)</td><td style="text-align:left">es_AR</td></tr><tr><td style="text-align:left">西班牙语(美国)</td><td style="text-align:left">es_US</td></tr><tr><td style="text-align:left">西班牙语(墨西哥)</td><td style="text-align:left">es_MX</td></tr><tr><td style="text-align:left">西班牙语(哥伦比亚)</td><td style="text-align:left">es_CO</td></tr><tr><td style="text-align:left">西班牙语(波多黎各)</td><td style="text-align:left">es_PR</td></tr><tr><td style="text-align:left">德语(德国)</td><td style="text-align:left">de_DE</td></tr><tr><td style="text-align:left">德语(奥地利)</td><td style="text-align:left">de_AT</td></tr><tr><td style="text-align:left">德语(瑞士)</td><td style="text-align:left">de_CH</td></tr><tr><td style="text-align:left">俄语(俄罗斯)</td><td style="text-align:left">ru_RU</td></tr><tr><td style="text-align:left">意大利语(意大利)</td><td style="text-align:left">it_IT</td></tr><tr><td style="text-align:left">希腊语(希腊)</td><td style="text-align:left">el_GR</td></tr><tr><td style="text-align:left">挪威语(挪威)</td><td style="text-align:left">no_NO</td></tr><tr><td style="text-align:left">匈牙利语(匈牙利)</td><td style="text-align:left">hu_HU</td></tr><tr><td style="text-align:left">土耳其语(土耳其)</td><td style="text-align:left">tr_TR</td></tr><tr><td style="text-align:left">捷克语(捷克共和国)</td><td style="text-align:left">cs_CZ</td></tr><tr><td style="text-align:left">斯洛文尼亚语</td><td style="text-align:left">sl_SL</td></tr><tr><td style="text-align:left">波兰语(波兰)</td><td style="text-align:left">pl_PL</td></tr><tr><td style="text-align:left">瑞典语(瑞典)</td><td style="text-align:left">sv_SE</td></tr><tr><td style="text-align:left">西班牙语(智利)</td><td style="text-align:left">es_CL</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国际化，也叫 i18n，为啥叫这个名字呢？因为国际化英文是 internationalization ，在 i 和 n 之间有 18 个字母，所以叫 i18n。我们的应用如果做了国际化就可以在不同的语言环境下，方便的进行切换，最常见的就是中文和英文之间的切换，国际化这个功能也是相当的常见。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="i18n" scheme="http://www.javaboy.org/tags/i18n/"/>
    
  </entry>
  
  <entry>
    <title>写博客必备！手把手教大家搭建免费图床，真香！</title>
    <link href="http://www.javaboy.org/2020/0304/qiniuyun-picgo.html"/>
    <id>http://www.javaboy.org/2020/0304/qiniuyun-picgo.html</id>
    <published>2020-03-04T02:18:53.000Z</published>
    <updated>2020-03-05T02:44:23.358Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间松哥发了一篇文章，鼓励大家写博客多做积累（<a href="https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA" target="_blank" rel="noopener">如果你没写过博客，现在就是你写博客的最佳时机</a>），有小伙伴告诉松哥他已经开始实践了，感觉到自己的苦口婆心总算有了一点点作用还是蛮欣慰的。</p><a id="more"></a><p>今天想和大家分享一个写博客过程中经常遇到的技术性问题，就是博客图片存到哪里。<strong>因为松哥自己最近搞了一个免费的图床，感觉还是蛮香的，于是和大家伙分享下。</strong></p><h2 id="蛮荒时代"><a href="#蛮荒时代" class="headerlink" title="蛮荒时代"></a>蛮荒时代</h2><p>先说说我刚开始写博客的时候，就直接打开博客平台的后台编辑器开始写，写好之后保存发布，写的过程中可能需要上传图片，于是就做好图片上传，博客写好之后，本地啥都没剩下。过了很久，我想把曾经写的博客整理成一个系列，结果发现只能从网站上重新拷贝文档下来，down 下来的图片还都自动加上博客平台的水印，真是让人又气又恼。</p><p>后来就学乖了，博客一般我在本地用 vscode 写，需要的图片，都一一编号，按顺序摆放好，然后在 Markdown 中通过相对路径的方式引入，像下面这样：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-1.png" alt></p><p>写好之后，再拷贝到博客网站发表即可。这样，我本地就有一份存档，这也是为什么大家可以看到松哥整理的 274 页离线版 Spring Boot 教程，就是这个原因。这样有一天，如果我想对文章进行二次整理或者完善就会非常方便。</p><p>用 vscode 这样写当然没问题，但是也有很多小伙伴用的是一些笔记软件，印象笔记，有道笔记等等，如果用笔记软件的话，图片的引用就不会这么方便了，此时如果我们有自己的图床就会方便很多。</p><p>对于自己的图床，我就两方面的要求：</p><ul><li>稳定</li><li>图片编号有序</li></ul><p>稳定就不用多说了，图片编号有序，这个挺关键的，这关系到未来有一天你是否还能够方便的找到自己的图片，而免费图床都是用随机字符串做图片名的，这块不是很方便，所以就想着能不能自己搭建一个图床。</p><p>刚好之前听说七牛云有免费的 10G 空间可以用来搭建个人图床，一直没有机会尝试，这次就试了下，没想到整个过程还是蛮顺利的，于是记录下来和小伙伴们分享下。</p><h2 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h2><p>搭建需要大家首先做两方面的准备工作：</p><ol><li>有一个自己的<strong>已备案</strong>域名，早期这个不是必须的，但是现在这个是必须的。当我们在七牛云上申请好存储之后，会生成一个临时的二级域名，这个二级域名有效期 1 个月，所以我们得提前准备好一个自己的域名。</li><li>准备一个七牛云账户，并且实名认证下，这个就不需要我多说了吧，网站注册+上传身份证认证，这算是基本操作了。</li></ol><p>好了，这两样准备好之后，我们就可以开始搭建我们的图床了。</p><p>首先在七牛云网站首页点击 <strong>管理控制台</strong> 进入到管理控制台页面，然后选择第一个对象存储，点击立即添加。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-2.png" alt></p><p>然后给新的存储空间取一个名字，选择合适的存储区域，由于我们是要搭建自己的图床，所以最后一项访问控制选择<strong>公开</strong>，切勿选错。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-3.png" alt></p><p>创建完成后，接下来，我们再来配置域名。</p><p>首先点击左边菜单栏的 CDN，然后再点击域名管理。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-4.png" alt></p><p>默认情况下，只有一个测试域名，我们点击上方的 <strong>添加域名</strong>，添加自己的域名进来，这里如果没有特殊需求，配置一下域名地址即可，其他都使用默认即可：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-5.png" alt></p><p>其他的选项，大家可以根据实际情况配置，我就不挨个说了，至少配置一个域名，后面就可以用了。配置完成之后，保存。</p><p>保存之后，这里会给你一个 CNAME，其实就是一个临时的二级域名：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-6.png" alt></p><p>把这个 CNAME 复制下来，然后打开自己的域名服务商控制台，添加一条 CNAME 解析记录，像下面这样：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-7.png" alt></p><p>这里的配置大家注意：</p><ul><li>由于一开始添加域名的时候，我们配置的是 img.javaboy.com，所以这里的主机记录就是 img，不要写错了</li><li>记录类型就是 CNAME，这个不能改</li><li>线路类型默认即可</li><li>记录值就是你复制的 CNAME</li></ul><p>其他都默认，配置完成之后，保存即可。</p><blockquote><p>那么这个域名配置是什么含义呢？我在这里给大家稍为科普一下。我们把图片上传到七牛云之后，肯定会生成一个访问路径，例如 <a href="http://abc-javaboy.qiniu.com/111.png，这个访问路径是有域名的，默认的域名就是七牛云给我们生成的一个临时二级域名，这个二级域名有效期" target="_blank" rel="noopener">http://abc-javaboy.qiniu.com/111.png，这个访问路径是有域名的，默认的域名就是七牛云给我们生成的一个临时二级域名，这个二级域名有效期</a> 1 个月，1 个月之后就会失效。所以，我们要配置自己的域名，例如 img.javaboy.com，但是当我访问 <a href="http://img.javaboy.com/111.png" target="_blank" rel="noopener">http://img.javaboy.com/111.png</a> 时，要让这个地址指向七牛云上去，怎么做呢？这个时候就要靠一条 CNAME 解析了，它可以把域名解析到别的域名上。</p></blockquote><p>OK，这些事情全部做完之后，等待一会，十分钟左右，在 <strong>空间管理-&gt;空间概览</strong> 里边，看到 CDN 加速域名的状态为成功时，我们的所有配置就算都 OK 了。</p><p>接下来点到 <strong>空间管理-&gt;空间概览</strong> ，点击文件上传，就可以上传文件了。文件上传成功后，点击右边的更多，就可以复制文件链接了。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-8.png" alt></p><p>整个操作过程还是比较 Easy 的，没有什么难度。</p><h2 id="PicGo-上传"><a href="#PicGo-上传" class="headerlink" title="PicGo 上传"></a>PicGo 上传</h2><p>每次需要上传图片的时候，都要打开七牛云后台，这显然有些麻烦，于是有人开发了不少好用的客户端工具，松哥经过各种踩坑之后，感觉 PicGo 比较好用，在 Mac/Windows 上都支持，挺方便的，所以采用这个来做文件上传。</p><p>PicGo 可以从 GitHub 上下载，根据自己的系统选择合适的版本下载：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a>。</p><p>下载安装，这个我就不用说了，普通软件安装。</p><p>安装好之后，在图床配置里边，配置一下七牛图床：</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-9.png" alt></p><p>AccessKey、SecretKey 都可以从你的七牛后台的个人中心页面看到，直接复制过来即可。存储空间名就是你一开始创建的存储空间，访问地址则是你自己的域名，例如 <a href="http://img.javaboy.org。存储区域根据自己一开始选择的华南/华东/华北等，根据实际情况填写，但是这里注意填写区域简称：" target="_blank" rel="noopener">http://img.javaboy.org。存储区域根据自己一开始选择的华南/华东/华北等，根据实际情况填写，但是这里注意填写区域简称：</a></p><p><img src="http://img.itboyhub.com/2020/03/qiniu-10.png" alt></p><p>配置完成后，以后就可以把图片拖拽到上传区上传了，上传成功后会返回图片访问路径，这些就比较简单了，不再赘述。</p><p><img src="http://img.itboyhub.com/2020/03/qiniu-11.png" alt></p><p>好了，这就是今天和小伙伴们分享的免费搭建自己的图床，写博客的小伙伴，可以试试哦。真香。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间松哥发了一篇文章，鼓励大家写博客多做积累（&lt;a href=&quot;https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如果你没写过博客，现在就是你写博客的最佳时机&lt;/a&gt;），有小伙伴告诉松哥他已经开始实践了，感觉到自己的苦口婆心总算有了一点点作用还是蛮欣慰的。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://www.javaboy.org/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="七牛云" scheme="http://www.javaboy.org/tags/%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    
      <category term="PicGo" scheme="http://www.javaboy.org/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 如何添加登录验证码？松哥手把手教你给微人事添加登录验证码</title>
    <link href="http://www.javaboy.org/2020/0303/springsecurity-verifycode.html"/>
    <id>http://www.javaboy.org/2020/0303/springsecurity-verifycode.html</id>
    <published>2020-03-03T02:18:34.000Z</published>
    <updated>2020-03-05T02:45:28.781Z</updated>
    
    <content type="html"><![CDATA[<p>登录添加验证码是一个非常常见的需求，网上也有非常成熟的解决方案。在传统的登录流程中加入一个登录验证码也不是难事，但是如何在 Spring Security 中添加登录验证码，对于初学者来说还是一件蛮有挑战的事情，因为默认情况下，在 Spring Security 中我们并不需要自己写登录认证逻辑，只需要自己稍微配置一下就可以了，所以如果要添加登录验证码，就涉及到如何在 Spring Security 即有的认证体系中，加入自己的验证逻辑。</p><a id="more"></a><p>学习本文，需要大家对 Spring Security 的基本操作有一些了解，如果大家对于 Spring Security 的操作还不太熟悉，可以在公众号后台回复 springboot，获取松哥纯手敲的 274 页免费 Spring Boot 学习干货。</p><p>好了，那么接下来，我们就来看下我是如何通过自定义过滤器给微人事添加上登录验证码的。</p><p><a href="https://mp.weixin.qq.com/s/aaop_dS9UIOgTtQd0hl_tw" target="_blank" rel="noopener">本文对应的视频教程链接</a></p><p>好了，不知道小伙伴们有没有看懂呢？视频中涉及到的所有代码我已经提交到 GitHub 上了：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>。如果小伙伴们对完整的微人事视频教程感兴趣，可以点击这里:<a href="https://mp.weixin.qq.com/s/8FmgtWyz6HUIbF4smXQOwQ" target="_blank" rel="noopener">Spring Boot + Vue 视频教程喜迎大结局，西交大的老师竟然都要来一套！</a></p><p>最后，还有一个去年写的关于验证码的笔记，小伙伴们也可以参考下。</p><h3 id="准备验证码"><a href="#准备验证码" class="headerlink" title="准备验证码"></a>准备验证码</h3><p>要有验证码，首先得先准备好验证码，本文采用 Java 自画的验证码，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 生成验证码的工具类</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">100</span>;<span class="hljs-comment">// 生成验证码图片的宽度</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">50</span>;<span class="hljs-comment">// 生成验证码图片的高度</span></span><br><span class="line"><span class="hljs-keyword">private</span> String[] fontNames = &#123; <span class="hljs-string">"宋体"</span>, <span class="hljs-string">"楷体"</span>, <span class="hljs-string">"隶书"</span>, <span class="hljs-string">"微软雅黑"</span> &#125;;</span><br><span class="line"><span class="hljs-keyword">private</span> Color bgColor = <span class="hljs-keyword">new</span> Color(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<span class="hljs-comment">// 定义验证码图片的背景颜色为白色</span></span><br><span class="line"><span class="hljs-keyword">private</span> Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line"><span class="hljs-keyword">private</span> String codes = <span class="hljs-string">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> String text;<span class="hljs-comment">// 记录随机字符串</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 获取一个随意颜色</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Color <span class="hljs-title">randomColor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> red = random.nextInt(<span class="hljs-number">150</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> green = random.nextInt(<span class="hljs-number">150</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> blue = random.nextInt(<span class="hljs-number">150</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Color(red, green, blue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 获取一个随机字体</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Font <span class="hljs-title">randomFont</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">String name = fontNames[random.nextInt(fontNames.length)];</span><br><span class="line"><span class="hljs-keyword">int</span> style = random.nextInt(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> size = random.nextInt(<span class="hljs-number">5</span>) + <span class="hljs-number">24</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Font(name, style, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 获取一个随机字符</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> <span class="hljs-title">randomChar</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> codes.charAt(random.nextInt(codes.length()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 创建一个空白的BufferedImage对象</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> BufferedImage <span class="hljs-title">createImage</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">Graphics2D g2 = (Graphics2D) image.getGraphics();</span><br><span class="line">g2.setColor(bgColor);<span class="hljs-comment">// 设置验证码图片的背景颜色</span></span><br><span class="line">g2.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);</span><br><span class="line"><span class="hljs-keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> BufferedImage <span class="hljs-title">getImage</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">BufferedImage image = createImage();</span><br><span class="line">Graphics2D g2 = (Graphics2D) image.getGraphics();</span><br><span class="line">StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;</span><br><span class="line">String s = randomChar() + <span class="hljs-string">""</span>;</span><br><span class="line">sb.append(s);</span><br><span class="line">g2.setColor(randomColor());</span><br><span class="line">g2.setFont(randomFont());</span><br><span class="line"><span class="hljs-keyword">float</span> x = i * width * <span class="hljs-number">1.0f</span> / <span class="hljs-number">4</span>;</span><br><span class="line">g2.drawString(s, x, height - <span class="hljs-number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.text = sb.toString();</span><br><span class="line">drawLine(image);</span><br><span class="line"><span class="hljs-keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 绘制干扰线</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> image</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLine</span><span class="hljs-params">(BufferedImage image)</span> </span>&#123;</span><br><span class="line">Graphics2D g2 = (Graphics2D) image.getGraphics();</span><br><span class="line"><span class="hljs-keyword">int</span> num = <span class="hljs-number">5</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> x1 = random.nextInt(width);</span><br><span class="line"><span class="hljs-keyword">int</span> y1 = random.nextInt(height);</span><br><span class="line"><span class="hljs-keyword">int</span> x2 = random.nextInt(width);</span><br><span class="line"><span class="hljs-keyword">int</span> y2 = random.nextInt(height);</span><br><span class="line">g2.setColor(randomColor());</span><br><span class="line">g2.setStroke(<span class="hljs-keyword">new</span> BasicStroke(<span class="hljs-number">1.5f</span>));</span><br><span class="line">g2.drawLine(x1, y1, x2, y2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getText</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">(BufferedImage image, OutputStream out)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">ImageIO.write(image, <span class="hljs-string">"JPEG"</span>, out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工具类很常见，网上也有很多，就是画一个简单的验证码，通过流将验证码写到前端页面，提供验证码的 Controller 如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyCodeController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/vercode"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">code</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        VerifyCode vc = <span class="hljs-keyword">new</span> VerifyCode();</span><br><span class="line">        BufferedImage image = vc.getImage();</span><br><span class="line">        String text = vc.getText();</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        session.setAttribute(<span class="hljs-string">"index_code"</span>, text);</span><br><span class="line">        VerifyCode.output(image, resp.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个 VerifyCode 对象，将生成的验证码字符保存到 session 中，然后通过流将图片写到前端，img 标签如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/vercode"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><p>展示效果如下：</p><p><img src="http://img.itboyhub.com/2020/03/springsecurity-verifycode-1.png" alt></p><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>在登陆页展示验证码这个就不需要我多说了，接下来我们来看看如何自定义验证码处理器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyCodeFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String defaultFilterProcessUrl = <span class="hljs-string">"/doLogin"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"POST"</span>.equalsIgnoreCase(request.getMethod()) &amp;&amp; defaultFilterProcessUrl.equals(request.getServletPath())) &#123;</span><br><span class="line">            <span class="hljs-comment">// 验证码验证</span></span><br><span class="line">            String requestCaptcha = request.getParameter(<span class="hljs-string">"code"</span>);</span><br><span class="line">            String genCaptcha = (String) request.getSession().getAttribute(<span class="hljs-string">"index_code"</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (StringUtils.isEmpty(requestCaptcha))</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"验证码不能为空!"</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span> (!genCaptcha.toLowerCase().equals(requestCaptcha.toLowerCase())) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"验证码错误!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义过滤器继承自 GenericFilterBean，并实现其中的 doFilter 方法，在 doFilter 方法中，当请求方法是 POST，并且请求地址是 <code>/doLogin</code> 时，获取参数中的 code 字段值，该字段保存了用户从前端页面传来的验证码，然后获取 session 中保存的验证码，如果用户没有传来验证码，则抛出验证码不能为空异常，如果用户传入了验证码，则判断验证码是否正确，如果不正确则抛出异常，否则执行 <code>chain.doFilter(request, response);</code> 使请求继续向下走。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>最后在 Spring Security 的配置中，配置过滤器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    VerifyCodeFilter verifyCodeFilter;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只贴出了部分核心代码，即 <code>http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</code> ，如此之后，整个配置就算完成了。</p><p>接下来在登录中，就需要传入验证码了，如果不传或者传错，都会抛出异常，例如不传的话，抛出如下异常：</p><p><img src="http://img.itboyhub.com/2020/03/springsecurity-verifycode-2.png" alt></p><p>本文案例，我已经上传到 GitHub ，欢迎大家 star：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></p><p>好了，本文就先说到这里，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;登录添加验证码是一个非常常见的需求，网上也有非常成熟的解决方案。在传统的登录流程中加入一个登录验证码也不是难事，但是如何在 Spring Security 中添加登录验证码，对于初学者来说还是一件蛮有挑战的事情，因为默认情况下，在 Spring Security 中我们并不需要自己写登录认证逻辑，只需要自己稍微配置一下就可以了，所以如果要添加登录验证码，就涉及到如何在 Spring Security 即有的认证体系中，加入自己的验证逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离项目(微人事)常见部署问题汇总</title>
    <link href="http://www.javaboy.org/2020/0302/vhr.html"/>
    <id>http://www.javaboy.org/2020/0302/vhr.html</id>
    <published>2020-03-02T02:18:13.000Z</published>
    <updated>2020-03-05T02:46:20.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-部署问题"><a href="#1-部署问题" class="headerlink" title="1. 部署问题"></a>1. 部署问题</h2><p><strong>最新版部署视频教程：<a href="https://mp.weixin.qq.com/s/dcJv6BIVFPnokI8nBf4IrQ" target="_blank" rel="noopener">前后端分离项目(微人事)常见部署问题汇总</a></strong></p><a id="more"></a><h4 id="1-1-下载问题"><a href="#1-1-下载问题" class="headerlink" title="1.1 下载问题"></a>1.1 下载问题</h4><p>有两个地方可以下载到最新版的微人事，如果在 GitHub 上下载失败，也可以从 Gitee 上下载。</p><ul><li>GitHub：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li><li>Gitee：<a href="https://gitee.com/lenve/vhr" target="_blank" rel="noopener">https://gitee.com/lenve/vhr</a></li></ul><h4 id="1-2-提前准备"><a href="#1-2-提前准备" class="headerlink" title="1.2 提前准备"></a>1.2 提前准备</h4><p>准备三样东西：</p><ul><li>空的 vhr 数据库</li><li>redis</li><li>rabbitmq</li></ul><h4 id="1-3-项目导入"><a href="#1-3-项目导入" class="headerlink" title="1.3 项目导入"></a>1.3 项目导入</h4><p>项目的 Maven 依赖下载失败，可以参考这篇文章：</p><p><a href="https://mp.weixin.qq.com/s/6PPYwrNestz-gvmB4ZkAqQ" target="_blank" rel="noopener">依赖下载失败解决方案</a></p><h4 id="1-4-项目配置"><a href="#1-4-项目配置" class="headerlink" title="1.4 项目配置"></a>1.4 项目配置</h4><p>vhrserver 的 web  模块 application.properties 中配置三样：</p><ul><li>数据库连接</li><li>redis</li><li>rabbitmq</li></ul><p>启动 vhr-web 模块。如果只是看效果，可以不启动 mailserver 模块（如果要启动 mailserver，一定先配置 mailserver 的 redis，rabbitmq 以及 邮件发送配置信息，邮件发送配置，可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/FKyQNyPDQY8O25Hk2x7rKg" target="_blank" rel="noopener">Spring Boot 中邮件发送</a>）。</p><h4 id="1-5-二次开发"><a href="#1-5-二次开发" class="headerlink" title="1.5 二次开发"></a>1.5 二次开发</h4><p>这个需要部署前端。前端在运行时，需要准备一个 nodejs。</p><p>用 webstorm 打开下载的前端项目。</p><p>前端项目打开后，需要在项目根目录下，执行 npm install。</p><p>默认安装比较慢，可以修改为淘宝的源。<a href="https://mp.weixin.qq.com/s/HWRYAR16vLE1XFep6_i1tA" target="_blank" rel="noopener">下载源修改为淘宝</a></p><p>npm install  执行成功后，再执行 npm run serve 启动前端项目。</p><p>二次开发完成后，执行 npm run build 前端编译打包。把打包后的文件拷贝到后端。</p><p>上线部署参考这篇文章：<a href="https://mp.weixin.qq.com/s/KWBtHi_au_1pH70OYptjfA" target="_blank" rel="noopener">手把手教你部署前后端分离项目，再也不用担心跨域问题了</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-部署问题&quot;&gt;&lt;a href=&quot;#1-部署问题&quot; class=&quot;headerlink&quot; title=&quot;1. 部署问题&quot;&gt;&lt;/a&gt;1. 部署问题&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;最新版部署视频教程：&lt;a href=&quot;https://mp.weixin.qq.com/s/dcJv6BIVFPnokI8nBf4IrQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前后端分离项目(微人事)常见部署问题汇总&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vhr" scheme="http://www.javaboy.org/categories/vhr/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="vhr" scheme="http://www.javaboy.org/tags/vhr/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手教你用 FastDFS 构建分布式文件管理系统</title>
    <link href="http://www.javaboy.org/2020/0301/fastdfs.html"/>
    <id>http://www.javaboy.org/2020/0301/fastdfs.html</id>
    <published>2020-03-01T02:17:52.000Z</published>
    <updated>2020-03-12T08:31:51.221Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>说起分布式文件管理系统，大家可能很容易想到 HDFS、GFS 等系统，前者是 Hadoop 的一部分，后者则是 Google 提供的分布式文件管理系统。除了这些之外，国内淘宝和腾讯也有自己的分布式文件管理系统，都叫 TFS（<code>Taobao File System</code> 和 <code>Tencent File System</code>）。</p><a id="more"></a><p>相对于上面提到的这些分布式文件管理系统而言，FastDFS 可能离我们 Java 工程师更近一些，因为文件上传这个功能太常见了，而想要搭建独立的分布式文件管理系统，FastDFS+Nginx 组合无疑是最佳方案。因此，松哥今天就来和大家简单聊一聊这个问题。</p><p>如果小伙伴们还不懂在传统的开发环境下如何进行文件上传，可以参考松哥之前发的文件上传教程：</p><ul><li><a href="https://mp.weixin.qq.com/s/OMgoUfH8lk8hDfuqWXGWTA" target="_blank" rel="noopener">Spring Boot + Vue，手把手教你做文件上传</a></li></ul><h2 id="1-什么是-FastDFS"><a href="#1-什么是-FastDFS" class="headerlink" title="1.什么是 FastDFS"></a>1.什么是 FastDFS</h2><h3 id="1-1-FastDFS-简介"><a href="#1-1-FastDFS-简介" class="headerlink" title="1.1 FastDFS 简介"></a>1.1 FastDFS 简介</h3><p>FastDFS 由淘宝的余庆大佬在 2008 年开源的一款轻量级分布式文件管理系统，FastDFS 用 C 语言实现，支持 Linux、FreeBSD、MacOS 等类 UNIX 系统。FastDFS 类似 google FS，属于应用级文件系统，不是通用的文件系统，只能通过专有 API 访问，目前提供了 C 和 Java SDK ，以及 PHP 扩展 SDK。</p><p>这款开源软件从发布至今，历经数十年，这款开源软件的生命力依然旺盛，在业界依然备受推崇，当然这也得益于作者一直在不断完善该软件。</p><p>FastDFS 专为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性，它可以看做是基于文件的 key/value 存储系统，key 为文件 ID，value 为文件内容，因此称作分布式文件存储服务更为合适。</p><h3 id="1-2-为什么需要-FastDFS"><a href="#1-2-为什么需要-FastDFS" class="headerlink" title="1.2 为什么需要 FastDFS"></a>1.2 为什么需要 FastDFS</h3><p>传统的企业级开发对于高并发要求不是很高，而且数据量可能也不大，在这样的环境下文件管理可能非常 Easy。</p><p>但是互联网应用访问量大、数据量大，在互联网应用中，我们必须考虑解决文件大容量存储和高性能访问的问题，而 FastDFS 就特别适合干这件事情，常见的图片存储、视频存储、文档存储等等我们都可以采用 FastDFS 来做。</p><h3 id="1-3-FastDFS-架构"><a href="#1-3-FastDFS-架构" class="headerlink" title="1.3 FastDFS 架构"></a>1.3 FastDFS 架构</h3><p>作为一款分布式文件管理系统，FastDFS 主要包括四个方面的功能：</p><ul><li>文件存储</li><li>文件同步</li><li>文件上传</li><li>文件下载</li></ul><p>这个方面的功能，基本上就能搞定我们常见的文件管理需求了。</p><p>下面这是一张来自 FastDFS 官网的系统架构图：</p><p><img src="http://img.itboyhub.com/2020/03/fastdfs-1.png" alt></p><p>从上面这张图中我们可以看到，FastDFS 架构包括 Tracker 和 Storage 两部分，看名字大概就能知道，Tracker 用来追踪文件，相当于是文件的一个索引，而 Storage 则用来保存文件。</p><p>我们上传文件的文件最终保存在 Storage 上，文件的元数据信息保存在 Tracker 上，通过 Tracker 可以实现对 Storage 的负载均衡。</p><p>Storage 一般会搭建成集群，一个 Storage Cluster 可以由多个组构成，不同的组之间不进行通信，一个组又相当于一个小的集群，组由多个 Storage Server 组成，组内的 Storage Server 会通过连接进行文件同步来保证高可用。</p><h2 id="2-FastDFS-安装"><a href="#2-FastDFS-安装" class="headerlink" title="2.FastDFS 安装"></a>2.FastDFS 安装</h2><p>介绍完 FastDFS 之后，相信小伙伴已经摩拳擦掌跃跃欲试了，接下来我们就来看下 FastDFS 的安装。</p><p>我这里为了测试方便，就不开启多台虚拟机了，Tracker 和 Storage 我将安装在同一台服务器上。</p><p>图片上传我们一般使用 FastDFS，图片上传成功之后，接下来的图片访问我们一般采用 Nginx，所以这里的安装我将从三个方面来介绍：</p><ul><li>Tracker 安装</li><li>Storage 安装</li><li>Nginx 安装</li></ul><h3 id="2-1-Tracker-安装"><a href="#2-1-Tracker-安装" class="headerlink" title="2.1 Tracker 安装"></a>2.1 Tracker 安装</h3><p>安装，我们首先需要准备一个环境两个库以及一个安装包。</p><p><strong>1.一个环境</strong></p><p>先来看一个环境，由于 FastDFS 采用 C 语言开发，所以在安装之前，如果没有 gcc 环境，需要先安装，安装命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><p><strong>2.两个库</strong></p><p>再来看两个库，由于 FastDFS 依赖 libevent 库，安装命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install libevent</span><br></pre></td></tr></table></figure><p>另一个库是 libfastcommon，这是 FastDFS 官方提供的，它包含了 FastDFS 运行所需要的一些基础库。</p><p>libfastcommon 下载地址：<a href="https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz" target="_blank" rel="noopener">https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz</a></p><blockquote><p>考虑到 GitHub 访问较慢，松哥已经把安装文件下载好了，放在百度网盘上，小伙伴们可以在松哥公众号后台回复 fastdfs 获取下载链接。</p></blockquote><p>将下载好的 libfastcommon 拷贝至 /usr/local/ 目录下，然后依次执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf V1.0.43.tar.gz</span><br><span class="line">cd libfastcommon-1.0.43/</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br></pre></td></tr></table></figure><p><strong>3.一个安装包</strong></p><p>接下来我们下载 Tracker，注意，由于 Tracker 和 Storage 是相同的安装包，所以下载一次即可（2.2 小节中不用再次下载）。</p><p>安装文件可以从 FastDFS 的 GitHub 仓库上下载，下载地址：<a href="https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz</a></p><blockquote><p>考虑到 GitHub 访问较慢，松哥已经把安装文件下载好了，放在百度网盘上，小伙伴们可以在松哥公众号后台回复 fastdfs 获取下载链接。</p></blockquote><p>下载成功后，将下载文件拷贝到 /usr/local 目录下，然后依次执行如下命令安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf V6.06.tar.gz</span><br><span class="line">cd fastdfs-6.06/</span><br><span class="line">./make.sh</span><br><span class="line">./make.sh install</span><br></pre></td></tr></table></figure><p>安装成功后，执行如下命令，将安装目录内 conf 目录下的配置文件拷贝到 /etc/fdfs 目录下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd conf/</span><br><span class="line">cp ./* /etc/fdfs/</span><br></pre></td></tr></table></figure><p><strong>4.配置</strong></p><p>接下来进入 /etc/fdfs/ 目录下进行配置：</p><p>打开 tracker.conf 文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi tracker.conf</span><br></pre></td></tr></table></figure><p>修改如下配置：</p><p><img src="http://img.itboyhub.com/2020/03/fastdfs-2.png" alt></p><p>默认端口是 22122，可以根据实际需求修改，我这里就不改了。然后下面配置一下元数据的保存目录（注意目录要存在）。</p><p><strong>5.启动</strong></p><p>接下来执行如下命令启动 Tracker：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start</span><br></pre></td></tr></table></figure><p>如此之后，我们的 Tracker 就算安装成功了。</p><h3 id="2-2-Storage-安装"><a href="#2-2-Storage-安装" class="headerlink" title="2.2 Storage 安装"></a>2.2 Storage 安装</h3><p>简单起见，这里我们搭建一个 Storage 实例即可。Storage 安装也需要 libevent 和 libfastcommon，这两个库的安装参考上文，这里我不在细说。</p><p>Storage 本身的安装，也和 Tracker 一致，执行命令也都一样，因为我这里将 Tracker 和 Storage 安装在同一台服务器上，所以不用再执行安装命令了（相当于安装 Tracker 时已经安装了 Storage 了）。</p><p>唯一要做的，就是进入到 /etc/fdfs 目录下，配置 Storage：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi storage.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-3.png" alt></p><p>这里一共配置三个地方，分别是 base_path、store_path0 以及 tracker_server ，tracker_server 模板有两个地址，我们这里只有一个，配置完成后，记得注释掉另外一个不用的。</p><p>配置完成后，执行如下命令启动 Storage：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start</span><br></pre></td></tr></table></figure><p>这两个启动完成后，现在就可以做文件的上传了，但是一般如果是图片文件，我们还需要提供一个图片的访问功能，目前来说最佳方案当然是 Nginx 了，所以我们这里连同 Nginx 一起配置好，再来做测试。</p><h3 id="2-3-Nginx-安装"><a href="#2-3-Nginx-安装" class="headerlink" title="2.3 Nginx 安装"></a>2.3 Nginx 安装</h3><p>Nginx 可以算是 FastDFS 的重要搭档。</p><p>Nginx 的安装分为两个步骤：</p><ul><li>安装 Nginx</li><li>首先在 Storage 下安装 fastdfs-nginx-module</li></ul><p>第一步简单，松哥之前专门写过一篇文章扫盲 Nginx，所以 Nginx 安装大家直接参考这里：<a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></p><p>接下来看第二步。</p><p>首先下载 fastdfs-nginx-module，下载地址：<a href="https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz" target="_blank" rel="noopener">https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz</a></p><blockquote><p>考虑到 GitHub 访问较慢，松哥已经把安装文件下载好了，放在百度网盘上，小伙伴们可以在松哥公众号后台回复 fastdfs 获取下载链接。</p></blockquote><p>下载完成后，将下载的文件拷贝到 /usr/local 目录下。然后进入 /usr/local 目录，分别执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">tar -zxvf V1.22.tar.gz</span><br></pre></td></tr></table></figure><p>然后将 <code>/usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf</code> 文件拷贝到 <code>/etc/fdfs/</code> 目录下，并修改该文件的内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fdfs/mod_fastdfs.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-4.png" alt></p><p>接下来，回到第一步下载的 nginx 安装文件的解压目录中，执行如下命令，重新配置编译安装：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-module=/usr/local/fastdfs-nginx-module-1.22/src</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装完成后，修改 nginx 的配置文件，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-5.png" alt></p><p>在这里配置 nginx 请求转发。</p><p>配置完成后，启动 nginx，看到如下日志，表示 nginx 启动成功：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_fastdfs_set pid=9908</span><br></pre></td></tr></table></figure><p><strong>疑问：fastdfs-nginx-module 有啥用</strong></p><p>看了整个安装过程之后，很多小伙伴有疑问，到头来还是 nginx 本身直接找到了图片文件目录，fastdfs-nginx-module 到底有啥用？</p><p>前面我们说过，Storage 由很多组构成，每个组又是一个小的集群，在每一个组里边，数据会进行同步，但是如果数据还没同步，这个时候就有请求发来了，该怎么办？此时fastdfs-nginx-module 会帮助我们直接从源 Storage 上获取文件。</p><p>安装成功了。</p><h2 id="3-Java-客户端调用"><a href="#3-Java-客户端调用" class="headerlink" title="3.Java 客户端调用"></a>3.Java 客户端调用</h2><p>安装成功后，接下来我们就用 Java 客户端来测试一下文件上传下载。</p><p>首先我们来创建一个普通的 Maven 工程，添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.oschina.zcx7878<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastdfs-client-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.27.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在项目的 resources 目录下添加 FastDFS 的配置文件 fastdfs-client.properties，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fastdfs.connect_timeout_in_seconds = 5</span><br><span class="line">fastdfs.network_timeout_in_seconds = 30</span><br><span class="line">fastdfs.charset = UTF-8</span><br><span class="line">fastdfs.http_anti_steal_token = false</span><br><span class="line">fastdfs.http_secret_key = FastDFS1234567890</span><br><span class="line">fastdfs.http_tracker_http_port = 80</span><br><span class="line">fastdfs.tracker_servers = 192.168.91.128:22122</span><br><span class="line">fastdfs.connection_pool.enabled = true</span><br><span class="line">fastdfs.connection_pool.max_count_per_entry = 500</span><br><span class="line">fastdfs.connection_pool.max_idle_time = 3600</span><br><span class="line">fastdfs.connection_pool.max_wait_time_in_ms = 1000</span><br></pre></td></tr></table></figure><p>这里的配置基本上都能见名知义，我就不挨个解释了。这里先配置下 fastdfs.tracker_servers，这是 Tracker 的地址，根据实际情况配置即可。</p><p>fastdfs.http_secret_key 配置这里先不用管它，后面我会跟大家解释。</p><h3 id="3-1-文件上传"><a href="#3-1-文件上传" class="headerlink" title="3.1 文件上传"></a>3.1 文件上传</h3><p>配置完成后，先来看文件上传，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testUpload</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        ClientGlobal.initByProperties(<span class="hljs-string">"fastdfs-client.properties"</span>);</span><br><span class="line">        TrackerClient tracker = <span class="hljs-keyword">new</span> TrackerClient();</span><br><span class="line">        TrackerServer trackerServer = tracker.getConnection();</span><br><span class="line">        StorageServer storageServer = <span class="hljs-keyword">null</span>;</span><br><span class="line">        StorageClient1 client = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">        NameValuePair nvp[] = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-comment">//上传到文件系统</span></span><br><span class="line">        String fileId = client.upload_file1(<span class="hljs-string">"C:\\Users\\javaboy\\Pictures\\picpick\\1.png"</span>, <span class="hljs-string">"png"</span>,</span><br><span class="line">                nvp);</span><br><span class="line">        logger.info(fileId);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，首先加载配置文件，然后构造一个 TrackerClient 对象，接着再根据这个对象获取到一个 TrackerServer，然后创建一个 StorageClient1 实例。NameValuePair 中保存的是文件的元数据信息，如果有的话，就以 key/value 的方式来设置，如果没有的话，直接给一个 null 即可。</p><p>最后，调用 client 的 upload_file1 方法上传文件，第一个参数是文件路径，第二个参数是文件的扩展名，第三个参数就是文件的元数据信息，这个方法的返回值，就是上传文件的访问路径。执行该方法，打印日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-02-29 17:46:03.017  INFO 6184 --- [           main] o.j.fastdfs.FastdfsApplicationTests      : group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png</span><br></pre></td></tr></table></figure><p>group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png 就是文件的路径，此时，在浏览器中输入 <a href="http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png" target="_blank" rel="noopener">http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png</a> 就可以看到上传的图片了。</p><h3 id="3-2-文件下载"><a href="#3-2-文件下载" class="headerlink" title="3.2 文件下载"></a>3.2 文件下载</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testDownload</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        ClientGlobal.initByProperties(<span class="hljs-string">"fastdfs-client.properties"</span>);</span><br><span class="line">        TrackerClient tracker = <span class="hljs-keyword">new</span> TrackerClient();</span><br><span class="line">        TrackerServer trackerServer = tracker.getConnection();</span><br><span class="line">        StorageServer storageServer = <span class="hljs-keyword">null</span>;</span><br><span class="line">        StorageClient1 client = <span class="hljs-keyword">new</span> StorageClient1(trackerServer, storageServer);</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] bytes = client.download_file1(<span class="hljs-string">"group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\javaboy\\Pictures\\picpick\\666.png"</span>));</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就很好理解了，直接调用 download_file1 方法获取到一个 byte 数组，然后通过 IO 流写出到本地文件即可。</p><h2 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4.安全问题"></a>4.安全问题</h2><p>现在，任何人都可以访问我们服务器上传文件，这肯定是不行的，这个问题好解决，加一个上传时候的令牌即可。</p><p>首先我们在服务端开启令牌校验：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/fdfs/http.conf</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2020/03/fastdfs-6.png" alt></p><p>配置完成后，记得重启服务端：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./nginx -s stop</span><br><span class="line">./nginx</span><br></pre></td></tr></table></figure><p>接下来，在前端准备一个获取令牌的方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ts = (<span class="hljs-keyword">int</span>) Instant.now().getEpochSecond();</span><br><span class="line">    String token = ProtoCommon.getToken(<span class="hljs-string">"M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png"</span>, ts, <span class="hljs-string">"FastDFS1234567890"</span>);</span><br><span class="line">    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">    sb.append(<span class="hljs-string">"?token="</span>).append(token);</span><br><span class="line">    sb.append(<span class="hljs-string">"&amp;ts="</span>).append(ts);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们主要是根据 ProtoCommon.getToken 方法来获取令牌，注意这个方法的第一个参数是你要访问的文件 id，<strong>注意，这个地址里边不包含 group，千万别搞错了；</strong>第二个参数是时间戳，第三个参数是密钥，密钥要和服务端的配置一致。</p><p>将生成的字符串拼接，追加到访问路径后面，如：<code>http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png?token=7e329cc50307000283a3ad3592bb6d32&amp;ts=1582975854</code>。<strong>此时访问路径里边如果没有令牌，会访问失败。</strong></p><p>好了，大功告成！下次和大家讲我如何在 Spring Boot 中玩这个东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;说起分布式文件管理系统，大家可能很容易想到 HDFS、GFS 等系统，前者是 Hadoop 的一部分，后者则是 Google 提供的分布式文件管理系统。除了这些之外，国内淘宝和腾讯也有自己的分布式文件管理系统，都叫 TFS（&lt;code&gt;Taobao File System&lt;/code&gt; 和 &lt;code&gt;Tencent File System&lt;/code&gt;）。&lt;/p&gt;
    
    </summary>
    
      <category term="FastDFS" scheme="http://www.javaboy.org/categories/FastDFS/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="FastDFS" scheme="http://www.javaboy.org/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>录视频上瘾，松哥再来传授两个IDEA技巧，让编码速度飞起来</title>
    <link href="http://www.javaboy.org/2020/0227/intellij-idea.html"/>
    <id>http://www.javaboy.org/2020/0227/intellij-idea.html</id>
    <published>2020-02-27T02:17:27.000Z</published>
    <updated>2020-03-05T03:33:31.810Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个视频教程，视频链接：<a href="https://mp.weixin.qq.com/s/7lKrU8jcKRDpdxqm3EdBnw" target="_blank" rel="noopener">—–&gt;&gt;&gt;&gt;&gt;&gt;&gt;没错，点我</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个视频教程，视频链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/7lKrU8jcKRDpdxqm3EdBnw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;—–&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;没错
      
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/categories/IntelliJ-IDEA/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 整合 RabbitMQ，消息重复消费怎么办？</title>
    <link href="http://www.javaboy.org/2020/0226/springboot-rabbitmq.html"/>
    <id>http://www.javaboy.org/2020/0226/springboot-rabbitmq.html</id>
    <published>2020-02-26T02:17:00.000Z</published>
    <updated>2020-03-05T02:49:20.168Z</updated>
    
    <content type="html"><![CDATA[<p>昨天跟小伙伴们分享了如何在 RabbitMQ 中确保消息发送可靠性的问题（<a href="https://mp.weixin.qq.com/s/aMu1qi46FbzIe0amJ4XJ7w" target="_blank" rel="noopener">我是如何在微人事项目中提高RabbitMQ消息可靠性的？</a>），我们主要是两个思路：</p><a id="more"></a><ul><li>开启消息发送失败回调，路由失败回调</li><li>开启定时任务巡查，发现有发送失败的消息自动重新投递</li></ul><p>双管齐下，我们确保了消息发送的可靠性。</p><p>但是，在这样的机制下，又带来了新的问题，就是消息可能会重复投递，进而导致，消息重复消费，例如一个员工入职了，结果收到了两封入职欢迎邮件，这是不对的，所以，今天松哥又给大家带来了一个新的视频，聊一聊如何确保一条消息只消费一次。</p><p>说到这个话题，我们就不得不先来说说消息幂等性。</p><h2 id="1-简单说说幂等性"><a href="#1-简单说说幂等性" class="headerlink" title="1.简单说说幂等性"></a>1.简单说说幂等性</h2><p>幂等性本身是数学上的概念，即使公式：f(x)=f(f(x)) 能够成立的数学性质。在开发领域，则表示对于同一个系统，使用相同的条件，一次请求和多次请求对系统资源的影响是一致的。</p><p>在分布式系统中幂等性尤为重要，因为分布式系统中，我们经常会用到接口调用失败进而进行重试这个功能，这样就带来了对一个接口可能会使用相同的条件进行重复调用，在这样的条件下，保证接口的幂等性就尤为重要了。</p><p>了解了问题，那么解决方案就很好整了，常见的方案有：</p><ul><li>MVCC</li><li>Token 机制</li><li>设计去重表</li><li>…</li></ul><p>MVCC 是多版本并发控制，这种方式就是在数据更新的时候需要去比较所持有的数据版本号，版本号不一致的话，操作会失败，这样每个 version 就只有一次执行成功的机会，一旦失败了必须重新获取。这种方式松哥以后可以抽空和大家细聊。</p><p>Token 则是目前使用比较广的一种方式，核心思想就是每个操作都有一个唯一凭证 token，一旦执行成功，对于重复的请求，总是返回同一个结果。</p><h2 id="2-微人事解决方案"><a href="#2-微人事解决方案" class="headerlink" title="2.微人事解决方案"></a>2.微人事解决方案</h2><p>松哥这次在微人事的 RabbitMQ 消费端实际上就是采用了 Token 这种方式。</p><p>大致的思路是这样，首先将 RabbitMQ 的消息自动确认机制改为手动确认，然后每当有一条消息消费成功了，就把该消息的唯一 ID 记录在 Redis 上，然后每次收到消息时，都先去 Redis 上查看是否有该消息的 ID，如果有，表示该消息已经消费过了，不再处理，否则再去处理。</p><p><a href="https://mp.weixin.qq.com/s/SMPyyZlRvvKM-kSMbOOQAw" target="_blank" rel="noopener">视频讲解链接地址</a></p><p>好了，通过昨天和今天一共三个视频，松哥主要和大家分享了微人事中是如何解决 RabbitMQ 消息可靠性的，如果小伙伴们没看昨天的视频，不妨去瞅一瞅：<a href="https://mp.weixin.qq.com/s/aMu1qi46FbzIe0amJ4XJ7w" target="_blank" rel="noopener">我是如何在微人事项目中提高RabbitMQ消息可靠性的？</a></p><p>当然，如果小伙伴们对完整的微人事项目视频感兴趣，可以看看这篇文章【<a href="https://mp.weixin.qq.com/s/8FmgtWyz6HUIbF4smXQOwQ" target="_blank" rel="noopener">微人事视频教程</a>】。</p><p>本文视频中涉及到的所有代码包括数据库脚本，都已经提交到 GitHub 和 Gitee 上了，地址分别是：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a> 和 <a href="https://gitee.com/lenve/vhr" target="_blank" rel="noopener">https://gitee.com/lenve/vhr</a> ，小伙伴们可以下载参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天跟小伙伴们分享了如何在 RabbitMQ 中确保消息发送可靠性的问题（&lt;a href=&quot;https://mp.weixin.qq.com/s/aMu1qi46FbzIe0amJ4XJ7w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我是如何在微人事项目中提高RabbitMQ消息可靠性的？&lt;/a&gt;），我们主要是两个思路：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>我是如何在微人事项目中提高RabbitMQ消息可靠性的？</title>
    <link href="http://www.javaboy.org/2020/0225/springboot-rabbitmq.html"/>
    <id>http://www.javaboy.org/2020/0225/springboot-rabbitmq.html</id>
    <published>2020-02-25T02:16:43.000Z</published>
    <updated>2020-03-05T02:50:38.548Z</updated>
    
    <content type="html"><![CDATA[<p>hello 各位小伙伴大家好，松哥在最新版的微人事中集成进来了消息中间件 RabbitMQ，结合 RabbitMQ 搭建了独立的邮件服务器 mailserver。</p><a id="more"></a><p>当 hr 向系统中录入一个员工时，录入成功后，系统会自动向消息中间件 RabbitMQ 发送一条消息，这条消息包含了新入职员工的基本信息，然后 mailserver 则专门用来从 RabbitMQ 上消费消息，根据收到的消息，自动的发送一封入职欢迎邮件。</p><p>由于邮件发送是一个耗时操作，在旧版微人事里边我当时为了省事直接上的多线程，但是这种方式不易扩展，无法解耦，用过就知道这有多么不方便了。引入 RabbitMQ 之后，有效的实现了系统的解耦，在未来你可能有更多的地方需要发送邮件、短信等，把这些邮件发送、短信发送的服务拎出来做成单独的服务，扩展起来更加方便。</p><p>RabbitMQ 虽然用着方便，有很多优势，但是也带来了很多问题，例如网络抖动怎么办？如何确保消息的可靠性？在理想的环境下这些问题都不存在，但是在复杂的生产环境中，什么都是有可能的，所以，我们要通过技术手段去处理这些问题。</p><p>松哥之前发过一篇如何在 Spring Boot 中解决 RabbitMQ 可靠性的问题的文章，但是代码排版不是很少，很多小伙伴表示看的脑瓜疼，于是，周末抽空录了两个视频教程，代码直接应用在微人事（<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>）项目上，手把手教大家这个问题如何解决。</p><p><a href="https://mp.weixin.qq.com/s/aMu1qi46FbzIe0amJ4XJ7w" target="_blank" rel="noopener">视频讲解链接地址</a></p><p>好了，通过这两个视频，主要向大家介绍了如何确保消息发送的可靠性，至于消息消费的可靠性，松哥明天来和大家捋一捋，如果小伙伴们对完整的微人事项目视频感兴趣，可以看看这篇文章【<a href="https://mp.weixin.qq.com/s/8FmgtWyz6HUIbF4smXQOwQ" target="_blank" rel="noopener">微人事视频教程</a>】。</p><p>好了，视频中涉及到的所有代码包括数据库脚本，都已经提交到 GitHub 和 Gitee 上了，地址分别是：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a> 和 <a href="https://gitee.com/lenve/vhr" target="_blank" rel="noopener">https://gitee.com/lenve/vhr</a> ，小伙伴们可以下载参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 各位小伙伴大家好，松哥在最新版的微人事中集成进来了消息中间件 RabbitMQ，结合 RabbitMQ 搭建了独立的邮件服务器 mailserver。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 要怎么学？要学哪些东西？要不要先学 SSM？松哥说说看法</title>
    <link href="http://www.javaboy.org/2020/0224/springboot-guide.html"/>
    <id>http://www.javaboy.org/2020/0224/springboot-guide.html</id>
    <published>2020-02-24T02:16:18.000Z</published>
    <updated>2020-03-05T02:52:48.813Z</updated>
    
    <content type="html"><![CDATA[<p>可能很多刚接触 Spring Boot 的小伙伴都会有这样的疑问，Spring Boot 要怎么学，要不要先学 SSM？今天结合自己的经验，和大家说一说我的看法，也顺便推荐几个 Spring Boot 学习资料。</p><a id="more"></a><h2 id="1-Spring-Boot-是什么"><a href="#1-Spring-Boot-是什么" class="headerlink" title="1.Spring Boot 是什么"></a>1.Spring Boot 是什么</h2><p>我们刚开始学习 JavaWeb 的时候，使用 Servlet/JSP 做开发，一个接口搞一个 Servlet ，很头大，后来我们通过隐藏域或者反射等方式，可以减少 Servlet 的创建，但是依然不方便。</p><p>再后来，我们引入 Struts2/SpringMVC 这一类的框架，来简化我们的开发 ，和 Servlet/JSP 相比，引入框架之后，生产力确实提高了不少，但是用久了，又发现了新的问题，即配置繁琐易出错，要做一个新项目，先搭建环境，环境搭建来搭建去，就是那几行配置，不同的项目，可能就是包不同，其他大部分的配置都是一样的。</p><p>Java 总是被人诟病配置繁琐代码量巨大，这就是其中一个表现。那么怎么办？Spring Boot 应运而生，Spring Boot 是 Pivotal 团队在 2013 年开始研发的一个基于 Spring 的全新框架，试图将 Spring 中臃肿的配置进行简化，使 Java 开发更加轻量与快速，这个框架非常活跃，官方也非常重视。</p><p>Spring Boot 主要提供了如下功能：</p><ol><li>为所有基于 Spring 的 Java 开发提供方便快捷的入门体验。</li><li>开箱即用，有自己自定义的配置就是用自己的，没有就使用官方提供的默认的。</li><li>提供了一系列通用的非功能性的功能，例如嵌入式服务器、安全管理、健康检测等。</li><li>绝对没有代码生成，也不需要XML配置。</li></ol><p>Spring Boot 的出现让 Java 开发又回归简单，因为确确实实解决了开发中的痛点，因此这个技术得到了非常广泛的使用，大概从 2017 年年初开始，Spring Boot 基本上面试必问，现在流行的 Spring Cloud 微服务也是基于 Spring Boot，因此，所有的 Java 工程师都有必要掌握好 Spring Boot。</p><p>从 Spring Boot 诞生的过程中，我们可以看到：</p><ol><li>Spring Boot 并非另起炉灶，而是在现有的 Spring 框架的基础上整出来的，它把 Spring 中繁琐的配置进行了简化。</li><li>Spring Boot 降低了 Spring 家族的使用门槛，使新手更易上手 Spring 框架。</li></ol><p>既然 Spring Boot 不是另起炉灶，那么 Spring Boot 学习要不要跳过 SSM 呢？听松哥来分析。</p><h2 id="2-要不要跳过-SSM"><a href="#2-要不要跳过-SSM" class="headerlink" title="2.要不要跳过 SSM"></a>2.要不要跳过 SSM</h2><p>这是很多人问我的一个问题，我的建议是：<strong>不要</strong>。</p><p>Spring Boot 基于 Spring，简单且容易上手，很多人想当然的跳过 SSM 直接上 Spring Boot。但是当我们细究 Spring Boot 中的自动化配置、条件注解、Java 配置等东西时，实在找不出太多新鲜玩意，Java 配置是 Spring3 开始提供的，条件注解 也是 Spring 中的东西，很多很多，都是 Spring 中就有的，只不过这些东西在 Spring Boot 时代大放异彩。</p><p>也就是说，即使你跳过了 SSM 直接去学习 Spring Boot，实际上还是在学习 Spring 中的东西，那既然这样，我们还不如坐下来，老老实实把 Spring 过一遍。</p><p>各个领域的开发工程师其实都会面临类似的问题，学习了一些优秀的封装框架之后，还有没有必要去学习底层？当然有必要！因为底层的东西可以让你深刻的理解你目前用的这个东西，也能让你在出问题时快速解决掉问题。</p><p>其实无论你想搞什么技术，都要有牢固的基础知识，这些牢固的基础知识就像肥沃的土壤，可以孕育出各种不同技术方向的牛人，基础掌握好了，学什么框架都快。今天你跳过 SSM 直接学了 Spring Boot，假如有一天 Spring Boot 不行了，Pivotal 团队又基于 Spring 框架搞了一个新的框架出来，那你是不是又要去学一遍？但是如果你一开始就掌握了 Spring 的各种用法，无论基于它搞出来什么样的框架，你都能快速上手。更进一步，如果你研究透了 Spring 中的 AOP、Ioc/DI，你会发现很多框架大同小异，核心思想就是这些东西，那么你在学习 Spring 之外的框架，就会容易很多。</p><p><strong>如果你对 SSM 还不太熟悉的话，可以在公号后台分别回复 <code>spring</code>、<code>springmvc</code>、<code>mybatis</code> 获取松哥手敲 5 万余字的干货教程。</strong></p><h2 id="3-都要学哪些"><a href="#3-都要学哪些" class="headerlink" title="3.都要学哪些"></a>3.都要学哪些</h2><p>那么 Spring Boot 学习都要学哪些东西呢？我这里列举了一个进阶路线：</p><ol><li>最基础的当然是 Spring/SpringMVC 相关的东西了。</li><li>搭配各种页面模版的使用，例如 Jsp/Thymeleaf/Freemarker/Groovy Templates 等。</li><li>和各种 SQL 数据库的整合，以及一些常见的数据持久化框架，例如 JdbcTemplate、MyBatis、Jpa 等。</li><li>和各种 NoSQL 数据库的整合，例如 Redis、MongoDB、Elasticsearch 等。</li><li>搭配安全管理相关的知识点，例如 Spring Security、Shiro 等。</li><li>缓存的使用，例如 JCache、Ehcache 等。</li><li>和消息中间件的搭配整合，如 ActiveMQ、RabbitMQ、Kafka 等。</li><li>数据校验/定时任务/邮件发送等。</li><li>各种监控的使用。</li><li>结合 WebSocket 的使用。</li><li>Spring Cloud 中相关组件。</li><li>…</li></ol><p>上面这些只是我列出来的一些比较常见的技术点，每个技术点都还可以延伸出很多其他的东西，大家可以结合自己的情况，按照顺序一个一个来学，这里边还涉及到很多第三方的框架，例如 Redis、MongoDB、RabbitMQ 等，Spring Boot 的出现只是让这些组件在和 Spring 家族的产品整合时变得更加方便，但是并不会简化这些组件原本的用法，所以，该学 Redis、该学 MongoDB、该学 RabbitMQ 等等，还是一个不能少。以 Redis 为例，学会了 Redis，学会了 Spring 整合 Redis，再回过头来看 Spring Boot 整合 Redis，那简直太 easy 了（<strong>大家在公众号后台回复 redis，有松哥手敲的 redis 教程</strong>）。</p><p>当然，学习 Spring Boot 最终我们还是奔着快速开发和微服务去的，所以，像 Docker、Spring Cloud 等技术，也是需要去了解一下的。</p><h2 id="4-怎么学"><a href="#4-怎么学" class="headerlink" title="4.怎么学"></a>4.怎么学</h2><p>Spring Boot 发展到今天，网上的资料和图书现在是越来越多了。在看资料学习的同时，大家也要留意以下几个点：</p><ol><li>多看源码。不同于其他全新的框架源码你可能会看懵了，由于 Spring Boot 是基于 Spring 的，所以只要你 Spring 基础扎实，看 Spring Boot 源码可以说是毫无压力。如果看 Spring Boot 源码觉得有压力，那可能你 Spring 基础不牢靠，这个时候不妨放下 Spring Boot，去复习下 Spring。</li><li>每当学会 Spring Boot 中的一个知识点，不妨想想这个功能在 Spring 框架中要如何使用，如何配置，两边都搞懂了，互相印证，加深对一个知识点的理解。</li><li>多多关注 Spring Boot 的发展动态。不同于传统的框架可能一年更新一两次，Spring Boot 更新非常频繁，二次每次更新都会带来一些好玩的东西，可能会有新的 API 加入进来，也可能会有旧的 API 失效，变化大，因此多多关注，避免掉坑。</li></ol><p>最后，我这里给大家列举几个我自己经常关注的几个资源。</p><h3 id="4-1-官方文档"><a href="#4-1-官方文档" class="headerlink" title="4.1 官方文档"></a>4.1 官方文档</h3><p>老实说，Spring Boot 的官方文档是我接触的所有官方文档中最条理清晰浅显易懂的，大家做开发，多多少少都接触过一些第三方的开放平台，很多平台的文档真是让人忍不住想吐槽，框架都做出来了，认认真真写个文档有那么难么？</p><p>不过 Spring Boot 的官方文档可以算是非常非常友好了。虽然是英文的，但是实际上对英文要求并不高，连读带猜，其实很容易明白它的含义，我一般对 Spring Boot 中某个知识点有疑问的时候，都是首选官方文档，当前最新版的官方文档地址是：</p><ul><li><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/html" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/html</a></li></ul><p>当然，如果你嫌官方文档打开慢，松哥也帮你下载好了最新版的 pdf，公众号后台回复 <code>springboot2.2.4</code> 可以获取。</p><h3 id="4-2-Spring-官方博客"><a href="#4-2-Spring-官方博客" class="headerlink" title="4.2 Spring 官方博客"></a>4.2 Spring 官方博客</h3><p>每次 Spring 或者 Spring Boot 发新版本，松哥都会去看一下新版本有哪些好玩的东西，增加了哪些内容。我不可能把源码读一遍然后总结出来它的变化，那一般是如何获取权威的第一手信息呢？关注 Spring 官方博客即可。</p><p>打开 Spring 官网，在顶部菜单里有一个选项就是 Blog，关于 Spring 家族产品的任何更新计划，更新结果，都会在这里通知到大家。</p><p><img src="http://www.javaboy.org/images/boot/132-1.png" alt></p><p>松哥也推荐大家多多关注这个 Blog，一方面能够及时接收到一手信息，另一方面还能提高英语，一举两得。宅在家，泡一壶茶，细细的品一品这个网站，真的蛮不错。</p><p>Blog 地址：</p><ul><li><a href="https://spring.io/blog" target="_blank" rel="noopener">https://spring.io/blog</a></li></ul><h3 id="4-3-中文资料"><a href="#4-3-中文资料" class="headerlink" title="4.3 中文资料"></a>4.3 中文资料</h3><p>说到中文资料，就不得不说松哥自己的在线教程和离线 pdf 文档了。手敲了 274 页教程，囊括了 Spring Boot2 常见的各种用法，即有离线的 pdf 供大家下载，也有在线的学习网站，这就是满满的诚意，还没下载 pdf 的小伙伴不要错过。</p><p><img src="http://www.javaboy.org/images/boot/132-2.png" alt></p><p>在线教程地址：</p><ul><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li></ul><p>离线 pdf 下载文档，在公众号后台回复 springboot 获取百度网盘地址。</p><h3 id="4-4-学习案例"><a href="#4-4-学习案例" class="headerlink" title="4.4 学习案例"></a>4.4 学习案例</h3><p>除了这些文字性的东西之外，一些在线案例也至关重要。这里给大家推荐两个仓库，这两个仓库中的所有案例都是基于 Spring Boot2 来做的。</p><p>首先就是我公众号上文章的配套案例：</p><p>GitHub 地址：</p><ul><li><a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></li></ul><p>Gitee 地址：</p><ul><li><a href="https://gitee.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://gitee.com/lenve/javaboy-code-samples</a></li></ul><p>这个仓库中的大部分案例都是针对 Spring Boot 的，而且有一个好处就是这些案例都有对应的讲解文章，每个案例都对应一个文章，岂不美哉。</p><p><img src="http://www.javaboy.org/images/boot/132-3.png" alt></p><p>另一个仓库就是我整理的比较完善的一个仓库，但是就没有对应的讲解文章了：</p><p>GitHub 地址：</p><ul><li><a href="https://github.com/lenve/javaboy-video-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-video-samples</a></li></ul><p>Gitee 地址：</p><ul><li><a href="https://gitee.com/lenve/javaboy-video-samples" target="_blank" rel="noopener">https://gitee.com/lenve/javaboy-video-samples</a></li></ul><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>资料贵精不贵多，关键是要动手去学。大学时候，有的同学热衷于收集各种资料，电脑硬盘塞得满满的，但是就是不学，这些资料再多也没有用。</p><p>当然，如果大家对松哥自己录制的 Spring Boot+Vue+微人事+Spring Cloud 视频教程感兴趣，也可以看看这篇文章：<a href="https://mp.weixin.qq.com/s/8FmgtWyz6HUIbF4smXQOwQ" target="_blank" rel="noopener">Spring Boot + Vue 视频教程喜迎大结局，西交大的老师竟然都要来一套！</a>，或者加下面的微信咨询。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/GvtDGKK4uYlKAUAF6FBTMiallA1DXTnOfgmwKGKgk9cIAc2eDwFuxiaZKcMDkJ3YdklibgB66mSOpy1wjex1SUaug/0?wx_fmt=jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可能很多刚接触 Spring Boot 的小伙伴都会有这样的疑问，Spring Boot 要怎么学，要不要先学 SSM？今天结合自己的经验，和大家说一说我的看法，也顺便推荐几个 Spring Boot 学习资料。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>新年新气象，接个私活赚点生活费？恐怕事情没有这么简单</title>
    <link href="http://www.javaboy.org/2020/0221/outsource.html"/>
    <id>http://www.javaboy.org/2020/0221/outsource.html</id>
    <published>2020-02-21T02:16:00.000Z</published>
    <updated>2020-03-05T02:55:29.195Z</updated>
    
    <content type="html"><![CDATA[<p>现在到处讲副业，怎么样利用副业赚钱，这能理解，一方面年轻人生存压力大，多赚钱点总是没有坏处；另一方面，每年的裁员信息看的人心惊胆颤，大家都想为自己留一条后路。</p><a id="more"></a><p>新年伊始，想必很多小伙伴可能都想大展拳脚，新的一年好好干一番，很多人就想到了接私活，但是接私活到底赚不赚钱，这里有哪些坑，松哥和大家扯扯。</p><p>松哥刚毕业的时候做 Android 开发，在做 Android 期间基本上没有接过私活，因为 Android 有一个特点，就是应用看着很简单，在甲方眼里可能就是画几个页面，但是实际操作起来，要考虑各种各样的机型适配、屏幕适配、甚至系统适配（由于国内厂商做了各种定制带来的）等操作，也算是一件非常费力的事情。由于和甲方这种认知上的差异， Android 的活很难谈上价钱，所以就没接过。</p><p>直接接应用做虽然没有做过，但是 Android 有另外一个灰产，就是做“二次打包”的羊毛党，这个几乎不需要很高的技术手法，把别人发布的 App 拿来，拆包之后，加入自己的私货（大部分情况下可能是广告），然后再发布出去供用户下载，就能赚钱了。由于 Android 的开源，加上二次打包成本低，导致这一现象曾经非常猖獗，在 Google Play 排名前 100 位的应用中，有 60% 的应用出现了二次打包版本，而这 60% 的应用中，大部分都是游戏类应用，高 ARPU 游戏，单个安装激活价也比较高。</p><p>我当时在广州上班，上海有同事做过这个，但是据我了解到的，他们这种一般也是需要多个人协作的，分配到程序员手里的就是拆包打包的活，工作的可替代性较强，所以其实能赚到的钱也是非常有限的（除非一个人搞定整个链条，那就很有赚头了）。</p><p>总之呢，当我还是一个 Android 猿的时候，其实是没有赚到什么外快的，虽然当时国内的一些接单平台都注册了，也经常登录上去看看有没有合适的，但从来没找到合适的。直到变成了一只 Java 猿，事情才有了转机。</p><p>下面我从几个不同的方面来和大家介绍接活的一些常见问题。</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>当我还是一名 Android 工程师的时候，我每次登录一些接单平台，找 Android 相关的活，但是人家大部分都是希望能够 Android、iOS 以及 Web App 同时做，这就比较麻烦了，你还得学 iOS，要么就是跨平台方案，所以我在 2016 年的时候，还搞了一段时间的 RN，不过跨平台方案不一定适用于有所场景，有的应用没法使用跨平台方案。</p><p>如果自己不想学，也可以搞一个团队来做，但是找一个靠谱的搭档其实也挺不容易的，外包赚的是辛苦钱，不一定大家都有这个意愿，而且很多人没接触这个行业，对报价有一些误解，经常乱报，当时有一个在北京总部的同事，做 iOS 的，我联系他，他直接报了一个天价，吓得我再也不敢找他了。</p><p>所以当我从 Android 切换到 Java 上之后，我一直在尝试走的路线就是全栈路线，我希望能够做到从前端到后端到架构一个人独立完成，当然这需要我付出巨大的学习成本，事实上我也确实花费了很大的时间去搞定这一套方案，直到今天，我还在继续完善自己的技术栈。</p><p>当你能独立搞定前后端这一整套方案，再去接私活就会灵活很多了，价钱、工期、技术栈等等，都有你自己来掌握。</p><p>当然，如果你不具备全栈开发的能力，但是有一些长期稳定合作的技术小伙伴，互相之间比较熟悉也比较信任，大家分工合作各司其职，那也可以，每个人的技术压力会小一些，而且技术选型可能也会更加灵活。</p><p><strong>这一块比较忌讳的是临时拉人头，临时凑一个水平参差不齐的团队，项目上线前夕想哭都没眼泪。</strong></p><h2 id="接活"><a href="#接活" class="headerlink" title="接活"></a>接活</h2><p>接活的话，这个我觉得要分情况。大家经常会在网上看到别人总结的一大堆接活平台，老实说，我几乎所有平台都注册过，但是从来没有接成功过，而且曾经差点被一个厦门的平台坑过，这个我一会和大家说。</p><p>在平台接活主要有两方面的问题：</p><ol><li>平台上的项目规模可能比较大，而且大多需要企业资质，个人开发者生存空间较小</li><li>互相之间不信任，要通过平台完成付款和验收等操作，这无形中增大了工作量</li></ol><p>基于这两点原因，我觉得个人开发者在平台上并不太好接活，那么怎么接？这个时候就考验你的人脉资源了。</p><p>松哥做过的几个外包，非常巧合的都是和学校有关，一个是给西藏大学的小程序，一个是给哈尔滨工程大学某老师做的，这两个，一个是我当时的领导给介绍的，另外一个是我高中室友介绍的，因为哈工程那个老师是我室友在西交大的师兄，除了这两个项目也做过几个国外的项目，国外项目是我在深圳的朋友介绍的。</p><p>因为都是朋友介绍的，也都比较信任，这样收款相对来说就要随意很多，事实上我做的几个项目都没遇到过因为项目质量或者尾款扯皮的事，所有事情都比较顺利。而如果是从平台上接的活，那么一般来说要严格签订合同，然后约定付款期限等。</p><p>那么平台也有一种比较坑的运作方式，大家要是注册过很多平台可能会遇到这种。有一类平台，当你注册成功之后，他会利用你急着接单的心里，打电话告诉你，他们有许多单需要派发，但是需要你先交会员费（是的，你没看错，你本来是想赚钱的，结果钱没见到，反而先被平台赚了一把），而且这个会员费基本上也不便宜，都得万把块，甚至更多。松哥身边有人掉到这个坑里了，他交了钱之后，平台确实给他派单了，但是都是几百块钱的单子，千把块的单子都很少，他说干个两三年，能回本就不错了。这里的坑就比较多了，我在知乎上也看到过相关的讨论，反正大家如果见到有平台让你先交钱，那么一定要拒绝。</p><h2 id="报价"><a href="#报价" class="headerlink" title="报价"></a>报价</h2><p>报价也是一个技术活，价钱不是漫天要价的，它有一个计算公式，先根据项目的工作量，大致上估算一个工期出来，比如这个项目你预计如果每天干 8 小时，需要 20 天才能完工，那这个 20 天就是工期，然后乘以你目前的日工资，比如你的日工资是 1000 块，那就乘以 1000，然后再上浮 30% 左右作为利润，最终得到的报价就是：</p><p><code>20*1000*1.3=26000</code></p><p>30% 这个可以根据项目的难易程度，技术含量等灵活调整，一般如果是企业级后台应用的话，其实是没有太多可圈可点的技术点的，都是一些常规技术，所以利润不会太高。</p><p>但是大家知道，无论是自己接私活，还是在公司里干活，项目需求都很难一步到位，未来都不可避免的需要更改。一般来说，如果是一些小的变动，我都选择忍。也遇到一些需要大规模更改的，这种该加钱就让加钱，该拒绝就要拒绝，不然累的是自己，而且要重新约定工期。当然，如果签订了合同的话，其实没啥太多问题，按照合同走就行了。</p><h2 id="合同"><a href="#合同" class="headerlink" title="合同"></a>合同</h2><p>合同的话，其实我之前拟定过。做哈工程老师的项目的时候，对方希望能够签订一个合同，那就签订吧。其实我一直觉得如果能签合同最好签，这对双方都有好处。然后我就在网上找了一个合同模版，自己改了下，然后找了一个学法律的同学帮我审了一遍合同，确定没什么问题，发给对方。但是在后来的实际操作中，双方都比较自觉，所以合同其实又放一边了。</p><p>大家可以在松哥公众号后台回复 <code>外包合同</code> 获取这份合同模版，大家自己以后如果签订外包合同时可以作为参考。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总的来说呢，接私活赚到的都是辛苦钱，因为我们要牺牲自己的休息时间，利用休息时间去做事情，而一般能够外包出来的项目也没有特别大的技术含量，所以普遍利润不高，而且也谈不上通过项目自我提升，小打小闹可以，但是如果想把它作为一个长期的事业来做的话，我其实是不太建议的。</p><p>长期的话，我觉得大家做一个产品，可能更有赚头一些，例如做一个完整的 erp、一个完整的 crm 或者 cms、wms 等，做一个产品，然后在接活的时候，接同一个领域的活，例如都是 erp、都是 crm ，这样，原本的代码随便改改就能用了，这样，利润就会高很多。也只有这种形式的外包，有赚头。</p><p>好了，小伙伴们有什么兼职接外包的经验，也可以来说说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在到处讲副业，怎么样利用副业赚钱，这能理解，一方面年轻人生存压力大，多赚钱点总是没有坏处；另一方面，每年的裁员信息看的人心惊胆颤，大家都想为自己留一条后路。&lt;/p&gt;
    
    </summary>
    
      <category term="外包" scheme="http://www.javaboy.org/categories/%E5%A4%96%E5%8C%85/"/>
    
    
      <category term="外包" scheme="http://www.javaboy.org/tags/%E5%A4%96%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>简化微人事部署，Flyway 搞起来</title>
    <link href="http://www.javaboy.org/2020/0219/springboot-flyway.html"/>
    <id>http://www.javaboy.org/2020/0219/springboot-flyway.html</id>
    <published>2020-02-19T02:15:43.000Z</published>
    <updated>2020-03-05T02:56:21.305Z</updated>
    
    <content type="html"><![CDATA[<p>虽然我之前录了一个微人事部署视频（<a href="https://mp.weixin.qq.com/s/FoNVyAR1BkYfutFq9sjJNQ" target="_blank" rel="noopener">新版微人事部署教程来啦</a>），但是由于这次升级涉及到了 Redis 和 RabbitMQ，所以在本地跑微人事还是一件比较麻烦的事情，有的小伙伴甚至部署失败，所以我也一直在尝试简化部署步骤，这两天给项目加了 Flyway，数据库准备这块算是得到了一定程度简化。</p><a id="more"></a><p>今天就和大家来大致说说 Flyway 的用法，以及如何在微人事中使用 Flyway。</p><h2 id="1-什么是-Flyway"><a href="#1-什么是-Flyway" class="headerlink" title="1.什么是 Flyway"></a>1.什么是 Flyway</h2><p>我们在公司做开发时，由于项目需求的变化，或者前期设计缺陷，导致在后期需要修改数据库，这应该是一个比较常见的事情，如果项目还没上线，你可能把表删除了重新创建，但是如果项目已经上线了，就不能这样简单粗暴了，我们需要通过 SQL 脚本在已有数据表的基础上进行升级。</p><p>目前 Java 这块，想要对数据库的版本进行管理主要有两个工具：</p><ul><li>Flyway</li><li>Liquibase</li></ul><p>两个工具各有千秋，但是核心功能都是数据库的版本管理，这里主要来看 Flyway。就像我们使用 Git 来管理代码版本一样，Flyway 可以用来管理数据库版本。</p><p>好了，接下来我们就来看看用 Flyway 如何简化微人事部署，然后再来说说 Flyway 的一个大致原理。</p><h2 id="2-嵌入到微人事"><a href="#2-嵌入到微人事" class="headerlink" title="2.嵌入到微人事"></a>2.嵌入到微人事</h2><p>如果是在一个全新的项目中使用 Flyway，那么在新建一个 Spring Boot 项目时，就有 Flyway 的选项，如下图：</p><p><img src="http://www.javaboy.org/images/boot/134-1.png" alt></p><p>项目创建成功后，resources 目录下也会多出来一个 db/migration 目录，这个目录用来存放数据库脚本，如下：</p><p><img src="http://www.javaboy.org/images/boot/134-2.png" alt></p><p><strong>注意</strong></p><p>这个如果创建项目时就选择了 Flyway 依赖，就会有这个目录。现在我要在已经做好的微人事中加入 Flyway，这个目录就需要我手动创建了。</p><p>首先在微人事中添加 flyway 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.flywaydb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flyway-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 vhr-web 模块下的 resources 目录下，手动创建 db/migration 目录，然后在该目录下创建数据库脚本，数据库脚本的命名方式如下：</p><ul><li><code>V&lt;VERSION&gt;__&lt;NAME&gt;.sql</code></li></ul><p>首先是大写字母 V，然后是版本号，要是有小版本可以用下划线隔开，例如 2_1，版本号后面是两个下划线，然后是脚本名称，文件后缀是 .sql。</p><p>例如我这里创建我的第一个数据库脚本，取名为 <code>V1__vhr.sql</code>，脚本内容就是微人事的数据库脚本，大家可以在 <a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a> 这里获取到。</p><p>完了之后，可以不用添加额外配置，大家只需要在本地 MySQL 中创建一个空的 vhr 数据库即可，然后直接启动微人事项目，项目启动成功后，我们查看启动日志：</p><p><img src="http://www.javaboy.org/images/boot/134-3.png" alt></p><p>从这段启动日志中，我们可以看到 Flyway 的执行信息，数据库脚本的执行执行，同时这里还说了，Flyway 还给创建了一个 flyway_schema_history 表，这个表用来记录数据库的更新历史。</p><p>这个时候，打开本地数据库，我们发现 vhr 库中该有的表都有了。同时还发现了 flyway_schema_history 表，如下：</p><p><img src="http://www.javaboy.org/images/boot/134-4.png" alt></p><p>有了这条记录，下次再启动 vhr 项目，V1__vhr.sql 这个脚本文件就不会执行了，因为系统知道这个脚本已经执行过了，如果你还想让 V1__vhr.sql 脚本再执行一遍，需要手动删除 flyway_schema_history 表中的对应记录，那么项目启动时，这个脚本就会被执行了。</p><h2 id="3-执行细节"><a href="#3-执行细节" class="headerlink" title="3.执行细节"></a>3.执行细节</h2><ul><li>我们在定义脚本的时候，除了 V 字开头的脚本之外，还有一种 R 字开头的脚本，V 字开头的脚本只会执行一次，而 R 字开头的脚本，只要脚本内容发生了变化，启动时候就会执行。</li><li>使用了 Flyway 之后，如果再想进行数据库版本升级，就不用该以前的数据库脚本了，直接创建新的数据库脚本，项目在启动时检测了有新的更高版本的脚本，就会自动执行，这样，在和其他同事配合工作时，也会方便很多。因为正常我们都是从 Git 上拉代码下来，不拉数据库脚本，这样要是有人更新了数据库，其他同事不一定能够收到最新的通知，使用了 Flyway 就可以有效避免这个问题了。</li><li>所有的脚本，一旦执行了，就会在 flyway_schema_history 表中有记录，如果你不小心搞错了，可以手动从 flyway_schema_history 表中删除记录，然后修改 SQL 脚本后再重新启动（生产环境不建议）。</li></ul><h2 id="4-其他配置"><a href="#4-其他配置" class="headerlink" title="4.其他配置"></a>4.其他配置</h2><p>在 Spring Boot 中，关于 Flyway 也有不少配置，这些配置都在 application.properties 中进行配置，常用的几个来和大家说下：</p><ul><li>spring.flyway.enabled：是否开启 flyway，默认就是开启的</li><li>spring.flyway.encoding：flyway 字符编码</li><li>spring.flyway.locations：sql 脚本的目录，默认是 classpath:db/migration，如果有多个，用 , 隔开</li><li>spring.flyway.clean-disabled：这个属性非常关键，它表示是否要清除已有库下的表，如果执行的脚本是 V1__xxx.sql，那么会先清除已有库下的表，然后再执行脚本，这在开发环境下还挺方便，但是在生产环境下就要命了，而且它默认就是要清除，生产环境一定要自己配置设置为 true。</li><li>spring.flyway.table：配置数据库信息表的名称，默认是 flyway_schema_history。</li></ul><p>好了，关于 Flyway 我就先说这么多，代码也已经更新到 vhr 上了，感兴趣的小伙伴不妨下载试一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然我之前录了一个微人事部署视频（&lt;a href=&quot;https://mp.weixin.qq.com/s/FoNVyAR1BkYfutFq9sjJNQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;新版微人事部署教程来啦&lt;/a&gt;），但是由于这次升级涉及到了 Redis 和 RabbitMQ，所以在本地跑微人事还是一件比较麻烦的事情，有的小伙伴甚至部署失败，所以我也一直在尝试简化部署步骤，这两天给项目加了 Flyway，数据库准备这块算是得到了一定程度简化。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Flyway" scheme="http://www.javaboy.org/tags/Flyway/"/>
    
  </entry>
  
  <entry>
    <title>27 岁了</title>
    <link href="http://www.javaboy.org/2020/0218/27.html"/>
    <id>http://www.javaboy.org/2020/0218/27.html</id>
    <published>2020-02-18T02:15:27.000Z</published>
    <updated>2020-03-05T02:56:53.616Z</updated>
    
    <content type="html"><![CDATA[<p>今天过生日，满 27 岁了。</p><a id="more"></a><p>人说三十而立，三十这个数字越来越近，从今天开始算，离三十岁还有整整三年，1096 天，而三年后真的就可以而立吗？老实说，心里压力蛮大的。</p><p>小时候过生日母亲总是包饺子，而我那时候一点都不喜欢吃饺子，我只想吃一包方便面，那会也叫干脆面，但是从来没有得到满足。有一年父亲出车祸，我还很小，还没上学，母亲在医院照顾父亲，我被寄养在外婆家和姑姑家，因为外婆家和姑姑家离得近，我经常趁外婆不注意跑去姑姑家或者趁姑姑不注意跑去外婆家，那年过生日时姑姑也给我包的饺子，好像大人们都一致觉得饺子就是好东西（二十年后，我也终于明白，饺子确实不错）。</p><p>上初二的时候，和同学们一起过了一次生日，那是我第一次吃生日蛋糕，好多小伙伴在晚饭后来我租的地方玩，满满的感动，小伙伴们带来的小礼品有不少现在还放在老家的箱子里。</p><p>也是在初中的时候，对于生日的态度发生了一些变化，自己何德何能，要过这个节日。如果有一天，自己有了孩子，可以接受孩子的祝福，或者分担了父母的压力，或者为这个社会作出了贡献，那就可以心安理得的过生日了。从那以后，就很少和人提起过生日了，高中时候陷入深深的自卑中，更不可能过生日。</p><p>上大学后有了女朋友，每年她都会很认真的对待这一天，而我经过高中三年的煎熬，对待生日已经变得比较佛系了，但是每一次生日，女朋友总能让我感动。大一时候，女朋友在宿舍简陋的环境下竟然捣鼓了一碗长寿面出来给我，那是我第一次知道长寿面，我虽然家在北方，日常也以面食为主，但是生日我们那里好像还是习惯吃饺子，没怎么听说过长寿面。</p><p>大一时候习惯泡在图书馆，大二时候习惯泡自习室，大三大四在老师提供的一个房间里搞 Java，像个独行侠一样很少和同学一起玩，也包括大学室友。有一次过生日，女朋友发了一个朋友圈，我回到宿舍室友都知道我过生日，一定要出去撸串，于是，半夜十二点宿舍四个人又一起出去撸串。这件事也令我印象深刻，因为我高中之后变得比较孤僻，很多时候独来独往，但是身边的室友小伙伴不和我计较，感谢他们的包容。</p><p>27 年，关于生日，就记得这些了。</p><p>很多时自己像耕牛一样，闲着没事的时候，就会把曾经的往事翻出来一一咀嚼，感觉做的不对的事情会充满愧疚，感觉做的好的事情，则自己就在那里傻笑。</p><p>三十而立，三十近在咫尺，就快要变成传说中油腻的中年男人了，希望到时候不油腻。加油吧骚年。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天过生日，满 27 岁了。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="程序人生" scheme="http://www.javaboy.org/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>懒人必备，IntelliJ IDEA中代码一键生成</title>
    <link href="http://www.javaboy.org/2020/0214/intellij-idea-easycode.html"/>
    <id>http://www.javaboy.org/2020/0214/intellij-idea-easycode.html</id>
    <published>2020-02-14T02:14:34.000Z</published>
    <updated>2020-03-05T02:58:55.444Z</updated>
    
    <content type="html"><![CDATA[<p>之前有不少小伙伴问松哥微人事项目(<a href="https://github.com/lenve/vhr)使用的" target="_blank" rel="noopener">https://github.com/lenve/vhr)使用的</a> MyBatis 逆向工程在哪里？其实旧版微人事当时没有使用逆向工程，是我自己手动敲出来的，当然手动敲的工作量非常大。</p><a id="more"></a><p>今年发出来的新版微人事，我使用了逆向工程自动生成实体类和 dao 层的代码。MyBatis 的逆向工程要么需要添加依赖，要么需要自己去网上下载 jar，用起来还是有点麻烦，所以，今天和小伙伴们介绍一款 IntelliJ IDEA 上的免费开源插件，叫做 EasyCode，可以方便的根据数据库生成相应的代码。</p><p>EasyCode 是基于 IntelliJ IDEA 开发的代码生成插件，支持自定义任意模板（Java，html，js，xml）；只要是与数据库相关的代码都可以通过自定义模板来生成；支持数据库类型与 java 类型映射关系配置；支持同时生成生成多张表的代码，张表有独立的配置信息，完全的个性化定义，规则由你设置。</p><p>我自己也稍微体验了一把，还是蛮方便的。</p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>首先点击 File-&gt;Settings-&gt;Plugins，然后搜索 EasyCode，如下：</p><p><img src="http://www.javaboy.org/images/tools/131-1.png" alt></p><p>安装成功之后，重启 IDEA。</p><h2 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h2><p>接下来我给大家演示一个如何在 Spring Boot 中使用 EasyCode。首先我们在 IDEA 中创建一个 SpringBoot 项目，创建过程我就不多说了，如果大家不会，可以在我公众号后台回复 <code>springboot</code>，有详细的教程。</p><h2 id="3-添加数据源"><a href="#3-添加数据源" class="headerlink" title="3.添加数据源"></a>3.添加数据源</h2><p>由于这个项目是基于 IDEA 上的 Database Tools 开发的，因此我们首先要通过 IDEA 上的 Database 连接数据源。</p><p><img src="http://www.javaboy.org/images/tools/131-2.png" alt></p><p>接下来配置你的数据库连接信息，如果没有检测到合适的数据库 Driver，点击左下角自动下载：</p><p><img src="http://www.javaboy.org/images/tools/131-3.png" alt></p><p>连接成功后，点击 OK。默认情况下没有展示连接下的数据库，需要我们手动勾选，例如我这里要连接 vhr 数据库，如下：</p><p><img src="http://www.javaboy.org/images/tools/131-4.png" alt></p><h2 id="4-生成代码"><a href="#4-生成代码" class="headerlink" title="4.生成代码"></a>4.生成代码</h2><p>做完前面三步，准备工作就算 OK 了，接下来就是生成代码了。例如我想给 vhr 中所有的代码生成实体类、dao 层以及 service 层，方式如下：</p><p>首先选中所有的表，然后右键单击，选择 Easy Code-&gt;Generate Code，如下：</p><p><img src="http://www.javaboy.org/images/tools/131-5.png" alt></p><p>第一次添加的时候，如果有数据库类型没有对应的 Java 类型，就会有提示，这个根据它的引导去添加映射关系即可，例如我在添加的时候，出了一个这个提示：</p><p><img src="http://www.javaboy.org/images/tools/131-6.png" alt></p><p>点击 Yes，然后去添加自己的类型映射：</p><p><img src="http://www.javaboy.org/images/tools/131-7.png" alt></p><p>添加成功之后，再去做代码生成，这下就可以了：</p><p><img src="http://www.javaboy.org/images/tools/131-8.png" alt></p><p>这里，如果项目是多模块项目，可以先选择代码生成的 Module，然后设置代码生成的 package，最后从下面勾选要生成的代码模版，点击 OK 即可。</p><blockquote><p>在代码生成的过程中，如果没检测到 package 下面有 service、dao 以及 entity 等包，工具会提示自动创建，点击 Yes 即可。</p></blockquote><p>最终生成的代码如下：</p><p><img src="http://www.javaboy.org/images/tools/131-9.png" alt></p><p>至此，各层的代码基本都生成了。大部分小伙伴用到这一步可能就 OK 了。</p><p>当然如果你觉得 EasyCode 自动生成的模版不够用，或者不好用，我们也可以自定义模版。</p><h2 id="5-自定义模版"><a href="#5-自定义模版" class="headerlink" title="5.自定义模版"></a>5.自定义模版</h2><p>例如，我想在生成的 dao 层代码中，额外添加一个不需要任何条件，获取所有数据的方法（默认的生成模版中没有这个方法）。</p><p>点击 File-&gt;Settings-&gt;Easy Code-&gt;Template Setting：</p><p><img src="http://www.javaboy.org/images/tools/131-10.png" alt></p><p>可以参考工具自己的定义方式，我们现在先在dao.java 中，添加如下方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 查询所有数据</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> $!tool.firstLowerCase($!&#123;tableInfo.name&#125;) 实例对象</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line">List&lt;$!&#123;tableInfo.name&#125;&gt; getAll();</span><br></pre></td></tr></table></figure><p>然后再给它添加一个配套的 mapper.xml 中的方法，打开 mapper.xml ，添加如下方法：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAll"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"$!&#123;tableInfo.name&#125;Map"</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">      #allSqlColumn()</span><br><span class="line">    from $!&#123;tableInfo.obj.parent.name&#125;.$!tableInfo.obj.name</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成后，点击 OK。</p><p>接下来再去重新生成代码，就可以看到生成的方法中多了一个方法了，其他代码模版的定义与这个类似，我就不再赘述了。</p><p>好了，小伙伴们不妨试试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有不少小伙伴问松哥微人事项目(&lt;a href=&quot;https://github.com/lenve/vhr)使用的&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lenve/vhr)使用的&lt;/a&gt; MyBatis 逆向工程在哪里？其实旧版微人事当时没有使用逆向工程，是我自己手动敲出来的，当然手动敲的工作量非常大。&lt;/p&gt;
    
    </summary>
    
      <category term="IntelliJ IDEA" scheme="http://www.javaboy.org/categories/IntelliJ-IDEA/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="IDEA，EasyCode" scheme="http://www.javaboy.org/tags/IDEA%EF%BC%8CEasyCode/"/>
    
  </entry>
  
  <entry>
    <title>背上一袋包子，西北小伙又要进城务工了</title>
    <link href="http://www.javaboy.org/2020/0213/start.html"/>
    <id>http://www.javaboy.org/2020/0213/start.html</id>
    <published>2020-02-13T02:14:20.000Z</published>
    <updated>2020-03-05T02:59:58.938Z</updated>
    
    <content type="html"><![CDATA[<p>昨天松哥也终于返程回到深圳了，这次回家宅了二十多天了，上周开始远程处理工作，但是呆在家里总感觉不在状态，还是想回深圳。</p><a id="more"></a><p>很多还没返程的小伙伴可能会好奇最近路上交通是个啥情况，深圳这边机场检查严不严格，我就把这一路返程的经过写一下，给大家一个参考。</p><p>首先无论是高铁还是高铁还是飞机，很多车次/航班都停运了，我是在 1 月 30 号就订了 2 月 12 号西安到深圳的机票，但是在 2 月 11 号下午 5 点的时候航班突然取消了，无奈又只好重新订了另外一个航班，还是 2 月 12 号出发，好在价格还能接受，只比取消的航班贵了 200 块。因为实在是积压了不少事情，急需返程：</p><p><img src="http://www.javaboy.org/images/other/130-1.jpeg" alt></p><p>春节回去的时候村里已经不让进了，家里人也都在西安，所以索性就没回老家，春节期间一直呆在西安，西安最近的管控比较严格：</p><ul><li>小的方面，小区出入要登记，一家在两天之内只能有一个人出去购物。</li><li>大的方面，非陕 A 牌照禁止进西安；然后就是身份证或者户口本不是西安的禁止进西安；第三就是外地人除非有当地社区开具的健康证明和单位开具的复工证明才让进西安，高铁站和机场都有人在检查，可以算是非常严格了。</li></ul><p>西安的机场在咸阳，西安和咸阳都不允许外地车辆进入，所以出发之前有点担心西安的出租车能不能去咸阳，要是不能去就只能先到西安北站，然后坐机场城际到咸阳，不过后来发现是我多虑了。</p><p>小区楼下最近都没啥车，道路空空荡荡：</p><p><img src="http://www.javaboy.org/images/other/130-2.jpeg" alt></p><p>拦了十多分钟终于拦下一辆车，出租车师傅说他本来是打算去出租车公司开证明的，因为现在各个小区每户两天只能出来一个人，他没法每天都出来开车，开了证明，就可以每天都出来了，然后跟师傅闲聊了一会知道现在西安的出租车去咸阳只能去机场，其他地方去不了。</p><p>去机场走福银高速，过收费的时候西安往咸阳方向没啥车，但是咸阳往西安方向堵了一小段，好像是在查体温。去机场一路上都没啥车，原本四五十分钟的路程，今天不到半小时就到了。</p><p>机场也没啥人，空空荡荡：</p><p><img src="http://www.javaboy.org/images/other/130-3.jpeg" alt></p><p>进去的时候，会测量一次体温。柜台也没什么人：</p><p><img src="http://www.javaboy.org/images/other/130-4.jpeg" alt></p><p>大家要是没有行李托运的话，可以下载一个航旅纵横 App，办理自助值机，然后用电子登机牌，这样到机场后就可以直接去安检了，省事一些，我因为老母亲怕我在深圳饿着，装了一箱子吃的，所以要去办理托运，不过柜台人不多。在柜台办理托运的时候，有一个二维码需要扫描，扫完之后是一个航班旅客信息登记卡，这个卡主要是问你从哪里来，目的地的详细地址，是否曾经到过湖北或者接触过来自湖北的患者等等，扫码之后填好即可。奇怪的是这些填写信息在上飞机后还需要再填写一个纸质版的，这个一会说。</p><p>过安检的时候，大家排队都挺自觉的，神排队法：</p><p><img src="http://www.javaboy.org/images/other/130-5.jpeg" alt></p><p>过完安检，登机口人很少，我还以为机票也是座位错开销售的，所以可能人不多，后来发现是大家都很自觉的分散在其他地方，到了登机时间突然排了好长一条队。上飞机的时候每人发了一个旅客信息登记卡：</p><p><img src="http://www.javaboy.org/images/other/130-6.jpeg" alt></p><p>跟一开始扫描二维码填的内容是一样的，在飞机上会对每个人逐个测量体温，然后发一支笔填写这张表格。我觉这个操作也用扫描二维码就行了，因为飞机上的笔只有几只，所有人轮着用，效率低，也存在潜在的风险。</p><p>另外就是飞机上也是座无虚席，虽然疫情严重，但是很多人还是要返回工作地。</p><p>到深圳之后，深圳地面的管理超级宽松，这让我挺吃惊的，因为深圳大部分都是外地人，按理说防疫的压力很大，但是只有在出机场的时候测了一下体温，也没人检查身份证，没人问你从哪里来，出去之后直接自己打车回家。深圳机场也挺空旷的，人不多，打车都不用排队，直接上车，这是出租车候车的地方，都没人排队：</p><p><img src="http://www.javaboy.org/images/other/130-7.jpeg" alt></p><p>出租车上，司机会让扫一个小程序码填一下自己的联系信息，这个应该是防止司机不幸接触到病例，方便通知坐过该车的其他人。我觉得这个办法挺好的，因为在西安也发生了类似的情况，就是患者在确诊之前乘坐过出租车，确诊之后就只能通过新闻去通知坐过该车的其他人，但是很多打车的人可能都不一定记得自己坐过的的士的车牌号，所以排查难度挺大的，如果能够留下每一个乘客的信息，排查就会方便很多。</p><p><img src="http://www.javaboy.org/images/other/130-8.jpeg" alt="这是之前新闻报道西安的病例"></p><p>回到住处后，房东也会发一个登记表，填写好之后就完事了：</p><p><img src="http://www.javaboy.org/images/other/130-9.jpeg" alt></p><p>好了，总算回来了。听说昨天长沙到深圳的高铁也是座无虚席，没有像前两天那样座位错开卖票了，所以小伙伴们返程还是需要注意戴好口罩保护好自己。</p><p>回来路上看了下，街边的便利店好几家都开门了，快餐店则基本没开门，一些在线买菜的服务也都畅通，可以使用，所以生活还算是蛮便利的。从西安走的时候，老母亲怕我在深圳买不到吃的，给我带了一锅包子又带了三个烙饼，这些估计能吃一个礼拜：</p><p><img src="http://www.javaboy.org/images/other/130-10.jpeg" alt><br><img src="http://www.javaboy.org/images/other/130-11.jpeg" alt></p><p>好了，开始 14 天的居家远程办公。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天松哥也终于返程回到深圳了，这次回家宅了二十多天了，上周开始远程处理工作，但是呆在家里总感觉不在状态，还是想回深圳。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="程序人生" scheme="http://www.javaboy.org/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Redis 系列教程(二)Redis中的五种数据类型</title>
    <link href="http://www.javaboy.org/2020/0211/redis.html"/>
    <id>http://www.javaboy.org/2020/0211/redis.html</id>
    <published>2020-02-11T02:12:40.000Z</published>
    <updated>2020-03-05T03:00:51.250Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们介绍了如何在Linux中安装Redis，本文我们来了解下Redis中的五种数据类型。</p><a id="more"></a><h2 id="五大数据类型介绍"><a href="#五大数据类型介绍" class="headerlink" title="五大数据类型介绍"></a>五大数据类型介绍</h2><p>redis 中的数据都是以 key/value 的形式存储的，五大数据类型主要是指 value 的数据类型，包含如下五种：</p><h3 id="STRING"><a href="#STRING" class="headerlink" title="STRING"></a>STRING</h3><p>STRING 是 redis 中最基本的数据类型，redis 中的 STRING 类型是二进制安全的，即它可以包含任何数据，比如一个序列化的对象甚至一个 jpg 图片，要注意的是 redis 中的字符串大小上限是 512M。</p><h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><p>LIST 是一个简单的字符串列表，按照插入顺序进行排序，我们可以从 LIST 的头部(LEFT)或者尾部(RIGHT)插入一个元素，也可以从 LIST 的头部(LEFT)或者尾部(RIGHT)弹出一个元素。</p><h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><p>HASH 类似于 Java 中的 Map，是一个键值对集合，在 redis 中可以用来存储对象。</p><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>SET 是 STRING 类型的无序集合，不同于 LIST，SET 中的元素不可以重复。</p><h3 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h3><p>ZSET 和 SET 一样，也是 STRING 类型的元素的集合，不同的是 ZSET 中的每个元素都会关联一个 double 类型的分数，ZSET 中的成员都是唯一的，但是所关联的分数可以重复。 </p><p>OK，通过上面的介绍，相信小伙伴们对五大数据类型都有一个大致的认识了，接下来我们就来看看这五种数据类型要怎么操作。</p><h2 id="key相关的命令"><a href="#key相关的命令" class="headerlink" title="key相关的命令"></a>key相关的命令</h2><p>由于五大数据类型的数据结构本身有差异，因此对应的命令也会不同，但是有一些命令不管对于哪种数据类型都是存在的，我们今天就先来看看这样一些特殊的命令。</p><p>首先通过 <code>redis-server redis.conf</code> 命令启动redis，再通过 <code>redis-cli</code> 命令进入到控制台中，如下：</p><p><img src="https://wx4.sinaimg.cn/mw690/6b239626gy1frit1lvhlaj20ft02vglh.jpg" alt="p295"></p><p>首先我们可以通过 set 命令插入一条记录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 v1</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="DEL-命令"><a href="#DEL-命令" class="headerlink" title="DEL 命令"></a>DEL 命令</h3><p>看到 OK 表示插入成功。通过 DEL 命令我们可以删除一个已经存在的 key，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; DEL k1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>看到(integer) 1表示数据已经删除成功。</p><h3 id="DUMP命令"><a href="#DUMP命令" class="headerlink" title="DUMP命令"></a>DUMP命令</h3><p>DUMP 命令可以序列化给定的 key，并返回序列化之后的值：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; DUMP k1</span><br><span class="line">&quot;\x00\x02v1\b\x00\xe6\xc8\\\xe1bI\xf3c&quot;</span><br></pre></td></tr></table></figure><h3 id="EXISTS-命令"><a href="#EXISTS-命令" class="headerlink" title="EXISTS 命令"></a>EXISTS 命令</h3><p>EXISTS 命令用来检测一个给定的 key 是否存在，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXISTS k1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS k2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>上面的运行结果表示k1存在而k2不存在。</p><h3 id="TTL命令"><a href="#TTL命令" class="headerlink" title="TTL命令"></a>TTL命令</h3><p>TTL 命令可以查看一个给定 key 的有效时间：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; TTL k1</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; TTL k2</span><br><span class="line">(integer) -2</span><br></pre></td></tr></table></figure><p>-2 表示 key 不存在或者已过期；-1 表示 key 存在并且没有设置过期时间（永久有效）。当然，我们可以通过下面的命令给 key 设置一个过期时间：</p><h3 id="EXPIRE命令"><a href="#EXPIRE命令" class="headerlink" title="EXPIRE命令"></a>EXPIRE命令</h3><p>EXPIRE 命令可以给 key 设置有效期，在有效期过后，key 会被销毁。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXPIRE k1 30</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; TTL k1</span><br><span class="line">(integer) 25</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>30 表示 30 秒，TTL k1 返回 25 表示这个 key 的有效期还剩 25 秒。</p><h3 id="PERSIST-命令"><a href="#PERSIST-命令" class="headerlink" title="PERSIST 命令"></a>PERSIST 命令</h3><p>PERSIST 命令表示移除一个 key 的过期时间，这样该 key 就永远不会过期：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXPIRE k1 60</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) 57</span><br><span class="line">127.0.0.1:6379&gt; PERSIST k1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl k1</span><br><span class="line">(integer) -1</span><br></pre></td></tr></table></figure><h3 id="PEXPIRE-命令"><a href="#PEXPIRE-命令" class="headerlink" title="PEXPIRE 命令"></a>PEXPIRE 命令</h3><p>PEXPIRE 命令的功能和 EXPIRE 命令的功能基本一致，只不过这里设置的参数是毫秒：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PEXPIRE k1 60000</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="PTTL-命令"><a href="#PTTL-命令" class="headerlink" title="PTTL 命令"></a>PTTL 命令</h3><p>PTTL 命令和 TTL 命令基本一致，只不过 PTTL 返回的是毫秒数：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PTTL k1</span><br><span class="line">(integer) 25421</span><br></pre></td></tr></table></figure><h3 id="KEYS-命令"><a href="#KEYS-命令" class="headerlink" title="KEYS 命令"></a>KEYS 命令</h3><p>KEYS 命令可以获取满足给定模式的所有 key，比如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; KEYS *</span><br><span class="line">1) &quot;k3&quot;</span><br><span class="line">2) &quot;k2&quot;</span><br><span class="line">3) &quot;k1&quot;</span><br></pre></td></tr></table></figure><p>KEYS <code>*</code> 表示获取所有的 KEY， <code>*</code> 也可以是一个正则表达式。</p><p>OK,key 相关的命令我们就介绍这么多，当然还有很多其他的，小伙伴们可以参考官方文档<a href="http://www.redis.cn/commands.html。小伙伴在看官方文档时，有什么问题欢迎留言讨论。" target="_blank" rel="noopener">http://www.redis.cn/commands.html。小伙伴在看官方文档时，有什么问题欢迎留言讨论。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们介绍了如何在Linux中安装Redis，本文我们来了解下Redis中的五种数据类型。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
  </entry>
  
</feed>
