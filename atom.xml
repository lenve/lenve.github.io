<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-01-10T02:09:14.203Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>天呐，世界上还有免费的域名，赶紧抢注一个压压惊</title>
    <link href="http://www.javaboy.org/2020/0110/free-domain.html"/>
    <id>http://www.javaboy.org/2020/0110/free-domain.html</id>
    <published>2020-01-10T01:26:39.000Z</published>
    <updated>2020-01-10T02:09:14.203Z</updated>
    
    <content type="html"><![CDATA[<p>你可能想不到，这世界上还有免费的顶级域名！虽然这不是什么大新闻，可是很多小伙伴可能还不知道。</p><a id="more"></a><p>前两天刚和大家聊了不花一分钱搭建个人博客的事情（<a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a>）,在这篇文章中，你要真的一分钱都不想花，那就要接受 GitHub 提供的默认域名，GitHub 默认提供的域名是二级域名，这个默认的二级域名可能不太好记。</p><p>另一方面，有的时候大家做一些简单开发，想把自己的应用扔到服务器上去跑，这个时候，给服务器配置一个域名操作起来也会方便很多。so。。。</p><p>今天松哥再和大家透漏几个真正免费的顶级域名。虽然免费，但是注册过程还是挺麻烦的，不过好在不要钱，麻烦就麻烦吧。</p><p>为什么说注册过程麻烦呢？因为免费域名你要去网站上申请，要申请就要先网站上注册一个账户，就跟你去国内云服务厂商去买域名一样，购买之前你得先注册个账户。</p><p>这些免费域名麻烦就麻烦在注册账户非常麻烦，要注意的地方非常多，不过一个核心的指导思想就是你全程伪装成你在美帝（所以要全程开网络代理，并且代理服务器还要在美帝），否则的话，你会发现找不到注册链接，找不到购买按钮等等。</p><p>松哥亲测，虽然麻烦，但是只要你按照网上的步骤来，是可以申请成功的。</p><p>好了，废话不多说，下面我来介绍我们今天的四大主角：.ml 域名、.cf 域名、.ga 域名以及 .tk 域名。</p><h3 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h3><p>以 .ML 顶级域名为例，我们可以在 freenom 网站上进行申请。申请地址如下：</p><ul><li><a href="http://www.freenom.com/en/index.html" target="_blank" rel="noopener">http://www.freenom.com/en/index.html</a></li></ul><p>打开这个网站，我们首先会看到如下页面：</p><p><img src="http://www.javaboy.org/images/other/110-1.png" alt></p><p>然后在输入框中输入你要查询的域名，例如我这里是 javaboy：</p><p><img src="http://www.javaboy.org/images/other/110-2.png" alt></p><p>然后进入到购物车，选择右边的 12 个月免费期：</p><p><img src="http://www.javaboy.org/images/other/110-3.png" alt></p><p>选择完成后，点击 Continue 按钮进入到下一步：</p><p><img src="http://www.javaboy.org/images/other/110-4.png" alt></p><p>这里非常关键，地址信息要和你的代理服务器信息一致（如果你不知道代理服务器的具体地址，可以用 Google 随便搜索一个东西，拉到最下面，就有 IP 地址所属的位置），所有信息都用英文填写，涉及到地址，要真实可查，并且要有关联，例如你的 Address 和 Zip Code、City、Country 以及 State/Region 之间有必然关系，邮箱地址建议使用国外邮箱，手机号码可以随意填写。</p><p>购买完成后，在首页找到 My Domains ，就可以去配置 DNS 了。</p><p>另外三个申请步骤基本都差不多，要注意的事项也都差不多，只不过注册地址不一样罢了：</p><ul><li>.CF 申请地址：<a href="http://www.dot.cf" target="_blank" rel="noopener">http://www.dot.cf</a></li><li>.GA 申请地址：<a href="http://www.dot.ga" target="_blank" rel="noopener">http://www.dot.ga</a></li><li>.TK 申请地址：<a href="http://www.dot.tk" target="_blank" rel="noopener">http://www.dot.tk</a></li></ul><h3 id="域名介绍"><a href="#域名介绍" class="headerlink" title="域名介绍"></a>域名介绍</h3><p>接下来我也简单介绍一下这几个域名，为什么他们是免费的？</p><p>.ML 域名来自马里，中文有“美丽”之意，任何人都可以注册，没有任何限制，也不收取任何费用。<br>.CF 域名来自中非共和国，目前由(SOCATEL) 管理，由荷兰的 Freedom Registry 公司负责运作。<br>.GA 域名来自非洲国家加蓬。<br>.TK 域名算是一个老牌的域名了，据说目前活跃的域名超过 1600 万个，这里估计国人也贡献了不少。</p><p>这些比较奇特的顶级域名 Google 肯定会收录，百度暂不清楚。</p><p>最后，虽然这些域名不要钱，不过如果大家想正儿八经的搞一个自己的博客网站，松哥还是建议花几十块买一个 .com 域名，也不贵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你可能想不到，这世界上还有免费的顶级域名！虽然这不是什么大新闻，可是很多小伙伴可能还不知道。&lt;/p&gt;
    
    </summary>
    
      <category term="domain" scheme="http://www.javaboy.org/categories/domain/"/>
    
    
      <category term="domain" scheme="http://www.javaboy.org/tags/domain/"/>
    
  </entry>
  
  <entry>
    <title>MacBook Pro 入手一年了，到底香不香？</title>
    <link href="http://www.javaboy.org/2020/0108/mackbookpro.html"/>
    <id>http://www.javaboy.org/2020/0108/mackbookpro.html</id>
    <published>2020-01-08T01:26:24.000Z</published>
    <updated>2020-01-10T02:08:23.400Z</updated>
    
    <content type="html"><![CDATA[<p>最近又有小伙伴问到底值不值得入手一台 MacBook Pro，松哥自己在 2018 年 10 月份的时候入手了一台，到现在为止，也用了一年多了，今天就来和小伙伴们聊一聊使用感受，至于到底值不值，需要大家自行判断。</p><a id="more"></a><p>我的第一台笔记本是大一第二学期（2012 年 4 月份）入手的，是一台 Sony 的 VAIO，这台电脑现在也一直在用，给大家录制的视频教程都是用这台电脑录制了，在接近 8 年的时间里，这台笔记本一直是我的主力机，更重要的是从来没有拿去修过，质量很棒，因此当我想要换电脑的时候，首先考虑的还是 VAIO，可惜 Sony 在 2014 年将 PC 业务整体出售，VAIO 这个品牌也卖给了 JIP（Japan Industrial Partners Inc.），从此退出了笔记本电脑市场。</p><p>排除了 VAIO 之后，剩下的选项就是 MacBook Pro 了。其实很早就想入手一台 mbp 了，2016 年那会，刚毕业一年，薪水翻了三倍，我想入手一台 mbp 奖励自己，但后来还是控制住自己了，买了一个固态硬盘给我的 Windows 装上了，然后就把买 mbp 这个欲望压下来了。去年 10 月份的时候，我的第一本书刚刚交稿给出版社，还是蛮激动的，心想这下可以买一个 mbp 了吧，这次没能成功控制住自己，于是就买了，要买就买好的，于是我在 Apple 官网定制了一台 32G 内存的 mbp，当时还送了一个 beat solo 耳机。</p><p>耳机一直是女票在用，我就不多说了，我这次主要和大家说说作为一个程序员，我比较关注的开发工具的使用感受。</p><h2 id="idea-秒开"><a href="#idea-秒开" class="headerlink" title="idea 秒开"></a>idea 秒开</h2><p>第一次知道原来 IntelliJ IDEA 可以秒开。最早用 Windows 的时候，那会还不是固态硬盘，每天到公司后，先按下开机键，然后去打杯水，回来电脑刚好开机，然后点下 idea 图标，再去上个厕所，回来后 idea 也开好了，后来换了个固态硬盘，Windows 开机基本上可以控制在 10s 之内，所以每条到公司的流程也调整了下，先开机，然后等一会开机完成后，开 idea，然后再去打水，回来的时候 idea 就刚好开好。</p><p>用了 mbp 之后，idea 和 webstorm 这两个平时开发用的最多的软件，基本都可以秒开，相应的，idea 在项目编译运行的时候，也要快很多。这样开发效率提升可不是一丁半点。</p><h2 id="不用关机"><a href="#不用关机" class="headerlink" title="不用关机"></a>不用关机</h2><p>mbp 还有一个非常有用的地方就是不用关机，想想你做开发，idea、webstorm、vscode、sequel pro、postman、命令行等等开了一堆，现在下班了，全部关掉回家，明天来了再挨个打开，不是很费事么？mac 用完了，直接合上盖就可以了，下次再打开盖子，这些东西都还可以接着使用。不用再一个一个打开。</p><p>我刚开始用的时候，对这个功能很不习惯，每次用完还是习惯性的关机，后来时间久了，慢慢就接受了，现在我的 mbp 估计都快一年没关过机了，依然用着很流畅。</p><h2 id="命令行好用"><a href="#命令行好用" class="headerlink" title="命令行好用"></a>命令行好用</h2><p>mbp 里边的命令行也是非常方便，远程连接 Linux 服务器时，甚至不需要额外准备第三方工具，直接在命令行用命令连接。</p><p>但是在命令行连接远程服务器，如果 ssh 连接空闲一段时间后，就会自动断开，下次又得重新连接，我在网上看了一些方案之后，后来还是决定用一些工具得了，综合比较后，使用了 Royal TSX，既可以做远程连接，又可以方便的上传文件。</p><h2 id="Adobe-Pr-真快"><a href="#Adobe-Pr-真快" class="headerlink" title="Adobe Pr 真快"></a>Adobe Pr 真快</h2><p>因为我今年一直在录视频教程，视频要二次处理剪辑啥的，二次处理我使用了 Adobe Premiere Pro ，刚开始我是在 Windows 上处理的，但是太慢了，一个 10 分钟左右的视频，渲染起来的时间接近 20 分钟，漫长的等待实在有点受不了，后来就把视频的二次处理换到 mbp 上来处理，10 分钟的视频，大概一两分钟就可以渲染好，速度非常快。</p><p>不过在 mbp 上处理视频，也有一个问题，就是视频长的时候（10 分钟以上），可以明显的听到电脑风扇呼呼响，渲染完成后，电脑又会慢慢冷静下来，这是一个非常明显的变化。这个让我有点吃惊，因为我印象中，mbp 应该比较擅长做视频处理，但是这块实际操作起来，感觉它还是有点压力。</p><p>至于为什么不在 mbp 上使用 FINAL CUT，这是因为有的时候我还需要搭配着 Windows 使用，为了能够在 Windows 和 mbp 之间平滑切换，选择了 Adobe Pr。</p><h2 id="Docker-必备"><a href="#Docker-必备" class="headerlink" title="Docker 必备"></a>Docker 必备</h2><p>个人觉得，使用 mbp，一定安装一个 Docker，Docker 在 mbp 上安装非常方便，比 windows 省事很多，Docker 装好之后，以后的 MySQL、RabbitMQ、Redis、Nginx 等工具，都可以直接使用 Docker 来安装，方便了很多。我一直就是这样搞的。</p><p>不过 Docker 使用过程中，遇到过一次超级耗内存的情况，就是有一次突然电脑风扇呼呼响，检查之后发现是 Docker 的问题，关掉的 Docker 之后就好了，不过后来使用 Docker 没再遇到这个情况。</p><h2 id="Sequel-Pro"><a href="#Sequel-Pro" class="headerlink" title="Sequel Pro"></a>Sequel Pro</h2><p>数据库连接工具我使用了 Sequel Pro，在 Windows 上，我一直是 Navicat 和 SQLyog 两个切换着使用，mbp 上也有 Navicat ，但是搞起来比较麻烦，我就懒得去弄了，于是入乡随俗，选择了 Sequel Pro。</p><p>Sequel Pro 其实用着也没啥不方便的地方，感觉我自己的平时的需求都够用了。</p><h2 id="mbp-Vs-Ubuntu"><a href="#mbp-Vs-Ubuntu" class="headerlink" title="mbp Vs Ubuntu"></a>mbp Vs Ubuntu</h2><p>在公司做开发的时候，用 Ubuntu 做主力系统也用了很长一段时间，这也是我后来切换到 mbp 上之后，没有太多的陌生感的原因之一。个人感觉 mbp 和 Ubuntu 有很多相似的地方，相比于 Ubuntu ，mbp 最大的优势在于软件生态丰富，像 Adobe 全家桶，微信这些东西，在 mbp 上安装就不用折腾。</p><p>小伙伴们要是未来有入手 mbp 的打算，我建议现在可以在 Windows 笔记本上整一个双系统，装上 Ubuntu，这样有一天当你想切换到 mbp 上时，就可以平滑过渡。</p><h2 id="还要-Windows-系统吗"><a href="#还要-Windows-系统吗" class="headerlink" title="还要 Windows 系统吗"></a>还要 Windows 系统吗</h2><p>老实说，Windows 还是离不开。至少我这边有不少事情还是需要在 Windows 上做，例如平时给大家录制视频教程，mbp 当然也可以录，但是录出来的视频文件超级大，不利于分发和传播，所以我一直选择在 Windows 上录制。不过我不太喜欢在 mbp 上搞 Windows ，所以现在是两台笔记本，mbp 是主力，之前那台用了八年的 Windows 打辅助，两台设备切换着用。</p><p>其实在电脑上我不太喜欢折腾，一般能满足需求，我就会一直先用着。换了 mbp 之后，使用最多的软件还是那几个开发工具，其他 mbp 上的功能发掘的少，不过也在慢慢摸索。</p><p>整体来说，还是比较香的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又有小伙伴问到底值不值得入手一台 MacBook Pro，松哥自己在 2018 年 10 月份的时候入手了一台，到现在为止，也用了一年多了，今天就来和小伙伴们聊一聊使用感受，至于到底值不值，需要大家自行判断。&lt;/p&gt;
    
    </summary>
    
      <category term="MacBookPro" scheme="http://www.javaboy.org/categories/MacBookPro/"/>
    
    
      <category term="MacBookPro" scheme="http://www.javaboy.org/tags/MacBookPro/"/>
    
  </entry>
  
  <entry>
    <title>不用花一分线，松哥手把手教你上线个人博客</title>
    <link href="http://www.javaboy.org/2020/0106/hexo-blog.html"/>
    <id>http://www.javaboy.org/2020/0106/hexo-blog.html</id>
    <published>2020-01-06T01:26:07.000Z</published>
    <updated>2020-01-10T02:07:30.905Z</updated>
    
    <content type="html"><![CDATA[<p>有不少小伙伴私信松哥，打听松哥的博客是怎么做的，其实这个我之前和大家聊过，今天就再来说一说。</p><a id="more"></a><p>我记得是 2015 年 4 月 15 在CSDN上发表了我的第一篇博客，是一个学习笔记，从那之后开启了我博客写作之路，到今天为止 4 年多了。</p><p>这 4 年时间我在 CSDN 上发表的博客最多，共有 550 篇原创，CSDN 是我的大本营，不过在这期间也有断断续续在其他公共平台上发过博客，例如 sf、博客园、掘金、慕课网等，但是都是非常零散，2016 年的时候，利用我的 GitHub 也搭建了一个个人站点，但是只是试验了几个页面，并没有好好去维护。</p><p>今年搞了一个自己的独立博客 <code>http://www.javaboy.org</code> ，从四月份到现在，博客 PV 和 UV 都以肉眼可见的速度增长，我也是蛮开心的。因为大家个人独立博客最怕的就是流量，这也是我把这个事情拖了 4 年才做的原因之一，但是真正动手做之后，我发现搭建个人独立博客比想象的要容易很多，至于流量，只要内容 OK，流量也都不是事。</p><p>今天我就来和大家聊一聊如何搭建一个个人博客。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>目前静态博客站点非常流行，所以我其实不太建议大家再去搞动态博客系统，那样要操心的事情太多了。使用搭建静态博客，可以让我们把大部分精力集中在博客写作上，而不是无休止的耗费在博客搭建上（很多小伙伴搭建博客的时候兴致勃勃，搭建完成后就意兴阑珊，然后就没有然后了，空留一个博客网站摆在那里）。</p><p>静态博客选型，松哥目前接触到的主要是两种方案：</p><ol><li>GitHub 上 结合 Jekyll 搭建的博客，Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和我们的 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。</li><li>本地渲染好 HTML 后，上传到服务端，代表作品就是 hexo。</li></ol><p>简单说，第一种方式，就是我们在本地写好 markdown 之后，直接上传到服务端，服务端会自动渲染成 HTML，然后展示给用户，第二种方案则是我们在本地写好 markdown 之后，在本地将 markdown 渲染成 HTML，然后将渲染好的 HTML 上传到服务端。（markdown 小伙伴们应该都了解吧，我就不做过多介绍了）</p><p>这两种方案松哥都有用，大家见到的 <code>http://www.javaboy.org</code>，是我使用 hexo+icarus 实现的。大家见到的 <code>http://springboot.javaboy.org</code>、<code>http://spring.javaboy.org</code>、<code>http://springmvc.javaboy.org</code>、<code>http://mybatis.javaboy.org</code>、<code>http://maven.javaboy.org</code> 等，则是我使用 Jekyll 来做的，两种方案各有优缺点，这个松哥后面再和大家详述。</p><p>今天主要和大家聊一聊 <code>http://www.javaboy.org</code> 站点的搭建，也就是我采用了 hexo+icarus 来实现的。</p><p>这个博客的所有资金投入就是几十块钱买了一个域名，再就没花钱了。站点托管在 GitHub 上，评论系统也用了 GitHub 来做，如果你能接受 GitHub 提供的默认域名，那你甚至连域名都不用买了，接下来我们就来看看这个东西怎么实现。</p><blockquote><p>如果大家玩过松哥的微人事(<a href="https://github.com/lenve/vhr)或者" target="_blank" rel="noopener">https://github.com/lenve/vhr)或者</a> V 部落(<a href="https://github.com/lenve/VBlog)，那么对于" target="_blank" rel="noopener">https://github.com/lenve/VBlog)，那么对于</a> hexo 上手可能非常容易，因为这个里边也使用了 nodejs，和微人事的前段操作有很多相同的地方。</p></blockquote><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><p>用 Hexo 搭建，要是有一点点前端 Node 的使用经验更佳，没有当然也没关系，因为与之相关的命令并不多。使用 Hexo 需要提前在电脑上安装好 Node 和 Git ，安装成功后，就可以开始 Hexo 的安装了。步骤如下：</p><ol><li>安装 Hexo</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ol start="2"><li>在本地创建一个博客目录</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>上面这个命令执行完后，会在本地创建一个 blog 目录，这里边就是独立博客所必须的一些文件，然后进入到这个目录中，执行 <code>npm install</code> 命令，安装相关的依赖。</p><p>安装完成后，会生成如下目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>这里几个文件/文件夹，我们先来关注其中两个 _config.yml 和 themes 目录， _config.yml 文件中，我们可以做网站的一些基本配置，例如 网站的 title，描述，关键字、图标等，这些配置大都见名知意。如下：</p><p><img src="http://www.javaboy.org/images/other/106-1.png" alt></p><p>配置完成后，定位到 blog 目录，执行 <code>hexo s</code> 就可以在本地启动项目了，启动成功后，浏览器中输入 <code>http://localhost:4000</code> 就可以看到网站了。</p><p>说到 <code>hexo s</code> 命令，这里有几个常用命令需要给大家介绍下，分别是：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">简写</th><th style="text-align:left">中文含义</th></tr></thead><tbody><tr><td style="text-align:left">hexo server</td><td style="text-align:left">hexo s</td><td style="text-align:left">本地启动</td></tr><tr><td style="text-align:left">hexo generate</td><td style="text-align:left">hexo g</td><td style="text-align:left">生成静态文件</td></tr><tr><td style="text-align:left">hexo deploy</td><td style="text-align:left">hexo d</td><td style="text-align:left">部署网站</td></tr><tr><td style="text-align:left">hexo clean</td><td style="text-align:left"></td><td style="text-align:left">清除缓存和已经生成的静态文件</td></tr></tbody></table><p>这四个算是松哥这两天使用最多的命令，其他的命令，大伙可以参考<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a>。</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>一般来说，主题都会自己配置一个，个人感觉 Hexo 的生态还是比较丰富的，有很多可选的主题，Hexo 默认使用的主题是 landscape ，松哥最早使用了 hexo-theme-next 主题。博客在本地跑起来之后，接下来就是修改主题，主题修改的第一步就是先选一个自己认为好看的主题，选好之后，首先将之克隆到 <code>./themes</code> 目录下，这个目录下原本有有一个 landscape 文件夹，里边放的默认的样式，当然开发者也可以直接将主题文件下载好拷贝进来，但是我还是建议使用 clone ，使用 clone ，假如有一天这个主题更新了，只需要 pull 一下就可以获取到最新样式了。</p><p>以 hexo-theme-next 主题为例， clone 命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>克隆成功后，修改 hexo 的 _config.yml 文件，将主题修改为 next，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>主题创建好之后，接下来就是对主题的配置了，这个比较容易，直接参考<a href="https://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方文档</a>即可。配置完成后，执行如下命令，即可看到新的主题效果：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>命令含义可以参考上面的表格，这里不再赘述。</p><p>这个 next 主题我大概用了两三个月，现在换成了 icarus，大家在主题配置的时候，只要会配置一个，其他多个肯定也就没有问题了。</p><h2 id="绑定到-GitHub"><a href="#绑定到-GitHub" class="headerlink" title="绑定到 GitHub"></a>绑定到 GitHub</h2><p>大家可能已经迫不及待想要把博客上传到 GitHub 了，绑定到 Github 步骤也很简单，首先以 <code>自己的GitHub ID.github.io</code> 为名创建一个 public 仓库，例如我的 ID 为 lenve，创建的仓库如下：</p><p><img src="http://www.javaboy.org/images/other/23-2.png" alt></p><p>创建成功之后，修改 hexo 的 <code>_config.yml</code> 文件，配置 GitHub 地址，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lenve/lenve.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这里根据自己的地址来配置即可，配置完成后，执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>执行完成后，就可以将数据上传到 GitHub 了（当然这里需要大家提前配置一下 GitHub 的公钥，具体可以参考<a href="https://mp.weixin.qq.com/s/x5bRe4QBMoVFKv5jNl9iRw" target="_blank" rel="noopener">Git关联远程仓库</a>）。</p><p>上传成功后，访问 <code>https://lenve.github.io</code> 就可以看到自己的个人站点了，这是 GitHub 默认给我们提供的域名。</p><p>如果你对 GitHub 提供的域名不满意，也可以自己申请一个域名，分分钟就配置好了。</p><h2 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h2><p>域名申请建议使用国外的域名提供商，不用备案（一个字，快！不用等），松哥使用了 godaddy ，主要是因为这个服务商支持支付宝付款，域名申请就比较容易了，无需多说，不过类似的域名提供商其实很多，大家不一定用这个，也可以自己再看看。</p><h2 id="域名和-GitHub-绑定"><a href="#域名和-GitHub-绑定" class="headerlink" title="域名和 GitHub 绑定"></a>域名和 GitHub 绑定</h2><p>域名申请成功之后，接下来的配置，也分为两部分。</p><h3 id="GitHub-配置"><a href="#GitHub-配置" class="headerlink" title="GitHub 配置"></a>GitHub 配置</h3><p>首先在博客所在目录下的 source 目录中（<strong>注意不要放错位置了</strong>），创建一个 CNAME 文件，文件内容就是你的域名，如下：</p><p><img src="http://www.javaboy.org/images/other/23-3.png" alt></p><p>然后执行 <code>hexo d</code> 命令将这个文件上传到 GitHub 就可以了。</p><p>在网上看到有人直接在 GitHub 上配置这个，如下图：</p><p><img src="http://www.javaboy.org/images/other/23-4.png" alt></p><p>这种方式也可以，这种方式会自动生成一个 CNAME 文件到当前仓库中，但是松哥在这里不推荐大家使用这种方式，因为如果你在本地执行了 <code>hexo clean</code> ，然后再去上传，就会丢失掉 CNAME 文件，然后又得重新配置。<strong>关键是当你执行了 <code>hexo clean</code> 之后，你可能还发现不了 CNAME 文件已经丢失了。</strong></p><h3 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h3><p>域名解析这块，当时遇到了一些问题，后来松哥使用了国内的 DNSPod 去做域名解析了，没有使用 godaddy 提供的域名解析。使用 DNSPod 首先要做的，就是修改 godaddy 提供的域名解析服务，登录自己的 godaddy 账号，找到域名管理，修改域名解析服务为 DNSPod ，如下：</p><p><img src="http://www.javaboy.org/images/other/23-5.png" alt></p><p>然后登录到 DNSPod（没有账号注册一个），然后添加自己的域名解析，如下图：</p><p><img src="http://www.javaboy.org/images/other/23-6.png" alt></p><p>添加两条 A 记录，指向 GitHub 的 IP 地址，再添加一条 CNAME ，指向你的 GitHub 域名就可以了。 </p><p>如此之后，大功告成！</p><p><img src="http://www.javaboy.org/images/other/23-7.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，不知道小伙伴们有没有 GET 到呢？这个不用花很多钱，就是一个域名的费用而已（如果你不想用 GitHub 提供的域名的话），也不需要额外买服务器，hexo 的使用也很简单，有兴趣小伙伴赶快实践下吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有不少小伙伴私信松哥，打听松哥的博客是怎么做的，其实这个我之前和大家聊过，今天就再来说一说。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://www.javaboy.org/categories/blog/"/>
    
    
      <category term="blog" scheme="http://www.javaboy.org/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十八)15 道 Spring Boot 高频面试题</title>
    <link href="http://www.javaboy.org/2020/0106/springboot-interview.html"/>
    <id>http://www.javaboy.org/2020/0106/springboot-interview.html</id>
    <published>2020-01-06T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.436Z</updated>
    
    <content type="html"><![CDATA[<p>什么是面霸？就是在面试中，神挡杀神佛挡杀佛，见招拆招，面到面试官自惭形秽自叹不如！松哥希望本文能成为你面霸路上的垫脚石！</p><a id="more"></a><p>做 Java 开发，没有人敢小觑 Spring Boot 的重要性，现在出去面试，无论多小的公司 or 项目，都要跟你扯一扯 Spring Boot，扯一扯微服务，不会？没用过？ Sorry ，我们不合适！</p><p>今天松哥就给大家整理了 15 道高频 Spring Boot 面试题，希望能够帮助到刚刚走出校门的小伙伴以及准备寻找新的工作机会的小伙伴。</p><ul><li>1.什么是 Spring Boot ?</li></ul><p>传统的 SSM/SSH 框架组合配置繁琐臃肿，不同项目有很多重复、模板化的配置，严重降低了 Java 工程师的开发效率，而 Spring Boot 可以轻松创建基于 Spring 的、可以独立运行的、生产级的应用程序。通过对 Spring 家族和一些第三方库提供一系列自动化配置的 Starter，来使得开发快速搭建一个基于 Spring 的应用程序。</p><p>Spring Boot 让日益臃肿的 Java 代码又重回简洁。在配合 Spring Cloud 使用时，还可以发挥更大的威力。</p><ul><li>2.Spring Boot 有哪些特点 ?</li></ul><p>Spring Boot 主要有如下特点：</p><ol><li>为 Spring 开发提供一个更快、更广泛的入门体验。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>绝对没有代码生成，也不需要XML配置。</li></ol><ul><li>3.Spring Boot 中的 starter 到底是什么 ?</li></ul><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。</p><p>当然，开发者也可以自定义 Starter，自定义 Starter 可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486499&amp;idx=2&amp;sn=ce229938f5284e3a43e04e9f84121bd1&amp;chksm=e9c35e43deb4d75571c430f42758930f2e963df4bd692dcbc52beac0c6907f9d172ad533904a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">自定义 Spring Boot 中的 starter</a>。</p><ul><li>4.spring-boot-starter-parent 有什么用 ?</li></ul><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li>定义了 Java 编译版本为 1.8 。</li><li>使用 UTF-8 格式编码。</li><li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</li><li>执行打包操作的配置。</li><li>自动化的资源过滤。</li><li>自动化的插件配置。</li><li>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</li></ol><p>关于这个问题，读者可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486397&amp;idx=2&amp;sn=44f4206b0431e3200fee9a058d6087f8&amp;chksm=e9c359dddeb4d0cbb9fcd7b9c5108a71900dcee28db16c91468797c92ef9678ae7d91da212f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解 spring-boot-starter-parent</a></p><ul><li>5.YAML 配置的优势在哪里 ?</li></ul><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>简洁</li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><p>关于 YAML 配置，要是大家还不熟悉，可以参考: <a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486440&amp;idx=2&amp;sn=51d96a2a11013c38b0756f634005521a&amp;chksm=e9c35988deb4d09eebd49c04088bdf7038035a454c88aaef3c62c23ccc6cef29ffe68f3d93fa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot中的 yaml 配置</a></p><ul><li>6.Spring Boot 中如何解决跨域问题 ?</li></ul><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在则是通过 @CrossOrigin 注解来解决跨域问题。关于 CORS ，小伙伴们可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486714&amp;idx=2&amp;sn=cc5164e4ee779241998c4d4173449bbc&amp;chksm=e9c35e9adeb4d78c89f70a483c4e30ac20bdfcda8715e71bd5b31706e1549eb766550bb620db&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CORS 解决跨域问题</a></p><ul><li>7.比较一下 Spring Security 和 Shiro 各自的优缺点 ?</li></ul><p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p><ol><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li>Spring Security 功能强大；Shiro 功能简单</li></ol><ul><li>8.微服务中如何实现 session 共享 ?</li></ul><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。 session 共享大家可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487019&amp;idx=2&amp;sn=2bdb576650d4e493606312544c29d641&amp;chksm=e9c35c4bdeb4d55d29272bf904098345b913f517c07c35cef05c172ae0c440cda1c190b14479&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Session 共享</a></p><ul><li>9.Spring Boot 如何实现热部署 ?</li></ul><p>Spring Boot 实现热部署其实很容易，引入 devtools 依赖即可，这样当编译文件发生变化时，Spring Boot 就会自动重启。在 Eclipse 中，用户按下保存按键，就会自动编译进而重启 Spring Boot，IDEA 中由于是自动保存的，自动保存时并未编译，所以需要开发者按下 Ctrl+F9 进行编译，编译完成后，项目就自动重启了。</p><p>如果仅仅只是页面模板发生变化，Java 类并未发生变化，此时可以不用重启 Spring Boot，使用 LiveReload 插件就可以轻松实现热部署。</p><ul><li>10.Spring Boot 中如何实现定时任务 ?</li></ul><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p><p>关于定时任务这一块，大家可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486770&amp;idx=2&amp;sn=03c4d34b5497b5328444237adf049038&amp;chksm=e9c35f52deb4d6442e007665ca8d48518582c8e22cb229f1fe5b0a467aa9bcf0650f54883aac&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">定时任务的两种实现方式</a></p><ul><li>11.前后端分离，如何维护接口文档 ?</li></ul><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到最新的接口文档，非常方便。关于 Swagger 的用法，大家可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486800&amp;idx=2&amp;sn=39965b130bdfc39e66a2d40a84d7ba57&amp;chksm=e9c35f30deb4d62602fd19cb12b8b755cf4be37de3e0510e2a3c7104b01446681355822947bd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringBoot 整合 Swagger2</a></p><ul><li>12.什么是 Spring Data ?</li></ul><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><ol><li>SpringData 项目支持 NoSQL 存储：</li><li>MongoDB （文档数据库）</li><li>Neo4j（图形数据库）</li><li>Redis（键/值存储）</li><li>Hbase（列族数据库）</li></ol><p>SpringData 项目所支持的关系数据存储技术：</p><ol><li>JDBC</li><li>JPA</li></ol><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><ul><li>13.Spring Boot 是否可以使用 XML 配置 ?</li></ul><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><ul><li>14.Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</li></ul><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。具体可以参考：<a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487374&amp;idx=2&amp;sn=e6d50ebecc5ffa67fa0999706729c53c&amp;chksm=e9c35deedeb4d4f8e7b1f9c18122b0c12173323aa5fcd505359fbd66b5bfcf74f3cd601b9f56&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 可执行 jar 分析</a></p><ul><li>15.bootstrap.properties 和 application.properties 有何区别 ?</li></ul><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>bootstrap.properties 在 application.properties 之前加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。bootstrap.properties 被 Spring ApplicationContext 的父类加载，这个类先于加载 application.properties 的 ApplicatonContext 启动。</p><p>当然，前面叙述中的 properties 也可以修改为 yaml 。</p><p>好了，本文就说到这里，欢迎小伙伴留言说说你曾经遇到过的 Spring Boot 面试题！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是面霸？就是在面试中，神挡杀神佛挡杀佛，见招拆招，面到面试官自惭形秽自叹不如！松哥希望本文能成为你面霸路上的垫脚石！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>听说你的 IDEA 昨天掉链子了？松哥给你准备了大招</title>
    <link href="http://www.javaboy.org/2020/0105/idea.html"/>
    <id>http://www.javaboy.org/2020/0105/idea.html</id>
    <published>2020-01-05T01:25:51.000Z</published>
    <updated>2020-01-10T02:05:45.614Z</updated>
    
    <content type="html"><![CDATA[<p>昨天一直在忙，中午抽空瞅了一眼技术群，天呐，竟然都在切磋 IDEA 激活码的事情，瞬间明白可能 jetbrains 又在搞事情了。</p><a id="more"></a><p>我大概了解了下，这次出事的主要是 2019 版，之前的 2018 版没有受影响。</p><p>我也是 2018 版用了好久才切换到 2019 版上面来的，刚用 2019 版的时候还没啥感觉，用久了发现 2019 版确实挺好用的，里边有很多新增的特性，这些我以后可以和大家细细的去聊，这里就不再多说。</p><p>由于国内目前的版权环境，使用正版 IDEA 的小伙伴可能并不多，正版一套其实还是蛮贵的，特别是对于一些学生党来说简直就是天价了，不过 jetbrains 公司还算是比较人性化的，提供了多种免费获取正版授权的方案。</p><p>第一种就是开源项目。如果你有一个不错的开源项目，而且一直在维护，那么你可以向 jetbrains 公司申请全家桶软件的激活码，这就是正儿八经的正版软件了。这条路看着容易，其实对大部分小伙伴来说还是有挺高的门槛的。</p><p>另一个适合在校大学生的方案就是使用一个 edu 邮箱，向 jetbrains 公司申请激活码。因为大部分学校可能都会给学生分配一个 edu 邮箱，用这个邮箱在 jetbrains 官网注册账号，然后就可以轻松获取到一个激活码。</p><p>个人感觉第二种方案其实漏洞比较大，因为获取一个 edu 邮箱太过 easy 了，即使学校不给，作为一个专业的程序员，还是有很多办法获取到一个 edu 邮箱的，我看到群里很多小伙伴都是采用了这种方案解决的。</p><p>不过如果已经工作了，自身条件也允许，其实也可以尝试一下正版 IDEA，毕竟作为一个程序员，应该是能够感受到一个好的 IDE 开发之不易的。</p><p><strong>当然，如果你既没有拿的出手的开源项目，也搞不到 edu 邮箱，不妨在松哥公众号后台回复 idea，看看松哥给你的惊喜。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天一直在忙，中午抽空瞅了一眼技术群，天呐，竟然都在切磋 IDEA 激活码的事情，瞬间明白可能 jetbrains 又在搞事情了。&lt;/p&gt;
    
    </summary>
    
      <category term="idea" scheme="http://www.javaboy.org/categories/idea/"/>
    
    
      <category term="idea" scheme="http://www.javaboy.org/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十七)Spring Boot 开发微信公众号后台(二)</title>
    <link href="http://www.javaboy.org/2020/0105/springboot-weixin.html"/>
    <id>http://www.javaboy.org/2020/0105/springboot-weixin.html</id>
    <published>2020-01-05T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.436Z</updated>
    
    <content type="html"><![CDATA[<p>hello 各位小伙伴，今天我们来继续学习如何通过 Spring Boot 开发微信公众号。还没阅读过上篇文章的小伙伴建议先看看上文，有助于理解本文：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw" target="_blank" rel="noopener">Spring Boot 开发微信公众号后台</a></li></ul><p>上篇文章中我们将微信服务器和我们自己的服务器对接起来了，并且在自己的服务器上也能收到微信服务器发来的消息，本文我们要看的就是如何给微信服务器回复消息。</p><h2 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h2><p>在讨论如何给微信服务器回复消息之前，我们需要先来了解下微信服务器发来的消息主要有哪些类型以及我们回复给微信的消息都有哪些类型。</p><p>在上文中大家了解到，微信发送来的 xml 消息中有一个 MsgType 字段，这个字段就是用来标记消息的类型。这个类型可以标记出这条消息是普通消息还是事件消息还是图文消息等。</p><p>普通消息主要是指：</p><ul><li>文本消息</li><li>图片消息</li><li>语音消息</li><li>视频消息</li><li>小视频消息</li><li>地址位置消息</li><li>链接消息</li></ul><p>不同的消息类型，对应不同的 MsgType，这里我还是以普通消息为例，如下：</p><table><thead><tr><th style="text-align:left">消息类型</th><th style="text-align:left">MsgType</th></tr></thead><tbody><tr><td style="text-align:left">文本消息</td><td style="text-align:left">text</td></tr><tr><td style="text-align:left">图片消息</td><td style="text-align:left">image</td></tr><tr><td style="text-align:left">语音消息</td><td style="text-align:left">voice</td></tr><tr><td style="text-align:left">视频消息</td><td style="text-align:left">video</td></tr><tr><td style="text-align:left">小视频消息</td><td style="text-align:left">shortvideo</td></tr><tr><td style="text-align:left">地址位置消息</td><td style="text-align:left">location</td></tr><tr><td style="text-align:left">链接消息</td><td style="text-align:left">link</td></tr></tbody></table><p>大家千万不要以为不同类型消息的格式是一样的，其实是不一样的，也就是说，MsgType 为 text 的消息和 MsgType 为 image 的消息，微信服务器发给我们的消息内容是不一样的，这样带来一个问题就是我无法使用一个 Bean 去接收不同类型的数据，因此这里我们一般使用 Map 接收即可。</p><p>这是消息的接收，除了消息的接收之外，还有一个消息的回复，我们回复的消息也有很多类型，可以回复普通消息，也可以回复图片消息，回复语音消息等，不同的回复消息我们可以进行相应的封装。因为不同的返回消息实例也是有一些共同的属性的，例如消息是谁发来的，发给谁，消息类型，消息 id 等，所以我们可以将这些共同的属性定义成一个父类，然后不同的消息再去继承这个父类。</p><h2 id="返回消息类型定义"><a href="#返回消息类型定义" class="headerlink" title="返回消息类型定义"></a>返回消息类型定义</h2><p>首先我们来定义一个公共的消息类型：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String ToUserName;</span><br><span class="line">    <span class="hljs-keyword">private</span> String FromUserName;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> CreateTime;</span><br><span class="line">    <span class="hljs-keyword">private</span> String MsgType;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> MsgId;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li>ToUserName 表示开发者的微信号</li><li>FromUserName 表示发送方账号（用户的 OpenID）</li><li>CreateTime 消息的创建时间</li><li>MsgType 表示消息的类型</li><li>MsgId 表示消息 id</li></ul><p>这是我们的基本消息类型，就是说，我们返回给用户的消息，无论是什么类型的消息，都有这几个基本属性。然后在此基础上，我们再去扩展出文本消息、图片消息 等。</p><p>我们来看下文本消息的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String Content;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文本消息在前面消息的基础上多了一个 Content 属性，因此文本消息继承自 BaseMessage ，再额外添加一个 Content 属性即可。</p><p>其他的消息类型也是类似的定义，我就不一一列举了，至于其他消息的格式，大家可以参考微信开放文档（<a href="http://1t.click/aPXK）。" target="_blank" rel="noopener">http://1t.click/aPXK）。</a></p><h2 id="返回消息生成"><a href="#返回消息生成" class="headerlink" title="返回消息生成"></a>返回消息生成</h2><p>消息类型的 Bean 定义完成之后，接下来就是将实体类生成 XML。</p><p>首先我们定义一个消息工具类，将常见的消息类型枚举出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：文本</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_TEXT = <span class="hljs-string">"text"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：音乐</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_MUSIC = <span class="hljs-string">"music"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：图文</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_NEWS = <span class="hljs-string">"news"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：图片</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Image = <span class="hljs-string">"image"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：语音</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Voice = <span class="hljs-string">"voice"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：视频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Video = <span class="hljs-string">"video"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：文本</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_TEXT = <span class="hljs-string">"text"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：图片</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_IMAGE = <span class="hljs-string">"image"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：链接</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_LINK = <span class="hljs-string">"link"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：地理位置</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_LOCATION = <span class="hljs-string">"location"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：音频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_VOICE = <span class="hljs-string">"voice"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：视频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_VIDEO = <span class="hljs-string">"video"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：推送</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_EVENT = <span class="hljs-string">"event"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：subscribe(订阅)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_SUBSCRIBE = <span class="hljs-string">"subscribe"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：unsubscribe(取消订阅)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_UNSUBSCRIBE = <span class="hljs-string">"unsubscribe"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：CLICK(自定义菜单点击事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_CLICK = <span class="hljs-string">"CLICK"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：VIEW(自定义菜单 URl 视图)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_VIEW = <span class="hljs-string">"VIEW"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：LOCATION(上报地理位置事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_LOCATION = <span class="hljs-string">"LOCATION"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：LOCATION(上报地理位置事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_SCAN = <span class="hljs-string">"SCAN"</span>;</span><br></pre></td></tr></table></figure><p>大家注意这里消息类型的定义，以 RESP 开头的表示返回的消息类型，以 REQ 表示微信服务器发来的消息类型。然后在这个工具类中再定义两个方法，用来将返回的对象转换成 XML：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">textMessageToXml</span><span class="hljs-params">(TextMessage textMessage)</span> </span>&#123;</span><br><span class="line">    xstream.alias(<span class="hljs-string">"xml"</span>, textMessage.getClass());</span><br><span class="line">    <span class="hljs-keyword">return</span> xstream.toXML(textMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> XStream xstream = <span class="hljs-keyword">new</span> XStream(<span class="hljs-keyword">new</span> XppDriver() &#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HierarchicalStreamWriter <span class="hljs-title">createWriter</span><span class="hljs-params">(Writer out)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PrettyPrintWriter(out) &#123;</span><br><span class="line">            <span class="hljs-keyword">boolean</span> cdata = <span class="hljs-keyword">true</span>;</span><br><span class="line">            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"rawtypes"</span>)</span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startNode</span><span class="hljs-params">(String name, Class clazz)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">super</span>.startNode(name, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeText</span><span class="hljs-params">(QuickWriter writer, String text)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (cdata) &#123;</span><br><span class="line">                    writer.write(<span class="hljs-string">"&lt;![CDATA["</span>);</span><br><span class="line">                    writer.write(text);</span><br><span class="line">                    writer.write(<span class="hljs-string">"]]&gt;"</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    writer.write(text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>textMessageToXML 方法用来将 TextMessage 对象转成 XML 返回给微信服务器，类似的方法我们还需要定义 imageMessageToXml、voiceMessageToXml 等，不过定义的方式都基本类似，我就不一一列出来了。</p><h2 id="返回消息分发"><a href="#返回消息分发" class="headerlink" title="返回消息分发"></a>返回消息分发</h2><p>由于用户发来的消息可能存在多种情况，我们需要分类进行处理，这个就涉及到返回消息的分发问题。因此我在这里再定义一个返回消息分发的工具类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">processMessage</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        String openid = map.get(<span class="hljs-string">"FromUserName"</span>); <span class="hljs-comment">//用户 openid</span></span><br><span class="line">        String mpid = map.get(<span class="hljs-string">"ToUserName"</span>);   <span class="hljs-comment">//公众号原始 ID</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (map.get(<span class="hljs-string">"MsgType"</span>).equals(MessageUtil.REQ_MESSAGE_TYPE_TEXT)) &#123; </span><br><span class="line">            <span class="hljs-comment">//普通文本消息</span></span><br><span class="line">            TextMessage txtmsg = <span class="hljs-keyword">new</span> TextMessage();</span><br><span class="line">            txtmsg.setToUserName(openid);</span><br><span class="line">            txtmsg.setFromUserName(mpid);</span><br><span class="line">            txtmsg.setCreateTime(<span class="hljs-keyword">new</span> Date().getTime());</span><br><span class="line">            txtmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">            txtmsg.setContent(<span class="hljs-string">"这是返回消息"</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> MessageUtil.textMessageToXml(txtmsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">processEvent</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//在这里处理事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还可以多加几个 elseif 去判断不同的消息类型，我这里因为只有普通文本消息，所以一个 if 就够用了。</p><p>在这里返回值我写死了，实际上这里需要根据微信服务端传来的 Content 去数据中查询，将查询结果返回，数据库查询这一套相信大家都能搞定，我这里就不重复介绍了。</p><p>最后在消息接收 Controller 中调用该方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(value = <span class="hljs-string">"/verify_wx_token"</span>,produces = <span class="hljs-string">"application/xml;charset=utf-8"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handler</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = MessageUtil.parseXml(request);</span><br><span class="line">    String msgType = map.get(<span class="hljs-string">"MsgType"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (MessageUtil.REQ_MESSAGE_TYPE_EVENT.equals(msgType)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageDispatcher.processEvent(map);</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageDispatcher.processMessage(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Controller 中，我们首先判断消息是否是事件，如果是事件，进入到事件处理通道，如果不是事件，则进入到消息处理通道。</p><p><strong>注意，这里需要配置一下返回消息的编码，否则可能会出现中文乱码。</strong></p><p>如此之后，我们的服务器就可以给公众号返回消息了。</p><p>上篇文章发出后，有小伙伴问松哥这个会不会开源，我可以负责任的告诉大家，肯定会开源，这个系列截稿后，我把代码处理下就上传到 GitHub。</p><p>好了，本文我们就先说到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 各位小伙伴，今天我们来继续学习如何通过 Spring Boot 开发微信公众号。还没阅读过上篇文章的小伙伴建议先看看上文，有助于理解本文：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十六)Spring Boot 开发微信公众号后台(一)</title>
    <link href="http://www.javaboy.org/2020/0104/springboot-weixin.html"/>
    <id>http://www.javaboy.org/2020/0104/springboot-weixin.html</id>
    <published>2020-01-04T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.486Z</updated>
    
    <content type="html"><![CDATA[<p>Hello 各位小伙伴，松哥今天要和大家聊一个有意思的话题，就是使用 Spring Boot 开发微信公众号后台。</p><a id="more"></a><p>很多小伙伴可能注意到松哥的个人网站（<a href="http://www.javaboy.org）前一阵子上线了一个公众号内回复口令解锁网站文章的功能，还有之前就有的公众号内回复口令获取超" target="_blank" rel="noopener">http://www.javaboy.org）前一阵子上线了一个公众号内回复口令解锁网站文章的功能，还有之前就有的公众号内回复口令获取超</a> 2TB 免费视频教程的功能（<a href="https://mp.weixin.qq.com/s/yOVbTBVk4CJy6a0lrKjLXA" target="_blank" rel="noopener">免费视频教程</a>），这两个都是松哥基于 Spring Boot 来做的，最近松哥打算通过一个系列的文章，来向小伙伴们介绍下如何通过 Spring Boot 来开发公众号后台。</p><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1. 缘起"></a>1. 缘起</h2><p>今年 5 月份的时候，我想把我自己之前收集到的一些视频教程分享给公众号上的小伙伴，可是这些视频教程大太了，无法一次分享，单次分享分享链接立马就失效了，为了把这些视频分享给大家，我把视频拆分成了很多份，然后设置了不同的口令，小伙伴们在公众号后台通过回复口令就可以获取到这些视频，口令前前后后有 100 多个，我一个一个手动的在微信后台进行配置。这么搞工作量很大，前前后后大概花了三个晚上才把这些东西搞定。</p><p>于是我就在想，该写点代码了。</p><p>上个月买了服务器，也备案了，该有的都有了，于是就打算把这些资源用代码实现下，因为大学时候搞过公众号开发，倒也没什么难度，于是说干就干。</p><h2 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2. 实现思路"></a>2. 实现思路</h2><p>其实松哥这个回复口令获取视频链接的实现原理很简单，说白了，就是一个数据查询操作而已，回复的口令是查询关键字，回复的内容则是查询结果。这个原理很简单。</p><p>另一方面大家需要明白微信公众号后台开发消息发送的一个流程，大家看下面这张图：</p><p><img src="http://www.javaboy.org/images/boot2/46-2.jpeg" alt></p><p>这是大家在公众号后台回复关键字的情况。那么这个消息是怎么样一个传递流程呢？我们来看看下面这张图：</p><p><img src="http://www.javaboy.org/images/boot2/46-1.png" alt></p><p>这张图，我给大家稍微解释下：</p><ol><li>首先 <code>javaboy4096</code> 这个字符从公众号上发送到了微信服务器</li><li>接下来微信服务器会把 <code>javaboy4096</code> 转发到我自己的服务器上</li><li>我收到 <code>javaboy4096</code> 这个字符之后，就去数据库中查询，将查询的结果，按照腾讯要求的 XML 格式进行返回</li><li>微信服务器把从我的服务器收到的信息，再发回到微信上，于是小伙伴们就看到了返回结果了</li></ol><p>大致的流程就是这个样子。</p><p>接下来我们就来看一下实现细节。</p><h2 id="3-公众号后台配置"><a href="#3-公众号后台配置" class="headerlink" title="3. 公众号后台配置"></a>3. 公众号后台配置</h2><p>开发的第一步，是微信服务器要验证我们自己的服务器是否有效。</p><p>首先我们登录微信公众平台官网后，在公众平台官网的 <strong>开发-基本设置</strong> 页面，勾选协议成为开发者，然后点击“修改配置”按钮，填写：</p><ul><li>服务器地址（URL）</li><li>Token</li><li>EncodingAESKey</li></ul><p><img src="http://www.javaboy.org/images/boot2/46-3.jpeg" alt></p><p>这里的 URL 配置好之后，我们需要针对这个 URL 开发两个接口，一个是 GET 请求的接口，这个接口用来做服务器有效性验证，另一个则是 POST 请求的接口，这个用来接收微信服务器发送来的消息。也就是说，微信服务器的消息都是通过 POST 请求发给我的。</p><p>Token 可由开发者可以任意填写，用作生成签名（该 Token 会和接口 URL 中包含的 Token 进行比对，从而验证安全性）。</p><p>EncodingAESKey 由开发者手动填写或随机生成，将用作消息体加解密密钥。</p><p>同时，开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。明文模式就是我们自己的服务器收到微信服务器发来的消息是明文字符串，直接就可以读取并且解析，安全模式则是我们收到微信服务器发来的消息是加密的消息，需要我们手动解析后才能使用。</p><h2 id="4-开发"><a href="#4-开发" class="headerlink" title="4. 开发"></a>4. 开发</h2><p>公众号后台配置完成后，接下来我们就可以写代码了。</p><h3 id="4-1-服务器有效性校验"><a href="#4-1-服务器有效性校验" class="headerlink" title="4.1 服务器有效性校验"></a>4.1 服务器有效性校验</h3><p>我们首先来创建一个普通的 Spring Boot 项目，创建时引入 <code>spring-boot-starter-web</code> 依赖，项目创建成功后，我们创建一个 Controller ，添加如下接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/verify_wx_token"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    String signature = request.getParameter(<span class="hljs-string">"signature"</span>);</span><br><span class="line">    String timestamp = request.getParameter(<span class="hljs-string">"timestamp"</span>);</span><br><span class="line">    String nonce = request.getParameter(<span class="hljs-string">"nonce"</span>);</span><br><span class="line">    String echostr = request.getParameter(<span class="hljs-string">"echostr"</span>);</span><br><span class="line">    PrintWriter out = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        out = response.getWriter();</span><br><span class="line">        <span class="hljs-keyword">if</span> (CheckUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">            out.write(echostr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这段代码，我做如下解释：</p><ol><li>首先通过 request.getParameter 方法获取到微信服务器发来的 signature、timestamp、nonce 以及 echostr 四个参数，这四个参数中：signature 表示微信加密签名，signature 结合了开发者填写的 token 参数和请求中的timestamp参数、nonce参数；timestamp 表示时间戳；nonce    表示随机数；echostr    则表示一个随机字符串。</li><li>开发者通过检验 signature 对请求进行校验，如果确认此次 GET 请求来自微信服务器，则原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。</li><li>具体的校验就是松哥这里的 CheckUtil.checkSignature 方法，在这个方法中，首先将token、timestamp、nonce 三个参数进行字典序排序，然后将三个参数字符串拼接成一个字符串进行 sha1 加密，最后开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信。</li></ol><p>校验代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckUtil</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String token = <span class="hljs-string">"123456"</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkSignature</span><span class="hljs-params">(String signature, String timestamp, String nonce)</span> </span>&#123;</span><br><span class="line">        String[] str = <span class="hljs-keyword">new</span> String[]&#123;token, timestamp, nonce&#125;;</span><br><span class="line">        <span class="hljs-comment">//排序</span></span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        <span class="hljs-comment">//拼接字符串</span></span><br><span class="line">        StringBuffer buffer = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            buffer.append(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//进行sha1加密</span></span><br><span class="line">        String temp = SHA1.encode(buffer.toString());</span><br><span class="line">        <span class="hljs-comment">//与微信提供的signature进行匹对</span></span><br><span class="line">        <span class="hljs-keyword">return</span> signature.equals(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SHA1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] HEX_DIGITS = &#123;<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>,</span><br><span class="line">            <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>&#125;;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getFormattedText</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = bytes.length;</span><br><span class="line">        StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(len * <span class="hljs-number">2</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            buf.append(HEX_DIGITS[(bytes[j] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>]);</span><br><span class="line">            buf.append(HEX_DIGITS[bytes[j] &amp; <span class="hljs-number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encode</span><span class="hljs-params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string">"SHA1"</span>);</span><br><span class="line">            messageDigest.update(str.getBytes());</span><br><span class="line">            <span class="hljs-keyword">return</span> getFormattedText(messageDigest.digest());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，完成之后，我们的校验接口就算是开发完成了。接下来就可以开发消息接收接口了。</p><h3 id="4-2-消息接收接口"><a href="#4-2-消息接收接口" class="headerlink" title="4.2 消息接收接口"></a>4.2 消息接收接口</h3><p>接下来我们来开发消息接收接口，消息接收接口和上面的服务器校验接口地址是一样的，都是我们一开始在公众号后台配置的地址。只不过消息接收接口是一个 POST 请求。</p><p>我在公众号后台配置的时候，消息加解密方式选择了明文模式，这样我在后台收到的消息直接就可以处理了。微信服务器给我发来的普通文本消息格式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">xml</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">CreateTime</span>&gt;</span>1348831860<span class="hljs-tag">&lt;/<span class="hljs-name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span>&lt;![CDATA[this is a test]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">MsgId</span>&gt;</span>1234567890123456<span class="hljs-tag">&lt;/<span class="hljs-name">MsgId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些参数含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ToUserName</td><td style="text-align:left">开发者微信号</td></tr><tr><td style="text-align:left">FromUserName</td><td style="text-align:left">发送方帐号（一个OpenID）</td></tr><tr><td style="text-align:left">CreateTime</td><td style="text-align:left">消息创建时间 （整型）</td></tr><tr><td style="text-align:left">MsgType</td><td style="text-align:left">消息类型，文本为text</td></tr><tr><td style="text-align:left">Content</td><td style="text-align:left">文本消息内容</td></tr><tr><td style="text-align:left">MsgId</td><td style="text-align:left">消息id，64位整型</td></tr></tbody></table><p>看到这里，大家心里大概就有数了，当我们收到微信服务器发来的消息之后，我们就进行 XML 解析，提取出来我们需要的信息，去做相关的查询操作，再将查到的结果返回给微信服务器。</p><p>这里我们先来个简单的，我们将收到的消息解析并打印出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/verify_wx_token"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    Map&lt;String, String&gt; parseXml = MessageUtil.parseXml(request);</span><br><span class="line">    String msgType = parseXml.get(<span class="hljs-string">"MsgType"</span>);</span><br><span class="line">    String content = parseXml.get(<span class="hljs-string">"Content"</span>);</span><br><span class="line">    String fromusername = parseXml.get(<span class="hljs-string">"FromUserName"</span>);</span><br><span class="line">    String tousername = parseXml.get(<span class="hljs-string">"ToUserName"</span>);</span><br><span class="line">    System.out.println(msgType);</span><br><span class="line">    System.out.println(content);</span><br><span class="line">    System.out.println(fromusername);</span><br><span class="line">    System.out.println(tousername);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; <span class="hljs-title">parseXml</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    InputStream inputStream = request.getInputStream();</span><br><span class="line">    SAXReader reader = <span class="hljs-keyword">new</span> SAXReader();</span><br><span class="line">    Document document = reader.read(inputStream);</span><br><span class="line">    Element root = document.getRootElement();</span><br><span class="line">    List&lt;Element&gt; elementList = root.elements();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Element e : elementList)</span><br><span class="line">        map.put(e.getName(), e.getText());</span><br><span class="line">    inputStream.close();</span><br><span class="line">    inputStream = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到其实都是一些常规代码，没有什么难度。</p><p>做完这些之后，我们将项目打成 jar 包在服务器上部署启动。启动成功之后，确认微信的后台配置也没问题，我们就可以在公众号上发一条消息了，这样我们自己的服务端就会打印出来刚刚消息的信息。</p><p>好了，篇幅限制，今天就和大家先聊这么多，后面再聊不同消息类型的解析和消息的返回问题。</p><p>不知道小伙伴们看懂没？有问题欢迎留言讨论。</p><p>参考资料：微信开放文档</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hello 各位小伙伴，松哥今天要和大家聊一个有意思的话题，就是使用 Spring Boot 开发微信公众号后台。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>2019 原创技术干货整理</title>
    <link href="http://www.javaboy.org/2020/0103/2019-article.html"/>
    <id>http://www.javaboy.org/2020/0103/2019-article.html</id>
    <published>2020-01-03T01:25:37.000Z</published>
    <updated>2020-01-10T02:05:01.448Z</updated>
    
    <content type="html"><![CDATA[<p>公众号的文章改整理一下了，老有小伙伴表示文章找不到，确实是这样，公众号的文章看过了没消化，后来再想找到有点难，有的小伙伴机智的收藏了一下，但是因为收藏夹里的东西太多了，后来还是不好找。</p><a id="more"></a><p>其实松哥公众号上的文章，大家都可以直接在松哥博客上搜索，博客右上角有一个搜索功能：</p><p><img src="http://www.javaboy.org/images/other/104-1.png" alt></p><p>好了，今天我就把 2019 年公众号上的原创干货整理出来，做成索引，方便小伙伴们查找。</p><h2 id="Spring-Boot-系列"><a href="#Spring-Boot-系列" class="headerlink" title="Spring Boot 系列"></a>Spring Boot 系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/DSbR-0Mi6fRGgPQSnL47Pg" target="_blank" rel="noopener">纯 Java 搭建 SSM 项目</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486390&amp;idx=2&amp;sn=351d689ae8e541915ab7c8fcbdb45793&amp;chksm=e9c359d6deb4d0c0afdffa191895bb09adec55625945e3f05c7a4f1528636f86915b493d5ef8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">创建 Spring Boot 项目的三种方式</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486397&amp;idx=2&amp;sn=44f4206b0431e3200fee9a058d6087f8&amp;chksm=e9c359dddeb4d0cbb9fcd7b9c5108a71900dcee28db16c91468797c92ef9678ae7d91da212f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解 spring-boot-starter-parent</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486427&amp;idx=2&amp;sn=91c4462d44f3866bc9ee4cc71feb4e89&amp;chksm=e9c359bbdeb4d0ada43758582d061da9282bb31d6911eb9aada36e61cd70c841426154549665&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解配置文件 application.properties ！</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486440&amp;idx=2&amp;sn=51d96a2a11013c38b0756f634005521a&amp;chksm=e9c35988deb4d09eebd49c04088bdf7038035a454c88aaef3c62c23ccc6cef29ffe68f3d93fa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot中的 yaml 配置</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486499&amp;idx=2&amp;sn=ce229938f5284e3a43e04e9f84121bd1&amp;chksm=e9c35e43deb4d75571c430f42758930f2e963df4bd692dcbc52beac0c6907f9d172ad533904a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">自定义 Spring Boot 中的 starter</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486535&amp;idx=2&amp;sn=2a0c95e2c10ff2d3dea883a4d0352da9&amp;chksm=e9c35e27deb4d73116f17a5105ae40dd08e25dc3393e916b270683d46f459938f263b966bdc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解自动化配置的原理</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486559&amp;idx=2&amp;sn=8a78f43c2ba9d820011ec1f953b1e9d0&amp;chksm=e9c35e3fdeb4d7292592937036e5835dbd5d4eb7c81ebc15c84b5c87950d7ccf2d9d21f24ee5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中配置 Https</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486582&amp;idx=2&amp;sn=ad1c5eac40c85b54e7545a382450a640&amp;chksm=e9c35e16deb4d700e3c3913ab1c890ad8020027113e1bfdf37578bee1e40d5e8fe03a657b780&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Thymeleaf</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486670&amp;idx=2&amp;sn=3f7d624d4dd0c3cef09c24a7616845d4&amp;chksm=e9c35eaedeb4d7b85a1e52249522fa997b3d8cdd975b8bc5fdfeefcc30ce0136867f9c1dd1cb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Freemarker</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486682&amp;idx=2&amp;sn=c3c203a006e19a18b09f768073fd37c4&amp;chksm=e9c35ebadeb4d7acb85b14f1ede981a3a212c5051164022a46cc529939051f0651aa1d0a36fd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中的静态资源配置</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486694&amp;idx=2&amp;sn=8f5b293ab5707b97ef16ddf553575b82&amp;chksm=e9c35e86deb4d7909ea7adf3a0b0507204a900088e4ec56a5efc0392f9948d660e4f29e31eb0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">@ControllerAdvice 的三种使用场景</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486703&amp;idx=2&amp;sn=3a61e9b2a9a4d2c0a6925958b6818a26&amp;chksm=e9c35e8fdeb4d7993e4ccc72565dfabf973b6b7b26acb849449504163be95ac9a89ad180b287&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中的全局异常处理</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486714&amp;idx=2&amp;sn=cc5164e4ee779241998c4d4173449bbc&amp;chksm=e9c35e9adeb4d78c89f70a483c4e30ac20bdfcda8715e71bd5b31706e1549eb766550bb620db&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CORS 解决跨域问题</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486744&amp;idx=2&amp;sn=14b4eb78b9ef8b3528a305619a5f9a66&amp;chksm=e9c35f78deb4d66e61e3dfd91943a872ba8a2afbc5e41582c9b4414f5bc2fb9fd06ca7c6c4ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">定义系统启动任务的两种方式</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486770&amp;idx=2&amp;sn=03c4d34b5497b5328444237adf049038&amp;chksm=e9c35f52deb4d6442e007665ca8d48518582c8e22cb229f1fe5b0a467aa9bcf0650f54883aac&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">定时任务的两种实现方式</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486800&amp;idx=2&amp;sn=39965b130bdfc39e66a2d40a84d7ba57&amp;chksm=e9c35f30deb4d62602fd19cb12b8b755cf4be37de3e0510e2a3c7104b01446681355822947bd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringBoot 整合 Swagger2</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486819&amp;idx=2&amp;sn=38914644e5fb688d9bf662e112f90aad&amp;chksm=e9c35f03deb4d615e7ddff95a3fccfafaeda21d5a05605de526f31f75faa0ba458200936c501&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中自定义 SpringMVC 配置</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486840&amp;idx=2&amp;sn=5d4f75a81b3d8eb02f288a92015f247c&amp;chksm=e9c35f18deb4d60eba6a3ecbe886999ef6c284ea3afce9f0f0b06a93def0dfc00ffc116f4d8b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 JdbcTemplate</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486879&amp;idx=2&amp;sn=16df1ab5688b6df3f4ae59ffa685e00a&amp;chksm=e9c35fffdeb4d6e994d15d66af1d2ab59f491c1dbe99932f4584ed025947ed1ae176b6226720&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合JdbcTemplate 多数据源</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486904&amp;idx=2&amp;sn=8168bef3766c91d65838bb2708d051cc&amp;chksm=e9c35fd8deb4d6ce4533758b6c9871a81dcfd045382623bcc1a593b8c23aacfc9440ff0e984d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">整合 MyBatis</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486912&amp;idx=3&amp;sn=425b82e363554a3fdb89cd955044a314&amp;chksm=e9c35fa0deb4d6b630a0b875cbf923b7c2e64313b74d1d827ebcdbb4cd85839e5f83e789df0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">整合 MyBatis 多数据源</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486935&amp;idx=2&amp;sn=dc8d2596d9238f27db47c7e74696bd76&amp;chksm=e9c35fb7deb4d6a1e5ccd9d6e7f4326a241c849a555b2e4c8c30a75cb902ba283460a12fb5c1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解 Spring Data Jpa</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486959&amp;idx=2&amp;sn=9d29a875d4d475267a9b7855544bdbca&amp;chksm=e9c35f8fdeb4d6991f8f89fb065be43d48f5949a26c892c3ef2a13606cf6f79e7e63b735fdc4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Redis</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486982&amp;idx=2&amp;sn=ca166f7b88d7c8e3aa16aa3742e8d2ef&amp;chksm=e9c35c66deb4d5705ed48d8d2234e38148e6a71f613e90a6fd6f93bb29aaa9be42db488c3f83&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Nginx 极简扫盲入门</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487019&amp;idx=2&amp;sn=2bdb576650d4e493606312544c29d641&amp;chksm=e9c35c4bdeb4d55d29272bf904098345b913f517c07c35cef05c172ae0c440cda1c190b14479&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Session 共享</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487052&amp;idx=2&amp;sn=21806ea097f28e30bd1ec15fb7d0ee44&amp;chksm=e9c35c2cdeb4d53a185b4a444b9c8c82f5724730ba990dca1f1c7906ac3a1461944c193e1969&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Redis</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487066&amp;idx=2&amp;sn=1e411c6543c1dbf9f80219a0db6203a4&amp;chksm=e9c35c3adeb4d52cb298a79344dec218071f429624181b6d4d603519cefbd878d5c45bb40679&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Ehcache</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487103&amp;idx=2&amp;sn=6b83609faf02d0a2a6e153c7db78a3ad&amp;chksm=e9c35c1fdeb4d5098bbc1c4093aff970dd303e3e8c7edaa5d514cfa454973a5ca3ceaa0c7bdd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 构建 RESTful 风格应用</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487130&amp;idx=2&amp;sn=5cf21ef43cc34c572a05eda61907e310&amp;chksm=e9c35cfadeb4d5ecd1be5913e366f62e7f651c4d15805641cdea9db05e3580d5e284f14edb0a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Shiro</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487146&amp;idx=3&amp;sn=ccd3d37ac7678821c9308453a6eb7f16&amp;chksm=e9c35ccadeb4d5dc2faae80c78852233735a924b0c31c8a64403b4f5fbe2df56d3adc3f5eb6d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">整合 Spring Security</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487167&amp;idx=2&amp;sn=21ca4e87814086580fbf2fd2c3ea00c7&amp;chksm=e9c35cdfdeb4d5c98730cba97f2e50fc8e3b151b48811f7f11eefa39049e4ff4626122e7c75d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Security 添加验证码</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487212&amp;idx=2&amp;sn=54d59ea55f7f9df6c7dbd0be3849ae65&amp;chksm=e9c35c8cdeb4d59ab5f26df6f389a81e4d0029a943e0aedce010716147ac6dd4b5338f6ba778&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringSecurity 使用 JSON 格式登录</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487219&amp;idx=2&amp;sn=5a90dde59f21b1ee036488350edc8c6d&amp;chksm=e9c35c93deb4d5851dd345c53c614278c0e5549c65f1db3df8088d1b407cc860952c62970ff1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringSecurity 中角色继承的坑</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487270&amp;idx=2&amp;sn=dcc3bb1660145cb2ff3ce3cecd85b012&amp;chksm=e9c35d46deb4d4500f2b918ec0d5168f4e6fe929d71be094ff5568c43d1135aad570021adb2d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Security 整合 JWT</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487283&amp;idx=2&amp;sn=1cf5dddbed5c0ea728f44fcf17e1d375&amp;chksm=e9c35d53deb4d445f38d1bcd509bbcd00f6950da83384013b2ded615ae1eed104affb264d2e7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Security 非法请求直接返回 JSON</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487291&amp;idx=2&amp;sn=d8f0b196710a06c2deb04b0d569f29cd&amp;chksm=e9c35d5bdeb4d44dd479f3f6c234110b6d7a61930382a8e7ff3da7acd594da68dfbc35afaa8d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 热部署</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487374&amp;idx=2&amp;sn=e6d50ebecc5ffa67fa0999706729c53c&amp;chksm=e9c35deedeb4d4f8e7b1f9c18122b0c12173323aa5fcd505359fbd66b5bfcf74f3cd601b9f56&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 可执行 jar 分析</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487418&amp;idx=2&amp;sn=f4afea6e7b2cf33e00819dbe54bf82ed&amp;chksm=e9c35ddadeb4d4cc10198f3c02ed4c4321c6eeac82991138f87a9d24dd8e6473c92e2113dca0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">部署 Spring Boot 到远程 Docker 容器</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487440&amp;idx=2&amp;sn=91e352ab638a63cbc126f011b4de923d&amp;chksm=e9c35db0deb4d4a668155ad4fd07004da5cb33b8a6518b3c1440973b1eacfa3d3d708d5ec101&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">使用 Jib 部署 Spring Boot</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487459&amp;idx=2&amp;sn=6d1405b414e1787d3fa08806ae096fd2&amp;chksm=e9c35d83deb4d4956f03d9e262f22f5499174db8cea3e0bb78fcff3dc260e1d4dc325fa6f6df&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 邮件发送的 5 种姿势</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487506&amp;idx=2&amp;sn=6b269e8f2c37ea55ea09850afe1f84b1&amp;chksm=e9c34272deb4cb641a2349b8ce7c43c59f33370ddcc67670648b3d468efa77bd0dac746a2922&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Session 中的 Bug</a></li><li><a href="https://mp.weixin.qq.com/s/kJou5tMWuMZpbrtGoaLrdg" target="_blank" rel="noopener">Spring Boot 2.2.0 中的 Bug</a></li><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw" target="_blank" rel="noopener">Spring Boot 开发微信公众号（一）</a></li><li><a href="https://mp.weixin.qq.com/s/1jTl9kBeFeibjbe5EbsCzg" target="_blank" rel="noopener">Spring Boot 开发微信公众号（二）</a></li><li><a href="https://mp.weixin.qq.com/s/deUN4S34y6xwaWnY4Y4jpg" target="_blank" rel="noopener">15 道 Spring Boot 面试题</a></li></ol><h2 id="前后端分离系列"><a href="#前后端分离系列" class="headerlink" title="前后端分离系列"></a>前后端分离系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/HWRYAR16vLE1XFep6_i1tA" target="_blank" rel="noopener">一个Java程序猿眼中的前后端分离以及Vue.js入门</a></li><li><a href="https://mp.weixin.qq.com/s/Qbqvlo7ftbyP6dnbuUcxrw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离，两种文件上传方式总结！</a></li><li><a href="https://mp.weixin.qq.com/s/K8ANNmm6ZrP2xMyK6LGZ_g" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，前端网络请求封装与配置</a></li><li><a href="https://mp.weixin.qq.com/s/5GsOO4QK9AnR0K6FdZixOw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，权限管理的一点思路</a></li><li><a href="https://mp.weixin.qq.com/s/f5kZM3TVZzdv1tI0THjnIg" target="_blank" rel="noopener">前后端分离时代，Java 程序员的变与不变！</a></li><li><a href="https://mp.weixin.qq.com/s/szgfT3tnYMCHSeiE3_QnpA" target="_blank" rel="noopener">学艺不精，总是掉坑！前后端分离历险记</a></li><li><a href="https://mp.weixin.qq.com/s/C7PIck3SIPPTcA3NX3ELoQ" target="_blank" rel="noopener">使用 Nginx 部署前后端分离项目，解决跨域问题</a></li><li><a href="https://mp.weixin.qq.com/s/GvqLzCZngQiMqVE_ZTafeA" target="_blank" rel="noopener">喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了</a></li><li><a href="https://mp.weixin.qq.com/s/NV7pRVnR6sLSjI2Snjl_aQ" target="_blank" rel="noopener">前后端分离开发中动态菜单的两种实现方案</a></li><li><a href="https://mp.weixin.qq.com/s/wwZDx4sRbXjVJPqccRcJvg" target="_blank" rel="noopener">前后端分离，我怎么就选择了 Spring Boot + Vue 技术栈？</a></li></ol><h2 id="MySQL-系列"><a href="#MySQL-系列" class="headerlink" title="MySQL 系列"></a>MySQL 系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/_lsNyXHrsu131mHONQi5rg" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(一)</a></li><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li><li><a href="https://mp.weixin.qq.com/s/xVJjsONasLroJrAGEiuitw" target="_blank" rel="noopener">借力 Docker ，三分钟搞定 MySQL 主从复制！</a></li><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li><li><a href="https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ" target="_blank" rel="noopener">What？Tomcat 竟然也算中间件？</a></li><li><a href="https://mp.weixin.qq.com/s/qWf5XZzhgpSuIGpE2T6iJg" target="_blank" rel="noopener">分布式数据库中间件 MyCat 搞起来！</a></li><li><a href="https://mp.weixin.qq.com/s/4DvKAKiG2sFe_vEQ0mUkeQ" target="_blank" rel="noopener">数据库分库分表，分片配置轻松入门！</a></li><li><a href="https://mp.weixin.qq.com/s/oNsTcrWCjntQefD2B0sq1A" target="_blank" rel="noopener">分布式数据库如何实现主键全局自增？</a></li><li><a href="https://mp.weixin.qq.com/s/OZ0Uqv7UCiyhhRurNdVi4A" target="_blank" rel="noopener">给数据库减负的八个思路</a></li><li><a href="https://mp.weixin.qq.com/s/3eCXo2XhhgT5ZTia3mGbKQ" target="_blank" rel="noopener">MyBatis 中 @Param 注解的四种使用场景，最后一种经常被人忽略！</a></li><li><a href="https://mp.weixin.qq.com/s/-CPpM0xPbqip6Zx6TKzCDQ" target="_blank" rel="noopener">MyBatis中主键回填的两种实现方式</a></li></ol><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ol><li><a href="https://mp.weixin.qq.com/s/Lr5CwOSqYvx-JrFCSGf_Dw" target="_blank" rel="noopener">起早贪黑几个月，我写完了人生第一本书！</a></li><li><a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a></li><li><a href="https://mp.weixin.qq.com/s/wLSM1bHK4-rjOa3WuS46CQ" target="_blank" rel="noopener">一个野生程序员的自我修养</a></li><li><a href="https://mp.weixin.qq.com/s/IJZukUhu-Rec8lF9KQseoQ" target="_blank" rel="noopener">我的第一本书，被选作大学教材了！</a></li><li><a href="https://mp.weixin.qq.com/s/Zx4jiw5QVv3CBa87_K9_Gw" target="_blank" rel="noopener">一个转行程序员的买房经历</a></li><li><a href="https://mp.weixin.qq.com/s/2tSD3U2nmIR-7L-U0sTtUQ" target="_blank" rel="noopener">当公司倒闭时，我在干什么？</a></li><li><a href="https://mp.weixin.qq.com/s/u00E39EyalzRBere_5kpOA" target="_blank" rel="noopener">跟着平台混了四年，现在要单飞了！</a></li><li><a href="https://mp.weixin.qq.com/s/d4x-kNNTfXOh9AODe0Pzzg" target="_blank" rel="noopener">每次回西安，都会动摇我继续留在深圳的决心</a></li><li><a href="https://mp.weixin.qq.com/s/BRQl02_a1FVDXckXjFsJ5Q" target="_blank" rel="noopener">1024，20个入行故事，浮世中见证着程序员的奋斗</a></li><li><a href="https://mp.weixin.qq.com/s/CGK8Labju1CjdkI3omgz-g" target="_blank" rel="noopener">搬砖不易，和大家聊聊松哥经历过的两次裁员</a></li><li><a href="https://mp.weixin.qq.com/s/Jchy_VCMPeCjpKQsfW8k-Q" target="_blank" rel="noopener">华为云 open day，带你看看别人家的公司</a></li></ol><h2 id="系列教程"><a href="#系列教程" class="headerlink" title="系列教程"></a>系列教程</h2><ol><li><a href="https://mp.weixin.qq.com/s/CyMXvY-IzY-69Q_uYxxXMA" target="_blank" rel="noopener">Maven 入门，Maven + IDEA 创建多模块项目，松哥手敲了 30 多页教程给大家送来了</a></li><li><a href="https://mp.weixin.qq.com/s/4N0qWTHM2CuUFRoBIBUHwQ" target="_blank" rel="noopener">来了，松哥纯手工打造的超 50 页 Spring 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/4v7VPjSjf5DW86I3ecptFw" target="_blank" rel="noopener">来了，松哥纯手工打造 80 多页的 SpringMVC 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/sf_ZtaZllP4RdyftZghoHQ" target="_blank" rel="noopener">MyBatis 教程来啦，松哥手码的 SSM 教程总算齐活了，小伙伴们可以下载啦</a></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><a href="https://mp.weixin.qq.com/s/XiUUgFvUQ3y8FUDSXbhEKA" target="_blank" rel="noopener">2019 Java 全栈工程师进阶路线图，一定要收藏！</a></li><li><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">快来！松哥的免费资源库更新啦！</a></li><li><a href="https://mp.weixin.qq.com/s/6PPYwrNestz-gvmB4ZkAqQ" target="_blank" rel="noopener">两步解决maven依赖导入失败问题</a></li><li><a href="https://mp.weixin.qq.com/s/3kyaY0bwoZw3D_big2F11A" target="_blank" rel="noopener">小程序开发框架WePY和mpvue使用感受</a></li><li><a href="https://mp.weixin.qq.com/s/g6D5b_YilzLeBH3pdjRnww" target="_blank" rel="noopener">干货|6个牛逼的基于Vue.js的后台控制面板，接私活必备</a></li><li><a href="https://mp.weixin.qq.com/s/CDnUVdktu1OKiR1HxFwv3Q" target="_blank" rel="noopener">Jpa VS MyBatis，你用哪个？</a></li><li><a href="https://mp.weixin.qq.com/s/HLP_9tyh_uU6XU5zJtks2A" target="_blank" rel="noopener">SpringMVC 方法三种类型返回值总结，你用过几种？</a></li><li><a href="https://mp.weixin.qq.com/s/rQGOyistMMz-X3kI0x21gQ" target="_blank" rel="noopener">天呐，我的服务器竟然也被黑客攻击了！</a></li><li><a href="https://mp.weixin.qq.com/s/OCMea0O_ussoGpMSb3R1oA" target="_blank" rel="noopener">Java 开发中到底该不该用 Lombok？</a></li><li><a href="https://mp.weixin.qq.com/s/_M0oqA9H4DXvB0xdgHjPGw" target="_blank" rel="noopener">想让自己的项目6666，可是 Chrome 不答应！</a></li><li><a href="https://mp.weixin.qq.com/s/MUPcD_-7NMF32tFLj9zhFQ" target="_blank" rel="noopener">天天吹微服务，单体应用有啥不好？</a></li><li><a href="https://mp.weixin.qq.com/s/KxyxlZoZpRWrbK3FJ7lAGA" target="_blank" rel="noopener">身边的人都说微服务好，好在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/pGpRXFqIJN7IhQ5qyNPmRw" target="_blank" rel="noopener">IDEA 神器入坑指南！17 个常用快捷键奉上！</a></li><li><a href="https://mp.weixin.qq.com/s/BwI8q9Cj3BfCbVUURc9DlA" target="_blank" rel="noopener">Spring 中用 XML 装配 Bean，竟然有五种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/PbFyhErajZoQPJ_G3osJeQ" target="_blank" rel="noopener">浏览 GitHub 太卡了？教你两招！</a></li><li><a href="https://mp.weixin.qq.com/s/yhDqHfbWJmRlPR0Nt1UUyg" target="_blank" rel="noopener">原创的离线版 Redis 教程，给力！</a></li><li><a href="https://mp.weixin.qq.com/s/F2jee_Y7J7lrOHfyXBBSvw" target="_blank" rel="noopener">微人事 star 数超 10k 啦！聊聊如何打造一个 star 数超 10k 的开源项目</a></li><li><a href="https://mp.weixin.qq.com/s/T_GIavgSPQBoJGqZ-2PJVQ" target="_blank" rel="noopener">晚十点半之前下班是耻辱？老板干嘛老爱和员工谈创业精神？</a></li><li><a href="https://mp.weixin.qq.com/s/9aMRFEXbh0-usVE96uZ8Ag" target="_blank" rel="noopener">学 Maven，看松哥这一篇就够了</a></li><li><a href="https://mp.weixin.qq.com/s/PZA4IjqXpQt1TWlCWguyvQ" target="_blank" rel="noopener">学习 Spring，看松哥这篇万余字的干货，够用了！</a></li><li><a href="https://mp.weixin.qq.com/s/Eo2RRB6zKQuPDMWlnCHDrw" target="_blank" rel="noopener">两年了，微人事项目迎来了一次重大更新</a></li><li><a href="https://mp.weixin.qq.com/s/7rvGBlfYie9A_4_J1uoqpg" target="_blank" rel="noopener">跟松哥学 SpringMVC（1/2）</a></li><li><a href="https://mp.weixin.qq.com/s/yNFFDWa8srJL0ArRE4H0oA" target="_blank" rel="noopener">跟松哥学 SpringMVC（2/2）</a></li></ol><h2 id="视频干货"><a href="#视频干货" class="headerlink" title="视频干货"></a>视频干货</h2><ol><li><a href="https://mp.weixin.qq.com/s/qN01Le434FWom0c3jqiQmA" target="_blank" rel="noopener">为了帮助前后端分离的新手，我做了一次大胆的尝试！</a></li><li><a href="https://mp.weixin.qq.com/s/sgjm09_e8ue5blXqPgeXZA" target="_blank" rel="noopener">说出来你可能不信，Spring Boot 中 Session 共享不超过 5 行代码！</a></li><li><a href="https://mp.weixin.qq.com/s/1rVPzJGCtDZKvMoA4BYzIA" target="_blank" rel="noopener">Spring Boot 整合 OAuth2，松哥手把手教你！</a></li><li><a href="https://mp.weixin.qq.com/s/Rrj7oco3K8kJBsTxEEdz9g" target="_blank" rel="noopener">Spring Boot 结合 WebSocket 实现在线聊天</a></li><li><a href="https://mp.weixin.qq.com/s/Sn59dxwtsEWoj2wdynQuRQ" target="_blank" rel="noopener">Spring Security 结合 Jwt 实现无状态登录</a></li><li><a href="https://mp.weixin.qq.com/s/qxMkC6H4XfCT4LqMrYtgsQ" target="_blank" rel="noopener">手把手教你 Spring Boot 整合 Spring Data Jpa</a></li><li><a href="https://mp.weixin.qq.com/s/OMgoUfH8lk8hDfuqWXGWTA" target="_blank" rel="noopener">Spring Boot + Vue，手把手教你做文件上传</a></li><li><a href="https://mp.weixin.qq.com/s/eun-ChD5KyN6LsbR9qFfiQ" target="_blank" rel="noopener">使用 Spring Security 实现微人事前后端分离登录接口</a></li><li><a href="https://mp.weixin.qq.com/s/rH5MeKuTnXbyaDaGsU4wNw" target="_blank" rel="noopener">Spring Boot 在后端如何控制前端 Vue 中菜单动态加载？</a></li><li><a href="https://mp.weixin.qq.com/s/7KftnJRj-3xnB3Eo-eUhbw" target="_blank" rel="noopener">手把手教你 Spring Boot 整合 Redis</a></li><li><a href="https://mp.weixin.qq.com/s/FoNVyAR1BkYfutFq9sjJNQ" target="_blank" rel="noopener">新版微人事部署教程来啦</a></li></ol><h2 id="优质投稿"><a href="#优质投稿" class="headerlink" title="优质投稿"></a>优质投稿</h2><ol><li><a href="https://mp.weixin.qq.com/s/Tup0cP2ZCdzodD8790Hr1w" target="_blank" rel="noopener">Spring Security 工作原理概览</a></li><li><a href="https://mp.weixin.qq.com/s/_szH8aN6HDR_1Z5Nyu4pmA" target="_blank" rel="noopener">MySQL复合索引和单列索引的单表查询分析</a></li><li><a href="https://mp.weixin.qq.com/s/r52hmD71TtiJjlOzQUvRlA" target="_blank" rel="noopener">干货推荐|Java并发编程核心概念一览，面试必备！</a></li><li><a href="https://mp.weixin.qq.com/s/7Dod-NcukPjYuQizGEdZdg" target="_blank" rel="noopener">面试干货 | Java 能否自定义一个类叫 java.lang.System？</a></li><li><a href="https://mp.weixin.qq.com/s/KoAUQm1-FXbi2WObrH3DOw" target="_blank" rel="noopener">Java 中的 jar ，天天见，可是你知道它的运行机制吗？</a></li><li><a href="https://mp.weixin.qq.com/s/U9WGULQoxdtWXGng_dpOdA" target="_blank" rel="noopener">干货 | 鸟瞰 MySQL，唬住面试官！</a></li><li><a href="https://mp.weixin.qq.com/s/8LhYFMQYfWfcDIti5qLMoA" target="_blank" rel="noopener">读者来稿：想和你聊聊 TCC</a></li></ol><p>好了，小伙伴们收藏好这篇文章，就不怕再也找不到松哥 2019 年的原创干货了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公众号的文章改整理一下了，老有小伙伴表示文章找不到，确实是这样，公众号的文章看过了没消化，后来再想找到有点难，有的小伙伴机智的收藏了一下，但是因为收藏夹里的东西太多了，后来还是不好找。&lt;/p&gt;
    
    </summary>
    
      <category term="2019" scheme="http://www.javaboy.org/categories/2019/"/>
    
    
      <category term="2019-article" scheme="http://www.javaboy.org/tags/2019-article/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十五)Spring Boot 2.2.0 中的 Bug</title>
    <link href="http://www.javaboy.org/2020/0103/springboot-freemarker-bug.html"/>
    <id>http://www.javaboy.org/2020/0103/springboot-freemarker-bug.html</id>
    <published>2020-01-03T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.487Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot2.2.0 这个版本发布没多久，Spring Boot2.2.1 就出来，看似不太重要的版本，却发生了一个小小变化，导致不少小伙伴掉坑了，我本来也没太在意，但是最近有快十个小伙伴在微信上问这个问题，看来我必须得写篇文章说下了，防止小伙伴们掉坑了。</p><a id="more"></a><p>到底是什么问题呢？其实就是 Freemarker 后缀变化的问题，一开始收到这个问题的时候，我以为就是小伙伴们学习不认真导致的，也没太在意：</p><p><img src="http://www.javaboy.org/images/boot2/45-1.png" alt><br><img src="http://www.javaboy.org/images/boot2/45-2.png" alt></p><p>结果最近不停有人掉坑，我觉得很有必要给各位小伙伴提个醒。</p><p>很多小伙伴可能很早就接触过 Freemarker，这个模板在 SSM 中也可以使用，只不过需要我们自己的配置东西稍微有点多。但是在之前我们使用 Freemarker 时，这个模板文件的后缀是 ftl，所以我们理所当然的认为这是标准后缀。</p><p>其实不然。</p><p>在 Freemarker 中，还有两个后缀，一个叫做 ftlh，这个用在 HTML 模板中，另一个叫做 ftlx，这个用在 XML 模板中。</p><p>Spring Boot2.2.0 之前，Freemarker 模板默认采用的后缀就是 ftl，我们可以看下 FreeMarkerProperties 类的部分源码（Spring Boot2.2.0 之前的版本）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="hljs-string">"spring.freemarker"</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">"classpath:/templates/"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".ftl"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap();</span><br><span class="line">    <span class="hljs-keyword">private</span> String[] templateLoaderPath = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"classpath:/templates/"</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> preferFileSystemAccess = <span class="hljs-keyword">true</span>;</span><br></pre></td></tr></table></figure><p>可以看到，DEFAULT_SUFFIX 变量中定义的 Freemarker 默认的后缀还是 <code>.ftl</code>。</p><p>从 Spring Boot2.2.0 开始，FreeMarkerProperties 文件内容就发生了变化，最新的 FreeMarkerProperties 文件部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="hljs-string">"spring.freemarker"</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">"classpath:/templates/"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".ftlh"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap();</span><br><span class="line">    <span class="hljs-keyword">private</span> String[] templateLoaderPath = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"classpath:/templates/"</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> preferFileSystemAccess = <span class="hljs-keyword">true</span>;</span><br></pre></td></tr></table></figure><p>可以看到，这个时候在 DEFAULT_SUFFIX 变量中定义的默认后缀变成 <code>.ftlh</code> 了。</p><p>就这样一个小小变化，就把很多初次接触 Spring Boot 的小伙伴搞晕啦。</p><p>那么这个问题如何解决呢？当大家发现了原因，应该也就能找到解决办法了，其实很简单，两个思路：</p><ul><li>将 Freemarker 模板的后缀改为 <code>.ftlh</code>，推荐这种方式</li><li>在 application.properties 中修改默认配置</li></ul><p>第一种方案，就是我们在定义 Freemarker 模板的时候，直接将原来的 ftl 改成 ftlh 就可以了，像下面这张图这样：</p><p><img src="http://www.javaboy.org/images/boot2/45-3.png" alt></p><p>这样框架就能找到相应的模板文件了。</p><p>第二种方案就是 Freemarker 模板的后缀不变，依然是 <code>ftl</code>，然后我们在 application.properties 中修改默认的后缀配置，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.freemarker.suffix=.ftl</span><br></pre></td></tr></table></figure><p>这样就是人为强行把 Freemarker 模板的后缀又改回 <code>.ftl</code> 了。</p><p>这两种方案都可以解决这个问题。</p><p><strong>其实这个问题很简单，只要你看了 FreeMarkerProperties 类的源码，这个问题一下就明了了。</strong></p><p>松哥刚开始录 Spring Boot 视频的时候，当时最新版是 2.1.6，后来随着视频录制，Spring Boot 版本一直在变化，视频里一直是跟随最新版录制，不过在讲 Freemarker 这块的时候，还是 2.1.6，所以当时还不存在上面这个问题。虽然问题不存在，但是我在视频中却是带领小伙伴们看了 FreeMarkerProperties 类的源码的，出了问题之后，有小伙伴就机智的去翻这个类的源码，然后自己顺利的把问题解决了。感觉深得松哥真传，吾心甚慰。</p><p><img src="http://www.javaboy.org/images/boot2/45-4.png" alt></p><p>好了，一个小小的坑，小伙伴们在这里遇到问题稍稍留意下就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot2.2.0 这个版本发布没多久，Spring Boot2.2.1 就出来，看似不太重要的版本，却发生了一个小小变化，导致不少小伙伴掉坑了，我本来也没太在意，但是最近有快十个小伙伴在微信上问这个问题，看来我必须得写篇文章说下了，防止小伙伴们掉坑了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十四)Spring Session 中的 Bug</title>
    <link href="http://www.javaboy.org/2020/0102/springboot-springsession.html"/>
    <id>http://www.javaboy.org/2020/0102/springboot-springsession.html</id>
    <published>2020-01-02T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.424Z</updated>
    
    <content type="html"><![CDATA[<p>真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。</p><a id="more"></a><p>如果大家没看过松哥之前写的 Spring Boot 整合 Spring Session，可以先回顾下：</p><ul><li><a href="https://mp.weixin.qq.com/s/qf-cQ7wI_Sp5pENTLlCRJw" target="_blank" rel="noopener">Spring Boot2 系列教程(二十八)Spring Boot 整合 Session 共享</a></li></ul><h2 id="第一次踩坑"><a href="#第一次踩坑" class="headerlink" title="第一次踩坑"></a>第一次踩坑</h2><p>事情是这样的，大概在今年 6 月初的时候，我在项目中使用到了 Session 共享，当时采用的方案就是 Redis+Spring Session。本来这是一个很简单的问题，我在以前的项目中也用过多次这种方案，早已轻车熟路，但是那次有点不对劲，项目启动时候报了如下错误：</p><p><img src="http://www.javaboy.org/images/boot2/44-1.png" alt></p><p>一模一样的代码，但是运行就是会出错，我感觉莫名其妙。因为在 Spring Boot 中整合 Spring Session 是一个非常简单的操作，就几行 Redis 的配置而已，我在确认了代码没问题之后，很快想到了可能是版本问题，因为当时 Spring Boot2.1.5 刚刚发布，我喜欢用最新版。于是我尝试将 Spring Boot 的版本切换到 2.1.4 ，切换回去之后，果然就 OK了，再次启动项目又不会报错了。于是基本确定这是 Spring Boot 的版本升级带来的问题。</p><p>但是当时我并没有深究，我以为就是官方出于安全考虑，让你在使用 Redis 时强制加上 Spring Security（因为根据错误提示，很容想到加上 Spring Security 依赖），加上 Spring Security 依赖之后，果然就没有问题了，我也没有多想，这件事就这样过了。​</p><h2 id="第二次踩坑"><a href="#第二次踩坑" class="headerlink" title="第二次踩坑"></a>第二次踩坑</h2><p>前两天我在给星球上的小伙伴录制 Spring Boot 视频的时候，采用了  Spring Boot 最新版 2.1.7，也是 Spring Session，但是在创建项目的时候，忘记添加 Spring Security 依赖了（第一次踩坑之后，我每次用 Spring Session 都会自觉的加上 Spring Security 依赖），运行的时候竟然没报错！我就郁闷了。</p><p>于是我去试了 Spring Boot2.1.4、Spring Boot2.1.6 发现都没有问题，在使用 Spring Session 的时候都不需要添加 Spring Security 依赖，只有 Spring Boot2.1.5 才有这个问题。于是我大概明白了，这可能是一个 Bug，而不是版本升级的新功能。</p><p>这一次，那我就打算追究一下问题的根源。</p><h2 id="源头"><a href="#源头" class="headerlink" title="源头"></a>源头</h2><p>要追究问题的源头，我们当然得从 Spring Session 的自动化配置类开始。</p><p>在 Spring Boot2.1.5 的 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类中，我看到如下源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectProvider&lt;SpringSessionRememberMeServices&gt; springSessionRememberMeServices)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//.....</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer</span><br><span class="line">.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line">springSessionRememberMeServices.ifAvailable((</span><br><span class="line">rememberMeServices) -&gt; cookieSerializer.setRememberMeRequestAttribute(</span><br><span class="line">SpringSessionRememberMeServices.REMEMBER_ME_LOGIN_ATTR));</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这一段源码中我们可以看到，这里使用到了 SpringSessionRememberMeServices ，而这个类中则用到 Spring Security 中相关的类。因此，如果不引入 Spring Security 就会报错。</p><p>我们再来看看 Spring Boot2.1.6 中 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类的源码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line"><span class="hljs-keyword">if</span> (ClassUtils.isPresent(REMEMBER_ME_SERVICES_CLASS, getClass().getClassLoader())) &#123;</span><br><span class="line"><span class="hljs-keyword">new</span> RememberMeServicesCookieSerializerCustomizer().apply(cookieSerializer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 Spring Boot2.1.6 中，这个问题已经得到修复。这里就没有 2.1.5 那么冲动了，上来了先用 <code>ClassUtils.isPresent</code> 方法判断了下 REMEMBER_ME_SERVICES_CLASS(<code>org.springframework.security.web.authentication.RememberMeServices</code>) 是否存在，存在的话，才有后面的操作。</p><p>至此，这个问题就总算弄懂了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>大家平时遇到问题，如果项目不是很赶的话，可以留意多想想，多追究一下原因，说不定你会有很多意外的收获。我这次就是一个活生生的例子，一开始没多想，后来又发现不对劲，前前后后一折腾，反而又多浪费了一些时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>2019 ，值了</title>
    <link href="http://www.javaboy.org/2020/0101/2019-life.html"/>
    <id>http://www.javaboy.org/2020/0101/2019-life.html</id>
    <published>2020-01-01T01:25:25.000Z</published>
    <updated>2020-01-10T02:03:56.747Z</updated>
    
    <content type="html"><![CDATA[<p>松哥是一个超级没有安全感的人，这可能和小时候的经历有关。</p><p>工作之后，互联网行业见过了太多的裁员与公司倒闭，这些事情，松哥自己都经历过好几波：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/CGK8Labju1CjdkI3omgz-g" target="_blank" rel="noopener">搬砖不易，和大家聊聊松哥经历过的两次裁员</a></li><li><a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a></li></ul><p>因此，从刚刚开始工作，就没敢放松警惕，一直在不断学习，不断的提高，只有不断的学习，不断的输出技术，才会让我有一点点安全感，才会感到踏实。</p><p>但是在 2019 年之前，我从来没想过可以凭技术输出赚钱，那个时候，我只是想凭着技术输出，获取一些技术影响力，帮助自己在跳槽的时候加分，化解职场风险（我的第一次跳槽就是因写博客结缘，对方的负责人通过 CSDN 博客找到我，给出了翻倍的薪水，参见：<a href="https://mp.weixin.qq.com/s/Zx4jiw5QVv3CBa87_K9_Gw" target="_blank" rel="noopener">一个转行程序员的买房经历</a>），不停的技术输出只是为了让我在找工作的时候更加从容。</p><p>但是在 3 月份，华为组织了一场云享专家与 MVP 的线下技术交流活动，活动中认识了纯洁的微笑，活动结束后和大佬约了个饭，微笑哥和我聊了公众号的事情，对我来说，就像打开了一扇新大门，于是从 3 月份开始，就认认真真开始做公众号，技术输出，到现在，坚持了差不多十个月了，公众号上的收获可能是 2019 最大的收获。</p><p>当然除了公众号，还有视频教程、新书等，接下来我想从这几个方面和大家聊聊我的 2019。</p><h2 id="关于书"><a href="#关于书" class="headerlink" title="关于书"></a>关于书</h2><p>其实我一直有点自卑，去年虽然辛辛苦苦写了书，但是信心不足，新书刚刚开始销售的时候，我心里想着首印能够卖完就算不错了。</p><p>没想到的是，这本书还比较受小伙伴们的欢迎，以至于后来加印多次。当然这也可能是和清华大学出版社强大的教材销售渠道有关，因为有不少小伙伴加我微信表示这本书他们在学校有用到（<a href="https://mp.weixin.qq.com/s/IJZukUhu-Rec8lF9KQseoQ" target="_blank" rel="noopener">我的第一本书，被选作大学教材了！</a>）。</p><p>不过老实说，写书其实不挣钱，技术图书出版社给到作者的稿酬基本都是 8%，也就是说一本售价 ¥70 的书，到作者手上就是 ¥5.6，再扣除个人所得税，还不到这个数。找过我的几家出版社，我打听了下，基本都是这个样子，所以你会看到，相比于写书，有不少作者宁愿去一些平台上出一些在线课程。</p><p>不过写书也有一些其他好处，例如可以和人吹牛。松哥因为这本书，结识了很多大佬，也认识了在座的各位小伙伴，这真是一件让人超级满足的事情。</p><h2 id="关于视频"><a href="#关于视频" class="headerlink" title="关于视频"></a>关于视频</h2><p>视频的成绩，有点出乎我的意料。</p><p>2 月份刚从老家回到深圳的时候，我就想针对书录制一套视频教程，但是一集都没录完，就放弃了，太费事了。</p><p>后来从 3 月份开始做公众号之后，我也学着其他大佬一样，开通了我自己的知识星球（Java 达摩院），出乎我意料的是，开通的头一天，就有十来个小伙伴加入了，感觉都是真爱呀。</p><p>一开始星球的定位就是给大家解决问题，聊一聊前后端分离，分享一些资源，后来发现这条路根本走不通，很多时候，大家的问题不是一言两语能搞定的，除非是一些非常典型的问题。等到六月份的时候，我一度想关闭星球，因为我觉得很难在星球上给大家提供有价值的东西，就这样犹犹豫豫到了 7 月。7 月份的时候，由于 Spring Cloud 专栏写完了，周末时间又腾出来了，加上那段时间有不少小伙伴问松哥有没有 Spring Boot 视频，于是我就下定决心，决定认认真真录一套和书配套的视频教程。</p><p>出乎我意料的是，这套视频非常受小伙伴们欢迎，截止到昨天，视频已经卖出了 1000+ 份，其中有 1/4 的小伙伴都是经朋友或者同学的介绍来的，这也给了我极大的信心，决定认认真真把这套视频教程搞完。</p><p>关于视频教程，我还想多说一句：录制视频教程，一开始当然是为了赚点外快。但是在我心里，比赚钱更重要的是小伙伴的认可，如果你认可我的 vhr，认可我的技术文章，那你买视频，我不会让大家失望，这是双赢；如果不认可的话，我其实是非常不建议购买我的视频教程的。</p><h2 id="关于公众号"><a href="#关于公众号" class="headerlink" title="关于公众号"></a>关于公众号</h2><p>公众号是我 2017 年申请的，到 2019 年 3 月份才 5200+ 读者，然后从 3 月份开始，下定决心做之后，用户的增长一直还比较可观，上周刚刚突破了 3W。这一路的历程也是比较艰辛的（<a href="https://mp.weixin.qq.com/s/Y7IqyoL140l1YV0AuJLD1w" target="_blank" rel="noopener">一个小小的里程碑！</a>）.</p><p>公众号 2019 年的原创技术文章大概也在 100 多篇，平均三天一篇技术干货。这些文章我两天会抽空整理好，制作好一个索引，方便大家查找。</p><p>公众号对我来说更重要的意义可能可能不仅仅是读者的增长，更在于我总算 GET 到了流量时代的商业模式了，以前都是一窍不通，而现在总算打开了新局面，在我了解到公众号的玩法之前，对于副业赚钱，我一直停留在接私活上，这也导致我在刚工作的几年里，做了好几个私活，做完之后，慢慢发现外包赚的都是辛苦钱，都是牺牲自己的业余休息时间赚来的，但是没办法，没有其他的副业思路，直到 2019 开始认认真真搞公众号。</p><p>说到公众号这个事情，我觉得我是起了个大早赶了个晚集。我 2014 年就做过公众号后台开发，那个时候大学还没毕业，2017 年注册了自己的公众号，但是一直都不懂这个东西怎么玩，直到 2019 才开窍，用后知后觉来形容一点都不为过。不过在坚持了 10 个多月之后，总算见到了一点点黎明前的曙光。</p><p>公众号的事，未来还要仰仗各位小伙伴多多支持，当然松哥也会提供更多的干货出来，后面也会和大家公布 2020 年的干货计划。</p><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>清明节期间，松哥终于搭建好了自己的个人博客，有了一个更加专业的展示自己博客内容的平台。从刚开始的每日个位数的 PV，到现在每日超过 2000 PV，也是不易。博客的流量谷歌搜索占了大头，因为博客托管在 GitHub 上，所以来自百度的流量比较少，不过这也导致了一个问题，就是博客的访问量比较慢，最近也打算抽空把博客迁到国内的云平台上。</p><p>松哥个人博客，目前做好了不少站点，对 Spring Boot+Spring Cloud+前后端分离感兴趣的小伙伴，这绝对是一个很棒的学习资源。</p><ul><li><a href="http://www.javaboy.org">http://www.javaboy.org</a></li><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li><li><a href="http://spring.javaboy.org" target="_blank" rel="noopener">http://spring.javaboy.org</a></li><li><a href="http://springmvc.javaboy.org" target="_blank" rel="noopener">http://springmvc.javaboy.org</a></li><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li><li><a href="http://maven.javaboy.org" target="_blank" rel="noopener">http://maven.javaboy.org</a></li></ul><p>2020 还有很多新的计划，小伙伴们关注就对了哈哈。</p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>忘了以前在哪里看到的，有人说副业做的好的人，本职工作都不会差，副业做不好的话，本职工作也不能做很好，所以本职工作就不和大家细聊了，对得起自己，对得起老板，这个就不和大家细聊了。</p><p>2019 年差不多就是这些事情吧，2020 年有很多干货计划，小伙伴们敬请期待吧。</p><p>2019 年，小伙伴们要是有值得铭记的故事，欢迎投稿。好的文章，松哥可能会送你一套松哥自制的 Spring Boot 视频教程哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥是一个超级没有安全感的人，这可能和小时候的经历有关。&lt;/p&gt;
&lt;p&gt;工作之后，互联网行业见过了太多的裁员与公司倒闭，这些事情，松哥自己都经历过好几波：&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十三)Spring Boot 邮件发送的 5 种姿势</title>
    <link href="http://www.javaboy.org/2020/0101/springboot-mail.html"/>
    <id>http://www.javaboy.org/2020/0101/springboot-mail.html</id>
    <published>2020-01-01T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.373Z</updated>
    
    <content type="html"><![CDATA[<p>邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。</p><a id="more"></a><h1 id="邮件基础"><a href="#邮件基础" class="headerlink" title="邮件基础"></a>邮件基础</h1><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。  </p><p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。  </p><p>生活中我们投递一封邮件要经过如下几个步骤：  </p><ol><li>深圳的小王先将邮件投递到深圳的邮局  </li><li>深圳的邮局将邮件运送到上海的邮局  </li><li>上海的小张来邮局取邮件   </li></ol><p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> ：  </p><ol><li><a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器  </li><li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器  </li><li><a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 登录网易的邮件服务器查看邮件  </li></ol><p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。  </p><p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件与 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><p>最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。  </p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>目前国内大部分的邮件服务商都不允许直接使用用户名/密码的方式来在代码中发送邮件，都是要先申请授权码，这里以 QQ 邮箱为例，向大家演示授权码的申请流程：首先我们需要先登录 QQ 邮箱网页版，点击上方的设置按钮：  </p><p><img src="http://www.javaboy.org/images/boot2/43-1.jpg" alt="p266">  </p><p>然后点击账户选项卡：  </p><p><img src="http://www.javaboy.org/images/boot2/43-2.jpg" alt="p267">  </p><p>在账户选项卡中找到开启POP3/SMTP选项，如下：  </p><p><img src="http://www.javaboy.org/images/boot2/43-3.jpg" alt="p268">  </p><p>点击开启，开启相关功能，开启过程需要手机号码验证，按照步骤操作即可，不赘述。开启成功之后，即可获取一个授权码，将该号码保存好，一会使用。</p><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p>接下来，我们就可以创建项目了，Spring Boot 中，对于邮件发送提供了自动配置类，开发者只需要加入相关依赖，然后配置一下邮箱的基本信息，就可以发送邮件了。</p><ul><li>首先创建一个 Spring Boot 项目，引入邮件发送依赖：</li></ul><p><img src="http://www.javaboy.org/images/boot2/43-4.png" alt></p><p>创建完成后，项目依赖如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置邮箱基本信息</li></ul><p>项目创建成功后，接下来在 application.properties 中配置邮箱的基本信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=587</span><br><span class="line">spring.mail.username=1510161612@qq.com</span><br><span class="line">spring.mail.password=ubknfzhjkhrbbabe</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory</span><br><span class="line">spring.mail.properties.mail.debug=true</span><br></pre></td></tr></table></figure><p>配置含义分别如下：</p><ul><li>配置 SMTP 服务器地址</li><li>SMTP 服务器的端口</li><li>配置邮箱用户名</li><li>配置密码，注意，不是真正的密码，而是刚刚申请到的授权码</li><li>默认的邮件编码</li><li>配饰 SSL 加密工厂</li><li>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</li></ul><p>如果不知道 smtp 服务器的端口或者地址的的话，可以参考 腾讯的邮箱文档</p><ul><li><a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371" target="_blank" rel="noopener">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371</a></li></ul><p>做完这些之后，Spring Boot 就会自动帮我们配置好邮件发送类，相关的配置在 <code>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration</code> 类中，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; MimeMessage.class, MimeType.class, MailSender.class &#125;)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(MailSender.class)</span><br><span class="line"><span class="hljs-meta">@Conditional</span>(MailSenderCondition.class)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(MailProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，可以看到，导入了另外一个配置 <code>MailSenderPropertiesConfiguration</code> 类，这个类中，提供了邮件发送相关的工具类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mail"</span>, name = <span class="hljs-string">"host"</span>)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderPropertiesConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MailProperties properties;</span><br><span class="line">        MailSenderPropertiesConfiguration(MailProperties properties) &#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> JavaMailSenderImpl <span class="hljs-title">mailSender</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                JavaMailSenderImpl sender = <span class="hljs-keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">                applyProperties(sender);</span><br><span class="line">                <span class="hljs-keyword">return</span> sender;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里创建了一个 <code>JavaMailSenderImpl</code> 的实例， <code>JavaMailSenderImpl</code> 是 <code>JavaMailSender</code> 的一个实现，我们将使用 <code>JavaMailSenderImpl</code> 来完成邮件的发送工作。</p><p>做完如上两步，邮件发送的准备工作就算是完成了，接下来就可以直接发送邮件了。</p><p>具体的发送，有 5 种不同的方式，我们一个一个来看。</p><h2 id="发送简单邮件"><a href="#发送简单邮件" class="headerlink" title="发送简单邮件"></a>发送简单邮件</h2><p>简单邮件就是指邮件内容是一个普通的文本文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JavaMailSender javaMailSender;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSimpleMail</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();</span><br><span class="line">    message.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    message.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    message.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    message.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    message.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    message.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    message.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    javaMailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上往下，代码含义分别如下：</p><ol><li>构建一个邮件对象</li><li>设置邮件主题</li><li>设置邮件发送者</li><li>设置邮件接收者，可以有多个接收者</li><li>设置邮件抄送人，可以有多个抄送人</li><li>设置隐秘抄送人，可以有多个</li><li>设置邮件发送日期</li><li>设置邮件的正文</li><li>发送邮件</li></ol><p>最后执行该方法，就可以实现邮件的发送，发送效果图如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-5.png" alt></p><h2 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h2><p>邮件的附件可以是图片，也可以是普通文件，都是支持的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAttachFileMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    helper.addAttachment(<span class="hljs-string">"javaboy.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里在构建邮件对象上和前文有所差异，这里是通过 javaMailSender 来获取一个复杂邮件对象，然后再利用 MimeMessageHelper 对邮件进行配置，MimeMessageHelper 是一个邮件配置的辅助工具类，创建时候的 true 表示构建一个 multipart message 类型的邮件，有了 MimeMessageHelper 之后，我们针对邮件的配置都是由 MimeMessageHelper 来代劳。</p><p>最后通过 addAttachment 方法来添加一个附件。</p><p>执行该方法，邮件发送效果图如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-6.png" alt></p><h2 id="发送带图片资源的邮件"><a href="#发送带图片资源的邮件" class="headerlink" title="发送带图片资源的邮件"></a>发送带图片资源的邮件</h2><p>图片资源和附件有什么区别呢？图片资源是放在邮件正文中的，即一打开邮件，就能看到图片。但是一般来说，不建议使用这种方式，一些公司会对邮件内容的大小有限制（因为这种方式是将图片一起发送的）。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendImgResMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"&lt;p&gt;hello 大家好，这是一封测试邮件，这封邮件包含两种图片，分别如下&lt;/p&gt;&lt;p&gt;第一张图片：&lt;/p&gt;&lt;img src='cid:p01'/&gt;&lt;p&gt;第二张图片：&lt;/p&gt;&lt;img src='cid:p02'/&gt;"</span>,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p01"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>)));</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p02"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy2.png"</span>)));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的邮件 text 是一个 HTML 文本，里边涉及到的图片资源先用一个占位符占着，setText 方法的第二个参数 true 表示第一个参数是一个 HTML 文本。</p><p>setText 之后，再通过 addInline 方法来添加图片资源。</p><p>最后执行该方法，发送邮件，效果如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-7.png" alt></p><p>在公司实际开发中，第一种和第三种都不是使用最多的邮件发送方案。因为正常来说，邮件的内容都是比较的丰富的，所以大部分邮件都是通过 HTML 来呈现的，如果直接拼接 HTML 字符串，这样以后不好维护，为了解决这个问题，一般邮件发送，都会有相应的邮件模板。最具代表性的两个模板就是 <code>Freemarker</code> 模板和 <code>Thyemeleaf</code> 模板了。</p><h2 id="使用-Freemarker-作邮件模板"><a href="#使用-Freemarker-作邮件模板" class="headerlink" title="使用 Freemarker 作邮件模板"></a>使用 Freemarker 作邮件模板</h2><p>首先需要引入 Freemarker 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>resources/templates</code> 目录下创建一个 <code>mail.ftl</code> 作为邮件发送模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;salary&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，将邮件模板渲染成 HTML ，然后发送即可。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFreemarkerMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException, IOException, TemplateException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    <span class="hljs-comment">//构建 Freemarker 的基本配置</span></span><br><span class="line">    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_0);</span><br><span class="line">    <span class="hljs-comment">// 配置模板位置</span></span><br><span class="line">    ClassLoader loader = MailApplication.class.getClassLoader();</span><br><span class="line">    configuration.setClassLoaderForTemplateLoading(loader, <span class="hljs-string">"templates"</span>);</span><br><span class="line">    <span class="hljs-comment">//加载模板</span></span><br><span class="line">    Template template = configuration.getTemplate(<span class="hljs-string">"mail.ftl"</span>);</span><br><span class="line">    User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    user.setNum(<span class="hljs-number">1</span>);</span><br><span class="line">    user.setSalary((<span class="hljs-keyword">double</span>) <span class="hljs-number">99999</span>);</span><br><span class="line">    StringWriter out = <span class="hljs-keyword">new</span> StringWriter();</span><br><span class="line">    <span class="hljs-comment">//模板渲染，渲染的结果将被保存到 out 中 ，将out 中的 html 字符串发送即可</span></span><br><span class="line">    template.process(user, out);</span><br><span class="line">    helper.setText(out.toString(),<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，虽然引入了 <code>Freemarker</code> 的自动化配置，但是我们在这里是直接 <code>new Configuration</code> 来重新配置 <code>Freemarker</code> 的，所以 Freemarker 默认的配置这里不生效，因此，在填写模板位置时，值为 <code>templates</code> 。</p><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-8.png" alt></p><h2 id="使用-Thymeleaf-作邮件模板"><a href="#使用-Thymeleaf-作邮件模板" class="headerlink" title="使用 Thymeleaf 作邮件模板"></a>使用 Thymeleaf 作邮件模板</h2><p>推荐在 Spring Boot 中使用 Thymeleaf 来构建邮件模板。因为 Thymeleaf 的自动化配置提供了一个 TemplateEngine，通过 TemplateEngine 可以方便的将 Thymeleaf 模板渲染为 HTML ，同时，Thymeleaf 的自动化配置在这里是继续有效的 。</p><p>首先，引入 Thymeleaf 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，创建 <code>Thymeleaf</code> 邮件模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;username&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;num&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;salary&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来发送邮件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendThymeleafMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    Context context = <span class="hljs-keyword">new</span> Context();</span><br><span class="line">    context.setVariable(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"num"</span>,<span class="hljs-string">"000001"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"salary"</span>, <span class="hljs-string">"99999"</span>);</span><br><span class="line">    String process = templateEngine.process(<span class="hljs-string">"mail.html"</span>, context);</span><br><span class="line">    helper.setText(process,<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://www.javaboy.org/images/boot2/43-8.png" alt></p><p>好了，这就是我们今天说的 5 种邮件发送姿势，不知道你掌握了没有呢？</p><p>本文案例已经上传到 GitHub：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a>。</p><p>有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十二)使用 Jib 部署 Spring Boot</title>
    <link href="http://www.javaboy.org/2019/1231/springboot-jib.html"/>
    <id>http://www.javaboy.org/2019/1231/springboot-jib.html</id>
    <published>2019-12-31T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.486Z</updated>
    
    <content type="html"><![CDATA[<p>之前松哥和大家分享过一篇将 Spring Boot 项目部署到远程 Docker 上的文章：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/7DrvNHM6MGc7lwz8JDULSQ" target="_blank" rel="noopener">一键部署 Spring Boot 到远程 Docker 容器</a></li></ul><p>但是这种部署有一个问题，就是一个小小的 helloworld 构建成镜像之后，竟然都有 660 MB+，这就有点过分了；而且这种方式步骤繁琐，很多人看了头大。</p><p>因此松哥今天想再和大家聊一聊另外一种方案 <strong>Jib</strong>，这是谷歌开源的一个容器化运行方案，使用它我们将 Spring Boot 进行容器化部署只要两步：</p><ul><li>第一步配置 Maven Plugin</li><li>第二步构建</li></ul><p>我们一起来看看。</p><h2 id="Jib"><a href="#Jib" class="headerlink" title="Jib"></a>Jib</h2><p>在之前那篇文章中，我们将 Spring Boot 项目进行容器化部署，要求开发人员要有一定的 Docker 技能作为支撑，然而在实际开发中，并非每个人都是 Docker 专家，或者说会用 Docker。</p><p>有鉴于此，Google 搞出来一个 Jib，使 Spring Boot 容器化部署变得更加简便，开发人员可以不需要任何 Docker 相关的技能，就能将 Spring Boot 项目构建成 Docker 中的镜像，而且还可以“顺便”将镜像 push 到 register 上，极大的简化了部署过程。</p><p>Jib 使用 Java 开发，使用也非常简单，可以作为 Maven 或者 Gradle 的插件直接集成到我们的项目中。它利用镜像分层和注册表缓存来实现快速、增量的构建。Jib 会自动读取项目的构建配置，代码组织到不同的层（依赖项、资源、类）中，然后它只会重新构建和推送发生变更的层。在项目进行快速迭代时，Jib 只将发生变更的层推送到 registers 来缩短构建时间。</p><p>好了，大致了解了 Jib 之后，接下来我们来看看 Jib 要怎么使用。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Jib 可以直接将构建好的镜像 push 到 registers 上，如果公司有自己的私有镜像站的话，可以直接推送到私有镜像站上，本文我就将构建好的镜像推送到官方的 Docker Hub 上，因此需要大家提前准备一个 Docker Hub 的账号，账号大家可以直接去 Docker Hub 上面注册（<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a>），大家要是对 Docker Hub 这些东西不了解，可以在公众号后台回复 docker，获取松哥自制的 Docker 教程。</p><h2 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h2><p>首先我们来创建一个 Spring Boot 工程，创建时只需要添加一个 Web 依赖即可：</p><p><img src="http://www.javaboy.org/images/boot2/42-1.png" alt></p><p>项目创建成功后，添加一个 HelloController 用来做测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello jib"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在 pom.xml 中添加上 Jib 的插件，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.cloud.tools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jib-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>openjdk:alpine<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>docker.io/wongsung/dockerjib<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">tags</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>v1<span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">tags</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">auth</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>wongsung<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>你的密码<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">auth</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于这段配置，我说如下几点：</p><ol><li>首先就是版本号的问题，我这里使用的是 <code>1.7.0</code> ，网上有的教程比较老，用的 0.x 的版本，老的版本在配置 Docker 认证的时候非常麻烦，所以版本这块建议大家使用当前最新版。</li><li>from 中的配置表示本镜像构建所基于的根镜像为 <code>openjdk:alpine</code></li><li>to 中的配置表示本镜像构建完成后，要发布到哪里去，如果是发布到私有镜像站，就写自己私有镜像站的地址，如果是发布到 Docker Hub 上，就参考我这里的写法 <code>docker.io/wongsung/dockerjib</code>，其中 wongsung 表示你在 Docker Hub 上注册的用户名，dockerjib 表示你镜像的名字，可以随意取。</li><li>tags 中配置的是自己镜像的版本。</li><li>auth 中配置你在 Docker Hub 上的用户名/密码。</li><li>executions 节点中的就是常规配置了，我就不再多说了。</li></ol><p>配置完成后，在命令行执行如下命令将当前下项目构建成一个 Docker 镜像并 push 到 Docker Hub：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile jib:build</span><br></pre></td></tr></table></figure><p>构建完成后，我们在 Docker Hub 上就能看到自己的镜像了：</p><p><img src="http://www.javaboy.org/images/boot2/42-2.png" alt></p><p>接下来，启动 Docker ，在 Docker 中执行如下命令拉取镜像下来并运行：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mydockerjib -p 8080:8080 docker.io/wongsung/dockerjib:v1</span><br></pre></td></tr></table></figure><p>启动成功后，我们在浏览器中就可以直接访问我们刚才的 Spring Boot 项目中的 hello 接口了：</p><p><img src="http://www.javaboy.org/images/boot2/42-3.png" alt></p><p>是不是很方便？比我第一次给大家介绍的方案要方便很多。</p><p><strong>注意</strong></p><p>这种方式是将项目构建成镜像后并 push 到 registers 上，这种构建方式不需要你本地安装 Docker，如果你需要在本地运行镜像，那当然需要 Docker，单纯的构建是不需要 Docker 环境的。</p><h2 id="本地构建"><a href="#本地构建" class="headerlink" title="本地构建"></a>本地构建</h2><p>如果你电脑本地刚好安装了 Docker ，有 Docker 环境，那么也可以将项目构建成本地 Docker 的镜像，</p><p>首先我们来查看一下本地镜像：</p><p><img src="http://www.javaboy.org/images/boot2/42-4.png" alt></p><p>可以看到只有 MySQL 镜像，然后我们执行如下命令构建本地镜像：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile jib:dockerBuild</span><br></pre></td></tr></table></figure><p>看到如下构建日志信息表示构建成功：</p><p><img src="http://www.javaboy.org/images/boot2/42-5.png" alt></p><p>构建完成后，我们再来看本地镜像：</p><p><img src="http://www.javaboy.org/images/boot2/42-6.png" alt></p><p>可以都看到，已经构建成功了，接下来启动命令和上面一样，我就不重复展示了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>容器的出现，让我们的 Java 程序比任何时候都接近“一次编写，到处运行”，Spring Boot 容器化部署也是越来越方便，后面有空松哥再和大家聊聊结合 jenkins 的用法，好了，本文的案例我已经上传到 GitHub：<a href="https://github.com/lenve/javaboy-code-samples，有问题欢迎留言讨论。" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples，有问题欢迎留言讨论。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前松哥和大家分享过一篇将 Spring Boot 项目部署到远程 Docker 上的文章：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot + Vue 视频教程喜迎大结局</title>
    <link href="http://www.javaboy.org/2019/1231/springboot-video.html"/>
    <id>http://www.javaboy.org/2019/1231/springboot-video.html</id>
    <published>2019-12-31T01:23:23.000Z</published>
    <updated>2020-01-10T01:55:23.147Z</updated>
    
    <content type="html"><![CDATA[<p>松哥的自己录制的 Spring Boot+微人事项目在经过几个月的加班加点后，终于迎来了大结局。</p><a id="more"></a><p>这套视频目前大概一共有 <strong>270 集，80 个小时</strong>左右，具体的大家可以参考下面这个目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line">├─第 0 章 准备工作</span><br><span class="line">│      01.开篇_1.mp4</span><br><span class="line">│      02.回顾 XML 配置 Spring.mp4</span><br><span class="line">│      03.Java配置SSM-1.mp4</span><br><span class="line">│      04.Java配置SSM-2.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 01 章 Spring Boot 入门</span><br><span class="line">│      01.SpringBoot介绍.mp4</span><br><span class="line">│      02.SpringBoot项目的三种创建方式.mp4</span><br><span class="line">│      03.SpringBoot启动类上的注解.mp4</span><br><span class="line">│      04.SpringBoot中parent的理解-1.mp4</span><br><span class="line">│      05.SpringBoot中parent的理解-2.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 02 章 Spring Boot 基础配置</span><br><span class="line">│      01.Banner配置.mp4</span><br><span class="line">│      02.容器相关配置.mp4</span><br><span class="line">│      03.Spring属性注入.mp4</span><br><span class="line">│      04.类型安全的属性注入.mp4</span><br><span class="line">│      05.YAML配置.mp4</span><br><span class="line">│      06.Profile.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 03 章 Spring Boot 整合视图层技术</span><br><span class="line">│      01.SpringBoot 整合视图层技术.mp4</span><br><span class="line">│      02.Spring Boot 整合 Freemarker.mp4</span><br><span class="line">│      03.Feemarker 常用指令.mp4</span><br><span class="line">│      04.整合 Thymeleaf.mp4</span><br><span class="line">│      05.整合 jsp.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 04 章 Spring Boot 整合 Web 开发</span><br><span class="line">│      01.Spring Boot 默认的 JSON 解析方案.mp4</span><br><span class="line">│      02.使用 Gson 处理 JSON.mp4</span><br><span class="line">│      03.Spring Boot 整合 Fastjson.mp4</span><br><span class="line">│      04.Spring Boot 默认的静态资源访问方案.mp4</span><br><span class="line">│      05.两种方式自定义静态资源位置.mp4</span><br><span class="line">│      06.Spring Boot 文件上传.mp4</span><br><span class="line">│      07.Ajax 实现文件上传.mp4</span><br><span class="line">│      08.多文件上传.mp4</span><br><span class="line">│      09.@ControllerAdvice 的三种用法.mp4</span><br><span class="line">│      10.@ControllerAdvice 处理全局异常_1.mp4</span><br><span class="line">│      11.@ControllerAdvice 预设全局数据.mp4</span><br><span class="line">│      12.@ControllerAdvice 请求参数预处理.mp4</span><br><span class="line">│      13.Spring Boot 自定义错误页.mp4</span><br><span class="line">│      14.Spring Boot 异常处理源码分析.mp4</span><br><span class="line">│      15.Spring Boot 自定义异常数据.mp4</span><br><span class="line">│      16.Spring Boot 自定义异常视图.mp4</span><br><span class="line">│      17.Spring Boot 通过 CORS 实现跨域.mp4</span><br><span class="line">│      18.Spring Boot 中加载 XML 配置.mp4</span><br><span class="line">│      19.Spring Boot 中注册拦截器.mp4</span><br><span class="line">│      20.CommandLineRunner 实现系统启动任务.mp4</span><br><span class="line">│      21.ApplicationRunner 实现系统启动任务.mp4</span><br><span class="line">│      22.Spring Boot 整合 Web 基础组件.mp4</span><br><span class="line">│      23.Spring Boot 路径映射.mp4</span><br><span class="line">│      24.Spring Boot 中使用类型转换器.mp4</span><br><span class="line">│      25.Spring Boot 整合 AOP.mp4</span><br><span class="line">│      26.Spring Boot 自定义欢迎页.mp4</span><br><span class="line">│      27.Spring Boot 自定义 favicon.mp4</span><br><span class="line">│      28.Spring Boot 除去自动化配置.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 05 章 Spring Boot 整合持久层技术</span><br><span class="line">│      01.Spring Boot 整合持久层技术.mp4</span><br><span class="line">│      02.Spring Boot 整合 JdbcTemplate.mp4</span><br><span class="line">│      03.Spring Boot 整合 JdbcTemplate 多数据源.mp4</span><br><span class="line">│      04.Spring Boot 整合 MyBatis.mp4</span><br><span class="line">│      05.Spring Boot 整合 MyBatis 多数据源.mp4</span><br><span class="line">│      06.Spring Data 和 Jpa 简介.mp4</span><br><span class="line">│      07.Spring Boot 整合 Spring Data Jpa.mp4</span><br><span class="line">│      08.Spring Data Jpa 关键字定义查询方法.mp4</span><br><span class="line">│      09.Spring Data Jpa 自定义查询 SQL.mp4</span><br><span class="line">│      10.Spring Data Jpa 自定义数据修改 SQL.mp4</span><br><span class="line">│      11.Spring Boot 整合 Jpa 多数据源.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 06 章 Spring Boot 整合 NoSQL</span><br><span class="line">│      01.Spring Boot 整合 NoSQL.mp4</span><br><span class="line">│      02.Spring Boot 整合 Redis.mp4</span><br><span class="line">│      03.为什么需要 session 共享.mp4</span><br><span class="line">│      04.Nginx 简介.mp4</span><br><span class="line">│      05.Spring Session 实现 Session 共享.mp4</span><br><span class="line">│      06.引入 Nginx 负载均衡.mp4</span><br><span class="line">│      07.MongoDB 安装.mp4</span><br><span class="line">│      08.Spring Boot 整合 MongoDB.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 07 章 构建 REST 服务</span><br><span class="line">│      01.RESTful 简介.mp4</span><br><span class="line">│      02.搭建 Jpa 环境.mp4</span><br><span class="line">│      03.Spring Boot 中 REST 默认提供的增删改查.mp4</span><br><span class="line">│      04.Spring Boot 中 REST 自定义查询方法.mp4</span><br><span class="line">│      05.REST 配置 CORS.mp4</span><br><span class="line">│      06.自定义 REST 配置.mp4</span><br><span class="line">│      07.MongoDB 实现 REST.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 08 章 开发者工具与单元测试</span><br><span class="line">│      01.Devtools 简介.mp4</span><br><span class="line">│      02.devtools 工作原理-.mp4</span><br><span class="line">│      03.自定义监控资源.mp4</span><br><span class="line">│      04.LiveReload 自动刷新页面.mp4</span><br><span class="line">│      05.禁用自动重启.mp4</span><br><span class="line">│      06.项目重启中的全局配置.mp4</span><br><span class="line">│      07.Spring Boot 单元测试介绍.mp4</span><br><span class="line">│      08.Service 测试.mp4</span><br><span class="line">│      09.Controller 测试.mp4</span><br><span class="line">│      10.JSON 测试.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 09 章 Spring Boot 缓存</span><br><span class="line">│      01.Spring Cache 介绍.mp4</span><br><span class="line">│      02.Spring Cache 整合 Redis.mp4</span><br><span class="line">│      03.Spring Cache 整合 Ehcache.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 10 章 Spring Boot 安全管理</span><br><span class="line">│      01.安全管理介绍.mp4</span><br><span class="line">│      02.Spring  Security 初体验.mp4</span><br><span class="line">│      03.手工配置用户名密码.mp4</span><br><span class="line">│      04.HttpSecurity 配置.mp4</span><br><span class="line">│      05.登录表单详细配置.mp4</span><br><span class="line">│      06.注销登录配置.mp4</span><br><span class="line">│      07.多个 HttpSecurity.mp4</span><br><span class="line">│      08.密码加密.mp4</span><br><span class="line">│      09.方法安全.mp4</span><br><span class="line">│      10.基于数据库的认证.mp4</span><br><span class="line">│      11.角色继承.mp4</span><br><span class="line">│      12.动态配置权限.mp4</span><br><span class="line">│      13.OAuth2 简介.mp4</span><br><span class="line">│      14.Spring Security 结合 OAuth2.mp4</span><br><span class="line">│      15.整合 Shiro 方式一.mp4</span><br><span class="line">│      16.整合 Shiro 方式二.mp4</span><br><span class="line">│      17.Spring Security 使用 JSON 登录.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 11 章 Spring Boot 整合 WebSocket</span><br><span class="line">│      01.WebSocket 介绍.mp4</span><br><span class="line">│      02.WebSocket 实现在线群聊.mp4</span><br><span class="line">│      03.WebSocket 实现在线单聊.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 12 章 消息服务</span><br><span class="line">│      01.消息服务.mp4</span><br><span class="line">│      02.ActiveMQ 安装.mp4</span><br><span class="line">│      03.Spring Boot 整合 ActiveMQ.mp4</span><br><span class="line">│      04.RabbitMQ 简介并安装.mp4</span><br><span class="line">│      05.Spring Boot 整合 RabbitMQ.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 13 章 企业开发</span><br><span class="line">│      01.邮件协议简介.mp4</span><br><span class="line">│      02.申请 QQ 邮箱授权码.mp4</span><br><span class="line">│      03.发送简单邮件.mp4</span><br><span class="line">│      04.发送带附件的邮件.mp4</span><br><span class="line">│      05.发送带图片资源的邮件.mp4</span><br><span class="line">│      06.Thymeleaf 做邮件模板.mp4</span><br><span class="line">│      07.Freemarker 做邮件模板.mp4</span><br><span class="line">│      08.Spring Boot 定时任务实现方案一(@Scheduled).mp4</span><br><span class="line">│      09.Spring Boot 定时任务实现方案二(Quartz).mp4</span><br><span class="line">│      10.Spring Boot 整合 Swagger2.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 14 章 应用监控</span><br><span class="line">│      01.应用端点.mp4</span><br><span class="line">│      02.Health 端点.mp4</span><br><span class="line">│      03.Info 端点.mp4</span><br><span class="line">│      04.监控信息可视化.mp4</span><br><span class="line">│      05.邮件报警.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 15 章 项目构建与部署</span><br><span class="line">│      01.jar.mp4</span><br><span class="line">│      02.war.mp4</span><br><span class="line">│      </span><br><span class="line">└─第 16 章 微人事项目实战</span><br><span class="line">        001.项目介绍.mp4</span><br><span class="line">        002.项目技术架构.mp4</span><br><span class="line">        003.Vue 学习规划.mp4</span><br><span class="line">        004.Vue 初体验.mp4</span><br><span class="line">        005.Vue 条件指令.mp4</span><br><span class="line">        006.Vue 循环指令.mp4</span><br><span class="line">        007.Vue 处理用户输入.mp4</span><br><span class="line">        008.Vue 处理用户输入.mp4</span><br><span class="line">        009.Vue 组件初体验.mp4</span><br><span class="line">        010.Vue 实例.mp4</span><br><span class="line">        011.Vue 模板语法.mp4</span><br><span class="line">        012.Vue 计算属性.mp4</span><br><span class="line">        013.Vue 侦听器.mp4</span><br><span class="line">        014.Vue Class 绑定.mp4</span><br><span class="line">        015.Vue Style 绑定.mp4</span><br><span class="line">        016.Vue 条件渲染.mp4</span><br><span class="line">        017.Vue 列表渲染.mp4</span><br><span class="line">        018.Vue 事件处理.mp4</span><br><span class="line">        019.Vue 表单输入绑定.mp4</span><br><span class="line">        020.Vue 组件基础.mp4</span><br><span class="line">        021.Vue 总结.mp4</span><br><span class="line">        022.Spa 单页面应用介绍.mp4</span><br><span class="line">        023.node 和 npm.mp4</span><br><span class="line">        024.创建一个单页面应用.mp4</span><br><span class="line">        025.Vue 工程目录介绍.mp4</span><br><span class="line">        026.Vue 单页面项目运行.mp4</span><br><span class="line">        027.Vue 工程代码解析.mp4</span><br><span class="line">        028.vue-cli3 构建 Vue 项目.mp4</span><br><span class="line">        029.vue-cli3 项目结构介绍.mp4</span><br><span class="line">        030.微人事登录页面制作.mp4</span><br><span class="line">        031.处理前端登录事件.mp4</span><br><span class="line">        032.服务端环境搭建.mp4</span><br><span class="line">        033.服务端登录接口制作(一).mp4</span><br><span class="line">        034.服务端登录接口制作(二).mp4</span><br><span class="line">        035.前后端接口对接.mp4</span><br><span class="line">        036.登录页面跳转.mp4</span><br><span class="line">        037.前端请求方法封装.mp4</span><br><span class="line">        038.Home 页 title 制作.mp4</span><br><span class="line">        039.左边导航菜单制作.mp4</span><br><span class="line">        040.菜单项接口介绍.mp4</span><br><span class="line">        041.服务端菜单接口设计.mp4</span><br><span class="line">        042.Vuex 介绍与安装.mp4</span><br><span class="line">        043.Vuex 配置.mp4</span><br><span class="line">        044.菜单请求工具类封装.mp4</span><br><span class="line">        045.前端页面添加并完善菜单请求.mp4</span><br><span class="line">        046.左边导航菜单加载.mp4</span><br><span class="line">        047.页面加载问题解决.mp4</span><br><span class="line">        048.微人事首页完善.mp4</span><br><span class="line">        049.前后端分离权限管理思路探讨.mp4</span><br><span class="line">        050.后端接口权限设计.mp4</span><br><span class="line">        051.权限问题解决.mp4</span><br><span class="line">        052.权限管理继续完善.mp4</span><br><span class="line">        053.基础信息设置.mp4</span><br><span class="line">        054.职位管理前端页面设计.mp4</span><br><span class="line">        055.职位管理后端接口设计.mp4</span><br><span class="line">        056.职位管理前后端接口对接.mp4</span><br><span class="line">        057.职位管理前后端对接问题解决.mp4</span><br><span class="line">        058.职位修改操作.mp4</span><br><span class="line">        059.职位批量删除实现.mp4</span><br><span class="line">        060.职称管理前端页面设计.mp4</span><br><span class="line">        061.职称管理后端接口设计.mp4</span><br><span class="line">        062.职称管理前后端接口对接.mp4</span><br><span class="line">        063.职称批量删除实现.mp4</span><br><span class="line">        064.解决职位管理中的一个小问题.mp4</span><br><span class="line">        065.权限组前端页面制作.mp4</span><br><span class="line">        066.权限组用户角色前后端接口对接.mp4</span><br><span class="line">        067.权限组菜单树展示.mp4</span><br><span class="line">        068.菜单角色关系修改.mp4</span><br><span class="line">        069.权限组角色添加.mp4</span><br><span class="line">        070.权限组角色删除.mp4</span><br><span class="line">        071.[补充]登录问题完善.mp4</span><br><span class="line">        072.部门管理数据展示和搜索.mp4</span><br><span class="line">        073.部门树展示添加与删除.mp4</span><br><span class="line">        074.部门树的动态修改[添加].mp4</span><br><span class="line">        075.部门树的动态修改[删除].mp4</span><br><span class="line">        076.操作员管理接口设计.mp4</span><br><span class="line">        077.操作员管理页面展示.mp4</span><br><span class="line">        078.用户状态更新操作.mp4</span><br><span class="line">        079.操作员角色更新.mp4</span><br><span class="line">        080.操作员搜索.mp4</span><br><span class="line">        081.操作员删除.mp4</span><br><span class="line">        082.[补充]增加数据加载进度条.mp4</span><br><span class="line">        083.员工管理后端接口设计.mp4</span><br><span class="line">        084.员工管理工具栏展示.mp4</span><br><span class="line">        085.员工管理员工数据展示.mp4</span><br><span class="line">        086.员工管理员工数据分页.mp4</span><br><span class="line">        087.员工管理之员工搜索.mp4</span><br><span class="line">        088.员工添加接口设计.mp4</span><br><span class="line">        089.员工添加页面绘制.mp4</span><br><span class="line">        090.员工添加页面下拉框数据加载.mp4</span><br><span class="line">        091.员工添加页面工号加载.mp4</span><br><span class="line">        092.员工添加页面部门列表展示.mp4</span><br><span class="line">        093.员工添加.mp4</span><br><span class="line">        094.员工添加数据校验.mp4</span><br><span class="line">        095.[问题处理]部门管理问题处理.mp4</span><br><span class="line">        096.员工删除.mp4</span><br><span class="line">        097.员工信息更新.mp4</span><br><span class="line">        098.[问题处理]自动计算合同期限问题.mp4</span><br><span class="line">        099.[问题处理]权限组取消角色的所有权限.mp4</span><br><span class="line">        100.员工数据导出(Excel 导出).mp4</span><br><span class="line">        101.员工数据导入(Excel 上传).mp4</span><br><span class="line">        102.员工数据导入(Excel 解析).mp4</span><br><span class="line">        103.员工数据导入(插入数据库).mp4</span><br><span class="line">        104.员工高级搜索页面设计.mp4</span><br><span class="line">        105.员工高级搜索页面动画.mp4</span><br><span class="line">        106.禁用普通搜索.mp4</span><br><span class="line">        107.员工高级搜索功能.mp4</span><br><span class="line">        108.项目模块化改造.mp4</span><br><span class="line">        109.准备 RabbitMQ 消息中间件.mp4</span><br><span class="line">        110.搭建邮件服务.mp4</span><br><span class="line">        111.自动发送员工入职欢迎邮件.mp4</span><br><span class="line">        112.[号外]开发环境的变化.mp4</span><br><span class="line">        113.工资账套服务端接口设计.mp4</span><br><span class="line">        114.工资账套前端页面设计.mp4</span><br><span class="line">        115.添加工资账套页面设计.mp4</span><br><span class="line">        116.工资账套添加页面设计.mp4</span><br><span class="line">        117.工资账套添加前后端接口对接.mp4</span><br><span class="line">        118.工资账套删除.mp4</span><br><span class="line">        119.工资账套编辑与刷新.mp4</span><br><span class="line">        120.员工账套数据展示.mp4</span><br><span class="line">        121.员工工资账套调整页面设计.mp4</span><br><span class="line">        122.员工工资账套更新.mp4</span><br><span class="line">        123.员工工资账套设置分页.mp4</span><br><span class="line">        124.修改工资账套问题解决.mp4</span><br><span class="line">        125.聊天页面方案介绍.mp4</span><br><span class="line">        126.项目首页增加聊天入口.mp4</span><br><span class="line">        127.聊天页面绘制.mp4</span><br><span class="line">        128.调整聊天页面个人信息.mp4</span><br><span class="line">        129.用户列表展示.mp4</span><br><span class="line">        130.服务端消息处理配置.mp4</span><br><span class="line">        131.前端的聊天配置.mp4</span><br><span class="line">        132.消息首发测试.mp4</span><br><span class="line">        133.用户列表优化.mp4</span><br><span class="line">        134.消息发送处理.mp4</span><br><span class="line">        135.消息接收处理.mp4</span><br><span class="line">        136.聊天数据展示.mp4</span><br><span class="line">        137.聊天消息自动刷新.mp4</span><br><span class="line">        138.聊天完善.mp4</span><br><span class="line">        139.聊天消息提示.mp4</span><br><span class="line">        140.新消息提示红点.mp4</span><br><span class="line">        141.聊天消息动态提示.mp4</span><br></pre></td></tr></table></figure><p>这套视频的前 15 章主要是讲了 Spring Boot 的基本用法，第 16 章主要是讲微人事项目，微人事项目是从零开始手把手带领大家来做的，这个手把手也包括前端 Vue，视频的具体内容，可以参考上面的目录。</p><p>Spring Boot 录完之后，接下来就要开始更新 Spring Cloud 了，松哥最近也是在积极准备中，估计元旦之后就可以开始更新 Spring Cloud 了。</p><p><strong>按照我们之前的约定，每有一套课程完结的时候，就会调整一下价格，元旦临近，我们就在元旦之后再调整。也就是 12 月 31 和 1 月 1 号，依然是 199，从 1 月 2 号开始，199 元（老实说 199 也不贵，这么多视频，这么多内容，在各个视频平台对比下就知道了）。</strong></p><p>关于视频的评价，松哥之前秀过好多次了，这次就再秀一把，有不少小伙伴都是朋友推荐来的，相比于赚钱，小伙伴们的认可更让我开心：</p><p><img src="http://www.javaboy.org/images/other/103-1.png" alt><br><img src="http://www.javaboy.org/images/other/103-2.jpg" alt><br><img src="http://www.javaboy.org/images/other/103-3.jpg" alt><br><img src="http://www.javaboy.org/images/other/103-4.jpg" alt></p><p>另外你可能无法想象，在购买人群中，竟然还有西交大的老师：</p><p><img src="http://www.javaboy.org/images/other/103-6.jpg" alt></p><p>还有这是上次松哥推视频的时候小伙伴们的评价，可以看到看了视频的小伙伴都是非常认可松哥的视频教程的：</p><p><img src="http://www.javaboy.org/images/other/103-5.png" alt></p><p>好了，我就不炫耀了。下面我列举了小伙伴们关于这套视频常见的一些问题：</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，需要自己下载后一机一码授权播放。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>松哥有在某平台发布视频课程（很短，讲了几个知识点，只有两三个小时），因为课程未上线，暂时不方便透露。不过可以告诉大家的是，我在该平台发布的课程，平台抽 6 成，我拿 4 成，也就是说，这个 199 的课程，如果放到平台上销售，至少卖 400 块钱；另一方面，这也不仅仅是钱的事，即使可以放在平台上，我也不会拿去在平台上销售的。</p><p><strong>Q3：以后录的视频都可以看吗？</strong></p><p>这次松哥一共计划出四套视频课程，Spring Boot、微人事、Spring Cloud 以及 Redis，其中前两个目前已经录完了，Spring Cloud 将从 1 月份开始更新，Spring Cloud 录完之后，录 Redis，也就是 199 一共可以看这四套视频。</p><p><strong>Q4：可以砍价吗？</strong></p><p>不可以。首先因为 199 就不贵，即使不算后面的 Spring Cloud 和 Redis，单纯就现在的 Spring Boot+微人事，<strong>270 集，80 个小时</strong>，199 就不贵，更何况未来还有 Spring Cloud 和 Redis。上次有个小伙伴，加了我微信后，上来就问 60 卖不卖，松哥这暴脾气，二话没说就拉黑了。我是兼职录的视频，起早贪黑几个月录了这些视频，在他眼里就值 60 块钱，那就是我的技术在他眼里就值这点钱，我觉得这是对一个程序员最大的侮辱，没法忍。</p><p><strong>Q5：星球是怎么回事？</strong></p><p>星球主要是用来更新视频下载地址的地方，大家在这套视频教程时遇到问题时，都可以在星球上提问。</p><p><strong>Q6：视频会搞活动吗？</strong></p><p>自从我开始录视频以来，从来没有过促销活动，以前没有，以后也不会有。</p><p><strong>Q7：付费视频和免费视频有什么区别？</strong></p><p>免费视频是我在网上搜集别人录制的视频，大家在公众号后台回复 <code>2TB</code> 可以获取，付费视频是我自己录制的，录完之后都有二次剪辑，去噪，花费了很大功夫，因此是付费的。</p><p><strong>Q8：看视频有问题可以问吗？</strong></p><p>参考 Q6。</p><p><strong>Q9：这套视频适合哪些人看？</strong></p><p>学习这套视频，后端需要有 SSM 基础，前端需要有 js 基础（可以不懂 Vue，第十六章视频会讲）。要是不懂 SSM，可以先看松哥之前手敲 5 万余字的 SSM 教程。</p><p><strong>Q10：可以只买其中一套吗？</strong></p><p>可以，但是价格不变。因为购买单独的一部分，我要给你单独加密，单独上传，单独设置课程，单独生成授权码，这一套流程下来，费时费力，所以价格不变。</p><p>好了，加松哥微信，发红包 199，和 1000+ 小伙伴一起撸 Spring Boot + Vue 以及微人事项目吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥的自己录制的 Spring Boot+微人事项目在经过几个月的加班加点后，终于迎来了大结局。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十一)部署 Spring Boot 到远程 Docker 容器</title>
    <link href="http://www.javaboy.org/2019/1230/springboot-docker.html"/>
    <id>http://www.javaboy.org/2019/1230/springboot-docker.html</id>
    <published>2019-12-30T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.373Z</updated>
    
    <content type="html"><![CDATA[<p>不知道各位小伙伴在生产环境都是怎么部署 Spring Boot 的，打成 jar 直接一键运行？打成 war 扔到 Tomcat 容器中运行？不过据松哥了解，容器化部署应该是目前的主流方案。</p><a id="more"></a><p>不同于传统的单体应用，微服务由于服务数量众多，在部署的时候出问题的可能性更大，这个时候，结合 Docker 来部署，就可以很好的解决这个问题，这也是目前使用较多的方案之一。</p><p>将 Spring Boot 项目打包到 Docker 容器中部署，有很多不同的方法，今天松哥主要来和大家聊一聊如何将 Spring Boot 项目一键打包到远程 Docker 容器，然后通过运行一个镜像的方式来启动一个 Spring Boot 项目。</p><p>至于其他的 Spring Boot 结合 Docker 的用法，大家不要着急，后续的文章，松哥会和大家慢慢的一一道来。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><h3 id="1-1-准备-Docker"><a href="#1-1-准备-Docker" class="headerlink" title="1.1 准备 Docker"></a>1.1 准备 Docker</h3><p>我这里以 CentOS7 为例来给大家演示。</p><p>首先需要在 CentOS7 上安装好 Docker，这个安装方式网上很多，我就不多说了，我自己去年写过一个 Docker 入门教程，大家可以在公众号后台回复 <code>Docker</code> 获取教程下载地址。</p><p>Docker 安装成功之后，我们首先需要修改 Docker 配置，开启允许远程访问 Docker 的功能，开启方式很简单，修改 <code>/usr/lib/systemd/system/docker.service</code> 文件，加入如下内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://www.javaboy.org/images/boot2/41-1.png" alt></p><p>配置完成后，保存退出，然后重启 Docker：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload    </span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>Docker 重启成功之后，Docker 的准备工作就算是 OK 了。</p><h3 id="1-2-准备-IDEA"><a href="#1-2-准备-IDEA" class="headerlink" title="1.2 准备 IDEA"></a>1.2 准备 IDEA</h3><p>IDEA 上的准备工作，主要是安装一个 Docker 插件，点击 <code>File-&gt;Settings-&gt;Plugins-&gt;Browse Repositories</code> 如下：</p><p><img src="http://www.javaboy.org/images/boot2/41-2.png" alt></p><p>点击右边绿色的 Install 按钮，完成安装，安装完成之后需要重启一下 IDEA。</p><p>IDEA 重启成功之后，我们依次打开 <code>File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Docker</code> ，然后配置一下 Docker 的远程连接地址：</p><p><img src="http://www.javaboy.org/images/boot2/41-3.png" alt></p><p>配置一下 Docker 的地址，配置完成后，可以看到下面有一个 Connection successful 提示，这个表示 Docker 已经连接上了。</p><p>如此之后，我们的准备工作就算是 OK 了。</p><h2 id="2-准备项目"><a href="#2-准备项目" class="headerlink" title="2.准备项目"></a>2.准备项目</h2><p>接下来我们来创建一个简单的 Spring Boot 项目（只需要引入 <code>spring-boot-starter-web</code> 依赖即可），项目创建成功之后，我们再创建一个普通的 <code>HelloDockerController</code>，用来做测试，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloDockerController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello docker!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很简单的接口，无需多说。</p><h2 id="3-配置-Dockerfile"><a href="#3-配置-Dockerfile" class="headerlink" title="3.配置 Dockerfile"></a>3.配置 Dockerfile</h2><p>接下来，在项目的根目录下，我创建一个 Dockerfile ，作为我镜像的构建文件，具体位置如下图：</p><p><img src="http://www.javaboy.org/images/boot2/41-4.png" alt></p><p>文件内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM hub.c.163.com/library/java:latest</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD target/docker-<span class="hljs-number">0.0</span>.1-SNAPSHOT.jar app.jar</span><br><span class="line">ENTRYPOINT [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/app.jar"</span>]</span><br></pre></td></tr></table></figure><p>这里只有简单的四行，我说一下：</p><ol><li>Spring Boot 项目的运行依赖 Java 环境，所以我自己的镜像基于 Java 镜像来构建。</li><li>考虑到 Docker 官方镜像下载较慢，我这里使用了网易提供的 Docker 镜像。</li><li>由于 Spring Boot 运行时需要 tmp 目录，这里数据卷配置一个 /tmp 目录出来。</li><li>将本地 target 目录中打包好的 .jar 文件复制一份新的 到 /app.jar。</li><li>最后就是配置一下启动命令，由于我打包的 jar 已经成为 app.jar 了，所以启动命令也是启动 app.jar。</li></ol><p>这是我们配置的一个简单的 Dockerfile。</p><h2 id="4-配置-Maven-插件"><a href="#4-配置-Maven-插件" class="headerlink" title="4.配置 Maven 插件"></a>4.配置 Maven 插件</h2><p>接下来在 pom.xml 文件中，添加如下插件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dockerHost</span>&gt;</span>http://192.168.66.131:2375<span class="hljs-tag">&lt;/<span class="hljs-name">dockerHost</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>javaboy/$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">imageTags</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">imageTag</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageTag</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">imageTags</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">forceTags</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">forceTags</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个插件的配置不难理解：</p><ol><li>首先在 execution 节点中配置当执行 mvn package 的时候，顺便也执行一下 docker:build</li><li>然后在 configuration 中分别配置 Docker 的主机地址，镜像的名称，镜像的 tags，其中 dockerDirectory 表示指定 Dockerfile 的位置。</li><li>最后 resource 节点中再配置一下 jar 的位置和名称即可。</li></ol><p>OK，做完这些我们就算大功告成了。</p><h2 id="5-打包运行"><a href="#5-打包运行" class="headerlink" title="5.打包运行"></a>5.打包运行</h2><p>接下来对项目进行打包，打包完成后，项目会自动构建成一个镜像，并且上传到 Docker 容器中，打包方式如下：</p><p><img src="http://www.javaboy.org/images/boot2/41-5.png" alt></p><p>打包过程会稍微有一点旧，因为还包含了镜像的构建，特别是第一次打包，需要下载基础镜像，会更慢一些。</p><p>部分打包日志如下（项目构建过程）:</p><p><img src="http://www.javaboy.org/images/boot2/41-6.png" alt></p><p>项目打包成功之后，我们就可以在 Docker 容器中看到我们刚刚打包成的镜像了，如下：</p><p><img src="http://www.javaboy.org/images/boot2/41-7.png" alt></p><h3 id="5-1-运行方式一"><a href="#5-1-运行方式一" class="headerlink" title="5.1 运行方式一"></a>5.1 运行方式一</h3><p>此时，我们可以直接在 Linux 上像创建普通容器一样创建这个镜像的容器，然后启动，执行如下命令即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name javaboy -p 8080:8080 javaboy/docker:0.0.1</span><br></pre></td></tr></table></figure><p>启动成功之后，我们就可以访问容器中的接口了。</p><p>但是这种操作显然还是有点麻烦，结合我们一开始安装的 Docker 插件，这个运行步骤还可以做进一步的简化。</p><h3 id="5-2-运行方式二"><a href="#5-2-运行方式二" class="headerlink" title="5.2 运行方式二"></a>5.2 运行方式二</h3><p>大家注意，此时我们的 IDEA 中多了一个选项，就是 docker，如下：</p><p><img src="http://www.javaboy.org/images/boot2/41-8.png" alt></p><p>点击左边的绿色启动按钮，连接上 Docker 容器，连接成功之后，我们就可以看到目前 Docker 中的所有容器和镜像了，当然也包括我们刚刚创建的 Docker 镜像，如下：</p><p><img src="http://www.javaboy.org/images/boot2/41-9.png" alt></p><p>此时，我们选中这个镜像，右键单击，即可基于此镜像创建出一个容器，如下图：</p><p><img src="http://www.javaboy.org/images/boot2/41-10.png" alt></p><p>我们选择 Create container，然后填入容器的一些必要信息，配置一下容器名称，镜像 ID 会自动填上，暴露的端口使用 Specify 即可，然后写上端口的映射关系：</p><p><img src="http://www.javaboy.org/images/boot2/41-11.png" alt></p><p>配置完成后，点击下方的 <code>run</code> 按钮，就可以开始运行了。运行日志如下：</p><p><img src="http://www.javaboy.org/images/boot2/41-12.png" alt></p><p>注意，这个日志是在 Docker 的那个窗口里打印出来的。</p><p>项目运行成功之后，在浏览器输入远程服务器的地址，就可以访问了：</p><p><img src="http://www.javaboy.org/images/boot2/41-13.png" alt></p><p>如此之后，我们的 Spring Boot 项目就算顺利发布到远程 Docker 容器中了。</p><p>好玩吗？试试！</p><p>本文案例我已经上传到 GitHub，小伙伴们可以参考：<a href="https://github.com/lenve/javaboy-code-samples​" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples​</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道各位小伙伴在生产环境都是怎么部署 Spring Boot 的，打成 jar 直接一键运行？打成 war 扔到 Tomcat 容器中运行？不过据松哥了解，容器化部署应该是目前的主流方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 教程姗姗来迟，松哥手码的 SSM 教程总算齐活了，小伙伴们可以下载啦</title>
    <link href="http://www.javaboy.org/2019/1230/mybatis-guide.html"/>
    <id>http://www.javaboy.org/2019/1230/mybatis-guide.html</id>
    <published>2019-12-30T01:23:06.000Z</published>
    <updated>2020-01-10T01:51:17.545Z</updated>
    
    <content type="html"><![CDATA[<p>上周末去了趟南京，昨晚到家都十二点多了，今天一大早起来整理 MyBatis 教程，现在总算搞好了，至此，松哥自制的 SSM 教程现在总算齐活了。</p><a id="more"></a><p>这套 Maven+SSM 教程总页数在 230 页左右，总字数在 5 万字左右，带领刚入行的小伙伴巩固下知识点，或者没接触过 SSM 的小伙伴入个门绝对是够用了。</p><p>其中，Maven、Spring、SpringMVC 的教程之前都已经发布过了：</p><ul><li><a href="https://mp.weixin.qq.com/s/CyMXvY-IzY-69Q_uYxxXMA" target="_blank" rel="noopener">Maven 教程</a></li><li><a href="https://mp.weixin.qq.com/s/4N0qWTHM2CuUFRoBIBUHwQ" target="_blank" rel="noopener">Spring 教程</a></li><li><a href="https://mp.weixin.qq.com/s/4v7VPjSjf5DW86I3ecptFw" target="_blank" rel="noopener">SpringMVC 教程</a></li></ul><p>今天要发布的这份 MyBatis 教程，松哥和大家详细聊了 MyBatis 一些常见用法，如 基本配置、一对一查询、一对多查询、Mapper 配置、逆向工程等，不过时间仓促，还有一些更加高级的玩法松哥在未来也会慢慢完善。</p><p>和前面的教程一样，这个 MyBatis 教程松哥也提供了线上版和离线版，线上版地址：</p><ul><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li></ul><p><img src="http://www.javaboy.org/images/other/101-1.png" alt></p><p>离线版是一个 pdf 文档，小伙伴们在松哥公众号后台回复 mybatis 可以获取离线版下载地址。</p><p><img src="http://www.javaboy.org/images/other/101-2.png" alt><br><img src="http://www.javaboy.org/images/other/101-3.png" alt></p><p><strong>注意</strong></p><blockquote><p>由于这个教程里涉及到的代码 Demo 比较多，我看了一下生成的 pdf，代码的排版不是很好看，换行有一点点乱，不方便阅读，因此建议大家通过在线版学习，也就是松哥上面给出来的那个网站。在线版网速可能有一点点慢，松哥后期也会对这个问题进行处理，请小伙伴们留意星球公告哦。</p></blockquote><p>现在，松哥自己的站点，已经做好的有：</p><ul><li><a href="http://www.javaboy.org">http://www.javaboy.org</a></li><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li><li><a href="http://maven.javaboy.org" target="_blank" rel="noopener">http://maven.javaboy.org</a></li><li><a href="http://spring.javaboy.org" target="_blank" rel="noopener">http://spring.javaboy.org</a></li><li><a href="http://springmvc.javaboy.org" target="_blank" rel="noopener">http://springmvc.javaboy.org</a></li><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li></ul><p>未来还计划出：</p><ul><li><a href="http://shiro.javaboy.org" target="_blank" rel="noopener">http://shiro.javaboy.org</a></li><li><a href="http://mongodb.javaboy.org" target="_blank" rel="noopener">http://mongodb.javaboy.org</a></li><li><a href="http://redis.javaboy.org" target="_blank" rel="noopener">http://redis.javaboy.org</a></li><li><a href="http://elasticsearch.javaboy.org" target="_blank" rel="noopener">http://elasticsearch.javaboy.org</a></li><li>…</li></ul><p>小伙伴们敬请期待哦。</p><p>好了，MyBatis 撸起来吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周末去了趟南京，昨晚到家都十二点多了，今天一大早起来整理 MyBatis 教程，现在总算搞好了，至此，松哥自制的 SSM 教程现在总算齐活了。&lt;/p&gt;
    
    </summary>
    
      <category term="MyBatis" scheme="http://www.javaboy.org/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(四十)Spring Boot 可执行 jar 分析</title>
    <link href="http://www.javaboy.org/2019/1229/springboot-jar.html"/>
    <id>http://www.javaboy.org/2019/1229/springboot-jar.html</id>
    <published>2019-12-29T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.436Z</updated>
    
    <content type="html"><![CDATA[<p>前两天被人问到这样一个问题:</p><a id="more"></a><p>“松哥，为什么我的 Spring Boot 项目打包成的 jar ，被其他项目依赖之后，总是报找不到类的错误？”</p><p>大伙有这样的疑问，就是因为还没搞清楚可执行 jar 和普通 jar 到底有什么区别？今天松哥就和大家来聊一聊这个问题。</p><h2 id="多了一个插件"><a href="#多了一个插件" class="headerlink" title="多了一个插件"></a>多了一个插件</h2><p>Spring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 <code>java -jar xxx.jar</code> 命令执行，普通的 <code>jar</code> 主要是被其他应用依赖，<code>Spring Boot</code> 打成的 <code>jar</code> 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。</p><p>有的小伙伴可能就有疑问了，既然同样是执行 <code>mvn package</code> 命令进行项目打包，为什么 Spring Boot 项目就打成了可执行 jar ，而普通项目则打包成了不可执行 jar 呢？</p><p>这我们就不得不提 Spring Boot 项目中一个默认的插件配置 <code>spring-boot-maven-plugin</code> ，这个打包插件存在 5 个方面的功能，从插件命令就可以看出：</p><p><img src="http://www.javaboy.org/images/boot2/40-1.png" alt></p><p>五个功能分别是：</p><ul><li>build-info：生成项目的构建信息文件 build-info.properties</li><li>repackage：这个是默认 goal，在 <code>mvn package</code> 执行之后，这个命令再次打包生成可执行的 jar，同时将 <code>mvn package</code> 生成的 jar 重命名为 <code>*.origin</code></li><li>run：这个可以用来运行 Spring Boot 应用</li><li>start：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li><li>stop：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li></ul><p>这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>repackage 功能的 作用，就是在打包的时候，多做一点额外的事情：</p><ol><li>首先 <code>mvn package</code> 命令 对项目进行打包，打成一个 <code>jar</code>，这个 <code>jar</code> 就是一个普通的 <code>jar</code>，可以被其他项目依赖，但是不可以被执行</li><li><code>repackage</code> 命令，对第一步 打包成的 <code>jar</code> 进行再次打包，将之打成一个 可执行 <code>jar</code> ，通过将第一步打成的 <code>jar</code> 重命名为 <code>*.original</code> 文件</li></ol><p>举个例子：</p><p>对任意一个 Spring Boot 项目进行打包，可以执行 <code>mvn package</code> 命令，也可以直接在 <code>IDEA</code> 中点击 <code>package</code> ，如下 ：</p><p><img src="http://www.javaboy.org/images/boot2/40-2.png" alt></p><p>打包成功之后， <code>target</code> 中的文件如下：</p><p><img src="http://www.javaboy.org/images/boot2/40-3.png" alt></p><p>这里有两个文件，第一个 <code>restful-0.0.1-SNAPSHOT.jar</code> 表示打包成的可执行 <code>jar</code> ，第二个 <code>restful-0.0.1-SNAPSHOT.jar.original</code> 则是在打包过程中 ，被重命名的 <code>jar</code>，这是一个不可执行 <code>jar</code>，但是可以被其他项目依赖的 <code>jar</code>。通过对这两个文件的解压，我们可以看出这两者之间的差异。</p><h2 id="两种-jar-的比较"><a href="#两种-jar-的比较" class="headerlink" title="两种 jar 的比较"></a>两种 jar 的比较</h2><p>可执行 <code>jar</code> 解压之后，目录如下：</p><p><img src="http://www.javaboy.org/images/boot2/40-4.png" alt></p><p>可以看到，可执行 jar 中，我们自己的代码是存在 于 <code>BOOT-INF/classes/</code> 目录下，另外，还有一个 <code>META-INF</code> 的目录，该目录下有一个 <code>MANIFEST.MF</code> 文件，打开该文件，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: restful</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Start-Class: org.javaboy.restful.RestfulApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Spring-Boot-Version: 2.1.6.RELEASE</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure><p>可以看到，这里定义了一个 <code>Start-Class</code>，这就是可执行 <code>jar</code> 的入口类，<code>Spring-Boot-Classes</code> 表示我们自己代码编译后的位置，<code>Spring-Boot-Lib</code> 则表示项目依赖的 <code>jar</code> 的位置。</p><p>换句话说，如果自己要打一个可执行 <code>jar</code> 包的话，除了添加相关依赖之外，还需要配置 <code>META-INF/MANIFEST.MF</code> 文件。</p><p>这是可执行 jar 的结构，那么不可执行 jar 的结构呢？</p><p>我们首先将默认的后缀 <code>.original</code> 除去，然后给文件重命名，重命名完成，进行解压：</p><p><img src="http://www.javaboy.org/images/boot2/40-5.png" alt></p><p>解压后可以看到，不可执行 <code>jar</code> 根目录就相当于我们的 <code>classpath</code>，解压之后，直接就能看到我们的代码，它也有 <code>META-INF/MANIFEST.MF</code> 文件，但是文件中没有定义启动类等。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: restful</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>这个不可以执行 <code>jar</code> 也没有将项目的依赖打包进来。</p><p>从这里我们就可以看出，两个 <code>jar</code> ，虽然都是 <code>jar</code> 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。</p><h2 id="一次打包两个-jar"><a href="#一次打包两个-jar" class="headerlink" title="一次打包两个 jar"></a>一次打包两个 jar</h2><p>一般来说，Spring Boot 直接打包成可执行 <code>jar</code> 就可以了，不建议将 Spring Boot 作为普通的 <code>jar</code> 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 <code>Maven</code> 项目，然后在 Spring Boot 中引用这个 <code>Maven</code> 项目。</p><p>如果非要将 Spring Boot 打包成一个普通 <code>jar</code> 被其他项目依赖，技术上来说，也是可以的，给 <code>spring-boot-maven-plugin</code> 插件添加如下配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置的 <code>classifier</code> 表示可执行 <code>jar</code> 的名字，配置了这个之后，在插件执行 <code>repackage</code> 命令时，就不会给 <code>mvn package</code> 所打成的 <code>jar</code> 重命名了，所以，打包后的 jar 如下：</p><p><img src="http://www.javaboy.org/images/boot2/40-6.png" alt></p><p>第一个 jar 表示可以被其他项目依赖的 jar ，第二个 jar 则表示一个可执行 jar。</p><p>好了，关于 Spring Boot 中 jar 的问题，我们就说这么多，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天被人问到这样一个问题:&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(三十九)Spring Boot 热部署</title>
    <link href="http://www.javaboy.org/2019/1228/springboot-devtools.html"/>
    <id>http://www.javaboy.org/2019/1228/springboot-devtools.html</id>
    <published>2019-12-28T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾热部署"><a href="#回顾热部署" class="headerlink" title="回顾热部署"></a>回顾热部署</h1><p>Spring Boot 中的热部署相信大家都用过吧，只需要添加 <code>spring-boot-devtools</code> 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：</p><a id="more"></a><ul><li>base classloader</li><li>restart classloader</li></ul><p>其中 base classloader 用来加载那些不会变化的类，例如各种第三方依赖，而 restart classloader 则用来加载那些会发生变化的类，例如你自己写的代码。Spring Boot 中热部署的原理就是当代码发生变化时，base classloader 不变，而 restart classloader 则会被废弃，被另一个新的 restart classloader 代替。在整个过程中，因为只重新加载了变化的类，所以启动速度要被重启快。</p><p>但是有另外一个问题，就是静态资源文件！使用 devtools ，默认情况下当静态资源发生变化时，并不会触发项目重启。虽然我们可以通过配置解决这一问题，但是没有必要！因为静态资源文件发生变化后不需要编译，按理说保存后刷新下就可以访问到了。</p><p>那么如何才能实现静态资源变化后，不编译就能自动刷新呢？ LiveReload 可以帮助我们实现这一功能！</p><h1 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h1><p>devtools 中默认嵌入了 LiveReload 服务器，利用 LiveReload 可以实现静态文件的热部署，LiveReload 可以在资源发生变化时自动触发浏览器更新，LiveReload 支持 Chrome、Firefox 以及 Safari 。以 Chrome 为例，在 Chrome 应用商店搜索 LiveReload ，结果如下图：</p><p><img src="http://www.javaboy.org/images/boot2/39-1.png" alt></p><p>将第一个搜索结果添加到 Chrome 中，添加成功后，在 Chrome 右上角有一个 LiveReload 图标</p><p><img src="http://www.javaboy.org/images/boot2/39-2.png" alt></p><p>在浏览器中打开项目的页面，然后点击浏览器右上角的 LiveReload 按钮，打开 LiveReload 连接。</p><p><strong>注意：</strong></p><p>LiveReload 是和浏览器选项卡绑定在一起的，在哪个选项卡中打开了 LiveReload，就在哪个选项卡中访问页面，这样才有效果。</p><p>打开 LiveReload 之后，我们启动一个加了 devtools 依赖的 Spring Boot 项目：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时随便在 resources/static 目录下添加一个静态 html 页面，然后启动 Spring Boot 项目，在<strong>打开了 LiveReload 的选项卡中访问 html 页面</strong>。</p><p>访问成功后，我们再去手动修改 html 页面代码，修改成功后，回到浏览器，不用做任何操作，就会发现浏览器自动刷新了，页面已经更新了。</p><p>整个过程中，我的 Spring Boot 项目并没有重启。</p><p>如果开发者安装并且启动了 LiveReload 插件，同时也添加了 devtools 依赖，但是却并不想当静态页面发生变化时浏览器自动刷新，那么可以在 application.properties 中添加如下代码进行配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.livereload.enabled=false</span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>建议开发者使用 LiveReload 策略而不是项目重启策略来实现静态资源的动态加载，因为项目重启所耗费时间一般来说要超过使用LiveReload 所耗费的时间。</p><p>Firefox 也可以安装 LiveReload 插件，装好之后和 Chrome 用法基本一致，这里不再赘述。</p><p>如果小伙伴们的 Chrome 商店使用不便，可以在松哥公众号后台回复 livereload，松哥有下载好的离线安装包。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回顾热部署&quot;&gt;&lt;a href=&quot;#回顾热部署&quot; class=&quot;headerlink&quot; title=&quot;回顾热部署&quot;&gt;&lt;/a&gt;回顾热部署&lt;/h1&gt;&lt;p&gt;Spring Boot 中的热部署相信大家都用过吧，只需要添加 &lt;code&gt;spring-boot-devtools&lt;/code&gt; 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(三十八)Spring Security 非法请求直接返回 JSON</title>
    <link href="http://www.javaboy.org/2019/1227/springboot-security-json.html"/>
    <id>http://www.javaboy.org/2019/1227/springboot-security-json.html</id>
    <published>2019-12-27T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.373Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用：</p><a id="more"></a><ol><li><a href="https://mp.weixin.qq.com/s/88zkkf6WyS_Jtv74qOdr8Q" target="_blank" rel="noopener">手把手带你入门 Spring Security！</a></li><li><a href="https://mp.weixin.qq.com/s/B9t0EtOCiM3wiCbosByMrQ" target="_blank" rel="noopener">Spring Security 登录添加验证码</a></li><li><a href="https://mp.weixin.qq.com/s/QApGe7I94lAMiYy8qbLZ9A" target="_blank" rel="noopener">SpringSecurity 登录使用 JSON 格式数据</a></li><li><a href="https://mp.weixin.qq.com/s/-K8W06y_-hvJvIgNsk3V_A" target="_blank" rel="noopener">Spring Security 中的角色继承问题</a></li><li><a href="https://mp.weixin.qq.com/s/Ykzo5sWdfmKig810Gp8JRw" target="_blank" rel="noopener">Spring Security 中使用 JWT!</a></li><li><a href="https://mp.weixin.qq.com/s/1rVPzJGCtDZKvMoA4BYzIA" target="_blank" rel="noopener">Spring Security 结合 OAuth2</a></li></ol><p>不过，今天要和小伙伴们聊一聊 Spring Security 中的另外一个问题，那就是在 Spring Security 中未获认证的请求默认会重定向到登录页，但是在前后端分离的登录中，这个默认行为则显得非常不合适，今天我们主要来看看如何实现未获认证的请求直接返回 JSON ，而不是重定向到登录页面。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这里关于 Spring Security 的基本用法我就不再赘述了，如果小伙伴们不了解，可以参考上面的 6 篇文章。</p><p>大家知道，在自定义 Spring Security 配置的时候，有这样几个属性：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login"</span>)</span><br><span class="line">            <span class="hljs-comment">//其他配置</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个比较重要的属性：</p><ul><li>loginProcessingUrl：这个表示配置处理登录请求的接口地址，例如你是表单登录，那么 form 表单中 action 的值就是这里填的值。</li><li>loginPage：这个表示登录页的地址，例如当你访问一个需要登录后才能访问的资源时，系统就会自动给你通过重定向跳转到这个页面上来。</li></ul><p>这种配置在前后端不分的登录中是没有问题的，在前后端分离的登录中，这种配置就有问题了。我举个简单的例子，例如我想访问 <code>/hello</code> 接口，但是这个接口需要登录之后才能访问，我现在没有登录就直接去访问这个接口了，那么系统会给我返回 302，让我去登录页面，在前后端分离中，我的后端一般是没有登录页面的，就是一个提示 JSON，例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">"尚未登录，请登录!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整代码大家可以参考我的微人事项目。</p></blockquote><p>也就是说，当我没有登录直接去访问 <code>/hello</code> 这个接口的时候，我会看到上面这段 JSON 字符串。在前后端分离开发中，这个看起来没问题（后端不再做页面跳转，无论发生什么都是返回 JSON）。但是问题就出在这里，系统默认的跳转是一个重定向，就是说当你访问 <code>/hello</code> 的时候，服务端会给浏览器返回 302，同时响应头中有一个 Location 字段，它的值为 <code>http://localhost:8081/login</code> ，也就是告诉浏览器你去访问 <code>http://localhost:8081/login</code> 地址吧。浏览器收到指令之后，就会直接去访问 <code>http://localhost:8081/login</code> 地址，如果此时是开发环境并且请求还是 Ajax 请求，就会发生跨域。因为前后端分离开发中，前端我们一般在 NodeJS 上启动，然后前端的所有请求通过 NodeJS 做请求转发，现在服务端直接把请求地址告诉浏览器了，浏览器就会直接去访问 <code>http://localhost:8081/login</code> 了，而不会做请求转发了，因此就发生了跨域问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>很明显，上面的问题我们不能用跨域的思路来解决，虽然这种方式看起来也能解决问题，但不是最佳方案。</p><p>如果我们的 Spring Security 在用户未获认证的时候去请求一个需要认证后才能请求的数据，此时不给用户重定向，而是直接就返回一个 JSON，告诉用户这个请求需要认证之后才能发起，就不会有上面的事情了。</p><p>这里就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Performs the redirect (or forward) to the login form URL.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationException authException)</span> </span>&#123;</span><br><span class="line">String redirectUrl = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (useForward) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (forceHttps &amp;&amp; <span class="hljs-string">"http"</span>.equals(request.getScheme())) &#123;</span><br><span class="line">redirectUrl = buildHttpsRedirectUrlForRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (redirectUrl == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String loginForm = determineUrlToUseForThisRequest(request, response,</span><br><span class="line">authException);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Server side forward to: "</span> + loginForm);</span><br><span class="line">&#125;</span><br><span class="line">RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);</span><br><span class="line">&#125;</span><br><span class="line">redirectStrategy.sendRedirect(request, response, redirectUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p><p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login"</span>)</span><br><span class="line">            <span class="hljs-comment">//其他配置</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable().exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(<span class="hljs-keyword">new</span> AuthenticationEntryPoint() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                PrintWriter out = resp.getWriter();</span><br><span class="line">                RespBean respBean = RespBean.error(<span class="hljs-string">"访问失败!"</span>);</span><br><span class="line">                <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;</span><br><span class="line">                    respBean.setMsg(<span class="hljs-string">"请求失败，请联系管理员!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，一个小小的重定向问题和小伙伴们分享下，不知道大家有没有看懂呢？这也是我最近在重构微人事的时候遇到的问题。预计 12 月份，微人事的 Spring Boot 版本会升级到目前最新版，请小伙伴们留意哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot2 系列教程(三十七)Spring Security 整合 JWT</title>
    <link href="http://www.javaboy.org/2019/1226/springboot-security-jwt.html"/>
    <id>http://www.javaboy.org/2019/1226/springboot-security-jwt.html</id>
    <published>2019-12-26T01:25:25.000Z</published>
    <updated>2020-01-13T03:33:14.436Z</updated>
    
    <content type="html"><![CDATA[<p>在前后端分离的项目中，登录策略也有不少，不过 JWT 算是目前比较流行的一种解决方案了，本文就和大家来分享一下如何将 Spring Security 和 JWT 结合在一起使用，进而实现前后端分离时的登录解决方案。</p><a id="more"></a><h2 id="1-无状态登录"><a href="#1-无状态登录" class="headerlink" title="1 无状态登录"></a>1 无状态登录</h2><h3 id="1-1-什么是有状态？"><a href="#1-1-什么是有状态？" class="headerlink" title="1.1 什么是有状态？"></a>1.1 什么是有状态？</h3><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h3 id="1-2-什么是无状态"><a href="#1-2-什么是无状态" class="headerlink" title="1.2 什么是无状态"></a>1.2 什么是无状态</h3><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3 如何实现无状态"></a>1.3 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="1-4-JWT"><a href="#1-4-JWT" class="headerlink" title="1.4 JWT"></a>1.4 JWT</h3><h4 id="1-4-1-简介"><a href="#1-4-1-简介" class="headerlink" title="1.4.1 简介"></a>1.4.1 简介</h4><p>JWT，全称是 Json Web Token， 是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权：</p><p><img src="http://www.javaboy.org/images/boot2/37-1.png" alt></p><p>JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的 Java 实现是 GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p><h4 id="1-4-2-JWT数据格式"><a href="#1-4-2-JWT数据格式" class="headerlink" title="1.4.2 JWT数据格式"></a>1.4.2 JWT数据格式</h4><p>JWT 包含三部分数据：</p><ul><li><p>Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul></li></ul><p>我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据。</p><ul><li><p>Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></li></ul><p>这部分也会采用 Base64Url 编码，得到第二部分数据。</p><ul><li>Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成。用于验证整个数据完整和可靠性。</li></ul><p>生成的数据格式如下图：</p><p><img src="http://www.javaboy.org/images/boot2/37-2.png" alt></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h4 id="1-4-3-JWT-交互流程"><a href="#1-4-3-JWT-交互流程" class="headerlink" title="1.4.3 JWT 交互流程"></a>1.4.3 JWT 交互流程</h4><p>流程图：</p><p> <img src="http://www.javaboy.org/images/boot2/37-3.png" alt></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如 API）</li></ol><p>因为 JWT 签发的 token 中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了 RESTful 的无状态规范。</p><h3 id="1-5-JWT-存在的问题"><a href="#1-5-JWT-存在的问题" class="headerlink" title="1.5 JWT 存在的问题"></a>1.5 JWT 存在的问题</h3><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p><ol><li>续签问题，这是被很多人诟病的问题之一，传统的 cookie+session 的方案天然的支持续签，但是 jwt 由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入 redis，虽然可以解决问题，但是 jwt 也变得不伦不类了。</li><li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改 secret 来实现注销，服务端 secret 修改后，已经颁发的未过期的 token 就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li><li>密码重置，密码重置后，原本的 token 依然可以访问系统，这时候也需要强制修改 secret。</li><li>基于第 2 点和第 3 点，一般建议不同用户取不同 secret。</li></ol><h2 id="2-实战"><a href="#2-实战" class="headerlink" title="2 实战"></a>2 实战</h2><p>说了这么久，接下来我们就来看看这个东西到底要怎么用？</p><h3 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h3><p>首先我们来创建一个 Spring Boot 项目，创建时需要添加 Spring Security 依赖，创建完成后，添加 <code>jjwt</code> 依赖，完整的 pom.xml 文件如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在项目中创建一个简单的 User 对象实现 UserDetails 接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//省略getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我们的用户对象，先放着备用，再创建一个 HelloController，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello jwt !"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello admin !"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloController 很简单，这里有两个接口，设计是 <code>/hello</code> 接口可以被具有 user 角色的用户访问，而 <code>/admin</code> 接口则可以被具有 admin 角色的用户访问。</p><h3 id="2-2-JWT-过滤器配置"><a href="#2-2-JWT-过滤器配置" class="headerlink" title="2.2 JWT 过滤器配置"></a>2.2 JWT 过滤器配置</h3><p>接下来提供两个和 JWT 相关的过滤器配置：</p><ol><li>一个是用户登录的过滤器，在用户的登录的过滤器中校验用户是否登录成功，如果登录成功，则生成一个token返回给客户端，登录失败则给前端一个登录失败的提示。</li><li>第二个过滤器则是当其他请求发送来，校验token的过滤器，如果校验成功，就让请求继续执行。</li></ol><p>这两个过滤器，我们分别来看，先看第一个：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtLoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">JwtLoginFilter</span><span class="hljs-params">(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(defaultFilterProcessesUrl));</span><br><span class="line">        setAuthenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> ObjectMapper().readValue(req.getInputStream(), User.class);</span><br><span class="line">        <span class="hljs-keyword">return</span> getAuthenticationManager().authenticate(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, FilterChain chain, Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        Collection&lt;? extends GrantedAuthority&gt; authorities = authResult.getAuthorities();</span><br><span class="line">        StringBuffer as = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">            as.append(authority.getAuthority())</span><br><span class="line">                    .append(<span class="hljs-string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String jwt = Jwts.builder()</span><br><span class="line">                .claim(<span class="hljs-string">"authorities"</span>, as)<span class="hljs-comment">//配置用户角色</span></span><br><span class="line">                .setSubject(authResult.getName())</span><br><span class="line">                .setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512,<span class="hljs-string">"sang@123"</span>)</span><br><span class="line">                .compact();</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(jwt));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException failed)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="hljs-string">"登录失败!"</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个类，我说如下几点：</p><ol><li>自定义 JwtLoginFilter 继承自 AbstractAuthenticationProcessingFilter，并实现其中的三个默认方法。</li><li>attemptAuthentication 方法中，我们从登录参数中提取出用户名密码，然后调用 AuthenticationManager.authenticate() 方法去进行自动校验。</li><li>第二步如果校验成功，就会来到 successfulAuthentication 回调中，在 successfulAuthentication 方法中，将用户角色遍历然后用一个 <code>,</code> 连接起来，然后再利用 Jwts 去生成 token，按照代码的顺序，生成过程一共配置了四个参数，分别是用户角色、主题、过期时间以及加密算法和密钥，然后将生成的 token 写出到客户端。</li><li>第二步如果校验失败就会来到 unsuccessfulAuthentication 方法中，在这个方法中返回一个错误提示给客户端即可。</li></ol><p>再来看第二个 token 校验的过滤器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) servletRequest;</span><br><span class="line">        String jwtToken = req.getHeader(<span class="hljs-string">"authorization"</span>);</span><br><span class="line">        System.out.println(jwtToken);</span><br><span class="line">        Claims claims = Jwts.parser().setSigningKey(<span class="hljs-string">"sang@123"</span>).parseClaimsJws(jwtToken.replace(<span class="hljs-string">"Bearer"</span>,<span class="hljs-string">""</span>))</span><br><span class="line">                .getBody();</span><br><span class="line">        String username = claims.getSubject();<span class="hljs-comment">//获取当前登录用户名</span></span><br><span class="line">        List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(<span class="hljs-string">"authorities"</span>));</span><br><span class="line">        UsernamePasswordAuthenticationToken token = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, <span class="hljs-keyword">null</span>, authorities);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class="line">        filterChain.doFilter(req,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个过滤器，我说如下几点：</p><ol><li>首先从请求头中提取出 authorization 字段，这个字段对应的 value 就是用户的 token。</li><li>将提取出来的 token 字符串转换为一个 Claims 对象，再从 Claims 对象中提取出当前用户名和用户角色，创建一个 UsernamePasswordAuthenticationToken 放到当前的 Context 中，然后执行过滤链使请求继续执行下去。</li></ol><p>如此之后，两个和 JWT 相关的过滤器就算配置好了。</p><h3 id="2-3-Spring-Security-配置"><a href="#2-3-Spring-Security-配置" class="headerlink" title="2.3 Spring Security 配置"></a>2.3 Spring Security 配置</h3><p>接下来我们来配置 Spring Security,如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication().withUser(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">                .password(<span class="hljs-string">"456"</span>)</span><br><span class="line">                .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/hello"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="hljs-string">"/login"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .addFilterBefore(<span class="hljs-keyword">new</span> JwtLoginFilter(<span class="hljs-string">"/login"</span>,authenticationManager()),UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .addFilterBefore(<span class="hljs-keyword">new</span> JwtFilter(),UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>简单起见，这里我并未对密码进行加密，因此配置了 NoOpPasswordEncoder 的实例。</li><li>简单起见，这里并未连接数据库，我直接在内存中配置了两个用户，两个用户具备不同的角色。</li><li>配置路径规则时， <code>/hello</code> 接口必须要具备 user 角色才能访问， <code>/admin</code> 接口必须要具备 admin 角色才能访问，POST 请求并且是 <code>/login</code> 接口则可以直接通过，其他接口必须认证后才能访问。</li><li>最后配置上两个自定义的过滤器并且关闭掉 csrf 保护。</li></ol><h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><p>做完这些之后，我们的环境就算完全搭建起来了，接下来启动项目然后在 POSTMAN 中进行测试，如下：</p><p><img src="http://www.javaboy.org/images/boot2/37-4.png" alt></p><p>登录成功后返回的字符串就是经过 base64url 转码的 token，一共有三部分，通过一个 <code>.</code> 隔开，我们可以对第一个 <code>.</code> 之前的字符串进行解码，即 Header，如下：</p><p><img src="http://www.javaboy.org/images/boot2/37-5.png" alt></p><p>再对两个 <code>.</code> 之间的字符解码，即 payload：</p><p><img src="http://www.javaboy.org/images/boot2/37-6.png" alt></p><p>可以看到，我们设置信息，由于 base64 并不是加密方案，只是一种编码方案，因此，不建议将敏感的用户信息放到 token 中。</p><p>接下来再去访问 <code>/hello</code> 接口，注意认证方式选择 Bearer Token，Token 值为刚刚获取到的值，如下：</p><p><img src="http://www.javaboy.org/images/boot2/37-7.png" alt></p><p>可以看到，访问成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这就是 JWT 结合 Spring Security 的一个简单用法，讲真，如果实例允许，类似的需求我还是推荐使用 OAuth2 中的 password 模式。</p><p>不知道大伙有没有看懂呢？如果没看懂，松哥还有一个关于这个知识点的视频教程，如下：</p><ul><li><a href="https://mp.weixin.qq.com/s/Sn59dxwtsEWoj2wdynQuRQ" target="_blank" rel="noopener">Spring Security + JWT 视频教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前后端分离的项目中，登录策略也有不少，不过 JWT 算是目前比较流行的一种解决方案了，本文就和大家来分享一下如何将 Spring Security 和 JWT 结合在一起使用，进而实现前后端分离时的登录解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
</feed>
