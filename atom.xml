<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2021-03-31T07:00:53.760Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot 定义接口的方法是否可以声明为 private？</title>
    <link href="http://www.javaboy.org/2021/0331/springmvc-handlermethod.html"/>
    <id>http://www.javaboy.org/2021/0331/springmvc-handlermethod.html</id>
    <published>2021-03-31T06:58:00.000Z</published>
    <updated>2021-03-31T07:00:53.760Z</updated>
    
    <content type="html"><![CDATA[<p>我们在 Controller 中定义接口的时候，一般都是像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">    map.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>估计很少有人会把接口方法定义成 private 的吧？那我们不禁要问，如果非要定义成 private 的方法，那能运行起来吗？</p><p>带着这个疑问，我们开始今天的源码解读～</p><p>在我们使用 Spring Boot 的时候，经常会看到 HandlerMethod 这个类型，例如我们在定义拦截器的时候，如果拦截目标是一个方法，则 preHandle 的第三个参数就是 HandlerMethod（以下案例选自松哥之前的视频：<a href="https://mp.weixin.qq.com/s/3gu8tuJduFp--AyDsnH0yg" target="_blank" rel="noopener">手把手教你 Spring Boot 自定义注解</a>）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdempotentInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenService tokenService;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//省略...</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在阅读 SpringMVC 源码的时候，也会反复看到这个 HandlerMethod，那么它到底是什么意思？今天我想和小伙伴们捋一捋这个问题，把这个问题搞清楚了，前面的问题大家也就懂了。</p><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p><img src="http://img.itboyhub.com/2021/02/20210319220725.png" alt></p><p>可以看到，HandlerMethod 体系下的类并不多：</p><p><strong>HandlerMethod</strong></p><p>封装 Handler 和具体处理请求的 Method。</p><p><strong>InvocableHandlerMethod</strong></p><p>在 HandlerMethod 的基础上增加了调用的功能。</p><p><strong>ServletInvocableHandlerMethod</strong></p><p>在 InvocableHandlerMethod 的基础上增了对 <code>@ResponseStatus</code> 注解的支持、增加了对返回值的处理。</p><p><strong>ConcurrentResultHandlerMethod</strong></p><p>在 ServletInvocableHandlerMethod 的基础上，增加了对异步结果的处理。</p><p>基本上就是这四个，接下来松哥就来详细说一说这四个组件。</p><h2 id="2-HandlerMethod"><a href="#2-HandlerMethod" class="headerlink" title="2.HandlerMethod"></a>2.HandlerMethod</h2><h3 id="2-1-bridgedMethod"><a href="#2-1-bridgedMethod" class="headerlink" title="2.1 bridgedMethod"></a>2.1 bridgedMethod</h3><p>在正式开始介绍 HandlerMethod 之前，想先和大家聊聊 bridgedMethod，因为在 HandlerMethod 中将会涉及到这个东西，而有的小伙伴可能还没听说过 bridgedMethod，因此松哥在这里做一个简单介绍。</p><p>首先考考大家，下面这段代码编译会报错吗？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Animal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"cat eat "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="hljs-keyword">new</span> Cat();</span><br><span class="line">        animal.eat(<span class="hljs-keyword">new</span> Object());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们定义了一个 Animal 接口，里边定义了一个 eat 方法，同时声明了一个泛型。Cat 实现了 Animal 接口，将泛型也定义为了 String。当我调用的时候，声明类型是 Animal，实际类型是 Cat，这个时候调 eat 方法传入了 Object 对象大家猜猜会怎么样？如果调用 eat 方法时传入的是 String 类型那就肯定没问题，但如果不是 String 呢？</p><p>松哥先说结论：编译没问题，运行报错。</p><p>如果小伙伴们在自己电脑上写出上面这段代码，你会发现这样一个问题，开发工具中提示的参数类型竟然是 Object，以松哥的 IDEA 为例，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210320213610.png" alt></p><p>大家看到，在我写代码的时候，开发工具会给我提示，这个参数类型是 Object，有的小伙伴会觉得奇怪，明明是泛型，怎么变成 Object 了？</p><p>我们可以通过反射查看 Cat 类中到底有哪些方法，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method[] methods = Cat.class.getMethods();</span><br><span class="line">        <span class="hljs-keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            String name = method.getName();</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            System.out.println(name+<span class="hljs-string">"("</span>+ Arrays.toString(parameterTypes) +<span class="hljs-string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210320214359.png" alt></p><p>可以看到，在实际运行过程中，竟然有两个 eat 方法，一个的参数为 String 类型，另一个参数为 Object 类型，这是怎么回事呢？</p><p>这个参数类型为 Object 的方法其实是 Java 虚拟机在运行时创建出来的，这个方法就是我们所说的 bridge method。本节的小标题叫做 <code>bridgedMethod</code>，这是 HandlerMethod 源码中的变量名，bridge 结尾多了一个 d，含义变成了被 bridge 的方法，也就是参数为 String 的原方法，大家在接下来的源码中看到了 bridgedMethod 就知道这表示参数类型不变的原方法。</p><h3 id="2-2-HandlerMethod-介绍"><a href="#2-2-HandlerMethod-介绍" class="headerlink" title="2.2 HandlerMethod 介绍"></a>2.2 HandlerMethod 介绍</h3><p>接下来我们来简单看下 HandlerMethod。</p><p>在我们前面分析 HandlerMapping 的时候（参见：<a href></a>），里边有涉及到 HandlerMethod，创建 HandlerMethod 的入口方法是 createWithResolvedBean，因此这里我们就从该方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> HandlerMethod <span class="hljs-title">createWithResolvedBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Object handler = <span class="hljs-keyword">this</span>.bean;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bean <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String beanName = (String) <span class="hljs-keyword">this</span>.bean;</span><br><span class="line">handler = <span class="hljs-keyword">this</span>.beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HandlerMethod(<span class="hljs-keyword">this</span>, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是确认了一下 handler 的类型，如果 handler 是 String 类型，则根据 beanName 从 Spring 容器中重新查找到 handler 对象，然后构建 HandlerMethod：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HandlerMethod</span><span class="hljs-params">(HandlerMethod handlerMethod, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.bean = handler;</span><br><span class="line"><span class="hljs-keyword">this</span>.beanFactory = handlerMethod.beanFactory;</span><br><span class="line"><span class="hljs-keyword">this</span>.beanType = handlerMethod.beanType;</span><br><span class="line"><span class="hljs-keyword">this</span>.method = handlerMethod.method;</span><br><span class="line"><span class="hljs-keyword">this</span>.bridgedMethod = handlerMethod.bridgedMethod;</span><br><span class="line"><span class="hljs-keyword">this</span>.parameters = handlerMethod.parameters;</span><br><span class="line"><span class="hljs-keyword">this</span>.responseStatus = handlerMethod.responseStatus;</span><br><span class="line"><span class="hljs-keyword">this</span>.responseStatusReason = handlerMethod.responseStatusReason;</span><br><span class="line"><span class="hljs-keyword">this</span>.resolvedFromHandlerMethod = handlerMethod;</span><br><span class="line"><span class="hljs-keyword">this</span>.description = handlerMethod.description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的参数都比较简单，没啥好说的，唯一值得介绍的地方有两个：parameters 和 responseStatus。</p><p><strong>parameters</strong></p><p>parameters 实际上就是方法参数，对应的类型是 MethodParameter，这个类的源码我这里就不贴出来了，主要和大家说一下封装的内容包括：参数的序号（parameterIndex），参数嵌套级别（nestingLevel），参数类型（parameterType），参数的注解（parameterAnnotations），参数名称查找器（parameterNameDiscoverer），参数名称（parameterName）等。</p><p>HandlerMethod 中还提供了两个内部类来封装 MethodParameter，分别是：</p><ul><li>HandlerMethodParameter：这个封装方法调用的参数。</li><li>ReturnValueMethodParameter：这个继承自 HandlerMethodParameter，它封装了方法的返回值，返回值里边的 parameterIndex 是 -1。</li></ul><p>注意，这两者中的 method 都是 bridgedMethod。</p><p><strong>responseStatus</strong></p><p>这个主要是处理方法的 <code>@ResponseStatus</code> 注解，这个注解用来描述方法的响应状态码，使用方式像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/04"</span>)</span><br><span class="line"><span class="hljs-meta">@ResponseBody</span></span><br><span class="line"><span class="hljs-meta">@ResponseStatus</span>(code = HttpStatus.OK)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello4</span><span class="hljs-params">(@SessionAttribute(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中大家可以看到，其实 <code>@ResponseStatus</code> 注解灵活性很差，不实用，当我们定义一个接口的时候，很难预知到该接口的响应状态码是 200。</p><p>在 handlerMethod 中，在调用其构造方法的时候，都会调用 evaluateResponseStatus 方法处理 <code>@ResponseStatus</code> 注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">evaluateResponseStatus</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">ResponseStatus annotation = getMethodAnnotation(ResponseStatus.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (annotation == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">annotation = AnnotatedElementUtils.findMergedAnnotation(getBeanType(), ResponseStatus.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (annotation != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.responseStatus = annotation.code();</span><br><span class="line"><span class="hljs-keyword">this</span>.responseStatusReason = annotation.reason();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这段代码也比较简单，找到注解，把里边的值解析出来，赋值给相应的变量。</p><p>这下小伙伴们应该明白了 HandlerMethod 大概是个怎么回事。</p><h2 id="3-InvocableHandlerMethod"><a href="#3-InvocableHandlerMethod" class="headerlink" title="3.InvocableHandlerMethod"></a>3.InvocableHandlerMethod</h2><p>看名字就知道，InvocableHandlerMethod 可以调用 HandlerMethod 中的具体方法，也就是 bridgedMethod。我们先来看下 InvocableHandlerMethod 中声明的属性：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> HandlerMethodArgumentResolverComposite resolvers = <span class="hljs-keyword">new</span> HandlerMethodArgumentResolverComposite();</span><br><span class="line"><span class="hljs-keyword">private</span> ParameterNameDiscoverer parameterNameDiscoverer = <span class="hljs-keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> WebDataBinderFactory dataBinderFactory;</span><br></pre></td></tr></table></figure><p>主要就是这三个属性：</p><ul><li>resolvers：这个不用说，参数解析器，前面的文章中松哥已经和大家聊过这个问题了。</li><li>parameterNameDiscoverer：这个用来获取参数名称，在 MethodParameter 中会用到。</li><li>dataBinderFactory：这个用来创建 WebDataBinder，在参数解析器中会用到。</li></ul><p>具体的请求调用方法是 invokeForRequest，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invokeForRequest</span><span class="hljs-params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"><span class="hljs-keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Method method = getBridgedMethod();</span><br><span class="line">ReflectionUtils.makeAccessible(method);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (KotlinDetector.isSuspendingFunction(method)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> method.invoke(getBean(), args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// 省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 getMethodArgumentValues 方法按顺序获取到所有参数的值，这些参数值组成一个数组，然后调用 doInvoke 方法执行，在 doInvoke 方法中，首先获取到 bridgedMethod，并设置其可见（<strong>意味着我们在 Controller 中定义的接口方法也可以是 private 的</strong>），然后直接通过反射调用即可。当我们没看 SpringMVC 源码的时候，我们就知道接口方法最终肯定是通过反射调用的，现在，经过层层分析之后，终于在这里找到了反射调用代码。</p><p>最后松哥再来说一下负责参数解析的 getMethodArgumentValues 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="hljs-meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">Object... providedArgs) <span class="hljs-keyword">throws</span> Exception &#123;</span><br><span class="line">MethodParameter[] parameters = getMethodParameters();</span><br><span class="line"><span class="hljs-keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line">Object[] args = <span class="hljs-keyword">new</span> Object[parameters.length];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">MethodParameter parameter = parameters[i];</span><br><span class="line">parameter.initParameterNameDiscovery(<span class="hljs-keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line"><span class="hljs-keyword">if</span> (args[i] != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="hljs-string">"No suitable resolver"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">args[i] = <span class="hljs-keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="hljs-keyword">this</span>.dataBinderFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="hljs-comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 getMethodParameters 方法获取到方法的所有参数。</li><li>创建 args 数组用来保存参数的值。</li><li>接下来一堆初始化配置。</li><li>如果 providedArgs 中提供了参数值，则直接赋值。</li><li>查看是否有参数解析器支持当前参数类型，如果没有，直接抛出异常。</li><li>调用参数解析器对参数进行解析，解析完成后，赋值。</li></ol><p>是不是，很 easy！</p><h2 id="4-ServletInvocableHandlerMethod"><a href="#4-ServletInvocableHandlerMethod" class="headerlink" title="4.ServletInvocableHandlerMethod"></a>4.ServletInvocableHandlerMethod</h2><p>ServletInvocableHandlerMethod 则是在 InvocableHandlerMethod 的基础上，又增加了两个功能：</p><ul><li>对 <code>@ResponseStatus</code> 注解的处理</li><li>对返回值的处理</li></ul><p>Servlet 容器下 Controller 在查找适配器时发起调用的最终就是 ServletInvocableHandlerMethod。</p><p>这里的处理核心方法是 invokeAndHandle，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAndHandle</span><span class="hljs-params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">setResponseStatus(webRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (returnValue == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="hljs-keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">disableContentCachingIfNecessary(webRequest);</span><br><span class="line">mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mavContainer.setRequestHandled(<span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用父类的 invokeForRequest 方法对请求进行执行，拿到请求结果。</li><li>调用 setResponseStatus 方法处理 <code>@ResponseStatus</code> 注解，具体的处理逻辑是这样：如果没有添加 <code>@ResponseStatus</code> 注解，则什么都不做；如果添加了该注解，并且 reason 属性不为空，则直接输出错误，否则设置响应状态码。这里需要注意一点，如果响应状态码是 200，就不要设置 reason，否则会按照 error 处理。</li><li>接下来就是对返回值的处理了，returnValueHandlers#handleReturnValue 方法松哥在之前的文章中和大家专门介绍过，这里就不再赘述，传送门：<a href="https://mp.weixin.qq.com/s/8aMz07rOF5LuclnBaI_p5g" target="_blank" rel="noopener">Spring Boot 中如何统一 API 接口响应格式？</a>。</li></ol><p>事实上，ServletInvocableHandlerMethod 还有一个子类 ConcurrentResultHandlerMethod，这个支持异步调用结果处理，因为使用场景较少，这里就不做介绍啦。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>现在大家可以回答文章标题提出的问题了吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在 Controller 中定义接口的时候，一般都是像下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/01&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Map&amp;lt;String,Object&amp;gt; map)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map.put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;javaboy&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;forward:/index&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>接口参数 Model 中的数据放在 session 中还是 request 中？</title>
    <link href="http://www.javaboy.org/2021/0330/sessionattribute.html"/>
    <id>http://www.javaboy.org/2021/0330/sessionattribute.html</id>
    <published>2021-03-30T06:58:11.000Z</published>
    <updated>2021-03-31T07:01:29.104Z</updated>
    
    <content type="html"><![CDATA[<p>在 SpringMVC 中，大家都知道有一个特殊的参数 Model，它的使用方式像下面这样：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"01"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个看起来人畜无害的普通参数，里边也会包含你的知识盲区吗？说不定真的包含了，不信你就往下看。</p><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h2><p>仅仅从使用上来说，Model 有两方面的功能：</p><ol><li>携带参数</li><li>返回参数</li></ol><p>先说携带参数：当我们在一个接口中放上 Model 这个参数之后，这个 Model 不一定是空白的，它里边可能已经有了携带的参数，携带的参数可能来自上一次 <code>@SessionAttributes</code> 注解标记过的参数，也可能来自 <code>@ModelAttribute</code> 注解标记过的全局参数。</p><p>在来说返回参数，Model 中的属性，你最终都可以在前端视图中获取到，这个没啥好说的。</p><p>前面提到了 <code>@ModelAttribute</code> 注解，这个如果有小伙伴不清楚，可以看看松哥之前的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/Qd0BAUdUtBuBUBmy1G0Z4w" target="_blank" rel="noopener">@ControllerAdvice 的三种使用场景</a></li></ul><p>或者在公众号后台回复 666 有文字教程，回复 ssm 有视频教程，都有关于 <code>@ModelAttribute</code> 的讲解。</p><p>至于 <code>@SessionAttributes</code>，松哥现在和大家分享一下，毕竟只有先懂怎么用，后面才会懂源码。</p><h2 id="2-SessionAttributes"><a href="#2-SessionAttributes" class="headerlink" title="2.@SessionAttributes"></a>2.<code>@SessionAttributes</code></h2><p><code>@SessionAttributes</code> 作用于处理器类上，这个注解可以把参数存储到 session 中，进而可以实现在多个请求之间传递参数。</p><p><code>@SessionAttributes</code> 的作用类似于 Session 的 Attribute 属性，但不完全一样，一般来说 <code>@SessionAttributes</code> 设置的参数只用于临时的参数传递，而不是长期的保存，参数用完之后可以通过 SessionStatus 将之清除。</p><p>通过 <code>@SessionAttributes</code> 注解设置的参数我们可以在三个地方获取：</p><ol><li>在当前的视图中直接通过 <code>request.getAttribute</code> 或 <code>session.getAttribute</code> 获取。</li></ol><p>例如如下接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"01"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name 属性会被临时保存在 session 中，在前端页面中，我们既可以从 request 域中获取也可以从 session 域中获取，以 Thymeleaf 页面模版为例：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;#request.getAttribute('name')&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;#session.getAttribute('name')&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有使用 <code>@SessionAttributes</code> 注解，那就只能从 request 域中获取，而不能从 session 域中获取。</p><ol start="2"><li>在后面的请求中，也可以通过 <code>session.getAttribute</code> 获取。</li></ol><p>参数既然存在 session 中，那就有一个好处，就是无论是服务器端跳转还是客户端跳转，参数都不会丢失。例如如下接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/02"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"01"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论开发者访问 <code>http://localhost:8080/01</code> 还是 <code>http://localhost:8080/02</code>，都能看到页面，并且 name 属性的值也能在页面上渲染出来。</p><p>不知道小伙伴们有没有想起来什么？对了，重定向的参数传递问题，之前松哥和大家分享了 FlashMap（<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>），现在你看到了，这也是一种方案。</p><ol start="3"><li>在后续的请求中，也可以直接从 Model 中获取。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/03"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello3</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        Object name = model.getAttribute(<span class="hljs-string">"name"</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问完 <code>/01</code> 接口之后，再去访问 <code>/03</code> 接口，也可以拿到 Model 中的数据。</p><p>第三种方式还有一个变体，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/04"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello4</span><span class="hljs-params">(@SessionAttribute(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是参数中不使用 Model，而是使用 <code>@SessionAttribute</code> 注解，直接将 session 中的属性绑定到参数上。</p><p>使用了 <code>@SessionAttributes</code> 注解之后，可以调用 <code>SessionStatus.setComplete</code> 方法来清除数据，注意这个方法只是清除 <code>SessionAttribute</code> 里的参数，而不会清除正常 Session 中的参数。</p><p>例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/04"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello4</span><span class="hljs-params">(@SessionAttribute(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/05"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello5</span><span class="hljs-params">(SessionStatus sessionStatus)</span> </span>&#123;</span><br><span class="line">        sessionStatus.setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先访问 <code>/01</code> 接口，访问完了就有数据了，这个时候访问 <code>/04</code> 接口，就会打印出数据，继续访问 <code>/05</code> 接口，访问完成后，再去访问 <code>/04</code> 接口，此时就会发现数据没了，因为被清除了。</p><p>现在，大家对 <code>@SessionAttributes</code> 注解的用法应该有了一定的认知了吧。</p><h2 id="3-ModelFactory"><a href="#3-ModelFactory" class="headerlink" title="3.ModelFactory"></a>3.ModelFactory</h2><p>接下来我们就来研究一下 ModelFactory，ModelFactory 是用来维护 Model 的，上面这一切，我们可以从 ModelFactory 中找到端倪。</p><p>整体上来说，ModelFactory 包含两方面的功能：1.初始化 Model；2.将 Model 中相应的参数更新到 SessionAtrributes 中。两方面的功能我们分别来看，先来看初始化问题。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initModel</span><span class="hljs-params">(NativeWebRequest request, ModelAndViewContainer container, HandlerMethod handlerMethod)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String, ?&gt; sessionAttributes = <span class="hljs-keyword">this</span>.sessionAttributesHandler.retrieveAttributes(request);</span><br><span class="line">container.mergeAttributes(sessionAttributes);</span><br><span class="line">invokeModelAttributeMethods(request, container);</span><br><span class="line"><span class="hljs-keyword">for</span> (String name : findSessionAttributeArguments(handlerMethod)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!container.containsAttribute(name)) &#123;</span><br><span class="line">Object value = <span class="hljs-keyword">this</span>.sessionAttributesHandler.retrieveAttribute(request, name);</span><br><span class="line"><span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpSessionRequiredException(<span class="hljs-string">"Expected session attribute '"</span> + name + <span class="hljs-string">"'"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">container.addAttribute(name, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 initModel 方法比较逻辑比较简单：</p><ol><li>首先它会从 <code>@SessionAttributes</code> 中取出参数，然后合并进 ModelAndViewContainer 容器中（不懂 ModelAndViewContainer 容器的话，可以参考松哥前面的文章：<a href="https://mp.weixin.qq.com/s/8aMz07rOF5LuclnBaI_p5g" target="_blank" rel="noopener">Spring Boot 中如何统一 API 接口响应格式？</a>）。</li><li>接下来调用含有 <code>@ModelAttribute</code> 注解的方法，并将结果合并进 ModelAndViewContainer 容器中。</li><li>寻找那些既有 <code>@ModelAttribute</code> 注解又有 <code>@SessionAttributes</code> 注解的属性，找到后，如果这些属性不存在于 ModelAndViewContainer 容器中，就从 SessionAttributes 中获取并设置到 ModelAndViewContainer 容器中。</li></ol><p>我们先来看看第一个 retrieveAttributes 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">retrieveAttributes</span><span class="hljs-params">(WebRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; attributes = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String name : <span class="hljs-keyword">this</span>.knownAttributeNames) &#123;</span><br><span class="line">Object value = <span class="hljs-keyword">this</span>.sessionAttributeStore.retrieveAttribute(request, name);</span><br><span class="line"><span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">attributes.put(name, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个其实没啥好说的，因为逻辑很清晰，knownAttributeNames 就是我们在使用 <code>@SessionAttributes</code> 注解时配置的属性名字，属性名字可以是一个数组。遍历 knownAttributeNames 属性，从 session 中获取相关数据存入 Map 集合中。</p><p>再来看第二个 invokeModelAttributeMethods 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeModelAttributeMethods</span><span class="hljs-params">(NativeWebRequest request, ModelAndViewContainer container)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.modelMethods.isEmpty()) &#123;</span><br><span class="line">InvocableHandlerMethod modelMethod = getNextModelMethod(container).getHandlerMethod();</span><br><span class="line">ModelAttribute ann = modelMethod.getMethodAnnotation(ModelAttribute.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (container.containsAttribute(ann.name())) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!ann.binding()) &#123;</span><br><span class="line">container.setBindingDisabled(ann.name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object returnValue = modelMethod.invokeForRequest(request, container);</span><br><span class="line"><span class="hljs-keyword">if</span> (modelMethod.isVoid()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(ann.value())) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">String returnValueName = getNameForReturnValue(returnValue, modelMethod.getReturnType());</span><br><span class="line"><span class="hljs-keyword">if</span> (!ann.binding()) &#123;</span><br><span class="line">container.setBindingDisabled(returnValueName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!container.containsAttribute(returnValueName)) &#123;</span><br><span class="line">container.addAttribute(returnValueName, returnValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取含有 <code>@ModelAttribute</code> 注解的方法，然后获取到该注解。</li><li>获取 <code>@ModelAttribute</code> 注解，并提取出它的 name 属性值，然后查看 ModelAndViewContainer 容器中是否已经包含了该属性，如果已经包含了，并且在 <code>@ModelAttribute</code> 注解中设置了不绑定，则将该属性添加到 ModelAndViewContainer 容器中的禁止绑定上面去。</li><li>接下来通过 <code>invokeForRequest</code> 方法去调用含有 <code>@ModelAttribute</code> 注解的方法，并获取返回值。</li><li>如果含有 <code>@ModelAttribute</code> 注解的方法返回值为 void，则该方法到此为止。</li><li>接下来解析出返回值的参数名，有的小伙伴们说，参数名不就是 <code>@ModelAttribute</code> 注解中配置的 name 属性吗？这当然没错！但是有时候用户没有配置 name 属性，那么这个时候就会对应一套默认的 name 生成方案。默认的名字生成方案是这样的：<ul><li>如果返回对象前两个字母都是大写，那就原封不动返回，否则首字母小写后返回。</li><li>如果返回类型是数组或者集合，则在真实类型后加上 List，例如 List<long> 对象 longList。</long></li></ul></li><li>有了 returnValueName 之后，再去判断是否要禁止属性绑定。最后如果 ModelAndViewContainer 容器中不包含该属性，则添加进来。</li></ol><p>这就是 Model 初始化的过程，可以看到，数据最终都被保存进 ModelAndViewContainer 容器中了，至于在该容器中数据被保存到哪个属性，则要看实际情况，可能是 defaultModel 也可能是 redirectModel，具体参见<a href="https://mp.weixin.qq.com/s/8aMz07rOF5LuclnBaI_p5g" target="_blank" rel="noopener">Spring Boot 中如何统一 API 接口响应格式？</a>）。</p><p>最后我们再来看看 ModelFactory 中修改 Model 的过程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateModel</span><span class="hljs-params">(NativeWebRequest request, ModelAndViewContainer container)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ModelMap defaultModel = container.getDefaultModel();</span><br><span class="line"><span class="hljs-keyword">if</span> (container.getSessionStatus().isComplete())&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.sessionAttributesHandler.cleanupAttributes(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.sessionAttributesHandler.storeAttributes(request, defaultModel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!container.isRequestHandled() &amp;&amp; container.getModel() == defaultModel) &#123;</span><br><span class="line">updateBindingResult(request, defaultModel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改的时候会首先判断一下是否已经调用了 <code>sessionStatus.setComplete();</code> 方法，如果调用过了，就执行清除操作，否则就进行正常的更新操作即可，更新的数据就是 ModelAndViewContainer 中的 defaultModel。最后判断是否需要进行页面渲染，如果需要，再给参数分别设置 BindingResult 以备视图使用。</p><p>现在，大家应该已经清楚了 ModelFactory 的功能了。</p><p>一句话，ModelFactory 在初始化的时候，就直接从 SessionAttributes 以及 ModelAttribute 处加载到数据，放到 ModelAndViewContainer 中，更新的时候，则有可能清除 SessionAttributes 中的数据。<strong>这里大家需要把握一点，就是数据最终被存入 ModelAndViewContainer 中了。</strong></p><h2 id="3-相关的参数解析器"><a href="#3-相关的参数解析器" class="headerlink" title="3.相关的参数解析器"></a>3.相关的参数解析器</h2><p>这是 Model 初始化的过程，初始化完成后，参数最终会在参数解析器中被解析，关于参数解析器，大家可以参考如下两篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/4c-uV8f6x5UPvxec6Em79A" target="_blank" rel="noopener">SpringBoot 中如何自定义参数解析器？</a></li><li><a href="https://mp.weixin.qq.com/s/qsS6Dwr6eXx07i5dhn8FEA" target="_blank" rel="noopener">深入分析 SpringMVC 参数解析器</a></li></ul><p>这里涉及到的参数解析器就是 ModelMethodProcessor，我们来看下它里边两个关键的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Model.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mavContainer.getModel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，支持的参数类型就是 Model，参数的值则是直接返回 ModelAndViewContainer 中的 model 对象。</p><p>这里还有一个类似的参数处理器 MapMethodProcessor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp;</span><br><span class="line">parameter.getParameterAnnotations().length == <span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mavContainer.getModel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是处理 Map 类型的参数，最终返回的也是 ModelAndViewContainer 中的 model，你是否发现什么了？对了，在本文第二小节的案例中，你把 Model 参数换成 Map 或者 ModelMap（ModelMap 本质上也是 Map，使用的参数解析器也是 MapMethodProcessor），最终效果是一样的！</p><p>前面我们还使用了 <code>@SessionAttribute</code> 注解，这个注解的 name 属性就绑定了 SessionAttributes 中对应的属性并赋值给变量，它使用的参数解析器是 SessionAttributeMethodArgumentResolver，我们来看下它里边的核心方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionAttributeMethodArgumentResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractNamedValueMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> parameter.hasParameterAnnotation(SessionAttribute.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveName</span><span class="hljs-params">(String name, MethodParameter parameter, NativeWebRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getAttribute(name, RequestAttributes.SCOPE_SESSION);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个参数最终对应的值就是从 session 中取出对应的 name 属性值。</p><p>最后，我们再来梳理一下整个过程：当请求到达后，首先要初始化 Model，初始化 Model 的时候，会根据 <code>@SessionAttributes</code> 注解从 session 中读取相关数据放入 ModelAndViewContainer 中，同时也会加载 <code>@ModelAttribute</code> 注解配置的全局数据到 ModelAndViewContainer 中。最终在参数解析器中，返回 ModelAndViewContainer 中的 model 即可。</p><hr><p>现在大家可以回答文章标题提出的问题了吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 SpringMVC 中，大家都知道有一个特殊的参数 Model，它的使用方式像下面这样：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 九大组件之 HandlerMapping 深入分析</title>
    <link href="http://www.javaboy.org/2021/0326/springmvc-handlermapping.html"/>
    <id>http://www.javaboy.org/2021/0326/springmvc-handlermapping.html</id>
    <published>2021-03-26T06:58:28.000Z</published>
    <updated>2021-03-31T07:03:03.605Z</updated>
    
    <content type="html"><![CDATA[<p>前面跟小伙伴们分享了 SpringMVC 一个大致的初始化流程以及请求的大致处理流程，在请求处理过程中，涉及到九大组件，分别是：</p><ol><li>HandlerMapping</li><li>HandlerAdapter</li><li>HandlerExceptionResolver</li><li>ViewResolver</li><li>RequestToViewNameTranslator</li><li>LocaleResolver</li><li>ThemeResolver</li><li>MultipartResolver</li><li>FlashMapManager</li></ol><a id="more"></a><p>这些组件相信小伙伴们在日常开发中多多少少都有涉及到，如果你对这些组件感到陌生，可以在公众号后台回复 <strong>ssm</strong>，免费获取松哥的入门视频教程。</p><p>那么接下来的几篇文章，松哥想和大家深入分析这九大组件，从用法到源码，挨个分析，今天我们就先来看看这九大组件中的第一个 HandlerMapping。</p><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p>HandlerMapping 叫做处理器映射器，它的作用就是根据当前 request 找到对应的 Handler 和 Interceptor，然后封装成一个 HandlerExecutionChain 对象返回，我们来看下 HandlerMapping 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerMapping</span> </span>&#123;</span><br><span class="line">String BEST_MATCHING_HANDLER_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".bestMatchingHandler"</span>;</span><br><span class="line"><span class="hljs-meta">@Deprecated</span></span><br><span class="line">String LOOKUP_PATH = HandlerMapping.class.getName() + <span class="hljs-string">".lookupPath"</span>;</span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".pathWithinHandlerMapping"</span>;</span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".bestMatchingPattern"</span>;</span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + <span class="hljs-string">".introspectTypeLevelMapping"</span>;</span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".uriTemplateVariables"</span>;</span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".matrixVariables"</span>;</span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".producibleMediaTypes"</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">usesPathPatterns</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">HandlerExecutionChain <span class="hljs-title">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，除了一堆声明的常量外，其实就一个需要实现的方法 getHandler，该方法的返回值就是我们所了解到的 HandlerExecutionChain。</p><p>HandlerMapping 的继承关系如下：</p><p><img src="http://img.itboyhub.com/2021/02/HandlerMapping.png" alt></p><p>这个继承关系虽然看着有点绕，其实仔细观察就两大类：</p><ul><li>AbstractHandlerMethodMapping</li><li>AbstractUrlHandlerMapping</li></ul><p>其他的都是一些辅助接口。</p><p>AbstractHandlerMethodMapping 体系下的都是根据方法名进行匹配的，而 AbstractUrlHandlerMapping 体系下的都是根据 URL 路径进行匹配的，这两者有一个共同的父类 AbstractHandlerMapping，接下来我们就对这三个关键类进行详细分析。</p><h2 id="2-AbstractHandlerMapping"><a href="#2-AbstractHandlerMapping" class="headerlink" title="2.AbstractHandlerMapping"></a>2.AbstractHandlerMapping</h2><p>AbstractHandlerMapping 实现了 HandlerMapping 接口，无论是通过 URL 进行匹配还是通过方法名进行匹配，都是通过继承 AbstractHandlerMapping 来实现的，所以 AbstractHandlerMapping 所做的事情其实就是一些公共的事情，将以一些需要具体处理的事情则交给子类去处理，这其实就是典型的模版方法模式。</p><p>AbstractHandlerMapping 间接继承自 ApplicationObjectSupport，并重写了 initApplicationContext 方法（其实该方法也是一个模版方法），这也是 AbstractHandlerMapping 的初始化入口方法，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">extendInterceptors(<span class="hljs-keyword">this</span>.interceptors);</span><br><span class="line">detectMappedInterceptors(<span class="hljs-keyword">this</span>.adaptedInterceptors);</span><br><span class="line">initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个方法都和拦截器有关。</p><p><strong>extendInterceptors</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extendInterceptors</span><span class="hljs-params">(List&lt;Object&gt; interceptors)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extendInterceptors 是一个模版方法，可以在子类中实现，子类实现了该方法之后，可以对拦截器进行添加、删除或者修改，不过在 SpringMVC 的具体实现中，其实这个方法并没有在子类中进行实现。</p><p><strong>detectMappedInterceptors</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detectMappedInterceptors</span><span class="hljs-params">(List&lt;HandlerInterceptor&gt; mappedInterceptors)</span> </span>&#123;</span><br><span class="line">mappedInterceptors.addAll(BeanFactoryUtils.beansOfTypeIncludingAncestors(</span><br><span class="line">obtainApplicationContext(), MappedInterceptor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>).values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>detectMappedInterceptors 方法会从 SpringMVC 容器以及 Spring 容器中查找所有 MappedInterceptor 类型的 Bean，查找到之后添加到 mappedInterceptors 属性中（其实就是全局的 adaptedInterceptors 属性）。一般来说，我们定义好一个拦截器之后，还要在 XML 文件中配置该拦截器，拦截器以及各种配置信息，最终就会被封装成一个 MappedInterceptor 对象。</p><p><strong>initInterceptors</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInterceptors</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.interceptors.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.interceptors.size(); i++) &#123;</span><br><span class="line">Object interceptor = <span class="hljs-keyword">this</span>.interceptors.get(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (interceptor == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Entry number "</span> + i + <span class="hljs-string">" in interceptors array is null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initInterceptors 方法主要是进行拦截器的初始化操作，具体内容是将 interceptors 集合中的拦截器添加到 adaptedInterceptors 集合中。</p><p>至此，我们看到，所有拦截器最终都会被存入 adaptedInterceptors 变量中。</p><p>AbstractHandlerMapping 的初始化其实也就是拦截器的初始化过程。</p><blockquote><p>为什么 AbstractHandlerMapping 中对拦截器如此重视呢？其实不是重视，大家想想，AbstractUrlHandlerMapping 和 AbstractHandlerMethodMapping 最大的区别在于查找处理器的区别，一旦处理器找到了，再去找拦截器，但是拦截器都是统一的，并没有什么明显区别，所以拦截器就统一在 AbstractHandlerMapping 中进行处理，而不会去 AbstractUrlHandlerMapping 或者 AbstractHandlerMethodMapping 中处理。</p></blockquote><p>接下来我们再来看看 AbstractHandlerMapping#getHandler 方法，看看处理器是如何获取到的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> HandlerExecutionChain <span class="hljs-title">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object handler = getHandlerInternal(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">handler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Ensure presence of cached lookupPath for interceptors and others</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!ServletRequestPathUtils.hasCachedPath(request)) &#123;</span><br><span class="line">initLookupPath(request);</span><br><span class="line">&#125;</span><br><span class="line">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">CorsConfiguration config = getCorsConfiguration(handler, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (getCorsConfigurationSource() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">CorsConfiguration globalConfig = getCorsConfigurationSource().getCorsConfiguration(request);</span><br><span class="line">config = (globalConfig != <span class="hljs-keyword">null</span> ? globalConfig.combine(config) : config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">config.validateAllowCredentials();</span><br><span class="line">&#125;</span><br><span class="line">executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的执行流程是这样的：</p><ol><li>首先调用 getHandlerInternal 方法去尝试获取处理器，getHandlerInternal 方法也是一个模版方法，该方法将在子类中实现。</li><li>如果没找到相应的处理器，则调用 getDefaultHandler 方法获取默认的处理器，我们在配置 HandlerMapping 的时候可以配置默认的处理器。</li><li>如果找到的处理器是一个字符串，则根据该字符串找去 SpringMVC 容器中找到对应的 Bean。</li><li>确保 lookupPath 存在，一会找对应的拦截器的时候会用到。</li><li>找到 handler 之后，接下来再调用 getHandlerExecutionChain 方法获取 HandlerExecutionChain 对象。</li><li>接下来 if 里边的是进行跨域处理的，获取到跨域的相关配置，然后进行验证&amp;配置，检查是否允许跨域。跨域这块的配置以及校验还是蛮有意思的，松哥以后专门写文章来和小伙伴们细聊。</li></ol><p>接下来我们再来看看第五步的 getHandlerExecutionChain 方法的执行逻辑，正是在这个方法里边把 handler 变成了 HandlerExecutionChain：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title">getHandlerExecutionChain</span><span class="hljs-params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">HandlerExecutionChain chain = (handler <span class="hljs-keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">(HandlerExecutionChain) handler : <span class="hljs-keyword">new</span> HandlerExecutionChain(handler));</span><br><span class="line"><span class="hljs-keyword">for</span> (HandlerInterceptor interceptor : <span class="hljs-keyword">this</span>.adaptedInterceptors) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (interceptor <span class="hljs-keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedInterceptor.matches(request)) &#123;</span><br><span class="line">chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">chain.addInterceptor(interceptor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接根据已有的 handler 创建一个新的 HandlerExecutionChain 对象，然后遍历 adaptedInterceptors 集合，该集合里存放的都是拦截器，如果拦截器的类型是 MappedInterceptor，则调用 matches 方法去匹配一下，看一下是否是拦截当前请求的拦截器，如果是，则调用 chain.addInterceptor 方法加入到 HandlerExecutionChain 对象中；如果就是一个普通拦截器，则直接加入到 HandlerExecutionChain 对象中。</p><p>这就是 AbstractHandlerMapping#getHandler 方法的大致逻辑，可以看到，这里留了一个模版方法 getHandlerInternal 在子类中实现，接下来我们就来看看它的子类。</p><h2 id="3-AbstractUrlHandlerMapping"><a href="#3-AbstractUrlHandlerMapping" class="headerlink" title="3.AbstractUrlHandlerMapping"></a>3.AbstractUrlHandlerMapping</h2><p>AbstractUrlHandlerMapping，看名字就知道，都是按照 URL 地址来进行匹配的，它的原理就是将 URL 地址与对应的 Handler 保存在同一个 Map 中，当调用 getHandlerInternal 方法时，就根据请求的 URL 去 Map 中找到对应的 Handler 返回就行了。</p><p>这里我们就先从他的 getHandlerInternal 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getHandlerInternal</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String lookupPath = initLookupPath(request);</span><br><span class="line">Object handler;</span><br><span class="line"><span class="hljs-keyword">if</span> (usesPathPatterns()) &#123;</span><br><span class="line">RequestPath path = ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">handler = lookupHandler(path, lookupPath, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">handler = lookupHandler(lookupPath, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// We need to care for the default handler directly, since we need to</span></span><br><span class="line"><span class="hljs-comment">// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span></span><br><span class="line">Object rawHandler = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.matchesCharacter(lookupPath, <span class="hljs-string">'/'</span>)) &#123;</span><br><span class="line">rawHandler = getRootHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (rawHandler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">rawHandler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (rawHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (rawHandler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) rawHandler;</span><br><span class="line">rawHandler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">validateHandler(rawHandler, request);</span><br><span class="line">handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先找到 lookupPath，就是请求的路径。这个方法本身松哥就不多说了，之前在<a href>Spring5 里边的新玩法！这种 URL 请求让我涨见识了！</a>一文中有过介绍。</li><li>接下来就是调用 lookupHandler 方法获取 Handler 对象，lookupHandler 有一个重载方法，具体用哪个，主要看所使用的 URL 匹配模式，如果使用了最新的 PathPattern（Spring5 之后的），则使用三个参数的 lookupHandler；如果还是使用之前旧的 AntPathMatcher，则这里使用两个参数的 lookupHandler。</li><li>如果前面没有获取到 handler 实例，则接下来再做各种尝试，去分别查找 RootHandler、DefaultHandler 等，如果找到的 Handler 是一个 String，则去 Spring 容器中查找该 String 对应的 Bean，再调用 validateHandler 方法来校验找到的 handler 和 request 是否匹配，不过这是一个空方法，子类也没有实现，所以可以忽略之。最后再通过 buildPathExposingHandler 方法给找到的 handler 添加一些参数。</li></ol><p>这就是整个 getHandlerInternal 方法的逻辑，实际上并不难，里边主要涉及到 lookupHandler 和 buildPathExposingHandler 两个方法，需要和大家详细介绍下，我们分别来看。</p><p><strong>lookupHandler</strong></p><p>lookupHandler 有两个，我们分别来看。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">lookupHandler</span><span class="hljs-params">(String lookupPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object handler = getDirectMatch(lookupPath, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Pattern match?</span></span><br><span class="line">List&lt;String&gt; matchingPatterns = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String registeredPattern : <span class="hljs-keyword">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (getPathMatcher().match(registeredPattern, lookupPath)) &#123;</span><br><span class="line">matchingPatterns.add(registeredPattern);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!registeredPattern.endsWith(<span class="hljs-string">"/"</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="hljs-string">"/"</span>, lookupPath)) &#123;</span><br><span class="line">matchingPatterns.add(registeredPattern + <span class="hljs-string">"/"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String bestMatch = <span class="hljs-keyword">null</span>;</span><br><span class="line">Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(lookupPath);</span><br><span class="line"><span class="hljs-keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">matchingPatterns.sort(patternComparator);</span><br><span class="line">bestMatch = matchingPatterns.get(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bestMatch != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">handler = <span class="hljs-keyword">this</span>.handlerMap.get(bestMatch);</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (bestMatch.endsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">handler = <span class="hljs-keyword">this</span>.handlerMap.get(bestMatch.substring(<span class="hljs-number">0</span>, bestMatch.length() - <span class="hljs-number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"Could not find handler for best pattern match ["</span> + bestMatch + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">validateHandler(handler, request);</span><br><span class="line">String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, lookupPath);</span><br><span class="line"><span class="hljs-comment">// There might be multiple 'best patterns', let's make sure we have the correct URI template variables</span></span><br><span class="line"><span class="hljs-comment">// for all of them</span></span><br><span class="line">Map&lt;String, String&gt; uriTemplateVariables = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (patternComparator.compare(bestMatch, matchingPattern) == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, lookupPath);</span><br><span class="line">Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// No handler found...</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">getDirectMatch</span><span class="hljs-params">(String urlPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object handler = <span class="hljs-keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line"><span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">validateHandler(handler, request);</span><br><span class="line"><span class="hljs-keyword">return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这里首先调用 getDirectMatch 方法直接去 handlerMap 中找对应的处理器，handlerMap 中就保存了请求 URL 和处理器的映射关系，具体的查找过程就是先去 handlerMap 中找，找到了，如果是 String，则去 Spring 容器中找对应的 Bean，然后调用 validateHandler 方法去验证（实际上没有验证，前面已经说了），最后调用 buildPathExposingHandler 方法添加拦截器。</li><li>如果 getDirectMatch 方法返回值不为 null，则直接将查找到的 handler 返回，方法到此为止。那么什么情况下 getDirectMatch 方法的返回值不为 null 呢？简单来收就是没有使用通配符的情况下，请求地址中没有通配符，一个请求地址对应一个处理器，只有这种情况，getDirectMatch 方法返回值才不为 null，因为 handlerMap 中保存的是代码的定义，比如我们定义代码的时候，某个处理器的访问路径可能带有通配符，但是当我们真正发起请求的时候，请求路径里是没有通配符的，这个时候再去 handlerMap 中就找不对对应的处理器了。如果用到了定义接口时用到了通配符，则需要在下面的代码中继续处理。</li><li>接下来处理通配符的情况。首先定义 matchingPatterns 集合，将当前请求路径和 handlerMap 集合中保存的请求路径规则进行对比，凡是能匹配上的规则都直接存入 matchingPatterns 集合中。具体处理中，还有一个 useTrailingSlashMatch 的可能，有的小伙伴 SpringMVC 用的不熟练，看到这里可能就懵了，这里是这样的，SpringMVC 中，默认是可以匹配结尾 <code>/</code> 的，举个简单例子，如果你定义的接口是 <code>/user</code>，那么请求路径可以是 <code>/user</code> 也可以 <code>/user/</code>，这两种默认都是支持的，所以这里的 useTrailingSlashMatch 分支主要是处理后面这种情况，处理方式很简单，就在 registeredPattern 后面加上 <code>/</code> 然后继续和请求路径进行匹配。</li><li>由于一个请求 URL 可能会和定义的多个接口匹配上，所以 matchingPatterns 变量是一个数组，接下来就要对 matchingPatterns 进行排序，排序完成后，选择排序后的第一项作为最佳选项赋值给 bestMatch 变量。默认的排序规则是 AntPatternComparator，当然开发者也可以自定义。AntPatternComparator 中定义的优先级如下：</li></ol><table><thead><tr><th style="text-align:left">路由配置</th><th style="text-align:left">优先级</th></tr></thead><tbody><tr><td style="text-align:left">不含任何特殊符号的路径，如：配置路由<code>/a/b/c</code></td><td style="text-align:left">第一优先级</td></tr><tr><td style="text-align:left">带有<code>{}</code>的路径，如：<code>/a/{b}/c</code></td><td style="text-align:left">第二优先级</td></tr><tr><td style="text-align:left">带有正则的路径，如：<code>/a/{regex:\d{3}}/c</code></td><td style="text-align:left">第三优先级</td></tr><tr><td style="text-align:left">带有<code>*</code>的路径，如：<code>/a/b/*</code></td><td style="text-align:left">第四优先级</td></tr><tr><td style="text-align:left">带有<code>**</code>的路径，如：<code>/a/b/**</code></td><td style="text-align:left">第五优先级</td></tr><tr><td style="text-align:left">最模糊的匹配：<code>/**</code></td><td style="text-align:left">最低优先级</td></tr></tbody></table><ol start="5"><li>找到 bestMatch 之后，接下来再根据 bestMatch 去 handlerMap 中找到对应的处理器，直接找如果没找到，就去检查 bestMatch 是否以 <code>/</code> 结尾，如果是以 <code>/</code> 结尾，则去掉结尾的 <code>/</code> 再去 handlerMap 中查找，如果还没找到，那就该抛异常出来了。如果找到的 handler 是 String 类型的，则再去 Spring 容器中查找对应的 Bean，接下来再调用 validateHandler 方法进行验证。</li><li>接下来调用 extractPathWithinPattern 方法提取出映射路径，例如定义的接口规则是 <code>myroot/*.html</code>，请求路径是 <code>myroot/myfile.html</code>，那么最终获取到的就是 <code>myfile.html</code>。</li><li>接下来的 for 循环是为了处理存在多个最佳匹配规则的情况，在第四步中，我们对 matchingPatterns 进行排序，排序完成后，选择第一项作为最佳选项赋值给 bestMatch，但是最佳选项可能会有多个，这里就是处理最佳选项有多个的情况。</li><li>最后调用 buildPathExposingHandler 方法注册两个内部拦截器，该方法下文我会给大家详细介绍。</li></ol><p>lookupHandler 还有一个重载方法，不过只要大家把这个方法的执行流程搞清楚了，重载方法其实很好理解，这里松哥就不再赘述了，唯一要说的就是重载方法用了 PathPattern 去匹配 URL 路径，而这个方法用了 AntPathMatcher 去匹配 URL 路径。</p><p><strong>buildPathExposingHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">buildPathExposingHandler</span><span class="hljs-params">(Object rawHandler, String bestMatchingPattern,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">String pathWithinMapping, @Nullable Map&lt;String, String&gt; uriTemplateVariables)</span> </span>&#123;</span><br><span class="line">HandlerExecutionChain chain = <span class="hljs-keyword">new</span> HandlerExecutionChain(rawHandler);</span><br><span class="line">chain.addInterceptor(<span class="hljs-keyword">new</span> PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));</span><br><span class="line"><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(uriTemplateVariables)) &#123;</span><br><span class="line">chain.addInterceptor(<span class="hljs-keyword">new</span> UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buildPathExposingHandler 方法向 HandlerExecutionChain 中添加了两个拦截器 PathExposingHandlerInterceptor 和 UriTemplateVariablesHandlerInterceptor，这两个拦截器在各自的 preHandle 中分别向 request 对象添加了一些属性，具体添加的属性小伙伴们可以自行查看，这个比较简单，我就不多说了。</p><p>在前面的方法中，涉及到一个重要的变量 handlerMap，我们定义的接口和处理器之间的关系都保存在这个变量中，那么这个变量是怎么初始化的呢？这就涉及到 AbstractUrlHandlerMapping 中的另一个方法 registerHandler：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHandler</span><span class="hljs-params">(String[] urlPaths, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String urlPath : urlPaths) &#123;</span><br><span class="line">registerHandler(urlPath, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHandler</span><span class="hljs-params">(String urlPath, Object handler)</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">Object resolvedHandler = handler;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.lazyInitHandlers &amp;&amp; handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">ApplicationContext applicationContext = obtainApplicationContext();</span><br><span class="line"><span class="hljs-keyword">if</span> (applicationContext.isSingleton(handlerName)) &#123;</span><br><span class="line">resolvedHandler = applicationContext.getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object mappedHandler = <span class="hljs-keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"Cannot map "</span> + getHandlerDescription(handler) + <span class="hljs-string">" to URL path ["</span> + urlPath +</span><br><span class="line"><span class="hljs-string">"]: There is already "</span> + getHandlerDescription(mappedHandler) + <span class="hljs-string">" mapped."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (urlPath.equals(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">setRootHandler(resolvedHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (urlPath.equals(<span class="hljs-string">"/*"</span>)) &#123;</span><br><span class="line">setDefaultHandler(resolvedHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line"><span class="hljs-keyword">if</span> (getPatternParser() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerHandler(String[],String) 方法有两个参数，第一个就是定义的请求路径，第二个参数则是处理器 Bean 的名字，第一个参数是一个数组，那是因为同一个处理器可以对应多个不同的请求路径。</p><p>在重载方法 registerHandler(String,String) 里边，完成了 handlerMap 的初始化，具体流程如下：</p><ol><li>如果没有设置 lazyInitHandlers，并且 handler 是 String 类型，那么就去 Spring 容器中找到对应的 Bean 赋值给 resolvedHandler。</li><li>根据 urlPath 去 handlerMap 中查看是否已经有对应的处理器了，如果有的话，则抛出异常，一个 URL 地址只能对应一个处理器，这个很好理解。</li><li>接下来根据 URL 路径，将处理器进行配置，最终添加到 handlerMap 变量中。</li></ol><p>这就是 AbstractUrlHandlerMapping 的主要工作，其中 registerHandler 将在它的子类中调用。</p><p>接下来我们来看 AbstractUrlHandlerMapping 的子类。</p><h3 id="3-1-SimpleUrlHandlerMapping"><a href="#3-1-SimpleUrlHandlerMapping" class="headerlink" title="3.1 SimpleUrlHandlerMapping"></a>3.1 SimpleUrlHandlerMapping</h3><p>为了方便处理，SimpleUrlHandlerMapping 中自己定义了一个 urlMap 变量，这样可以在注册之前做一些预处理，例如确保所有的 URL 都是以 <code>/</code> 开始。SimpleUrlHandlerMapping 在定义时重写了父类的 initApplicationContext 方法，并在该方法中调用了 registerHandlers，在 registerHandlers 中又调用了父类的 registerHandler 方法完成了 handlerMap 的初始化操作：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>.initApplicationContext();</span><br><span class="line">registerHandlers(<span class="hljs-keyword">this</span>.urlMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHandlers</span><span class="hljs-params">(Map&lt;String, Object&gt; urlMap)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (urlMap.isEmpty()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"No patterns in "</span> + formatMappingName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">urlMap.forEach((url, handler) -&gt; &#123;</span><br><span class="line"><span class="hljs-comment">// Prepend with slash if not already present.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!url.startsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">url = <span class="hljs-string">"/"</span> + url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Remove whitespace from handler bean name.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">handler = ((String) handler).trim();</span><br><span class="line">&#125;</span><br><span class="line">registerHandler(url, handler);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码很简单，实在没啥好说的，如果 URL 不是以 <code>/</code> 开头，则手动给它加上 <code>/</code> 即可。有小伙伴们可能要问了，urlMap 的值从哪里来？当然是从我们的配置文件里边来呀，像下面这样：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"urlMap"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"/aaa"</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">"/hello"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-AbstractDetectingUrlHandlerMapping"><a href="#3-2-AbstractDetectingUrlHandlerMapping" class="headerlink" title="3.2 AbstractDetectingUrlHandlerMapping"></a>3.2 AbstractDetectingUrlHandlerMapping</h3><p>AbstractDetectingUrlHandlerMapping 也是 AbstractUrlHandlerMapping 的子类，但是它和 SimpleUrlHandlerMapping 有一些不一样的地方。</p><p>不一样的是哪里呢？</p><p>AbstractDetectingUrlHandlerMapping 会自动查找到 SpringMVC 容器以及 Spring 容器中的所有 beanName，然后根据 beanName 解析出对应的 URL 地址，再将解析出的 url 地址和对应的 beanName 注册到父类的 handlerMap 变量中。换句话说，如果你用了 AbstractDetectingUrlHandlerMapping，就不用像 SimpleUrlHandlerMapping 那样去挨个配置 URL 地址和处理器的映射关系了。我们来看下 AbstractDetectingUrlHandlerMapping#initApplicationContext 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ApplicationContextException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>.initApplicationContext();</span><br><span class="line">detectHandlers();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detectHandlers</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">ApplicationContext applicationContext = obtainApplicationContext();</span><br><span class="line">String[] beanNames = (<span class="hljs-keyword">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">applicationContext.getBeanNamesForType(Object.class));</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">registerHandler(urls, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractDetectingUrlHandlerMapping 重写了父类的 initApplicationContext 方法，并在该方法中调用了 detectHandlers 方法，在 detectHandlers 中，首先查找到所有的 beanName，然后调用 determineUrlsForHandler 方法分析出 beanName 对应的 URL，不过这里的 determineUrlsForHandler 方法是一个空方法，具体的实现在它的子类中，AbstractDetectingUrlHandlerMapping 只有一个子类 BeanNameUrlHandlerMapping，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanNameUrlHandlerMapping</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDetectingUrlHandlerMapping</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">List&lt;String&gt; urls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (beanName.startsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">urls.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">String[] aliases = obtainApplicationContext().getAliases(beanName);</span><br><span class="line"><span class="hljs-keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (alias.startsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">urls.add(alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> StringUtils.toStringArray(urls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类很简单，里边就一个 determineUrlsForHandler 方法，这个方法的执行逻辑也很简单，就判断 beanName 是不是以 <code>/</code> 开始，如果是，则将之作为 URL。</p><p>如果我们想要在项目中使用 BeanNameUrlHandlerMapping，配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.init.HelloController"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"/hello"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"handlerMapping"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，Controller 的 name 必须是以 <code>/</code> 开始，否则该 bean 不会被自动作为处理器。</p><p>至此，AbstractUrlHandlerMapping 体系下的东西就和大家分享完了。</p><h2 id="4-AbstractHandlerMethodMapping"><a href="#4-AbstractHandlerMethodMapping" class="headerlink" title="4.AbstractHandlerMethodMapping"></a>4.AbstractHandlerMethodMapping</h2><p>AbstractHandlerMethodMapping 体系下只有三个类，分别是 AbstractHandlerMethodMapping、RequestMappingInfoHandlerMapping 以及 RequestMappingHandlerMapping，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210307171135.png" alt></p><p>在前面第三小节的 AbstractUrlHandlerMapping 体系下，一个 Handler 一般就是一个类，但是在 AbstractHandlerMethodMapping 体系下，一个 Handler 就是一个 Mehtod，这也是我们目前使用 SpringMVC 时最常见的用法，即直接用 @RequestMapping 去标记一个方法，该方法就是一个 Handler。</p><p>接下来我们就一起来看看 AbstractHandlerMethodMapping。</p><h3 id="4-1-初始化流程"><a href="#4-1-初始化流程" class="headerlink" title="4.1 初始化流程"></a>4.1 初始化流程</h3><p>AbstractHandlerMethodMapping 类实现了 InitializingBean 接口，所以 Spring 容器会自动调用其 afterPropertiesSet 方法，在这里将完成初始化操作：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerMethods</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">processCandidateBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">protected</span> String[] getCandidateBeanNames() &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</span><br><span class="line">obtainApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCandidateBean</span><span class="hljs-params">(String beanName)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; beanType = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (beanType != <span class="hljs-keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">detectHandlerMethods(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，具体的初始化又是在 initHandlerMethods 方法中完成的，在该方法中，首先调用 getCandidateBeanNames 方法获取容器中所有的 beanName，然后调用 processCandidateBean 方法对这些候选的 beanName 进行处理，具体的处理思路就是根据 beanName 找到 beanType，然后调用 isHandler 方法判断该 beanType 是不是一个 Handler，isHandler 是一个空方法，在它的子类 RequestMappingHandlerMapping 中被实现了，该方法主要是检查该 beanType 上有没有 <code>@Controller</code> 或者 <code>@RequestMapping</code> 注解，如果有，说明这就是我们想要的 handler，接下来再调用 detectHandlerMethods 方法保存 URL 和 handler 的映射关系：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detectHandlerMethods</span><span class="hljs-params">(Object handler)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; handlerType = (handler <span class="hljs-keyword">instanceof</span> String ?</span><br><span class="line">obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"><span class="hljs-keyword">if</span> (handlerType != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">userType.getName() + <span class="hljs-string">"]: "</span> + method, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先找到 handler 的类型 handlerType。</li><li>调用 ClassUtils.getUserClass 方法检查是否是 cglib 代理的子对象类型，如果是，则返回父类型，否则将参数直接返回。</li><li>接下来调用 MethodIntrospector.selectMethods 方法获取当前 bean 中所有符合要求的 method。</li><li>遍历 methods，调用 registerHandlerMethod 方法完成注册。</li></ol><p>上面这段代码里又涉及到两个方法：</p><ul><li>getMappingForMethod</li><li>registerHandlerMethod</li></ul><p>我们分别来看：</p><p><strong>getMappingForMethod</strong></p><p>getMappingForMethod 是一个模版方法，具体的实现也是在子类 RequestMappingHandlerMapping 里边：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> RequestMappingInfo <span class="hljs-title">getMappingForMethod</span><span class="hljs-params">(Method method, Class&lt;?&gt; handlerType)</span> </span>&#123;</span><br><span class="line">RequestMappingInfo info = createRequestMappingInfo(method);</span><br><span class="line"><span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);</span><br><span class="line"><span class="hljs-keyword">if</span> (typeInfo != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">info = typeInfo.combine(info);</span><br><span class="line">&#125;</span><br><span class="line">String prefix = getPathPrefix(handlerType);</span><br><span class="line"><span class="hljs-keyword">if</span> (prefix != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">info = RequestMappingInfo.paths(prefix).options(<span class="hljs-keyword">this</span>.config).build().combine(info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据 method 对象，调用 createRequestMappingInfo 方法获取一个 RequestMappingInfo，一个 RequestMappingInfo 包含了一个接口定义的详细信息，例如参数、header、produces、consumes、请求方法等等信息都在这里边。接下来再根据 handlerType 也获取一个 RequestMappingInfo，并调用 combine 方法将两个 RequestMappingInfo 进行合并。接下来调用 getPathPrefix 方法查看 handlerType 上有没有 URL 前缀，如果有，就添加到 info 里边去，最后将 info 返回。</p><p>这里要说一下 handlerType 里边的这个前缀是那里来的，我们可以在 Controller 上使用 <code>@RequestMapping</code> 注解，配置一个路径前缀，这样 Controller 中的所有方法都加上了该路径前缀，但是这种方式需要一个一个的配置，如果想一次性配置所有的 Controller 呢？我们可以使用 Spring5.1 中新引入的方法 addPathPrefix 来配置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.setPatternParser(<span class="hljs-keyword">new</span> PathPatternParser()).addPathPrefix(<span class="hljs-string">"/itboyhub"</span>, HandlerTypePredicate.forAnnotation(RestController.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个配置表示，所有的 <code>@RestController</code> 标记的类都自动加上 <code>itboyhub</code> 前缀。有了这个配置之后，上面的 getPathPrefix 方法获取到的就是 <code>/itboyhub</code> 了。</p><p><strong>registerHandlerMethod</strong></p><p>当找齐了 URL 和 handlerMethod 之后，接下来就是将这些信息保存下来，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHandlerMethod</span><span class="hljs-params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">Set&lt;String&gt; directPaths = AbstractHandlerMethodMapping.<span class="hljs-keyword">this</span>.getDirectPaths(mapping);</span><br><span class="line"><span class="hljs-keyword">for</span> (String path : directPaths) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.pathLookup.add(path, mapping);</span><br><span class="line">&#125;</span><br><span class="line">String name = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (getNamingStrategy() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">addMappingName(name, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line"><span class="hljs-keyword">if</span> (corsConfig != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">corsConfig.validateAllowCredentials();</span><br><span class="line"><span class="hljs-keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.registry.put(mapping,</span><br><span class="line"><span class="hljs-keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directPaths, name, corsConfig != <span class="hljs-keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 createHandlerMethod 方法创建 HandlerMethod 对象。</li><li>调用 validateMethodMapping 方法对 handlerMethod 进行验证，主要是验证 handlerMethod 是否已经存在。</li><li>从 mappings 中提取出 directPaths，就是不包含通配符的请求路径，然后将请求路径和 mapping 的映射关系保存到 pathLookup 中。</li><li>找到所有 handler 的简称，调用 addMappingName 方法添加到 nameLookup 中。例如我们在 HelloController 中定义了一个名为 hello 的请求接口，那么这里拿到的就是 <code>HC#hello</code>，HC 是 HelloController 中的大写字母。</li><li>初始化跨域配置，并添加到 corsLookup 中。</li><li>将构建好的关系添加到 registry 中。</li></ol><p>多说一句，第四步这个东西有啥用呢？这个其实是 Spring4 中开始增加的功能，算是一个小彩蛋吧，虽然日常开发很少用，但是我这里还是和大家说一下。</p><p>假如你有如下一个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/javaboy"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/aaa"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello99</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"aaa"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你请求该接口的时候，不想通过路径，想直接通过方法名，行不行呢？当然可以！</p><p>在 jsp 文件中，添加如下超链接：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="hljs-string">"s"</span> uri=<span class="hljs-string">"http://www.springframework.org/tags"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="hljs-string">"text/html;charset=UTF-8"</span> language=<span class="hljs-string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href="$&#123;s:mvcUrl('HC#hello99').build()&#125;"&gt;Go!&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当这个 jsp 页面渲染完成后，href 属性就自动成了 hello99 方法的请求路径了。这个功能的实现，就依赖于前面第四步的内容。</p><p>至此，我们就把 AbstractHandlerMethodMapping 的初始化流程看完了。</p><h3 id="4-2-请求处理"><a href="#4-2-请求处理" class="headerlink" title="4.2 请求处理"></a>4.2 请求处理</h3><p>接下来我们来看下当请求到来后，AbstractHandlerMethodMapping 会如何处理。</p><p>和前面第三小节一样，这里处理请求的入口方法也是 getHandlerInternal，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title">getHandlerInternal</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String lookupPath = initLookupPath(request);</span><br><span class="line"><span class="hljs-keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line"><span class="hljs-keyword">return</span> (handlerMethod != <span class="hljs-keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title">lookupHandlerMethod</span><span class="hljs-params">(String lookupPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;Match&gt; matches = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;T&gt; directPathMatches = <span class="hljs-keyword">this</span>.mappingRegistry.getMappingsByDirectPath(lookupPath);</span><br><span class="line"><span class="hljs-keyword">if</span> (directPathMatches != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">addMatchingMappings(<span class="hljs-keyword">this</span>.mappingRegistry.getRegistrations().keySet(), matches, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">Match bestMatch = matches.get(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (matches.size() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">Comparator&lt;Match&gt; comparator = <span class="hljs-keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">matches.sort(comparator);</span><br><span class="line">bestMatch = matches.get(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Match match : matches) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (match.hasCorsConfig()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Match secondBestMatch = matches.get(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">Method m1 = bestMatch.getHandlerMethod().getMethod();</span><br><span class="line">Method m2 = secondBestMatch.getHandlerMethod().getMethod();</span><br><span class="line">String uri = request.getRequestURI();</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"Ambiguous handler methods mapped for '"</span> + uri + <span class="hljs-string">"': &#123;"</span> + m1 + <span class="hljs-string">", "</span> + m2 + <span class="hljs-string">"&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.getHandlerMethod());</span><br><span class="line">handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line"><span class="hljs-keyword">return</span> bestMatch.getHandlerMethod();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleNoMatch(<span class="hljs-keyword">this</span>.mappingRegistry.getRegistrations().keySet(), lookupPath, request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就比较容易，通过 lookupHandlerMethod 找到对应的 HandlerMethod 返回即可，如果 lookupHandlerMethod 方法返回值不为 null，则通过 createWithResolvedBean 创建 HandlerMethod（主要是确认里边的 Bean 等），具体的创建过程松哥在后面的文章中会专门和大家分享。lookupHandlerMethod 方法也比较容易：</p><ol><li>首先根据 lookupPath 找到匹配条件 directPathMatches，然后将获取到的匹配条件添加到 matches 中（不包含通配符的请求走这里）。</li><li>如果 matches 为空，说明根据 lookupPath 没有找到匹配条件，那么直接将所有匹配条件加入 matches 中（包含通配符的请求走这里）。</li><li>对 matches 进行排序，并选择排序后的第一个为最佳匹配项，如果前两个排序相同，则抛出异常。</li></ol><p>大致的流程就是这样，具体到请求并没有涉及到它的子类。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>SpringMVC 九大组件，今天和小伙伴们把 HandlerMapping 过了一遍，其实只要认真看，这里并没有难点。如果小伙伴们觉得阅读吃力，也可以在公众号后台回复 ssm，查看松哥录制的免费入门教程～</p><p>剩下的八大组件源码解析，小伙伴们敬请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面跟小伙伴们分享了 SpringMVC 一个大致的初始化流程以及请求的大致处理流程，在请求处理过程中，涉及到九大组件，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HandlerMapping&lt;/li&gt;
&lt;li&gt;HandlerAdapter&lt;/li&gt;
&lt;li&gt;HandlerExceptionResolver&lt;/li&gt;
&lt;li&gt;ViewResolver&lt;/li&gt;
&lt;li&gt;RequestToViewNameTranslator&lt;/li&gt;
&lt;li&gt;LocaleResolver&lt;/li&gt;
&lt;li&gt;ThemeResolver&lt;/li&gt;
&lt;li&gt;MultipartResolver&lt;/li&gt;
&lt;li&gt;FlashMapManager&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 源码分析之 DispatcherServlet</title>
    <link href="http://www.javaboy.org/2021/0324/springmvc-dispatcherservlet.html"/>
    <id>http://www.javaboy.org/2021/0324/springmvc-dispatcherservlet.html</id>
    <published>2021-03-24T03:27:25.000Z</published>
    <updated>2021-03-24T03:28:32.423Z</updated>
    
    <content type="html"><![CDATA[<p>前面松哥和大家聊了 DispatcherServlet 的父类 FrameworkServlet，大家从中了解到在 DispatcherServlet 中，方法执行的入口应该是 doService。如果小伙伴们还没看前面的分析，可以先看下，这有助于理解本文，传送门<a href="https://mp.weixin.qq.com/s/uXN93XkXflSefqejWwj1NA" target="_blank" rel="noopener">SpringMVC 源码分析之 FrameworkServlet</a>。</p><a id="more"></a><p>即使你没看过 DispatcherServlet 的源码，估计也听说过：DispatcherServlet 是 SpringMVC 的大脑，它负责整个 SpringMVC 的调度工作，是 SpringMVC 中最最核心的类，SpringMVC 整个顶层架构设计都体现在这里，所以搞明白 DispatcherServlet 的源码，基本上 SpringMVC 的工作原理也就了然于胸了。</p><p>经过<a href="https://mp.weixin.qq.com/s/uXN93XkXflSefqejWwj1NA" target="_blank" rel="noopener">上篇文章</a>的分析，大家已经知道 DispatcherServlet 的入口方法是 doService，所以今天我们就从 doService 方法开始看起，松哥将带领大家，一步一步揭开 DispatcherServlet 的面纱。</p><h2 id="doService"><a href="#doService" class="headerlink" title="doService"></a>doService</h2><p>先来看 doService，把源码先贴上来，然后我们逐步分析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">logRequest(request);</span><br><span class="line"><span class="hljs-comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line"><span class="hljs-comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">attributesSnapshot = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line"><span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">String attrName = (String) attrNames.nextElement();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.localeResolver);</span><br><span class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.themeResolver);</span><br><span class="line">request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);</span><br><span class="line">&#125;</span><br><span class="line">RequestPath previousRequestPath = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parseRequestPath) &#123;</span><br><span class="line">previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);</span><br><span class="line">ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">doDispatch(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码并不长，我们来稍微分析一下：</p><ol><li>首先判断当前请求是不是 include 请求，如果是 include，则对 request 的 attribute 做一个快照备份，在最后的 finally 中再对备份的属性进行还原。</li><li>接下来对 request 设置一些常见属性，例如应用上下文、国际化的解析器、主题解析器等等，这些东西在初始化的时候已经准备好了，这里只是应用（初始化过程参见<a href="https://mp.weixin.qq.com/s/IeMOfnXhOX5RCf4i5Xsdzw" target="_blank" rel="noopener">SpringMVC 初始化流程分析</a>一文）。</li><li>接下来处理 flashMap，如果存在 flashMap 则进行复原，这一块松哥在之前的文章中和小伙伴们已经分享过了，传送门<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>。</li><li>接下来处理 RequestPath，将请求路径对象化以备后续使用（在后面的请求映射匹配时会用到）。</li><li>调用 doDispatch 方法进行下一步处理。</li><li>还原快照属性、还原 RequestPath。</li></ol><p>所以说这段代码并不难理解，它的核心在于 doDispatch 方法，所以接下来我们就来看看 doDispatch 方法。</p><h2 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch"></a>doDispatch</h2><p>doDispatch 方法所做的事情就比较多了，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">boolean</span> multipartRequestParsed = <span class="hljs-keyword">false</span>;</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="hljs-keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"><span class="hljs-comment">// Determine handler for the current request.</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"><span class="hljs-comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="hljs-keyword">boolean</span> isGet = <span class="hljs-string">"GET"</span>.equals(method);</span><br><span class="line"><span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="hljs-keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"><span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="hljs-comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较长，涉及到很多组件的处理，这里松哥先和大家把思路梳理畅通，各个组件的详细用法松哥将在以后的文章中和大家仔细分享。</p><p>doDispatch 方法其实主要做了两方面的事情：请求处理以及页面渲染，我们先来看看初始变量的含义：</p><ol><li>processedRequest：这个用来保存实际上所用的 request 对象，在后面的流程中会对当前 request 对象进行检查，如果是文件上传请求，则会对请求重新进行封装，如果不是文件上传请求，则继续使用原来的请求。</li><li>mappedHandler：这是具体处理请求的处理器链，处理器链包含两方面的东西：请求处理器和对应的 Interceptor。</li><li>multipartRequestParsed：表示是否是文件上传请求的标记。</li><li>asyncManager：这是一个异步请求管理器。</li><li>mv：这是最终渲染返回的 ModelAndView 对象。</li><li>dispatchException：表示请求处理过程中所抛出的异常，这个异常不包括渲染过程抛出的异常。</li></ol><p>接下来再来看看具体的处理逻辑：</p><ol><li>首先通过 checkMultipart 检查是不是文件上传请求，如果是，则对当前 request 重新进行包装，如果不是，则直接将参数返回。</li><li>如果 processedRequest 不等于 request，则说明当前请求是文件上传请求（request 在 checkMultipart 方法中被重新封装了），否则说明当前请求不是文件上传请求。</li><li>根据当前请求，调用 getHandler 方法获取请求处理器，如果没找到对应的请求处理器，则调用 noHandlerFound 方法抛出异常或者给出 404。</li><li>接下来再调用 getHandlerAdapter 方法，根据当前的处理器找到处理器适配器。</li><li>然后处理 GET 和 HEAD 请求头的 Last_Modified 字段。当浏览器第一次发起 GET 或者 HEAD 请求时，请求的响应头中包含一个 Last-Modified 字段，这个字段表示该资源最后一次修改时间，以后浏览器再次发送 GET、HEAD 请求时，都会携带上该字段，服务端收到该字段之后，和资源的最后一次修改时间进行对比，如果资源还没有过期，则直接返回 304 告诉浏览器之前的资源还是可以继续用的，如果资源已经过期，则服务端会返回新的资源以及新的 Last-Modified。</li><li>接下来调用拦截器的 preHandle 方法，如果该方法返回 false，则直接 return 掉当前请求（拦截器的用法大家可以参考松哥之前录的免费的 SpringMVC 视频教程，里边有讲，传送门<a href="https://mp.weixin.qq.com/s/KONEIdt_c3Di1zMlXGLxuw" target="_blank" rel="noopener">硬核！松哥又整了一套免费视频，搞起！</a>）。</li><li>接下来执行 <code>ha.handle</code> 去调用真正的请求，获取到返回结果 mv。</li><li>接下来判断当前请求是否需要异步处理，如果需要，则直接 return 掉。</li><li>如果不需要异步处理，则执行 applyDefaultViewName 方法，检查当前 mv 是否没有视图，如果没有（例如方法返回值为 void），则给一个默认的视图名。</li><li>接下来调用 applyPostHandle 方法执行拦截器里边的 postHandle 方法。</li><li>接下来调用 processDispatchResult 方法对执行结果进行处理，包括异常处理、渲染页面以及执行拦截器的 afterCompletion 方法都在这里完成。</li><li>最后在 finally 代码块中判断是否开启了异步处理，如果开启了，则调用相应的拦截器；如果请求是文件上传请求，则再调用 cleanupMultipart 方法清除文件上传过程产生的一些临时文件。</li></ol><p>这是 doDispatch 方法的一个大致执行逻辑，doDispatch 里边的 try-catch 有两层，最里边那一层，抛出来的异常会被赋值给 dispatchException 变量，这些异常最终在 processDispatchResult 方法中被处理掉，外面的异常则是 processDispatchResult 方法在执行的过程中抛出的异常，一般来说主要是页面渲染时候的异常。</p><h2 id="processDispatchResult"><a href="#processDispatchResult" class="headerlink" title="processDispatchResult"></a>processDispatchResult</h2><p>最后我们再来看下 processDispatchResult 方法的执行逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Exception exception)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> errorView = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Object handler = (mappedHandler != <span class="hljs-keyword">null</span> ? mappedHandler.getHandler() : <span class="hljs-keyword">null</span>);</span><br><span class="line">mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">errorView = (mv != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Did the handler return a view to render?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (mv != <span class="hljs-keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">render(mv, request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (errorView) &#123;</span><br><span class="line">WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Concurrent handling started during a forward</span></span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Exception (if any) is already handled..</span></span><br><span class="line">mappedHandler.triggerAfterCompletion(request, response, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 processDispatchResult 方法中首先对异常进行了处理，配置好异常对应的 ModelAndView，然后调用 render 方法对页面进行渲染，最后通过 triggerAfterCompletion 方法去触发拦截器的 afterCompletion 方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们就把一个请求的大致流程和大家梳理完了，松哥画了一张流程图我们一起来看下：</p><p><img src="http://img.itboyhub.com/2021/02/jkdfajkldfjkl74857829djnfklsk.png" alt></p><p>这下相信大家对 doDispatch 方法比较熟悉了，当然这里还涉及到很多组件，这些组件松哥将在后面的文章中和大家逐一进行分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面松哥和大家聊了 DispatcherServlet 的父类 FrameworkServlet，大家从中了解到在 DispatcherServlet 中，方法执行的入口应该是 doService。如果小伙伴们还没看前面的分析，可以先看下，这有助于理解本文，传送门&lt;a href=&quot;https://mp.weixin.qq.com/s/uXN93XkXflSefqejWwj1NA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringMVC 源码分析之 FrameworkServlet&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 源码分析之 FrameworkServlet</title>
    <link href="http://www.javaboy.org/2021/0323/springmvc-frameworkservlet.html"/>
    <id>http://www.javaboy.org/2021/0323/springmvc-frameworkservlet.html</id>
    <published>2021-03-23T00:37:53.000Z</published>
    <updated>2021-03-23T00:39:00.002Z</updated>
    
    <content type="html"><![CDATA[<p>前面和小伙伴们聊了 SpringMVC 的初始化流程，相信大家对于 SpringMVC 的初始化过程都有一个基本认知了，今天我们就来看看当一个请求到达后，它的执行流程是什么样的？当然这个流程比较长，松哥这里可能会分两篇文章来和大家分享。</p><a id="more"></a><p>很多小伙伴都知道 SpringMVC 的核心是 DispatcherServlet，而 DispatcherServlet 的父类就是 FrameworkServlet，因此我们先来看看 FrameworkServlet，这有助于我们理解 DispatcherServlet。</p><h2 id="1-FrameworkServlet"><a href="#1-FrameworkServlet" class="headerlink" title="1.FrameworkServlet"></a>1.FrameworkServlet</h2><p>FrameworkServlet 继承自 HttpServletBean，而 HttpServletBean 继承自 HttpServlet，HttpServlet 就是 JavaEE 里边的东西了，这里我们不做讨论，从 HttpServletBean 开始就是框架的东西了，但是 HttpServletBean 比较特殊，它的特殊在于它没有进行任何的请求处理，只是参与了一些初始化的操作，这些比较简单，而且我们在上篇文章中也已经分析过了，所以这里我们对 HttpServletBean 不做分析，就直接从它的子类 FrameworkServlet 开始看起。</p><p><img src="http://img.itboyhub.com/2021/02/20210301214050.png" alt></p><p>和所有的 Servlet 一样，FrameworkServlet 对请求的处理也是从 service 方法开始，我们先来看看该方法 FrameworkServlet#service：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="hljs-keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在该方法中，首先获取到当前请求方法，然后对 patch 请求额外关照了下，其他类型的请求统统都是 super.service 进行处理。</p><p>然而在 HttpServlet 中并未对 doGet、doPost 等请求进行实质性处理，所以 FrameworkServlet 中还重写了各种请求对应的方法，如 doDelete、doGet、doOptions、doPost、doPut、doTrace 等，其实就是除了 doHead 之外的其他方法都重写了。</p><p>我们先来看看 doDelete、doGet、doPost 以及 doPut 四个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPut</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDelete</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里又把请求交给 processRequest 去处理了，在 processRequest 方法中则会进一步调用到 doService，对不同类型的请求分类处理。</p><p>doOptions 和 doTrace 则稍微有些差异，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOptions</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (response.containsHeader(<span class="hljs-string">"Allow"</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">super</span>.doOptions(request, <span class="hljs-keyword">new</span> HttpServletResponseWrapper(response) &#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String name, String value)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-string">"Allow"</span>.equals(name)) &#123;</span><br><span class="line">value = (StringUtils.hasLength(value) ? value + <span class="hljs-string">", "</span> : <span class="hljs-string">""</span>) + HttpMethod.PATCH.name();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">super</span>.setHeader(name, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTrace</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dispatchTraceRequest) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-string">"message/http"</span>.equals(response.getContentType())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">super</span>.doTrace(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这两个方法的处理多了一层逻辑，就是去选择是在当前方法中处理对应的请求还是交给父类去处理，由于 dispatchOptionsRequest 和 dispatchTraceRequest 变量默认都是 false，因此默认情况下，这两种类型的请求都是交给了父类去处理。</p><h2 id="2-processRequest"><a href="#2-processRequest" class="headerlink" title="2.processRequest"></a>2.processRequest</h2><p>我们再来看 processRequest，这算是 FrameworkServlet 的核心方法了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">Throwable failureCause = <span class="hljs-keyword">null</span>;</span><br><span class="line">LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line">RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="hljs-keyword">new</span> RequestBindingInterceptor());</span><br><span class="line">initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">doService(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Request processing failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line"><span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">requestAttributes.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">logResult(request, response, failureCause, asyncManager);</span><br><span class="line">publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法虽然比较长，但是其实它的核心就是最中间的 doService 方法，以 doService 为界，我们可以将该方法的内容分为三部分：</p><ol><li>doService 之前主要是一些准备工作，准备工作主要干了两件事，第一件事就是从 LocaleContextHolder 和 RequestContextHolder 中分别获取它们原来保存的 LocaleContext 和 RequestAttributes 对象存起来，然后分别调用 buildLocaleContext 和 buildRequestAttributes 方法获取到当前请求的 LocaleContext 和 RequestAttributes 对象，再通过 initContextHolders 方法将当前请求的 LocaleContext 和 RequestAttributes 对象分别设置到 LocaleContextHolder 和 RequestContextHolder 对象中；第二件事则是获取到异步管理器并设置拦截器。</li><li>接下来就是 doService 方法，这是一个抽象方法，具体的实现在 DispatcherServlet 中，这个松哥放到 DispatcherServlet 中再和大家分析。</li><li>第三部分就是 finally 中，这个里边干了两件事：第一件事就是将 LocaleContextHolder 和 RequestContextHolder 中对应的对象恢复成原来的样子（参考第一步）；第二件事就是通过 publishRequestHandledEvent 方法发布一个 ServletRequestHandledEvent 类型的消息。</li></ol><p>经过上面的分析，大家发现，processRequest 其实主要做了两件事，第一件事就是对 LocaleContext 和 RequestAttributes 的处理，第二件事就是发布事件。我们对这两件事分别来研究。</p><h3 id="2-1-LocaleContext-和-RequestAttributes"><a href="#2-1-LocaleContext-和-RequestAttributes" class="headerlink" title="2.1 LocaleContext 和 RequestAttributes"></a>2.1 LocaleContext 和 RequestAttributes</h3><p>LocaleContext 和 RequestAttributes 都是接口，不同的是里边存放的对象不同。</p><h4 id="2-1-1-LocaleContext"><a href="#2-1-1-LocaleContext" class="headerlink" title="2.1.1 LocaleContext"></a>2.1.1 LocaleContext</h4><p>LocaleContext 里边存放着 Locale，也就是本地化信息，如果我们需要支持国际化，就会用到 Locale。</p><p>国际化的时候，如果我们需要用到 Locale 对象，第一反应就是从 HttpServletRequest 中获取，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Locale locale = req.getLocale();</span><br></pre></td></tr></table></figure><p>但是大家知道，HttpServletRequest 只存在于 Controller 中，如果我们想要在 Service 层获取 HttpServletRequest，就得从 Controller 中传参数过来，这样就比较麻烦，特别是有的时候 Service 中相关方法都已经定义好了再去修改，就更头大了。</p><p>所以 SpringMVC 中还给我们提供了 LocaleContextHolder，这个工具就是用来保存当前请求的 LocaleContext 的。当大家看到 LocaleContextHolder 时不知道有没有觉得眼熟，松哥在之前的 Spring Security 系列教程中和大家聊过 SecurityContextHolder，这两个的原理基本一致，都是基于 ThreadLocal 来保存变量，进而确保不同线程之间互不干扰，对 ThreadLocal 不熟悉的小伙伴，可以看看松哥的 Spring Security 系列，之前有详细分析过（公号后台回复 ss）。</p><p>有了 LocaleContextHolder 之后，我们就可以在任何地方获取 Locale 了，例如在 Service 中我们可以通过如下方式获取 Locale：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Locale locale = LocaleContextHolder.getLocale();</span><br></pre></td></tr></table></figure><p>上面这个 Locale 对象实际上就是从 LocaleContextHolder 中的 LocaleContext 里边取出来的。</p><blockquote><p>需要注意的是，SpringMVC 中还有一个 LocaleResolver 解析器，所以前面 req.getLocale() 并不总是获取到 Locale 的值，这个松哥在以后的文章中再和小伙伴们细聊。</p></blockquote><h4 id="2-1-2-RequestAttributes"><a href="#2-1-2-RequestAttributes" class="headerlink" title="2.1.2 RequestAttributes"></a>2.1.2 RequestAttributes</h4><p>RequestAttributes 是一个接口，这个接口可以用来 get/set/remove 某一个属性。</p><p>RequestAttributes 有诸多实现类，默认使用的是 ServletRequestAttributes，通过 ServletRequestAttributes，我们可以 getRequest、getResponse 以及 getSession。</p><p>在 ServletRequestAttributes 的具体实现中，会通过 scope 参数判断操作 request 还是操作 session（如果小伙伴们不记得 Spring 中的作用域问题，可以公号后台回复 spring，看看松哥录制的免费的 Spring 入门教程，里边有讲），我们来看一下 ServletRequestAttributes#setAttribute 方法（get/remove 方法执行逻辑类似）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, Object value, <span class="hljs-keyword">int</span> scope)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (scope == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isRequestActive()) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot set request attribute - request is not active anymore!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">this</span>.request.setAttribute(name, value);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        HttpSession session = <span class="hljs-keyword">this</span>.obtainSession();</span><br><span class="line">        <span class="hljs-keyword">this</span>.sessionAttributesToUpdate.remove(name);</span><br><span class="line">        session.setAttribute(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里会先判断 scope，scope 为 0 就操作 request，scope 为 1 就操作 session。如果操作的是 request，则需要首先通过 isRequestActive 方法判断当前 request 是否执行完毕，如果执行完毕，就不可以再对其进行其他操作了（当执行了 finally 代码块中的 requestAttributes.requestCompleted 方法后，isRequestActive 就会返回 false）。</p><p>和 LocaleContext 类似，RequestAttributes 被保存在 RequestContextHolder 中，RequestContextHolder 的原理也和 SecurityContextHolder 类似，这里不再赘述。</p><p>看了上面的讲解，大家应该发现了，在 SpringMVC 中，如果我们需要在 Controller 之外的其他地方使用 request、response 以及 session，其实不用每次都从 Controller 中传递 request、response 以及 session 等对象，我们完全可以直接通过 RequestContextHolder 来获取，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">HttpServletRequest request = servletRequestAttributes.getRequest();</span><br><span class="line">HttpServletResponse response = servletRequestAttributes.getResponse();</span><br></pre></td></tr></table></figure><p>是不是非常 easy！</p><h3 id="2-2-事件发布"><a href="#2-2-事件发布" class="headerlink" title="2.2 事件发布"></a>2.2 事件发布</h3><p>最后就是 processRequest 方法中的事件发布了。</p><p>在 finally 代码块中会调用 publishRequestHandledEvent 方法发送一个 ServletRequestHandledEvent 类型的事件，具体发送代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishRequestHandledEvent</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span> startTime, @Nullable Throwable failureCause)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.publishEvents &amp;&amp; <span class="hljs-keyword">this</span>.webApplicationContext != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Whether or not we succeeded, publish an event.</span></span><br><span class="line"><span class="hljs-keyword">long</span> processingTime = System.currentTimeMillis() - startTime;</span><br><span class="line"><span class="hljs-keyword">this</span>.webApplicationContext.publishEvent(</span><br><span class="line"><span class="hljs-keyword">new</span> ServletRequestHandledEvent(<span class="hljs-keyword">this</span>,</span><br><span class="line">request.getRequestURI(), request.getRemoteAddr(),</span><br><span class="line">request.getMethod(), getServletConfig().getServletName(),</span><br><span class="line">WebUtils.getSessionId(request), getUsernameForRequest(request),</span><br><span class="line">processingTime, failureCause, response.getStatus()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，事件的发送需要 publishEvents 为 true，而该变量默认就是 true。如果需要修改该变量的值，可以在 web.xml 中配置 DispatcherServlet 时，通过 init-param 节点顺便配置一下该变量的值。正常情况下，这个事件总是会被发送出去，如果项目有需要，我们可以监听该事件，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletRequestHandleListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ServletRequestHandledEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ServletRequestHandledEvent servletRequestHandledEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"请求执行完毕-"</span>+servletRequestHandledEvent.getRequestUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个请求执行完毕时，该事件就会被触发。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>这篇文章主要和小伙伴们分享了 SpringMVC 中 DispatcherServlet 的父类 FrameworkServlet，FrameworkServlet 的功能其实比较简单，主要就是在 service 方法中增加了对 PATCH 的处理，然后其他类型的请求都被归类到 processRequest 方法中进行统一处理，processRequest 方法则又分了三部分，首先是对 LocaleContext 和 RequestAttributes 的处理，然后执行 doService，最后在 finally 代码块中对 LocaleContext 和 RequestAttributes 属性进行复原，同时发布一个请求结束的事件。</p><p>doService 是重头戏，松哥将在下篇文章中和大家分享。好啦，今天就先和小伙伴们聊这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和小伙伴们聊了 SpringMVC 的初始化流程，相信大家对于 SpringMVC 的初始化过程都有一个基本认知了，今天我们就来看看当一个请求到达后，它的执行流程是什么样的？当然这个流程比较长，松哥这里可能会分两篇文章来和大家分享。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中如何统一 API 接口响应格式？</title>
    <link href="http://www.javaboy.org/2021/0319/spring-boot-handler-method-return-value-handler.html"/>
    <id>http://www.javaboy.org/2021/0319/spring-boot-handler-method-return-value-handler.html</id>
    <published>2021-03-19T05:56:09.000Z</published>
    <updated>2021-03-22T05:58:54.797Z</updated>
    
    <content type="html"><![CDATA[<p>今天又要给大家介绍一个 Spring Boot 中的组件–HandlerMethodReturnValueHandler。</p><a id="more"></a><p>在前面的文章中（<a href="https://mp.weixin.qq.com/s/LWuUNHJVnBLK15Msu38Wgw" target="_blank" rel="noopener">如何优雅的实现 Spring Boot 接口参数加密解密？</a>），松哥已经和大家介绍过如何对请求/响应数据进行预处理/二次处理，当时我们使用了 ResponseBodyAdvice 和 RequestBodyAdvice。其中 ResponseBodyAdvice 可以实现对响应数据的二次处理，可以在这里对响应数据进行加密/包装等等操作。不过这不是唯一的方案，今天松哥要和大家介绍一种更加灵活的方案–HandlerMethodReturnValueHandler，我们一起来看看下。</p><h2 id="1-HandlerMethodReturnValueHandler"><a href="#1-HandlerMethodReturnValueHandler" class="headerlink" title="1.HandlerMethodReturnValueHandler"></a>1.HandlerMethodReturnValueHandler</h2><p>HandlerMethodReturnValueHandler 的作用是对处理器的处理结果再进行一次二次加工，这个接口里边有两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsReturnType：这个处理器是否支持相应的返回值类型。</li><li>handleReturnValue：对方法返回值进行处理。</li></ul><p>HandlerMethodReturnValueHandler 有很多默认的实现类，我们来看下：</p><p><img src="http://img.itboyhub.com/2021/02/20210317092534.png" alt></p><p>接下来我们来把这些实现类的作用捋一捋：</p><p><strong>ViewNameMethodReturnValueHandler</strong></p><p>这个处理器用来处理返回值为 void 和 String 的情况。如果返回值为 void，则不做任何处理。如果返回值为 String，则将 String 设置给 mavContainer 的 viewName 属性，同时判断这个 String 是不是重定向的 String，如果是，则设置 mavContainer 的 redirectModelScenario 属性为 true，这是处理器返回重定向视图的标志。</p><p><strong>ViewMethodReturnValueHandler</strong></p><p>这个处理器用来处理返回值为 View 的情况。如果返回值为 View，则将 View 设置给 mavContainer 的 view 属性，同时判断这个 View 是不是重定向的 View，如果是，则设置 mavContainer 的 redirectModelScenario 属性为 true，这是处理器返回重定向视图的标志。</p><p><strong>MapMethodProcessor</strong></p><p>这个处理器用来处理返回值类型为 Map 的情况，具体的处理方案就是将 map 添加到 mavContainer 的 model 属性中。</p><p><strong>StreamingResponseBodyReturnValueHandler</strong></p><p>这个用来处理 StreamingResponseBody 或者 <code>ResponseEntity&lt;StreamingResponseBody&gt;</code> 类型的返回值。</p><p><strong>DeferredResultMethodReturnValueHandler</strong></p><p>这个用来处理 DeferredResult、ListenableFuture 以及 CompletionStage 类型的返回值，用于异步请求。</p><p><strong>CallableMethodReturnValueHandler</strong></p><p>处理 Callable 类型的返回值，也是用于异步请求。</p><p><strong>HttpHeadersReturnValueHandler</strong></p><p>这个用来处理 HttpHeaders 类型的返回值，具体处理方式就是将 mavContainer 中的 requestHandled 属性设置为 true，该属性是请求是否已经处理完成的标志（如果处理完了，就到此为止，后面不会再去找视图了），然后将 HttpHeaders 添加到响应头中。</p><p><strong>ModelMethodProcessor</strong></p><p>这个用来处理返回值类型为 Model 的情况，具体的处理方式就是将 Model 添加到 mavContainer 的 model 上。</p><p><strong>ModelAttributeMethodProcessor</strong></p><p>这个用来处理添加了 <code>@ModelAttribute</code> 注解的返回值类型，如果 annotaionNotRequired 属性为 true，也可以用来处理其他非通用类型的返回值。</p><p><strong>ServletModelAttributeMethodProcessor</strong></p><p>同上，该类只是修改了参数解析方式。</p><p><strong>ResponseBodyEmitterReturnValueHandler</strong></p><p>这个用来处理返回值类型为 <code>ResponseBodyEmitter</code> 的情况。</p><p><strong>ModelAndViewMethodReturnValueHandler</strong></p><p>这个用来处理返回值类型为 <code>ModelAndView</code> 的情况，将返回值中的 Model 和 View 分别设置到 mavContainer 的相应属性上去。</p><p><strong>ModelAndViewResolverMethodReturnValueHandler</strong></p><p>这个的 supportsReturnType 方法返回 true，即可以处理所有类型的返回值，这个一般放在最后兜底。</p><p><strong>AbstractMessageConverterMethodProcessor</strong></p><p>这是一个抽象类，当返回值需要通过 HttpMessageConverter 进行转化的时候会用到它的子类。这个抽象类主要是定义了一些工具方法。</p><p><strong>RequestResponseBodyMethodProcessor</strong></p><p>这个用来处理添加了 <code>@ResponseBody</code> 注解的返回值类型。</p><p><strong>HttpEntityMethodProcessor</strong></p><p>这个用来处理返回值类型是 HttpEntity 并且不是 RequestEntity 的情况。</p><p><strong>AsyncHandlerMethodReturnValueHandler</strong></p><p>这是一个空接口，暂未发现典型使用场景。</p><p><strong>AsyncTaskMethodReturnValueHandler</strong></p><p>这个用来处理返回值类型为 WebAsyncTask 的情况。</p><p><strong>HandlerMethodReturnValueHandlerComposite</strong></p><p>看 Composite 就知道，这是一个组合处理器，没啥好说的。</p><p>这个就是系统默认定义的 HandlerMethodReturnValueHandler。</p><p>那么在上面的介绍中，大家看到反复涉及到一个组件 mavContainer，这个我也要和大家介绍一下。</p><h2 id="2-ModelAndViewContainer"><a href="#2-ModelAndViewContainer" class="headerlink" title="2.ModelAndViewContainer"></a>2.ModelAndViewContainer</h2><p>ModelAndViewContainer 就是一个数据穿梭巴士，在整个请求的过程中承担着数据传送的工作，从它的名字上我们可以看出来它里边保存着 Model 和 View 两种类型的数据，但是实际上可不止两种，我们来看下 ModelAndViewContainer 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelAndViewContainer</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ignoreDefaultModelOnRedirect = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> Object view;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ModelMap defaultModel = <span class="hljs-keyword">new</span> BindingAwareModelMap();</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> ModelMap redirectModel;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> redirectModelScenario = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> HttpStatus status;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; noBinding = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; bindingDisabled = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SessionStatus sessionStatus = <span class="hljs-keyword">new</span> SimpleSessionStatus();</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> requestHandled = <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这几个属性理解了，基本上也就整明白 ModelAndViewContainer 的作用了：</p><ul><li>defaultModel：默认使用的 Model。当我们在接口参数重使用 Model、ModelMap 或者 Map 时，最终使用的实现类都是 BindingAwareModelMap，对应的也都是 defaultModel。</li><li>redirectModel：重定向时候的 Model，如果我们在接口参数中使用了 RedirectAttributes 类型的参数，那么最终会传入 redirectModel。</li></ul><p>可以看到，一共有两个 Model，两个 Model 到底用哪个呢？这个在 getModel 方法中根据条件返回合适的 Model：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelMap <span class="hljs-title">getModel</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (useDefaultModel()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultModel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.redirectModel == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.redirectModel = <span class="hljs-keyword">new</span> ModelMap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.redirectModel;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">useDefaultModel</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (!<span class="hljs-keyword">this</span>.redirectModelScenario || (<span class="hljs-keyword">this</span>.redirectModel == <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.ignoreDefaultModelOnRedirect));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 redirectModelScenario 表示处理器是否返回 redirect 视图；ignoreDefaultModelOnRedirect 表示是否在重定向时忽略 defaultModel，所以这块的逻辑是这样：</p><ol><li>如果 redirectModelScenario 为 true，即处理器返回的是一个重定向视图，那么使用 redirectModel。如果 redirectModelScenario 为 false，即处理器返回的不是一个重定向视图，那么使用 defaultModel。</li><li>如果 redirectModel 为 null，并且 ignoreDefaultModelOnRedirect 为 false，则使用 redirectModel，否则使用 defaultModel。</li></ol><p>接下来还剩下如下一些参数：</p><ul><li>view：返回的视图。</li><li>status：HTTP 状态码。</li><li>noBinding：是否对 @ModelAttribute(binding=true/false) 声明的数据模型的相应属性进行绑定。</li><li>bindingDisabled：不需要进行数据绑定的属性。</li><li>sessionStatus：SessionAttribute 使用完成的标识。</li><li>requestHandled：请求处理完成的标识（例如添加了 <code>@ResponseBody</code> 注解的接口，这个属性为 true，请求就不会再去找视图了）。</li></ul><blockquote><p>这个 ModelAndViewContainer 小伙伴们权且做一个了解，松哥在后面的源码分析中，还会和大家再次聊到这个组件。</p></blockquote><p>接下来我们也来自定义一个 HandlerMethodReturnValueHandler，来感受一下 HandlerMethodReturnValueHandler 的基本用法。</p><h2 id="3-API-接口数据包装"><a href="#3-API-接口数据包装" class="headerlink" title="3.API 接口数据包装"></a>3.API 接口数据包装</h2><p>假设我有这样一个需求：我想在原始的返回数据外面再包裹一层，举个简单例子，本来接口是下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setAddress(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的数据格式是下面这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="hljs-attr">"username"</span>:<span class="hljs-string">"javaboy"</span>,<span class="hljs-attr">"address"</span>:<span class="hljs-string">"www.javaboy.org"</span>&#125;</span><br></pre></td></tr></table></figure><p>现在我希望返回的数据格式变成下面这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="hljs-attr">"status"</span>:<span class="hljs-string">"ok"</span>,<span class="hljs-attr">"data"</span>:&#123;<span class="hljs-attr">"username"</span>:<span class="hljs-string">"javaboy"</span>,<span class="hljs-attr">"address"</span>:<span class="hljs-string">"www.javaboy.org"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>就这样一个简单需求，我们一起来看下怎么实现。</p><h3 id="3-1-RequestResponseBodyMethodProcessor"><a href="#3-1-RequestResponseBodyMethodProcessor" class="headerlink" title="3.1 RequestResponseBodyMethodProcessor"></a>3.1 RequestResponseBodyMethodProcessor</h3><p>在开始定义之前，先给大家介绍一下 RequestResponseBodyMethodProcessor，这是 HandlerMethodReturnValueHandler 的实现类之一，这个主要用来处理返回 JSON 的情况。</p><p>我们来稍微看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||</span><br><span class="line">returnType.hasMethodAnnotation(ResponseBody.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);</span><br><span class="line">ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line">writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsReturnType：从这个方法中可以看到，这里支持有 <code>@ResponseBody</code> 注解的接口。</li><li>handleReturnValue：这是具体的处理逻辑，首先 mavContainer 中设置 requestHandled 属性为 true，表示这里处理完成后就完了，以后不用再去找视图了，然后分别获取 inputMessage 和 outputMessage，调用 writeWithMessageConverters 方法进行输出，writeWithMessageConverters 方法是在父类中定义的方法，这个方法比较长，核心逻辑就是调用确定输出数据、确定 MediaType，然后通过 HttpMessageConverter 将 JSON 数据写出去即可。</li></ul><p>有了上面的知识储备之后，接下来我们就可以自己实现了。</p><h3 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h3><p>首先自定义一个 HandlerMethodReturnValueHandler：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlerMethodReturnValueHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> HandlerMethodReturnValueHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHandlerMethodReturnValueHandler</span><span class="hljs-params">(HandlerMethodReturnValueHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> handler.supportsReturnType(returnType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="hljs-string">"status"</span>, <span class="hljs-string">"ok"</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"data"</span>, returnValue);</span><br><span class="line">        handler.handleReturnValue(map, returnType, mavContainer, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们要做的功能其实是在 RequestResponseBodyMethodProcessor 基础之上实现的，因为支持 <code>@ResponseBody</code>，输出 JSON 那些东西都不变，我们只是在输出之前修改一下数据而已。所以我这里直接定义了一个属性 HandlerMethodReturnValueHandler，这个属性的实例就是 RequestResponseBodyMethodProcessor，supportsReturnType 方法就按照 RequestResponseBodyMethodProcessor 的要求来，在 handleReturnValue 方法中，我们先对返回值进行一个预处理，然后调用 RequestResponseBodyMethodProcessor#handleReturnValue 方法继续输出 JSON 即可。</p><p>接下来就是配置 MyHandlerMethodReturnValueHandler 使之生效了。由于 SpringMVC 中 HandlerAdapter 在加载的时候已经配置了 HandlerMethodReturnValueHandler（这块松哥以后会和大家分析相关源码），所以我们可以通过如下方式对已经配置好的 RequestMappingHandlerAdapter 进行修改，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReturnValueConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RequestMappingHandlerAdapter requestMappingHandlerAdapter;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; originHandlers = requestMappingHandlerAdapter.getReturnValueHandlers();</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; newHandlers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(originHandlers.size());</span><br><span class="line">        <span class="hljs-keyword">for</span> (HandlerMethodReturnValueHandler originHandler : originHandlers) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (originHandler <span class="hljs-keyword">instanceof</span> RequestResponseBodyMethodProcessor) &#123;</span><br><span class="line">                newHandlers.add(<span class="hljs-keyword">new</span> MyHandlerMethodReturnValueHandler(originHandler));</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                newHandlers.add(originHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        requestMappingHandlerAdapter.setReturnValueHandlers(newHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 ReturnValueConfig 实现 InitializingBean 接口，afterPropertiesSet 方法会被自动调用，在该方法中，我们将 RequestMappingHandlerAdapter 中已经配置好的 HandlerMethodReturnValueHandler 拎出来挨个检查，如果类型是 RequestResponseBodyMethodProcessor，则重新构建，用我们自定义的 MyHandlerMethodReturnValueHandler 代替它，最后给 requestMappingHandlerAdapter 重新设置 HandlerMethodReturnValueHandler 即可。</p><p>最后再提供一个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setAddress(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-comment">//省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，就可以启动项目啦。</p><p>项目启动成功后，访问 <code>/user</code> 接口，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210317203148.png" alt></p><p>完美。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>其实统一 API 接口响应格式办法很多，可以参考松哥之前分享的 <a href="https://mp.weixin.qq.com/s/LWuUNHJVnBLK15Msu38Wgw" target="_blank" rel="noopener">如何优雅的实现 Spring Boot 接口参数加密解密？</a>，也可以使用本文中的方案，甚至也可以自定义过滤器实现。</p><p>本文的内容稍微有点多，不知道大家有没有发现松哥最近发了很多 SpringMVC 源码相关的东西，没错，本文其实是松哥 SpringMVC 源码解析的一部分，为了源码解析不那么枯燥，所以强行加了一个案例进来，祝小伙伴们学习愉快～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天又要给大家介绍一个 Spring Boot 中的组件–HandlerMethodReturnValueHandler。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>深入分析 SpringMVC 参数解析器</title>
    <link href="http://www.javaboy.org/2021/0318/springmvc-argument-resolver.html"/>
    <id>http://www.javaboy.org/2021/0318/springmvc-argument-resolver.html</id>
    <published>2021-03-18T05:55:53.000Z</published>
    <updated>2021-03-22T05:58:52.770Z</updated>
    
    <content type="html"><![CDATA[<p>前面和大家聊了自定义 SpringMVC 参数解析器，同时我们也分析了几个比较简单的参数解析器，相信大家对于 SpringMVC 中的参数解析器应该已经有了一定的了解，如果还没看过的小伙伴可以先看看：<a href="https://mp.weixin.qq.com/s/4c-uV8f6x5UPvxec6Em79A" target="_blank" rel="noopener">SpringBoot 中如何自定义参数解析器？</a>。</p><a id="more"></a><p>不过我相信很多小伙伴真正疑惑的是像下面这种接口，参数是怎么解析的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抑或者像下面这种接口，参数是怎么解析的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello/&#123;id&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello3</span><span class="hljs-params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"id = "</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们日常中最常见的参数定义方式，相信很多小伙伴对此很感兴趣。由于这块涉及到一个非常庞大的类 AbstractNamedValueMethodArgumentResolver，因此这里我单独写了一篇文章来和大家分享这个问题。</p><p>在正式分享之前，我们先来整体看看参数解析器都有哪些。</p><h2 id="1-参数解析器"><a href="#1-参数解析器" class="headerlink" title="1.参数解析器"></a>1.参数解析器</h2><p>HandlerMethodArgumentResolver 就是我们口口声声说的参数解析器，它的实现类还是蛮多的，因为每一种类型的参数都对应了一个参数解析器：</p><p><img src="http://img.itboyhub.com/2021/02/20210315143417.png" alt></p><p>为了理解方便，我们可以将这些参数解析器分为四大类：</p><ul><li>xxxMethodArgumentResolver：这就是一个普通的参数解析器。</li><li>xxxMethodProcessor：不仅可以当作参数解析器，还可以处理对应类型的返回值。</li><li>xxxAdapter：这种不做参数解析，仅仅用来作为 WebArgumentResolver 类型的参数解析器的适配器。</li><li>HandlerMethodArgumentResolverComposite：这个看名字就知道是一个组合解析器，它是一个代理，具体代理其他干活的那些参数解析器。</li></ul><p>大致上可以分为这四类，其中最重要的当然就是前两种了。</p><h2 id="2-参数解析器概览"><a href="#2-参数解析器概览" class="headerlink" title="2.参数解析器概览"></a>2.参数解析器概览</h2><p>接下来我们来先来大概看看这些参数解析器分别都是用来干什么的。</p><p><strong>MapMethodProcessor</strong></p><p>这个用来处理 Map/ModelMap 类型的参数，解析完成后返回 model。</p><p><strong>PathVariableMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@PathVariable</code> 注解并且参数类型不为 Map 的参数，参数类型为 Map 则使用 <code>PathVariableMapMethodArgumentResolver</code> 来处理。</p><p><strong>PathVariableMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>ErrorsMethodArgumentResolver</strong></p><p>这个用来处理 Error 参数，例如我们做参数校验时的 BindingResult。</p><p><strong>AbstractNamedValueMethodArgumentResolver</strong></p><p>这个用来处理 key/value 类型的参数，如请求头参数、使用了 <code>@PathVariable</code> 注解的参数以及 Cookie 等。</p><p><strong>RequestHeaderMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@RequestHeader</code> 注解，并且参数类型不是 Map 的参数（参数类型是 Map 的使用 <code>RequestHeaderMapMethodArgumentResolver</code>）。</p><p><strong>RequestHeaderMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>RequestAttributeMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@RequestAttribute</code> 注解的参数。</p><p><strong>RequestParamMethodArgumentResolver</strong></p><p>这个功能就比较广了。使用了 <code>@RequestParam</code> 注解的参数、文件上传的类型 MultipartFile、或者一些没有使用任何注解的基本类型（Long、Integer）以及 String 等，都使用该参数解析器处理。需要注意的是，如果 <code>@RequestParam</code> 注解的参数类型是 Map，则该注解必须有 name 值，否则解析将由 <code>RequestParamMapMethodArgumentResolver</code> 完成。</p><p><strong>RequestParamMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>AbstractCookieValueMethodArgumentResolver</strong></p><p>这个是一个父类，处理使用了 <code>@CookieValue</code> 注解的参数。</p><p><strong>ServletCookieValueMethodArgumentResolver</strong></p><p>这个处理使用了 <code>@CookieValue</code> 注解的参数。</p><p><strong>MatrixVariableMethodArgumentResolver</strong></p><p>这个处理使用了 <code>@MatrixVariable</code> 注解并且参数类型不是 Map 的参数，如果参数类型是 Map，则使用 <code>MatrixVariableMapMethodArgumentResolver</code> 来处理。</p><p><strong>MatrixVariableMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>SessionAttributeMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@SessionAttribute</code> 注解的参数。</p><p><strong>ExpressionValueMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@Value</code> 注解的参数。</p><p><strong>ServletResponseMethodArgumentResolver</strong></p><p>这个用来处理 ServletResponse、OutputStream 以及 Writer 类型的参数。</p><p><strong>ModelMethodProcessor</strong></p><p>这个用来处理 Model 类型参数，并返回 model。</p><p><strong>ModelAttributeMethodProcessor</strong></p><p>这个用来处理使用了 <code>@ModelAttribute</code> 注解的参数。</p><p><strong>SessionStatusMethodArgumentResolver</strong></p><p>这个用来处理 SessionStatus 类型的参数。</p><p><strong>PrincipalMethodArgumentResolver</strong></p><p>这个用来处理 Principal 类型参数，这个松哥在前面的文章中和大家介绍过了（<a href>SpringBoot 中如何自定义参数解析器？</a>）。</p><p><strong>AbstractMessageConverterMethodArgumentResolver</strong></p><p>这是一个父类，当使用 HttpMessageConverter 解析 requestbody 类型参数时，相关的处理类都会继承自它。</p><p><strong>RequestPartMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@RequestPart</code> 注解、MultipartFile 以及 Part 类型的参数。</p><p><strong>AbstractMessageConverterMethodProcessor</strong></p><p>这是一个工具类，不承担参数解析任务。</p><p><strong>RequestResponseBodyMethodProcessor</strong></p><p>这个用来处理添加了 <code>@RequestBody</code> 注解的参数。</p><p><strong>HttpEntityMethodProcessor</strong></p><p>这个用来处理 HttpEntity 和 RequestEntity 类型的参数。</p><p><strong>ContinuationHandlerMethodArgumentResolver</strong></p><p><strong>AbstractWebArgumentResolverAdapter</strong></p><p>这种不做参数解析，仅仅用来作为 WebArgumentResolver 类型的参数解析器的适配器。</p><p><strong>ServletWebArgumentResolverAdapter</strong></p><p>这个给父类提供 request。</p><p><strong>UriComponentsBuilderMethodArgumentResolver</strong></p><p>这个用来处理 UriComponentsBuilder 类型的参数。</p><p><strong>ServletRequestMethodArgumentResolver</strong></p><p>这个用来处理 WebRequest、ServletRequest、MultipartRequest、HttpSession、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId 类型的参数。</p><p><strong>HandlerMethodArgumentResolverComposite</strong></p><p>这个看名字就知道是一个组合解析器，它是一个代理，具体代理其他干活的那些参数解析器。</p><p><strong>RedirectAttributesMethodArgumentResolver</strong></p><p>这个用来处理 RedirectAttributes 类型的参数，RedirectAttributes 松哥在之前的文章中和大家介绍过：<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>。</p><p>好了，各个参数解析器的大致功能就给大家介绍完了，接下来我们选择其中一种，来具体说说它的源码。</p><h2 id="3-AbstractNamedValueMethodArgumentResolver"><a href="#3-AbstractNamedValueMethodArgumentResolver" class="headerlink" title="3.AbstractNamedValueMethodArgumentResolver"></a>3.AbstractNamedValueMethodArgumentResolver</h2><p>AbstractNamedValueMethodArgumentResolver 是一个抽象类，一些键值对类型的参数解析器都是通过继承它实现的，它里边定义了很多这些键值对类型参数解析器的公共操作。</p><p>AbstractNamedValueMethodArgumentResolver 中也是应用了很多模版模式，例如它没有实现 supportsParameter 方法，该方法的具体实现在不同的子类中，resolveArgument 方法它倒是实现了，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);</span><br><span class="line">MethodParameter nestedParameter = parameter.nestedIfOptional();</span><br><span class="line">Object resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line"><span class="hljs-keyword">if</span> (resolvedName == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="hljs-string">"Specified name must not resolve to null: ["</span> + namedValueInfo.name + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (namedValueInfo.defaultValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (binderFactory != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, <span class="hljs-keyword">null</span>, namedValueInfo.name);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ConversionNotSupportedException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),</span><br><span class="line">namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),</span><br><span class="line">namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Check for null value after conversion of incoming argument value</span></span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span> &amp;&amp; namedValueInfo.defaultValue == <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line">namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先根据当前请求获取一个 NamedValueInfo 对象，这个对象中保存了参数的三个属性：参数名、参数是否必须以及参数默认值。具体的获取过程就是先去缓存中拿，缓存中如果有，就直接返回，缓存中如果没有，则调用 createNamedValueInfo 方法去创建，将创建结果缓存起来并返回。createNamedValueInfo 方法是一个模版方法，具体的实现在子类中。</li><li>接下来处理 Optional 类型参数。</li><li>resolveEmbeddedValuesAndExpressions 方法是为了处理注解中使用了 SpEL 表达式的情况，例如如下接口：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">"$&#123;aa.bb&#125;"</span>)</span> String name) </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数名使用了表达式，那么 resolveEmbeddedValuesAndExpressions 方法的目的就是解析出表达式的值，如果没用到表达式，那么该方法会将原参数原封不动返回。</p><ol start="4"><li>接下来调用 resolveName 方法解析出参数的具体值，这个方法也是一个模版方法，具体的实现在子类中。</li><li>如果获取到的参数值为 null，先去看注解中有没有默认值，然后再去看参数值是否是必须的，如果是，则抛异常出来，否则就设置为 null 即可。</li><li>如果解析出来的参数值为空字符串 <code>&quot;&quot;</code>，则也去 resolveEmbeddedValuesAndExpressions 方法中走一遭。</li><li>最后则是 WebDataBinder 的处理，解决一些全局参数的问题，WebDataBinder 松哥在之前的文章中也有介绍过，传送门：<a href="https://mp.weixin.qq.com/s/Qd0BAUdUtBuBUBmy1G0Z4w" target="_blank" rel="noopener">@ControllerAdvice 的三种使用场景</a>。</li></ol><p>大致的流程就是这样。</p><p>在这个流程中，我们看到主要有如下两个方法是在子类中实现的：</p><ul><li>createNamedValueInfo</li><li>resolveName</li></ul><p>在加上 supportsParameter 方法，子类中一共有三个方法需要我们重点分析。</p><p>那么接下来我们就以 RequestParamMethodArgumentResolver 为例，来看下这三个方法。</p><h2 id="4-RequestParamMethodArgumentResolver"><a href="#4-RequestParamMethodArgumentResolver" class="headerlink" title="4.RequestParamMethodArgumentResolver"></a>4.RequestParamMethodArgumentResolver</h2><h3 id="4-1-supportsParameter"><a href="#4-1-supportsParameter" class="headerlink" title="4.1 supportsParameter"></a>4.1 supportsParameter</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (parameter.hasParameterAnnotation(RequestParam.class)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;</span><br><span class="line">RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="hljs-keyword">return</span> (requestParam != <span class="hljs-keyword">null</span> &amp;&amp; StringUtils.hasText(requestParam.name()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line"><span class="hljs-keyword">if</span> (MultipartResolutionDelegate.isMultipartArgument(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useDefaultResolution) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> BeanUtils.isSimpleProperty(parameter.getNestedParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSimpleProperty</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> isSimpleValueType(type) || (type.isArray() &amp;&amp; isSimpleValueType(type.getComponentType()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSimpleValueType</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (Void.class != type &amp;&amp; <span class="hljs-keyword">void</span>.class != type &amp;&amp;</span><br><span class="line">(ClassUtils.isPrimitiveOrWrapper(type) ||</span><br><span class="line">Enum.class.isAssignableFrom(type) ||</span><br><span class="line">CharSequence.class.isAssignableFrom(type) ||</span><br><span class="line">Number.class.isAssignableFrom(type) ||</span><br><span class="line">Date.class.isAssignableFrom(type) ||</span><br><span class="line">Temporal.class.isAssignableFrom(type) ||</span><br><span class="line">URI.class == type ||</span><br><span class="line">URL.class == type ||</span><br><span class="line">Locale.class == type ||</span><br><span class="line">Class.class == type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 supportsParameter 方法中可以非常方便的看出支持的参数类型：</p><ol><li>首先参数如果有 <code>@RequestParam</code> 注解的话，则分两种情况：参数类型如果是 Map，则 <code>@RequestParam</code> 注解必须配置 name 属性，否则不支持；如果参数类型不是 Map，则直接返回 true，表示总是支持（想想自己平时使用的时候是不是这样）。</li><li>参数如果含有 <code>@RequestPart</code> 注解，则不支持。</li><li>检查下是不是文件上传请求，如果是，返回 true 表示支持。</li><li>如果前面都没能返回，则使用默认的解决方案，判断是不是简单类型，主要就是 Void、枚举、字符串、数字、日期等等。</li></ol><p>这块代码其实很简单，支持谁不支持谁，一目了然。</p><h3 id="4-2-createNamedValueInfo"><a href="#4-2-createNamedValueInfo" class="headerlink" title="4.2 createNamedValueInfo"></a>4.2 createNamedValueInfo</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> NamedValueInfo <span class="hljs-title">createNamedValueInfo</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">RequestParam ann = parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="hljs-keyword">return</span> (ann != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> RequestParamNamedValueInfo(ann) : <span class="hljs-keyword">new</span> RequestParamNamedValueInfo());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestParamNamedValueInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamedValueInfo</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestParamNamedValueInfo</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(<span class="hljs-string">""</span>, <span class="hljs-keyword">false</span>, ValueConstants.DEFAULT_NONE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestParamNamedValueInfo</span><span class="hljs-params">(RequestParam annotation)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(annotation.name(), annotation.required(), annotation.defaultValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取注解，读取注解中的属性，构造 RequestParamNamedValueInfo 对象返回。</p><h3 id="4-3-resolveName"><a href="#4-3-resolveName" class="headerlink" title="4.3 resolveName"></a>4.3 resolveName</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveName</span><span class="hljs-params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mpArg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object arg = <span class="hljs-keyword">null</span>;</span><br><span class="line">MultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequest != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line"><span class="hljs-keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">arg = (files.size() == <span class="hljs-number">1</span> ? files.get(<span class="hljs-number">0</span>) : files);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String[] paramValues = request.getParameterValues(name);</span><br><span class="line"><span class="hljs-keyword">if</span> (paramValues != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">arg = (paramValues.length == <span class="hljs-number">1</span> ? paramValues[<span class="hljs-number">0</span>] : paramValues);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法思路也比较清晰：</p><ol><li>前面两个 if 主要是为了处理文件上传请求。</li><li>如果不是文件上传请求，则调用 <code>request.getParameterValues</code> 方法取出参数返回即可。</li></ol><p>整个过程还是比较 easy 的。小伙伴们可以在此基础之上自行分析 PathVariableMethodArgumentResolver 的原理，也很容易。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>今天主要和小伙伴们梳理了 SpringMVC 参数解析器的整个体系，关于这些解析器在何时被配置，在何时被调用，松哥在后面的文章中会和大家继续分析。好啦，今天就说这么多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和大家聊了自定义 SpringMVC 参数解析器，同时我们也分析了几个比较简单的参数解析器，相信大家对于 SpringMVC 中的参数解析器应该已经有了一定的了解，如果还没看过的小伙伴可以先看看：&lt;a href=&quot;https://mp.weixin.qq.com/s/4c-uV8f6x5UPvxec6Em79A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringBoot 中如何自定义参数解析器？&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 中如何自定义参数解析器？</title>
    <link href="http://www.javaboy.org/2021/0316/springmvc-param-resolver.html"/>
    <id>http://www.javaboy.org/2021/0316/springmvc-param-resolver.html</id>
    <published>2021-03-16T08:48:03.000Z</published>
    <updated>2021-03-16T08:51:16.790Z</updated>
    
    <content type="html"><![CDATA[<p>在一个 Web 请求中，参数我们无非就是放在地址栏或者请求体中，个别请求可能放在请求头中。</p><a id="more"></a><p>放在地址栏中，我们可以通过如下方式获取参数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javaboy = request.getParameter(<span class="hljs-string">"name "</span>);</span><br></pre></td></tr></table></figure><p>放在请求体中，如果是 key/value 形式，我们可以通过如下方式获取参数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javaboy = request.getParameter(<span class="hljs-string">"name "</span>);</span><br></pre></td></tr></table></figure><p>如果是 JSON 形式，我们则通过如果如下方式获取到输入流，然后解析成 JSON 字符串，再通过 JSON 工具转为对象：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(request.getInputStream()));</span><br><span class="line">String json = reader.readLine();</span><br><span class="line">reader.close();</span><br><span class="line">User user = <span class="hljs-keyword">new</span> ObjectMapper().readValue(json, User.class);</span><br></pre></td></tr></table></figure><p>如果参数放在请求头中，我们可以通过如下方式获取：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String javaboy = request.getHeader(<span class="hljs-string">"name"</span>);</span><br></pre></td></tr></table></figure><p>如果你用的是 Jsp/Servlet 那一套技术栈，那么参数获取无外乎这几种方式。</p><p>如果用了 SpringMVC 框架，有的小伙伴们可能会觉得参数获取方式太丰富了，各种注解如 <code>@RequestParam</code>、<code>@RequestBody</code>、<code>@RequestHeader</code>、<code>@PathVariable</code>，参数可以是 key/value 形式，也可以是 JSON 形式，非常丰富！但是，<strong>无论多么丰富，最底层获取参数的方式无外乎上面几种。</strong></p><p>那有小伙伴要问了，SpringMVC 到底是怎么样从 request 中把参数提取出来直接给我们用的呢？例如下面这个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道 name 参数是从 HttpServletRequest 中提取出来的，到底是怎么提取出来的？这就是松哥今天要和大家分享的话题。</p><h2 id="1-自定义参数解析器"><a href="#1-自定义参数解析器" class="headerlink" title="1.自定义参数解析器"></a>1.自定义参数解析器</h2><p>为了搞清楚这个问题，我们先来自定义一个参数解析器看看。</p><p>自定义参数解析器需要实现 HandlerMethodArgumentResolver 接口，我们先来看看该接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中就两个方法：</p><ul><li>supportsParameter：该方法表示是否启用这个参数解析器，返回 true 表示启用，返回 false 表示不启用。</li><li>resolveArgument：这是具体的解析过程，就是从 request 中取出参数的过程，方法的返回值就对应了接口中参数的值。</li></ul><p>自定义参数解析器只需要实现该接口即可。</p><p>假设我现在有这样一个需求（实际上在 Spring Security 中获取当前登录用户名非常方便，这里只是为了该案例而做，勿抬杠）：</p><p>假设我现在系统安全框架使用了 Spring Security（对 Spring Security 不熟悉的小伙伴，可以在公众号江南一点雨后台回复 ss，有教程），如果我在接口的参数上添加了 @CurrentUserName 注解，那么该参数的值就是当前登录的用户名，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@CurrentUserName String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现这个功能，非常 easy，首先我们自定义一个 <code>@CurrentUserName</code> 注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CurrentUserName &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解没啥好解释的。</p><p>接下来我们自定义参数解析器 CurrentUserNameHandlerMethodArgumentResolver，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CurrentUserNameHandlerMethodArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> parameter.getParameterType().isAssignableFrom(String.class)&amp;&amp;parameter.hasParameterAnnotation(CurrentUserName.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">        <span class="hljs-keyword">return</span> user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsParameter：如果参数类型是 String，并且参数上有 <code>@CurrentUserName</code> 注解，则使用该参数解析器。</li><li>resolveArgument：该方法的返回值就是参数的具体值，当前登录用户名从 SecurityContextHolder 中获取即可（具体参数松哥的 Spring Security 教程，公号后台回复 ss）。</li></ul><p>最后，我们再将自定义的参数解析器配置到 HandlerAdapter 中，配置方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">        resolvers.add(<span class="hljs-keyword">new</span> CurrentUserNameHandlerMethodArgumentResolver());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，就算配置完成了。</p><p>接下来启动项目，用户登录成功后，访问 <code>/hello</code> 接口，就可以看到返回当前登录用户数据了。</p><p>这就是我们自定义的一个参数类型解析器。可以看到，非常 Easy。</p><p>在 SpringMVC 中，默认也有很多 HandlerMethodArgumentResolver 的实现类，他们处理的问题也都类似，松哥再给大家举个例子。</p><h2 id="2-PrincipalMethodArgumentResolver"><a href="#2-PrincipalMethodArgumentResolver" class="headerlink" title="2.PrincipalMethodArgumentResolver"></a>2.PrincipalMethodArgumentResolver</h2><p>如果我们在项目中使用了 Spring Security，我们可以通过如下方式获取当前登录用户信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">(Principal principal)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span> + principal.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即直接在当前接口的参数中添加 Principal 类型的参数即可，该参数描述了当前登录用户信息，这个用过 Spring Security 的小伙伴应该都知道（不熟悉 Spring Security 的小伙伴可以在公众号【江南一点雨】后台回复 ss）。</p><p>那么这个功能是怎么实现的呢？当然就是 PrincipalMethodArgumentResolver 在起作用了！</p><p>我们一起来看下这个参数解析器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrincipalMethodArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Principal.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (request == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Current request is not of type HttpServletRequest: "</span> + webRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Principal principal = request.getUserPrincipal();</span><br><span class="line"><span class="hljs-keyword">if</span> (principal != <span class="hljs-keyword">null</span> &amp;&amp; !parameter.getParameterType().isInstance(principal)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Current user principal is not of type ["</span> +</span><br><span class="line">parameter.getParameterType().getName() + <span class="hljs-string">"]: "</span> + principal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> principal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsParameter：这个方法主要是判断参数类型是不是 Principal，如果参数类型是 Principal，就支持。</li><li>resolveArgument：这个方法的逻辑很简单，首先获取原生的请求，再从请求中获取 Principal 对象返回即可。</li></ul><p>是不是很简单，有了这个，我们就可以随时加载到当前登录用户信息了。</p><h2 id="3-RequestParamMapMethodArgumentResolver"><a href="#3-RequestParamMapMethodArgumentResolver" class="headerlink" title="3.RequestParamMapMethodArgumentResolver"></a>3.RequestParamMapMethodArgumentResolver</h2><p>松哥再给大家举个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam MultiValueMap map)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口很多小伙伴可能都写过，使用 Map 去接收前端传来的参数，那么这里用到的参数解析器就是 RequestParamMapMethodArgumentResolver。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestParamMapMethodArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="hljs-keyword">return</span> (requestParam != <span class="hljs-keyword">null</span> &amp;&amp; Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp;</span><br><span class="line">!StringUtils.hasText(requestParam.name()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ResolvableType resolvableType = ResolvableType.forMethodParameter(parameter);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (MultiValueMap.class.isAssignableFrom(parameter.getParameterType())) &#123;</span><br><span class="line"><span class="hljs-comment">// MultiValueMap</span></span><br><span class="line">Class&lt;?&gt; valueType = resolvableType.as(MultiValueMap.class).getGeneric(<span class="hljs-number">1</span>).resolve();</span><br><span class="line"><span class="hljs-keyword">if</span> (valueType == MultipartFile.class) &#123;</span><br><span class="line">MultipartRequest multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> (multipartRequest != <span class="hljs-keyword">null</span> ? multipartRequest.getMultiFileMap() : <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(<span class="hljs-number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueType == Part.class) &#123;</span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span> &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">Collection&lt;Part&gt; parts = servletRequest.getParts();</span><br><span class="line">LinkedMultiValueMap&lt;String, Part&gt; result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(parts.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">result.add(part.getName(), part);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = webRequest.getParameterMap();</span><br><span class="line">MultiValueMap&lt;String, String&gt; result = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(parameterMap.size());</span><br><span class="line">parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String value : values) &#123;</span><br><span class="line">result.add(key, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Regular Map</span></span><br><span class="line">Class&lt;?&gt; valueType = resolvableType.asMap().getGeneric(<span class="hljs-number">1</span>).resolve();</span><br><span class="line"><span class="hljs-keyword">if</span> (valueType == MultipartFile.class) &#123;</span><br><span class="line">MultipartRequest multipartRequest = MultipartResolutionDelegate.resolveMultipartRequest(webRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> (multipartRequest != <span class="hljs-keyword">null</span> ? multipartRequest.getFileMap() : <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(<span class="hljs-number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (valueType == Part.class) &#123;</span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span> &amp;&amp; MultipartResolutionDelegate.isMultipartRequest(servletRequest)) &#123;</span><br><span class="line">Collection&lt;Part&gt; parts = servletRequest.getParts();</span><br><span class="line">LinkedHashMap&lt;String, Part&gt; result = CollectionUtils.newLinkedHashMap(parts.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : parts) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!result.containsKey(part.getName())) &#123;</span><br><span class="line">result.put(part.getName(), part);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = webRequest.getParameterMap();</span><br><span class="line">Map&lt;String, String&gt; result = CollectionUtils.newLinkedHashMap(parameterMap.size());</span><br><span class="line">parameterMap.forEach((key, values) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (values.length &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">result.put(key, values[<span class="hljs-number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsParameter：参数类型是 Map，并且使用了 <code>@RequestParam</code> 注解，并且 <code>@RequestParam</code> 注解中没有配置 name 属性，就可以使用该参数解析器。</li><li>resolveArgument：具体解析分为两种情况：MultiValueMap 和其他 Map，前者中又分三种情况：MultipartFile、Part 或者其他普通请求，前两者可以处理文件上传，第三个就是普通参数。如果是普通 Map，则直接获取到原始请求参数放到一个 Map 集合中返回即可。</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>前面和大家聊的都是几种简单的情况，还有复杂的如 PathVariableMethodArgumentResolver 和 RequestParamMethodArgumentResolver 松哥以后再和大家详细聊。同时还有一个问题就是这些参数解析器具体是在哪里调用的，这个也会在松哥近期的 SpringMVC 源码解析系列文章中和大家分享，好啦，今天周末，就这点简单的小知识祝大家周末愉快～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个 Web 请求中，参数我们无非就是放在地址栏或者请求体中，个别请求可能放在请求头中。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 初始化流程分析</title>
    <link href="http://www.javaboy.org/2021/0315/springmvc-init.html"/>
    <id>http://www.javaboy.org/2021/0315/springmvc-init.html</id>
    <published>2021-03-15T08:47:50.000Z</published>
    <updated>2021-03-16T08:51:54.332Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>框架源码是我们 Coding 晋级中的必修课，SSM 应该算是小伙伴们日常接触最多的框架了，这其中 SpringMVC 初始化流程相对来说要简单一些，因此今天松哥就先来和大家分析一下 SpringMVC 初始化流程。</p><a id="more"></a><p>即使你没看过 SpringMVC 的源码，估计也听说过：DispatcherServlet 是 SpringMVC 的大脑，它负责整个 SpringMVC 的调度工作，是 SpringMVC 中最最核心的类，SpringMVC 整个顶层架构设计都体现在这里，所以搞明白 DispatcherServlet 的源码，基本上 SpringMVC 的工作原理也就了然于胸了。</p><p>然而 DispatcherServlet 继承自 FrameworkServlet，FrameworkServlet 又继承自 HttpServletBean，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210301214050.png" alt></p><p>因此我们的分析就从 HttpServletBean 开始。</p><h2 id="1-HttpServletBean"><a href="#1-HttpServletBean" class="headerlink" title="1.HttpServletBean"></a>1.HttpServletBean</h2><p><code>HttpServletBean</code> 继承自 <code>HttpServlet</code>，它负责将 <code>init-param</code> 中的参数注入到当前 <code>Servlet</code> 实例的属性中，同时也为子类提供了增加 <code>requiredProperties</code> 的能力，需要注意的是 <code>HttpServletBean</code> 并不依赖于 <code>Spring</code> 容器。</p><p>大家知道，HttpServlet 的初始化是从 init 方法开始的，所以我们就先从 HttpServletBean 的 init 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Set bean properties from init parameters.</span></span><br><span class="line">PropertyValues pvs = <span class="hljs-keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="hljs-keyword">this</span>.requiredProperties);</span><br><span class="line"><span class="hljs-keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="hljs-keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="hljs-keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="hljs-keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line">bw.setPropertyValues(pvs, <span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">logger.error(<span class="hljs-string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="hljs-string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里，首先获取到 Servlet 的所有配置并转为 PropertyValues，然后通过 BeanWrapper 修改目标 Servlet 的相关属性。BeanWrapper 是 Spring 中提供一个工具，使用它可以修改一个对象的属性，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        BeanWrapper beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(user);</span><br><span class="line">        beanWrapper.setPropertyValue(<span class="hljs-string">"username"</span>, <span class="hljs-string">"itboyhub"</span>);</span><br><span class="line">        PropertyValue pv = <span class="hljs-keyword">new</span> PropertyValue(<span class="hljs-string">"address"</span>, <span class="hljs-string">"www.itboyhub.com"</span>);</span><br><span class="line">        beanWrapper.setPropertyValue(pv);</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;username=&apos;itboyhub&apos;, address=&apos;www.itboyhub.com&apos;&#125;</span><br></pre></td></tr></table></figure><p>所以前面的 bw 实际上就代表当前 DispatcherServlet 对象。</p><p>通过 BeanWrapper 修改目标 Servlet 的相关属性时，有一个 initBeanWrapper 方法是空方法，开发者如有需要可以在子类中实现该方法，并且完成一些初始化操作。</p><p>属性配置完成后，最终调用 initServletBean 方法进行 Servlet 初始化，然而该方法也是一个空方法，在子类中实现。</p><p>这就是 HttpServletBean 所做的事情，比较简单，加载 Servlet 相关属性并设置给当前 Servlet 对象，然后调用 initServletBean 方法继续完成 Servlet 的初始化操作。</p><h2 id="2-FrameworkServlet"><a href="#2-FrameworkServlet" class="headerlink" title="2.FrameworkServlet"></a>2.FrameworkServlet</h2><p>从前面的介绍可知，FrameworkServlet 初始化的入口方法就是 initServletBean，因此我们就从 FrameworkServlet#initServletBean 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServletBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法原本挺长的，但是抛开日志打印异常抛出，剩下的核心代码其实就两行：</p><ol><li>initWebApplicationContext 方法用来初始化 WebApplicationContext。</li><li>initFrameworkServlet 方法用来初始化 FrameworkServlet，但是这个方法是一个空方法，没有具体的实现。本来子类可以重写该方法做一些初始化操作，但是实际上子类并没有重写该方法，所以这个方法我们就暂且忽略之，不去分析了。</li></ol><p>那么这里最为重要的其实就是 initWebApplicationContext 方法了，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">initWebApplicationContext</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.webApplicationContext != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac = <span class="hljs-keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="hljs-keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (cwac.getParent() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.publishContext) &#123;</span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑也比较清晰：</p><ol><li>首先获取 rootContext。在默认情况下，Spring 会将容器设置为 ServletContext 的一个属性，属性的 key 为 <code>org.springframework.web.context.WebApplicationContext.ROOT</code>，所以根据这个 key 就可以调用 ServletContext#getAttribute 方法获取到 rootContext 了。</li><li>获取 WebApplicationContext 实例，也就是给 wac 变量赋值的过程，这里存在三种可能性：1.如果已经通过构造方法给 webApplicationContext 赋值了，则直接将其赋给 wac 变量，同时，如果需要设置 parent 就设置，需要刷新就刷新。这种方式适用于 Servlet3.0 以后的环境，因为从 Servlet3.0 开始，才支持直接调用 ServletContext.addServlet 方法去注册 Servlet，手动注册的时候就可以使用自己提前准备好的 WebApplicationContext 了，这块松哥在我录制的 Spring Boot 视频中也讲过，感兴趣的小伙伴可以在公众号后台回复 vhr 查看视频详情；2.如果第一步没能成功给 wac 赋值，那么调用 findWebApplicationContext 方法尝试去 ServletContext 中查找 WebApplicationContext 对象，找到了就赋值给 wac；3.如果第二步没能成功给 wac 赋值，那么调用 createWebApplicationContext 方法创建一个 WebApplicationContext 对象并赋值给 wac，一般来说都是通过这种方式创建的 WebApplicationContext。这三套组合拳下来，wac 肯定是有值了。</li><li>当 ContextRefreshedEvent 事件没有触发时，调用 onRefresh 方法完成容器刷新（由于第一种和第三种获取 WebApplicationContext 的方式最终都会调用 configureAndRefreshWebApplicationContext 方法，然后发布事件，再将 refreshEventReceived 变量标记为 true，所以实际上只有第二种方式获取 wac 实例的时候，这里才会刷新，具体可以看下文分析）。</li><li>最后将 wac 保存到到 ServletContext 中。保存的时候会根据 publishContext 变量的值来决定是否保存，publishContext 可以在 web.xml 中配置 Servlet 时通过 init-param 进行配置，保存的目的是为了方便获取。</li></ol><p>上面的这些步骤中，通过 createWebApplicationContext 方法创建 WebApplicationContext 对象需要和大家细说下，因为一般情况下就是通过这种方式创建的 WebApplicationContext。我们来看一下相关的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createWebApplicationContext</span><span class="hljs-params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line"><span class="hljs-keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(</span><br><span class="line"><span class="hljs-string">"Fatal initialization error in servlet with name '"</span> + getServletName() +</span><br><span class="line"><span class="hljs-string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +</span><br><span class="line"><span class="hljs-string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">&#125;</span><br><span class="line">ConfigurableWebApplicationContext wac =</span><br><span class="line">(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">wac.setEnvironment(getEnvironment());</span><br><span class="line">wac.setParent(parent);</span><br><span class="line">String configLocation = getContextConfigLocation();</span><br><span class="line"><span class="hljs-keyword">if</span> (configLocation != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac.setConfigLocation(configLocation);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"><span class="hljs-keyword">return</span> wac;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureAndRefreshWebApplicationContext</span><span class="hljs-params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line"><span class="hljs-comment">// The application context id is still set to its original default value</span></span><br><span class="line"><span class="hljs-comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.contextId != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">wac.setId(<span class="hljs-keyword">this</span>.contextId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Generate default id...</span></span><br><span class="line">wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="hljs-string">'/'</span> + getServletName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wac.setServletContext(getServletContext());</span><br><span class="line">wac.setServletConfig(getServletConfig());</span><br><span class="line">wac.setNamespace(getNamespace());</span><br><span class="line">wac.addApplicationListener(<span class="hljs-keyword">new</span> SourceFilteringListener(wac, <span class="hljs-keyword">new</span> ContextRefreshListener()));</span><br><span class="line"><span class="hljs-comment">// The wac environment's #initPropertySources will be called in any case when the context</span></span><br><span class="line"><span class="hljs-comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line"><span class="hljs-comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line"><span class="hljs-keyword">if</span> (env <span class="hljs-keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">&#125;</span><br><span class="line">postProcessWebApplicationContext(wac);</span><br><span class="line">applyInitializers(wac);</span><br><span class="line">wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共涉及到两个方法：</p><p><strong>createWebApplicationContext</strong></p><p>首先获取到创建类型，并检查创建类型，没问题的话调用 instantiateClass 方法完成创建工作，然后给创建好的 wac 对象配置各种属性，配置的 configLocation 就是我们在 web.xml 文件中配置的 SpringMVC 配置文件路径，默认的文件路径是 <code>/WEB-INF/[servletName]-servlet.xml</code>。</p><p><strong>configureAndRefreshWebApplicationContext</strong></p><p>configureAndRefreshWebApplicationContext 方法主要也是配置&amp;刷新 WebApplicationContext，在这个方法里会调用 addApplicationListener 为 wac 添加一个监听器，监听的是 ContextRefreshedEvent 事件，当收到该事件后，会调用 FrameworkServlet 的 onApplicationEvent 方法，并在该方法中调用 onRefresh 方法完成刷新，刷新之后，会将 refreshEventReceived 变量标记为 true。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.refreshEventReceived = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">onRefresh(event.getApplicationContext());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 FrameworkServlet#initServletBean 方法的大致工作逻辑。这里涉及到了 onRefresh 方法，但是这是一个空方法，在子类 DispatcherServlet 中实现了，所以接下来我们就来看 DispatcherServlet。</p><h2 id="3-DispatcherServlet"><a href="#3-DispatcherServlet" class="headerlink" title="3.DispatcherServlet"></a>3.DispatcherServlet</h2><p>这里我们就不废话了，直接来看 onRefresh 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 onRefresh 方法中调用了 initStrategies 进行初始化操作。initStrategies 的内容其实很简单，就是九个组件的初始化。九个的初始化流程比较类似，这里我们以常见的视图解析器的初始化方法 initViewResolvers 为例，来一起看看初始化流程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initViewResolvers</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detectAllViewResolvers) &#123;</span><br><span class="line"><span class="hljs-comment">// Find all ViewResolvers in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">Map&lt;String, ViewResolver&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line"><span class="hljs-comment">// We keep ViewResolvers in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="hljs-keyword">this</span>.viewResolvers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// Ignore, we'll add a default ViewResolver later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Ensure we have at least one ViewResolver, by registering</span></span><br><span class="line"><span class="hljs-comment">// a default ViewResolver if no other resolvers are found.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"No ViewResolvers declared for servlet '"</span> + getServletName() +</span><br><span class="line"><span class="hljs-string">"': using default strategies from DispatcherServlet.properties"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始的 viewResolvers 变量是一个集合，解析出来的视图解析器对象都将放入这个集合中。</p><p>首先判断 detectAllViewResolvers 变量是否为 true，如果为 true，则直接去查找 Spring 容器中的所有视图解析器，将查找结果赋值给 viewResolvers，然后进行排序。默认情况下 detectAllViewResolvers 变量的值为 true，如果有需要，可以在 web.xml 中进行配置，像下面这样：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>detectAllViewResolvers<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 detectAllViewResolvers 的值为 false，那么接下来就会去 Spring 容器中查找一个名为 viewResolver 的视图解析器，此时查找到的就是一个单独的视图解析器。</p><p>一般来说，我们并不需要在 web.xml 中去配置 detectAllViewResolvers 的值，视图解析器有多少个就加载多少个。</p><p>举个简单例子，我们在 SpringMVC 的配置文件中可能像下面这样配置视图解析器：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，这个 bean 的 id 有没有都行，如果有，取什么值都可以，反正最终都是通过类型而不是 id 去查找的视图解析器。但是如果你在 web.xml 中将 detectAllViewResolvers 修改为 false，那么这个 bean 的 id 取值就比较重要了，就一定要是 viewResolver。</p><p>如果在 Spring 容器中通过这两种方式（通过类型查找或通过 id 查找）都没有找到 ViewResolver 实例，那么会调用 getDefaultStrategies 方法去获取一个默认的 ViewResolver 实例。默认实例的获取方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">getDefaultStrategies</span><span class="hljs-params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (defaultStrategies == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Load default strategy implementations from properties file.</span></span><br><span class="line"><span class="hljs-comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line"><span class="hljs-comment">// by application developers.</span></span><br><span class="line">ClassPathResource resource = <span class="hljs-keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</span><br><span class="line">defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="hljs-string">"': "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String key = strategyInterface.getName();</span><br><span class="line">String value = defaultStrategies.getProperty(key);</span><br><span class="line"><span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span><br><span class="line">List&lt;T&gt; strategies = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(classNames.length);</span><br><span class="line"><span class="hljs-keyword">for</span> (String className : classNames) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span><br><span class="line">Object strategy = createDefaultStrategy(context, clazz);</span><br><span class="line">strategies.add((T) strategy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInitializationException(</span><br><span class="line"><span class="hljs-string">"Could not find DispatcherServlet's default strategy class ["</span> + className +</span><br><span class="line"><span class="hljs-string">"] for interface ["</span> + key + <span class="hljs-string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInitializationException(</span><br><span class="line"><span class="hljs-string">"Unresolvable class definition for DispatcherServlet's default strategy class ["</span> +</span><br><span class="line">className + <span class="hljs-string">"] for interface ["</span> + key + <span class="hljs-string">"]"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> strategies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实也比较简单，就是通过反射去获取默认的视图解析器。</p><p>首先给 defaultStrategies 赋值，defaultStrategies 的值实际上就是从 DispatcherServlet.properties 文件中加载到的，我们来看下这个文件内容：</p><p><img src="http://img.itboyhub.com/2021/02/20210303202947.png" alt></p><p>可以看到，这里一共定义了 8 个默认的键值对，有的值是一个，有的值是多个。前面 initStrategies 方法中一共要初始化九个组件，这里默认只定义了 8 个，少了一个 MultipartResolver，这也好理解，并非所有的项目都有文件上传，而且即使有文件上传，用哪一个具体的 MultipartResolver 也不好确定，还是要开发者自己决定。</p><p>defaultStrategies 其实加载到的就是这 8 个键值对，其中视图解析器对应的是 org.springframework.web.servlet.view.InternalResourceViewResolver，通过反射创建该类的实例，当 Spring 容器中不存在任何视图解析器的时候，默认的视图解析器即此。</p><p>这就是 initViewResolvers 的工作流程，另外 8 个也和它差不多，唯一不同的是 initMultipartResolver，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMultipartResolver</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartResolver = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它只是根据 bean 的名字去查找 bean 实例，没有去查找默认的 MultipartResolver。</p><p>说到这里，松哥和大家多说一句 SpringMVC 配置中的小细节，</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"multipartResolver"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个关于视图解析器和文件上传解析器的配置，不知道小伙伴们有没有注意过，视图解析器的 id 可有可无，而文件上传解析器的 id 必须是 multipartResolver，回顾我们上面的源码分析，你就知道为啥了！</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，这就是松哥和小伙伴们分享的 SpringMVC 的初始化流程，主要涉及到了 HttpServletBean、FrameworkServlet 以及 DispatcherServlet 三个实例，HttpServletBean 主要是加载 Servlet 配置的各种属性并设置到 Servlet 上；FrameworkServlet 则主要是初始化了 WebApplicationContext；DispatcherServlet 则主要是初始化了自身的九个组件。</p><p>这只是初始化的流程，那么当请求到来之后，请求的流程又是怎么样的呢？这个松哥下篇文章来和大家分享～好啦，今天就先和小伙伴们聊这么多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;框架源码是我们 Coding 晋级中的必修课，SSM 应该算是小伙伴们日常接触最多的框架了，这其中 SpringMVC 初始化流程相对来说要简单一些，因此今天松哥就先来和大家分析一下 SpringMVC 初始化流程。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的实现 Spring Boot 接口参数加密解密?</title>
    <link href="http://www.javaboy.org/2021/0309/springboot-encrypt-decrypt.html"/>
    <id>http://www.javaboy.org/2021/0309/springboot-encrypt-decrypt.html</id>
    <published>2021-03-09T06:15:49.000Z</published>
    <updated>2021-03-09T06:16:56.735Z</updated>
    
    <content type="html"><![CDATA[<p>因为有小伙伴刚好问到这个问题，松哥就抽空撸一篇文章和大家聊聊这个话题。</p><a id="more"></a><p>加密解密本身并不是难事，问题是在何时去处理？定义一个过滤器，将请求和响应分别拦截下来进行处理也是一个办法，这种方式虽然粗暴，但是灵活，因为可以拿到一手的请求参数和响应数据。不过 SpringMVC 中给我们提供了 ResponseBodyAdvice 和 RequestBodyAdvice，利用这两个工具可以对请求和响应进行预处理，非常方便。</p><p>所以今天这篇文章有两个目的：</p><ul><li>分享参数/响应加解密的思路。</li><li>分享 ResponseBodyAdvice 和 RequestBodyAdvice 的用法。</li></ul><p>好了，那么接下来就不废话了，我们一起来看下。</p><h2 id="1-开发加解密-starter"><a href="#1-开发加解密-starter" class="headerlink" title="1.开发加解密 starter"></a>1.开发加解密 starter</h2><p>为了让我们开发的这个工具更加通用，也为了复习一下自定义 Spring Boot Starter，这里我们就将这个工具做成一个 stater，以后在 Spring Boot 项目中直接引用就可以。</p><p>首先我们创建一个 Spring Boot 项目，引入 spring-boot-starter-web 依赖：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;version&gt;2.4.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>因为我们这个工具是为 Web 项目开发的，以后必然使用在 Web 环境中，所以这里添加依赖时 scope 设置为 provided。</p><p>依赖添加完成后，我们先来定义一个加密工具类备用，加密这块有多种方案可以选择，对称加密、非对称加密，其中对称加密又可以使用 AES、DES、3DES 等不同算法，这里我们使用 Java 自带的 Cipher 来实现对称加密，使用 AES 算法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AES_ALGORITHM = <span class="hljs-string">"AES/ECB/PKCS5Padding"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 获取 cipher</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Cipher <span class="hljs-title">getCipher</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] key, <span class="hljs-keyword">int</span> model)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="hljs-keyword">new</span> SecretKeySpec(key, <span class="hljs-string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);</span><br><span class="line">        cipher.init(model, secretKeySpec);</span><br><span class="line">        <span class="hljs-keyword">return</span> cipher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// AES加密</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cipher cipher = getCipher(key, Cipher.ENCRYPT_MODE);</span><br><span class="line">        <span class="hljs-keyword">return</span> Base64.getEncoder().encodeToString(cipher.doFinal(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// AES解密</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] decrypt(<span class="hljs-keyword">byte</span>[] data, <span class="hljs-keyword">byte</span>[] key) <span class="hljs-keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = getCipher(key, Cipher.DECRYPT_MODE);</span><br><span class="line">        <span class="hljs-keyword">return</span> cipher.doFinal(Base64.getDecoder().decode(data));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工具类比较简单，不需要多解释。需要说明的是，加密后的数据可能不具备可读性，因此我们一般需要对加密后的数据再使用 Base64 算法进行编码，获取可读字符串。换言之，上面的 AES 加密方法的返回值是一个 Base64 编码之后的字符串，AES 解密方法的参数也是一个 Base64 编码之后的字符串，先对该字符串进行解码，然后再解密。</p><p>接下来我们封装一个响应工具类备用，这个大家如果经常看松哥视频已经很了解了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RespBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer status;</span><br><span class="line">    <span class="hljs-keyword">private</span> String msg;</span><br><span class="line">    <span class="hljs-keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">ok</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">200</span>, msg, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">ok</span><span class="hljs-params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">200</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">error</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">500</span>, msg, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RespBean <span class="hljs-title">error</span><span class="hljs-params">(String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RespBean(<span class="hljs-number">500</span>, msg, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RespBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">RespBean</span><span class="hljs-params">(Integer status, String msg, Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.status = status;</span><br><span class="line">        <span class="hljs-keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="hljs-keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getStatus</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">setStatus</span><span class="hljs-params">(Integer status)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.status = status;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">setMsg</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObj</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">setObj</span><span class="hljs-params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.obj = obj;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们定义两个注解 <code>@Decrypt</code> 和 <code>@Encrypt</code>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(&#123;ElementType.METHOD,ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Decrypt &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Encrypt &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个注解就是两个标记，在以后使用的过程中，哪个接口方法添加了 @Encrypt 注解就对哪个接口的数据加密返回，哪个接口/参数添加了 @Decrypt 注解就对哪个接口/参数进行解密。这个定义也比较简单，没啥好说的，需要注意的是 <code>@Decrypt</code> 比 <code>@Encrypt</code> 多了一个使用场景就是 <code>@Decrypt</code> 可以用在参数上。</p><p>考虑到用户可能会自己配置加密的 key，因此我们再来定义一个 EncryptProperties 类来读取用户配置的 key：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.encrypt"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String DEFAULT_KEY = <span class="hljs-string">"www.itboyhub.com"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> String key = DEFAULT_KEY;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setKey</span><span class="hljs-params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我设置了默认的 key 是 <code>www.itboyhub.com</code>，key 是 16 位字符串，松哥这个网站地址刚好满足。以后如果用户想自己配置 key，只需要在 application.properties 中配置 <code>spring.encrypt.key=xxx</code> 即可。</p><p>所有准备工作做完了，接下来就该正式加解密了。</p><p>因为松哥这篇文章一个很重要的目的是想和大家分享 ResponseBodyAdvice 和 RequestBodyAdvice 的用法，RequestBodyAdvice 在做解密的时候倒是没啥问题，而 ResponseBodyAdvice 在做加密的时候则会有一些局限，不过影响不大，还是我前面说的，如果想非常灵活的掌控一切，那还是自定义过滤器吧。这里我就先用这两个工具来实现了。</p><p>另外还有一点需要注意，ResponseBodyAdvice 在你使用了 @ResponseBody 注解的时候才会生效，RequestBodyAdvice 在你使用了 @RequestBody 注解的时候才会生效，换言之，前后端都是 JSON 交互的时候，这两个才有用。不过一般来说接口加解密的场景也都是前后端分离的时候才可能有的事。</p><p>先来看接口加密：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(EncryptProperties.class)</span><br><span class="line"><span class="hljs-meta">@ControllerAdvice</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptResponse</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResponseBodyAdvice</span>&lt;<span class="hljs-title">RespBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    EncryptProperties encryptProperties;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> returnType.hasMethodAnnotation(Encrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">beforeBodyWrite</span><span class="hljs-params">(RespBean body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] keyBytes = encryptProperties.getKey().getBytes();</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (body.getMsg()!=<span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                body.setMsg(AESUtils.encrypt(body.getMsg().getBytes(),keyBytes));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (body.getObj() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                body.setObj(AESUtils.encrypt(om.writeValueAsBytes(body.getObj()), keyBytes));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自定义 EncryptResponse 类实现 ResponseBodyAdvice<respbean> 接口，泛型表示接口的返回类型，这里一共要实现两个方法：</respbean></p><ol><li>supports：这个方法用来判断什么样的接口需要加密，参数 returnType 表示返回类型，我们这里的判断逻辑就是方法是否含有 <code>@Encrypt</code> 注解，如果有，表示该接口需要加密处理，如果没有，表示该接口不需要加密处理。</li><li>beforeBodyWrite：这个方法会在数据响应之前执行，也就是我们先对响应数据进行二次处理，处理完成后，才会转成 json 返回。我们这里的处理方式很简单，RespBean 中的 status 是状态码就不用加密了，另外两个字段重新加密后重新设置值即可。</li><li>另外需要注意，自定义的 ResponseBodyAdvice 需要用 <code>@ControllerAdvice</code> 注解来标记。</li></ol><p>再来看接口解密：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(EncryptProperties.class)</span><br><span class="line"><span class="hljs-meta">@ControllerAdvice</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecryptRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestBodyAdviceAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    EncryptProperties encryptProperties;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> methodParameter.hasMethodAnnotation(Decrypt.class) || methodParameter.hasParameterAnnotation(Decrypt.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HttpInputMessage <span class="hljs-title">beforeBodyRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpInputMessage inputMessage, MethodParameter parameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] body = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[inputMessage.getBody().available()];</span><br><span class="line">        inputMessage.getBody().read(body);</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">byte</span>[] decrypt = AESUtils.decrypt(body, encryptProperties.getKey().getBytes());</span><br><span class="line">            <span class="hljs-keyword">final</span> ByteArrayInputStream bais = <span class="hljs-keyword">new</span> ByteArrayInputStream(decrypt);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpInputMessage() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getBody</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> bais;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> HttpHeaders <span class="hljs-title">getHeaders</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> inputMessage.getHeaders();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先大家注意，DecryptRequest 类我们没有直接实现 <code>RequestBodyAdvice</code> 接口，而是继承自 RequestBodyAdviceAdapter 类，该类是 RequestBodyAdvice 接口的子类，并且实现了接口中的一些方法，这样当我们继承自 RequestBodyAdviceAdapter 时，就只需要根据自己实际需求实现某几个方法即可。</li><li>supports：该方法用来判断哪些接口需要处理接口解密，我们这里的判断逻辑是方法上或者参数上含有 <code>@Decrypt</code> 注解的接口，处理解密问题。</li><li>beforeBodyRead：这个方法会在参数转换成具体的对象之前执行，我们先从流中加载到数据，然后对数据进行解密，解密完成后再重新构造 HttpInputMessage 对象返回。</li></ol><p>接下来，我们再来定义一个自动化配置类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(<span class="hljs-string">"org.javaboy.encrypt.starter"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也没啥好说的，比较简单。</p><p>最后，resources 目录下定义 META-INF，然后再定义 spring.factories 文件，内容如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=org.javaboy.encrypt.starter.autoconfig.EncryptAutoConfiguration</span><br></pre></td></tr></table></figure><p>这样当项目启动时，就会自动加载该配置类。</p><p>至此，我们的 starter 就开发完成啦。</p><h2 id="2-打包发布"><a href="#2-打包发布" class="headerlink" title="2.打包发布"></a>2.打包发布</h2><p>我们可以将项目安装到本地仓库，也可以发布到线上供他人使用。</p><h3 id="2-1-安装到本地仓库"><a href="#2-1-安装到本地仓库" class="headerlink" title="2.1 安装到本地仓库"></a>2.1 安装到本地仓库</h3><p>安装到本地仓库比较简单，直接 <code>mvn install</code>，或者在 IDEA 中，点击右边的 Maven，然后双击 install，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210309110308.png" alt></p><h3 id="2-2-发布到线上"><a href="#2-2-发布到线上" class="headerlink" title="2.2 发布到线上"></a>2.2 发布到线上</h3><p>发不到线上我们可以使用 JitPack 来做。</p><p>首先我们在 GitHub 上创建一个仓库，将我们的代码上传上去，这个过程应该不用我多说吧。</p><p>上传成功后，点击右边的 <code>Create a new release</code> 按钮，发布一个正式版，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210309111015.png" alt></p><p><img src="http://img.itboyhub.com/2021/02/20210309115344.png" alt></p><p>发布成功后，打开 jitpack，输入仓库的完整路径，点击 lookup 按钮，查找到之后，再点击 <code>Get it</code> 按钮完成构建，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210309115450.png" alt></p><p>构建成功后，JitPack 上会给出项目引用方式：</p><p><img src="http://img.itboyhub.com/2021/02/20210309111839.png" alt></p><p>注意引用时将 tag 改成你具体的版本号。</p><p>至此，我们的工具就已经成功发布了！小伙伴们可以通过如下方式引用这个 starter：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.lenve<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>encrypt-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jitpack.io<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://jitpack.io<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h2><p>我们创建一个普通的 Spring Boot 项目，引入 web 依赖，再引入我们刚刚的 starter 依赖，如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.github.lenve&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;encrypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;jitpack.io&lt;/id&gt;</span><br><span class="line">        &lt;url&gt;https:<span class="hljs-comment">//jitpack.io&lt;/url&gt;</span></span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure><p>然后再创建一个实体类备用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-meta">@Encrypt</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setId((<span class="hljs-keyword">long</span>) <span class="hljs-number">99</span>);</span><br><span class="line">        user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"ok"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">addUser</span><span class="hljs-params">(@RequestBody @Decrypt User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"ok"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个接口使用了 <code>@Encrypt</code> 注解，所以会对该接口的数据进行加密（如果不使用该注解就不加密），第二个接口使用了 <code>@Decrypt</code> 所以会对上传的参数进行解密，注意 <code>@Decrypt</code> 注解既可以放在方法上也可以放在参数上。</p><p>接下来启动项目进行测试。</p><p>首先测试 get 请求接口：</p><p><img src="http://img.itboyhub.com/2021/02/20210309120433.png" alt></p><p>可以看到，返回的数据已经加密。</p><p>再来测试 post 请求：</p><p><img src="http://img.itboyhub.com/2021/02/20210309120520.png" alt></p><p>可以看到，参数中的加密数据已经被还原了。</p><p>如果用户想要修改加密密钥，可以在 application.properties 中添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.encrypt.key=1234567890123456</span><br></pre></td></tr></table></figure><p>加密数据到了前端，前端也有一些 js 工具来处理加密数据，这个松哥后面有空再和大家说说 js 的加解密。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天这篇文章主要是想和大家聊聊 ResponseBodyAdvice 和 RequestBodyAdvice 的用法，一些加密思路，当然 ResponseBodyAdvice 和 RequestBodyAdvice 还有很多其他的使用场景，小伙伴们可以自行探索～本文使用了对称加密中的 AES 算法，大家也可以尝试改成非对称加密。</p><p>好啦，今天就聊这么多，小伙伴们可以去试试啦～公号后台回复 20210309 可以下载本文案例～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为有小伙伴刚好问到这个问题，松哥就抽空撸一篇文章和大家聊聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring5 里边的新玩法！这种 URL 请求让我涨见识了！</title>
    <link href="http://www.javaboy.org/2021/0307/springmvc-pathpattern.html"/>
    <id>http://www.javaboy.org/2021/0307/springmvc-pathpattern.html</id>
    <published>2021-03-07T14:41:20.000Z</published>
    <updated>2021-03-07T15:16:07.570Z</updated>
    
    <content type="html"><![CDATA[<p>Spring5 也已经出来好久了，里边有一些新玩法也需要我们去慢慢揭开面纱，这不，松哥最近在研究 SpringMVC 源码的时候，就看到这样一段代码：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">initLookupPath</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (usesPathPatterns()) &#123;</span><br><span class="line">request.removeAttribute(UrlPathHelper.PATH_ATTRIBUTE);</span><br><span class="line">RequestPath requestPath = ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">String lookupPath = requestPath.pathWithinApplication().value();</span><br><span class="line"><span class="hljs-keyword">return</span> UrlPathHelper.defaultInstance.removeSemicolonContent(lookupPath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getUrlPathHelper().resolveAndCacheLookupPath(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是 Spring5 里边出来的，以前是没有这个方法的。在旧的 SpringMVC 中，当我们需要获取当前请求地址的时候，直接通过如下方式获取：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String lookupPath = <span class="hljs-keyword">this</span>.getUrlPathHelper().getLookupPathForRequest(request);</span><br></pre></td></tr></table></figure><p>但是现在变了，现在获取当前请求 URL 地址时，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String lookupPath = initLookupPath(request);</span><br></pre></td></tr></table></figure><p>两种方式相比，主要是 initLookupPath 方法中多了 usesPathPatterns 选项，这是 Spring5 中的新玩意，所以今天松哥就通过一篇简单的文章来和大家分享一下 usesPathPatterns 到底是什么，该怎么玩！</p><p>这可不是一个小变化哦！特别是如果你在项目中使用了 WebFlux，那么这个东西就显得尤为重要了！</p><h2 id="AntPathMatcher"><a href="#AntPathMatcher" class="headerlink" title="AntPathMatcher"></a>AntPathMatcher</h2><p>当我们使用 @RequestMapping 注解去标记请求接口的时候（或者使用它的类似方法如 @GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping），我们可以使用一些通配符去匹配 URL 地址，举个简单例子，假设我有下面五个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello/**/hello"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/hello/**/hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/h?llo"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/h?llo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/**/*.html"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/**/*.html"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello/&#123;p1&#125;/&#123;p2&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello4</span><span class="hljs-params">(@PathVariable String p1, @PathVariable String p2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"p1 = "</span> + p1);</span><br><span class="line">    System.out.println(<span class="hljs-string">"p2 = "</span> + p2);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"/hello/&#123;p1&#125;/&#123;p2&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(@PathVariable String name, @PathVariable String version, @PathVariable String ext)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    System.out.println(<span class="hljs-string">"version = "</span> + version);</span><br><span class="line">    System.out.println(<span class="hljs-string">"ext = "</span> + ext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解释接口的含义之前，先来说说这几个通配符的含义：</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>**</code></td><td style="text-align:left">匹配0个或者多个目录</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配0个或者多个字符</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配任意单个字符</td></tr></tbody></table><p>了解了通配符的含义，我们再来说说各个接口都能接收哪些请求：</p><ul><li>第一个接口，可以接收诸如 <code>/hello/123/123/hello</code>、<code>/hello/a/hello</code> 以及 <code>/hello/hello</code> 这样的请求，因为中间的 <code>**</code> 代表 0 个或者多个目录。</li><li>第二个接口，可以接收诸如 <code>/hallo</code>、<code>/hello</code>、<code>/hMllo</code> 之类的请求，注意它不能接收 <code>/haallo</code> 或者 <code>/hllo</code>，因为 <code>?</code> 表示一个字符。</li><li>第三个接口可以接收任意以 <code>.html</code> 为后缀的请求，例如 <code>/aaa/bb/cc.html</code>、<code>/aa.html</code> 或者 <code>/aa/aa.html</code>。</li><li>第四个接口估计大家都比较熟悉，在 RESTful 风格的接口设计中估计大家都用过，它接收的请求格式类似于 <code>/hello/aa/bb</code>，其中参数 p1 就对应 aa，参数 p2 对应 bb。</li><li>第五个接口则用到了正则，name、version 以及 ext 三个参数格式用正则表达出来，它可以接收诸如 <code>/spring-web-3.0.5.jar</code> 格式的请求，最终的参数 name 就是 <code>spring-web</code>，version 就是 <code>3.0.5</code>，ext 则是 <code>.jar</code>。</li></ul><p>这是 SpringMVC 中之前就存在的功能，不管你用没用过，反正它一致存在。</p><p>那么是谁支撑了这个功能呢？那就是 AntPathMatcher。</p><p>AntPathMatcher 是一个实现了 Ant 风格的路径匹配器，Ant 风格的路径规则实际上就是我们前面给大家介绍的那三种路径匹配符，很 Easy。这种路径匹配规则源自 Apache Ant 项目（<a href="https://ant.apache.org），Apache" target="_blank" rel="noopener">https://ant.apache.org），Apache</a> Ant 我们现在其实已经很少会用到了，它的替代品就是大家所熟知的 Maven，如果你有幸维护一些 2010 年之前的老项目的话，有可能会接触到 Ant。</p><p>AntPathMatcher 实际上在 SpringMVC 中有非常广泛的应用，不仅仅是在 @RequestMapping 中定义接口用到，在其他一些涉及到地址匹配的地方也会用到，例如我们在 SpringMVC 的配置文件中配置静态资源过滤时，也是 Ant 风格路径匹配：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/**"</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>另外像拦截器里的拦截路径注册、跨域处理时的路径匹配等等，都会用到 Ant 风格的路径匹配符。</p><p>整体上来说，AntPathMatcher 是 Spring 中一种比较原始的路径匹配解决方案，虽然比较简单，但是它的效率很低，并且在处理 URL 编码的时候也很不方便。</p><p>因此，才有了 Spring5 中的 PathPattern。</p><h2 id="PathPattern"><a href="#PathPattern" class="headerlink" title="PathPattern"></a>PathPattern</h2><p>PathPattern 专为 Web 应用设计，它与之前的 AntPathMatcher 功能大部分比较类似，当然也有一些细微差异，这个松哥后面会说。</p><p>如果是 Servlet 应用，目前官方推荐的 URL 匹配解决方案就是 PathPattern（当然你也可以选择较早的 AntPathMatcher），虽然官方推荐的是 PathPattern，但实际上默认使用的依然是 AntPathMatcher；如果你用的是 WebFlux，PathPattern 就是唯一解决方案了。</p><blockquote><p>注意，PathPattern 是一个非常新鲜的玩艺，目前 Spring 最新版是 5.3.4，在 Spring5.3 之前，我们在 Servlet 应用中，也只能选择 AntPathMatcher，从 Spring5.3 之后，我们才可以使用 PathPattern 了。</p></blockquote><p>PathPattern 会将 URL 规则预解析为 PathContainer，它对 URL 地址匹配的处理更加快速，PathPattern 与 AntPathMatcher 的差异主要体现在两个方面：</p><p>第一，PathPattern 只支持结尾部分使用 <code>**</code>，如果在路径的中间使用 <code>**</code> 就会报错，上文中第一个和第三个接口，在 PathPattern 模式下会报错，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210306174530.png" alt></p><p>因为在中间或者开始使用 <code>**</code> 极易造成混乱，因此 PathPattern 只支持在结尾使用 <code>**</code>。</p><p>第二，PathPattern 支持使用诸如 <code>{*path}</code> 的方式进行路径匹配，这种写法也可以匹配到多层路径，并且将匹配到的值赋值给 path 变量，例如如下一个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/javaboy/&#123;*path&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello6</span><span class="hljs-params">(@PathVariable String path)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"path = "</span> + path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果请求路径是 <code>http://localhost:8080/javaboy/aa</code>，那么参数 path 的值就是 <code>/aa</code>；</p><p>如果请求路径是 <code>http://localhost:8080/javaboy/aa/bb/cc/dd</code>，那么参数 path 的值就是 <code>/aa/bb/cc/dd</code>；</p><p>这个写法也比较新颖，因为之前的 AntPathMatcher 里边没有这个。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>默认情况下，SpringMVC 中使用的还是 AntPathMatcher，那么如何开启 PathPattern 呢？很简单，在 SpringBoot 项目中只需要添加如下配置即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.setPatternParser(<span class="hljs-keyword">new</span> PathPatternParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了这个配置后，在我们文章一开始贴出来的代码里，就会进入到 if 分支中，进而使用 PathPattern 去解析请求 URL。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好啦，今天就和小伙伴们聊这么多，大家可以体验一把这个东东，不过注意选择 Spring 的版本哦，一定选择 5.3 之上的版本～大家周末愉快哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring5 也已经出来好久了，里边有一些新玩法也需要我们去慢慢揭开面纱，这不，松哥最近在研究 SpringMVC 源码的时候，就看到这样一段代码：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>来啦来啦，松哥的免费视频教程来啦！</title>
    <link href="http://www.javaboy.org/2021/0304/mybatis-video.html"/>
    <id>http://www.javaboy.org/2021/0304/mybatis-video.html</id>
    <published>2021-03-04T14:41:04.000Z</published>
    <updated>2021-03-07T15:08:10.346Z</updated>
    
    <content type="html"><![CDATA[<p>ssm 系列的最后一个专题 MyBatis 总算录完了，念叨了两年的 ssm 教程总算搞定了，其实真的认真做花不了多少时间，就是拖延症太可怕了。松哥亲身经历劝诫各位小伙伴，今日事今日毕，拖了一天就有可能拖一个月拖一年。。。</p><a id="more"></a><p>不说了，看干货吧，松哥最近加班加点录的，自认为讲的还比较详细，除了 MyBatis 最基本的用法，还带手把手教大家开发 MyBatis 插件，除了教大家用开源的 MyBatis 逆向工程，还手把手教大家自己开发 MyBatis 逆向工程，不废话了，赶紧来看看目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">├── 01.MyBatis 视频介绍.mp4</span><br><span class="line">├── 02.MyBatis 简单介绍.mp4</span><br><span class="line">├── 03.HelloWorld.mp4</span><br><span class="line">├── 04.SqlSessionFactory单例模式.mp4</span><br><span class="line">├── 05.通过 Log4j 查看 MyBatis 运行日志.mp4</span><br><span class="line">├── 06.MyBatis 增删改查.mp4</span><br><span class="line">├── 07.MyBatis 引入 Mapper.mp4</span><br><span class="line">├── 08.# 和 $ 的区别.mp4</span><br><span class="line">├── 09.Mapper 中多个参数如何处理.mp4</span><br><span class="line">├── 10.@Param 注解源码解析.mp4</span><br><span class="line">├── 11.Mapper 中使用实体类做参数.mp4</span><br><span class="line">├── 12.Mapper 中使用 Map 做参数.mp4</span><br><span class="line">├── 13.MyBatis 两种主键回填方式.mp4</span><br><span class="line">├── 14.resultType 玩法.mp4</span><br><span class="line">├── 15.resultMap 使用详解.mp4</span><br><span class="line">├── 16.【动态 SQL】之 if.mp4</span><br><span class="line">├── 17.【动态 SQL】之 choose.mp4</span><br><span class="line">├── 18.【动态 SQL】之 where.mp4</span><br><span class="line">├── 19.【动态 SQL】之 set.mp4</span><br><span class="line">├── 20.【动态 SQL】之 trim.mp4</span><br><span class="line">├── 21.【动态 SQL】之 foreach.mp4</span><br><span class="line">├── 22.【动态 SQL】之 bind.mp4</span><br><span class="line">├── 23.MyBatis 多数据库支持.mp4</span><br><span class="line">├── 24.查询结果一对一映射【1】.mp4</span><br><span class="line">├── 25.查询结果一对一映射【2】.mp4</span><br><span class="line">├── 26.查询结果一对一映射【3】.mp4</span><br><span class="line">├── 27.查询结果一对一映射【懒加载】.mp4</span><br><span class="line">├── 28.查询结果一对多映射.mp4</span><br><span class="line">├── 29.查询结果一对多映射【懒加载】.mp4</span><br><span class="line">├── 30.鉴别映射器.mp4</span><br><span class="line">├── 31.自定义类型转换器.mp4</span><br><span class="line">├── 32.MyBatis 一级缓存.mp4</span><br><span class="line">├── 33.MyBatis 二级缓存.mp4</span><br><span class="line">├── 34.MyBatis 使用 Redis 做缓存.mp4</span><br><span class="line">├── 35.MyBatis 内存分页.mp4</span><br><span class="line">├── 36.自定义 MyBatis 插件【1】.mp4</span><br><span class="line">├── 37.自定义 MyBatis 插件【2】.mp4</span><br><span class="line">├── 38.自定义 MyBatis 分页插件.mp4</span><br><span class="line">├── 39.MyBatis 逆向工程使用.mp4</span><br><span class="line">└── 40.SSM 整合.mp4</span><br><span class="line">├── 41.【自定义逆向工具】项目介绍.mp4</span><br><span class="line">├── 42.【自定义逆向工具】数据库连接.mp4</span><br><span class="line">├── 43.【自定义逆向工具】加载数据表信息.mp4</span><br><span class="line">├── 44.【自定义逆向工具】生成 Model.mp4</span><br><span class="line">├── 45.【自定义逆向工具】生成其他类.mp4</span><br></pre></td></tr></table></figure><p>视频的笔记、案例这次也会一并分享给大家，小伙伴们在公众号【江南一点雨】后台回复 <strong>mybatis</strong>，获取视频播放链接以及笔记、案例的下载链接。</p><p>Spring 和 SpringMVC 的免费视频松哥之前也已经发过了，大家可以在公众号【江南一点雨】后台回复 <strong>ssm</strong> 获取整个系列的学习资料～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ssm 系列的最后一个专题 MyBatis 总算录完了，念叨了两年的 ssm 教程总算搞定了，其实真的认真做花不了多少时间，就是拖延症太可怕了。松哥亲身经历劝诫各位小伙伴，今日事今日毕，拖了一天就有可能拖一个月拖一年。。。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 中的参数还能这么传递？涨姿势了！</title>
    <link href="http://www.javaboy.org/2021/0302/springmvc-flashmap.html"/>
    <id>http://www.javaboy.org/2021/0302/springmvc-flashmap.html</id>
    <published>2021-03-02T14:40:10.000Z</published>
    <updated>2021-03-07T15:08:16.098Z</updated>
    
    <content type="html"><![CDATA[<p>今天来聊一个 JavaWeb 中简单的话题，但是感觉却比较稀罕，因为这个技能点，有的小伙伴们可能没听过！</p><a id="more"></a><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1.缘起"></a>1.缘起</h2><p>说到 Web 请求参数传递，大家能想到哪些参数传递方式？</p><p>参数可以放在地址栏中，不过地址栏参数的长度有限制，并且在有的场景下我们可能不希望参数暴漏在地址栏中。参数可以放在请求体中，这个没啥好说的。</p><p>小伙伴们试想这样一个场景：</p><p>在一个电商项目中，有一个提交订单的请求，这个请求是一个 POST 请求，请求参数都在请求体中。当用户提交成功后，为了防止用户刷新浏览器页面造成订单请求重复提交，我们一般会将用户重定向到一个显示订单的页面，这样即使用户刷新页面，也不会造成订单请求重复提交。</p><p>大概的代码就像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">order</span><span class="hljs-params">(OrderInfo orderInfo)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//其他处理逻辑</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/orderlist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码我相信大家都懂吧！如果不懂可以看看松哥录制的免费的 SpringMVC 入门教程（<a href="https://mp.weixin.qq.com/s/KONEIdt_c3Di1zMlXGLxuw" target="_blank" rel="noopener">硬核！松哥又整了一套免费视频，搞起！</a>）。</p><p>但是这里有一个问题：如果我想传递参数怎么办？</p><p>如果是服务器端跳转，我们可以将参数放在 request 对象中，跳转完成后还能拿到参数，但是如果是客户端跳转我们就只能将参数放在地址栏中了，像上面这个方法的返回值我们可以写成：<code>return &quot;redirect:/orderlist?xxx=xxx&quot;;</code>，这种传参方式有两个缺陷：</p><ul><li>地址栏的长度是有限的，也就意味着能够放在地址栏中的参数是有限的。</li><li>不想将一些特殊的参数放在地址栏中。</li></ul><p>那该怎么办？还有办法传递参数吗？</p><p>有！这就是今天松哥要和大家介绍的 flashMap，专门用来解决重定向时参数的传递问题。</p><h2 id="2-flashMap"><a href="#2-flashMap" class="headerlink" title="2.flashMap"></a>2.flashMap</h2><p>在重定向时，如果需要传递参数，但是又不想放在地址栏中，我们就可以通过 flashMap 来传递参数，松哥先来一个简单的例子大家看看效果：</p><p>首先我们定义一个简单的页面，里边就一个 post 请求提交按钮，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/order"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在服务端接收该请求，并完成重定向：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">order</span><span class="hljs-params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        FlashMap flashMap = (FlashMap) req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE);</span><br><span class="line">        flashMap.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/orderlist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/orderlist"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">orderList</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (String) model.getAttribute(<span class="hljs-string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在 order 接口中，获取到 flashMap 属性，然后存入需要传递的参数，这些参数最终会被 SpringMVC 自动放入重定向接口的 Model 中，这样我们在 orderlist 接口中，就可以获取到该属性了。</p><p>当然，这是一个比较粗糙的写法，我们还可以通过 RedirectAttributes 来简化这一步骤：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/order"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">order</span><span class="hljs-params">(RedirectAttributes attr)</span> </span>&#123;</span><br><span class="line">        attr.addFlashAttribute(<span class="hljs-string">"site"</span>, <span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        attr.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"微信公众号：江南一点雨"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/orderlist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/orderlist"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">orderList</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (String) model.getAttribute(<span class="hljs-string">"site"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedirectAttributes 中有两种添加参数的方式：</p><ul><li>addFlashAttribute：将参数放到 flashMap 中。</li><li>addAttribute：将参数放到 URL 地址中。</li></ul><p>经过前面的讲解，现在小伙伴们应该大致明白了 flashMap 的作用了，就是在你进行重定向的时候，不通过地址栏传递参数。</p><p>很多小伙伴可能会有疑问，重定向其实就是浏览器发起了一个新的请求，这新的请求怎么就获取到上一个请求保存的参数呢？这我们就要来看看 SpringMVC 的源码了。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><p>首先这里涉及到一个关键类叫做 FlashMapManager，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FlashMapManager</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">FlashMap <span class="hljs-title">retrieveAndUpdate</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveOutputFlashMap</span><span class="hljs-params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法含义一眼就能看出来：</p><ul><li>retrieveAndUpdate：这个方法用来恢复参数，并将恢复过的的参数和超时的参数从保存介质中删除。</li><li>saveOutputFlashMap：将参数保存保存起来。</li></ul><p>FlashMapManager 的实现类如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210301173455.png" alt></p><p>从这个继承类中，我们基本上就能确定默认的保存介质时 session。具体的保存逻辑则是在 AbstractFlashMapManager 类中。</p><p>整个参数传递的过程可以分为三大步：</p><p>第一步，首先我们将参数设置到 outputFlashMap 中，有两种设置方式：我们前面的代码 <code>req.getAttribute(DispatcherServlet.OUTPUT_FLASH_MAP_ATTRIBUTE)</code> 就是直接获取 outputFlashMap 对象然后把参数放进去；第二种方式就是通过在接口中添加 RedirectAttributes 参数，然后把需要传递的参数放入 RedirectAttributes 中，这样当处理器处理完毕后，会自动将其设置到 outputFlashMap 中，具体逻辑在 RequestMappingHandlerAdapter#getModelAndView 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title">getModelAndView</span><span class="hljs-params">(ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (model <span class="hljs-keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (request != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果 model 是 RedirectAttributes 的实例的话，则通过 getOutputFlashMap 方法获取到 outputFlashMap 属性，然后相关的属性设置进去。</p><p>这是第一步，就是将需要传递的参数，先保存到 flashMap 中。</p><p>第二步，重定向对应的视图是 RedirectView，在它的 renderMergedOutputModel 方法中，会调用 FlashMapManager 的 saveOutputFlashMap 方法，将 outputFlashMap 保存到 session 中，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renderMergedOutputModel</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String targetUrl = createTargetUrl(model, request);</span><br><span class="line">targetUrl = updateTargetUrl(targetUrl, model, request, response);</span><br><span class="line"><span class="hljs-comment">// Save flash attributes</span></span><br><span class="line">RequestContextUtils.saveOutputFlashMap(targetUrl, request, response);</span><br><span class="line"><span class="hljs-comment">// Redirect</span></span><br><span class="line">sendRedirect(request, response, targetUrl, <span class="hljs-keyword">this</span>.http10Compatible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestContextUtils.saveOutputFlashMap 方法最终就会调用到 FlashMapManager 的 saveOutputFlashMap 方法，将 outputFlashMap 保存下来。我们来大概看一下保存逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveOutputFlashMap</span><span class="hljs-params">(FlashMap flashMap, HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(flashMap)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String path = decodeAndNormalizePath(flashMap.getTargetRequestPath(), request);</span><br><span class="line">flashMap.setTargetRequestPath(path);</span><br><span class="line">flashMap.startExpirationPeriod(getFlashMapTimeout());</span><br><span class="line">Object mutex = getFlashMapsMutex(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (mutex != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line">allFlashMaps = (allFlashMaps != <span class="hljs-keyword">null</span> ? allFlashMaps : <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;());</span><br><span class="line">allFlashMaps.add(flashMap);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line">allFlashMaps = (allFlashMaps != <span class="hljs-keyword">null</span> ? allFlashMaps : <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>));</span><br><span class="line">allFlashMaps.add(flashMap);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里的逻辑也很简单，保存之前会给 flashMap 设置两个属性，一个是重定向的 url 地址，另一个则是过期时间，过期时间默认 180 秒，这两个属性在第三步加载 flashMap 的时候会用到。然后将 flashMap 放入集合中，并调用 updateFlashMaps 方法存入 session 中。</p><p>第三步，当重定向请求到达 DispatcherServlet#doService 方法后，此时会调用 FlashMapManager#retrieveAndUpdate 方法从 Session 中获取 outputFlashMap 并设置到 Request 属性中备用（最终会被转化到 Model 中的属性），相关代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里获取出来的 outputFlashMap 换了一个名字，变成了 inputFlashMap，其实是同一个东西。</p><p>我们可以大概看一下获取的逻辑 AbstractFlashMapManager#retrieveAndUpdate：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> FlashMap <span class="hljs-title">retrieveAndUpdate</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">List&lt;FlashMap&gt; allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(allFlashMaps)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;FlashMap&gt; mapsToRemove = getExpiredFlashMaps(allFlashMaps);</span><br><span class="line">FlashMap match = getMatchingFlashMap(allFlashMaps, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (match != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mapsToRemove.add(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!mapsToRemove.isEmpty()) &#123;</span><br><span class="line">Object mutex = getFlashMapsMutex(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (mutex != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">allFlashMaps = retrieveFlashMaps(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (allFlashMaps != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">allFlashMaps.removeAll(mapsToRemove);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">allFlashMaps.removeAll(mapsToRemove);</span><br><span class="line">updateFlashMaps(allFlashMaps, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先调用 retrieveFlashMaps 方法从 session 中获取到所有的 FlashMap。</li><li>调用 getExpiredFlashMaps 方法获取所有过期的 FlashMap，FlashMap 默认的过期时间是 180s。</li><li>获取和当前请求匹配的 getMatchingFlashMap，具体的匹配逻辑就两点：重定向地址要和当前请求地址相同；预设参数要相同。一般来说我们不需要配置预设参数，所以这一条可以忽略。如果想要设置，则首先给 flashMap 设置，像这样：<code>flashMap.addTargetRequestParam(&quot;aa&quot;, &quot;bb&quot;);</code>，然后在重定向的地址栏也加上这个参数：<code>return &quot;redirect:/orderlist?aa=bb&quot;;</code> 即可。</li><li>将获取到的匹配的 FlashMap 对象放入 mapsToRemove 集合中（这个匹配到的 FlashMap 即将失效，放入集合中一会被清空）。</li><li>将 allFlashMaps 集合中的所有 mapsToRemove 数据清空，同时调用 updateFlashMaps 方法更新 session 中的 FlashMap。</li><li>最终将匹配到的 flashMap 返回。</li></ul><p>这就是整个获取 flashMap 的方法，整体来看还是非常 easy 的，并没有什么难点。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和小伙伴们分享了一下 SpringMVC 中的 flashMap，不知道大家有没有在工作中用到这个东西？如果刚好碰到松哥前面所说的需求，用 FlashMap 真的还是蛮方便的。如果需要下载本文案例，小伙伴们可以在公众号后台回复 <code>20210302</code>，好啦，今天就和大家聊这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来聊一个 JavaWeb 中简单的话题，但是感觉却比较稀罕，因为这个技能点，有的小伙伴们可能没听过！&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你开发 MyBatis 插件</title>
    <link href="http://www.javaboy.org/2021/0226/mybatis-plugin.html"/>
    <id>http://www.javaboy.org/2021/0226/mybatis-plugin.html</id>
    <published>2021-02-26T14:39:55.000Z</published>
    <updated>2021-03-07T15:08:01.401Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴们元宵节快乐，记得吃元宵哦～</p><a id="more"></a><p>在日常开发中，小伙伴们多多少少都有用过 MyBatis 插件，松哥猜测大家用的最多的就是 MyBatis 的分页插件！不知道小伙伴们有没有想过有一天自己也来开发一个 MyBatis 插件？</p><p>其实自己动手撸一个 MyBatis 插件并不难，今天松哥就把手带大家撸一个 MyBatis 插件！</p><h2 id="1-MyBatis-插件接口"><a href="#1-MyBatis-插件接口" class="headerlink" title="1.MyBatis 插件接口"></a>1.MyBatis 插件接口</h2><p>即使你没开发过 MyBatis 插件，估计也能猜出来，MyBatis 插件是通过拦截器来起作用的，MyBatis 框架在设计的时候，就已经为插件的开发预留了相关接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中就三个方法，第一个方法必须实现，后面两个方法都是可选的。三个方法作用分别如下：</p><ol><li><p>intercept：这个就是具体的拦截方法，我们自定义 MyBatis 插件时，一般都需要重写该方法，我们插件所完成的工作也都是在该方法中完成的。</p></li><li><p>plugin：这个方法的参数 target 就是拦截器要拦截的对象，一般来说我们不需要重写该方法。Plugin.wrap 方法会自动判断拦截器的签名和被拦截对象的接口是否匹配，如果匹配，才会通过动态代理拦截目标对象。</p></li><li><p>setProperties：这个方法用来传递插件的参数，可以通过参数来改变插件的行为。我们定义好插件之后，需要对插件进行配置，在配置的时候，可以给插件设置相关属性，设置的属性可以通过该方法获取到。插件属性设置像下面这样：</p></li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"org.javaboy.mybatis03.plugin.CamelInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"xxx"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"xxx"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-MyBatis-拦截器签名"><a href="#2-MyBatis-拦截器签名" class="headerlink" title="2.MyBatis 拦截器签名"></a>2.MyBatis 拦截器签名</h2><p>拦截器定义好了后，拦截谁？</p><p>这个就需要拦截器签名来完成了！</p><p>拦截器签名是一个名为 @Intercepts 的注解，该注解中可以通过 @Signature 配置多个签名。@Signature 注解中则包含三个属性：</p><ul><li>type: 拦截器需要拦截的接口，有 4 个可选项，分别是：Executor、ParameterHandler、ResultSetHandler 以及 StatementHandler。</li><li>method: 拦截器所拦截接口中的方法名，也就是前面四个接口中的方法名，接口和方法要对应上。</li><li>args: 拦截器所拦截方法的参数类型，通过方法名和参数类型可以锁定唯一一个方法。</li></ul><p>一个简单的签名可能像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Intercepts</span>(<span class="hljs-meta">@Signature</span>(</span><br><span class="line">        type = ResultSetHandler.class,</span><br><span class="line">        method = <span class="hljs-string">"handleResultSets"</span>,</span><br><span class="line">        args = &#123;Statement.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CamelInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-被拦截的对象"><a href="#3-被拦截的对象" class="headerlink" title="3.被拦截的对象"></a>3.被拦截的对象</h2><p>根据前面的介绍，被拦截的对象主要有如下四个：</p><p><strong>Executor</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ResultHandler NO_RESULT_HANDLER = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(MappedStatement ms, Object parameter)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">Cursor&lt;E&gt; <span class="hljs-title">queryCursor</span><span class="hljs-params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">List&lt;BatchResult&gt; <span class="hljs-title">flushStatements</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> required)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> required)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">CacheKey <span class="hljs-title">createCacheKey</span><span class="hljs-params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCached</span><span class="hljs-params">(MappedStatement ms, CacheKey key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearLocalCache</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deferLoad</span><span class="hljs-params">(MappedStatement ms, MetaObject resultObject, String property, CacheKey key, Class&lt;?&gt; targetType)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Transaction <span class="hljs-title">getTransaction</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceRollback)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isClosed</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setExecutorWrapper</span><span class="hljs-params">(Executor executor)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>update：该方法会在所有的 INSERT、 UPDATE、 DELETE 执行时被调用，如果想要拦截这些操作，可以通过该方法实现。</li><li>query：该方法会在 SELECT 查询方法执行时被调用，方法参数携带了很多有用的信息，如果需要获取，可以通过该方法实现。</li><li>queryCursor：当 SELECT 的返回类型是 Cursor 时，该方法会被调用。</li><li>flushStatements：当 SqlSession 方法调用 flushStatements 方法或执行的接口方法中带有 @Flush 注解时该方法会被触发。</li><li>commit：当 SqlSession 方法调用 commit 方法时该方法会被触发。</li><li>rollback：当 SqlSession 方法调用 rollback 方法时该方法会被触发。</li><li>getTransaction：当 SqlSession 方法获取数据库连接时该方法会被触发。</li><li>close：该方法在懒加载获取新的 Executor 后会被触发。</li><li>isClosed：该方法在懒加载执行查询前会被触发。</li></ul><p><strong>ParameterHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ParameterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Object <span class="hljs-title">getParameterObject</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParameters</span><span class="hljs-params">(PreparedStatement ps)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>getParameterObject：在执行存储过程处理出参的时候该方法会被触发。</li><li>setParameters：设置 SQL 参数时该方法会被触发。</li></ul><p><strong>ResultSetHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">handleResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">Cursor&lt;E&gt; <span class="hljs-title">handleCursorResultSets</span><span class="hljs-params">(Statement stmt)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleOutputParameters</span><span class="hljs-params">(CallableStatement cs)</span> <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>handleResultSets：该方法会在所有的查询方法中被触发（除去返回值类型为 Cursor<e> 的查询方法），一般来说，如果我们想对查询结果进行二次处理，可以通过拦截该方法实现。</e></li><li>handleCursorResultSets：当查询方法的返回值类型为 Cursor<e> 时，该方法会被触发。</e></li><li>handleOutputParameters：使用存储过程处理出参的时候该方法会被调用。</li></ul><p><strong>StatementHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">Statement <span class="hljs-title">prepare</span><span class="hljs-params">(Connection connection, Integer transactionTimeout)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parameterize</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">batch</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(Statement statement, ResultHandler resultHandler)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; <span class="hljs-function">Cursor&lt;E&gt; <span class="hljs-title">queryCursor</span><span class="hljs-params">(Statement statement)</span></span></span><br><span class="line"><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">BoundSql <span class="hljs-title">getBoundSql</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function">ParameterHandler <span class="hljs-title">getParameterHandler</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各方法含义分别如下：</p><ul><li>prepare：该方法在数据库执行前被触发。</li><li>parameterize：该方法在 prepare 方法之后执行，用来处理参数信息。</li><li>batch：如果 MyBatis 的全剧配置中配置了 <code>defaultExecutorType=”BATCH”</code>，执行数据操作时该方法会被调用。</li><li>update：更新操作时该方法会被触发。</li><li>query：该方法在 SELECT 方法执行时会被触发。</li><li>queryCursor：该方法在 SELECT 方法执行时，并且返回值为 Cursor 时会被触发。</li></ul><p>在开发一个具体的插件时，我们应当根据自己的需求来决定到底拦截哪个方法。</p><h2 id="4-开发分页插件"><a href="#4-开发分页插件" class="headerlink" title="4.开发分页插件"></a>4.开发分页插件</h2><h3 id="4-1-内存分页"><a href="#4-1-内存分页" class="headerlink" title="4.1 内存分页"></a>4.1 内存分页</h3><p>MyBatis 中提供了一个不太好用的内存分页功能，就是一次性把所有数据都查询出来，然后在内存中进行分页处理，这种分页方式效率很低，基本上没啥用，但是如果我们想要自定义分页插件，就需要对这种分页方式有一个简单了解。</p><p>内存分页的使用方式如下，首先在 Mapper 中添加 RowBounds 参数，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsersByPage</span><span class="hljs-params">(RowBounds rowBounds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中定义相关 SQL：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUsersByPage"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.mybatis03.model.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在 SQL 定义时，压根不用管分页的事情，MyBatis 会查询到所有的数据，然后在内存中进行分页处理。</p><p>Mapper 中方法的调用方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class);</span><br><span class="line">    RowBounds rowBounds = <span class="hljs-keyword">new</span> RowBounds(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.getAllUsersByPage(rowBounds);</span><br><span class="line">    <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建 RowBounds 时传入两个参数，分别是 offset 和 limit，对应分页 SQL 中的两个参数。也可以通过 RowBounds.DEFAULT 的方式构建一个 RowBounds 实例，这种方式构建出来的 RowBounds 实例，offset 为 0，limit 则为 Integer.MAX_VALUE，也就相当于不分页。</p><p>这就是 MyBatis 中提供的一个很不实用的内存分页功能。</p><p>了解了 MyBatis 自带的内存分页之后，接下来我们就可以来看看如何自定义分页插件了。</p><h3 id="4-2-自定义分页插件"><a href="#4-2-自定义分页插件" class="headerlink" title="4.2 自定义分页插件"></a>4.2 自定义分页插件</h3><p>首先要声明一下，这里松哥带大家自定义 MyBatis 分页插件，主要是想通过这个东西让小伙伴们了解自定义 MyBatis 插件的一些条条框框，了解整个自定义插件的流程，分页插件并不是我们的目的，自定义分页插件只是为了让大家的学习过程变得有趣一些而已。</p><p>接下来我们就来开启自定义分页插件之旅。</p><p>首先我们需要自定义一个 RowBounds，因为 MyBatis 原生的 RowBounds 是内存分页，并且没有办法获取到总记录数（一般分页查询的时候我们还需要获取到总记录数），所以我们自定义 PageRowBounds，对原生的 RowBounds 功能进行增强，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageRowBounds</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RowBounds</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long total;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageRowBounds</span><span class="hljs-params">(<span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(offset, limit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageRowBounds</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getTotal</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTotal</span><span class="hljs-params">(Long total)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们自定义的 PageRowBounds 中增加了 total 字段，用来保存查询的总记录数。</p><p>接下来我们自定义拦截器 PageInterceptor，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Intercepts</span>(<span class="hljs-meta">@Signature</span>(</span><br><span class="line">        type = Executor.class,</span><br><span class="line">        method = <span class="hljs-string">"query"</span>,</span><br><span class="line">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">))</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line">        MappedStatement ms = (MappedStatement) args[<span class="hljs-number">0</span>];</span><br><span class="line">        Object parameterObject = args[<span class="hljs-number">1</span>];</span><br><span class="line">        RowBounds rowBounds = (RowBounds) args[<span class="hljs-number">2</span>];</span><br><span class="line">        <span class="hljs-keyword">if</span> (rowBounds != RowBounds.DEFAULT) &#123;</span><br><span class="line">            Executor executor = (Executor) invocation.getTarget();</span><br><span class="line">            BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">            Field additionalParametersField = BoundSql.class.getDeclaredField(<span class="hljs-string">"additionalParameters"</span>);</span><br><span class="line">            additionalParametersField.setAccessible(<span class="hljs-keyword">true</span>);</span><br><span class="line">            Map&lt;String, Object&gt; additionalParameters = (Map&lt;String, Object&gt;) additionalParametersField.get(boundSql);</span><br><span class="line">            <span class="hljs-keyword">if</span> (rowBounds <span class="hljs-keyword">instanceof</span> PageRowBounds) &#123;</span><br><span class="line">                MappedStatement countMs = newMappedStatement(ms, Long.class);</span><br><span class="line">                CacheKey countKey = executor.createCacheKey(countMs, parameterObject, RowBounds.DEFAULT, boundSql);</span><br><span class="line">                String countSql = <span class="hljs-string">"select count(*) from ("</span> + boundSql.getSql() + <span class="hljs-string">") temp"</span>;</span><br><span class="line">                BoundSql countBoundSql = <span class="hljs-keyword">new</span> BoundSql(ms.getConfiguration(), countSql, boundSql.getParameterMappings(), parameterObject);</span><br><span class="line">                Set&lt;String&gt; keySet = additionalParameters.keySet();</span><br><span class="line">                <span class="hljs-keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">                    countBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Object&gt; countQueryResult = executor.query(countMs, parameterObject, RowBounds.DEFAULT, (ResultHandler) args[<span class="hljs-number">3</span>], countKey, countBoundSql);</span><br><span class="line">                Long count = (Long) countQueryResult.get(<span class="hljs-number">0</span>);</span><br><span class="line">                ((PageRowBounds) rowBounds).setTotal(count);</span><br><span class="line">            &#125;</span><br><span class="line">            CacheKey pageKey = executor.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">            pageKey.update(<span class="hljs-string">"RowBounds"</span>);</span><br><span class="line">            String pageSql = boundSql.getSql() + <span class="hljs-string">" limit "</span> + rowBounds.getOffset() + <span class="hljs-string">","</span> + rowBounds.getLimit();</span><br><span class="line">            BoundSql pageBoundSql = <span class="hljs-keyword">new</span> BoundSql(ms.getConfiguration(), pageSql, boundSql.getParameterMappings(), parameterObject);</span><br><span class="line">            Set&lt;String&gt; keySet = additionalParameters.keySet();</span><br><span class="line">            <span class="hljs-keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">                pageBoundSql.setAdditionalParameter(key, additionalParameters.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">            List list = executor.query(ms, parameterObject, RowBounds.DEFAULT, (ResultHandler) args[<span class="hljs-number">3</span>], pageKey, pageBoundSql);</span><br><span class="line">            <span class="hljs-keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//不需要分页，直接返回结果</span></span><br><span class="line">        <span class="hljs-keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> MappedStatement <span class="hljs-title">newMappedStatement</span><span class="hljs-params">(MappedStatement ms, Class&lt;Long&gt; longClass)</span> </span>&#123;</span><br><span class="line">        MappedStatement.Builder builder = <span class="hljs-keyword">new</span> MappedStatement.Builder(</span><br><span class="line">                ms.getConfiguration(), ms.getId() + <span class="hljs-string">"_count"</span>, ms.getSqlSource(), ms.getSqlCommandType()</span><br><span class="line">        );</span><br><span class="line">        ResultMap resultMap = <span class="hljs-keyword">new</span> ResultMap.Builder(ms.getConfiguration(), ms.getId(), longClass, <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">0</span>)).build();</span><br><span class="line">        builder.resource(ms.getResource())</span><br><span class="line">                .fetchSize(ms.getFetchSize())</span><br><span class="line">                .statementType(ms.getStatementType())</span><br><span class="line">                .timeout(ms.getTimeout())</span><br><span class="line">                .parameterMap(ms.getParameterMap())</span><br><span class="line">                .resultSetType(ms.getResultSetType())</span><br><span class="line">                .cache(ms.getCache())</span><br><span class="line">                .flushCacheRequired(ms.isFlushCacheRequired())</span><br><span class="line">                .useCache(ms.isUseCache())</span><br><span class="line">                .resultMaps(Arrays.asList(resultMap));</span><br><span class="line">        <span class="hljs-keyword">if</span> (ms.getKeyProperties() != <span class="hljs-keyword">null</span> &amp;&amp; ms.getKeyProperties().length &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            StringBuilder keyProperties = <span class="hljs-keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="hljs-keyword">for</span> (String keyProperty : ms.getKeyProperties()) &#123;</span><br><span class="line">                keyProperties.append(keyProperty).append(<span class="hljs-string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            keyProperties.delete(keyProperties.length() - <span class="hljs-number">1</span>, keyProperties.length());</span><br><span class="line">            builder.keyProperty(keyProperties.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们今天定义的核心代码，涉及到的知识点松哥来给大家一个一个剖析。</p><ol><li>首先通过 @Intercepts 注解配置拦截器签名，从 @Signature 的定义中我们可以看到，拦截的是 Executor#query 方法，该方法有一个重载方法，通过 args 指定了方法参数，进而锁定了重载方法（实际上该方法的另一个重载方法我们没法拦截，那个是 MyBatis 内部调用的，这里不做讨论）。</li><li>将查询操作拦截下来之后，接下来我们的操作主要在 PageInterceptor#intercept 方法中完成，该方法的参数重包含了拦截对象的诸多信息。</li><li>通过 <code>invocation.getArgs()</code> 获取拦截方法的参数，获取到的是一个数组，正常来说这个数组的长度为 4。数组第一项是一个 MappedStatement，我们在 Mapper.xml 中定义的各种操作节点和 SQL，都被封装成一个个的 MappedStatement 对象了；数组第二项就是所拦截方法的具体参数，也就是你在 Mapper 接口中定义的方法参数；数组的第三项是一个 RowBounds 对象，我们在 Mapper 接口中定义方法时不一定使用了 RowBounds 对象，如果我们没有定义 RowBounds 对象，系统会给我们提供一个默认的 RowBounds.DEFAULT；数组第四项则是一个处理返回值的 ResultHandler。</li><li>接下来判断上一步提取到的 rowBounds 对象是否不为 RowBounds.DEFAULT，如果为 RowBounds.DEFAULT，说明用户不想分页；如果不为 RowBounds.DEFAULT，则说明用户想要分页，如果用户不想分页，则直接执行最后的 <code>return invocation.proceed();</code>，让方法继续往下走就行了。</li><li>如果需要进行分页，则先从 invocation 对象中取出执行器 Executor、BoundSql 以及通过反射拿出来 BoundSql 中保存的额外参数（如果我们使用了动态 SQL，可能会存在该参数）。BoundSql 中封装了我们执行的 Sql 以及相关的参数。</li><li>接下来判断 rowBounds 是否是 PageRowBounds 的实例，如果是，说明除了分页查询，还想要查询总记录数，如果不是，则说明 rowBounds 可能是 RowBounds 实例，此时只要分页即可，不用查询总记录数。</li><li>如果需要查询总记录数，则首先调用 newMappedStatement 方法构造出一个新的 MappedStatement 对象出来，这个新的 MappedStatement 对象的返回值是 Long 类型的。然后分别创建查询的 CacheKey、拼接查询的 countSql，再根据 countSql 构建出 countBoundSql，再将额外参数添加进 countBoundSql 中。最后通过 executor.query 方法完成查询操作，并将查询结果赋值给 PageRowBounds 中的 total 属性。</li><li>接下来进行分页查询，有了第七步的介绍之后，分页查询就很简单了，这里就不细说了，唯一需要强调的是，当我们启动了这个分页插件之后，MyBatis 原生的 RowBounds 内存分页会变成物理分页，原因就在这里我们修改了查询 SQL。</li><li>最后将查询结果返回。</li></ol><p>在前面的代码中，我们一共在两个地方重新组织了 SQL，一个是查询总记录数的时候，另一个则是分页的时候，都是通过 boundSql.getSql() 获取到 Mapper.xml 中的 SQL 然后进行改装，有的小伙伴在 Mapper.xml 中写 SQL 的时候不注意，结尾可能加上了 <code>;</code>，这会导致分页插件重新组装的 SQL 运行出错，这点需要注意。松哥在 GitHub 上看到的其他 MyBatis 分页插件也是一样的，Mapper.xml 中 SQL 结尾不能有 <code>;</code>。</p><p>如此之后，我们的分页插件就算是定义成功了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>接下来我们对我们的分页插件进行一个简单测试。</p><p>首先我们需要在全局配置中配置分页插件，配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">"org.javaboy.mybatis03.plugin.PageInterceptor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们在 Mapper 中定义查询接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsersByPage</span><span class="hljs-params">(RowBounds rowBounds)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义 UserMapper.xml，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUsersByPage"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.mybatis03.model.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后我们进行测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; list = userMapper.getAllUsersByPage(<span class="hljs-keyword">new</span> RowBounds(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));</span><br><span class="line">    <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在查询时，我们使用了 RowBounds 对象，就只会进行分页，而不会统计总记录数。需要注意的时，此时的分页已经不是内存分页，而是物理分页了，这点我们从打印出来的 SQL 中也能看到，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210224164138.png" alt></p><p>可以看到，查询的时候就已经进行了分页了。</p><p>当然，我们也可以使用 PageRowBounds 进行测试，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class);</span><br><span class="line">    PageRowBounds pageRowBounds = <span class="hljs-keyword">new</span> PageRowBounds(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.getAllUsersByPage(pageRowBounds);</span><br><span class="line">    <span class="hljs-keyword">for</span> (User user : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="hljs-string">"pageRowBounds.getTotal() = "</span> + pageRowBounds.getTotal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时通过 pageRowBounds.getTotal() 方法我们就可以获取到总记录数。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好啦，今天主要和小伙伴们分享了我们如何自己开发一个 MyBatis 插件，插件功能其实都是次要的，最主要是希望小伙伴们能够理解 MyBatis 的工作流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴们元宵节快乐，记得吃元宵哦～&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
      <category term="Plugin" scheme="http://www.javaboy.org/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>硬核！松哥又整了一套免费视频，搞起！</title>
    <link href="http://www.javaboy.org/2021/0223/springmvc-video.html"/>
    <id>http://www.javaboy.org/2021/0223/springmvc-video.html</id>
    <published>2021-02-23T14:39:41.000Z</published>
    <updated>2021-03-07T15:09:02.697Z</updated>
    
    <content type="html"><![CDATA[<p>不知道小伙伴们过年期间玩的好不好，松哥刚回家拿两天还蛮舒服的，时间久了又觉得无聊了，作为程序员，解决无聊的办法就是 Coding！于是，一个拖延很久的计划终于被松哥拾起来了，录一套<strong>免费的</strong> SSM 视频。</p><a id="more"></a><p>松哥从大二开始自学 Java，大学毕业后顺利入坑，自学之路还是蛮艰辛的。所以我深知大家在自学时面临的两个问题：</p><ol><li>学习顺序</li><li>学习资料</li></ol><p>首先是不知道学什么，这个我之前已经总结了 Java 升级路线图（<a href="https://mp.weixin.qq.com/s/rBRFL2UcDKWB-bHp324mCw" target="_blank" rel="noopener">Java 打怪升级路线图</a>），大家可以参考。</p><p>第二个就是学习资料的问题，虽然现在网上的资料多如牛毛，但是很多时候我们缺的不是一个资料，<strong>我们缺的是一个从头到尾连贯的、系统的资料</strong>，经常是这个人讲的看了一点，那个人讲的看了一点，想头到尾看一个人讲，发现几乎没有这样的资源。</p><p>如果是一个人来讲，知识是连贯的，什么东西讲过，什么东西没讲过，他心里有数，这样大家的学习的时候就不会觉得突兀，比如突然蹦出来一个你从来没听说过的知识点，一个人讲的话，就不会发生这种事情，学习体验也会好很多，也会更加容易构建自己的知识体系。</p><p>所以松哥很早就想根据自己整理的 Java 学习路线图（公号后台回复 <code>进阶路线</code> 获取 Java 进阶路线图）录一套 Java 视频教程，可是由于拖延症一直进展缓慢。在 2021 年，希望能把这项工作扎实推进，也希望小伙伴们对继续保持关注，录制好的视频我会第一时间在公众号上告诉大家。</p><p>现在这套 SSM 视频，在去年 6 月份已经发布了 Spring 部分，相关链接参见：</p><p><a href="https://mp.weixin.qq.com/s/aj9Bt1TE1pb8ZPVCpDKI8A" target="_blank" rel="noopener">我为什么要出一套免费视频教程</a></p><p>这次休假期间，我主要是录制了 SpringMVC 部分，一共录制了三十多集约 6 个小时的视频教程，教程目录如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">├── 01.SpringMVC 免费视频录制计划.mp4</span><br><span class="line">├── 02.SpringMVC 简单介绍.mp4</span><br><span class="line">├── 03.SpringMVC 之 HelloWorld.mp4</span><br><span class="line">├── 04.SpringMVC 组件简单介绍.mp4</span><br><span class="line">├── 05.DispatcherServlet 配置细节.mp4</span><br><span class="line">├── 06.Spring+SpringMVC 分开配置.mp4</span><br><span class="line">├── 07.Spring 容器和 SpringMVC 容器.mp4</span><br><span class="line">├── 08.处理器映射器与处理器适配器.mp4</span><br><span class="line">├── 09.处理器映射器与处理器适配器最佳实践.mp4</span><br><span class="line">├── 10.@RequestMapping 注解使用细节.mp4</span><br><span class="line">├── 11.Controller 中接口方法各种返回值类型.mp4</span><br><span class="line">├── 12.【Spring MVC参数绑定】默认参数.mp4</span><br><span class="line">├── 13.【Spring MVC参数绑定】基本类型参数.mp4</span><br><span class="line">├── 14.【Spring MVC参数绑定】对象参数.mp4</span><br><span class="line">├── 15.【Spring MVC参数绑定】自定义参数类型转换器.mp4</span><br><span class="line">├── 16.【Spring MVC参数绑定】数组类型.mp4</span><br><span class="line">├── 17.【Spring MVC参数绑定】List 集合类型.mp4</span><br><span class="line">├── 18.【Spring MVC参数绑定】Map 集合类型.mp4</span><br><span class="line">├── 19.SpringMVC 文件上传【上古方案】.mp4</span><br><span class="line">├── 20.SpringMVC 文件上传【最新方案】.mp4</span><br><span class="line">├── 21.SpringMVC 多文件上传.mp4</span><br><span class="line">├── 22.SpringMVC 全局异常处理.mp4</span><br><span class="line">├── 23.SpringMVC 数据校验.mp4</span><br><span class="line">├── 24.SpringMVC 数据分组校验.mp4</span><br><span class="line">├── 25.手动数据回显.mp4</span><br><span class="line">├── 26.自动数据回显.mp4</span><br><span class="line">├── 27.@ModelAttribute注解用法.mp4</span><br><span class="line">├── 28.SpringMVC+Jackson生成 JSON 数据.mp4</span><br><span class="line">├── 29.SpringMVC+Gson生成 JSON 数据.mp4</span><br><span class="line">├── 30.SpringMVC+FastJson生成 JSON 数据.mp4</span><br><span class="line">├── 31.SpringMVC 接收 JSON 类型参数.mp4</span><br><span class="line">├── 32.SpringMVC 开发 RESTful 接口.mp4</span><br><span class="line">├── 33.SpringMVC 静态资源访问.mp4</span><br><span class="line">└── 34.SpringMVC 中使用拦截器.mp4</span><br></pre></td></tr></table></figure><p>视频的笔记、案例这次我都一并分享给小伙伴们，大家在公众号后台回复 <code>springmvc</code> 就可以获取视频播放链接、视频笔记以及视频案例。</p><p>下一步就是 MyBatis 了，最近也在抽空录制了，估计很快会和小伙伴们见面，敬请期待～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道小伙伴们过年期间玩的好不好，松哥刚回家拿两天还蛮舒服的，时间久了又觉得无聊了，作为程序员，解决无聊的办法就是 Coding！于是，一个拖延很久的计划终于被松哥拾起来了，录一套&lt;strong&gt;免费的&lt;/strong&gt; SSM 视频。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>小伙伴们提的这个问题，我今天必须解决了！</title>
    <link href="http://www.javaboy.org/2021/0221/itboyhub.html"/>
    <id>http://www.javaboy.org/2021/0221/itboyhub.html</id>
    <published>2021-02-21T14:39:27.000Z</published>
    <updated>2021-03-07T15:08:58.059Z</updated>
    
    <content type="html"><![CDATA[<p>hello 小伙伴们新年好～给大家拜个晚年～</p><a id="more"></a><p>今年虽然倡导就地过年，松哥还是溜回家过年去了，回家那是真舒服啊，公众号都荒废了两周了～</p><p>不过过年期间也不是一点事没干，过年期间终于抽空把小伙伴们反映很久的一个问题解决了～</p><p><img src="http://img.itboyhub.com/2021/02/20210220-181045.jpg" alt></p><p>每次小伙伴们反映 <code>www.javaboy.org</code> 很慢，我都很焦虑，但是这个网站我暂时没办法解决慢的问题，我说说原因。</p><p><code>javaboy.org</code> 是我从国外服务商那里买的域名，当时选择这个的原因是不用备案，当天买当天网站就能上线，很快。服务器我也没有自己搭建，选择了 GitHub Pages 的服务再结合 Hexo 做的网站，所以这个网站肯定是不会挂的，除非 GitHub Pages 自己挂掉了。</p><p>刚开始的时候网站访问量不大也没发现啥弊端，后来慢慢访问的人多了，小伙伴们就开始反映网站访问慢。</p><p>刚开始收到小伙伴们的反馈的时候，我最直观的想法就是把 <code>javaboy.org</code> 这个域名转回到国内，然后买服务器，备案，走正常的流程，后来一查才发现，国内 <code>.org</code> 域名在国内无法备案，这就意味着我要是把这个域名转回到国内连用都用不了了。所以导致这个网站目前处于一个比较尴尬的位置，当然如果你能顺利访问 Google，那么可以把这个域名也添加到代理名单中，这样访问速度会略微好一点。</p><p>既然 <code>www.javaboy.org</code> 的问题没法根治，那就只能另起炉灶，我又重新在国内的服务商处买了个 <code>itboyhub.com</code> 的域名，又买了服务器，然后重新搭建网站。重新搭建的网站依然采用了 Hexo+Nginx 来做，但是效果并不好，为此我还专门又买了 CDN 加速服务，但是感觉提速效果都不太明显，再后来工作比较忙就懒得折腾了。</p><p>过年期间，我想把这个问题好好梳理一下，彻底解决小伙伴们一直反映的访问慢的问题。首先确认了服务器的配置没问题，因为我有一个相同配置的服务器跑着另外的服务，网速就很好。既然不是服务器的配置问题，那就应该是我采用的技术栈的问题了，网上搜了下，果然看到很多人反映 Hexo 加载慢的问题，用了两年的 Hexo 也有点腻了，换个新玩意试试。于是瞄准了 wordpress，三下五除二用 wordpress 重新搭建了一个站点，速度还不错。</p><p><img src="http://img.itboyhub.com/2021/02/20210220193819.png" alt></p><p>这次没上 CDN 加速服务了，用工具测了一下网速基本上也都是全绿，nice！</p><p>到目前为止，我已经把之前发过的大部分系列教程腾挪上去了，并且进行了分类，小伙伴们都可以很方便的查看：</p><p><img src="http://img.itboyhub.com/2021/02/20210220200037.png" alt></p><p>可以在右边的分类目录中查看不同分类下的文章。</p><p>这个问题解决了总算了却了一桩心事，小伙伴们可以畅快的访问 <a href="http://www.itboyhub.com" target="_blank" rel="noopener">www.itboyhub.com</a> 了，松哥所有的文章/教程都会同步上去，小伙伴也可以点击阅读原文体验一把新网站加载速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 小伙伴们新年好～给大家拜个晚年～&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>这得多老的项目才会有这么奇葩的需求</title>
    <link href="http://www.javaboy.org/2021/0204/springmvc-resolver.html"/>
    <id>http://www.javaboy.org/2021/0204/springmvc-resolver.html</id>
    <published>2021-02-04T14:39:12.000Z</published>
    <updated>2021-03-07T15:09:56.325Z</updated>
    
    <content type="html"><![CDATA[<p>维护老项目的时候，我们总会遇到一些奇奇怪怪的需求，解决这些奇葩问题可能才是我们开发的常态。</p><a id="more"></a><p>这不，最近就有小伙伴问了这样一个问题：</p><p><img src="http://img.itboyhub.com/2021/02/20210202172051.png" alt></p><p>这个小伙伴想在 Spring Boot 中同时使用多个视图解析器，一般来说我们正常设计一个项目时，肯定不会搞成这样，要么前后端分离不需要视图解析器，要么前后端不分需要视图解析器，但是即使需要一般也只会使用一种视图解析器，而不会多种视图解析器混在一起使用。</p><p>不过现在既然小伙伴提出了这个问题，我们就来看看这个需求能不能做！先说结论：技术上来说这个当然是可以实现的，而且实现方式不难。</p><p>不过要把这个问题理解透彻，这就涉及到到 SpringMVC 的工作原理了，今天松哥就来和大家把这个问题稍微梳理下。</p><h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>在 SpringMVC 中我们可以配置多个视图解析器，这些视图解析器最终会在 DispatcherServlet#initViewResolvers 方法中完成加载，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initViewResolvers</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detectAllViewResolvers) &#123;</span><br><span class="line"><span class="hljs-comment">// Find all ViewResolvers in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">Map&lt;String, ViewResolver&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, ViewResolver.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line"><span class="hljs-comment">// We keep ViewResolvers in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="hljs-keyword">this</span>.viewResolvers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = Collections.singletonList(vr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// Ignore, we'll add a default ViewResolver later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Ensure we have at least one ViewResolver, by registering</span></span><br><span class="line"><span class="hljs-comment">// a default ViewResolver if no other resolvers are found.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = getDefaultStrategies(context, ViewResolver.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑很清楚：</p><ul><li>首先将 viewResolvers 变量置空，这个变量将存储所有的视图解析器。</li><li>接下来根据 detectAllViewResolvers 的变量值来决定是否要加载所有的视图解析器，该变量默认为 true，表示加载所有的视图解析器，加载所有的视图解析器就是去 Spring 容器中查找到所有的 ViewResolver 实例，然后给这些 ViewResolver 实例按照 Order 优先级进行排序。如果 detectAllViewResolvers 的变量值为 false，表示只加载名为 viewResolver 的视图解析器。</li><li>经过前面的步骤，如果 viewResolvers 还是为 null，表示用户压根就没有配置视图解析器，此时调用 getDefaultStrategies 方法加载一个默认的视图解析器，以确保我们的系统中至少有一个视图解析器。</li></ul><p>一般来说，在一个 SSM 项目中，如果我们在 SpringMVC 的配置文件中，没有做任何关于视图解析器的配置，那么就会走入第三步。</p><p>initViewResolvers 方法的主要目的就是初始化视图解析器，并对视图解析器进行排序。从这里我们也可以大概看出来 SpringMVC 中是支持多个视图解析器同时存在的。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>上面是视图解析器的初始化过程。</p><p>接下来我们来看看视图解析器具体是如何发挥作用的。</p><p>小伙伴们知道，一个请求进入 DispatcherServlet 之后，执行的方法流程依次是 service-&gt;processRequest-&gt;doService-&gt;doDispatch-&gt;processDispatchResult-&gt;render-&gt;resolveViewName-&gt;…</p><p>进入 render 方法就差不多进入正题了，我们的页面渲染将在这个方法中完成。render 方法中包含如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">View view;</span><br><span class="line">String viewName = mv.getViewName();</span><br><span class="line"><span class="hljs-keyword">if</span> (viewName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// We need to resolve the view name.</span></span><br><span class="line">view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Could not resolve view with name '"</span> + mv.getViewName() +</span><br><span class="line"><span class="hljs-string">"' in servlet with name '"</span> + getServletName() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></span><br><span class="line">view = mv.getView();</span><br><span class="line"><span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"ModelAndView ["</span> + mv + <span class="hljs-string">"] neither contains a view name nor a "</span> +</span><br><span class="line"><span class="hljs-string">"View object in servlet with name '"</span> + getServletName() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里获取到视图的名字之后，接下来调用 resolveViewName 方法去获取一个具体的视图。在 resolveViewName 方法中，将根据视图名称以及现有的视图解析器找到对应的视图。</p><p>那么这里就存在一个问题，现有的视图解析器如果有多个，究竟该以哪个为准呢？</p><p>我们来看下 resolveViewName 方法中的执行逻辑。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, @Nullable Map&lt;String, Object&gt; model,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Locale locale, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就是遍历所有的 ViewResolver，调用其 resolveViewName 方法去找到对应的 View，找到后就返回了。</p><p>ViewResolver 就是我们常说的视图解析器，我们用 JSP、Thymeleaf、Freemarker 等，都有对应的视图解析器，从下面一张图中就可以看出 ViewResolver 的继承类：</p><p><img src="http://img.itboyhub.com/2021/02/20210202193709.png" alt></p><p>不过在 Spring Boot 中，我们并不会直接使用这些视图解析器，而是使用一个名为 ContentNegotiatingViewResolver 的视图解析器，这个是 Spring3.0 中引入的的视图解析器，它不负责具体的视图解析，而是根据当前请求的 MIME 类型，从上下文中选择一个合适的视图解析器，并将请求工作委托给它。</p><p>所以这里我们就先来看看 ContentNegotiatingViewResolver#resolveViewName 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">RequestAttributes attrs = RequestContextHolder.getRequestAttributes();</span><br><span class="line">List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());</span><br><span class="line"><span class="hljs-keyword">if</span> (requestedMediaTypes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);</span><br><span class="line">View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);</span><br><span class="line"><span class="hljs-keyword">if</span> (bestView != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bestView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useNotAcceptableStatusCode) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> NOT_ACCEPTABLE_VIEW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码逻辑也比较简单：</p><ul><li>首先是获取到当前的请求对象，可以直接从 RequestContextHolder 中获取。然后从当前请求对象中提取出 MediaType。</li><li>如果 MediaType 不为 null，则根据 MediaType，找到合适的视图解析器，并将解析出来的 View 返回。</li><li>如果 MediaType 为 null，则为两种情况，如果 useNotAcceptableStatusCode 为 true，则返回 NOT_ACCEPTABLE_VIEW 视图，这个视图其实是一个 406 响应，表示客户端错误，服务器端无法提供与 Accept-Charset 以及 Accept-Language 消息头指定的值相匹配的响应；如果 useNotAcceptableStatusCode 为 false，则返回 null。</li></ul><p>现在问题的核心其实就变成 getCandidateViews 方法和 getBestView 方法了，看名字就知道，前者是获取所有的候选 View，后者则是从这些候选 View 中选择一个最佳的 View，我们一个一个来看。</p><p>先来看 getCandidateViews：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;View&gt; <span class="hljs-title">getCandidateViews</span><span class="hljs-params">(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;View&gt; candidateViews = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">candidateViews.add(view);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (MediaType requestedMediaType : requestedMediaTypes) &#123;</span><br><span class="line">List&lt;String&gt; extensions = <span class="hljs-keyword">this</span>.contentNegotiationManager.resolveFileExtensions(requestedMediaType);</span><br><span class="line"><span class="hljs-keyword">for</span> (String extension : extensions) &#123;</span><br><span class="line">String viewNameWithExtension = viewName + <span class="hljs-string">'.'</span> + extension;</span><br><span class="line">view = viewResolver.resolveViewName(viewNameWithExtension, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">candidateViews.add(view);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.defaultViews)) &#123;</span><br><span class="line">candidateViews.addAll(<span class="hljs-keyword">this</span>.defaultViews);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> candidateViews;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取所有的候选 View 分为两个步骤：</p><ol><li>调用各个 ViewResolver 中的 resolveViewName 方法去加载出对应的 View 对象。</li><li>根据 MediaType 提取出扩展名，再根据扩展名去加载 View 对象，在实际应用中，这一步我们都很少去配置，所以一步基本上是加载不出来 View 对象的，主要靠第一步。</li></ol><p>第一步去加载 View 对象，其实就是根据你的 viewName，再结合 ViewResolver 中配置的 prefix、suffix、templateLocation 等属性，找到对应的 View，方法执行流程依次是 resolveViewName-&gt;createView-&gt;loadView。</p><p>具体执行的方法我就不一一贴出来了，<strong>唯一需要说的一个重点就是最后的 loadView 方法</strong>，我们来看下这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">loadView</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractUrlBasedView view = buildView(viewName);</span><br><span class="line">View result = applyLifecycleMethods(viewName, view);</span><br><span class="line"><span class="hljs-keyword">return</span> (view.checkResource(locale) ? result : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，View 加载出来后，会调用其 checkResource 方法判断 View 是否存在，如果存在就返回 View，不存在就返回 null。</p><p>这是一个非常关键的步骤，但是我们常用的视图对此的处理却不尽相同：</p><ul><li>FreeMarkerView：会老老实实检查。</li><li>ThymeleafView：没有检查这个环节（Thymeleaf 的整个 View 体系不同于 FreeMarkerView 和 JstlView）。</li><li>JstlView：检查结果总是返回 true。</li></ul><p>至此，我们就找到了所有的候选 View，但是大家需要注意，这个候选 View 不一定存在，在有 Thymeleaf 的情况下，返回的候选 View 不一定可用，在 JstlView 中，候选 View 也不一定真的存在。</p><p>接下来调用 getBestView 方法，从所有的候选 View 中找到最佳的 View。getBestView 方法的逻辑比较简单，就是查找看所有 View 的 MediaType，然后和请求的 MediaType 数组进行匹配，第一个匹配上的就是最佳 View，这个过程它不会检查视图是否真的存在，所以就有可能选出来一个压根没有的视图，最终导致 404。</p><p>这就是整个 View 的加载过程。</p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p>如果是单个视图，这套加载流程没什么问题，但是如果是多个视图解析器同时存在，就可能会有问题。</p><p>松哥一个一个来说明。</p><p>第一种情况：</p><p>FreeMarkerView、ThymeleafView 以及 JstlView 在项目中只存在任意一个，这种情况没任何问题，这也是小伙伴们日常常见的使用场景。</p><p>第二种情况：</p><p>FreeMarkerView+ThymeleafView 组合。如果项目中同时存在这两种视图解析器，由于 FreeMarkerView 会老老实实检查视图是否存在，而 ThymeleafView 不会检查，所以需要确保 FreeMarkerViewResolver 的优先级高于 ThymeleafViewResolver 的优先级。这样就能够确保视图加载的时候先去加载 FreeMarkerView（FreeMarkerView 如果不存在，则不会列为候选 View），再去加载 ThymeleafView，这样无论是 FreeMarkerView 还是 ThymeleafView，都能够正常加载到（回顾前面所讲 getBestView 方法逻辑）。假如 ThymeleafViewResolver 的优先级高于 FreeMarkerViewResolver，那么就会出现如下情况：用户请求一个 Freemarker 视图，结果在 getCandidateViews 方法中返回了两个视图，依次是 ThymeleafView 和 FreeMarkerView，但是实际上 ThymeleafView 中的视图是不存在的，结果在 getBestView 方法中，按顺序直接匹配到 ThymeleafView，最终导致运行出错。</p><p>在 Spring Boot 中，如果我们引入了 Freemarker 和 Thyemeleaf 的 starter，默认情况下，Freemarker 和 Thymeleaf 的优先级相同，都是 <code>Ordered.LOWEST_PRECEDENCE - 5</code>，但是由于 Freemarker 总是被优先加载，而排序时由于两者优先级相同所以位置不变，所以在具体代码实践中，FreeMarkerViewResolver 总是排在 ThymeleafViewResolver 前面，FreeMarkerView 会自动检查视图是否存在，所以这样的排序刚刚恰到好处。在具体代码实践中，如果我们在项目中同时引入了 Freemarker 和 Thymeleaf，可以不用做任何配置直接同时使用这两种视图解析器。</p><p>这里要吐槽一下，网上看多人说默认情况下 Freemarker 优先级高于 Thymeleaf，不知道谁抄谁的，反正都说错了，还是要严谨呀！</p><p>第三种情况：</p><p>Freemarker+Jsp 组合，如果项目中同时使用了这两种视图解析器，则只需要对 jsp 进行常规配置即可，不需要额外配置。所谓的常规配置就是首先引入所需依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后配置一下 jsp 视图的前缀后缀啥的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.jsp(<span class="hljs-string">"/"</span>, <span class="hljs-string">".jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就可以了。</p><p>为什么这个组合这么简单呢？原因如下：</p><ol><li>在 Spring 设计中，InternalResourceView 其实就是兜底的，所以它不会检查视图是否真的存在，它的优先级也是最低的。</li><li>由于 InternalResourceView 的优先级最低，排在 Freemarker 后面，而 Freemarker 会自动检查视图是否存在，所以对于这个组合我们不需要额外配置。</li></ol><p>第四种情况：</p><p>Thymeleaf+Jsp 组合。这个组合稍微有点麻烦，因为 Thymeleaf 和 InternalResourceView 都不会去检查视图是否存在，而 Thymeleaf 的优先级高于 Jsp，所以 Thymeleaf 会“吞掉” Jsp 视图的请求。</p><p>想要这两个视图解析器同时存在，必须要有一个视图解析器具备检查视图是否存在的能力。Jsp 在这块的配置相对容易一些，所以我们选择对 InternalResourceView 做一些定制。</p><p>具体办法如下，首先定义类继承自 InternalResourceView 并重写 checkResource 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandleResourceViewExists</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InternalResourceView</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkResource</span><span class="hljs-params">(Locale locale)</span> </span>&#123;</span><br><span class="line">        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-keyword">this</span>.getServletContext().getRealPath(<span class="hljs-string">"/"</span>) + getUrl());</span><br><span class="line">        <span class="hljs-comment">//判断页面是否存在</span></span><br><span class="line">        <span class="hljs-keyword">return</span> file.exists();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InternalResourceView 默认的 checkResource 方法总是返回 true，现在我们稍微修改一下，让它去判断一下视图文件是否存在，如果存在，返回 true，否则返回 false。</p><p>配置完成后，将新的 HandleResourceViewExists 重新配置，同时修改优先级，使之优先级大于 ThymeleafViewResolver，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.jsp(<span class="hljs-string">"/"</span>, <span class="hljs-string">".jsp"</span>).viewClass(HandleResourceViewExists.class);</span><br><span class="line">        registry.order(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此之后，这两个视图解析器就可以同时存在了。</p><p>第五种情况：</p><p>Freemarker+Thymeleaf+Jsp，看了前面四种，第五种情况应该就不用我多说了吧～</p><p>好啦，这个问题从原理到应用，都给大伙捋了一遍了，感兴趣的小伙伴赶紧试试哦～</p><p>对了，这个问题松哥也录制了相关的视频，感兴趣的小伙伴可以在公众号后台回复 <strong>vhr</strong> 查看视频详情。</p><p><img src="http://img.itboyhub.com/2021/02/20210204083251.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;维护老项目的时候，我们总会遇到一些奇奇怪怪的需求，解决这些奇葩问题可能才是我们开发的常态。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="ViewResolver" scheme="http://www.javaboy.org/tags/ViewResolver/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 应用监控常见方案梳理</title>
    <link href="http://www.javaboy.org/2021/0203/springboot-actuator.html"/>
    <id>http://www.javaboy.org/2021/0203/springboot-actuator.html</id>
    <published>2021-02-03T14:38:58.000Z</published>
    <updated>2021-03-07T15:09:50.227Z</updated>
    
    <content type="html"><![CDATA[<p>应用监控是我们在生产环境下一个非常重要的东西，运维人员不可能 24 小时盯着应用，应用挂了及时解决，这不现实。我们需要能够实时掌握应用的运行数据，以便提早发现问题，同时在应用挂掉的时候还能够自动报警，这样才能解放开发人员。</p><a id="more"></a><p>Spring Boot 中也提供了生产级的应用监控方案，对于单体应用、微服务应用都有相应的解决方案，今天松哥就想来和大家捋一捋 Spring Boot 中的应用监控方案都有哪些。</p><p>首先我们来捋一下应用监控都需要哪些东西？其实就两点：</p><ol><li>信息采集器</li><li>数据可视化 UI</li></ol><p>信息采集器会收集应用的健康、审计、指标、HTTP 请求等信息，并将之暴露出来，数据可视化 UI 则会通过仪表盘、图形等展示这些数据，并对数据进行分析、报警等处理。我们分别来看。</p><h2 id="Spring-Boot-Actuator"><a href="#Spring-Boot-Actuator" class="headerlink" title="Spring Boot Actuator"></a>Spring Boot Actuator</h2><p>在 Spring Boot 项目中，我们使用的信息采集器主要就是 Spring Boot Actuator，这个模块由 Spring Boot 官方提供，它包含了许多生产级别的功能，例如健康检查、审计、指标收集、HTTP 请求追踪等，Spring Boot Actuator 将这些信息收集起来后，通过 HTTP 和 JMX 两种方式暴露给外部模块。例如 Spring Boot Actuator 通过 <code>/health</code> 端点（endpoints）提供了应用的健康信息，开发者只需要访问该端点就可以看到应用的健康信息，但是这些端点返回的数据是 JSON 格式的，不方便查看，也不方便分析，所以一般情况下，Spring Boot Actuator 都是和一些外部模块一起使用。</p><p>Spring Boot Actuator 支持的端点主要有如下一些：</p><p><img src="http://img.itboyhub.com/2021/02/20210201202406.png" alt></p><p>如果是 Web 应用，则再次基础上还支持如下端点：</p><p><img src="http://img.itboyhub.com/2021/02/20210201202855.png" alt></p><p>提到 Spring Boot Actuator，就还有一个东西需要和大家介绍，那就是 Micrometer，从 Spring Boot2.0 开始，Actuator 底层改为了 Micrometer。</p><p>当我们在一个 Spring Boot 项目中引入 Actuator 依赖之后，我们会发现它里边包含了 Micrometer：</p><p><img src="http://img.itboyhub.com/2021/01/spring-cloud/20210201162644.png" alt></p><p>这个依赖又是干什么的呢？</p><p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标即可，而 Micrometer 则会负责完成与不同监控系统的适配工作，类似于一个 Adapter，有了这个 Adapter，切换监控系统就变得非常容易。同时 Micrometer 还支持推送数据到多个不同的监控系统。</p><p>而 Spring Boot Actuator 使用 Micrometer 与外部应用监视系统进行集成，这样一来，开发者只需要稍微配置一下就可以使其和外部应用监视系统进行整合了。Micrometer 支持的监控系统有：</p><ul><li>AppOptics</li><li>Atlas</li><li>Datadog</li><li>Dynatrace</li><li>Elastic</li><li>Ganglia</li><li>Graphite</li><li>Humio</li><li>Influx</li><li>JMX</li><li>KairosDB</li><li>New Relic</li><li>Prometheus</li><li>SignalFx</li><li>Simple (in-memory)</li><li>StatsD</li><li>Wavefront</li></ul><p>信息采集器这块，老实说松哥见到的大部分项目都是用的 Spring Boot Actuator，似乎没有其他更好的选择。如果小伙伴们有用到其他方案，也可以留言讨论。</p><p>接下来我们来看看一些常用的应用监控可视化工具。</p><h2 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h2><p>这个算是 Spring Boot 中最最正宗的应用监控可视化工具了，看名字就知道有多正宗，当我们创建一个 Spring Boot 项目时，选择依赖时候就有这个选项：</p><p><img src="http://img.itboyhub.com/2021/02/20210201173448.png" alt></p><p>如果是<strong>单体应用</strong>很多人可能会选择 Spring Boot Admin 作为监控数据可视化工具，不过它也支持微服务应用的(可以通过 Eureka、Consul 等注册中心获取应用信息)，只不过在微服务中，我们可能会更多的选择 Grafana+Prometheus 组合。</p><p>Spring Boot Admin 主要包含如下功能：</p><ul><li>显示应用健康信息。</li><li>显示应用运行的详细信息，例如 JVM 和内存指标、数据源指标、缓存指标等等。</li><li>显示应用的构建信息。</li><li>查看 JVM 系统和环境属性</li><li>查看 Spring Boot 配置属性</li><li>支持 Spring Cloud 中的端点刷新功能 /refresh-endpoint</li><li>方便的日志级别管理功能</li><li>可以与 JMX-beans 进行交互</li><li>查看 Thread dump</li><li>查看 http 请求</li><li>查看计划任务</li><li>查看和删除活动会话</li><li>查看 Flyway/Liquibase 数据库迁移</li><li>下载 heapdump</li><li>状态更改通知</li><li>…</li></ul><p>可以看到，Spring Boot Admin 不仅仅是将 Actuator 接口中的数据进行可视化，还在此基础上提供了分析、报警等功能。</p><p>Spring Boot Admin 的显示界面如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210201181913.png" alt></p><h2 id="Grafana-Prometheus"><a href="#Grafana-Prometheus" class="headerlink" title="Grafana+Prometheus"></a>Grafana+Prometheus</h2><p>这个组合在微服务项目中比较常见，松哥之前录制的 Spring Cloud 视频里边也有讲到（公号后台回复 vhr 有视频详细介绍）。</p><p><img src="http://img.itboyhub.com/2021/02/20210201182618.png" alt></p><p>Prometheus 是一款开源的监控 + 时序数据库 + 报警软件，由SoundCloud 公司开发的，在 CNCF 基金会托管并已成功孵化，不过这个 Prometheus 的 UI 比较简单，用户体验不怎么好，现在都流行大屏监控页面，上面展示各种炫酷的图表。所以在实际应用中，Prometheus 一般都是结合 Grafana 一起来使用，Grafana 也是一个开源的跨平台度量分析和可视化 + 告警工具，它支持多种数据源，包括 Prometheus，Grafana 的 UI 就比较炫酷，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210201200600.png" alt></p><p>当然，使用这套组合也离不开 Spring Boot Actuator。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>前面跟小伙伴们分享了 Spring Boot 应用监控的主流方案，没说具体用法，后面抽空松哥会和大家聊一聊具体用法。除了这些主流的方案之后，还有很多小众的方案，松哥也见到有极少数项目团队自研应用监控方案。不过对于大多数的项目而言，这些现成的成熟方案无疑是最佳选择。</p><p>好啦，今天就先和小伙伴们聊这么多，后面我们再来看具体用法～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用监控是我们在生产环境下一个非常重要的东西，运维人员不可能 24 小时盯着应用，应用挂了及时解决，这不现实。我们需要能够实时掌握应用的运行数据，以便提早发现问题，同时在应用挂掉的时候还能够自动报警，这样才能解放开发人员。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Actuator" scheme="http://www.javaboy.org/tags/Actuator/"/>
    
  </entry>
  
  <entry>
    <title>Swagger3.0，你所不知道的新变化！</title>
    <link href="http://www.javaboy.org/2021/0129/springboot-swagger3.html"/>
    <id>http://www.javaboy.org/2021/0129/springboot-swagger3.html</id>
    <published>2021-01-29T14:38:24.000Z</published>
    <updated>2021-03-07T15:09:45.200Z</updated>
    
    <content type="html"><![CDATA[<p>在社区的推动下，Springfox3.0 去年 7 月份就发布了，最近终于得空和小伙伴们聊一聊新版本的新变化。这次的版本升级估计小伙伴们都翘首以待好久了，毕竟上一次发版已经是两年前的事情了。</p><a id="more"></a><p><img src="http://img.itboyhub.com/2021/01/docker/20210128112402.png" alt></p><p>新版本还是有很多好玩的地方，我们一起来看下。</p><h2 id="支持-OpenAPI"><a href="#支持-OpenAPI" class="headerlink" title="支持 OpenAPI"></a>支持 OpenAPI</h2><p>什么是 OpenAPI？</p><p>OpenAPI 规范其实就是以前的 Swagger 规范，它是一种 REST API 的描述格式，通过既定的规范来描述文档接口，它是业界真正的 API 文档标准，可以通过 YAML 或者 JSON 来描述。它包括如下内容：</p><ul><li>接口（/users）和每个接口的操作（GET /users，POST /users）</li><li>输入参数和响应内容</li><li>认证方法</li><li>一些必要的联系信息、license 等。</li></ul><p>关于 OpenAPI 的更多内容，感兴趣的小伙伴可以在 GitHub 上查看：<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md" target="_blank" rel="noopener">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md</a></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>以前在使用 2.9.2 这个版本的时候，一般来说我们可能需要添加如下两个依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两个，一个用来生成接口文档（JSON 数据），另一个用来展示将 JSON 可视化。</p><p>在 3.0 版本中，我们不需要这么麻烦了，一个 starter 就可以搞定：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和 Spring Boot 中的其他 starter 一样，springfox-boot-starter 依赖可以实现零配置以及自动配置支持。也就是说，如果你没有其他特殊需求，加一个这个依赖就行了，接口文档就自动生成了。</p><h2 id="接口地址"><a href="#接口地址" class="headerlink" title="接口地址"></a>接口地址</h2><p>3.0 中的接口地址也和之前有所不同，以前在 2.9.2 中我们主要访问两个地址：</p><ul><li>文档接口地址：<a href="http://localhost:8080/v2/api-docs" target="_blank" rel="noopener">http://localhost:8080/v2/api-docs</a></li><li>文档页面地址：<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a></li></ul><p>现在在 3.0 中，这两个地址也发生了变化：</p><ul><li>文档接口地址：<a href="http://localhost:8080/v3/api-docs" target="_blank" rel="noopener">http://localhost:8080/v3/api-docs</a></li><li>文档页面地址：<a href="http://localhost:8080/swagger-ui/index.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui/index.html</a></li></ul><p>特别是文档页面地址，如果用了 3.0，而去访问之前的页面，会报 404。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>旧的注解还可以继续使用，不过在 3.0 中还提供了一些其他注解。</p><p>例如我们可以使用 @EnableOpenApi 代替以前旧版本中的 @EnableSwagger2。</p><p>话是这么说，不过松哥在实际体验中，感觉 @EnableOpenApi 注解的功能不明显，加不加都行。翻了下源码，@EnableOpenApi 注解主要功能是为了导入 OpenApiDocumentationConfiguration 配置类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(value = &#123;java.lang.annotation.ElementType.TYPE&#125;)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Import</span>(OpenApiDocumentationConfiguration.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableOpenApi &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我又看了下自动化配置类 OpenApiAutoConfiguration，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(SpringfoxConfigurationProperties.class)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(value = <span class="hljs-string">"springfox.documentation.enabled"</span>, havingValue = <span class="hljs-string">"true"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123;</span><br><span class="line">    OpenApiDocumentationConfiguration.class,</span><br><span class="line">    SpringDataRestConfiguration.class,</span><br><span class="line">    BeanValidatorPluginsConfiguration.class,</span><br><span class="line">    Swagger2DocumentationConfiguration.class,</span><br><span class="line">    SwaggerUiWebFluxConfiguration.class,</span><br><span class="line">    SwaggerUiWebMvcConfiguration.class</span><br><span class="line">&#125;)</span><br><span class="line"><span class="hljs-meta">@AutoConfigureAfter</span>(&#123; WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,</span><br><span class="line">    HttpMessageConvertersAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenApiAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，自动化配置类里边也导入了 OpenApiDocumentationConfiguration。</p><p>所以在正常情况下，实际上不需要添加 @EnableOpenApi 注解。</p><p>根据 OpenApiAutoConfiguration 上的 @ConditionalOnProperty 条件注解中的定义，我们发现，如果在 application.properties 中设置 <code>springfox.documentation.enabled=false</code>，即关闭了 swagger 功能，此时自动化配置类就不执行了，这个时候可以通过 @EnableOpenApi 注解导入 OpenApiDocumentationConfiguration 配置类。技术上来说逻辑是这样，不过应用中暂未发现这样的需求（即在 application.properties 中关闭 swagger，再通过 @EnableOpenApi 注解开启）。</p><p>对于 @EnableOpenApi 注解的使用场景，小伙伴们要是有自己的见解，欢迎留言讨论。</p><p>另外，以前我们用的 @ApiResponses/@ApiResponse 注解，在 3.0 中名字没变，但是所在的包变了，小伙伴们使用时注意导包问题哦。</p><p>另外，我们之前用的 @ApiOperation 注解在 3.0 中可以使用 @Operation 代替。</p><p>另外还有一些新注解如 @Parameter、Parameters、@Schema 等，松哥尝试了下，感觉不太好用，不如旧的用的舒服，这些新注解小伙伴们可以自行尝试下。</p><p>好啦，今天主要和小伙伴们分享了 Swagger3.0 带来的一些新变化，如果还没用过 Swagger，可以在公众号后台回复 666，有一个松哥原创的 Spring Boot 入门教程，里边有讲 Swagger 的用法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在社区的推动下，Springfox3.0 去年 7 月份就发布了，最近终于得空和小伙伴们聊一聊新版本的新变化。这次的版本升级估计小伙伴们都翘首以待好久了，毕竟上一次发版已经是两年前的事情了。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Swagger3" scheme="http://www.javaboy.org/tags/Swagger3/"/>
    
  </entry>
  
  <entry>
    <title>Maven 聚合工程的几个小细节</title>
    <link href="http://www.javaboy.org/2021/0127/maven.html"/>
    <id>http://www.javaboy.org/2021/0127/maven.html</id>
    <published>2021-01-27T14:38:10.000Z</published>
    <updated>2021-03-07T15:10:01.015Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 作为我们 Java 开发领域最最基础的工具，估计每个小伙伴每天都在用。但是对于新手而言，Maven 中有一些基本的概念似乎很容易搞混，例如继承、聚合、集成等等。所以今天我们就来简单聊聊这个话题。</p><a id="more"></a><h2 id="为什么需要分模块"><a href="#为什么需要分模块" class="headerlink" title="为什么需要分模块"></a>为什么需要分模块</h2><p>松哥在 vhr(<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>) 项目中也用到了聚合工程，那么为什么用聚合工程？直接一个工程分包不行吗？</p><p>如果只是一个小 case，分包当然是可以的，但是如果项目越来越大，分包的弊端就会逐步展现出来：</p><ul><li>pom.xml 中引用的依赖非常多以至于难以维护。</li><li>同时在修改 dao 层的代码，结果改错了，你在 service 层编译不通过，烦躁。</li><li>项目越来越大，build 等待时间也越来越长。</li><li>有一个新的项目想要复用你的 utils 工具包，结果你只能去拷贝代码。</li></ul><p>这样高度耦和的代码实际上并不符合我们的设计规范，所以我们需要对代码进行拆分，做成不同的模块。</p><h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><p>经过模块划分后，我们的 Maven 项目结构可能是这样的：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">└── vhr-parent</span><br><span class="line">    ├── vhr-dao</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   └── src</span><br><span class="line">    │       ├── main</span><br><span class="line">    │       │   ├── java</span><br><span class="line">    │       │   └── resources</span><br><span class="line">    │       └── test</span><br><span class="line">    │           └── java</span><br><span class="line">    ├── vhr-service</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   └── src</span><br><span class="line">    │       ├── main</span><br><span class="line">    │       │   ├── java</span><br><span class="line">    │       │   └── resources</span><br><span class="line">    │       └── test</span><br><span class="line">    │           └── java</span><br><span class="line">    └── vhr-web</span><br><span class="line">        ├── pom.xml</span><br><span class="line">        └── src</span><br><span class="line">            ├── main</span><br><span class="line">            │   ├── java</span><br><span class="line">            │   └── resources</span><br><span class="line">            └── test</span><br><span class="line">                └── java</span><br></pre></td></tr></table></figure><p>先说下代码组织形式，可以是父子形式，就像上面这样，父工程是一个目录，子工程的目录在父工程目录中。也可以是平铺的形式，即父子工程在同一目录下。两种形式皆可，但是在配置上会略有差异，这个松哥后面会说，这里我们先按照上面这种代码组织形式来讲。</p><p>service 依赖 dao，web 依赖 service，默认情况下，依赖是可以传递的，所以你在 web 中也可以使用 dao。一些特殊的情况下，如果我们不希望依赖传递，则可以使用 scope 节点进行配置。</p><p>一般来说，dao、service 都是打包成 jar、web 打包成 war，parent 的 packaging 类型则是一个 pom。</p><p>按照模块划分之后，上面我们所提到的问题，现在都解决了：</p><ul><li>首先，项目变大之后，build 等待时间并不会飞速增长，各个模块都可以独自 build。</li><li>拆分之后，pom.xml 文件中的依赖也不再凌乱。</li><li>如果其他项目有需要，可以方便的将某一个模块提供给其他项目使用。</li><li>依赖版本可以使用 depencencyManagement 节点进行统一管理。spring-boot 中的 parent 就是这么干的。</li></ul><h2 id="配置细节"><a href="#配置细节" class="headerlink" title="配置细节"></a>配置细节</h2><p>首先我们来看下 vhr-parent 中的配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前面我们说过了，parent 的 packaging 节点要为 pom，这个是固定的，只要有子模块，packaging 就是 pom。</p><p>另外我们还在 parent 的 pom.xml 中配置了 modules，将其所包含的所有子模块都列出来，当我们在 parent 处进行打包时，Maven 会自动梳理子模块之间的依赖关系，整理出来一个 build 顺序，然后进行编译打包。</p><p>再来看看子模块的 pom.xml 配置，以 vhr-service 为例：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模块中需要配置 parent，这样 vhr-service 就继承了 parent 的一切，包括依赖、插件、坐标、版本号等等，有了来自 parent 的一大堆东西之后，vhr-service 自己的 pom.xml 中只需要简单配置一下 artifactId 即可。依赖的版本号则可以通过 ${project.version} 变量引用项目的版本号。</p><p>这里没有配置 packaging，默认就是 jar，所以可以省略，如果是 web 模块，则还需要配置 packaging 为 war。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>聚合工程，听名字就知道是很多工程聚在一起组成一个完整的项目，所以打包的时候，也是一起打包。直接在 parent 处执行 <code>mvn package</code> 命令，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sang-3:vhr-parent sang$ mvn package</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Build Order:</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] vhr-parent                                                         [pom]</span><br><span class="line">[INFO] vhr-dao                                                            [jar]</span><br><span class="line">[INFO] vhr-service                                                        [jar]</span><br><span class="line">[INFO] vhr-web                                                            [jar]</span><br><span class="line">[INFO] </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Reactor Summary for vhr-parent 1.0-SNAPSHOT:</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] vhr-parent ......................................... SUCCESS [  0.004 s]</span><br><span class="line">[INFO] vhr-dao ............................................ SUCCESS [  0.867 s]</span><br><span class="line">[INFO] vhr-service ........................................ SUCCESS [  0.038 s]</span><br><span class="line">[INFO] vhr-web ............................................ SUCCESS [  0.025 s]</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  1.021 s</span><br><span class="line">[INFO] Finished at: 2021-01-26T12:50:42+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>可以看到整个打包过程，各个聚合工程都被打包了。打包完成后，在不同模块的目录下都可以看到一个 target 目录，里边就有刚刚打包好的 jar 或者 war。</p><p>如果你使用的是 IntelliJ IDEA，也可以在工具右侧找到 Maven-&gt;LifeCycle-&gt;Package，双击进行打包。</p><p><img src="http://img.itboyhub.com/2021/springboot2/20210126125328.png" alt></p><h2 id="目录问题"><a href="#目录问题" class="headerlink" title="目录问题"></a>目录问题</h2><p>在前面的案例中，我们的代码结构使用了父子目录的形式，但是在实际应用中，有的时候我们可能会采用平铺的形式，像下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">└── vhr</span><br><span class="line">    ├── parent</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    ├── vhr-dao</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   ├── src</span><br><span class="line">    │   │   ├── main</span><br><span class="line">    │   │   │   ├── java</span><br><span class="line">    │   │   │   └── resources</span><br><span class="line">    │   │   └── test</span><br><span class="line">    │   │       └── java</span><br><span class="line">    ├── vhr-service</span><br><span class="line">    │   ├── pom.xml</span><br><span class="line">    │   ├── src</span><br><span class="line">    │   │   ├── main</span><br><span class="line">    │   │   │   ├── java</span><br><span class="line">    │   │   │   └── resources</span><br><span class="line">    │   │   └── test</span><br><span class="line">    │   │       └── java</span><br><span class="line">    └── vhr-web</span><br><span class="line">        ├── pom.xml</span><br><span class="line">        ├── src</span><br><span class="line">        │   ├── main</span><br><span class="line">        │   │   ├── java</span><br><span class="line">        │   │   └── resources</span><br><span class="line">        │   └── test</span><br><span class="line">        │       └── java</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/springboot2/20210126132625.png" alt></p><p>可以看到，parent 和各个子模块处于同一目录下，这个时候，无论是 parent 的 pom.xml 还是子模块的 pom.xml，写法都会和之前略有差异。</p><p>先来看 parent 的 pom.xml：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于 module 中定义的是子模块名称，所以，当子模块和父模块处于同一目录下时，需要明确指出子模块的位置，因此这里用到了相对路径。</p><p>同理，在子模块中也需要明确指定父模块的 pom.xml，以 vhr-service 为例，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在 parnet 节点中多了 relativePath 用来指定父模块的 pom.xml。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Maven 作为我们 Java 开发领域最最基础的工具，估计每个小伙伴每天都在用。但是对于新手而言，Maven 中有一些基本的概念似乎很容易搞混，例如继承、聚合、集成等等。所以今天我们就来简单聊聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://www.javaboy.org/categories/Maven/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
      <category term="Maven" scheme="http://www.javaboy.org/tags/Maven/"/>
    
  </entry>
  
</feed>
