<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2021-11-03T12:36:20.858Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10万条数据批量插入，到底怎么做才快？</title>
    <link href="http://www.javaboy.org/2021/1102/mysql_batch_insert.html"/>
    <id>http://www.javaboy.org/2021/1102/mysql_batch_insert.html</id>
    <published>2021-11-02T12:23:31.000Z</published>
    <updated>2021-11-03T12:36:20.858Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>上周松哥转载了一个数据批量插入的文章，里边和大家聊了一下数据批量插入的问题，批量插入到底怎么做才快。</p><p>有个小伙伴看了文章后提出了不同的意见：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2021/10/tran/20211102121436.png" alt></p><p>松哥认真和 BUG 同学聊了下，基本上明白了这个小伙伴的意思，于是我自己也写了个测试案例，重新整理了今天这篇文章，希望和小伙伴们一起探讨这个问题，也欢迎小伙伴们提出更好的方案。</p><h2 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1. 思路分析"></a>1. 思路分析</h2><p>批量插入这个问题，我们用 JDBC 操作，其实就是两种思路吧：</p><ol><li>用一个 for 循环，把数据一条一条的插入（这种需要开启批处理）。</li><li>生成一条插入 sql，类似这种 <code>insert into user(username,address) values(&#39;aa&#39;,&#39;bb&#39;),(&#39;cc&#39;,&#39;dd&#39;)...</code>。</li></ol><p>到底哪种快呢？</p><p>我们从两方面来考虑这个问题：</p><ol><li>插入 SQL 本身执行的效率。</li><li>网络 I/O。</li></ol><p>先说第一种方案，就是用 for 循环循环插入：</p><ul><li>这种方案的优势在于，JDBC 中的 PreparedStatement 有预编译功能，预编译之后会缓存起来，后面的 SQL 执行会比较快并且 JDBC 可以开启批处理，这个批处理执行非常给力。</li><li>劣势在于，很多时候我们的 SQL 服务器和应用服务器可能并不是同一台，所以必须要考虑网络 IO，如果网络 IO 比较费时间的话，那么可能会拖慢 SQL 执行的速度。</li></ul><p>再来说第二种方案，就是生成一条 SQL 插入：</p><ul><li>这种方案的优势在于只有一次网络 IO，即使分片处理也只是数次网络 IO，所以这种方案不会在网络 IO 上花费太多时间。</li><li>当然这种方案有好几个劣势，一是 SQL 太长了，甚至可能需要分片后批量处理；二是无法充分发挥 PreparedStatement 预编译的优势，SQL 要重新解析且无法复用；三是最终生成的 SQL 太长了，数据库管理器解析这么长的 SQL 也需要时间。</li></ul><p>所以我们最终要考虑的就是我们在网络 IO 上花费的时间，是否超过了 SQL 插入的时间？这是我们要考虑的核心问题。</p><h2 id="2-数据测试"><a href="#2-数据测试" class="headerlink" title="2. 数据测试"></a>2. 数据测试</h2><p>接下来我们来做一个简单的测试，批量插入 5 万条数据看下。</p><p>首先准备一个简单的测试表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`address`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`password`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>接下来创建一个 Spring Boot 工程，引入 MyBatis 依赖和 MySQL 驱动，然后 application.properties 中配置一下数据库连接信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123</span><br><span class="line">spring.datasource.url=jdbc:mysql:///batch_insert?serverTimezone=Asia/Shanghai&amp;rewriteBatchedStatements=true</span><br></pre></td></tr></table></figure><p>大家需要注意，这个数据库连接 URL 地址中多了一个参数 <strong>rewriteBatchedStatements</strong>，这是核心。</p><p>MySQL JDBC 驱动在默认情况下会无视 <code>executeBatch()</code> 语句，把我们期望批量执行的一组 <code>sql</code> 语句拆散，一条一条地发给 <code>MySQL</code> 数据库，批量插入实际上是单条插入，直接造成较低的性能。将 <code>rewriteBatchedStatements</code> 参数置为 <code>true</code>, 数据库驱动才会帮我们批量执行 <code>SQL</code>。</p><p>OK，这样准备工作就做好了。</p><h3 id="2-1-方案一测试"><a href="#2-1-方案一测试" class="headerlink" title="2.1 方案一测试"></a>2.1 方案一测试</h3><p>首先我们来看方案一的测试，即一条一条的插入（实际上是批处理）。</p><p>首先创建相应的 mapper，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">Integer <span class="hljs-title">addUserOneByOne</span><span class="hljs-params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 XML 文件如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"addUserOneByOne"</span>&gt;</span></span><br><span class="line">    insert into user (username,address,password) values (#&#123;username&#125;,#&#123;address&#125;,#&#123;password&#125;)</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>service 如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">UserMapper</span>, <span class="hljs-title">User</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(UserService.class);</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUserOneByOne</span><span class="hljs-params">(List&lt;User&gt; users)</span> </span>&#123;</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line">        UserMapper um = session.getMapper(UserMapper.class);</span><br><span class="line">        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="hljs-keyword">for</span> (User user : users) &#123;</span><br><span class="line">            um.addUserOneByOne(user);</span><br><span class="line">        &#125;</span><br><span class="line">        session.commit();</span><br><span class="line">        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="hljs-string">"一条条插入 SQL 耗费时间 &#123;&#125;"</span>, (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我要说一下：</p><p>虽然是一条一条的插入，但是我们要开启批处理模式（BATCH），这样前前后后就只用这一个 SqlSession，如果不采用批处理模式，反反复复的获取 Connection 以及释放 Connection 会耗费大量时间，效率奇低，这种效率奇低的方式松哥就不给大家测试了。</p><p>接下来写一个简单的测试接口看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = getLogger(HelloController.class);</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 一条一条插入</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">user2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000</span>; i++) &#123;</span><br><span class="line">            User u = <span class="hljs-keyword">new</span> User();</span><br><span class="line">            u.setAddress(<span class="hljs-string">"广州："</span> + i);</span><br><span class="line">            u.setUsername(<span class="hljs-string">"张三："</span> + i);</span><br><span class="line">            u.setPassword(<span class="hljs-string">"123："</span> + i);</span><br><span class="line">            users.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        userService.addUserOneByOne(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个简单的单元测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * 单元测试加事务的目的是为了插入之后自动回滚，避免影响下一次测试结果</span></span><br><span class="line"><span class="hljs-comment"> * 一条一条插入</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addUserOneByOne</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000</span>; i++) &#123;</span><br><span class="line">        User u = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        u.setAddress(<span class="hljs-string">"广州："</span> + i);</span><br><span class="line">        u.setUsername(<span class="hljs-string">"张三："</span> + i);</span><br><span class="line">        u.setPassword(<span class="hljs-string">"123："</span> + i);</span><br><span class="line">        users.add(u);</span><br><span class="line">    &#125;</span><br><span class="line">    userService.addUserOneByOne(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20211026213505.png" alt></p><p>可以看到，耗时 901 毫秒，5w 条数据插入不到 1 秒。</p><h3 id="2-2-方案二测试"><a href="#2-2-方案二测试" class="headerlink" title="2.2 方案二测试"></a>2.2 方案二测试</h3><p>方案二是生成一条 SQL 然后插入。</p><p>mapper 如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addByOneSQL</span><span class="hljs-params">(@Param(<span class="hljs-string">"users"</span>)</span> List&lt;User&gt; users)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 SQL 如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"addByOneSQL"</span>&gt;</span></span><br><span class="line">    insert into user (username,address,password) values</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"users"</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span>&gt;</span></span><br><span class="line">        (#&#123;user.username&#125;,#&#123;user.address&#125;,#&#123;user.password&#125;)</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>service 如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">UserMapper</span>, <span class="hljs-title">User</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(UserService.class);</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="hljs-meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addByOneSQL</span><span class="hljs-params">(List&lt;User&gt; users)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        userMapper.addByOneSQL(users);</span><br><span class="line">        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="hljs-string">"合并成一条 SQL 插入耗费时间 &#123;&#125;"</span>, (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在单元测试中调一下这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 合并成一条 SQL 插入</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addByOneSQL</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50000</span>; i++) &#123;</span><br><span class="line">        User u = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        u.setAddress(<span class="hljs-string">"广州："</span> + i);</span><br><span class="line">        u.setUsername(<span class="hljs-string">"张三："</span> + i);</span><br><span class="line">        u.setPassword(<span class="hljs-string">"123："</span> + i);</span><br><span class="line">        users.add(u);</span><br><span class="line">    &#125;</span><br><span class="line">    userService.addByOneSQL(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20211026213928.png" alt></p><p>可以看到插入 5 万条数据耗时 1805 毫秒。</p><p>可以看到，生成一条 SQL 的执行效率还是要差一点。</p><p>另外还需要注意，第二种方案还有一个问题，就是当数据量大的时候，生成的 SQL 将特别的长，MySQL 可能一次性处理不了这么大的 SQL，这个时候就需要修改 MySQL 的配置或者对待插入的数据进行分片处理了，这些操作又会导致插入时间更长。</p><h3 id="2-3-对比分析"><a href="#2-3-对比分析" class="headerlink" title="2.3 对比分析"></a>2.3 对比分析</h3><p>很明显，方案一更具优势。当批量插入十万、二十万数据的时候，方案一的优势会更加明显（方案二则需要修改 MySQL 配置或者对待插入数据进行分片）。</p><h2 id="3-MP-怎么做的？"><a href="#3-MP-怎么做的？" class="headerlink" title="3. MP 怎么做的？"></a>3. MP 怎么做的？</h2><p>小伙伴们知道，其实 MyBatis Plus 里边也有一个批量插入的方法 saveBatch，我们来看看它的实现源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">saveBatch</span><span class="hljs-params">(Collection&lt;T&gt; entityList, <span class="hljs-keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">    String sqlStatement = getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">    <span class="hljs-keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里拿到的 sqlStatement 就是一个 <code>INSERT_ONE</code>，即一条一条插入。</p><p>再来看 executeBatch 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">executeBatch</span><span class="hljs-params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="hljs-keyword">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="hljs-number">1</span>, <span class="hljs-string">"batchSize must not be less than one"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> size = list.size();</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="hljs-keyword">if</span> ((i % batchSize == <span class="hljs-number">0</span>) || i == size) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意 return 中的第三个参数，是一个 lambda 表达式，这也是 MP 中批量插入的核心逻辑，可以看到，MP 先对数据进行分片（默认分片大小是 1000），分片完成之后，也是一条一条的插入。继续查看 executeBatch 方法，就会发现这里的 sqlSession 其实也是一个批处理的 sqlSession，并非普通的 sqlSession。</p><p>综上，MP 中的批量插入方案跟我们 2.1 小节的批量插入思路其实是一样的。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，经过上面的分析，现在小伙伴们知道了批量插入该怎么做了吧？</p><p>松哥提供了一个测试案例，公众号后台回复<strong>批量插入测试</strong>获取案例地址，案例中有三个单元测试方法，直接运行，就可以看到批量插入的时间差异（数据库脚本在 resources 目录下）。</p><p>感兴趣的小伙伴不妨试试~</p><p>最后再次感谢 BUG 童鞋提出的意见~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;上周松哥转载了一个数据批量插入的文章，里边和大家聊了一下数据批量插入的问题，批量插入到底怎么做才快。&lt;/p&gt;
&lt;p&gt;有个小伙伴看了文章后提出了不同的意见：&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>由蒸馒头悟出的一点敲代码的道理~</title>
    <link href="http://www.javaboy.org/2021/1101/coding.html"/>
    <id>http://www.javaboy.org/2021/1101/coding.html</id>
    <published>2021-11-01T12:23:10.000Z</published>
    <updated>2021-11-03T12:36:15.249Z</updated>
    
    <content type="html"><![CDATA[<p>前两周松哥一时兴起，整了一锅馒头，第一次尝试，效果还不错，虽然馒头的外观不大美观，但是味道还是杠杠滴：</p><ul><li><a href="https://mp.weixin.qq.com/s/3bx6fiTHY9nYr5WyiuGmaQ" target="_blank" rel="noopener">周六蒸馒头，周日录视频，技术圈惊现美食博主</a></li></ul><a id="more"></a><p>因为第一次蒸馒头比较顺利，所以上周我又尝试了一把，这次对馒头的外观进行了改进，看起来比第一次蒸的馒头好看多了，然而味道和第一次相比似乎查了一丢丢~</p><p>这一好一坏，让我想起来刚毕业时候在公司敲代码的情景~</p><p>long long ago，我还是一名安卓猿，当时移动互联网火热，公司也在积极开拓新业务，于是招了一帮应届生来敲 App。</p><p>大概是在头一年 10 月份左右，招了一帮实习生，据说当时没日没夜的搞了几个月，弄出来了 1.0 版，1.0 版上线后，最大的问题就是闪崩，这也是 Android 开发中较常见的问题，就是点着点着 App 就崩了，崩了就得去检查问题，找到问题后修复，本来没啥，问题在于闪崩的问题始终无法根治，总是有，可能是在修改 BUG 的过程中引发的新问题，也可能是在开发新功能的时候引出来的新问题，总之一直到第二年 6 月底我入职的时候，闪崩问题都还在。我入职的头一个月，就是解决各种各样的闪崩问题。</p><p>有一次我开发的一个自定义下拉刷新被一个同事不知道是有意还是无意改了一个像素参数，导致下拉列表顶部有一条非常细小的线，如果用户在下拉刷新时刚好按在了这条线上，就崩了。这个问题测试测了好久都没找到崩溃的具体原因，他们就是说你这个点着点着就崩溃，我说没有啊，他们当着我的面演示，也不能重现问题，好吧，这种不能稳定重现的 BUG 就先放着吧。。。直到有一天他们部门老大找来，这问题才到了非解决不可的地步，我自己研究，找规律，终于发现了问题所在，然后看 Svn 上的提交记录，知道是有人改了参数…</p><p>总之，当时我们一帮应届生，在一个有经验的大佬领导下（他不怎么参与安卓 Coding），鼓捣出来的这个 App 总是不太稳定。</p><p>不久之后，我们的直属领导，一个搞 C# 的大佬，被拉去开发一个新的桌面系统，因为公司人力有限，新的系统很长一段时间都是他一个人在搞。在一次项目汇报的会议中，他说了一句话令我印象深刻：“我这个系统目前功能完成了 60% 左右，目前没有任何莫名其妙/不可预见的崩溃，很稳定”。</p><p>大佬这话说出来，和我们几个应届生做出来的安卓 App 形成了鲜明对比，我当时就在心里想，这就是大佬。</p><p>多年后，当我再次回想起这件事，脑子里闪出一个词：<strong>“稳定输出”</strong>，这可能是大佬和新手的重要区别。</p><p>现在网络上的学习资料非常多，图书市场也非常繁荣，大部分情况下，我们需要的资料都能在网上/书上找到，面向搜索引擎编程，小白也能完成很多事情，这就给人一种错觉，年纪越大的程序员在逐步丧失竞争力。然而真的是这样吗！</p><p>新手往往需要在学习中写代码，这样的代码虽然也能实现功能，但是可能像下图这样：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20211029193101.png" alt></p><p>功能实现了，但是网上借鉴了很多不知道啥意思的代码，所以写好的代码不能动，一动程序就挂了。</p><p>而有经验的老手，他们的代码都是自己敲的，可以做到“稳定输出”，他们知道自己每一行代码的含义，出了问题能够快速定位到问题原因，知道怎么修改，这也是老手的价值之一。</p><p>我这里说的老手并非年长者，而是开发经验丰富的大佬，与年龄无关。我这里所说的开发也主要是指 Java 应用/企业级项目开发。</p><p>上周第二次蒸馒头就属于不能“稳定输出”，新手的通病，加强练习争取早日能够实现“稳定输出”。</p><p>无意冒犯任何人，以上纯属个人经验并非真理，轻喷。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两周松哥一时兴起，整了一锅馒头，第一次尝试，效果还不错，虽然馒头的外观不大美观，但是味道还是杠杠滴：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3bx6fiTHY9nYr5WyiuGmaQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;周六蒸馒头，周日录视频，技术圈惊现美食博主&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>这套视频，诚意满满！</title>
    <link href="http://www.javaboy.org/2021/1029/spring_transaction_video.html"/>
    <id>http://www.javaboy.org/2021/1029/spring_transaction_video.html</id>
    <published>2021-10-29T12:22:56.000Z</published>
    <updated>2021-11-03T12:36:53.641Z</updated>
    
    <content type="html"><![CDATA[<p>没错，最近 B 站视频上新速度加快了～</p><p>在刚刚过去的周末，松哥又整了一套，不废话，来看看目录：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2021/10/tran/20211027223900.png" alt></p><p>松哥周二发了一篇 Spring 事务相关的教程，传送门：</p><ul><li><a href="https://mp.weixin.qq.com/s/6tRPXwXnWUW4mVfCdBlkog" target="_blank" rel="noopener">长文捋明白 Spring 事务！隔离性？传播性？一网打尽！</a></li></ul><p>Spring 事务说难也不难，但是传播性和隔离性是两个比较绕的知识点，学习这两个知识点不能光靠死记硬背概念，那样转个身就忘记了！最好是能够敲一下代码，设计几个小案例看一下到底是个啥情况，只有自己亲身体验的，印象才会深刻。</p><p>那么上面这套视频松哥就是通过一个又一个简单的案例来和大家分享 Spring 事务中的各种细节，让小伙伴们用案例记住 Spring 事务的各项特点。</p><p>现在视频已经上传到 B 站了，小伙伴们去撸吧～</p><p>视频链接：</p><ul><li><a href="https://www.bilibili.com/video/BV1Eq4y1R7Ds" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Eq4y1R7Ds</a></li></ul><p>点击阅读原文直达 B 站～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没错，最近 B 站视频上新速度加快了～&lt;/p&gt;
&lt;p&gt;在刚刚过去的周末，松哥又整了一套，不废话，来看看目录：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="video" scheme="http://www.javaboy.org/tags/video/"/>
    
      <category term="Transaction" scheme="http://www.javaboy.org/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>长文捋明白 Spring 事务！隔离性？传播性？一网打尽！</title>
    <link href="http://www.javaboy.org/2021/1026/spring_transaction.html"/>
    <id>http://www.javaboy.org/2021/1026/spring_transaction.html</id>
    <published>2021-10-26T12:22:40.000Z</published>
    <updated>2021-11-03T12:36:46.620Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>事务的重要性不言而喻，Spring 对事务也提供了非常丰富的支持，各种支持的属性应有尽有。</p><p>然而很多小伙伴知道，这里有两个属性特别绕：</p><ul><li>隔离性</li><li>传播性</li></ul><a id="more"></a><p>有多绕呢？松哥都一直懒得写文章去总结。不过最近有小伙伴问到这个问题，刚好有空，就抽空总结一下，我不会干巴巴的和大家讲概念，接下来的所有内容，松哥都会通过具体的案例来和大家演示。</p><p>好啦，不废话啦，请看大屏幕。</p><h2 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务"></a>1. 什么是事务</h2><p>数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么一起成功，要么一起失败，是一个不可分割的工作单元。</p><p>在我们日常工作中，涉及到事务的场景非常多，一个 service 中往往需要调用不同的 dao 层方法，这些方法要么同时成功要么同时失败，我们需要在 service 层确保这一点。</p><p>说到事务最典型的案例就是转账了：</p><blockquote><p>张三要给李四转账 500 块钱，这里涉及到两个操作，从张三的账户上减去 500 块钱，给李四的账户添加 500 块钱，这两个操作要么同时成功要么同时失败，如何确保他们同时成功或者同时失败呢？答案就是事务。</p></blockquote><p>事务有四大特性（ACID）：</p><p><img src="http://img.itboyhub.com/2021/07/20211012195927.png" alt></p><ul><li><strong>原子性（Atomicity）：</strong> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read Uncommitted）、提交读（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</li><li><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>这就是事务的四大特性。</p><h2 id="2-Spring-中的事务"><a href="#2-Spring-中的事务" class="headerlink" title="2. Spring 中的事务"></a>2. Spring 中的事务</h2><h3 id="2-1-两种用法"><a href="#2-1-两种用法" class="headerlink" title="2.1 两种用法"></a>2.1 两种用法</h3><p>Spring 作为 Java 开发中的基础设施，对于事务也提供了很好的支持，总体上来说，Spring 支持两种类型的事务，声明式事务和编程式事务。</p><p>编程式事务类似于 Jdbc 事务的写法，需要将事务的代码嵌入到业务逻辑中，这样代码的耦合度较高，而声明式事务通过 AOP 的思想能够有效的将事务和业务逻辑代码解耦，因此在实际开发中，声明式事务得到了广泛的应用，而编程式事务则较少使用，考虑到文章内容的完整，本文对两种事务方式都会介绍。</p><h3 id="2-2-三大基础设施"><a href="#2-2-三大基础设施" class="headerlink" title="2.2 三大基础设施"></a>2.2 三大基础设施</h3><p>Spring 中对事务的支持提供了三大基础设施，我们先来了解下。</p><ol><li>PlatformTransactionManager</li><li>TransactionDefinition</li><li>TransactionStatus</li></ol><p>这三个核心类是 Spring 处理事务的核心类。</p><h4 id="2-2-1-PlatformTransactionManager"><a href="#2-2-1-PlatformTransactionManager" class="headerlink" title="2.2.1 PlatformTransactionManager"></a>2.2.1 PlatformTransactionManager</h4><p>PlatformTransactionManager 是事务处理的核心，它有诸多的实现类，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/3-1.png" alt></p><p>PlatformTransactionManager 的定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">TransactionStatus <span class="hljs-title">getTransaction</span><span class="hljs-params">(@Nullable TransactionDefinition definition)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>PlatformTransactionManager</code> 中定义了基本的事务操作方法，这些事务操作方法都是平台无关的，具体的实现都是由不同的子类来实现的。</p><p>这就像 JDBC 一样，SUN 公司制定标准，其他数据库厂商提供具体的实现。这么做的好处就是我们 Java 程序员只需要掌握好这套标准即可，不用去管接口的具体实现。以 <code>PlatformTransactionManager</code> 为例，它有众多实现，如果你使用的是 JDBC 那么可以将 <code>DataSourceTransactionManager</code> 作为事务管理器；如果你使用的是 Hibernate，那么可以将 <code>HibernateTransactionManager</code> 作为事务管理器；如果你使用的是 JPA，那么可以将 <code>JpaTransactionManager</code> 作为事务管理器。<code>DataSourceTransactionManager</code>、<code>HibernateTransactionManager</code> 以及 <code>JpaTransactionManager</code> 都是 <code>PlatformTransactionManager</code> 的具体实现，但是我们并不需要掌握这些具体实现类的用法，我们只需要掌握好 <code>PlatformTransactionManager</code> 的用法即可。</p><p><code>PlatformTransactionManager</code> 中主要有如下三个方法：</p><p><strong>1.getTransaction()</strong></p><p>getTransaction() 是根据传入的 TransactionDefinition 获取一个事务对象，TransactionDefinition 中定义了一些事务的基本规则，例如传播性、隔离级别等。</p><p><strong>2.commit()</strong></p><p>commit() 方法用来提交事务。</p><p><strong>3.rollback()</strong></p><p>rollback() 方法用来回滚事务。</p><h4 id="2-2-2-TransactionDefinition"><a href="#2-2-2-TransactionDefinition" class="headerlink" title="2.2.2 TransactionDefinition"></a>2.2.2 TransactionDefinition</h4><p><code>TransactionDefinition</code> 用来描述事务的具体规则，也称作事务的属性。事务有哪些属性呢？看下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211012204524.png" alt></p><p>可以看到，主要是五种属性：</p><ol><li>隔离性</li><li>传播性</li><li>回滚规则</li><li>超时时间</li><li>是否只读</li></ol><p>这五种属性接下来松哥会和大家详细介绍。</p><p><code>TransactionDefinition</code> 类中的方法如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/3-3.png" alt></p><p>可以看到一共有五个方法：</p><ol><li>getIsolationLevel()，获取事务的隔离级别</li><li>getName()，获取事务的名称</li><li>getPropagationBehavior()，获取事务的传播性</li><li>getTimeout()，获取事务的超时时间</li><li>isReadOnly()，获取事务是否是只读事务</li></ol><p>TransactionDefinition 也有诸多的实现类，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/3-4.png" alt></p><p>如果开发者使用了编程式事务的话，直接使用 <code>DefaultTransactionDefinition</code> 即可。</p><h4 id="2-2-3-TransactionStatus"><a href="#2-2-3-TransactionStatus" class="headerlink" title="2.2.3 TransactionStatus"></a>2.2.3 TransactionStatus</h4><p>TransactionStatus 可以直接理解为事务本身，该接口源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TransactionStatus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SavepointManager</span>, <span class="hljs-title">Flushable</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isNewTransaction</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasSavepoint</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setRollbackOnly</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRollbackOnly</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCompleted</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>isNewTransaction() 方法获取当前事务是否是一个新事务。</li><li>hasSavepoint() 方法判断是否存在 savePoint()。</li><li>setRollbackOnly() 方法设置事务必须回滚。</li><li>isRollbackOnly() 方法获取事务只能回滚。</li><li>flush() 方法将底层会话中的修改刷新到数据库，一般用于 Hibernate/JPA 的会话，对如 JDBC 类型的事务无任何影响。</li><li>isCompleted() 方法用来获取是一个事务是否结束。</li></ol><p><strong>这就是 Spring 中支持事务的三大基础设施。</strong></p><h2 id="3-编程式事务"><a href="#3-编程式事务" class="headerlink" title="3. 编程式事务"></a>3. 编程式事务</h2><p>我们先来看看编程式事务怎么玩。</p><p>通过 PlatformTransactionManager 或者 TransactionTemplate 可以实现编程式事务。如果是在 Spring Boot 项目中，这两个对象 Spring Boot 会自动提供，我们直接使用即可。但是如果是在传统的 SSM 项目中，则需要我们通过配置来提供这两个对象，松哥给一个简单的配置参考，如下（简单起见，数据库操作我们使用 JdbcTemplate）：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql:///spring_tran?serverTimezone=Asia/Shanghai"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.transaction.support.TransactionTemplate"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.core.JdbcTemplate"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了这两个对象，接下来的代码就简单了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    PlatformTransactionManager txManager;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DefaultTransactionDefinition definition = <span class="hljs-keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">        TransactionStatus status = txManager.getTransaction(definition);</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            jdbcTemplate.update(<span class="hljs-string">"update user set account=account+100 where username='zhangsan'"</span>);</span><br><span class="line">            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">            jdbcTemplate.update(<span class="hljs-string">"update user set account=account-100 where username='lisi'"</span>);</span><br><span class="line">            txManager.commit(status);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            txManager.rollback(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，没啥好解释的，在 <code>try...catch...</code> 中进行业务操作，没问题就 commit，有问题就 rollback。如果我们需要配置事务的隔离性、传播性等，可以在 DefaultTransactionDefinition 对象中进行配置。</p><p>上面的代码是通过 PlatformTransactionManager 实现的编程式事务，我们也可以通过 TransactionTemplate 来实现编程式事务，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TransactionTemplate tranTemplate;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        tranTemplate.execute(<span class="hljs-keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInTransactionWithoutResult</span><span class="hljs-params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    jdbcTemplate.update(<span class="hljs-string">"update user set account=account+100 where username='zhangsan'"</span>);</span><br><span class="line">                    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">                    jdbcTemplate.update(<span class="hljs-string">"update user set account=account-100 where username='lisi'"</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接注入 TransactionTemplate，然后在 execute 方法中添加回调写核心的业务即可，当抛出异常时，将当前事务标注为只能回滚即可。注意，execute 方法中，如果不需要获取事务执行的结果，则直接使用 TransactionCallbackWithoutResult 类即可，如果要获取事务执行结果，则使用 TransactionCallback 即可。</p><p>这就是两种编程式事务的玩法。</p><p>编程式事务由于代码入侵太严重了，因为在实际开发中使用的很少，我们在项目中更多的是使用声明式事务。</p><h2 id="4-声明式事务"><a href="#4-声明式事务" class="headerlink" title="4. 声明式事务"></a>4. 声明式事务</h2><p>声明式事务如果使用 <code>XML</code> 配置，可以做到无侵入；如果使用 <code>Java</code> 配置，也只有一个 <code>@Transactional</code> 注解侵入而已，相对来说非常容易。</p><p><strong>以下配置针对传统 SSM 项目（因为在 Spring Boot 项目中，事务相关的组件已经配置好了）：</strong></p><h3 id="4-1-XML-配置"><a href="#4-1-XML-配置" class="headerlink" title="4.1 XML 配置"></a>4.1 XML 配置</h3><p>XML 配置声明式事务大致上可以分为三个步骤，如下：</p><ol><li>配置事务管理器</li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql:///spring_tran?serverTimezone=Asia/Shanghai"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置事务通知</li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m4"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置 AOP</li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pc1"</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* org.javaboy.demo.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"pc1"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步和第三步中定义出来的方法交集，就是我们要添加事务的方法。</p><p>配置完成后，如下一些方法就自动具备事务了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update user set money=997 where username=?"</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Java-配置"><a href="#4-2-Java-配置" class="headerlink" title="4.2 Java 配置"></a>4.2 Java 配置</h3><p>我们也可以使用 Java 配置来实现声明式事务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-comment">//开启事务注解支持</span></span><br><span class="line"><span class="hljs-meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DriverManagerDataSource ds = <span class="hljs-keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setPassword(<span class="hljs-string">"123"</span>);</span><br><span class="line">        ds.setUsername(<span class="hljs-string">"root"</span>);</span><br><span class="line">        ds.setUrl(<span class="hljs-string">"jdbc:mysql:///test01?serverTimezone=Asia/Shanghai"</span>);</span><br><span class="line">        ds.setDriverClassName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要配置的东西其实和 XML 中配置的都差不多，最最关键的就两个：</p><ul><li>事务管理器 PlatformTransactionManager。</li><li>@EnableTransactionManagement 注解开启事务支持。</li></ul><p>配置完成后，接下来，哪个方法需要事务就在哪个方法上添加 <code>@Transactional</code> 注解即可，向下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(noRollbackFor = ArithmeticException.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update4</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">998</span>, <span class="hljs-string">"lisi"</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个稍微有点代码入侵，不过问题不大，日常开发中这种方式使用较多。当<code>@Transactional</code> 注解加在类上面的时候，表示该类的所有方法都有事务，该注解加在方法上面的时候，表示该方法有事务。</p><h3 id="4-3-混合配置"><a href="#4-3-混合配置" class="headerlink" title="4.3 混合配置"></a>4.3 混合配置</h3><p>也可以 Java 代码和 XML 混合配置来实现声明式事务，就是一部分配置用 XML 来实现，一部分配置用 Java 代码来实现：</p><p>假设 XML 配置如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">&lt;!--</span></span><br><span class="line"><span class="hljs-comment">    开启事务的注解配置，添加了这个配置，就可以直接在代码中通过 @Transactional 注解来开启事务了</span></span><br><span class="line"><span class="hljs-comment">    --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么 Java 代码中的配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-meta">@ImportResource</span>(locations = <span class="hljs-string">"classpath:applicationContext3.xml"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DriverManagerDataSource ds = <span class="hljs-keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setPassword(<span class="hljs-string">"123"</span>);</span><br><span class="line">        ds.setUsername(<span class="hljs-string">"root"</span>);</span><br><span class="line">        ds.setUrl(<span class="hljs-string">"jdbc:mysql:///test01?serverTimezone=Asia/Shanghai"</span>);</span><br><span class="line">        ds.setDriverClassName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 配置中通过 @ImportResource 注解导入了 XML 配置，XML 配置中的内容就是开启 <code>@Transactional</code> 注解的支持，所以 Java 配置中省略了 @EnableTransactionManagement 注解。</p><p>这就是声明式事务的几种配置方式。好玩吧！</p><h2 id="5-事务属性"><a href="#5-事务属性" class="headerlink" title="5. 事务属性"></a>5. 事务属性</h2><p>在前面的配置中，我们只是简单说了事务的用法，并没有和大家详细聊一聊事务的一些属性细节，那么接下来我们就来仔细捋一捋事务中的五大属性。</p><h3 id="5-1-隔离性"><a href="#5-1-隔离性" class="headerlink" title="5.1 隔离性"></a>5.1 隔离性</h3><p>首先就是事务的隔离性，也就是事务的隔离级别。</p><p>MySQL 中有四种不同的隔离级别，这四种不同的隔离级别在 Spring 中都得到了很好的支持。Spring 中默认的事务隔离级别是 default，即数据库本身的隔离级别是啥就是啥，default 就能满足我们日常开发中的大部分场景。</p><p>不过如果项目有需要，我们也可以调整事务的隔离级别。</p><p>调整方式如下：</p><h4 id="5-1-1-编程式事务隔离级别"><a href="#5-1-1-编程式事务隔离级别" class="headerlink" title="5.1.1 编程式事务隔离级别"></a>5.1.1 编程式事务隔离级别</h4><p>如果是编程式事务，通过如下方式修改事务的隔离级别：</p><p><strong>TransactionTemplate</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br></pre></td></tr></table></figure><p>TransactionDefinition 中定义了各种隔离级别。</p><p><strong>PlatformTransactionManager</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//创建事务的默认配置</span></span><br><span class="line">    DefaultTransactionDefinition definition = <span class="hljs-keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">    definition.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line">    TransactionStatus status = platformTransactionManager.getTransaction(definition);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">999</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-comment">//提交事务</span></span><br><span class="line">        platformTransactionManager.commit(status);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        <span class="hljs-comment">//回滚</span></span><br><span class="line">        platformTransactionManager.rollback(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是在 DefaultTransactionDefinition 对象中设置事务的隔离级别。</p><h4 id="5-1-2-声明式事务隔离级别"><a href="#5-1-2-声明式事务隔离级别" class="headerlink" title="5.1.2 声明式事务隔离级别"></a>5.1.2 声明式事务隔离级别</h4><p>如果是声明式事务通过如下方式修改隔离级别：</p><p>XML：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-comment">&lt;!--以 add 开始的方法，添加事务--&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add*"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"insert*"</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">"SERIALIZABLE"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(isolation = Isolation.SERIALIZABLE)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update4</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">998</span>, <span class="hljs-string">"lisi"</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于事务的隔离级别，如果大家还不熟悉，可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/eTbWDz8NiM8L8BbIrNiLHQ" target="_blank" rel="noopener">四个案例看懂 MySQL 事务隔离级别</a>。</p><h3 id="5-2-传播性"><a href="#5-2-传播性" class="headerlink" title="5.2 传播性"></a>5.2 传播性</h3><p>先来说说何谓事务的传播性：</p><blockquote><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题，当一个事务方法被另一个事务方法调用时，事务该以何种状态存在？例如新方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行，等等，这些规则就涉及到事务的传播性。</p></blockquote><p>关于事务的传播性，Spring 主要定义了如下几种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Propagation &#123;</span><br><span class="line">REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line">SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line">MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line">NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line">NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line">NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;</span><br><span class="line">Propagation(<span class="hljs-keyword">int</span> value) &#123; <span class="hljs-keyword">this</span>.value = value; &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体含义如下：</p><table><thead><tr><th style="text-align:left">传播性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">REQUIRED</td><td style="text-align:left">如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</td></tr><tr><td style="text-align:left">SUPPORTS</td><td style="text-align:left">如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</td></tr><tr><td style="text-align:left">MANDATORY</td><td style="text-align:left">如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</td></tr><tr><td style="text-align:left">REQUIRES_NEW</td><td style="text-align:left">创建一个新的事务，如果当前存在事务，则把当前事务挂起</td></tr><tr><td style="text-align:left">NOT_SUPPORTED</td><td style="text-align:left">以非事务方式运行，如果当前存在事务，则把当前事务挂起</td></tr><tr><td style="text-align:left">NEVER</td><td style="text-align:left">以非事务方式运行，如果当前存在事务，则抛出异常</td></tr><tr><td style="text-align:left">NESTED</td><td style="text-align:left">如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED</td></tr></tbody></table><p>一共是七种传播性，具体配置也简单：</p><p><strong>TransactionTemplate中的配置</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br></pre></td></tr></table></figure><p><strong>PlatformTransactionManager中的配置</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//创建事务的默认配置</span></span><br><span class="line">    DefaultTransactionDefinition definition = <span class="hljs-keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">    definition.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line">    definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">    TransactionStatus status = platformTransactionManager.getTransaction(definition);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">999</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-comment">//提交事务</span></span><br><span class="line">        platformTransactionManager.commit(status);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        <span class="hljs-comment">//回滚</span></span><br><span class="line">        platformTransactionManager.rollback(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明式事务的配置（XML）</strong></p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-comment">&lt;!--以 add 开始的方法，添加事务--&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add*"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"insert*"</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">"SERIALIZABLE"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>声明式事务的配置（Java）</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(noRollbackFor = ArithmeticException.class,propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update4</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">998</span>, <span class="hljs-string">"lisi"</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用就是这么来用，至于七种传播的具体含义，松哥来和大家一个一个说。</p><h4 id="5-2-1-REQUIRED"><a href="#5-2-1-REQUIRED" class="headerlink" title="5.2.1 REQUIRED"></a>5.2.1 REQUIRED</h4><p>REQUIRED 表示如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p>例如我有如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="hljs-meta">@Transactional</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update user set money = ? where id=?;"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountService2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AccountService accountService;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update user set money = ? where username=?;"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">        accountService.handle1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在 handle2 方法中调用 handle1。</p><p>那么：</p><ol><li>如果 handle2 方法本身是有事务的，则 handle1 方法就会加入到 handle2 方法所在的事务中，这样两个方法将处于同一个事务中，一起成功或者一起失败（不管是 handle2 还是 handle1 谁抛异常，都会导致整体回滚）。</li><li>如果 handle2 方法本身是没有事务的，则 handle1 方法就会自己开启一个新的事务，自己玩。</li></ol><p>举一个简单的例子：handle2 方法有事务，handle1 方法也有事务（小伙伴们根据前面的讲解自行配置事务），项目打印出来的事务日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.spring_tran02.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@875256468 wrapping com.mysql.cj.jdbc.ConnectionImpl@9753d50] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@875256468 wrapping com.mysql.cj.jdbc.ConnectionImpl@9753d50] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Participating in existing transaction</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@875256468 wrapping com.mysql.cj.jdbc.ConnectionImpl@9753d50]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@875256468 wrapping com.mysql.cj.jdbc.ConnectionImpl@9753d50] after transaction</span><br></pre></td></tr></table></figure><p>从日志中可以看到，前前后后一共就开启了一个事务，日志中有这么一句：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Participating in existing transaction</span><br></pre></td></tr></table></figure><p>这个就说明 handle1 方法没有自己开启事务，而是加入到 handle2 方法的事务中了。</p><h4 id="5-2-2-REQUIRES-NEW"><a href="#5-2-2-REQUIRES-NEW" class="headerlink" title="5.2.2 REQUIRES_NEW"></a>5.2.2 REQUIRES_NEW</h4><p>REQUIRES_NEW 表示创建一个新的事务，如果当前存在事务，则把<strong>当前事务挂起</strong>。换言之，不管外部方法是否有事务，REQUIRES_NEW 都会开启自己的事务。</p><p>这块松哥要多说两句，有的小伙伴可能觉得 REQUIRES_NEW 和 REQUIRED 太像了，似乎没啥区别。其实你要是单纯看最终回滚效果，可能确实看不到啥区别。但是，大家注意松哥上面的加粗，在 REQUIRES_NEW 中可能会同时存在两个事务，外部方法的事务被挂起，内部方法的事务独自运行，而在 REQUIRED 中则不会出现这种情况，如果内外部方法传播性都是 REQUIRED，那么最终也只是一个事务。</p><p>还是上面那个例子，假设 handle1 和 handle2 方法都有事务，handle2 方法的事务传播性是 REQUIRED，而 handle1 方法的事务传播性是 REQUIRES_NEW，那么最终打印出来的事务日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.spring_tran02.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@422278016 wrapping com.mysql.cj.jdbc.ConnectionImpl@732405c2] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@422278016 wrapping com.mysql.cj.jdbc.ConnectionImpl@732405c2] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Suspending current transaction, creating new transaction with name [org.javaboy.spring_tran02.AccountService.handle1]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@247691344 wrapping com.mysql.cj.jdbc.ConnectionImpl@14ad4b95] for JDBC transaction</span><br><span class="line">com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@14ad4b95</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@247691344 wrapping com.mysql.cj.jdbc.ConnectionImpl@14ad4b95] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@247691344 wrapping com.mysql.cj.jdbc.ConnectionImpl@14ad4b95]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@247691344 wrapping com.mysql.cj.jdbc.ConnectionImpl@14ad4b95] after transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Resuming suspended transaction after completion of inner transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@422278016 wrapping com.mysql.cj.jdbc.ConnectionImpl@732405c2]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@422278016 wrapping com.mysql.cj.jdbc.ConnectionImpl@732405c2] after transaction</span><br></pre></td></tr></table></figure><p>分析这段日志我们可以看到：</p><ol><li>首先为 handle2 方法开启了一个事务。</li><li>执行完 handle2 方法的 SQL 之后，事务被刮起（Suspending）。</li><li>为 handle1 方法开启了一个新的事务。</li><li>执行 handle1 方法的 SQL。</li><li>提交 handle1 方法的事务。</li><li>恢复被挂起的事务（Resuming）。</li><li>提交 handle2 方法的事务。</li></ol><p>从这段日志中大家可以非常明确的看到 REQUIRES_NEW 和 REQUIRED 的区别。</p><p>松哥再来简单总结下(假设 handle1 方法的事务传播性是 REQUIRES_NEW)：</p><ol><li>如果 handle2 方法没有事务，handle1 方法自己开启一个事务自己玩。</li><li>如果 handle2 方法有事务，handle1 方法还是会开启一个事务。此时，如果 handle2 发生了异常进行回滚，并不会导致 handle1 方法回滚，因为 handle1 方法是独立的事务；如果 handle1 方法发生了异常导致回滚，并且 handle1 方法的异常没有被捕获处理传到了 handle2 方法中，那么也会导致 handle2 方法回滚。</li></ol><blockquote><p>这个地方小伙伴们要稍微注意一下，我们测试的时候，由于是两个更新 SQL，如果更新的查询字段不是索引字段，那么 InnoDB 将使用表锁，这样就会发生死锁（handle2 方法执行时开启表锁，导致 handle1 方法陷入等待中，而必须 handle1 方法执行完，handle2 才能释放锁）。所以，在上面的测试中，我们要将 username 字段设置为索引字段，这样默认就使用行锁了。</p></blockquote><h4 id="5-2-3-NESTED"><a href="#5-2-3-NESTED" class="headerlink" title="5.2.3 NESTED"></a>5.2.3 NESTED</h4><p>NESTED 表示如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 NESTED，那么最终执行的事务日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.demo.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@2025689131 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ed3628e] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@2025689131 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ed3628e] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating nested transaction with name [org.javaboy.demo.AccountService.handle1]</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing transaction savepoint</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@2025689131 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ed3628e]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@2025689131 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ed3628e] after transaction</span><br></pre></td></tr></table></figure><p>关键一句在 <code>Creating nested transaction</code>。</p><p>此时，NESTED 修饰的内部方法（handle1）属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务（需要处理掉内部子事务的异常）。</p><h4 id="5-2-4-MANDATORY"><a href="#5-2-4-MANDATORY" class="headerlink" title="5.2.4 MANDATORY"></a>5.2.4 MANDATORY</h4><p>MANDATORY 表示如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p><p>这个好理解，我举两个例子：</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 MANDATORY，那么最终执行的事务日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.demo.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@768820610 wrapping com.mysql.cj.jdbc.ConnectionImpl@14840df2] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@768820610 wrapping com.mysql.cj.jdbc.ConnectionImpl@14840df2] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Participating in existing transaction</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@768820610 wrapping com.mysql.cj.jdbc.ConnectionImpl@14840df2]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@768820610 wrapping com.mysql.cj.jdbc.ConnectionImpl@14840df2] after transaction</span><br></pre></td></tr></table></figure><p>从这段日志可以看出：</p><ol><li>首先给 handle2 方法开启事务。</li><li>执行 handle2 方法的 SQL。</li><li>handle1 方法加入到已经存在的事务中。</li><li>执行 handle1 方法的 SQL。</li><li>提交事务。</li></ol><p>假设 handle2 方法无事务，handle1 方法有事务且传播性为 MANDATORY，那么最终执行时会抛出如下异常：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No existing transaction found for transaction marked with propagation &apos;mandatory&apos;</span><br></pre></td></tr></table></figure><p>由于没有已经存在的事务，所以出错了。</p><h4 id="5-2-5-SUPPORTS"><a href="#5-2-5-SUPPORTS" class="headerlink" title="5.2.5 SUPPORTS"></a>5.2.5 SUPPORTS</h4><p>SUPPORTS 表示如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p><p>这个也简单，举两个例子大家就明白了。</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 SUPPORTS，那么最终事务执行日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.demo.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@1780573324 wrapping com.mysql.cj.jdbc.ConnectionImpl@44eafcbc] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@1780573324 wrapping com.mysql.cj.jdbc.ConnectionImpl@44eafcbc] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Participating in existing transaction</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@1780573324 wrapping com.mysql.cj.jdbc.ConnectionImpl@44eafcbc]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@1780573324 wrapping com.mysql.cj.jdbc.ConnectionImpl@44eafcbc] after transaction</span><br></pre></td></tr></table></figure><p>这段日志很简单，没啥好说的，认准 <code>Participating in existing transaction</code> 表示加入到已经存在的事务中即可。</p><p>假设 handle2 方法无事务，handle1 方法有事务且传播性为 SUPPORTS，这个最终就不会开启事务了，也没有相关日志。</p><h4 id="5-2-6-NOT-SUPPORTED"><a href="#5-2-6-NOT-SUPPORTED" class="headerlink" title="5.2.6 NOT_SUPPORTED"></a>5.2.6 NOT_SUPPORTED</h4><p>NOT_SUPPORTED 表示以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 NOT_SUPPORTED，那么最终事务执行日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.demo.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@1365886554 wrapping com.mysql.cj.jdbc.ConnectionImpl@3198938b] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@1365886554 wrapping com.mysql.cj.jdbc.ConnectionImpl@3198938b] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Suspending current transaction</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.datasource.DataSourceUtils      : Fetching JDBC Connection from DataSource</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Resuming suspended transaction after completion of inner transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@1365886554 wrapping com.mysql.cj.jdbc.ConnectionImpl@3198938b]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@1365886554 wrapping com.mysql.cj.jdbc.ConnectionImpl@3198938b] after transaction</span><br></pre></td></tr></table></figure><p>这段日志大家认准这两句就行了 ： <code>Suspending current transaction</code> 表示挂起当前事务；<code>Resuming suspended transaction</code> 表示恢复挂起的事务。 </p><h4 id="5-2-7-NEVER"><a href="#5-2-7-NEVER" class="headerlink" title="5.2.7 NEVER"></a>5.2.7 NEVER</h4><p>NEVER 表示以非事务方式运行，如果当前存在事务，则抛出异常。</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 NEVER，那么最终会抛出如下异常：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Existing transaction found for transaction marked with propagation &apos;never&apos;</span><br></pre></td></tr></table></figure><h3 id="5-3-回滚规则"><a href="#5-3-回滚规则" class="headerlink" title="5.3 回滚规则"></a>5.3 回滚规则</h3><p>默认情况下，事务只有遇到运行期异常（RuntimeException 的子类）以及 Error 时才会回滚，在遇到检查型（Checked Exception）异常时不会回滚。</p><p>像 1/0，空指针这些是 RuntimeException，而 IOException 则算是 Checked Exception，换言之，默认情况下，如果发生 IOException 并不会导致事务回滚。</p><p>如果我们希望发生 IOException 时也能触发事务回滚，那么可以按照如下方式配置：</p><p>Java 配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(rollbackFor = IOException.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update user set money = ? where username=?;"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">    accountService.handle1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">"java.io.IOException"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，我们也可以指定在发生某些异常时不回滚，例如当系统抛出 ArithmeticException 异常并不要触发事务回滚，配置方式如下：</p><p>Java 配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(noRollbackFor = ArithmeticException.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update user set money = ? where username=?;"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">    accountService.handle1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span> <span class="hljs-attr">no-rollback-for</span>=<span class="hljs-string">"java.lang.ArithmeticException"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-是否只读"><a href="#5-4-是否只读" class="headerlink" title="5.4 是否只读"></a>5.4 是否只读</h3><p>只读事务一般设置在查询方法上，但不是所有的查询方法都需要只读事务，要看具体情况。</p><p>一般来说，如果这个业务方法只有一个查询 SQL，那么就没必要添加事务，强行添加最终效果适得其反。</p><p>但是如果一个业务方法中有多个查询 SQL，情况就不一样了：多个查询 SQL，默认情况下，每个查询 SQL 都会开启一个独立的事务，这样，如果有并发操作修改了数据，那么多个查询 SQL 就会查到不一样的数据。此时，如果我们开启事务，并设置为只读事务，那么多个查询 SQL 将被置于同一个事务中，多条相同的 SQL 在该事务中执行将会获取到相同的查询结果。</p><p>设置事务只读的方式如下：</p><p>Java 配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(readOnly = <span class="hljs-keyword">true</span>)</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-5-超时时间"><a href="#5-5-超时时间" class="headerlink" title="5.5 超时时间"></a>5.5 超时时间</h3><p>超时时间是说一个事务允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><p>事务超时时间配置方式如下(单位为秒)：</p><p>Java 配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(timeout = <span class="hljs-number">10</span>)</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>TransactionDefinition</code> 中以 int 的值来表示超时时间，其单位是秒，默认值为-1。</p><h2 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h2><ol><li>事务只能应用到 public 方法上才会有效。</li><li>事务需要从外部调用，<strong>Spring 自调事务用会失效</strong>。即相同类里边，A 方法没有事务，B 方法有事务，A 方法调用 B 方法，则 B 方法的事务会失效，这点尤其要注意，因为代理模式只拦截通过代理传入的外部方法调用，所以自调用事务是不生效的。</li><li>建议事务注解 @Transactional 一般添加在实现类上，而不要定义在接口上，如果加在接口类或接口方法上时，只有配置基于接口的代理这个注解才会生效。</li></ol><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p>好啦，这就是松哥和大家分享的 Spring 事务的玩法，不知道小伙伴们搞明白没有？配套视频已经录好，正在上传，敬请期待～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;事务的重要性不言而喻，Spring 对事务也提供了非常丰富的支持，各种支持的属性应有尽有。&lt;/p&gt;
&lt;p&gt;然而很多小伙伴知道，这里有两个属性特别绕：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离性&lt;/li&gt;
&lt;li&gt;传播性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Transaction" scheme="http://www.javaboy.org/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>16年后再逛游戏厅</title>
    <link href="http://www.javaboy.org/2021/1025/game.html"/>
    <id>http://www.javaboy.org/2021/1025/game.html</id>
    <published>2021-10-25T12:22:20.000Z</published>
    <updated>2021-11-03T12:36:36.982Z</updated>
    
    <content type="html"><![CDATA[<p>周天跟在深圳的大学同学一起吃了个饭，都是大学同班同学，说起来大学同班同学在深圳的还不少，每次吃饭都能凑一桌。</p><p>在壹方城吃完饭，时间尚早，有个做游戏开发的大佬提议去壹方城三楼的游戏厅玩一下，我好多年没进过这种地方了，于是就跟着去玩了下，反正有人请客。</p><a id="more"></a><p>可能因为是周日，里边人还蛮多的，大部分是年轻人，也有一些是家长带着小朋友来玩的，游戏厅里熙熙攘攘，一些热门的如开车的游戏稍微排一下队就能玩上，不用等太久。</p><p>我在里边转了几圈，实在没有特别想玩的，提不上兴趣，感觉可能过了玩游戏的年纪了，不过同行的小伙伴们兴致盎然，于是我也跟着玩了一个开车、骑摩托和保龄球的游戏，骑那个摩托的时候，旁边的一个小哥要和我 PK，两台设备自动 PK，我心里还有点发怵，毕竟一群人围着看，可不能丢人呀！结果那个小哥比我还菜，我顺利拿下第一，面子保住了。</p><p><img src="http://img.itboyhub.com//2020/04/vhr/796625582294316095.jpg" alt></p><p>不知道小伙伴们怎么看待游戏厅，虽然我去的时候里边人挺多的，但是可能跟大家不在一个频道，哪些游戏玩起来实在有点索然无味，没太大兴趣，我觉得我以后也不会花钱去玩。</p><p>特别是游戏厅的消费还蛮高的（可能是因为我比较穷吧），100 块钱 75 个币，一局基本上都是 4 个币或者 6 个币，100 块钱都玩不了二十局。从我进去就看到一个小男孩在玩骑摩托，十来岁的样子，摩托上还放着校服，一把完了就投币接着玩，一直到我走他都还在玩，我都惊呆了，这一个下午得花多少钱呀～我现在上班敲代码，赚的不算多也不算少，要让我花个 100 块钱在这里玩我都有点舍不得。</p><p>出来后我不禁回想起我玩游戏的历史。</p><p>小学的时候有一段时间特别痴迷。</p><p>当时我还上小学，我堂哥在镇上读初中，有一次他带了一个他同学的游戏机回来，像路由器那么大，插卡的，有两个游戏手柄，要接上电视机才能玩。我伯母不让他在家里玩，他就把家伙什带我家里玩了（我爸妈不在家），在我家那个黑白电视机上，我们俩玩了一下午的忍者神龟，天黑了还意犹未尽。临走了他看我似乎还想玩，就说把游戏机放我家里，他下周再来取，就这样我每天放学沉迷其中。</p><p>那个时候是真的喜欢玩，玩游戏能让人变得开心。</p><p>不过好景不长，没几天他就要把游戏机还给同学，我也只能恋恋不舍的游戏机还回去了，那个时候我就在想，要是能有一个游戏机让我一次玩个尽兴那该有多好。</p><p>上小学五年级的时候，我姨家有个 VCD 播放器，里边放上碟片，接上电视，插上两个手柄就能打游戏，我表弟天天玩，我看着就心痒痒的。但是我姨家离我家较远，我不能天天去，我姨说等我放暑假考完试把 VCD 播放器拿回家去玩，她可能随便说了下，结果我给当真了。那个暑假，当天考完试，去奶奶家里吃了饭，我就从村里走了一个多小时去我姨家，我姨一看到我就知道我干嘛来了，于是把 VCD 播放器连同手柄都装在一个袋子里就让我拎回去了，我几乎是一路飞奔着跑回家，去我姨家下坡路走了快一个小时，回来上坡路不到四十分钟就到家了。</p><p>有了游戏机，加上暑假的加持，天天在家里玩，魂斗罗、坦克大战、超级玛丽以及各种叫不上名字的游戏，玩了个遍。玩了两个礼拜吧，慢慢就意兴阑珊了，感觉不到玩游戏的乐趣了，再后来就把 VCD 播放器还回去了，心里也不再惦记着玩游戏了。</p><p>小学六年级的时候，镇上开始有了游戏厅（2005 年），五毛钱一个币，玩三国杀啥的。那个暑假我妈怕我在家里没人管，于是就给我在镇上报的课外辅导班，每天会给我几块钱的饭钱。结果我就被同学带去游戏厅了，五毛钱一个币，玩三国杀，结果我连游戏规则还没搞清楚就 0 血匆匆下线了。。。没有从游戏中获得成就感，玩了一两次就没去玩了，没意思，而且玩了游戏我就得饿肚子，不玩了。如果当年镇上的那种小店铺也算游戏厅的话，那我这次在深圳算是第二次进游戏厅了。</p><p>再后来读书工作，一直对游戏没啥兴趣，说出来不怕大家笑话，这么多年我最感兴趣的游戏是数独，但也就是偶尔玩一玩。我媳妇也不怎么玩游戏，只是后来拿了腾讯游戏的 offer，入职后要写一份游戏体验报告，才硬着头皮玩了几个游戏，但是游戏体验报告写完后就不玩了，没意思。</p><p>我之前看人说，这种单机的游戏很难上瘾，玩的差不多就不想玩了，我觉得有道理，至少在我身上确实是这样。但是网游会上瘾，可是我这卡出翔的千元安卓机玩不了网游，所以也就懒得去尝试。</p><p>玩游戏挺费时间的，有这时间敲两篇博客和大伙分享技术不香么。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周天跟在深圳的大学同学一起吃了个饭，都是大学同班同学，说起来大学同班同学在深圳的还不少，每次吃饭都能凑一桌。&lt;/p&gt;
&lt;p&gt;在壹方城吃完饭，时间尚早，有个做游戏开发的大佬提议去壹方城三楼的游戏厅玩一下，我好多年没进过这种地方了，于是就跟着去玩了下，反正有人请客。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>扯一把 Spring 的三种注入方式，到底哪种注入方式最佳？</title>
    <link href="http://www.javaboy.org/2021/1022/spring_3_injected.html"/>
    <id>http://www.javaboy.org/2021/1022/spring_3_injected.html</id>
    <published>2021-10-22T12:22:04.000Z</published>
    <updated>2021-11-03T12:36:31.959Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>循环依赖这个问题，按理说我们在日常的程序设计中应该避免，其实这个本来也是能够避免的。不过由于总总原因，我们可能还是会遇到一些循环依赖的问题，特别是在面试的过程中，面试考察循环依赖，主要是想考察候选人对 Spring 源码的熟悉程度，因为要把循环依赖这个问题解释清楚，涉及到不少 Spring 源码。</p><a id="more"></a><p>今天松哥抽空和大家简单聊聊这个话题，问题比较庞大，我可能花几篇文章来和大家分享下，今天先来聊聊实例的注入方式。</p><h2 id="1-实例的注入方式"><a href="#1-实例的注入方式" class="headerlink" title="1. 实例的注入方式"></a>1. 实例的注入方式</h2><p>首先来看看 Spring 中的实例该如何注入，总结起来，无非三种：</p><ul><li>属性注入</li><li>set 方法注入</li><li>构造方法注入</li></ul><p>我们分别来看下。</p><h3 id="1-1-属性注入"><a href="#1-1-属性注入" class="headerlink" title="1.1 属性注入"></a>1.1 属性注入</h3><p>属性注入是大家最为常见也是使用最多的一种注入方式了，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AService aService;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是使用 <code>@Autowired</code> 注解注入。另外也有 <code>@Resource</code> 以及 <code>@Inject</code> 等注解，都可以实现注入。</p><p>不过不知道小伙伴们有没有留意过，在 IDEA 里边，使用属性注入，会有一个警告⚠️：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211018195406.png" alt></p><p><strong>不推荐属性注入！</strong></p><p>原因我们后面讨论。</p><h3 id="1-2-set-方法注入"><a href="#1-2-set-方法注入" class="headerlink" title="1.2 set 方法注入"></a>1.2 set 方法注入</h3><p>set 方法注入太过于臃肿，实际上很少使用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BService</span> </span>&#123;</span><br><span class="line">    AService aService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setaService</span><span class="hljs-params">(AService aService)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.aService = aService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码看一眼都觉得难受，坚决不用。</p><h3 id="1-3-构造方法注入"><a href="#1-3-构造方法注入" class="headerlink" title="1.3 构造方法注入"></a>1.3 构造方法注入</h3><p>构造方法注入方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    BService bService;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AService</span><span class="hljs-params">(BService bService)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.bService = bService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类只有一个构造方法，那么 <code>@Autowired</code> 注解可以省略；如果类中有多个构造方法，那么需要添加上 <code>@Autowired</code> 来明确指定到底使用哪个构造方法。</p><h2 id="2-实例注入方式大-PK"><a href="#2-实例注入方式大-PK" class="headerlink" title="2. 实例注入方式大 PK"></a>2. 实例注入方式大 PK</h2><p>上面给大家列出来了三种注入方式，那么三种注入方式各自有何区别呢？</p><p>结合 Spring 官方文档，我们来分析下。</p><p>松哥翻出了 12 年前的 Spring3.0 的文档（<a href="https://docs.spring.io/spring-framework/docs/3.0.x/reference/beans.html），里边有如下一段话：" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/3.0.x/reference/beans.html），里边有如下一段话：</a></p><p><img src="http://img.itboyhub.com/2021/10/tran/20211018220058.png" alt></p><p>我来简单翻译下（意译）：</p><blockquote><p>使用构造方法注入还是使用 set 方法注入？<br>由于构造方法注入和 set 方法注入可以混合使用，因此，如果需要强制注入，我们可以使用构造方法注入的方式；如果是可选注入，则我们可以使用 set 方法注入的方式。当然，我们在 setter 上使用 @Required 注解可以让 set 方法注入也变为强制性注入。<br><strong>Spring 团队通常提倡 setter 注入，因为当属性特别多的时候，构造方法看起来会特别臃肿，特别是当属性是可选的时（属性可选意味着没必要通过构造方法注入）。Setter 方法注入还有一个好处就是可以使该类的属性可以在以后重新配置或重新注入。</strong><br>一些纯粹主义者喜欢基于构造函数的注入，这样意味着所有的属性都被初始化了，缺点则是对象变得不太适合重新配置和重新注入。<br>另外在一些特殊的场景下，如一个第三方类要注入到 Spring 容器，但是该类没有提供 set 方法，那么此时你就只能使用构造方法注入了。</p></blockquote><p>英文水平有限，大概翻译了下。小伙伴们重点看加粗部分，也就是说在 Spring3.0 时代，官方还是提倡 set 方法注入的。</p><p>不过从 Spring4.x 开始，官方就不推荐这种注入方式了，转而推荐构造器注入。</p><p>我们来看看 Spring4.x 的文档怎么说（<a href="https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#beans-setter-injection）：" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#beans-setter-injection）：</a></p><p><img src="http://img.itboyhub.com/2021/10/tran/20211018230657.png" alt></p><p>这段内容我就不一一翻译了，大家重点看第二段第一句：</p><p><strong>The Spring team generally advocates constructor injection</strong></p><p>这句话就是说 Spring 团队倡导通过构造方法完成注入。才一个大版本更新，Spring 咋就变了呢？别急，人家也给出用构造方法注入的理由，第二段翻译一下大概是这个意思：</p><p>通过构造方法注入的方式，能够保证注入的组件不可变，并且能够确保需要的依赖不为空。此外，构造方法注入的依赖总是能够在返回客户端（组件）代码的时候保证完全初始化的状态。</p><p>上面这段话主要说了三件事：</p><ol><li>依赖不可变：这个好理解，通过构造方法注入依赖，在对象创建的时候就要注入依赖，一旦对象创建成功，以后就只能使用注入的依赖而无法修改了，这就是依赖不可变（通过 set 方法注入将来还能通过 set 方法修改）。</li><li>依赖不为空：通过构造方法注入的时候，会自动检查注入的对象是否为空，如果为空，则注入失败；如果不为空，才会注入成功。</li><li>完全初始化：由于获取到了依赖对象（这个依赖对象是初始化之后的），并且调用了要初始化组件的构造方法，因此最终拿到的就是完全初始化的对象了。</li></ol><p>在 Spring3.0 文档中，官方说如果构造方法注入的话，属性太多可能会让代码变得非常臃肿，那么在 4.0 文档中，官方对这个说法也做了一些<strong>订正</strong>：如果用构造方法注入的时候，参数过多以至于代码过于臃肿，那么此时你需要考虑这个类的设计是否合理，这个类是否参杂了太多的其他无关功能，这个类是否做到了单一职责。</p><blockquote><p>好吧，你说的总是有理！</p></blockquote><p>这是构造方法注入和 set 方法注入的问题，那么上面我们还提到不推荐属性注入，这又是咋回事呢？</p><p>属性注入其实有一个显而易见的缺点，那就是对于 IOC 容器以外的环境，除了使用反射来提供它需要的依赖之外，无法复用该实现类。因为该类没有提供该属性的 set 方法或者相应的构造方法来完成该属性的初始化。换言之，要是使用属性注入，那么你这个类就只能在 IOC 容器中使用，要是想自己 new 一下这个类的对象，那么相关的依赖无法完成注入。</p><p>以上分析都是根据 Spring 官方文档得来，日常开发应该还是属性注入较多，这个咱们不必纠结，代码该咋写还咋写，Spring 官方的态度了解一下即可，当然，<strong>如果项目允许，也不妨试试 Spring 推荐的代码规范。</strong></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，今天就和小伙伴们随便扯扯 Spring 中的注入方式，因为我最近又要重新捡起 Spring 源码分析了，所以先来个简单的预热一下哈哈～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;循环依赖这个问题，按理说我们在日常的程序设计中应该避免，其实这个本来也是能够避免的。不过由于总总原因，我们可能还是会遇到一些循环依赖的问题，特别是在面试的过程中，面试考察循环依赖，主要是想考察候选人对 Spring 源码的熟悉程度，因为要把循环依赖这个问题解释清楚，涉及到不少 Spring 源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>周六蒸馒头，周日录视频，技术圈惊现美食博主</title>
    <link href="http://www.javaboy.org/2021/1021/mysql_isolation.html"/>
    <id>http://www.javaboy.org/2021/1021/mysql_isolation.html</id>
    <published>2021-10-21T12:21:47.000Z</published>
    <updated>2021-11-03T12:36:26.452Z</updated>
    
    <content type="html"><![CDATA[<p>前两周松哥一时兴起，整了一锅馒头，第一次尝试，效果还不错，虽然馒头的外观不大美观，但是味道还是杠杠滴：</p><ul><li><a href="https://mp.weixin.qq.com/s/3bx6fiTHY9nYr5WyiuGmaQ" target="_blank" rel="noopener">周六蒸馒头，周日录视频，技术圈惊现美食博主</a></li></ul><a id="more"></a><p>因为第一次蒸馒头比较顺利，所以上周我又尝试了一把，这次对馒头的外观进行了改进，看起来比第一次蒸的馒头好看多了，然而味道和第一次相比似乎查了一丢丢~</p><p>这一好一坏，让我想起来刚毕业时候在公司敲代码的情景~</p><p>long long ago，我还是一名安卓猿，当时移动互联网火热，公司也在积极开拓新业务，于是招了一帮应届生来敲 App。</p><p>大概是在头一年 10 月份左右，招了一帮实习生，据说当时没日没夜的搞了几个月，弄出来了 1.0 版，1.0 版上线后，最大的问题就是闪崩，这也是 Android 开发中较常见的问题，就是点着点着 App 就崩了，崩了就得去检查问题，找到问题后修复，本来没啥，问题在于闪崩的问题始终无法根治，总是有，可能是在修改 BUG 的过程中引发的新问题，也可能是在开发新功能的时候引出来的新问题，总之一直到第二年 6 月底我入职的时候，闪崩问题都还在。我入职的头一个月，就是解决各种各样的闪崩问题。</p><p>有一次我开发的一个自定义下拉刷新被一个同事不知道是有意还是无意改了一个像素参数，导致下拉列表顶部有一条非常细小的线，如果用户在下拉刷新时刚好按在了这条线上，就崩了。这个问题测试测了好久都没找到崩溃的具体原因，他们就是说你这个点着点着就崩溃，我说没有啊，他们当着我的面演示，也不能重现问题，好吧，这种不能稳定重现的 BUG 就先放着吧。。。直到有一天他们部门老大找来，这问题才到了非解决不可的地步，我自己研究，找规律，终于发现了问题所在，然后看 Svn 上的提交记录，知道是有人改了参数…</p><p>总之，当时我们一帮应届生，在一个有经验的大佬领导下（他不怎么参与安卓 Coding），鼓捣出来的这个 App 总是不太稳定。</p><p>不久之后，我们的直属领导，一个搞 C# 的大佬，被拉去开发一个新的桌面系统，因为公司人力有限，新的系统很长一段时间都是他一个人在搞。在一次项目汇报的会议中，他说了一句话令我印象深刻：“我这个系统目前功能完成了 60% 左右，目前没有任何莫名其妙/不可预见的崩溃，很稳定”。</p><p>大佬这话说出来，和我们几个应届生做出来的安卓 App 形成了鲜明对比，我当时就在心里想，这就是大佬。</p><p>多年后，当我再次回想起这件事，脑子里闪出一个词：<strong>“稳定输出”</strong>，这可能是大佬和新手的重要区别。</p><p>现在网络上的学习资料非常多，图书市场也非常繁荣，大部分情况下，我们需要的资料都能在网上/书上找到，面向搜索引擎编程，小白也能完成很多事情，这就给人一种错觉，年纪越大的程序员在逐步丧失竞争力。然而真的是这样吗！</p><p>新手往往需要在学习中写代码，这样的代码虽然也能实现功能，但是可能像下图这样：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20211029193101.png" alt></p><p>功能实现了，但是网上借鉴了很多不知道啥意思的代码，所以写好的代码不能动，一动程序就挂了。</p><p>而有经验的老手，他们的代码都是自己敲的，可以做到“稳定输出”，他们知道自己每一行代码的含义，出了问题能够快速定位到问题原因，知道怎么修改，这也是老手的价值之一。</p><p>我这里说的老手并非年长者，而是开发经验丰富的大佬，与年龄无关。我这里所说的开发也主要是指 Java 应用/企业级项目开发。</p><p>上周第二次蒸馒头就属于不能“稳定输出”，新手的通病，加强练习争取早日能够实现“稳定输出”。</p><p>无意冒犯任何人，以上纯属个人经验并非真理，轻喷。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两周松哥一时兴起，整了一锅馒头，第一次尝试，效果还不错，虽然馒头的外观不大美观，但是味道还是杠杠滴：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3bx6fiTHY9nYr5WyiuGmaQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;周六蒸馒头，周日录视频，技术圈惊现美食博主&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>松哥 B 站视频上新啦～</title>
    <link href="http://www.javaboy.org/2021/1019/scheduling_video.html"/>
    <id>http://www.javaboy.org/2021/1019/scheduling_video.html</id>
    <published>2021-10-19T13:40:38.000Z</published>
    <updated>2021-10-20T14:12:41.333Z</updated>
    
    <content type="html"><![CDATA[<p>是的，终于更新啦～</p><p>这半年时间，松哥视频一直都在录，不过都是发在公众号上，基本上没有上传到 B 站。</p><a id="more"></a><p>可能由于手机屏幕较小且手机上看视频比较费流量，所以公众号上视频的播放量一直不怎么样，我也挺郁闷。</p><p>这里多说一句，公众号上看视频可以选择分辨率，有小伙伴反映手机上视频模糊，其实只要调一下分辨率即可，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211018191948.png" alt></p><p>视频右下角可以选择视频分辨率，选择<strong>超清</strong>即可。</p><p>之前视频一直没上传到 B 站是因为我这里上传 B 站太麻烦了。一来家里的网络上载带宽一直不达标，上传到 B 站非常耗时；二来因为我录的都是视频教程，一般都是好几集，在 B 站上传时候要分 P 上传，Mac 端没有对应的工具，只有 Windows 端有上传工具可以分 P 上传，而我录视频都是在 Mac 上录的，一想想要把视频分类整理拷贝到 Windows 上去，就感觉好麻烦，还是再攒攒吧，攒多了一起搞。</p><p>现在终于攒的差不多了，开始上传啦～</p><p>不过网络依然很慢，昨天传了一个下午，上传了三集，把 DIY 定时任务的视频教程上传完了。。。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211018192530.png" alt></p><p>这个教程一共三集，约 80 分钟左右，就是手把手带领大家敲一个可动态配置的定时任务管理系统，松哥之前也写过专门的文章介绍，如下：</p><ul><li><a href="https://mp.weixin.qq.com/s/skZ7uU7q1iH9QrV2EKiGOg" target="_blank" rel="noopener">Spring 定时任务玩出花！</a></li><li><a href="https://mp.weixin.qq.com/s/H3RrpnBYDNwgtSOMlt3Ihg" target="_blank" rel="noopener">刚出炉热腾腾的定时任务可视化管理系统</a></li></ul><p>感兴趣的小伙伴可以先去 B 站围观下：</p><ul><li><a href="https://www.bilibili.com/video/BV1Yq4y157PM" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yq4y157PM</a></li></ul><p>前段时间在连载的 Spring Security 最近也会慢慢上传到 B 站上了，另外这个周末我还抽空了录了一个 Spring 事务的视频，这些视频我今天就会开始上传，不过由于网络问题，上传好了这两天就会和小伙伴们见面啦～</p><p>点击阅读原文，直达 B 站。</p><p><a href="https://space.bilibili.com/49484631" target="_blank" rel="noopener">https://space.bilibili.com/49484631</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是的，终于更新啦～&lt;/p&gt;
&lt;p&gt;这半年时间，松哥视频一直都在录，不过都是发在公众号上，基本上没有上传到 B 站。&lt;/p&gt;
    
    </summary>
    
      <category term="视频教程" scheme="http://www.javaboy.org/categories/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="video" scheme="http://www.javaboy.org/tags/video/"/>
    
      <category term="视频" scheme="http://www.javaboy.org/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>松哥读者开发的这款 Chrome 插件，让你的项目联调 so easy！</title>
    <link href="http://www.javaboy.org/2021/1018/chrome.html"/>
    <id>http://www.javaboy.org/2021/1018/chrome.html</id>
    <published>2021-10-18T13:40:24.000Z</published>
    <updated>2021-10-20T14:12:29.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p><code>poseidon-chrome-proxy</code> 是一款浏览器请求代理插件；它能把向服务器发起的请求代理到本地，并且可以修改其请求头。</p><p>通过这个插件我们可以降低前后端联调的成本，以及帮助我们快速定位线上 bug。</p><a id="more"></a><p>插件作者：joyful 与 muggle，这个插件我们会长期维护下去，小伙伴们如果有想加进去的功能可以联系我们哟。</p><h2 id="插件使用说明"><a href="#插件使用说明" class="headerlink" title="插件使用说明"></a>插件使用说明</h2><p>插件下载地址：<a href="https://github.com/Poseidon-Service-Framework/poseidon-chrome-proxy/releases" target="_blank" rel="noopener">https://github.com/Poseidon-Service-Framework/poseidon-chrome-proxy/releases</a> </p><p><img src="http://img.itboyhub.com/2021/10/tran/插件下载.jpg" alt></p><p>目前最新版本是 <code>2.1.0-beta</code>，下载后解压并打开谷歌浏览器 <code>更多工具-&gt;扩展程序</code>：</p><p><img src="http://img.itboyhub.com/2021/10/tran/加载扩展程序1.jpg" alt></p><p>然后打开开发者模式选择解压的插件：</p><p><img src="http://img.itboyhub.com/2021/10/tran/加载扩展程序2.jpg" alt></p><p>插件安装好后，点击图标弹出配置页面，可以在该页面上配置我们的请求头信息与代理规则，配置使用的是 json 格式：</p><p><img src="http://img.itboyhub.com/2021/10/tran/插件pop.jpg" alt></p><p>点击右上角角的 <code>Json代码说明</code> 可以看到 json 中每个字段的含义，编辑完 json 后直接退出即可保存编辑内容。</p><p>点击最下方的<strong>停用/启用</strong>按钮，停用/启用代理功能；</p><h2 id="插件-json-内容说明"><a href="#插件-json-内容说明" class="headerlink" title="插件 json 内容说明"></a>插件 json 内容说明</h2><p>插件的 json 内容是一个数组，每个 json 代表一个代理规则，json 中字段说明</p><ul><li><code>domain</code>: 需要代理的域名，如 <code>www.javaboy.org</code></li><li><code>requestHeader</code>： 请求头设置数组， 请以 <code>name:value</code> 的形式填写请求头信息</li><li><code>matchingRules</code>：拦截规则数组。</li><li><code>route</code>：请求拦截前缀</li><li><code>targetUrl</code>：请求处理代理服务器的 <code>ip:端口</code></li></ul><p>配置示例：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="hljs-attr">"domain"</span>: <span class="hljs-string">"www.javaboy.org"</span>,</span><br><span class="line">    <span class="hljs-attr">"requestHeader"</span>: [<span class="hljs-string">"test:xxxxxxxxxx"</span>],</span><br><span class="line">    <span class="hljs-attr">"matchingRules"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="hljs-attr">"route"</span>: <span class="hljs-string">"/a/b"</span>,</span><br><span class="line">        <span class="hljs-attr">"targetUrl"</span>: <span class="hljs-string">"127.0.0.1:9020"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,  &#123;</span><br><span class="line">    <span class="hljs-attr">"domain"</span>: <span class="hljs-string">"xx.20yx.net"</span>,</span><br><span class="line">    <span class="hljs-attr">"requestHeader"</span>: [<span class="hljs-string">"test:8888"</span>],</span><br><span class="line">    <span class="hljs-attr">"matchingRules"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="hljs-attr">"route"</span>: <span class="hljs-string">"/"</span>,</span><br><span class="line">        <span class="hljs-attr">"targetUrl"</span>: <span class="hljs-string">"127.0.0.1:8080"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如上配置会将：</p><ol><li><code>https://www.javaboy.org/a/b/xxxx</code> 代理到 <code>127.0.0.1:9020/a/b/xxxx</code> 并携带请求头 <code>test:xxxxxxxxxx</code>。</li><li>将 <code>https://xxx.20yx.net/ss/ss</code> 代理到 <code>127.0.0.1:8080/ss/ss</code> 并携带请求头 <code>test:8888</code>。</li></ol><p>插件的原理可在项目的 readme 中查看。</p><h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p>插件注意事项：</p><ol><li>该插件和一些梯子冲突，如果你在使用梯子上网的时候请禁用该插件。</li><li><code>targetUrl</code> 只能填写 <code>ip:port</code>，形如 <code>127.0.0.1:8080/xxx</code> 这种是不会生效的；</li><li>部分代理的网址会失效，如 <code>www.baidu.com</code> 原因未知。</li></ol><p>特别鸣谢：</p><p>感谢 joyful 大佬参与开发，joyful 大佬是这个插件的主要开发，为本插件提供了很多想法并贡献了很多代码；joyful大佬的博客地址：<a href="https://blog.csdn.net/qq_42671576，感兴趣的可以关注哦。" target="_blank" rel="noopener">https://blog.csdn.net/qq_42671576，感兴趣的可以关注哦。</a></p><p>感谢参与插件测试的各位小伙伴。</p><p>如果小伙伴们对这个有好的想法，或者需要参与开发的请联系本人，撸码不易，感兴趣大佬给个star；求star 求star 求star ：<a href="https://github.com/Poseidon-Service-Framework/poseidon-chrome-proxy。" target="_blank" rel="noopener">https://github.com/Poseidon-Service-Framework/poseidon-chrome-proxy。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插件介绍&quot;&gt;&lt;a href=&quot;#插件介绍&quot; class=&quot;headerlink&quot; title=&quot;插件介绍&quot;&gt;&lt;/a&gt;插件介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;poseidon-chrome-proxy&lt;/code&gt; 是一款浏览器请求代理插件；它能把向服务器发起的请求代理到本地，并且可以修改其请求头。&lt;/p&gt;
&lt;p&gt;通过这个插件我们可以降低前后端联调的成本，以及帮助我们快速定位线上 bug。&lt;/p&gt;
    
    </summary>
    
      <category term="chrome" scheme="http://www.javaboy.org/categories/chrome/"/>
    
    
      <category term="Chrome" scheme="http://www.javaboy.org/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 还能做延迟队列？nice！</title>
    <link href="http://www.javaboy.org/2021/1015/rabbitmq_delay_queue.html"/>
    <id>http://www.javaboy.org/2021/1015/rabbitmq_delay_queue.html</id>
    <published>2021-10-15T13:40:06.000Z</published>
    <updated>2021-10-20T14:12:23.336Z</updated>
    
    <content type="html"><![CDATA[<p>在很多场景下，我们都有延迟队列的需求，然而默认情况下 RabbitMQ 并未提供延迟队列相关的功能，不过，在前面的文章中，松哥和大家分享了 RabbitMQ 中的死信队列，结合死信队列以及消息过期时间的设定，我们也可以实现延迟队列的功能，今天我们就一起来看下。</p><a id="more"></a><blockquote><p>RabbitMQ 其实有提供专门的延迟队列插件，这个咱们有空了再聊。</p></blockquote><p>如果大家还没看过前面的文章，可以先去瞅瞅，这有助于理解本文：</p><ul><li><a href="https://mp.weixin.qq.com/s/fFqzuN2AnLazoCyahL3EFw" target="_blank" rel="noopener">RabbitMQ 中的消息会过期吗？</a></li></ul><h2 id="1-什么时候需要延迟队列？"><a href="#1-什么时候需要延迟队列？" class="headerlink" title="1. 什么时候需要延迟队列？"></a>1. 什么时候需要延迟队列？</h2><p>先来说说什么时候我们需要延迟队列。</p><p>举几个简单的例子。</p><ul><li>在电商项目中，当我们下单之后，一般需要 20 分钟之内或者 30 分钟之内付款，否则订单就会进入异常处理逻辑中，被取消，那么进入到异常处理逻辑中，就可以当成是一个延迟队列。</li><li>我买了一个智能砂锅，可以用来煮粥，上班前把素材都放到锅里，然后设置几点几分开始煮粥，这样下班后就可以喝到香喷喷的粥了，那么这个煮粥的指令也可以看成是一个延迟任务，放到一个延迟队列中，时间到了再执行。</li><li>公司的会议预定系统，在会议预定成功后，会在会议开始前半小时通知所有预定该会议的用户。</li><li>安全工单超过 24 小时未处理，则自动拉企业微信群提醒相关责任人。</li><li>用户下单外卖以后，距离超时时间还有 10 分钟时提醒外卖小哥即将超时。</li><li>…</li></ul><p>很多场景下我们都需要延迟队列。</p><p>可能有小伙伴说至于嘛，直接搞个定时任务不更方便？如果项目中只有一个这样的延迟队列的场景，那么搞个定时任务似乎也可以，但是如果项目中有很多这样的场景，那么定时任务很明显就不是最佳方案了，我们可以通过延迟队列来实现一个通用的解决方案。</p><h2 id="2-延迟队列实现思路"><a href="#2-延迟队列实现思路" class="headerlink" title="2. 延迟队列实现思路"></a>2. 延迟队列实现思路</h2><p>延迟队列实现的思路也很简单，就是<a href="https://mp.weixin.qq.com/s/fFqzuN2AnLazoCyahL3EFw" target="_blank" rel="noopener">上篇文章</a>我们所说的 DLX（死信交换机）+TTL（消息超时时间）。</p><p>我们可以把死信队列就当成延迟队列。</p><p>具体来说是这样：</p><p><strong>假如一条消息需要延迟 30 分钟执行，我们就设置这条消息的有效期为 30 分钟，同时为这条消息配置死信交换机和死信 <code>routing_key</code>，并且不为这个消息队列设置消费者，那么 30 分钟后，这条消息由于没有被消费者消费而进入死信队列，此时我们有一个消费者就在“蹲点”这个死信队列，消息一进入死信队列，就立马被消费了。</strong></p><p>这就是延迟队列的实现思路，是不是很简单？</p><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><p>接下来松哥通过一个简单的案例，来和大家演示一下延迟队列的具体实现。</p><p>首先准备好一个启动的 RabbitMQ。</p><p>然后我们创建一个 Spring Boot 项目，引入 RabbitMQ 依赖：</p><p><img src="http://img.itboyhub.com/2021/07/20211010211954.png" alt></p><p>然后在 application.properties 中配置一下 RabbitMQ 的基本连接信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.port=5672</span><br></pre></td></tr></table></figure><p>接下来我们来配置两个消息队列：一个普通队列，一个死信队列：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_QUEUE_NAME = <span class="hljs-string">"javaboy_queue_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_EXCHANGE_NAME = <span class="hljs-string">"javaboy_exchange_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_ROUTING_KEY = <span class="hljs-string">"javaboy_routing_key"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_QUEUE_NAME = <span class="hljs-string">"dlx_queue_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_EXCHANGE_NAME = <span class="hljs-string">"dlx_exchange_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_ROUTING_KEY = <span class="hljs-string">"dlx_routing_key"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 死信队列</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Queue <span class="hljs-title">dlxQueue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DLX_QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 死信交换机</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DirectExchange <span class="hljs-title">dlxExchange</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DLX_EXCHANGE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 绑定死信队列和死信交换机</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Binding <span class="hljs-title">dlxBinding</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> BindingBuilder.bind(dlxQueue()).to(dlxExchange())</span><br><span class="line">                .with(DLX_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 普通消息队列</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Queue <span class="hljs-title">javaboyQueue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="hljs-comment">//设置消息过期时间</span></span><br><span class="line">        args.put(<span class="hljs-string">"x-message-ttl"</span>, <span class="hljs-number">1000</span>*<span class="hljs-number">10</span>);</span><br><span class="line">        <span class="hljs-comment">//设置死信交换机</span></span><br><span class="line">        args.put(<span class="hljs-string">"x-dead-letter-exchange"</span>, DLX_EXCHANGE_NAME);</span><br><span class="line">        <span class="hljs-comment">//设置死信 routing_key</span></span><br><span class="line">        args.put(<span class="hljs-string">"x-dead-letter-routing-key"</span>, DLX_ROUTING_KEY);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(JAVABOY_QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 普通交换机</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DirectExchange <span class="hljs-title">javaboyExchange</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(JAVABOY_EXCHANGE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 绑定普通队列和与之对应的交换机</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Binding <span class="hljs-title">javaboyBinding</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> BindingBuilder.bind(javaboyQueue())</span><br><span class="line">                .to(javaboyExchange())</span><br><span class="line">                .with(JAVABOY_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置代码虽然略长，不过原理其实简单。</p><ul><li>配置可以分为两组，第一组配置死信队列，第二组配置普通队列。每一组都由消息队列、消息交换机以及 Binding 三者组成。</li><li>配置消息队列时，为消息队列指定死信队列，不熟悉的小伙伴可以翻一下上篇文章，传送门：<a href="https://mp.weixin.qq.com/s/fFqzuN2AnLazoCyahL3EFw" target="_blank" rel="noopener">RabbitMQ 中的消息会过期吗？</a>。</li><li>配置队列中的消息过期时间时，默认的时间单位时毫秒。</li></ul><p>接下来我们为死信队列配置一个消费者，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DlxConsumer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(DlxConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@RabbitListener</span>(queues = QueueConfig.DLX_QUEUE_NAME)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到消息后就将之打印出来。</p><p>这就完事了。</p><p>启动项目。</p><p>最后我们在单元测试中发送一条消息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootTest</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayQueueApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        rabbitTemplate.convertAndSend(QueueConfig.JAVABOY_EXCHANGE_NAME, QueueConfig.JAVABOY_ROUTING_KEY, <span class="hljs-string">"hello javaboy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就没啥好说的了，就是普通的消息发送，10 秒之后这条消息会在死信队列的消费者中被打印出来。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，这就是我们用 RabbitMQ 做延迟队列的思路～</p><p>小伙伴们在公众号后台回复文章标题，可以下载本文案例～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多场景下，我们都有延迟队列的需求，然而默认情况下 RabbitMQ 并未提供延迟队列相关的功能，不过，在前面的文章中，松哥和大家分享了 RabbitMQ 中的死信队列，结合死信队列以及消息过期时间的设定，我们也可以实现延迟队列的功能，今天我们就一起来看下。&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
      <category term="延迟队列" scheme="http://www.javaboy.org/tags/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>闲扯Maven项目代码组织形式</title>
    <link href="http://www.javaboy.org/2021/1011/maven_code.html"/>
    <id>http://www.javaboy.org/2021/1011/maven_code.html</id>
    <published>2021-10-11T13:39:46.000Z</published>
    <updated>2021-10-20T14:13:17.843Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>因为最近有小伙伴问到了，所以我想和大家随便扯扯 Maven 项目中代码的组织形式这个问题。</p><p>其实也不是啥大问题，但是如果不懂的话，就像雾里看花，始终不能看的明明白白，懂了就像一层窗户纸，捅破就好了。</p><a id="more"></a><p>所以我们就简单扯几句。</p><h2 id="1-代码组织形式"><a href="#1-代码组织形式" class="headerlink" title="1. 代码组织形式"></a>1. 代码组织形式</h2><p>首先来说说代码组织形式。</p><p>一般来说，就两种比较常见的形式：</p><ul><li>平铺</li><li>父子结构</li></ul><p>这两种形式松哥在不同的项目中都有遇到过，所以我们就不说孰优孰劣，单纯来说这两种方案。</p><h3 id="1-1-平铺"><a href="#1-1-平铺" class="headerlink" title="1.1 平铺"></a>1.1 平铺</h3><p>平铺的代码类似下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── parent</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   └── resources</span><br><span class="line">│       └── test</span><br><span class="line">│           └── java</span><br><span class="line">├── vhr-dao</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   │   ├── main</span><br><span class="line">│   │   │   ├── java</span><br><span class="line">│   │   │   └── resources</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       └── java</span><br><span class="line">└── vhr-service</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    ├── src</span><br><span class="line">    │   ├── main</span><br><span class="line">    │   │   ├── java</span><br><span class="line">    │   │   └── resources</span><br><span class="line">    │   └── test</span><br><span class="line">    │       └── java</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20211009194907.png" alt></p><p>可以看到，在这种结构下，parent 父工程和各个子工程从代码组织形式上来看都是平级的，都处于同一个目录下。</p><p>不过仔细查看 pom.xml 文件，还是能够清晰的看到这三个 module 的父子关系的：</p><p>parent：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可以看到，在指定 module 时，由于 vhr-dao 和 vhr-service 和 parent 的 pom.xml 不在同一个目录下，所以这里使用了相对路径，相对路径的参考依据是 parent 的 pom.xml 文件位置。</strong></p><p>vhr-dao：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可以看到，relativePath 节点中，通过相对路径指定了 parent 的 pom.xml 文件位置，这个相对路径的参考依据是子模块的 pom.xml 文件。</strong></p><p>vhr-service：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个和 vhr-dao 的差不多，不赘述。</p><h3 id="1-2-父子结构"><a href="#1-2-父子结构" class="headerlink" title="1.2 父子结构"></a>1.2 父子结构</h3><p>父子结构则类似于下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── maven_parent</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── vhr-dao</span><br><span class="line">│   │   ├── pom.xml</span><br><span class="line">│   │   └── src</span><br><span class="line">│   │       ├── main</span><br><span class="line">│   │       │   ├── java</span><br><span class="line">│   │       │   └── resources</span><br><span class="line">│   │       └── test</span><br><span class="line">│   │           └── java</span><br><span class="line">│   └── vhr-service</span><br><span class="line">│       ├── pom.xml</span><br><span class="line">│       └── src</span><br><span class="line">│           ├── main</span><br><span class="line">│           │   ├── java</span><br><span class="line">│           │   └── resources</span><br><span class="line">│           └── test</span><br><span class="line">│               └── java</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20211009200853.png" alt></p><p>这种父子结构的看起来就非常的层次分明了，parent 和各个 module 一眼就能看出来，我们从 GitHub 上下载的很多开源项目如 Shiro，都是这种结构。</p><p>不过文件夹的层级并不能说明任何问题，关键还是要看 pom.xml 中的定义，接下来我们就来看看 parent 的 pom.xml 和各个子模块的 pom.xml 有何异同。</p><p>maven_parent：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>和前面不同的是，这里声明 modules 不需要相对路径了（其实还是相对路径，只是不需要 <code>../</code> 了），因为各个子模块和 parent 的 pom.xml 文件处于同一目录下。</strong></p><p>vhr-dao：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这里也不需要通过 relativePath 节点去指定 parent 的 pom.xml 文件位置了，因为 parent 的 pom.xml 和各个子模块处于同一目录下。</strong></p><p>vhr-service：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-打包问题"><a href="#2-打包问题" class="headerlink" title="2. 打包问题"></a>2. 打包问题</h2><h3 id="2-1-继承"><a href="#2-1-继承" class="headerlink" title="2.1 继承"></a>2.1 继承</h3><p>有的时候，单纯只是想通过 parent 来统一管理不同的项目的依赖，并非一个聚合项目。</p><p>这个时候只需要去掉 parent 的 pom.xml 中的 modules 节点及其中的内容即可，这样就不是聚合工程了，各个子模块也可以独立打包。</p><h3 id="2-2-聚合"><a href="#2-2-聚合" class="headerlink" title="2.2 聚合"></a>2.2 聚合</h3><p>当然很多情况我们是聚合工程。</p><p>聚合工程的话，一般松哥是建议大家从 parent 处统一进行打包：</p><p><img src="http://img.itboyhub.com/2021/07/20211009204226.png" alt></p><p>这样可以确保打包到的是最新的代码。</p><p>当然还有另外一种操作流程：</p><ol><li>首先将 parent 安装到本地仓库。</li><li>然后分别将 model、dao 以及 service 等模块安装到本地仓库。</li><li>最后 web 模块就可以独立打包了。</li></ol><p>如果使用这种操作流程，需要注意一点，就是每个模块代码更新之后，要及时安装到本地仓库，否则当 web 模块独立打包时，用到的其他模块就不是最新的代码。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，几个 Maven 中的小问题，窗户纸捅破了就豁然开朗啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;因为最近有小伙伴问到了，所以我想和大家随便扯扯 Maven 项目中代码的组织形式这个问题。&lt;/p&gt;
&lt;p&gt;其实也不是啥大问题，但是如果不懂的话，就像雾里看花，始终不能看的明明白白，懂了就像一层窗户纸，捅破就好了。&lt;/p&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://www.javaboy.org/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://www.javaboy.org/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>LayUI 走了，JDK17 来了</title>
    <link href="http://www.javaboy.org/2021/0928/layui_jdk17.html"/>
    <id>http://www.javaboy.org/2021/0928/layui_jdk17.html</id>
    <published>2021-09-28T13:39:30.000Z</published>
    <updated>2021-10-20T14:11:08.388Z</updated>
    
    <content type="html"><![CDATA[<p>上周五松哥就在 QQ 群里看到了 LayUI 下线的消息：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2021/07/20210927195612.png" alt></p><p>看到这条消息时充满了感慨，毕竟松哥虽然主业是 Java，但是也一直在关注着前端的发展。</p><p>2013 年还在大三的时候就玩过 TypeScript，2014 年的时候当时还买了一本书 NodeJS 的书，后来大学毕业，工作，慢慢的兴趣就集中在后端了，前端虽然也一直在关注，但是只能说略懂略懂。</p><p>这是 LayUI 官方的通告：</p><p><img src="http://img.itboyhub.com/2021/07/20210927202106.png" alt></p><p>不得不说 LayUI 作者这文笔还是可以滴。</p><p>LayUI 算是 jQuery 这一派的 UI 库了。</p><p>松哥早年也是 jQuery 的狂热爱好者，jQuery、jQuery UI、jQuery Mobile 都用过，甚至用 jQuery Mobile 还搞过 <code>香草兰移动农务栽培技术</code> 手机 App，这个 App 还有推广应用。想当年我接的第一个私活，前端就是用 jQuery EasyUI 做的，所以说，我对 jQuery 还是充满了感情的。</p><p>不过自从投入 Vue 的怀抱后，老实说，就不怎么待见 jQuery 了，毕竟 Vue 更香，配合着前端工程化，Vue + ElementUI + Spring Boot 几乎成了经典搭配。</p><p>然而，公司的实际情况和我们想象中的情况却总是存在着差距。</p><p>由于历史原因，或者实际使用场景等原因，大部分是前者。我们依然会在不少项目中遇到 jQuery 家族的产品，说出来你可能都不信，松哥前两天还在敲 jQuery EasyUI 的代码，上个月还敲过 LayUI 的代码，虽然我一点都不想写 LayUI，但是很多时候，很多事情不由你。</p><p>不过老实说，每次我打开 LayUI 官网的时候，我都在想，咋还能访问？难道真的还有很多人舍不得 jQuery，舍不得 LayUI？现在好啦，以后不会再有这样的困惑了。</p><p>Vue 袭来，有的 jQuery 库在积极转型，例如 jQuery EasyUI 也有 Vue 版本，没有转型的，如 LayUI 最终不免落入关站停更的地步。</p><p>LayUI 下线，也算是意料之中吧，这个行业就是这样，技术更新迭代如流水，唯有学习的态度永恒。</p><p>LayUI 走了，JDK17 来了。</p><p>以上内容来自一位 Java 程序员的见解，关于前端部分狂吹 Vue 不一定准确，大家且听之，轻喷。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周五松哥就在 QQ 群里看到了 LayUI 下线的消息：&lt;/p&gt;
    
    </summary>
    
      <category term="layui" scheme="http://www.javaboy.org/categories/layui/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
      <category term="杂谈" scheme="http://www.javaboy.org/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>一个奇怪的登录需求</title>
    <link href="http://www.javaboy.org/2021/0927/spring_security_login.html"/>
    <id>http://www.javaboy.org/2021/0927/spring_security_login.html</id>
    <published>2021-09-27T13:39:16.000Z</published>
    <updated>2021-10-20T14:13:11.340Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>一个奇怪的登录需求。</p><a id="more"></a><p>这是小伙伴们在微信群里的一个提问，我觉得很有意思：</p><p><img src="http://img.itboyhub.com/2021/07/20210927122328.png" alt></p><p>虽然这并非一个典型需求，但是把这个问题解决了，有助于加深大家对于 Spring Security 的理解。</p><p>因此，松哥打算撸一篇文章和大家稍微聊聊这个话题。</p><h2 id="1-问题再现"><a href="#1-问题再现" class="headerlink" title="1. 问题再现"></a>1. 问题再现</h2><p>可能有小伙伴还不明白这个问题，因此我先稍微解释一下。</p><p>当我们登录失败的时候，可能用户名写错，也可能密码写错，但是出于安全考虑，服务端一般不会明确提示是用户名写错了还是密码写错了，而只会给出一个模糊的用户名或者密码写错了。</p><p>然而对于很多新手程序员而言，可能并不了解这样一些“潜规则”，可能会给用户一个明确的提示，明确提示是用户名写错了还是密码写错了。</p><p>为了避免这一情况，Spring Security 通过封装，隐藏了用户名不存在的异常，导致开发者在开发的时候，只能获取到 BadCredentialsException，这个异常既表示用户名不存在，也表示用户密码输入错误。Spring Security 这样做是为了确保我们的系统足够安全。</p><p>然而由于种种原因，有时候我们又希望能够分别获取到用户不存在的异常和密码输入错误的异常，这个时候就需要我们对 Spring Security 进行一些简单的定制了。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>首先我们要先找到问题发生的原因，发生的地方。</p><p>在 Spring Security 中，负责用户校验的工作的类有很多，我这里就不一一列举了（感兴趣的小伙伴可以查看《<a href="https://mp.weixin.qq.com/s/i4qsE1atlKMEcLV22qYjVw" target="_blank" rel="noopener">深入浅出Spring Security</a>》一书），我这里直接说我们涉及到的关键类 <code>AbstractUserDetailsAuthenticationProvider</code>。</p><p>这个类将负责用户名密码的校验工作，具体在 authenticate 方法里边，这个方法本来特别长，我这里只把和本文相关的代码列出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (UsernameNotFoundException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hideUserNotFoundExceptions) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-keyword">this</span>.messages</span><br><span class="line">.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>, <span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>retrieveUser 方法就是根据用户登录输入的用户名去查找用户，如果没找到，就会抛出一个 UsernameNotFoundException，这个异常被 catch 之后，会首先判断是否要隐藏这个异常，如果不隐藏，则原异常原封不动抛出来，如果需要隐藏，则抛出一个新的 BadCredentialsException 异常，BadCredentialsException 异常从字面理解就是密码输入错误的异常。</p><p>所以问题的核心就变成了 hideUserNotFoundExceptions 变量了。</p><p>这是一个 Boolean 类型的属性，默认是 true，<code>AbstractUserDetailsAuthenticationProvider</code> 也为该属性提供了 set 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHideUserNotFoundExceptions</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hideUserNotFoundExceptions)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.hideUserNotFoundExceptions = hideUserNotFoundExceptions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来修改 hideUserNotFoundExceptions 属性并不难！只要找到 <code>AbstractUserDetailsAuthenticationProvider</code> 的实例，然后调用相应的 set 方法就能修改了。</p><p>现在问题的核心变成了从哪里获取 <code>AbstractUserDetailsAuthenticationProvider</code> 的实例？</p><p>看名字就知道，<code>AbstractUserDetailsAuthenticationProvider</code> 是一个抽象类，所以它的实例其实就是它子类的实例，子类是谁？当然是负责用户密码校验工作的 <code>DaoAuthenticationProvider</code>。</p><p>这个知识点先记住，我们一会会用到。</p><h2 id="3-登录流程"><a href="#3-登录流程" class="headerlink" title="3. 登录流程"></a>3. 登录流程</h2><p>为了弄明白这个问题，我们还需要搞懂 Spring Security 一个大致的认证流程，这个也非常重要。</p><p>首先大家知道，Spring Security 的认证工作主要是由 AuthenticationManager 来完成的，而 AuthenticationManager 则是一个接口，它的实现类是 ProviderManager。简而言之，Spring Security 中具体负责校验工作的是 ProviderManager#authenticate 方法。</p><p>但是校验工作并不是由 ProviderManager 直接完成的，ProviderManager 中管理了若干个 AuthenticationProvider，ProviderManager 会调用它所管理的 AuthenticationProvider 去完成校验工作，如下图：</p><p><img src="http://img.itboyhub.com/2020/07/20200709222237.png" alt></p><p>另一方面，ProviderManager 又分为全局的和局部的。</p><p>当我们登录的时候，首先由局部的 ProviderManager 出场进行用户名密码的校验工作，如果校验成功，那么用户就登录成功了，如果校验失败，则会调用局部 ProviderManager 的 parent，也就是全局 ProviderManager 去完成校验工作，如果全局 ProviderManager 校验成功，就表示用户登录成功，如果全局 ProviderManager 校验失败，就表示用户登录失败，如下图：</p><p><img src="http://img.itboyhub.com/2020/07/20200721164221.png" alt></p><p>OK，有了上面的知识储备，我们再来分析一下我们想要抛出 UsernameNotFoundException 该怎么做。</p><h2 id="4-思路分析"><a href="#4-思路分析" class="headerlink" title="4. 思路分析"></a>4. 思路分析</h2><p>首先我们的用户校验工作在局部的 ProviderManager 中进行，局部的 ProviderManager 中管理了若干个 AuthenticationProvider，这若干个 AuthenticationProvider 中就有可能包含了我们所需要的 DaoAuthenticationProvider。那我们是否需要在这里调用 DaoAuthenticationProvider 的 setHideUserNotFoundExceptions 方法完成属性的修改呢？</p><p>松哥的建议是没必要！</p><p>为什么？</p><p>因为当用户登录的时候，首先去局部的 ProviderManager 中去校验，如果校验成功当然最好；如果校验失败，并不会立马抛出异常，而是去全局的 ProviderManager 中继续校验，这样即使我们在局部 ProviderManager 中抛出了 UsernameNotFoundException 也没用，因为最终这个异常能不能抛出来决定权在全局 ProviderManager 中（如果全局的 ProviderManager 所管理的 DaoAuthenticationProvider 没做任何特殊处理，那么局部 ProviderManager 中抛出来的 UsernameNotFoundException 异常最终还是会被隐藏）。</p><p>所以，我们要做的就是获取全局的 ProviderManager，进而获取到全局 ProviderManager 所管理的 DaoAuthenticationProvider，然后调用其 setHideUserNotFoundExceptions 方法修改相应属性值即可。</p><p>弄明白了原理，代码就简单了。</p><h2 id="5-具体实践"><a href="#5-具体实践" class="headerlink" title="5. 具体实践"></a>5. 具体实践</h2><p>全局 ProviderManager 的修改在 <code>WebSecurityConfigurerAdapter#configure(AuthenticationManagerBuilder)</code> 类中，这里配置的 AuthenticationManagerBuilder 最终用来生成全局的 ProviderManager，所以我们的配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider daoAuthenticationProvider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        daoAuthenticationProvider.setHideUserNotFoundExceptions(<span class="hljs-keyword">false</span>);</span><br><span class="line">        InMemoryUserDetailsManager userDetailsService = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        userDetailsService.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        daoAuthenticationProvider.setUserDetailsService(userDetailsService);</span><br><span class="line">        auth.authenticationProvider(daoAuthenticationProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .failureHandler((request, response, exception) -&gt; System.out.println(exception))</span><br><span class="line">                .permitAll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码就简单了：</p><ol><li>创建一个 DaoAuthenticationProvider 对象。</li><li>调用 DaoAuthenticationProvider 对象的 setHideUserNotFoundExceptions 方法，修改相应的属性值。</li><li>为 DaoAuthenticationProvider 配置用户数据源。</li><li>将 DaoAuthenticationProvider 设置给 auth 对象，auth 将用来生成全局的 ProviderManager。</li><li>在另一个 configure 方法中，我们就配置一下登录回调即可，登录失败的时候，打印异常信息看看。</li></ol><p>行啦。</p><p>接下来启动项目进行测试。输入一个错误的用户名，可以看到 IDEA 控制台会打印出如下信息：</p><p><img src="http://img.itboyhub.com/2021/07/20210923214411.png" alt></p><p>可以看到，UsernameNotFoundException 异常已经抛出来了。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>好啦，今天就和小伙伴们分享了一下在 Spring Security 中如何抛出 UsernameNotFoundException 异常，虽然这只是一个小众需求，但是可以加深大家对 Spring Security 的理解，感兴趣的小伙伴可以仔细琢磨下。</p><p>题外话：</p><blockquote><p>这个需求还有一个简单的实现方式，就是自定义一个用户不存在的异常，当在 UserDetailsService 中查找用户查找不到时，抛出自定义的异常，这个自定义的异常不会被隐藏，这个比较简单，我就不写代码了，感兴趣的小伙伴可以去试试。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;一个奇怪的登录需求。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 玩出花！两种方式 DIY 登录</title>
    <link href="http://www.javaboy.org/2021/0924/spring_security_diy_login.html"/>
    <id>http://www.javaboy.org/2021/0924/spring_security_diy_login.html</id>
    <published>2021-09-24T13:38:59.000Z</published>
    <updated>2021-10-20T14:13:05.481Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>一般情况下，我们在使用 Spring Security 的时候，用的是 Spring Security 自带的登录方案，配置一下登录接口，配置一下登录参数，再配置一下登录回调就能用了，这种用法可以算是最佳实践了！</p><p>但是！</p><a id="more"></a><p>总会有一些奇奇怪怪得需求，例如想自定义登录，像 Shiro 那样自己写登录逻辑，如果要实现这一点，该怎么做？今天松哥就来和大家分享一下。</p><p>松哥琢磨了一下，想在 Spring Security 中自定义登录逻辑，我们有两种思路，不过这两种思路底层实现其实异曲同工，我们一起来看下。</p><h2 id="1-化腐朽为神奇"><a href="#1-化腐朽为神奇" class="headerlink" title="1. 化腐朽为神奇"></a>1. 化腐朽为神奇</h2><p>前面松哥和大家分享了一个 Spring Security 视频：</p><ul><li><a href="https://mp.weixin.qq.com/s/x3Xm8sNe8NR0evhiBwCWWw" target="_blank" rel="noopener">没见过的奇葩登录</a></li></ul><p>这个视频里主要是和大家分享了我们其实可以使用 HttpServletRequest 来完成系统的登录，这其实是 JavaEE 的规范，这种登录方式虽然冷门，但是却很好玩！</p><p>然后松哥还和大家分享了一个视频：</p><ul><li><a href="https://mp.weixin.qq.com/s/0gLhR52BMkb4yTaC0B3_kg" target="_blank" rel="noopener">SpringSecurity登录数据获取最后一讲</a></li></ul><p>这个视频其实是在讲 Spring Security 对 HttpServletRequest 登录逻辑的实现，或句话说，HttpServletRequest 中提供的那几个和登录相关的 API，Spring Security 都按照自己的实现方式对其进行了重写。</p><p>有了这两个储备知识后，第一个 DIY Spring Security 登录的方案呼之欲出。</p><h3 id="1-1-实践"><a href="#1-1-实践" class="headerlink" title="1.1 实践"></a>1.1 实践</h3><p>我们来看看具体操作。</p><p>首先我们来创建一个 Spring Boot 工程，引入 Web 和 Security 两个依赖，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210918192205.png" alt></p><p>方便起见，我们在 application.properties 中配置一下默认的用户名密码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=123</span><br></pre></td></tr></table></figure><p>接下来我们提供一个 SecurityConfig，为登录接口放行：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/login"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录接口就是 <code>/login</code>，一会我们自定义的登录逻辑就写在这个里边，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            req.login(username, password);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 HttpServletRequest#login 方法，传入用户名和密码完成登录操作。</p><p>最后我们再提供一个测试接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello security!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>just this！</p><p>启动项目，我们首先访问 <code>/hello</code> 接口，会访问失败，接下来我们访问 <code>/login</code> 接口执行登录操作，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210918194657.png" alt></p><p>登录成功之后，再去访问 <code>/hello</code> 接口，此时就可以访问成功了。</p><p>是不是很 Easy？登录成功后，以后的授权等操作都还是原来的写法不变。</p><h3 id="1-2-原理分析"><a href="#1-2-原理分析" class="headerlink" title="1.2 原理分析"></a>1.2 原理分析</h3><p>上面这种登录方式的原理其实松哥一开始就介绍过了，如果大家还不熟悉，可以看看这两个视频就懂了：</p><ul><li><a href="https://mp.weixin.qq.com/s/x3Xm8sNe8NR0evhiBwCWWw" target="_blank" rel="noopener">没见过的奇葩登录</a></li><li><a href="https://mp.weixin.qq.com/s/0gLhR52BMkb4yTaC0B3_kg" target="_blank" rel="noopener">SpringSecurity登录数据获取最后一讲</a></li></ul><p>这里我也是稍微说两句。</p><p>我们在 LoginController#login 方法中所获取到的 HttpServletRequest 实例其实是 HttpServlet3RequestFactory 中的一个内部类 Servlet3SecurityContextHolderAwareRequestWrapper 的对象，在这个类中，重写了 HttpServletRequest 的 login 以及 authenticate 等方法，我们先来看看 login 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isAuthenticated()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Cannot perform login for '"</span> + username + <span class="hljs-string">"' already authenticated as '"</span></span><br><span class="line">+ getRemoteUser() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">AuthenticationManager authManager = HttpServlet3RequestFactory.<span class="hljs-keyword">this</span>.authenticationManager;</span><br><span class="line"><span class="hljs-keyword">if</span> (authManager == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">HttpServlet3RequestFactory.<span class="hljs-keyword">this</span>.logger.debug(</span><br><span class="line"><span class="hljs-string">"authenticationManager is null, so allowing original HttpServletRequest to handle login"</span>);</span><br><span class="line"><span class="hljs-keyword">super</span>.login(username, password);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Authentication authentication = getAuthentication(authManager, username, password);</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>如果用户已经认证了，就抛出异常。</li><li>获取到一个 AuthenticationManager 对象。</li><li>调用 getAuthentication 方法完成登录，在该方法中，会根据用户名密码构建 UsernamePasswordAuthenticationToken 对象，然后调用 Authentication#authenticate 方法完成登录，具体代码如下：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Authentication <span class="hljs-title">getAuthentication</span><span class="hljs-params">(AuthenticationManager authManager, String username, String password)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> authManager.authenticate(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该方法返回的是一个认证后的 Authentication 对象。</p></blockquote><ol start="4"><li>最后，将认证后的 Authentication 对象存入 SecurityContextHolder 中，这里的具体逻辑我就不啰嗦了，我在公众号【江南一点雨】之前的视频中已经讲过多次了。</li></ol><p>这就是 login 方法的执行逻辑。</p><p>Servlet3SecurityContextHolderAwareRequestWrapper 类也重写了 HttpServletRequest#authenticate 方法，这个也是做认证的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">authenticate</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">AuthenticationEntryPoint entryPoint = HttpServlet3RequestFactory.<span class="hljs-keyword">this</span>.authenticationEntryPoint;</span><br><span class="line"><span class="hljs-keyword">if</span> (entryPoint == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">HttpServlet3RequestFactory.<span class="hljs-keyword">this</span>.logger.debug(</span><br><span class="line"><span class="hljs-string">"authenticationEntryPoint is null, so allowing original HttpServletRequest to handle authenticate"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticate(response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (isAuthenticated()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">entryPoint.commence(<span class="hljs-keyword">this</span>, response,</span><br><span class="line"><span class="hljs-keyword">new</span> AuthenticationCredentialsNotFoundException(<span class="hljs-string">"User is not Authenticated"</span>));</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法用来判断用户是否已经完成认证操作，返回 true 表示用户已经完成认证，返回 false 表示用户尚未完成认证工作。</p><h2 id="2-源码的力量"><a href="#2-源码的力量" class="headerlink" title="2. 源码的力量"></a>2. 源码的力量</h2><p>看了上面的原理分析，大家应该也明白了第二种方案了，就是不使用 HttpServletRequest#login 方法，我们直接调用 AuthenticationManager 进行登录验证。</p><p>一起来看下。</p><p>首先我们修改配置类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/login"</span>,<span class="hljs-string">"/login2"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        provider.setUserDetailsService(manager);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProviderManager(provider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先在登录放行中，添加 <code>/login2</code> 接口，这是我即将自定义的第二个登录接口。</li><li>提供一个 AuthenticationManager 实例，关于 AuthenticationManager 的玩法松哥在之前的 Spring Security 系列中已经多次分享过，这里就不再赘述（没看过的小伙伴公众号后台回复 <code>ss</code>）。创建 AuthenticationManager 实例时，还需要提供一个 DaoAuthenticationProvider，大家知道，用户密码的校验工作在这个类里边完成，并为 DaoAuthenticationProvider 配置一个 UserDetailsService 实例，该实体提供了用户数据源。</li></ol><p>接下来提供一个登录接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login2</span><span class="hljs-params">(String username, String password, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Authentication token = authenticationManager.authenticate(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password));</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在登录接口中，传入用户名密码等参数，然后将用户名密码等参数封装成一个 UsernamePasswordAuthenticationToken 对象，最后调用 AuthenticationManager#authenticate 方法进行验证，验证成功后会返回一个认证后的 Authentication 对象，再手动把该 Authentication 对象存入 SecurityContextHolder 中。</p><p>配置完成后，重启项目，进行登录测试即可。</p><p>第二种方案和第一种方案异曲同工，第二种实际上就是把第一种的底层拉出来自己重新实现，<strong>仅此而已</strong>。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，今天就和大家介绍了两种 Spring Security DIY 登录的方案，这些方案可能工作中并不常用，但是对于大家理解 Spring Security 原理还是大有裨益的，感兴趣的小伙伴可以敲一下试试哦～</p><p>另外，如果你感觉阅读本文吃力，不妨在公众号后台回复 <code>ss</code>，看看 Spring Security 系列的其他文章，这有助于理解本文，当然也可以看看松哥的新书：</p><p>《深入浅出Spring Security》一书已由清华大学出版社正式出版发行，感兴趣的小伙伴戳这里<a href="https://mp.weixin.qq.com/s/i4qsE1atlKMEcLV22qYjVw" target="_blank" rel="noopener">-&gt;-&gt;&gt;深入浅出Spring Security</a>，一本书学会 Spring Security。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;一般情况下，我们在使用 Spring Security 的时候，用的是 Spring Security 自带的登录方案，配置一下登录接口，配置一下登录参数，再配置一下登录回调就能用了，这种用法可以算是最佳实践了！&lt;/p&gt;
&lt;p&gt;但是！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 中的消息会过期吗？</title>
    <link href="http://www.javaboy.org/2021/0921/rabbitmq_msg_expire.html"/>
    <id>http://www.javaboy.org/2021/0921/rabbitmq_msg_expire.html</id>
    <published>2021-09-21T13:38:34.000Z</published>
    <updated>2021-10-20T14:12:17.396Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>RabbitMQ 中的消息长期未被消费会过期吗？用过 RabbitMQ 的小伙伴可能都有这样的疑问，今天松哥就来和大家捋一捋这个问题。</p><a id="more"></a><h2 id="1-默认情况"><a href="#1-默认情况" class="headerlink" title="1. 默认情况"></a>1. 默认情况</h2><p>首先我们来看看默认情况。</p><p>默认情况下，消息是不会过期的，也就是我们平日里在消息发送时，如果不设置任何消息过期的相关参数，那么消息是不会过期的，即使消息没被消费掉，也会一直存储在队列中。</p><p>这种情况具体代码就不用我再演示了吧，松哥之前的文章凡是涉及到 RabbitMQ 的，基本上都是这样的。</p><h2 id="2-TTL"><a href="#2-TTL" class="headerlink" title="2. TTL"></a>2. TTL</h2><p>TTL（Time-To-Live），消息存活的时间，即消息的有效期。如果我们希望消息能够有一个存活时间，那么我们可以通过设置 TTL 来实现这一需求。如果消息的存活时间超过了 TTL 并且还没有被消息，此时消息就会变成<code>死信</code>，关于<code>死信</code>以及<code>死信队列</code>，松哥后面再和大家介绍。</p><p>TTL 的设置有两种不同的方式：</p><ol><li>在声明队列的时候，我们可以在队列属性中设置消息的有效期，这样所有进入该队列的消息都会有一个相同的有效期。</li><li>在发送消息的时候设置消息的有效期，这样不同的消息就具有不同的有效期。</li></ol><p>那如果两个都设置了呢？</p><p><strong>以时间短的为准。</strong></p><p>当我们设置了消息有效期后，消息过期了就会被从队列中删除了（进入到死信队列，后文一样，不再标注），但是两种方式对应的删除时机有一些差异：</p><ol><li>对于第一种方式，当消息队列设置过期时间的时候，那么消息过期了就会被删除，因为消息进入 RabbitMQ 后是存在一个消息队列中，队列的头部是最早要过期的消息，所以 RabbitMQ 只需要一个定时任务，从头部开始扫描是否有过期消息，有的话就直接删除。</li><li>对于第二种方式，当消息过期后并不会立马被删除，而是当消息要投递给消费者的时候才会去删除，因为第二种方式，每条消息的过期时间都不一样，想要知道哪条消息过期，必须要遍历队列中的所有消息才能实现，当消息比较多时这样就比较耗费性能，因此对于第二种方式，当消息要投递给消费者的时候才去删除。</li></ol><p>介绍完 TTL 之后，接下来我们来看看具体用法。</p><p><strong>接下来所有代码松哥都以 Spring Boot 中封装的 AMPQ 为例来讲解。</strong></p><h3 id="2-1-单条消息过期"><a href="#2-1-单条消息过期" class="headerlink" title="2.1 单条消息过期"></a>2.1 单条消息过期</h3><p>我们先来看单条消息的过期时间。</p><p>首先创建一个 Spring Boot 项目，引入 Web 和 RabbitMQ 依赖，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210919182844.png" alt></p><p>然后在 application.properties 中配置一下 RabbitMQ 的连接信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=127.0.0.1</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure><p>接下来稍微配置一下消息队列：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_QUEUE_DEMO = <span class="hljs-string">"javaboy_queue_demo"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_EXCHANGE_DEMO = <span class="hljs-string">"javaboy_exchange_demo"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HELLO_ROUTING_KEY = <span class="hljs-string">"hello_routing_key"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(JAVABOY_QUEUE_DEMO, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(JAVABOY_EXCHANGE_DEMO, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue())</span><br><span class="line">                .to(directExchange())</span><br><span class="line">                .with(HELLO_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类主要干了三件事：配置消息队列、配置交换机以及将两者绑定在一起。</p><ol><li>首先配置一个消息队列，new 一个 Queue：第一个参数是消息队列的名字；第二个参数表示消息是否持久化；第三个参数表示消息队列是否排他，一般我们都是设置为 false，即不排他；第四个参数表示如果该队列没有任何订阅的消费者的话，该队列会被自动删除，一般适用于临时队列。</li><li>配置一个 DirectExchange 交换机。</li><li>将交换机和队列绑定到一起。</li></ol><p>这段配置应该很简单，没啥好解释的，有一个排他性，松哥这里稍微多说两句：</p><blockquote><p>关于排他性，如果设置为 true，则该消息队列只有创建它的 Connection 才能访问，其他的 Connection 都不能访问该消息队列，如果试图在不同的连接中重新声明或者访问排他性队列，那么系统会报一个资源被锁定的错误。另一方面，对于排他性队列而言，当连接断掉的时候，该消息队列也会自动删除（无论该队列是否被声明为持久性队列都会被删除）。</p></blockquote><p>接下来提供一个消息发送接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Message message = MessageBuilder.withBody(<span class="hljs-string">"hello javaboy"</span>.getBytes())</span><br><span class="line">                .setExpiration(<span class="hljs-string">"10000"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(QueueConfig.JAVABOY_QUEUE_DEMO, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建 Message 对象的时候我们可以设置消息的过期时间，这里设置消息的过期时间为 10 秒。</p><p>这就可以啦！</p><p>接下来我们启动项目，进行消息发送测试。当消息发送成功之后，由于没有消费者，所以这条消息并不会被消费。打开 RabbitMQ 管理页面，点击到 Queues 选项卡，10s 之后，我们会发现消息已经不见了：</p><p><img src="http://img.itboyhub.com/2021/07/20210919220427.png" alt></p><p>很简单吧！</p><p>单条消息设置过期时间，就是在消息发送的时候设置一下消息有效期即可。</p><h3 id="2-2-队列消息过期"><a href="#2-2-队列消息过期" class="headerlink" title="2.2 队列消息过期"></a>2.2 队列消息过期</h3><p>给队列设置消息过期时间，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    args.put(<span class="hljs-string">"x-message-ttl"</span>, <span class="hljs-number">10000</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(JAVABOY_QUEUE_DEMO, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置完成后，我们修改消息的发送逻辑，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Message message = MessageBuilder.withBody(<span class="hljs-string">"hello javaboy"</span>.getBytes())</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(QueueConfig.JAVABOY_QUEUE_DEMO, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，消息正常发送即可，不用设置消息过期时间。</p><p>OK，启动项目，发送一条消息进行测试。查看 RabbitMQ 管理页面，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210919225204.png" alt></p><p>可以看到，消息队列的 Features 属性为 D 和 TTL，D 表示消息队列中消息持久化，TTL 则表示消息会过期。</p><p>10s 之后刷新页面，发现消息数量已经恢复为 0。</p><p>这就是给消息队列设置消息过期时间，一旦设置了，所有进入到该队列的消息都有一个过期时间了。</p><h3 id="2-3-特殊情况"><a href="#2-3-特殊情况" class="headerlink" title="2.3 特殊情况"></a>2.3 特殊情况</h3><p>还有一种特殊情况，就是将消息的过期时间 TTL 设置为 0，这表示如果消息不能立马消费则会被立即丢掉，这个特性可以部分替代 RabbitMQ3.0 以前支持的 immediate 参数，之所以所部分代替，是因为 immediate 参数在投递失败会有 basic.return 方法将消息体返回（这个功能可以利用死信队列来实现）。</p><p>具体代码松哥就不演示了，这个应该比较容易。</p><h2 id="3-死信队列"><a href="#3-死信队列" class="headerlink" title="3. 死信队列"></a>3. 死信队列</h2><p>有小伙伴不禁要问，被删除的消息去哪了？真的被删除了吗？非也非也！这就涉及到死信队列了，接下来我们来看看死信队列。</p><h3 id="3-1-死信交换机"><a href="#3-1-死信交换机" class="headerlink" title="3.1 死信交换机"></a>3.1 死信交换机</h3><p>死信交换机，Dead-Letter-Exchange 即 DLX。</p><p>死信交换机用来接收死信消息（Dead Message）的，那什么是死信消息呢？一般消息变成死信消息有如下几种情况：</p><ul><li>消息被拒绝(Basic.Reject/Basic.Nack) ，井且设置requeue 参数为false</li><li>消息过期</li><li>队列达到最大长度</li></ul><p>当消息在一个队列中变成了死信消息后，此时就会被发送到 DLX，绑定 DLX 的消息队列则称为死信队列。</p><p>DLX 本质上也是一个普普通通的交换机，我们可以为任意队列指定 DLX，当该队列中存在死信时，RabbitMQ 就会自动的将这个死信发布到 DLX 上去，进而被路由到另一个绑定了 DLX 的队列上（即死信队列）。</p><h3 id="3-2-死信队列"><a href="#3-2-死信队列" class="headerlink" title="3.2 死信队列"></a>3.2 死信队列</h3><p>这个好理解，绑定了死信交换机的队列就是死信队列。</p><h3 id="3-3-实践"><a href="#3-3-实践" class="headerlink" title="3.3 实践"></a>3.3 实践</h3><p>我们来看一个简单的例子。</p><p>首先我们来创建一个死信交换机，接着创建一个死信队列，再将死信交换机和死信队列绑定到一起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_EXCHANGE_NAME = <span class="hljs-string">"dlx_exchange_name"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_QUEUE_NAME = <span class="hljs-string">"dlx_queue_name"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_ROUTING_KEY = <span class="hljs-string">"dlx_routing_key"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 配置死信交换机</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">DirectExchange <span class="hljs-title">dlxDirectExchange</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DLX_EXCHANGE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 配置死信队列</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Queue <span class="hljs-title">dlxQueue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DLX_QUEUE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 绑定死信队列和死信交换机</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Binding <span class="hljs-title">dlxBinding</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> BindingBuilder.bind(dlxQueue())</span><br><span class="line">            .to(dlxDirectExchange())</span><br><span class="line">            .with(DLX_ROUTING_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实跟普通的交换机，普通的消息队列没啥两样。</p><p>接下来为消息队列配置死信交换机，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="hljs-comment">//设置消息过期时间</span></span><br><span class="line">    args.put(<span class="hljs-string">"x-message-ttl"</span>, <span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-comment">//设置死信交换机</span></span><br><span class="line">    args.put(<span class="hljs-string">"x-dead-letter-exchange"</span>, DLX_EXCHANGE_NAME);</span><br><span class="line">    <span class="hljs-comment">//设置死信 routing_key</span></span><br><span class="line">    args.put(<span class="hljs-string">"x-dead-letter-routing-key"</span>, DLX_ROUTING_KEY);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(JAVABOY_QUEUE_DEMO, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就两个参数：</p><ul><li>x-dead-letter-exchange：配置死信交换机。</li><li>x-dead-letter-routing-key：配置死信 <code>routing_key</code>。</li></ul><p>这就配置好了。</p><p>将来发送到这个消息队列上的消息，如果发生了 nack、reject 或者过期等问题，就会被发送到 DLX 上，进而进入到与 DLX 绑定的消息队列上。</p><p>死信消息队列的消费和普通消息队列的消费并无二致：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = QueueConfig.DLX_QUEUE_NAME)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dlxHandle</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"dlx msg = "</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易吧～</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，今天就和小伙伴们聊一聊 RabbitMQ 中的消息过期问题，感兴趣的小伙伴可以去试试哦～</p><p>公众号江南一点雨后台回复本文标题，可以获取本文案例下载链接。</p><p>参考资料：</p><ul><li>blog.csdn.net/u012988901/article/details/88958654</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;RabbitMQ 中的消息长期未被消费会过期吗？用过 RabbitMQ 的小伙伴可能都有这样的疑问，今天松哥就来和大家捋一捋这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
      <category term="消息过期" scheme="http://www.javaboy.org/tags/%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F/"/>
    
      <category term="死信队列" scheme="http://www.javaboy.org/tags/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring 定时任务玩出花！</title>
    <link href="http://www.javaboy.org/2021/0916/spring_scheduling_system.html"/>
    <id>http://www.javaboy.org/2021/0916/spring_scheduling_system.html</id>
    <published>2021-09-16T13:38:18.000Z</published>
    <updated>2021-10-20T14:12:59.697Z</updated>
    
    <content type="html"><![CDATA[<p>今天抽空撸一篇文章，和大家聊一聊上篇文章的可视化定时任务是怎么实现的。</p><p>上篇文章发了后，有不少小伙伴在评论区提出了一些问题，我觉得还挺有意思的，这篇文章应该能解决掉大家的大部分疑惑。</p><a id="more"></a><p>好啦，就不废话了，我们来看看具体实现方案。</p><p>对了，如果还没看过上篇文章的小伙伴可以先看看，不然可能不知道我在说啥，传送门：</p><ul><li><a href="https://mp.weixin.qq.com/s/H3RrpnBYDNwgtSOMlt3Ihg" target="_blank" rel="noopener">刚出炉热腾腾的定时任务可视化管理系统</a></li></ul><hr><h2 id="1-项目概览"><a href="#1-项目概览" class="headerlink" title="1. 项目概览"></a>1. 项目概览</h2><p>我们首先来大概看下这个项目：</p><p><img src="http://img.itboyhub.com/2021/07/20210912220951.png" alt></p><p>这里和定时任务相关的配置主要在 config 包里边，其他的都是业务类代码，换句话说其他的都是常规的 CURD，所以我这里主要和小伙伴们介绍 config 中的代码。</p><h2 id="2-整体思路"><a href="#2-整体思路" class="headerlink" title="2. 整体思路"></a>2. 整体思路</h2><p>我先来说说这个项目的整体思路，这样方便大家理解下面的内容。</p><p>在这个项目中，每一个定时任务都由一个线程去处理，负责处理每一个定时任务的线程类是 SchedulingRunnable，所有的线程都跑在一个线程池中，这个线程池是 ThreadPoolTaskScheduler，这是一个专为定时任务设计的线程池（支持 Cron 表达式），它的底层其实就是大家所熟知的 ScheduledThreadPoolExecutor。当有一个新的定时任务需要执行时，创建一个 SchedulingRunnable 线程，然后连同 Cron 表达式一起扔到 ThreadPoolTaskScheduler 池子里去执行就行了。</p><h2 id="3-配置分析"><a href="#3-配置分析" class="headerlink" title="3. 配置分析"></a>3. 配置分析</h2><p>几个配置类我们逐一来分析。</p><h3 id="3-1-SpringContextUtils"><a href="#3-1-SpringContextUtils" class="headerlink" title="3.1 SpringContextUtils"></a>3.1 SpringContextUtils</h3><p>首先我们提供了一个 SpringContextUtils 工具类，这个工具类实现了 ApplicationContextAware 接口，通过这个工具类，我们可以从 Spring 容器中查询一个 Bean 或者判断 Spring 容器中是否存在某一个 Bean，工具类的代码如下（我主要列出来了有哪些方法，具体实现大家可以参考：<a href="https://github.com/lenve/scheduling" target="_blank" rel="noopener">https://github.com/lenve/scheduling</a>）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringContextUtils</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span></span></span><br><span class="line"><span class="hljs-function">            <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SpringContextUtils.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;? extends Object&gt; getType(String name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-SchedulingRunnable"><a href="#3-2-SchedulingRunnable" class="headerlink" title="3.2 SchedulingRunnable"></a>3.2 SchedulingRunnable</h3><p>将来每一个定时任务执行的时候，我们都开启一个新的线程去执行这个定时任务，SchedulingRunnable 就是关于这个线程的配置，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchedulingRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(SchedulingRunnable.class);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> String params;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Object targetBean;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SchedulingRunnable</span><span class="hljs-params">(String beanName, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>(beanName, methodName, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SchedulingRunnable</span><span class="hljs-params">(String beanName, String methodName, String params)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.beanName = beanName;</span><br><span class="line">        <span class="hljs-keyword">this</span>.methodName = methodName;</span><br><span class="line">        <span class="hljs-keyword">this</span>.params = params;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            targetBean = SpringContextUtils.getBean(beanName);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (StringUtils.hasText(params)) &#123;</span><br><span class="line">                method = targetBean.getClass().getDeclaredMethod(methodName, String.class);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                method = targetBean.getClass().getDeclaredMethod(methodName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"定时任务开始执行 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;"</span>, beanName, methodName, params);</span><br><span class="line">        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (StringUtils.hasText(params)) &#123;</span><br><span class="line">                method.invoke(targetBean, params);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                method.invoke(targetBean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            logger.error(String.format(<span class="hljs-string">"定时任务执行异常 - bean：%s，方法：%s，参数：%s "</span>, beanName, methodName, params), ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">long</span> times = System.currentTimeMillis() - startTime;</span><br><span class="line">        logger.info(<span class="hljs-string">"定时任务执行结束 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;，耗时：&#123;&#125; 毫秒"</span>, beanName, methodName, params, times);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        SchedulingRunnable that = (SchedulingRunnable) o;</span><br><span class="line">        <span class="hljs-keyword">if</span> (params == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> beanName.equals(that.beanName) &amp;&amp;</span><br><span class="line">                    methodName.equals(that.methodName) &amp;&amp;</span><br><span class="line">                    that.params == <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> beanName.equals(that.beanName) &amp;&amp;</span><br><span class="line">                methodName.equals(that.methodName) &amp;&amp;</span><br><span class="line">                params.equals(that.params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (params == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> Objects.hash(beanName, methodName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> Objects.hash(beanName, methodName, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SchedulingRunnable 实现了 Runnable 接口，这里的实现逻辑也比较简单，我们一起来看下：</p><ol><li>首先声明了 beanName、methodName 以及 params 分别作为定时任务执行的 Bean 的 bean 名称、方法名称以及方法参数。不知道小伙伴们是否记得我们<a href="https://mp.weixin.qq.com/s/H3RrpnBYDNwgtSOMlt3Ihg" target="_blank" rel="noopener">上篇文章</a>中介绍的该系统的用法，在添加一个定时任务时，我们需要传入相应的 beanName、methodName 以及 params 参数，传入后就来到这里了。另外还有 targetBean 和 method 分别表示 beanName 对应的对象以及 methodName 对应的对象，其中 targetBean 通过 beanName 从 Spring 容器中查找，method 则通过 methodName 从 targetBean 中查找。</li><li>在 run 方法中，通过反射去调用 method 方法，这也是定时任务执行时候的具体逻辑。</li><li>另外，这里重写了 equals 和 hashCode 方法，这两个方法主要是比较了 beanName、methodName 以及 params 三个属性，换言之，如果这三个属性相同，则认为这是同一个对象（这三个属性相同表示这是同一个定时任务）。</li></ol><h3 id="3-3-SchedulingConfig"><a href="#3-3-SchedulingConfig" class="headerlink" title="3.3 SchedulingConfig"></a>3.3 SchedulingConfig</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchedulingConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskScheduler <span class="hljs-title">taskScheduler</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskScheduler taskScheduler = <span class="hljs-keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">        taskScheduler.setPoolSize(<span class="hljs-number">4</span>);</span><br><span class="line">        taskScheduler.setRemoveOnCancelPolicy(<span class="hljs-keyword">true</span>);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(<span class="hljs-string">"TaskSchedulerThreadPool-"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是配置一下 ThreadPoolTaskScheduler，这个可以很方便的对重复执行的任务进行调度管理，相比于通过 Java 自带的周期性任务线程池ScheduleThreadPoolExecutor，ThreadPoolTaskScheduler 对象支持根据 Cron 表达式创建周期性任务。</p><p>既然是线程池，必然就有线程数量等问题，它的核心线程池大小就是我们配置的 poolSize 属性，最大线程池大小是 <code>Integer.MAX_VALUE</code>，<code>keepAliveTime</code> 为 0 ,这里用到的队列是 <code>DelayedWorkQueue</code> ，这个队列有一个属性 <code>private final DelayQueue&lt;RunnableScheduledFuture&gt; dq = new DelayQueue&lt;RunnableScheduledFuture&gt;();</code> 对这个队列的操作实际是是对这个 DelayQueue 的操作，这个队列大小是 Integer.MAX_VALUE，所以线程数量肯定是够用了。</p><p>其他配置就没啥好说的。</p><h3 id="3-4-ScheduledTask"><a href="#3-4-ScheduledTask" class="headerlink" title="3.4 ScheduledTask"></a>3.4 ScheduledTask</h3><p>ScheduledTask 是 ScheduledFuture 的包装类，这个包装类中主要多了一个 future 属性，这个 future 属性表示 TaskScheduler 定时任务线程池的执行结果：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledTask</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">volatile</span> ScheduledFuture&lt;?&gt; future;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        ScheduledFuture&lt;?&gt; future = <span class="hljs-keyword">this</span>.future;</span><br><span class="line">        <span class="hljs-keyword">if</span> (future != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            future.cancel(<span class="hljs-keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-CronTaskRegistrar"><a href="#3-5-CronTaskRegistrar" class="headerlink" title="3.5 CronTaskRegistrar"></a>3.5 CronTaskRegistrar</h3><p>核心的方法都在这个里边。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CronTaskRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Runnable, ScheduledTask&gt; scheduledTasks = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-keyword">private</span> TaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskScheduler <span class="hljs-title">getScheduler</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCronTask</span><span class="hljs-params">(Runnable task, String cronExpression)</span> </span>&#123;</span><br><span class="line">        addCronTask(<span class="hljs-keyword">new</span> CronTask(task, cronExpression));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCronTask</span><span class="hljs-params">(CronTask cronTask)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (cronTask != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            Runnable task = cronTask.getRunnable();</span><br><span class="line">            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scheduledTasks.containsKey(task)) &#123;</span><br><span class="line">                removeCronTask(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">this</span>.scheduledTasks.put(task, scheduleCronTask(cronTask));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeCronTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        ScheduledTask scheduledTask = <span class="hljs-keyword">this</span>.scheduledTasks.remove(task);</span><br><span class="line">        <span class="hljs-keyword">if</span> (scheduledTask != <span class="hljs-keyword">null</span>)</span><br><span class="line">            scheduledTask.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ScheduledTask <span class="hljs-title">scheduleCronTask</span><span class="hljs-params">(CronTask cronTask)</span> </span>&#123;</span><br><span class="line">        ScheduledTask scheduledTask = <span class="hljs-keyword">new</span> ScheduledTask();</span><br><span class="line">        scheduledTask.future = <span class="hljs-keyword">this</span>.taskScheduler.schedule(cronTask.getRunnable(), cronTask.getTrigger());</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> scheduledTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (ScheduledTask task : <span class="hljs-keyword">this</span>.scheduledTasks.values()) &#123;</span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.scheduledTasks.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微说下这个类：</p><ol><li>首先这个类实现了 DisposableBean 接口，实现这个接口就重写了 destroy 方法，以便在 Bean 销毁的时候，清除所有的定时任务。</li><li>addCronTask(Runnable, String) 方法用来添加一个定时任务，传两个参数，第一个是 Runnable，也就是我们前面所说的定时任务，第二个则是一个 Cron 表达式。</li><li>addCronTask(CronTask) 方法也用来添加定时任务，添加之前先判断这个定时任务是否已经存在，如果已经存在，就先移除。然后将定时任务存入 scheduledTasks 中，存储的时候，key 就是那个 Runnable 对象，value 则是一个 ScheduledTask 对象。</li><li>ScheduledTask 对象从 scheduleCronTask 方法中获取，<strong>这也是整个系统最最核心的一段代码</strong>，调用 taskScheduler 对象把定时任务添加进去。</li><li>removeCronTask 方法用来移除一个定时任务，移除分为两部分：1. 从 scheduledTasks 集合中找到定时任务并移除；2. 取消定时任务的执行。</li><li>最后的 destroy 方法就是一个常规方法，该移除移除，该清空清空。</li></ol><h3 id="3-6-InitTask"><a href="#3-6-InitTask" class="headerlink" title="3.6 InitTask"></a>3.6 InitTask</h3><p>这是一个处理数据库中已有定时任务的类。当系统启动时，首先从数据库中读取需要定时执行的任务，然后挨个加入定时任务执行器中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    CronTaskRegistrar cronTaskRegistrar;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    SysJobService sysJobService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;SysJob&gt; list = sysJobService.getJobsByStatus(<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (SysJob sysJob : list) &#123;</span><br><span class="line">            cronTaskRegistrar.addCronTask(<span class="hljs-keyword">new</span> SchedulingRunnable(sysJob.getBeanName(), sysJob.getMethodName(), sysJob.getMethodParams()), sysJob.getCronExpression());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查询所有状态为 1 的定时任务。</li><li>遍历第一步查询出来的集合，添加定时任务。</li></ol><p>好啦，这就是整个项目最最核心的配置了，其他的代码都是一些业务层面的代码，乏善可陈，我就不啰嗦啦。</p><h2 id="4-定时任务怎么配"><a href="#4-定时任务怎么配" class="headerlink" title="4. 定时任务怎么配"></a>4. 定时任务怎么配</h2><p>有的小伙伴可能还不知道定时任务怎么配置，我这里稍微说两句。</p><p>项目中提供了如下一个测试类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"schedulingTaskDemo"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchedulingTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">taskWithParams</span><span class="hljs-params">(String params)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"执行有参示例任务："</span> + params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">taskNoParams</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"执行无参示例任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是提前写好的，需要的时候我们配置的定时任务就是这里相关的参数，如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20210913221607.png" alt></p><p>Bean 名称、方法名称都和测试案例中的 Bean 一一对应。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>好啦，是不是很 Easy？小伙伴们赶紧去尝试下吧！</p><p>项目地址：</p><ul><li>GitHub：<a href="https://github.com/lenve/scheduling" target="_blank" rel="noopener">https://github.com/lenve/scheduling</a></li><li>Gitee：<a href="https://gitee.com/lenve/scheduling" target="_blank" rel="noopener">https://gitee.com/lenve/scheduling</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天抽空撸一篇文章，和大家聊一聊上篇文章的可视化定时任务是怎么实现的。&lt;/p&gt;
&lt;p&gt;上篇文章发了后，有不少小伙伴在评论区提出了一些问题，我觉得还挺有意思的，这篇文章应该能解决掉大家的大部分疑惑。&lt;/p&gt;
    
    </summary>
    
      <category term="定时任务" scheme="http://www.javaboy.org/categories/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="定时任务" scheme="http://www.javaboy.org/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>刚出炉热腾腾的定时任务可视化管理系统</title>
    <link href="http://www.javaboy.org/2021/0913/scheduling_system.html"/>
    <id>http://www.javaboy.org/2021/0913/scheduling_system.html</id>
    <published>2021-09-13T13:37:59.000Z</published>
    <updated>2021-10-20T14:12:53.539Z</updated>
    
    <content type="html"><![CDATA[<p>定时任务也算是我们日常开发中比较常见的需求了，市面上也有很多成熟的框架：</p><a id="more"></a><ul><li>quartz</li><li>elastic-job</li><li>xxl-job</li><li>…</li></ul><p>不过小伙伴们知道，其实我们 Spring 框架中也提供了相应的定时任务，这个定时任务通过 <code>@EnableScheduling</code> 注解开启，松哥之前也写过文章和大家分享这个注解的基本用法：</p><ul><li><a href="https://mp.weixin.qq.com/s/_20RYBkjKrB4tdpXI3hBOA" target="_blank" rel="noopener">Spring Boot 中实现定时任务的两种方式!</a></li></ul><p>不过之前的定时任务都是固定的，提前写死的，没法动态配置，前两天有小伙伴问松哥如何实现定时任务的动态配置？</p><p>这个东西要是基于 xxl-job 之类的框架来做其实是比较容易的，不过用 Spring 自带的 <code>@EnableScheduling</code> 注解其实也能实现，而且并不难，松哥基于此火急火燎的写了一个，今天先和大家聊聊大致用法，后面抽空再写一篇文章介绍实现原理。</p><p>项目已开源，项目地址：</p><ul><li><a href="https://github.com/lenve/scheduling" target="_blank" rel="noopener">https://github.com/lenve/scheduling</a></li></ul><h2 id="食用方式"><a href="#食用方式" class="headerlink" title="食用方式"></a>食用方式</h2><ol><li>克隆项目：<code>git clone https://github.com/lenve/scheduling.git</code>。</li><li>本地数据库创建一个名为 <code>scheduling</code> 的库。</li><li>修改配置文件 <code>src/main/resources/application.yaml</code>，主要修改数据库连接的用户名和地址。</li><li>启动项目。</li><li>浏览器访问 <code>http://localhost:8080</code>，可以看到如下页面：</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210910174209.png" alt></p><p>表示启动成功。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ol><li>项目启动时，会自动从数据库中加载状态为 1 的定时任务并开始执行，1 表示处于开启状态的定时任务，0 表示处于禁用状态的定时任务。</li><li>点击页面上的<strong>添加作业</strong>按钮，可以添加一个新的定时任务，新任务的 Bean 名称、方法名称以及方法参数如果和已有的记录相同，则认为是重复作业，重复作业会添加失败。</li></ol><p>添加作业的页面如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210910181820.png" alt></p><p>这里涉及到几个参数，含义如下：</p><ul><li>Bean 名称：这是项目中注入 Spring 的 Bean 名称，测试代码中以 <code>org/javaboy/scheduling02/service/SchedulingTaskDemo.java</code> 为例。</li><li>方法名称：参数 1 中 bean 里边的方法名称。</li><li>方法参数：参数 2 中方法的参数。</li><li>Cron 表达式：定时任务的 Cron 表达式。</li><li>作业状态：开启和禁用两种。开启的话，添加完成后这个定时任务就会开始执行，禁用的话，就单纯只是将记录添加到数据库中。</li></ul><p>作业添加成功提示如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210910182636.png" alt></p><p>作业添加失败提示如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210910181458.png" alt></p><ol start="3"><li>点击作业编辑，可以修改作业的各项数据：</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210910182736.png" alt></p><p>修改后会立马生效。</p><ol start="4"><li>点击作业删除，可以删除一个现有的作业。假如删除的作业正在执行，则先停止该作业，然后删除。</li><li>点击列表中的 switch 按钮也可以切换作业的状态。</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210910183133.png" alt></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>SpringBoot</li><li>Jpa</li><li>MySQL</li><li>Spring Job</li><li>Vue</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这是一个学习的 Demo，并非完整项目，后面松哥会出一篇文章和大家分享具体的实现思路。</p><p>好啦，先说这么多。</p><p>感兴趣的小伙伴赶紧去体验一把吧：</p><ul><li><a href="https://github.com/lenve/scheduling" target="_blank" rel="noopener">https://github.com/lenve/scheduling</a></li><li><a href="https://gitee.com/lenve/scheduling" target="_blank" rel="noopener">https://gitee.com/lenve/scheduling</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定时任务也算是我们日常开发中比较常见的需求了，市面上也有很多成熟的框架：&lt;/p&gt;
    
    </summary>
    
      <category term="定时任务" scheme="http://www.javaboy.org/categories/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="定时任务" scheme="http://www.javaboy.org/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 高可用之如何确保消息成功消费</title>
    <link href="http://www.javaboy.org/2021/0907/rabbitmq.html"/>
    <id>http://www.javaboy.org/2021/0907/rabbitmq.html</id>
    <published>2021-09-07T13:37:42.000Z</published>
    <updated>2021-10-20T14:11:32.870Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前面一篇文章松哥和大家聊了 MQ 高可用之如何确保消息成功发送，各种配置齐上阵，最终确保了消息的成功发送，甚至在一些极端情况下还可能发生同一条消息重复发送的情况，不管怎么样，消息总算发送出去了，如果小伙伴们还没看过上篇文章，建议先看看，再来学习本文：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/hj8iqASSOk2AgdtkuLPCCQ" target="_blank" rel="noopener">四种策略确保 RabbitMQ 消息发送可靠性！你用哪种？</a></li></ul><p>今天我们就来聊一聊消息消费的问题，看看如何确保消息消费成功，并且确保幂等性。</p><h2 id="1-两种消费思路"><a href="#1-两种消费思路" class="headerlink" title="1. 两种消费思路"></a>1. 两种消费思路</h2><p>RabbitMQ 的消息消费，整体上来说有两种不同的思路：</p><ul><li>推（push）：MQ 主动将消息<strong>推送</strong>给消费者，这种方式需要消费者设置一个缓冲区去缓存消息，对于消费者而言，内存中总是有一堆需要处理的消息，所以这种方式的效率比较高，这也是目前大多数应用采用的消费方式。</li><li>拉（pull）：消费者主动从 MQ <strong>拉取</strong>消息，这种方式效率并不是很高，不过有的时候如果服务端需要批量拉取消息，倒是可以采用这种方式。</li></ul><p>两种方式我都举个例子看下。</p><p>先来看推（push）：</p><p>这种方式大家比较常见，就是通过 <code>@RabbitListener</code> 注解去标记消费者，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@RabbitListener</span>(queues = RabbitConfig.JAVABOY_QUEUE_NAME)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"msg = "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当监听的队列中有消息时，就会触发该方法。</p><p>再来看拉（pull）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    Object o = rabbitTemplate.receiveAndConvert(RabbitConfig.JAVABOY_QUEUE_NAME);</span><br><span class="line">    System.out.println(<span class="hljs-string">"o = "</span> + <span class="hljs-keyword">new</span> String(((<span class="hljs-keyword">byte</span>[]) o),<span class="hljs-string">"UTF-8"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 receiveAndConvert 方法，方法参数为队列名称，方法执行完成后，会从 MQ 上拉取一条消息下来，如果该方法返回值为 null，表示该队列上没有消息了。receiveAndConvert 方法有一个重载方法，可以在重载方法中传入一个等待超时时间，例如 3 秒。此时，假设队列中没有消息了，则 receiveAndConvert 方法会阻塞 3 秒，3 秒内如果队列中有了新消息就返回，3 秒后如果队列中还是没有新消息，就返回 null，这个等待超时时间要是不设置的话，默认为 0。</p><p>这是消息两种不同的消费模式。</p><p>如果需要从消息队列中持续获得消息，就可以使用推模式；如果只是单纯的消费一条消息，则使用拉模式即可。<strong>切忌将拉模式放到一个死循环中，变相的订阅消息，这会严重影响 RabbitMQ 的性能。</strong></p><h2 id="2-确保消费成功两种思路"><a href="#2-确保消费成功两种思路" class="headerlink" title="2. 确保消费成功两种思路"></a>2. 确保消费成功两种思路</h2><p>在<a href="https://mp.weixin.qq.com/s/hj8iqASSOk2AgdtkuLPCCQ" target="_blank" rel="noopener">上篇文章</a>中，我们想尽办法确保消息能够发送成功，对于消息消费成功，其实官方提供了相关的机制，我们一起来看下。</p><p>为了保证消息能够可靠的到达消息消费者，RabbitMQ 中提供了消息消费确认机制。当消费者去消费消息的时候，可以通过指定 autoAck 参数来表示消息消费的确认方式。</p><ul><li>当 autoAck 为 false 的时候，此时即使消费者已经收到消息了，RabbitMQ 也不会立马将消息移除，而是等待消费者显式的回复确认信号后，才会将消息打上删除标记，然后再删除。</li><li>当 autoAck 为 true 的时候，此时消息消费者就会自动把发送出去的消息设置为确认，然后将消息移除（从内存或者磁盘中），即使这些消息并没有到达消费者。</li></ul><p>我们来看一张图：</p><p><img src="http://img.itboyhub.com/2021/07/20210902220542.png" alt></p><p>如上图所示，在 RabbitMQ 的 web 管理页面：</p><ul><li>Ready 表示待消费的消息数量。</li><li>Unacked 表示已经发送给消费者但是还没收到消费者 ack 的消息数量。</li></ul><p>这是我们可以从 UI 层面观察消息的消费情况确认情况。</p><p>当我们将 autoAck 设置为 false 的时候，对于 RabbitMQ 而言，消费分成了两个部分：</p><ul><li>待消费的消息</li><li>已经投递给消费者，但是还没有被消费者确认的消息</li></ul><p>换句话说，当设置 autoAck 为 false 的时候，消费者就变得非常从容了，它将有足够的时间去处理这条消息，当消息正常处理完成后，再手动 ack，此时 RabbitMQ 才会认为这条消息消费成功了。如果 RabbitMQ 一直没有收到客户端的反馈，并且此时客户端也已经断开连接了，那么 RabbitMQ 就会将刚刚的消息重新放回队列中，等待下一次被消费。</p><p>综上所述，确保消息被成功消费，无非就是手动 Ack 或者自动 Ack，无他。当然，无论这两种中的哪一种，最终都有可能导致消息被重复消费，所以一般来说我们还需要在处理消息时，解决幂等性问题。</p><h2 id="3-消息拒绝"><a href="#3-消息拒绝" class="headerlink" title="3. 消息拒绝"></a>3. 消息拒绝</h2><p>当客户端收到消息时，可以选择消费这条消息，也可以选择拒绝这条消息。我们来看下拒绝的方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@RabbitListener</span>(queues = RabbitConfig.JAVABOY_QUEUE_NAME)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(Channel channel, Message message)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//获取消息编号</span></span><br><span class="line">        <span class="hljs-keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//拒绝消息</span></span><br><span class="line">            channel.basicReject(deliveryTag, <span class="hljs-keyword">true</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者收到消息之后，可以选择拒绝消费该条消息，拒绝的步骤分两步：</p><ol><li>获取消息编号 deliveryTag。</li><li>调用 basicReject 方法拒绝消息。</li></ol><p>调用 basicReject 方法时，第二个参数是 requeue，即是否重新入队。如果第二个参数为 true，则这条被拒绝的消息会重新进入到消息队列中，等待下一次被消费；如果第二个参数为 false，则这条被拒绝的消息就会被丢掉，不会有新的消费者去消费它了。</p><p>需要注意的是，basicReject 方法一次只能拒绝一条消息。</p><h2 id="4-消息确认"><a href="#4-消息确认" class="headerlink" title="4. 消息确认"></a>4. 消息确认</h2><p>消息确认分为自动确认和手动确认，我们分别来看。</p><h3 id="4-1-自动确认"><a href="#4-1-自动确认" class="headerlink" title="4.1 自动确认"></a>4.1 自动确认</h3><p>先来看看自动确认，在 Spring Boot 中，默认情况下，消息消费就是自动确认的。</p><p>我们来看如下一个消息消费方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@RabbitListener</span>(queues = RabbitConfig.JAVABOY_QUEUE_NAME)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle2</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"msg = "</span> + msg);</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @Componet 注解将当前类注入到 Spring 容器中，然后通过 @RabbitListener 注解来标记一个消息消费方法，默认情况下，消息消费方法自带事务，即如果该方法在执行过程中抛出异常，那么被消费的消息会重新回到队列中等待下一次被消费，如果该方法正常执行完没有抛出异常，则这条消息就算是被消费了。</p><h3 id="4-2-手动确认"><a href="#4-2-手动确认" class="headerlink" title="4.2 手动确认"></a>4.2 手动确认</h3><p>手动确认我又把它分为两种：推模式手动确认与拉模式手动确认。</p><h4 id="4-2-1-推模式手动确认"><a href="#4-2-1-推模式手动确认" class="headerlink" title="4.2.1 推模式手动确认"></a>4.2.1 推模式手动确认</h4><p>要开启手动确认，需要我们首先关闭自动确认，关闭方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br></pre></td></tr></table></figure><p>这个配置表示将消息的确认模式改为手动确认。</p><p>接下来我们来看下消费者中的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = RabbitConfig.JAVABOY_QUEUE_NAME)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle3</span><span class="hljs-params">(Message message,Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-comment">//消息消费的代码写到这里</span></span><br><span class="line">        String s = <span class="hljs-keyword">new</span> String(message.getBody());</span><br><span class="line">        System.out.println(<span class="hljs-string">"s = "</span> + s);</span><br><span class="line">        <span class="hljs-comment">//消费完成后，手动 ack</span></span><br><span class="line">        channel.basicAck(deliveryTag, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="hljs-comment">//手动 nack</span></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            channel.basicNack(deliveryTag, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将消费者要做的事情放到一个 <code>try..catch</code> 代码块中。</p><p>如果消息正常消费成功，则执行 <code>basicAck</code> 完成确认。</p><p>如果消息消费失败，则执行 <code>basicNack</code> 方法，告诉 RabbitMQ 消息消费失败。</p><p>这里涉及到两个方法：</p><ul><li>basicAck：这个是手动确认消息已经成功消费，该方法有两个参数：第一个参数表示消息的 id；第二个参数 multiple 如果为 false，表示仅确认当前消息消费成功，如果为 true，则表示当前消息之前所有未被当前消费者确认的消息都消费成功。</li><li>basicNack：这个是告诉 RabbitMQ 当前消息未被成功消费，该方法有三个参数：第一个参数表示消息的 id；第二个参数 multiple 如果为 false，表示仅拒绝当前消息的消费，如果为 true，则表示拒绝当前消息之前所有未被当前消费者确认的消息；第三个参数 requeue 含义和前面所说的一样，被拒绝的消息是否重新入队。</li></ul><p><strong>当 basicNack 中最后一个参数设置为 false 的时候，还涉及到一个死信队列的问题，这个松哥以后再专门写文章和大家细聊。</strong></p><h4 id="4-2-2-拉模式手动确认"><a href="#4-2-2-拉模式手动确认" class="headerlink" title="4.2.2 拉模式手动确认"></a>4.2.2 拉模式手动确认</h4><p>拉模式手动 ack 比较麻烦一些，在 Spring 中封装的 RabbitTemplate 中并未找到对应的方法，所以我们得用原生的办法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = rabbitTemplate.getConnectionFactory().createConnection().createChannel(<span class="hljs-keyword">true</span>);</span><br><span class="line">    <span class="hljs-keyword">long</span> deliveryTag = <span class="hljs-number">0L</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        GetResponse getResponse = channel.basicGet(RabbitConfig.JAVABOY_QUEUE_NAME, <span class="hljs-keyword">false</span>);</span><br><span class="line">        deliveryTag = getResponse.getEnvelope().getDeliveryTag();</span><br><span class="line">        System.out.println(<span class="hljs-string">"o = "</span> + <span class="hljs-keyword">new</span> String((getResponse.getBody()), <span class="hljs-string">"UTF-8"</span>));</span><br><span class="line">        channel.basicAck(deliveryTag, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            channel.basicNack(deliveryTag, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到的 basicAck 和 basicNack 方法跟前面的一样，我就不再赘述。</p><h2 id="5-幂等性问题"><a href="#5-幂等性问题" class="headerlink" title="5. 幂等性问题"></a>5. 幂等性问题</h2><p>最后我们再来说说消息的幂等性问题。</p><p>大家设想下面一个场景：</p><blockquote><p>消费者在消费完一条消息后，向 RabbitMQ 发送一个 ack 确认，此时由于网络断开或者其他原因导致 RabbitMQ 并没有收到这个 ack，那么此时 RabbitMQ 并不会将该条消息删除，当重新建立起连接后，消费者还是会再次收到该条消息，这就造成了消息的重复消费。同时，由于类似的原因，消息在发送的时候，同一条消息也可能会发送两次（参见<a href="https://mp.weixin.qq.com/s/hj8iqASSOk2AgdtkuLPCCQ" target="_blank" rel="noopener">四种策略确保 RabbitMQ 消息发送可靠性！你用哪种？</a>）。种种原因导致我们在消费消息时，一定要处理好幂等性问题。</p></blockquote><p>幂等性问题的处理倒也不难，基本上都是从业务上来处理，我来大概说说思路。</p><p>采用 Redis，在消费者消费消息之前，现将消息的 id 放到 Redis 中，存储方式如下：</p><ul><li>id-0（正在执行业务）</li><li>id-1（执行业务成功）</li></ul><p>如果 ack 失败，在 RabbitMQ 将消息交给其他的消费者时，先执行 setnx，如果 key 已经存在（说明之前有人消费过该消息），获取他的值，如果是 0，当前消费者就什么都不做，如果是 1，直接 ack。</p><p>极端情况：第一个消费者在执行业务时，出现了死锁，在 setnx 的基础上，再给 key 设置一个生存时间。生产者，发送消息时，指定 messageId。</p><p>当然这只是一个简单思路供大家参考。</p><p>松哥在 vhr 项目中也处理了消息幂等性问题，感兴趣的小伙伴可以查看 vhr 源码（<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>），代码在 mailserver 中。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>好啦，今天就和小伙伴们聊了下 RabbitMQ 中和消息消费相关的几个话题，感兴趣的小伙伴可以实践下哦～</p><p>复制文章标题并在公众号后台回复，可以下载本文案例～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前面一篇文章松哥和大家聊了 MQ 高可用之如何确保消息成功发送，各种配置齐上阵，最终确保了消息的成功发送，甚至在一些极端情况下还可能发生同一条消息重复发送的情况，不管怎么样，消息总算发送出去了，如果小伙伴们还没看过上篇文章，建议先看看，再来学习本文：&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>哪种分布式事务处理方案效率最高？必然是...</title>
    <link href="http://www.javaboy.org/2021/0903/transaction_rabbitmq.html"/>
    <id>http://www.javaboy.org/2021/0903/transaction_rabbitmq.html</id>
    <published>2021-09-03T13:37:19.000Z</published>
    <updated>2021-10-20T14:12:10.911Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前面几篇文章松哥和大家介绍了 Seata 中四种分布式事务处理方案，相信经过前面的几篇文章的学习，大家对于 Seata 中的分布式事务已经非常了解了。还没看过前面文章的小伙伴，可以先看一下：</p><ul><li><a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA" target="_blank" rel="noopener">看了那么多博客，还是不懂 TCC，不妨看看这个案例！</a></li><li><a href="https://mp.weixin.qq.com/s/BJHmVkNrvNL87hBT8DM8vg" target="_blank" rel="noopener">XA 事务水很深，小伙子我怕你把握不住！</a></li><li><a href="https://mp.weixin.qq.com/s/cZabAt7JF4QrQHERHHAWjA" target="_blank" rel="noopener">你这 Saga 事务保“隔离性”吗？</a></li></ul><a id="more"></a><p>不过很多小伙伴看完后感觉 Seata 对于分布式事务的处理，代码虽然简单，但是内部花费在网络上的时间消耗太多了，在高并发场景下，这似乎并不是一种很好的解决方案。</p><p>要说哪种分布式事务处理方案效率高，必然绕不开消息中间件！基于消息中间件的两阶段提交方案，通常用在高并发场景下。这种方式通过牺牲数据的强一致性换取性能的大幅提升，不过实现这种方式的成本和复杂度是比较高的，使用时还要看实际业务情况。</p><p>今天松哥想通过一个简单的案例，来和大家聊一聊如何通过消息中间件来处理分布式事务。</p><h2 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1. 思路分析"></a>1. 思路分析</h2><p>先来说说整体思路。</p><p>有一个名词叫做消息驱动的微服务，相信很多小伙伴都听说过。怎么理解呢？</p><p>在微服务系统中，服务之间的互相调用，我们可以使用 HTTP 的方式，例如 OpenFeign，也可以使用 RPC 的方式，例如 Dubbo，除了这些方案之外，我们也可以使用消息驱动，这是一种典型的响应式系统设计方案。</p><p>在消息驱动的微服务中，服务之间不再互相直接调用，当服务之间需要通信时，就把通信内容发送到消息中间件上，另一个服务则通过监听消息中间件中的消息队列，来完成相应的业务逻辑调用，过程就是这么个过程，并不难，具体怎么玩，我们继续往下看。</p><h2 id="2-业务分析"><a href="#2-业务分析" class="headerlink" title="2. 业务分析"></a>2. 业务分析</h2><p>折腾了半天，后来松哥在网上找到了一个别人写好的例子，我觉得用来演示这个问题特别合适，所以我就没有自己写案例了，直接用别人的代码，我们来逐个分析，跟前面讲分布式事务 Seata 的方式一致。</p><p>首先我们来看如下一张流程图，这是一个用户购票的案例：</p><p><img src="http://img.itboyhub.com/2021/07/20210829194847.png" alt></p><p>当用户想要购买一张票时：</p><ol><li>向新订单队列中写入一条数据。</li><li>Order Service 负责消费这个队列中的消息，完成订单的创建，然后再向新订单缴费队列中写入一条消息。</li><li>User Service 负责消费新订单缴费队列中的消息，在 User Service 中完成对用户账户余额的划扣，然后向新订单转移票队列中写入一条消息。</li><li>Ticket Service 负责消费新订单转移票队列，在 Ticket Service 中完成票的转移，然后发送一条消息给订单完成队列。</li><li>最后 Order Service 中负责监听订单完成队列，处理完成后的订单。</li></ol><p>这就是一个典型的<strong>消息驱动微服务</strong>，也是一个典型的<strong>响应式系统</strong>。在这个系统中，一共有三个服务，分别是：</p><ul><li>Order Service</li><li>User Service</li><li>Ticket Service</li></ul><p>这三个服务之间不会进行任何形式的直接调用，大家有事都是直接发送到消息中间件，其他服务则从消息中间件中获取自己想要的消息然后进行处理。</p><p>具体到我们的实践中，则多了一个检查票是否够用的流程，如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20210829195014.png" alt></p><p>创建订单时，先由 Ticket 服务检查票是否够用，没问题的话再继续发起订单的创建。其他过程我就不说了。</p><p><strong>另外还需要注意，在售票系统中，由于每张票都不同，例如每张票可能有座位啥的，因此一张票在数据库中往往是被设计成一条记录。</strong></p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h2><p>流程我已经说明白了，接下来我们就来看看具体的代码实践。</p><h3 id="3-1-准备数据库"><a href="#3-1-准备数据库" class="headerlink" title="3.1 准备数据库"></a>3.1 准备数据库</h3><p>首先我们准备三个数据库，分别是：</p><ul><li>javaboy_order：订单库，用户创建订单等操作，在这个数据库中完成。</li><li>javaboy_ticket：票务库，这个库中保存着所有的票据信息，每一张票都是一条记录，都保存在这个库中。</li><li>javaboy_user：用户库，这里保存着用户的账户余额以及付款记录等信息。</li></ul><p>每个库中都有各自对应的表，为了操作方便，这些表不用自己创建，将来等项目启动了，利用 JPA 自动创建即可。</p><h3 id="3-2-项目概览"><a href="#3-2-项目概览" class="headerlink" title="3.2 项目概览"></a>3.2 项目概览</h3><p>我们先来整体上看下这个项目，公众号后台回复 <code>mq_tran</code> 可以下载完整代码：</p><p><img src="http://img.itboyhub.com/2021/07/20210831214348.png" alt></p><p>一共有五个服务：</p><ul><li>eureka：注册中心</li><li>order：订单服务</li><li>service：公共模块</li><li>ticket：票务服务</li><li>user：用户服务</li></ul><p>下面分别来说。</p><h3 id="3-3-注册中心"><a href="#3-3-注册中心" class="headerlink" title="3.3 注册中心"></a>3.3 注册中心</h3><p>有人说，都消息驱动了，还要注册中心干嘛？</p><p>消息驱动没错，消息驱动微服务之后每个服务只管把消息往消息中间件上扔，每个服务又只管消费消息中间件上的消息，这个时候对于服务注册中心似乎不是那么强需要。不过在我们这个案例中，消息驱动主要用来处理事务问题，其他常规需求我们还是用 OpenFeign 来处理，所以这里我们依然需要一个注册中心。</p><p>这里的注册中心我就选择常见的 Eureka，省事一些。<strong>由于本文主要是和大家聊分布式事务，所以涉及到微服务的东西我就简单介绍下，不会占用过多篇幅</strong>，如果大家还不熟悉 Spring Cloud 的用法，可以在公众号后台回复 vhr 有一套视频介绍。</p><p>服务注册中心的创建记得加上 Spring Security，将自己的服务注册中心保护起来。</p><p>这块有一个小小的细节和大家多说两句。</p><p>Eureka 用 Spring Security 保护起来之后，以后其他服务注册都是通过 Http Basic 来认证，所以我们要在代码中开启 Http Basic 认证，如下（以前旧版本不需要下面这段代码，但是新版本需要）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and().formLogin().and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-购票服务"><a href="#3-4-购票服务" class="headerlink" title="3.4 购票服务"></a>3.4 购票服务</h3><p>接下来我们就来看看购票服务。</p><p>购票是从下订单开始，所以我们就先从订单服务 order 开始整个流程的分析。</p><h4 id="3-4-1-新订单处理（order）"><a href="#3-4-1-新订单处理（order）" class="headerlink" title="3.4.1 新订单处理（order）"></a>3.4.1 新订单处理（order）</h4><p>当用户发起一个购票请求后，这个请求发送到 order 服务上，order 服务首先会向 <code>order:new</code> 队列发送一条消息，开启一个订单的处理流程。代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">""</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(@RequestBody OrderDTO dto)</span> </span>&#123;</span><br><span class="line">    dto.setUuid(UUID.randomUUID().toString());</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:new"</span>, dto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面设置的 UUID 是整个订单在处理过程中的一个唯一标志符，也算是一条主线。</p><p><code>order:new</code> 队列中的消息将被 ticket 服务消费，ticket 服务消费 <code>order:new</code> 中的消息，并进行锁票操作（锁票的目的防止有两个消费同时购买同一张票），锁票成功后，ticket 服务将向 <code>order:locked</code> 队列发送一条消息，表示锁票成功；否则向 <code>order:fail</code> 队列发送一条消息表示锁票失败。</p><p>这里的 OrderDTO 对象将贯穿整个购票过程。</p><h4 id="3-4-2-锁票（ticket）"><a href="#3-4-2-锁票（ticket）" class="headerlink" title="3.4.2 锁票（ticket）"></a>3.4.2 锁票（ticket）</h4><p>锁票操作是在 ticket 服务中完成的，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:new"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleTicketLock</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get new order for ticket lock:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-keyword">int</span> lockCount = ticketRepository.lockTicket(msg.getCustomerId(), msg.getTicketNum());</span><br><span class="line">    <span class="hljs-keyword">if</span> (lockCount == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        msg.setStatus(<span class="hljs-string">"TICKET_LOCK_FAIL"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="hljs-string">"order:fail"</span>, msg);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        msg.setStatus(<span class="hljs-string">"TICKET_LOCKED"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="hljs-string">"order:locked"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用 lockTicket 方法去数据库中锁票，所谓的锁票就是将要购买的票的 lock_user 字段设置为 customer_id（购买者的 id）。</p><p>如果锁票成功（即数据库修改成功），设置 msg 的状态为 <code>TICKET_LOCKED</code>，同时发送消息到 <code>order:locked</code> 队列，表示锁票成功。</p><p>如果锁票失败（即数据库修改失败），设置 msg 的状态为 <code>TICKET_LOCK_FAIL</code>，同时发送消息到 <code>order:fail</code> 队列，表示锁票失败。</p><h4 id="3-4-2-锁票成功（order）"><a href="#3-4-2-锁票成功（order）" class="headerlink" title="3.4.2 锁票成功（order）"></a>3.4.2 锁票成功（order）</h4><p>接下来，由 order 服务消费 <code>order:locked</code> 队列中的消息，也就是锁票成功后接下来的操作。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:locked"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get new order to create:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-keyword">if</span> (orderRepository.findOneByUuid(msg.getUuid()) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"Msg already processed:&#123;&#125;"</span>, msg);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        Order order = newOrder(msg);</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        msg.setId(order.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    msg.setStatus(<span class="hljs-string">"NEW"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:pay"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁票成功后，先根据订单的 UUID 去订单数据库查询，是否已经有订单记录了，如果有，说明这条消息已经被处理了，可以防止订单的重复处理（这块主要是解决幂等性问题）。</p><p>如果订单还没有被处理，则创建一个新的订单对象，并保存到数据库中，创建新订单对象的时候，需要设置订单的 status 为 NEW。</p><p>最后设置 msg 的 status 为 NEW，然后向 <code>order:pay</code> 队列发送一条消息开启付款流程，付款是由 user 服务提供的。user 服务中会检查用户的账户余额是否够用，如果不够用，就会发送消息到 <code>order:ticket_error</code> 队列，表示订票失败；如果余额够用，则进行正常的付款操作，并在付款成功后发送消息到 <code>order:ticket_move</code> 队列，开启票的转移。</p><h4 id="3-4-3-缴费（user）"><a href="#3-4-3-缴费（user）" class="headerlink" title="3.4.3 缴费（user）"></a>3.4.3 缴费（user）</h4><p>锁票成功后，接下来就是付费了，付费服务由 user 提供。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:pay"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get new order to pay:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-comment">// 先检查payInfo判断重复消息。</span></span><br><span class="line">    PayInfo pay = payInfoRepository.findOneByOrderId(msg.getId());</span><br><span class="line">    <span class="hljs-keyword">if</span> (pay != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        LOG.warn(<span class="hljs-string">"Order already paid, duplicated message."</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Customer customer = customerRepository.getById(msg.getCustomerId());</span><br><span class="line">    <span class="hljs-keyword">if</span> (customer.getDeposit() &lt; msg.getAmount()) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"No enough deposit, need amount:&#123;&#125;"</span>, msg.getAmount());</span><br><span class="line">        msg.setStatus(<span class="hljs-string">"NOT_ENOUGH_DEPOSIT"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="hljs-string">"order:ticket_error"</span>, msg);</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pay = <span class="hljs-keyword">new</span> PayInfo();</span><br><span class="line">    pay.setOrderId(msg.getId());</span><br><span class="line">    pay.setAmount(msg.getAmount());</span><br><span class="line">    pay.setStatus(<span class="hljs-string">"PAID"</span>);</span><br><span class="line">    payInfoRepository.save(pay);</span><br><span class="line">    customerRepository.charge(msg.getCustomerId(), msg.getAmount());</span><br><span class="line">    msg.setStatus(<span class="hljs-string">"PAID"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:ticket_move"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的执行步骤如下：</p><ol><li>首先根据订单 id 去查找付款信息，检查当前订单是否已经完成付款，如果已经完成服务，则直接 return，这一步也是为了处理幂等性问题。</li><li>根据顾客的 id，查找到顾客的完整信息，包括顾客的账户余额。</li><li>检查顾客的账户余额是否足够支付票价，如果不够，则设置 msg 的 status 为 NOT_ENOUGH_DEPOSIT，同时向 <code>order:ticket_error</code> 队列发送消息，表示订票失败。</li><li>如果顾客账户余额足够支付票价，则创建一个 PayInfo 对象，设置相关的支付信息，并存入 <code>pay_info</code> 表中。</li><li>调用 charge 方法完成顾客账户余额的扣款。</li><li>发送消息到 <code>order:ticket_move</code> 队列中，开启交票操作。</li></ol><h4 id="3-4-4-交票（ticket）"><a href="#3-4-4-交票（ticket）" class="headerlink" title="3.4.4 交票（ticket）"></a>3.4.4 交票（ticket）</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:ticket_move"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleTicketMove</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get new order for ticket move:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-keyword">int</span> moveCount = ticketRepository.moveTicket(msg.getCustomerId(), msg.getTicketNum());</span><br><span class="line">    <span class="hljs-keyword">if</span> (moveCount == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"Ticket already transferred."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg.setStatus(<span class="hljs-string">"TICKET_MOVED"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:finish"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 moveTicket 方法完成交票操作，也就是设置 ticket 表中票的 owner 为 customerId。</p><p>交票成功后，发送消息到 <code>order:finish</code> 队列，表示交票完成。</p><h4 id="3-4-5-订单完成（order）"><a href="#3-4-5-订单完成（order）" class="headerlink" title="3.4.5 订单完成（order）"></a>3.4.5 订单完成（order）</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:finish"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleFinish</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get finished order:&#123;&#125;"</span>, msg);</span><br><span class="line">    Order order = orderRepository.getById(msg.getId());</span><br><span class="line">    order.setStatus(<span class="hljs-string">"FINISH"</span>);</span><br><span class="line">    orderRepository.save(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理就比较简单，订单完成后，就设置订单的状态为 FINISH 即可。</p><p>上面介绍的是一条主线，顺利的话，消息顺着这条线走一遍，一个订单就处理完成了。</p><p>不顺利的话，就有各种幺蛾子，我们分别来看。</p><h4 id="3-4-6-锁票失败（order）"><a href="#3-4-6-锁票失败（order）" class="headerlink" title="3.4.6 锁票失败（order）"></a>3.4.6 锁票失败（order）</h4><p>锁票是在 ticket 服务中完成的，如果锁票失败，就会直接向 <code>order:fail</code> 队列发送消息，该队列的消息由 order 服务负责消费。</p><h4 id="3-4-7-扣款失败（ticket）"><a href="#3-4-7-扣款失败（ticket）" class="headerlink" title="3.4.7 扣款失败（ticket）"></a>3.4.7 扣款失败（ticket）</h4><p>扣款操作是在 user 中完成的，扣款失败就会向 <code>order:ticket_error</code> 队列中发送消息，该队列的消息由 ticket 服务负责消费。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:ticket_error"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get order error for ticket unlock:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-keyword">int</span> count = ticketRepository.unMoveTicket(msg.getCustomerId(), msg.getTicketNum());</span><br><span class="line">    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"Ticket already unlocked:"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    count = ticketRepository.unLockTicket(msg.getCustomerId(), msg.getTicketNum());</span><br><span class="line">    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"Ticket already unmoved, or not moved:"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:fail"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当扣款失败的时候，做三件事：</p><ol><li>撤销票的转移，也就是把票的 owner 字段重新置为 null。</li><li>撤销锁票，也就是把票的 <code>lock_user</code> 字段重新置为 null。</li><li>向 <code>order:fail</code> 队列发送订单失败的消息。</li></ol><h4 id="3-4-8-下单失败（order）"><a href="#3-4-8-下单失败（order）" class="headerlink" title="3.4.8 下单失败（order）"></a>3.4.8 下单失败（order）</h4><p>下单失败的处理在 order 服务中，有三种情况会向 <code>order:fail</code> 队列发送消息：</p><ol><li>锁票失败</li><li>扣款失败（客户账户余额不足）</li><li>订单超时</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:fail"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleFailed</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get failed order:&#123;&#125;"</span>, msg);</span><br><span class="line">    Order order;</span><br><span class="line">    <span class="hljs-keyword">if</span> (msg.getId() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        order = newOrder(msg);</span><br><span class="line">        order.setReason(<span class="hljs-string">"TICKET_LOCK_FAIL"</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        order = orderRepository.getById(msg.getId());</span><br><span class="line">        <span class="hljs-keyword">if</span> (msg.getStatus().equals(<span class="hljs-string">"NOT_ENOUGH_DEPOSIT"</span>)) &#123;</span><br><span class="line">            order.setReason(<span class="hljs-string">"NOT_ENOUGH_DEPOSIT"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    order.setStatus(<span class="hljs-string">"FAIL"</span>);</span><br><span class="line">    orderRepository.save(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的具体处理逻辑如下：</p><ol><li>首先查看是否有订单 id，如果连订单 id 都没有，就说明是锁票失败，给订单设置 reason 属性的值为<code>TICKET_LOCK_FAIL</code>。</li><li>如果有订单 id，则根据 id 查询订单信息，并判断订单状态是否为 <code>NOT_ENOUGH_DEPOSIT</code>，这个表示扣款失败，如果订单状态是 <code>NOT_ENOUGH_DEPOSIT</code>，则设置失败的 reason 也为此。</li><li>最后设置订单状态为 FAIL，然后更新数据库中的订单信息即可。</li></ol><h4 id="3-4-9-订单超时（order）"><a href="#3-4-9-订单超时（order）" class="headerlink" title="3.4.9 订单超时（order）"></a>3.4.9 订单超时（order）</h4><p>order 服务中还有一个定时任务，定时去数据库中捞取那些处理失败的订单，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Scheduled</span>(fixedDelay = <span class="hljs-number">10000L</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkInvalidOrder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ZonedDateTime checkTime = ZonedDateTime.now().minusMinutes(<span class="hljs-number">1L</span>);</span><br><span class="line">    List&lt;Order&gt; orders = orderRepository.findAllByStatusAndCreatedDateBefore(<span class="hljs-string">"NEW"</span>, checkTime);</span><br><span class="line">    orders.stream().forEach(order -&gt; &#123;</span><br><span class="line">        LOG.error(<span class="hljs-string">"Order timeout:&#123;&#125;"</span>, order);</span><br><span class="line">        OrderDTO dto = <span class="hljs-keyword">new</span> OrderDTO();</span><br><span class="line">        dto.setId(order.getId());</span><br><span class="line">        dto.setTicketNum(order.getTicketNum());</span><br><span class="line">        dto.setUuid(order.getUuid());</span><br><span class="line">        dto.setAmount(order.getAmount());</span><br><span class="line">        dto.setTitle(order.getTitle());</span><br><span class="line">        dto.setCustomerId(order.getCustomerId());</span><br><span class="line">        dto.setStatus(<span class="hljs-string">"TIMEOUT"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="hljs-string">"order:ticket_error"</span>, dto);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里是去数据库中捞取那些状态为 NEW 并且是 1 分钟之前的订单，根据前面的分析，当锁票成功后，就会将订单的状态设置为 NEW 并且存入数据库中。换言之，当锁票成功一分钟之后，这张票还没有卖掉，就设置订单超时，同时向 <code>order:ticket_error</code> 队列发送一条消息，这条消息在 ticket 服务中被消费，最终完成撤销交票、撤销锁票等操作。</p><p>这就是大致的代码处理流程。</p><p>再来回顾一下前面那张图：</p><p><img src="http://img.itboyhub.com/2021/07/20210829195014.png" alt></p><p>结合着代码来看这张图是不是就很容易懂了。</p><h3 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h3><p>接下来我们来进行一个简单的测试。</p><p>先来一个订票失败的测试，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210901194732.png" alt></p><p>由于用户只有 1000 块钱，这张票要 10000，所以购票必然失败。请求执行成功后，我们查看 order 表，多了如下一条记录：</p><p><img src="http://img.itboyhub.com/2021/07/20210901194945.png" alt></p><p>可以看到，订单失败的理由就是账户余额不足。此时查看 ticket 和 user 表，发现都完好如初（如果需要，则已经反向补偿了）。</p><p>接下来我们手动给 ticket 表中 lock_user 字段设置一个值，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210901195235.png" alt></p><p>这个表示这张票已经被人锁定了。</p><p>然后我们发起一次购票请求（这次可以把金额设置到合理范围，其实不设置也行，反正这次失败还没走到付款这一步）：</p><p><img src="http://img.itboyhub.com/2021/07/20210901195356.png" alt></p><p>请求发送成功后，接下来我们去查看 order 表，多了如下一条记录：</p><p><img src="http://img.itboyhub.com/2021/07/20210901195546.png" alt></p><p>可以看到，这次下单失败的理由是锁票失败。此时查看 ticket 和 user 表，发现都完好如初（如果需要，则已经反向补偿了）。</p><p>最后再来一次成功测试，先把 ticket 表中的 <code>lock_user</code> 字段置空，然后发送如下请求：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200004.png" alt></p><p>这次购票成功，查看 ticket 表，发票已经票有所属：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200110.png" alt></p><p>查看订单表：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200403.png" alt></p><p>可以多了一条成功的购票记录。</p><p>查看用户表：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200443.png" alt></p><p>用户账户已扣款。</p><p>查看支付记录表：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200516.png" alt></p><p>可以看到已经有了支付记录。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>整体上来说，上面这个案例，技术上并没有什么难的，复杂之处在于设计。一开始要设计好消息的处理流程以及消息处理失败后如何进行补偿，这个是比较考验大家技术的。</p><p>另外上面案例中，消息的发送和消费都用到了 RabbitMQ 中的事务机制（确保消息消费成功）以及 Spring 中的事务机制（确保消息发送和数据保存同时成功），这些我就不再赘述了。</p><p>总之，通过消息中间件处理分布式事务，这种方式通过牺牲数据的强一致性换取性能的大幅提升，但是实现这种方式的成本和复杂度是比较高的，使用时还要看实际业务情况。</p><p>好啦，小伙伴们有什么想说的欢迎留言讨论～</p><p>公众号后台回复 <code>mq_tran</code> 可以下载上面案例的完整代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前面几篇文章松哥和大家介绍了 Seata 中四种分布式事务处理方案，相信经过前面的几篇文章的学习，大家对于 Seata 中的分布式事务已经非常了解了。还没看过前面文章的小伙伴，可以先看一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五分钟带你体验一把分布式事务！so easy！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;看了那么多博客，还是不懂 TCC，不妨看看这个案例！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BJHmVkNrvNL87hBT8DM8vg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XA 事务水很深，小伙子我怕你把握不住！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/cZabAt7JF4QrQHERHHAWjA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;你这 Saga 事务保“隔离性”吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="http://www.javaboy.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://www.javaboy.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="消息驱动" scheme="http://www.javaboy.org/tags/%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>四个案例看懂 MySQL 事务隔离级别</title>
    <link href="http://www.javaboy.org/2021/0830/mysql_isolation.html"/>
    <id>http://www.javaboy.org/2021/0830/mysql_isolation.html</id>
    <published>2021-08-30T13:36:55.000Z</published>
    <updated>2021-10-20T14:12:47.865Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>很多小伙伴对 MySQL 的隔离级别一直心存疑惑，其实这个问题一点都不难，关键看怎么讲！单纯的看理论，绝对让你晕头转向，但是，如果我们通过几个实际的 SQL 来演示一些，大家就会发现这玩意原来这么简单！</p><p>今天松哥想通过几个简单的案例，来和大家演示一下 MySQL 中的事务隔离级别问题。</p><a id="more"></a><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1. 理论"></a>1. 理论</h2><p>MySQL 中事务的隔离级别一共分为四种，分别如下：</p><ul><li>序列化（SERIALIZABLE）</li><li>可重复读（REPEATABLE READ）</li><li>提交读（READ COMMITTED）</li><li>未提交读（READ UNCOMMITTED）</li></ul><p>四种不同的隔离级别含义分别如下：</p><ol><li>SERIALIZABLE</li></ol><blockquote><p>如果隔离级别为序列化，则用户之间通过一个接一个顺序地执行当前的事务，这种隔离级别提供了事务之间最大限度的隔离。</p></blockquote><ol start="2"><li>REPEATABLE READ</li></ol><blockquote><p>在可重复读在这一隔离级别上，事务不会被看成是一个序列。不过，当前正在执行事务的变化仍然不能被外部看到，也就是说，如果用户在另外一个事务中执行同条 SELECT 语句数次，结果总是相同的。（因为正在执行的事务所产生的数据变化不能被外部看到）。</p></blockquote><ol start="3"><li>READ COMMITTED</li></ol><blockquote><p>READ COMMITTED 隔离级别的安全性比 REPEATABLE READ 隔离级别的安全性要差。处于 READ COMMITTED 级别的事务可以看到其他事务对数据的修改。也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个 SELECT 语句可能返回不同的结果。</p></blockquote><ol start="4"><li>READ UNCOMMITTED</li></ol><blockquote><p>READ UNCOMMITTED 提供了事务之间最小限度的隔离。除了容易产生虚幻的读操作和不能重复的读操作外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，这就导致了大量的数据变化。</p></blockquote><p><strong>在 MySQL 数据库种，默认的事务隔离级别是 REPEATABLE READ</strong></p><h2 id="2-SQL-实践"><a href="#2-SQL-实践" class="headerlink" title="2. SQL 实践"></a>2. SQL 实践</h2><p>接下来通过几条简单的 SQL 向读者验证上面的理论。</p><h3 id="2-1-查看隔离级别"><a href="#2-1-查看隔离级别" class="headerlink" title="2.1 查看隔离级别"></a>2.1 查看隔离级别</h3><p>通过如下 SQL 可以查看数据库实例默认的全局隔离级别和当前 session 的隔离级别：</p><p>MySQL8 之前使用如下命令查看 MySQL 隔离级别：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> @@GLOBAL.tx_isolation, @@tx_isolation;</span><br></pre></td></tr></table></figure><p>查询结果如图： </p><p><img src="http://img.itboyhub.com/2021/07/20210826193903.png" alt></p><p>可以看到，默认的隔离级别为 REPEATABLE-READ，全局隔离级别和当前会话隔离级别皆是如此。</p><p><strong>MySQL8 开始，通过如下命令查看 MySQL 默认隔离级别</strong>：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> @@GLOBAL.transaction_isolation, @@transaction_isolation;</span><br></pre></td></tr></table></figure><p>就是关键字变了，其他都一样。</p><p>通过如下命令可以修改隔离级别（建议开发者在修改时修改当前 session 隔离级别即可，不用修改全局的隔离级别）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure><p>上面这条 SQL 表示将当前 session 的数据库隔离级别设置为 READ UNCOMMITTED，设置成功后，再次查询隔离级别，发现当前 session 的隔离级别已经变了，如图1-2：</p><p><img src="http://img.itboyhub.com/2021/07/20210826194455.png" alt></p><p><strong>注意，如果只是修改了当前 session 的隔离级别，则换一个 session 之后，隔离级别又会恢复到默认的隔离级别，所以我们测试时，修改当前 session 的隔离级别即可。</strong></p><h3 id="2-2-READ-UNCOMMITTED"><a href="#2-2-READ-UNCOMMITTED" class="headerlink" title="2.2 READ UNCOMMITTED"></a>2.2 READ UNCOMMITTED</h3><h4 id="2-2-1-准备测试数据"><a href="#2-2-1-准备测试数据" class="headerlink" title="2.2.1 准备测试数据"></a>2.2.1 准备测试数据</h4><p>READ UNCOMMITTED 是最低隔离级别，这种隔离级别中存在<strong>脏读、不可重复读以及幻象读</strong>问题，所以这里我们先来看这个隔离级别，借此大家可以搞懂这三个问题到底是怎么回事。</p><p>下面分别予以介绍。</p><p>首先创建一个简单的表，预设两条数据，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210826200353.png" alt></p><p>表的数据很简单，有 javaboy 和 itboyhub 两个用户，两个人的账户各有 1000 人民币。现在模拟这两个用户之间的一个转账操作。</p><p><strong>注意，如果读者使用的是 Navicat 的话，不同的查询窗口就对应了不同的 session，如果读者使用了 SQLyog 的话，不同查询窗口对应同一个 session，因此如果使用 SQLyog，需要读者再开启一个新的连接，在新的连接中进行查询操作。</strong></p><h4 id="2-2-2-脏读"><a href="#2-2-2-脏读" class="headerlink" title="2.2.2 脏读"></a>2.2.2 脏读</h4><p>一个事务读到另外一个事务还没有提交的数据，称之为脏读。具体操作如下：</p><ol><li>首先打开两个SQL操作窗口，假设分别为 A 和 B，在 A 窗口中输入如下几条 SQL （输入完成后不用执行）：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">set</span> balance=balance+<span class="hljs-number">100</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'javaboy'</span>;</span><br><span class="line"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">set</span> balance=balance<span class="hljs-number">-100</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'itboyhub'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 B 窗口执行如下 SQL，修改默认的事务隔离级别为 READ UNCOMMITTED，如下：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure><ol start="3"><li>接下来在 B 窗口中输入如下 SQL，输入完成后，首先执行第一行开启事务（注意只需要执行一行即可）：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>接下来执行 A 窗口中的前两条 SQL，即开启事务，给 javaboy 这个账户添加 100 元。</p></li><li><p>进入到 B 窗口，执行 B 窗口的第二条查询 SQL（SELECT * from user;），结果如下：</p></li></ol><p><img src="http://img.itboyhub.com/2021/07/20210826201458.png" alt></p><p>可以看到，A 窗口中的事务，虽然还未提交，但是 B 窗口中已经可以查询到数据的相关变化了。</p><p>这就是<strong>脏读</strong>问题。</p><h4 id="2-2-3-不可重复读"><a href="#2-2-3-不可重复读" class="headerlink" title="2.2.3 不可重复读"></a>2.2.3 不可重复读</h4><p>不可重复读是指一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。具体操作步骤如下（操作之前先将两个账户的钱都恢复为1000）：</p><ol><li><p>首先打开两个查询窗口 A 和 B ，并且将 B 的数据库事务隔离级别设置为 READ UNCOMMITTED。具体 SQL 参考上文，这里不赘述。</p></li><li><p>在 B 窗口中输入如下 SQL，然后只执行前两条 SQL 开启事务并查询 javaboy 的账户：</p></li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'javaboy'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>前两条 SQL 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210826201858.png" alt></p><ol start="3"><li>在 A 窗口中执行如下 SQL，给 javaboy 这个账户添加 100 块钱，如下：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">set</span> balance=balance+<span class="hljs-number">100</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'javaboy'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>4.再次回到 B 窗口，执行 B 窗口的第二条 SQL 查看 javaboy 的账户，结果如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210826202036.png" alt></p><p>javaboy 的账户已经发生了变化，即前后两次查看 javaboy 账户，结果不一致，这就是<strong>不可重复读</strong>。</p><p><strong>和脏读的区别在于，脏读是看到了其他事务未提交的数据，而不可重复读是看到了其他事务已经提交的数据（由于当前 SQL 也是在事务中，因此有可能并不想看到其他事务已经提交的数据）。</strong></p><h4 id="2-2-4-幻象读"><a href="#2-2-4-幻象读" class="headerlink" title="2.2.4 幻象读"></a>2.2.4 幻象读</h4><p>幻象读和不可重复读非常像，看名字就是产生幻觉了。</p><p>我举一个简单例子。</p><p>在 A 窗口中输入如下 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">account</span>(<span class="hljs-keyword">name</span>,balance) <span class="hljs-keyword">values</span>(<span class="hljs-string">'zhangsan'</span>,<span class="hljs-number">1000</span>);</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>然后在 B 窗口输入如下 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span>;</span><br><span class="line"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'zhangsan'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>我们执行步骤如下：</p><ol><li>首先执行 B 窗口的前两行，开启一个事务，同时查询数据库中的数据，此时查询到的数据只有 javaboy 和 itboyhub。</li><li>执行 A 窗口的前两行，向数据库中添加一个名为 zhangsan 的用户，注意不用提交事务。</li><li>执行 B 窗口的第二行，由于脏读问题，此时可以查询到 zhangsan 这个用户。</li><li>执行 B 窗口的第三行，去删除 name 为 zhangsan 的记录，这个时候删除就会出问题，虽然在 B 窗口中可以查询到 zhangsan，但是这条记录还没有提交，是因为脏读的原因才看到了，所以是没法删除的。此时就产生了幻觉，明明有个 zhangsan，却无法删除。</li></ol><p>这就是<strong>幻读</strong>。</p><p>看了上面的案例，大家应该明白了<strong>脏读</strong>、<strong>不可重复读</strong>以及<strong>幻读</strong>各自是什么含义了。</p><h3 id="2-3-READ-COMMITTED"><a href="#2-3-READ-COMMITTED" class="headerlink" title="2.3 READ COMMITTED"></a>2.3 READ COMMITTED</h3><p>和 READ UNCOMMITTED 相比，READ COMMITTED 主要解决了脏读的问题，对于不可重复读和幻象读则未解决。</p><p>将事务的隔离级别改为 <code>READ COMMITTED</code> 之后，重复上面关于脏读案例的测试，发现已经不存在脏读问题了；重复上面关于不可重复读案例的测试，发现不可重复读问题依然存在。</p><p>上面那个案例不适用于幻读的测试，我们换一个幻读的测试案例。</p><p>还是两个窗口 A 和 B，将 B 窗口的隔离级别改为 <code>READ COMMITTED</code>，</p><p>然后在 A 窗口输入如下测试 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">account</span>(<span class="hljs-keyword">name</span>,balance) <span class="hljs-keyword">values</span>(<span class="hljs-string">'zhangsan'</span>,<span class="hljs-number">1000</span>);</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>在 B 窗口输入如下测试 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span>;</span><br><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">account</span>(<span class="hljs-keyword">name</span>,balance) <span class="hljs-keyword">values</span>(<span class="hljs-string">'zhangsan'</span>,<span class="hljs-number">1000</span>);</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>测试方式如下：</p><ol><li>首先执行 B 窗口的前两行 SQL，开启事务并查询数据，此时查到的只有 javaboy 和 itboyhub 两个用户。</li><li>执行 A 窗口的前两行 SQL，插入一条记录，但是并不提交事务。</li><li>执行 B 窗口的第二行 SQL，由于现在已经没有了脏读问题，所以此时查不到 A 窗口中添加的数据。</li><li>执行 B 窗口的第三行 SQL，由于 name 字段唯一，因此这里会无法插入。此时就产生幻觉了，明明没有 zhangsan 这个用户，却无法插入 zhangsan。</li></ol><h3 id="2-4-REPEATABLE-READ"><a href="#2-4-REPEATABLE-READ" class="headerlink" title="2.4 REPEATABLE READ"></a>2.4 REPEATABLE READ</h3><p>和 READ COMMITTED 相比，REPEATABLE READ 进一步解决了不可重复读的问题，但是幻象读则未解决。</p><p>REPEATABLE READ 中关于幻读的测试和上一小节基本一致，不同的是第二步中执行完插入 SQL 后记得提交事务。</p><p>由于 REPEATABLE READ 已经解决了不可重复读，因此第二步即使提交了事务，第三步也查不到已经提交的数据，第四步继续插入就会出错。</p><p><strong>注意，REPEATABLE READ 也是 InnoDB 引擎的默认数据库事务隔离级别</strong></p><h3 id="2-5-SERIALIZABLE"><a href="#2-5-SERIALIZABLE" class="headerlink" title="2.5 SERIALIZABLE"></a>2.5 SERIALIZABLE</h3><p>SERIALIZABLE 提供了事务之间最大限度的隔离，在这种隔离级别中，事务一个接一个顺序的执行，不会发生脏读、不可重复读以及幻象读问题，最安全。</p><p>如果设置当前事务隔离级别为 SERIALIZABLE，那么此时开启其他事务时，就会阻塞，必须等当前事务提交了，其他事务才能开启成功，因此前面的脏读、不可重复读以及幻象读问题这里都不会发生。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>总的来说，隔离级别和脏读、不可重复读以及幻象读的对应关系如下：</p><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻象读</th></tr></thead><tbody><tr><td style="text-align:left">READ UNCOMMITTED</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">READ COMMITED</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">REPEATABLE READ</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td></tr></tbody></table><p>性能关系如图：</p><p><img src="http://img.itboyhub.com/2021/07/1-72222.png" alt></p><p>好了，这篇文章就和小伙伴们先说这么多，大家不妨写几行 SQL 试一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;很多小伙伴对 MySQL 的隔离级别一直心存疑惑，其实这个问题一点都不难，关键看怎么讲！单纯的看理论，绝对让你晕头转向，但是，如果我们通过几个实际的 SQL 来演示一些，大家就会发现这玩意原来这么简单！&lt;/p&gt;
&lt;p&gt;今天松哥想通过几个简单的案例，来和大家演示一下 MySQL 中的事务隔离级别问题。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://www.javaboy.org/categories/mysql/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="事务" scheme="http://www.javaboy.org/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
</feed>
