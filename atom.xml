<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2022-04-05T12:16:03.792Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 表分区？涨知识了！</title>
    <link href="http://www.javaboy.org/2022/0322/mysql_table_partitioning.html"/>
    <id>http://www.javaboy.org/2022/0322/mysql_table_partitioning.html</id>
    <published>2022-03-22T10:42:33.000Z</published>
    <updated>2022-04-05T12:16:03.792Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>松哥之前写过文章跟大家介绍过用 MyCat 实现 MySQL 的分库分表，不知道有没有小伙伴研究过，MySQL 其实也自带了分区功能，我们可以创建一个带有分区的表，而且不需要借助任何外部工具，今天我们就一起来看看。</p><a id="more"></a><h2 id="1-什么是表分区"><a href="#1-什么是表分区" class="headerlink" title="1. 什么是表分区"></a>1. 什么是表分区</h2><p>小伙伴们知道，MySQL 数据库中的数据是以文件的形势存在磁盘上的，默认放在 <code>/var/lib/mysql/</code> 目录下面，我们可以通过 <code>show variables like &#39;%datadir%&#39;;</code> 命令来查看：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220307225420.png" alt></p><p>我们进入到这个目录下，就可以看到我们定义的所有数据库了，一个数据库就是一个文件夹，一个库中，有其对应的表的信息，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220307225815.png" alt></p><p>在 MySQL 中，如果存储引擎是 MyISAM，那么在 data 目录下会看到 3 类文件：<code>.frm</code>、<code>.myi</code>、<code>.myd</code>，作用如下：</p><ol><li><code>*.frm</code>：这个是表定义，是描述表结构的文件。</li><li><code>*.myd</code>：这个是数据信息文件，是表的数据文件。</li><li><code>*.myi</code>：这个是索引信息文件。</li></ol><p>如果存储引擎是 <code>InnoDB</code>, 那么在 data 目录下会看到两类文件：<code>.frm</code>、<code>.ibd</code>，作用分别如下：</p><ol><li><code>*.frm</code>：表结构文件。</li><li><code>*.ibd</code>：表数据和索引的文件。</li></ol><p>无论是哪种存储引擎，只要一张表的数据量过大，就会导致 <code>*.myd</code>、<code>*.myi</code> 以及 <code>*.ibd</code> 文件过大，数据的查找就会变的很慢。</p><p>为了解决这个问题，我们可以利用 MySQL 的分区功能，在物理上将这一张表对应的文件，分割成许多小块，如此，当我们查找一条数据时，就不用在某一个文件中进行整个遍历了，我们只需要知道这条数据位于哪一个数据块，然后在那一个数据块上查找就行了；另一方面，如果一张表的数据量太大，可能一个磁盘放不下，这个时候，通过表分区我们就可以把数据分配到不同的磁盘里面去。</p><p>MySQL 从 5.1 开始添加了对分区的支持，分区的过程是将一个表或索引分解为多个更小、更可管理的部分。对于开发者而言，分区后的表使用方式和不分区基本上还是一模一样，只不过在物理存储上，原本该表只有一个数据文件，现在变成了多个，每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</p><p>需要注意的是，分区功能并不是在存储引擎层完成的，常见的存储引擎如 <code>InnoDB</code>、<code>MyISAM</code>、<code>NDB</code> 等都支持分区。但并不是所有的存储引擎都支持，如 <code>CSV</code>、<code>FEDORATED</code>、<code>MERGE</code> 等就不支持分区，因此在使用此分区功能前，应该对选择的存储引擎对分区的支持有所了解。</p><h2 id="2-分区的两种方式"><a href="#2-分区的两种方式" class="headerlink" title="2. 分区的两种方式"></a>2. 分区的两种方式</h2><p>不同于 MyCat 中既可以垂直切分又可以水平切分，MySQL 数据库支持的分区类型为水平分区，它不支持垂直分区。</p><h3 id="2-1-水平切分"><a href="#2-1-水平切分" class="headerlink" title="2.1 水平切分"></a>2.1 水平切分</h3><p>先来一张简单的示意图，大家感受一下什么是水平切分：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/5-1-20210128205545140.png" alt></p><p>假设我的 DB 中有 table-1、table-2 以及 table-3 三张表，水平切分就是拿着我 40 米大刀，对准黑色的线条，砍一剑或者砍 N 剑！</p><p>砍完之后，将砍掉的部分放到另外一个数据库实例中，变成下面这样：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/5-2-20210128205551008.png" alt><br><img src="http://img.itboyhub.com/2021/01/mysql/5-3-20210128205556342.png" alt></p><p>这样，原本放在一个 DB 中的 table 现在放在两个 DB 中了，观察之后我们发现：</p><ol><li>两个 DB 中表的个数都是完整的，就是原来 DB 中有几张表，现在还是几张。</li><li>每张表中的数据是不完整的，数据被拆分到了不同的 DB 中去了。</li></ol><p>这就是数据库的水平切分，也可以理解为按照数据行进行切分，即按照表中某个字段的<strong>某种规则</strong>来将表数据分散到多个库之中，每个表中包含一部分数据，即水平切分不改变表结构。</p><h3 id="2-2-垂直切分"><a href="#2-2-垂直切分" class="headerlink" title="2.2 垂直切分"></a>2.2 垂直切分</h3><p>先来一张简单的示意图，大家感受一下垂直切分：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/5-4-20210128205608727.png" alt></p><p>所谓的垂直切分就是拿着我 40 米大刀，对准了黑色的线条砍。砍完之后，将不同的表放到不同的数据库实例中去，变成下面这个样子：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/5-5-20210128205614468.png" alt><br><img src="http://img.itboyhub.com/2021/01/mysql/5-6-20210128205621939.png" alt><br><img src="http://img.itboyhub.com/2021/01/mysql/5-7-20210128205632490.png" alt></p><p>这个时候我们发现如下几个特点：</p><ol><li>每一个数据库实例中的表的数量都是不完整的。</li><li>每一个数据库实例中表的数据是完整的。</li></ol><p>这就是垂直切分。一般来说，垂直切分我们可以按照业务来划分，不同业务的表放到不同的数据库实例中。</p><p><strong>MySQL 数据库支持的分区类型为水平分区。</strong></p><p>此外，MySQL 数据库的分区是局部分区索引，即一个分区中既存放了数据又存放了索引，目前，MySQL数据库还不支持全局分区（数据存放在各个分区中，但是所有数据的索引放在一个对象中）。</p><h2 id="3-为什么需要表分区"><a href="#3-为什么需要表分区" class="headerlink" title="3. 为什么需要表分区"></a>3. 为什么需要表分区</h2><ol><li>可以让单表存储更多的数据。</li><li>分区表的数据更容易维护，可以通过清除整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作。</li><li>部分查询能够从查询条件确定只落在少数分区上，查询速度会很快。</li><li>分区表的数据还可以分布在不同的物理设备上，从而高效利用多个硬件设备。</li><li>可以使用分区表来避免某些特殊瓶颈，例如 InnoDB 单个索引的互斥访问、ext3 文件系统的 inode 锁竞争。</li><li>可以备份和恢复单个分区。</li></ol><p>分区的限制和缺点：</p><ol><li>一个表最多只能有 1024 个分区。</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。</li><li>分区表无法使用外键约束。</li><li>NULL 值会使分区过滤无效。</li><li>所有分区必须使用相同的存储引擎。</li></ol><h2 id="4-分区实践"><a href="#4-分区实践" class="headerlink" title="4. 分区实践"></a>4. 分区实践</h2><p>说了这么多，来个例子看一下。</p><p>首先我们先来查看一下当前的 MySQL 是否支持分区。</p><p>在 MySQL5.6.1 之前可以通过命令 <code>show variables like &#39;%have_partitioning%&#39;</code> 来查看 MySQL 是否支持分区。如果 <code>have_partitioning</code> 的值为 YES，则表示支持分区。</p><p>从 MySQL5.6.1 开始，<code>have_partitioning</code> 参数已经被去掉了，而是用 <code>SHOW PLUGINS</code> 来代替。若有 partition 行且 STATUS 列的值为 ACTIVE，则表示支持分区，如下所示：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220308181510.png" alt></p><p>确认我们的 MySQL 支持分区后，我们就可以开始分区啦！</p><p>接下来我们来看几种不同的分区策略。</p><h3 id="4-1-RANGE-分区"><a href="#4-1-RANGE-分区" class="headerlink" title="4.1 RANGE 分区"></a>4.1 RANGE 分区</h3><p>RANGE 分区比较简单，就是根据某一个字段的值进行分区。<strong>不过这个字段有一个要求，就是必须是主键或者是联合主键中的某个字段。</strong></p><p>例如根据 user 表的 id 进行分区：</p><ol><li>当 id 小于 100，数据插入 p0 分区；</li><li>当 id 大于等于 100 小于 200 的时候，插入 p1 分区；</li><li>如果 id 大于等于 200 则插入 p2 分区。</li></ol><p>上面的规则涉及到了 id 的所有范围了，如果没有第三条规则，那么插入一个 id 为 300 的记录时，就会报错。</p><p>建表 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span>  <span class="hljs-keyword">table</span>  <span class="hljs-keyword">user</span>(</span><br><span class="line">  <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span>,</span><br><span class="line">  username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>)</span><br><span class="line">)<span class="hljs-keyword">engine</span>=<span class="hljs-keyword">innodb</span></span><br><span class="line">  <span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">id</span>)(</span><br><span class="line">     <span class="hljs-keyword">partition</span>  p0  <span class="hljs-keyword">values</span>  <span class="hljs-keyword">less</span>  <span class="hljs-keyword">than</span>(<span class="hljs-number">100</span>),</span><br><span class="line">     <span class="hljs-keyword">partition</span>  p1  <span class="hljs-keyword">values</span>  <span class="hljs-keyword">less</span>  <span class="hljs-keyword">than</span>(<span class="hljs-number">200</span>),</span><br><span class="line">     <span class="hljs-keyword">partition</span>  p2  <span class="hljs-keyword">values</span>  <span class="hljs-keyword">less</span>  <span class="hljs-keyword">than</span> maxvalue  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表创建成功后，我们进入到 <code>/var/lib/mysql/test08</code> 文件夹中，来看刚刚创建的表文件：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220308183135.png" alt></p><p>可以看到，此时的数据文件分为好几个了。</p><p>在 <code>information_schema.partitions</code> 表中，我们可以查看分区的详细信息：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220308194655.png" alt></p><p>也可以自己写个 SQL 去查询：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> information_schema.partitions <span class="hljs-keyword">where</span> table_schema=<span class="hljs-string">'test08'</span> <span class="hljs-keyword">and</span> table_name=<span class="hljs-string">'user'</span>\G</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220308194757.png" alt></p><p>每一行展示一个分区的信息，包括分区的方式、该区的范围、分区的字段、该区目前有几条记录等等。</p><p>RANGE 分区有一个比较典型的使用场景，就是按照日期对表进行分区，例如同一年注册的用户放在一个分区中，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span>  <span class="hljs-keyword">table</span>  <span class="hljs-keyword">user</span>(</span><br><span class="line">  <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,</span><br><span class="line">  username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  <span class="hljs-keyword">password</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  createDate <span class="hljs-built_in">date</span>,</span><br><span class="line">  primary <span class="hljs-keyword">key</span> (<span class="hljs-keyword">id</span>,createDate)</span><br><span class="line">)<span class="hljs-keyword">engine</span>=<span class="hljs-keyword">innodb</span></span><br><span class="line">  <span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">range</span>(<span class="hljs-keyword">year</span>(createDate))(</span><br><span class="line">     <span class="hljs-keyword">partition</span>  p2022  <span class="hljs-keyword">values</span>  <span class="hljs-keyword">less</span>  <span class="hljs-keyword">than</span>(<span class="hljs-number">2023</span>),</span><br><span class="line">     <span class="hljs-keyword">partition</span>  p2023  <span class="hljs-keyword">values</span>  <span class="hljs-keyword">less</span>  <span class="hljs-keyword">than</span>(<span class="hljs-number">2024</span>),</span><br><span class="line">     <span class="hljs-keyword">partition</span>  p2024  <span class="hljs-keyword">values</span>  <span class="hljs-keyword">less</span>  <span class="hljs-keyword">than</span>(<span class="hljs-number">2025</span>)  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>注意，createDate 是联合主键的一员。</strong>如果 createDate 不是主键，只是一个普通字段，那么创建时就会抛出如下错误：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220308201529.png" alt></p><p>现在，如果我们要查询 2022 年注册的用户，系统就只会去搜索 p2022 这个分区，通过 explain 执行计划可以证实我们的想法：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220308201939.png" alt></p><p>如果想要删除 2022 年注册的用户，则只需要删除该分区即可：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">drop</span> <span class="hljs-keyword">partition</span> p2022;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220308202156.png" alt></p><p>由上图可以看到，删除之后，数据就没了。</p><h3 id="4-2-LIST-分区"><a href="#4-2-LIST-分区" class="headerlink" title="4.2 LIST 分区"></a>4.2 LIST 分区</h3><p>LIST 分区和 RANGE 分区类似，区别在于 LIST 分区是基于列值匹配一个离散值集合中的某个值来进行选择，而非连续的。举个例子大家看下就明白了：</p><p>假设我有一个用户表，用户有性别，现在想按照性别将用户分开存储，男性存储在一个分区中，女性存储在一个分区中，SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span>  <span class="hljs-keyword">table</span>  <span class="hljs-keyword">user</span>(</span><br><span class="line">  <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,</span><br><span class="line">  username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  <span class="hljs-keyword">password</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  gender <span class="hljs-built_in">int</span>,</span><br><span class="line">  primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>, gender)</span><br><span class="line">)<span class="hljs-keyword">engine</span>=<span class="hljs-keyword">innodb</span></span><br><span class="line">  <span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">list</span>(gender)(</span><br><span class="line">     <span class="hljs-keyword">partition</span>  man  <span class="hljs-keyword">values</span>  <span class="hljs-keyword">in</span>  (<span class="hljs-number">1</span>),</span><br><span class="line">     <span class="hljs-keyword">partition</span>  woman  <span class="hljs-keyword">values</span>  <span class="hljs-keyword">in</span>  (<span class="hljs-number">0</span>));</span><br></pre></td></tr></table></figure><p>这个表将来就两个分区，分别存储男性和女性，gender 的取值为 1 或者 0，gender 如果取其他值，执行就会出错，最终执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220308204535.png" alt></p><p>这样分区之后，将来查询男性或者查询女性效率都会比较高，删除某一性别的用户时删除效率也高。</p><h3 id="4-3-HASH-分区"><a href="#4-3-HASH-分区" class="headerlink" title="4.3 HASH 分区"></a>4.3 HASH 分区</h3><p>HASH 分区的目的是将数据均匀地分布到预先定义的各个分区中，保证各分区的数据量大致都是一样的。在 RANGE 和 LIST 分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在 HASH 分区中，MySQL 自动完成这些工作，用户所要做的只是基于将要进行哈希分区的列指定一个表达式，并且分区的数量。</p><p>使用 HASH 分区来分割一个表，要在 CREATE TABLE 语句上添加 <code>PARTITION BY HASH (expr)</code>，其中 expr 是一个字段或者是一个返回整数的表达式；另外通过 PARTITIONS 属性指定分区的数量，如果没有指定，那么分区的数量默认为 1，另外，HASH 分区不能删除分区，所以不能使用 <code>DROP PARTITION</code> 操作进行分区删除操作。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span>  <span class="hljs-keyword">table</span>  <span class="hljs-keyword">user</span>(</span><br><span class="line">  <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,</span><br><span class="line">  username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  <span class="hljs-keyword">password</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  gender <span class="hljs-built_in">int</span>,</span><br><span class="line">  primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>, gender)</span><br><span class="line">)<span class="hljs-keyword">engine</span>=<span class="hljs-keyword">innodb</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">hash</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">partitions</span> <span class="hljs-number">4</span>;</span><br></pre></td></tr></table></figure><h3 id="4-4-KEY-分区"><a href="#4-4-KEY-分区" class="headerlink" title="4.4 KEY 分区"></a>4.4 KEY 分区</h3><p>KEY 分区和 HASH 分区相似，但是 KEY 分区支持除 text 和 BLOB 之外的所有数据类型的分区，而 HASH 分区只支持数字分区。</p><p>KEY 分区不允许使用用户自定义的表达式进行分区，KEY 分区使用系统提供的 HASH 函数进行分区。</p><p>当表中存在主键或者唯一索引时，如果创建 KEY 分区时没有指定字段系统默认会首选主键列作为分区字段,如果不存在主键列会选择<strong>非空唯一索引</strong>列作为分区字段。</p><p>举个例子：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span>  <span class="hljs-keyword">table</span>  <span class="hljs-keyword">user</span>(</span><br><span class="line">  <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,</span><br><span class="line">  username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  <span class="hljs-keyword">password</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  gender <span class="hljs-built_in">int</span>,</span><br><span class="line">  primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>, gender)</span><br><span class="line">)<span class="hljs-keyword">engine</span>=<span class="hljs-keyword">innodb</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">partitions</span> <span class="hljs-number">4</span>;</span><br></pre></td></tr></table></figure><h3 id="4-5-COLUMNS-分区"><a href="#4-5-COLUMNS-分区" class="headerlink" title="4.5 COLUMNS 分区"></a>4.5 COLUMNS 分区</h3><p>COLUMN 分区是 5.5 开始引入的分区功能，只有 RANGE COLUMN 和 LIST COLUMN 这两种分区；支持整形、日期、字符串；这种分区方式和 RANGE、LIST 的分区方式非常的相似。</p><p>COLUMNS Vs RANGE Vs LIST 分区：</p><ol><li>针对日期字段的分区不需要再使用函数进行转换了。</li><li>COLUMN 分区支持多个字段作为分区键但是不支持表达式作为分区键。</li></ol><p>COLUMNS 支持的类型</p><ul><li>整形支持：tinyint、smallint、mediumint、int、bigint；不支持 decimal 和 float。</li><li>时间类型支持：date、datetime。</li><li>字符类型支持：char、varchar、binary、varbinary；不支持text、blob。</li></ul><p>举个例子看下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span>  <span class="hljs-keyword">table</span>  <span class="hljs-keyword">user</span>(</span><br><span class="line">  <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,</span><br><span class="line">  username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  <span class="hljs-keyword">password</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  gender <span class="hljs-built_in">int</span>,</span><br><span class="line">  createDate <span class="hljs-built_in">date</span>,</span><br><span class="line">  primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>, createDate)</span><br><span class="line">)<span class="hljs-keyword">engine</span>=<span class="hljs-keyword">innodb</span> <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">RANGE</span> <span class="hljs-keyword">COLUMNS</span>(createDate) (</span><br><span class="line">    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">LESS</span> <span class="hljs-keyword">THAN</span> (<span class="hljs-string">'1990-01-01'</span>),</span><br><span class="line">    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">LESS</span> <span class="hljs-keyword">THAN</span> (<span class="hljs-string">'2000-01-01'</span>),</span><br><span class="line">    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">LESS</span> <span class="hljs-keyword">THAN</span> (<span class="hljs-string">'2010-01-01'</span>),</span><br><span class="line">    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">LESS</span> <span class="hljs-keyword">THAN</span> (<span class="hljs-string">'2020-01-01'</span>),</span><br><span class="line">    <span class="hljs-keyword">PARTITION</span> p4 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">LESS</span> <span class="hljs-keyword">THAN</span> MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这是 RANGE COLUMNS，分区值是连续的。</p><p>再来看 LIST COLUMNS 分区，这个就类似于枚举了：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span>  <span class="hljs-keyword">table</span>  <span class="hljs-keyword">user</span>(</span><br><span class="line">  <span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,</span><br><span class="line">  username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  <span class="hljs-keyword">password</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>),</span><br><span class="line">  gender <span class="hljs-built_in">int</span>,</span><br><span class="line">  createDate <span class="hljs-built_in">date</span>,</span><br><span class="line">  primary <span class="hljs-keyword">key</span>(<span class="hljs-keyword">id</span>, createDate)</span><br><span class="line">)<span class="hljs-keyword">engine</span>=<span class="hljs-keyword">innodb</span> <span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">LIST</span> <span class="hljs-keyword">COLUMNS</span>(createDate) (</span><br><span class="line">    <span class="hljs-keyword">PARTITION</span> p0 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">'1990-01-01'</span>),</span><br><span class="line">    <span class="hljs-keyword">PARTITION</span> p1 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">'2000-01-01'</span>),</span><br><span class="line">    <span class="hljs-keyword">PARTITION</span> p2 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">'2010-01-01'</span>),</span><br><span class="line">    <span class="hljs-keyword">PARTITION</span> p3 <span class="hljs-keyword">VALUES</span> <span class="hljs-keyword">IN</span> (<span class="hljs-string">'2020-01-01'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="5-常见分区命令"><a href="#5-常见分区命令" class="headerlink" title="5. 常见分区命令"></a>5. 常见分区命令</h2><ol><li>添加分区：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">partition</span> (<span class="hljs-keyword">partition</span> p3 <span class="hljs-keyword">values</span> <span class="hljs-keyword">less</span> <span class="hljs-keyword">than</span> (<span class="hljs-number">4000</span>)); <span class="hljs-comment">-- range 分区</span></span><br></pre></td></tr></table></figure><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">partition</span> (<span class="hljs-keyword">partition</span> p3 <span class="hljs-keyword">values</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">40</span>));  <span class="hljs-comment">-- lists分区</span></span><br></pre></td></tr></table></figure><ol start="2"><li>删除表分区（<strong>会删除数据</strong>）：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">drop</span> <span class="hljs-keyword">partition</span> p30;</span><br></pre></td></tr></table></figure><ol start="3"><li>删除表的所有分区（不会丢失数据）：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> remove partitioning;</span><br></pre></td></tr></table></figure><ol start="4"><li>重新定义 range 分区表（不会丢失数据）：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">range</span>(salary)(</span><br><span class="line"><span class="hljs-keyword">partition</span> p1 <span class="hljs-keyword">values</span> <span class="hljs-keyword">less</span> <span class="hljs-keyword">than</span> (<span class="hljs-number">2000</span>),</span><br><span class="line"><span class="hljs-keyword">partition</span> p2 <span class="hljs-keyword">values</span> <span class="hljs-keyword">less</span> <span class="hljs-keyword">than</span> (<span class="hljs-number">4000</span>));</span><br></pre></td></tr></table></figure><ol start="5"><li>重新定义 hash 分区表（不会丢失数据）：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">hash</span>(salary) <span class="hljs-keyword">partitions</span> <span class="hljs-number">7</span>;</span><br></pre></td></tr></table></figure><ol start="6"><li>合并分区：把 2 个分区合并为一个，不会丢失数据：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>  reorganize <span class="hljs-keyword">partition</span> p1,p2 <span class="hljs-keyword">into</span> (<span class="hljs-keyword">partition</span> p1 <span class="hljs-keyword">values</span> <span class="hljs-keyword">less</span> <span class="hljs-keyword">than</span> (<span class="hljs-number">1000</span>));</span><br></pre></td></tr></table></figure><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>不知道小伙伴们是否还记得松哥 2019 年写的 MyCat 教程（公众号江南一点雨后台回复 2019 有文章索引），这些分区策略是不是和 MyCat 中的策略非常相似呀？感兴趣的小伙伴赶紧去试一把吧～</p><p>参考资料：</p><p><a href="https://www.cnblogs.com/dw3306/p/12620O42.html" target="_blank" rel="noopener">https://www.cnblogs.com/dw3306/p/12620O42.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;松哥之前写过文章跟大家介绍过用 MyCat 实现 MySQL 的分库分表，不知道有没有小伙伴研究过，MySQL 其实也自带了分区功能，我们可以创建一个带有分区的表，而且不需要借助任何外部工具，今天我们就一起来看看。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>主键索引就是聚集索引？MySQL 索引类型大梳理</title>
    <link href="http://www.javaboy.org/2022/0321/mysql_index_type.html"/>
    <id>http://www.javaboy.org/2022/0321/mysql_index_type.html</id>
    <published>2022-03-21T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:59.790Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>之前松哥在前面的文章中介绍 MySQL 的索引时，有小伙伴表示被概念搞晕了，主键索引、非主键索引、聚簇索引、非聚簇索引、二级索引、辅助索引等等，今天咱们就来捋一捋这些概念。</p><a id="more"></a><h2 id="1-按照功能划分"><a href="#1-按照功能划分" class="headerlink" title="1. 按照功能划分"></a>1. 按照功能划分</h2><p>按照功能来划分，索引主要有四种：</p><ul><li>普通索引</li><li>唯一性索引</li><li>主键索引</li><li>全文索引</li></ul><p><strong>普通索引</strong>就是最最基础的索引，这种索引没有任何的约束作用，它存在的主要意义就是提高查询效率。</p><p>普通索引创建方式如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`name`</span> (<span class="hljs-string">`name`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>name 字段就是一个普通索引（括号外面的是索引名，里边的是索引的字段）。</p><p><strong>唯一性索引</strong>则在普通索引的基础上增加了数据唯一性的约束，一张表中可以同时存在多个唯一性索引，唯一性索引创建方式如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`name`</span> (<span class="hljs-string">`name`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>name 字段就是唯一性索引。</p><p><strong>主键索引</strong>则是在唯一性索引的基础上又增加了不为空的约束（换言之，添加了唯一性索引的字段，是可以包含 NULL 值的），即 <code>NOT NULL+UNIQUE</code>，一张表里最多只有一个主键索引，当然一个主键索引中可以包含多个字段。</p><p>前面两个例子中都有主键索引的创建方式，我这里就不再列举了。</p><p><strong>全文索引</strong>其实我们很少在 MySQL 中用，如果项目中有做全文索引的需求，一般可以通过 Elasticsearch 或者 Solr 来做，目前比较流行的就是 Elasticsearch 了，松哥之前也录过专门的视频，公众号后台回复 es 获取教程链接。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220301222925.png" alt></p><p>全文索引在 MySQL 中支持的版本也需要大家留意一下：</p><ul><li>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引。</li><li>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引。</li></ul><p>创建全文索引对字段类型也有要求，只有字段的数据类型为 <code>CHAR</code>、<code>VARCHAR</code> 以及 <code>TEXT</code> 等才可以建立全文索引。</p><p>MySQL 的全文索引最开始只支持英文，因为英文分词比较方便；中文分词就比较麻烦，所以最早的 MySQL 全文索引是不支持中文的。从 MySQL5.7.6 版本开始，引入了 ngram 全文分析器来解决分词问题，并且这个分词器对 MyISAM 和 InnoDB 引擎都有效。</p><p>不过 MySQL 的全文索引并不好用，有这方面的需求还是直接上 Es 吧。</p><p>全文索引的创建方式如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  FULLTEXT <span class="hljs-keyword">KEY</span> <span class="hljs-string">`name`</span> (<span class="hljs-string">`name`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>name 字段就是全文索引。</p><h2 id="2-按照物理实现划分"><a href="#2-按照物理实现划分" class="headerlink" title="2. 按照物理实现划分"></a>2. 按照物理实现划分</h2><p>按照物理实现方式，索引可以分为两大类：</p><ul><li>聚集索引（有的人也称之为“聚簇索引”）</li><li>非聚集索引（有的人也称之为“非聚簇索引”）</li></ul><h3 id="2-1-聚集索引"><a href="#2-1-聚集索引" class="headerlink" title="2.1 聚集索引"></a>2.1 聚集索引</h3><p><strong>聚集索引</strong>在存储的时候，可以按照主键（不是必须，看情况）来排序存储数据，B+Tree 的叶子结点就是完整的数据行，查找的时候，找到了主键也就找到了完整的数据行。</p><p>如下图，在聚集索引中，叶子结点保存了每一行的数据。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211215195802.png" alt></p><p>在聚集索引里，表中数据行按索引的排序方式进行存储，对查找行很有效。只有当表包含聚集索引时，表内的数据行才会按找索引列的值在磁盘上进行物理排序和存储。每张表只能有一个聚集索引，原因很简单，因为数据行本身只能按一个顺序存储。</p><p>当我们基于 InnoDB 引擎创建一张表的时候，都会创建一个聚集索引，每张表都有唯一的聚集索引：</p><ol><li>如果这张表定义了主键索引，那么这个主键索引就作为聚集索引。</li><li>如果这张表没有定义主键索引，那么该表的第一个唯一非空索引作为聚集索引。</li><li>如果这张表也没有唯一非空索引，那么 InnoDB 内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个 6 个字节的列，该列的值会随着数据的插入自增。</li></ol><p><strong>基于以上描述大家可以看到，主键索引和聚集索引并不是一回事，切勿混淆！</strong></p><p>聚集索引最主要的优势就是查询快。如果要查询完整的数据行，使用非聚集索引往往需要回表才能实现，而使用聚集索引则能一步到位。</p><p>不过聚集索引也有一些劣势：</p><ol><li>聚集索引可以减少磁盘 IO 的次数，这在传统的机械硬盘中是很有优势的，不过要是固态硬盘或者内存（有时候为了提高操作效率，数据库服务器会整一个比较大的内存），这个优势就不明显了。</li><li>聚集索引在插入的时候，最好是主键自增，自增主键插入的时候比较快，直接插入即可，不会涉及到叶子节点分裂等问题（不需要挪动其他记录）；而其他非自增主键插入的时候，可能要插入到两个已有的数据中间，就有可能导致叶子节点分裂等问题，插入效率低（要挪动其他记录）。如果聚集索引在插入的时候不是自增主键，插入效率就会比较低。</li></ol><h3 id="2-2-非聚集索引"><a href="#2-2-非聚集索引" class="headerlink" title="2.2 非聚集索引"></a>2.2 非聚集索引</h3><p><strong>非聚集索引</strong>我们一般也称为二级索引或者辅助索引，对于非聚集索引，数据库会有单独的存储空间来存放。非聚集索引在查找的时候要经过两个步骤，例如执行 <code>select * from user where username=&#39;javaboy&#39;</code>（假设 username 字段是非聚集索引），那么此时需要先搜索 username 这一列索引的 B+Tree，这个 B+Tree 的叶子结点存储的不是完整的数据行，而是主键值，当我们搜索完成后得到主键的值，然后拿着主键值再去搜索主键索引的 B+Tree，就可以获取到一行完整的数据。</p><p>所以如果我们在查询中用到了非聚集索引，那么就会搜索两棵 B+Tree，<strong>第一次搜索 B+Tree 拿到主键值后再去搜索聚集索引的 B+Tree，这个过程就是所谓的回表。</strong></p><p>一张表只能有一个聚集索引，但可以有多个非聚集索引。使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>总的来说，数据库索引可以按照两种思路来分类：按照功能分和按照存储方式分。</p><p>按照功能分，可以分四种：</p><ul><li>普通索引</li><li>唯一性索引</li><li>主键索引</li><li>全文索引</li></ul><p>按照存储方式分，可以分两种：</p><ul><li>聚集索引</li><li>非聚集索引</li></ul><p>每种之间有区别又有联系，希望上文能为大家解惑，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;之前松哥在前面的文章中介绍 MySQL 的索引时，有小伙伴表示被概念搞晕了，主键索引、非主键索引、聚簇索引、非聚簇索引、二级索引、辅助索引等等，今天咱们就来捋一捋这些概念。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>S 锁与 X 锁，当前读与快照读！</title>
    <link href="http://www.javaboy.org/2022/0318/mysql_s_x.html"/>
    <id>http://www.javaboy.org/2022/0318/mysql_s_x.html</id>
    <published>2022-03-18T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:56.309Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 中的锁还是蛮多的，在之前的文章中，松哥和大家介绍过 MySQL 中的 MDL 锁（<a href="https://mp.weixin.qq.com/s/NUcf9QqacwUUXvcXzAHAgg" target="_blank" rel="noopener">为什么执行 alter 更新表要慎重？</a>），今天我们再来看看 MySQL 中比较重要的两个锁：S 锁和 X 锁。</p><a id="more"></a><h2 id="1-S-锁"><a href="#1-S-锁" class="headerlink" title="1. S 锁"></a>1. S 锁</h2><p>S 锁，英文为 Shared Lock，中文译作共享锁，有时候我们也称之为读锁，即 Read Lock。S 锁之间是共享的，或者说是互不阻塞的。</p><p>当事务读取一条记录时，需要先获取该记录的 S 锁。</p><p>举个例子：</p><p>事务 T1 对记录 R1 加上了 S 锁，那么事务 T1 可以读取 R1 这一行记录，但是不能修改 R1，其他事务 T2 可以继续对 R1 添加 S 锁，但是不能添加 X 锁，只有当 R1 上面的 S 锁释放了，才能加上 X 锁。</p><p>举一个加 S 锁的例子，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220221221333.png" alt></p><p>此时，对于 id=1 的这条记录，只能读取不能修改了。假设在另外一个事务 T 中，执行如下 SQL 是没问题的，因为 S 锁是共享锁，S 锁和 S 锁之间是兼容的：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span> <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">share</span> <span class="hljs-keyword">mode</span>;</span><br></pre></td></tr></table></figure><p>但是如果执行如下 SQL 则会被阻塞，因为修改数据需要获取 X 锁，而 S 锁和 X 锁不兼容：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> username=<span class="hljs-string">'javaboy'</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span>;</span><br></pre></td></tr></table></figure><p>上面这个更新语句内部会获取 X 锁，对于一些手动添加了 X 锁的查询语句，也会阻塞，例如下面这个：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220221221913.png" alt></p><p>可以看到，这个 SQL 执行之后就被阻塞了。</p><h2 id="2-X-锁"><a href="#2-X-锁" class="headerlink" title="2. X 锁"></a>2. X 锁</h2><p>X 锁，英文为 Exclusive Lock，中文译作排他锁，有时候我们也称之为写锁，即 Write Lock。如同它的名字，X 锁是具有排他性的，即一个写锁会阻塞其他的 X 锁和 S 锁。</p><p>当事务需要修改一条记录时，需要先获取该记录的 X 锁。</p><p>举个例子：</p><p>事务 T1 对记录 R1 加上了 X 锁，那么事务 T1 即可以读取 R1 也可以修改 R1，而其他事务则不能对 R1 再添加任何锁，直到 T1 释放了 R1 上的锁。</p><p>如上文图示，锁定读的格式是这样的：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> .... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</span><br></pre></td></tr></table></figure><h2 id="3-当前读与快照读"><a href="#3-当前读与快照读" class="headerlink" title="3. 当前读与快照读"></a>3. 当前读与快照读</h2><p>由上面这两种锁，又引申出来两种读：</p><h3 id="3-1-快照读"><a href="#3-1-快照读" class="headerlink" title="3.1 快照读"></a>3.1 快照读</h3><p>快照读（SnapShot Read）是一种一致性不加锁的读，是 InnoDB 存储引擎并发如此之高的核心原因之一。</p><p>在可重复读的隔离级别下，事务启动的时候，就会针对当前库拍一个照片（快照），快照读读取到的数据要么就是拍照时的数据，即事务开启那一瞬间数据库中的数据，要么就是当前事务自身插入/修改过的数据。</p><p>我们日常所用的不加锁的查询，都属于快照读，这个我就不演示了。</p><h3 id="3-2-当前读"><a href="#3-2-当前读" class="headerlink" title="3.2 当前读"></a>3.2 当前读</h3><p>与快照读相对应的就是当前读，当前读就是读取最新数据，而不是历史版本的数据，换言之，在可重复读隔离级别下，如果使用了当前读，也可以读到别的事务已提交的数据。</p><p>松哥举个例子：</p><p>MySQL 事务开启两个会话 A 和 B。</p><p>首先在 A 会话中开启事务并查询 id 为 1 的记录：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211215211328.png" alt></p><p>接下来我们在 B 会话中对 id 为 1 的数据进行修改，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211215211509.png" alt></p><p><strong>注意 B 会话不要开启事务或者开启了及时提交事务，否则 update 语句占用一把排他锁会导致一会在 A 会话中用锁时发生阻塞。</strong></p><p>接下来，回到 A 会话中继续做查询操作，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211215211745.png" alt></p><p>可以看到，A 会话中第一个查询是快照读，读取到的是当前事务开启时的数据状态，后面两个查询则是当前读，读取到了当前最新的数据（B 会话中修改后的数据）。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，一个小小的知识点，日积月累，fighting！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL 中的锁还是蛮多的，在之前的文章中，松哥和大家介绍过 MySQL 中的 MDL 锁（&lt;a href=&quot;https://mp.weixin.qq.com/s/NUcf9QqacwUUXvcXzAHAgg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;为什么执行 alter 更新表要慎重？&lt;/a&gt;），今天我们再来看看 MySQL 中比较重要的两个锁：S 锁和 X 锁。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主从复制数据不一致，怎么办？</title>
    <link href="http://www.javaboy.org/2022/0316/mysql_master_slave.html"/>
    <id>http://www.javaboy.org/2022/0316/mysql_master_slave.html</id>
    <published>2022-03-16T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:52.737Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>今天的文章来晚了，主要是我一觉起来变黄码了，关键是我还不知道，早上 8.20 到了公司楼下，保安要看健康码，当我自信满满的打开粤省事却傻眼了，折腾一早上，绿码总算回来了，真是生活处处有惊喜。。。</p><hr><p>书接上回，闲话不表。</p><p>今天来说说 MySQL 主从复制数据不一致的问题，通过几个具体的案例，来向小伙伴们展示 binlog 不同 format 之间的区别。</p><a id="more"></a><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>以下配置基于 Docker。</p><p>我这里有一张简单的图向大伙展示 MySQL 主从的工作方式：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/3-1-20210128205201707.png" alt></p><p>这里，我们准备两台机器：</p><ul><li>主机：10.3.50.27:33061</li><li>从机：10.3.50.27:33062</li></ul><h3 id="1-1-主机配置"><a href="#1-1-主机配置" class="headerlink" title="1.1 主机配置"></a>1.1 主机配置</h3><p>主机的配置就三个步骤，比较容易：</p><p><strong>1. 授权给从机服务器</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* to &apos;rep1&apos;@&apos;10.3.50.27&apos; identified by &apos;123&apos;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>这里表示配置从机登录用户名为 rep1，密码为 123，并且必须从 <code>10.3.50.27</code> 这个地址登录，登录成功之后可以操作任意库中的任意表。其中，如果不需要限制登录地址，可以将 IP 地址更换为一个 <code>%</code>。</p><blockquote><p>注意，在 MySQL8 里边，这块有一些变化。MySQL8 中用户创建和授权需要分开，不能像上面那样一步到位，具体方式如下：</p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER `rep1`@`10.3.50.27` IDENTIFIED WITH caching_sha2_password BY &apos;javaboy.COM&apos;;</span><br><span class="line"></span><br><span class="line">GRANT Replication Slave ON *.* TO `rep1`@`10.3.50.27`;</span><br></pre></td></tr></table></figure><p><strong>2. 修改主库配置文件</strong></p><p>开启 binlog ，并设置 server-id ，每次修改配置文件后都要重启 MySQL 服务才会生效</p><p>开启 binlog 主要是修改 MySQL 的配置文件 mysqld.cnf，该文件在容器的 <code>/etc/mysql/mysql.conf.d</code> 目录下。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211222232342.png" alt></p><p>针对该配置文件，我们做如下修改：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 这个参数表示启用 binlog 功能，并指定 binlog 的存储目录</span><br><span class="line">log-bin=javaboy_logbin</span><br><span class="line"># 设置 binlog_format 格式</span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"># 设置一个 binlog 文件的最大字节</span><br><span class="line"># 设置最大 100MB</span><br><span class="line">max_binlog_size=104857600</span><br><span class="line"></span><br><span class="line"># 设置了 binlog 文件的有效期（单位：天）</span><br><span class="line">expire_logs_days = 7</span><br><span class="line"></span><br><span class="line"># binlog 日志只记录指定库的更新（配置主从复制的时候会用到）</span><br><span class="line">binlog-do-db=javaboy_db</span><br><span class="line"></span><br><span class="line"># binlog 日志不记录指定库的更新（配置主从复制的时候会用到）</span><br><span class="line">#binlog-ignore-db=javaboy_no_db</span><br><span class="line"></span><br><span class="line"># 写缓存多少次，刷一次磁盘，默认 0 表示这个操作由操作系统根据自身负载自行决定多久写一次磁盘</span><br><span class="line"># 1 表示每一条事务提交都会立即写磁盘，n 则表示 n 个事务提交才会写磁盘</span><br><span class="line">sync_binlog=0</span><br><span class="line"></span><br><span class="line"># 为当前服务取一个唯一的 id（MySQL5.7 开始需要）</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure><p>各项配置的含义松哥已经在注视中说明了。截图如下：</p><p>如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228220023.png" alt></p><ul><li>log-bin：同步的日志路径及文件名，一定注意这个目录要是 MySQL 有权限写入的（我这里是偷懒了，直接放在了下面那个datadir下面）。</li><li>binlog-do-db：要同步的数据库名，当从机连上主机后，只有这里配置的数据库才会被同步，其他的不会被同步。</li><li>server-id: MySQL 在主从环境下的唯一标志符，给个任意数字，注意不能和从机重复。</li><li><strong>修改 binlog_format 的值为 STATEMENT，这一点很关键。</strong></li></ul><p>配置完成后重启 MySQL 服务端：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql33061</span><br></pre></td></tr></table></figure><p><strong>3. 查看主服务器当前二进制日志名和偏移量</strong></p><p>这个操作的目的是为了在从数据库启动后，从这个点开始进行数据的恢复：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220228220650.png" alt></p><p>再看一眼 binlog_format 设置成功没：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228220801.png" alt></p><p>可以看到，没问题。</p><p>至此，主机配置完成。  </p><h3 id="1-2-从机配置"><a href="#1-2-从机配置" class="headerlink" title="1.2 从机配置"></a>1.2 从机配置</h3><p>从机的配置也比较简单，我们一步一步来看：</p><p><strong>1. 在/etc/my.cnf 添加配置</strong></p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228221057.png" alt></p><p>注意从机这里只需要配置一下 server-id 即可。</p><p><strong>注意：如果从机是从主机复制来的，即我们通过复制 CentOS 虚拟机获取了 MySQL 实例 ，此时两个 MySQL 的 uuid 一样（正常安装是不会相同的），这时需要手动修改，修改位置在 <code>/var/lib/mysql/auto.cnf</code> ，注意随便修改这里几个字符即可，但也不可太过于随意，例如修改了 uuid 的长度。</strong></p><p>配置完成后，记得重启从机。</p><p><strong>2. 使用命令来配置从机</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;10.3.50.27&apos;,master_port=33061,master_user=&apos;rep1&apos;,master_password=&apos;123&apos;,master_log_file=&apos;javaboy_logbin.000001&apos;,master_log_pos=154;</span><br></pre></td></tr></table></figure><p>这里配置了主机地址、端口以及从机登录主机的用户名和密码，注意最后两个参数要和 master 中的保持一致。</p><p>注意，由于 MySQL8 密码插件的问题，这个问题同样会给主从配置带来问题，所以在 MySQL8 配置主从上，上面这行命令需要添加 <code>get_master_public_key=1</code>，完整命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;10.3.50.27&apos;,master_port=33061,master_user=&apos;rep1&apos;,master_password=&apos;123&apos;,master_log_file=&apos;javaboy_logbin.000001&apos;,master_log_pos=154,get_master_public_key=1;</span><br></pre></td></tr></table></figure><p><strong>3. 启动 slave 进程</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>启动之后查看从机状态：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220228222404.png" alt></p><p><strong>4. 查看 slave 的状态</strong></p><p>主要是下面两项值都要为为 YES，则表示配置正确：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure><p>至此，配置完成，主机创建库，添加数据，从机会自动同步。 </p><p>如果这两个有一个不为 YES ，表示主从环境搭建失败，此时可以阅读日志，查看出错的原因，再具体问题具体解决。</p><p>具体的同步过程如下：</p><ol><li>首先在从机 33062 上通过 change master 命令，设置主机 33061 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog（<code>master_log_pos</code>），这个位置包含文件名和日志偏移量。</li><li>在从机 33061 上执行 <code>start slave</code> 命令，这时候从机会启动两个线程，分别是 <code>io_thread</code> 和 <code>sql_thread</code>。</li><li><code>io_thread</code> 负责与主机建立连接。</li><li>主机 33061 校验完用户名、密码后，开始按照从机 33062 传过来的位置，从本地读取 binlog，发给 33062。</li><li>从机 33062 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li><li><code>sql_thread</code> 线程读取中转日志，解析出日志里的命令，并执行。</li></ol><p>大致就是这样一个流程。</p><h2 id="2-数据不一致问题"><a href="#2-数据不一致问题" class="headerlink" title="2. 数据不一致问题"></a>2. 数据不一致问题</h2><p>接下来我们创建一个 javaboy_db 的数据库，并在里边创建一个 user 表，user 表的定义如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`uuid`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>接下来我们在主机中向 user 表中插入一条记录，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228223335.png" alt></p><p>按道理，这条记录会同步到 33062 这台从机上：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228223446.png" alt></p><p>大家看到，<strong>数据确实同步了，但是 uuid 却不一样。</strong></p><h2 id="3-原因分析"><a href="#3-原因分析" class="headerlink" title="3. 原因分析"></a>3. 原因分析</h2><p>我们知道，MySQL 主从同步最主要的依据就是 binlog，master 将自己的 binlog 发给 slave，slave 重放之后获取和 master 一致的数据。</p><p>那我们就来看看 master 生成的 binlog 是啥样子。</p><p>我们按照事件的方式来看一下 binlog，命令格式如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">binlog</span> <span class="hljs-keyword">events</span> [<span class="hljs-keyword">IN</span> <span class="hljs-string">'log_name'</span>] [<span class="hljs-keyword">FROM</span> pos] [<span class="hljs-keyword">LIMIT</span> [<span class="hljs-keyword">offset</span>,] <span class="hljs-keyword">row_count</span>];</span><br></pre></td></tr></table></figure><p>这个表示以事件的方式来查看 binlog，这里涉及到几个参数：</p><ul><li>log_name：可以指定要查看的 binlog 日志文件名，如果不指定的话，表示查看最早的 binlog 文件。</li><li>pos：从哪个 pos 点开始查看，凡是 binlog 记录下来的操作都有一个 pos 点，这个其实就是相当于我们可以指定从哪个操作开始查看日志，如果不指定的话，就是从该 binlog 的开头开始查看。</li><li>offset：这是是偏移量，不指定默认就是 0。</li><li>row_count：查看多少行记录，不指定就是查看所有。</li></ul><p>查看命令如下（我这里就从 pos 为 154 的位置开始）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">binlog</span> <span class="hljs-keyword">events</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">'javaboy_logbin.000001'</span> <span class="hljs-keyword">FROM</span> <span class="hljs-number">154</span>;</span><br></pre></td></tr></table></figure><p>查看结果如下（部分）：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228230059.png" alt></p><p>从图中可以看到，记录在 binlog 原文中的日志是：<code>use javaboy_db; insert into user(uuid,name) values(uuid(),&#39;javaboy&#39;)</code>。</p><p>这句 SQL 将来同步到 slave 之后，slave 照着执行一下，那必然出现执行结果不一致的问题，因为 <code>uuid()</code> 函数每次执行结果都不一样。</p><p>现在小伙伴们看明白问题的原因了吧。</p><h2 id="4-问题解决"><a href="#4-问题解决" class="headerlink" title="4. 问题解决"></a>4. 问题解决</h2><p>问题倒也好解决，上篇文章我们说过，我们可以将 binlog_format 设置为 ROW 来解决这个问题。</p><p>具体操作步骤如下。</p><p>在主机中，修改 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 配置文件，将 binlog_format 改为 ROW，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228230712.png" alt></p><p>修改完成后，重启主机，主机重启之后，会产生新的 binlog 文件，所以我们需要重新查看主机的最新状态并重新配置从机，先来看主机，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228231314.png" alt></p><p>以此为依据，让从机重新连接主机，在从机上再进行如下操作：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">stop</span> <span class="hljs-keyword">slave</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">change</span> <span class="hljs-keyword">master</span> <span class="hljs-keyword">to</span> master_host=<span class="hljs-string">'10.3.50.27'</span>,master_port=<span class="hljs-number">33061</span>,master_user=<span class="hljs-string">'rep1'</span>,master_password=<span class="hljs-string">'123'</span>,master_log_file=<span class="hljs-string">'javaboy_logbin.000002'</span>,master_log_pos=<span class="hljs-number">794</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">start</span> <span class="hljs-keyword">slave</span>;</span><br></pre></td></tr></table></figure><p>重新配置完从机之后，我们继续向 user 表插入一条数据，插入完成后，我们再去看从机的数据，发现此时的数据已经是一致的了。</p><p>解决这个问题，我们最主要的更改就是修改了 binlog_format 为 ROW，当我们把 binlog_format 改为 ROW 之后，我们来看看此时 binlog 中都记录了啥。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">binlog</span> <span class="hljs-keyword">events</span> <span class="hljs-keyword">IN</span> <span class="hljs-string">'javaboy_logbin.000002'</span> <span class="hljs-keyword">FROM</span> <span class="hljs-number">794</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220301112029.png" alt></p><p>大家看到，在 BEGIN 和 COMMIT 之间，就是我们的数据修改操作。</p><ul><li>Table_map：这一行是说明了接下来要操作 javaboy_db.user 表。</li><li>Write_rows：这一行是说明了要写一行新的数据了。</li></ul><p>不过这里看不出啥端倪来，我们借助 mysqlbinlog 工具来看看是否有新的发现。</p><p>为了查看 binlog，MySQL 为我们提供了两个官方工具，除了上面的 <code>show binlog events</code>，另一个就是 <code>mysqlbinlog</code> 命令，如下（注意在系统中执行该命令，不是在 MySQL 终端执行该命令）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -vv /var/lib/mysql/javaboy_logbin.000002 <span class="hljs-comment">--start-position=794;</span></span><br></pre></td></tr></table></figure><ul><li>-vv 表示显示详细信息，这样就会打印出 binlog 中二进制文件的内容。</li></ul><p><img src="http://img.itboyhub.com/2021/10/tran/20220301115035.png" alt></p><p>这里的内容比较多，我们来看几个比较关键的地方：</p><ol><li>Table_map: <code>javaboy_db</code>.<code>user</code> mapped to number 108：这表示接下来要操作编号为 108 的表，每张表都有一个自己的编号。</li><li>Write_rows: table id 108 flags: STMT_END_F：这个就是具体的添加操作了，向编号为 108 的表中添加一条记录。</li></ol><p>接下来那两行，大致上瞅一眼，像是 Base64 转码后的内容，大家感兴趣的可以自行解码看看，解码后有一些是乱码的，但是有一些字符串如 uuid 则没有乱码，我们也能大致猜出来这里存储的内容。</p><p>接下来我们看下面记录的 SQL，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220301115311.png" alt></p><p>这就是日志中记录的内容，可以看到，每个字段上具体的值是啥，都写下来了，这样当然就不会发生数据不一致的情况了。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>好啦，今天通过一个简单的案例，跟小伙伴们分享了 binlog 两种不同的日志格式，另外还有一中 MIXED 格式现在很少用了，感兴趣的小伙伴可以结合上篇文章的内容，在本文案例的基础上继续测试 MIXED 模式，这里我就不赘述啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;今天的文章来晚了，主要是我一觉起来变黄码了，关键是我还不知道，早上 8.20 到了公司楼下，保安要看健康码，当我自信满满的打开粤省事却傻眼了，折腾一早上，绿码总算回来了，真是生活处处有惊喜。。。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;书接上回，闲话不表。&lt;/p&gt;
&lt;p&gt;今天来说说 MySQL 主从复制数据不一致的问题，通过几个具体的案例，来向小伙伴们展示 binlog 不同 format 之间的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>666！MySQL 的 binlog 的三种格式这么好玩！</title>
    <link href="http://www.javaboy.org/2022/0315/mysql_binlog_format.html"/>
    <id>http://www.javaboy.org/2022/0315/mysql_binlog_format.html</id>
    <published>2022-03-15T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:46.847Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 中的日志比较重要的有 binlog（归档日志）、redo log（重做日志）以及 undo log，那么跟我们本文相关的主要是 binlog，另外两个日志松哥将来有空了再和大家详细介绍。</p><a id="more"></a><h2 id="1-binlog"><a href="#1-binlog" class="headerlink" title="1. binlog"></a>1. binlog</h2><p>binlog 我们中文一般称作归档日志，如果大家看过松哥之前发的 MySQL 主从搭建，应该对这个日志有印象，当我们搭建 MySQL 主从的时候就离不开 binlog（传送门：<a href="https://mp.weixin.qq.com/s/y8PR1emyBjvk124b5ByjXg" target="_blank" rel="noopener">MySQL8 主从复制踩坑指南</a>）。</p><p>binlog 是 MySQL Server 层的日志，而不是存储引擎自带的日志，它记录了所有的 DDL 和 DML(不包含数据查询语句)语句，而且是以事件形式记录，还包含语句所执行的消耗的时间等，需要注意的是：</p><ul><li>binlog 是一种逻辑日志，他里边所记录的是一条 SQL 语句的原始逻辑，例如给某一个字段 +1，注意这个区别于 redo log 的物理日志（在某个数据页上做了什么修改）。</li><li>binlog 文件写满后，会自动切换到下一个日志文件继续写，而不会覆盖以前的日志，这个也区别于 redo log，redo log 是循环写入的，即后面写入的可能会覆盖前面写入的。</li><li>一般来说，我们在配置 binlog 的时候，可以指定 binlog 文件的有效期，这样在到期后，日志文件会自动删除，这样避免占用较多存储空间。</li></ul><p>根据 MySQL 官方文档的介绍，开启 binlog 之后，大概会有 1% 的性能损耗，不过这还是可以接受的，一般来说，binlog 有两个重要的使用场景：</p><ul><li>MySQL 主从复制时：在主机上开启 binlog，主机将 binlog 同步给从机，从机通过 binlog 来同步数据，进而实现主机和从机的数据同步。</li><li>MySQL 数据恢复，通过使用 mysqlbinlog 工具再结合 binlog 文件，可以将数据恢复到过去的某一时刻。</li></ul><h2 id="2-配置-binlog"><a href="#2-配置-binlog" class="headerlink" title="2. 配置 binlog"></a>2. 配置 binlog</h2><p>为了演示方便，松哥这里在 Docker 中安装了 MySQL，我们以此为例来开始今天的演示。如果小伙伴们还不懂 docker 的使用，可以在公众号后台回复 docker，有松哥写的教程。</p><p>首先我们在 docker 中安装好 MySQL，然后进入到容器中，通过如下命令可以查看 binlog 是否开启：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211222232153.png" alt></p><p>这个 OFF 就表示 binlog 是一个关闭状态，没有开启。</p><p>通过以下命令可以查看 binlog 日志的格式，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228193430.png" alt></p><p>可以看到，这个 binlog 的格式为 ROW。</p><p>这里就涉及到一个问题，binlog 的格式。</p><h3 id="2-1-binlog-的格式"><a href="#2-1-binlog-的格式" class="headerlink" title="2.1 binlog 的格式"></a>2.1 binlog 的格式</h3><p>binlog 有三种格式：</p><ul><li>Statement（Statement-Based Replication,SBR）：每一条会修改数据的 SQL 都会记录在 binlog 中。</li><li>Row（Row-Based Replication,RBR）：不记录 SQL 语句上下文信息，仅保存哪条记录被修改。</li><li>Mixed（Mixed-Based Replication,MBR）：Statement 和 Row 的混合体。</li></ul><h4 id="2-1-1-Statement"><a href="#2-1-1-Statement" class="headerlink" title="2.1.1 Statement"></a>2.1.1 Statement</h4><p>Statement 模式只记录执行的 SQL，不需要记录每一行数据的变化，因此极大的减少了 binlog 的日志量，避免了大量的 IO 操作，提升了系统的性能。</p><p>但是，正是由于 Statement 模式只记录 SQL，而如果一些 SQL 中包含了函数，那么可能会出现执行结果不一致的情况。比如说 <code>uuid()</code> 函数，每次执行的时候都会生成一个随机字符串，在 master 中记录了 uuid，当同步到 slave 之后，再次执行，就获取到另外一个结果了。</p><p>所以使用 Statement 格式会出现一些数据一致性问题。</p><h4 id="2-2-2-Row"><a href="#2-2-2-Row" class="headerlink" title="2.2.2 Row"></a>2.2.2 Row</h4><p>从 MySQL5.1.5 版本开始，binlog 引入了 Row 格式，Row 格式不记录 SQL 语句上下文相关信息，仅仅只需要记录某一条记录被修改成什么样子了。</p><p>Row 格式的日志内容会非常清楚的记录下每一行数据修改的细节，这样就不会出现 Statement 中存在的那种数据无法被正常复制的情况。</p><p>不过 Row 格式也有一个很大的问题，那就是日志量太大了，特别是批量 update、整表 delete、alter 表等操作，由于要记录每一行数据的变化，此时会产生大量的日志，大量的日志也会带来 IO 性能问题。</p><h4 id="2-2-3-Mixed"><a href="#2-2-3-Mixed" class="headerlink" title="2.2.3 Mixed"></a>2.2.3 Mixed</h4><p>从 MySQL5.1.8 版开始，MySQL 又推出了 Mixed 格式，这种格式实际上就是 Statement 与 Row 的结合。</p><p>在 Mixed 模式下，系统会自动判断该用 Statement 还是 Row：一般的语句修改使用 Statement 格式保存 binlog；对于一些 Statement 无法准确完成主从复制的操作，则采用 Row 格式保存 binlog。</p><p>Mixed 模式中，MySQL 会根据执行的每一条具体的 SQL 语句来区别对待记录的日志格式，也就是在 Statement 和 Row 之间选择一种。</p><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h3><p>接下来我们来看看 binlog 的配置。</p><h4 id="2-2-1-开启-binlog"><a href="#2-2-1-开启-binlog" class="headerlink" title="2.2.1 开启 binlog"></a>2.2.1 开启 binlog</h4><p>开启 binlog 主要是修改 MySQL 的配置文件 mysqld.cnf，该文件在容器的 <code>/etc/mysql/mysql.conf.d</code> 目录下。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211222232342.png" alt></p><p>针对该配置文件，我们做如下修改：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 这个参数表示启用 binlog 功能，并指定 binlog 的存储目录</span><br><span class="line">log-bin=javaboy_logbin</span><br><span class="line"></span><br><span class="line"># 设置一个 binlog 文件的最大字节</span><br><span class="line"># 设置最大 100MB</span><br><span class="line">max_binlog_size=104857600</span><br><span class="line"></span><br><span class="line"># 设置了 binlog 文件的有效期（单位：天）</span><br><span class="line">expire_logs_days = 7</span><br><span class="line"></span><br><span class="line"># binlog 日志只记录指定库的更新（配置主从复制的时候会用到）</span><br><span class="line">#binlog-do-db=javaboy_db</span><br><span class="line"></span><br><span class="line"># binlog 日志不记录指定库的更新（配置主从复制的时候会用到）</span><br><span class="line">#binlog-ignore-db=javaboy_no_db</span><br><span class="line"></span><br><span class="line"># 写缓存多少次，刷一次磁盘，默认 0 表示这个操作由操作系统根据自身负载自行决定多久写一次磁盘</span><br><span class="line"># 1 表示每一条事务提交都会立即写磁盘，n 则表示 n 个事务提交才会写磁盘</span><br><span class="line">sync_binlog=0</span><br><span class="line"></span><br><span class="line"># 为当前服务取一个唯一的 id（MySQL5.7 之后需要配置）</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure><p>各项配置的含义松哥已经在注视中说明了。截图如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211227203629.png" alt></p><p>配置完成后，执行如下命令重启 mysql 容器（mysql1 是我这里容器的名字）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql1</span><br></pre></td></tr></table></figure><p>重启之后，再次执行 <code>show variables like &#39;log_bin%&#39;;</code> 即可看到 binlog 已经开启了。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211222233821.png" alt></p><p>这里除了 log_bin 变量外，还有两个变量名也值得我们关注：</p><ul><li>log_bin_basename：这个是将来产生的 binlog 日志文件的名称前缀，换句话说，根据大家目前所看到的配置，将来产生的 binlog 日志文件名为 <code>javaboy_logbin.xxx</code>，这个文件中将会用来记录所有的 DDL 和 DML 语句事件。</li><li>log_bin_index：这个是 binlog 的索引文件，保存了所有 binlog 的目录，因为 binlog 可能会有多个。我们可以来查看一下现在的 <code>javaboy_logbin.index</code> 文件：</li></ul><p><img src="http://img.itboyhub.com/2021/10/tran/20211225163102.png" alt></p><p>可以看到，目前只有一个 logbin 文件。</p><h4 id="2-2-2-修改-binlog-format"><a href="#2-2-2-修改-binlog-format" class="headerlink" title="2.2.2 修改 binlog_format"></a>2.2.2 修改 binlog_format</h4><p>binlog_format 有几种不同的改法：</p><p>修改当前会话的 binlog_format，这个修改只针对当前会话有效：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228203938.png" alt></p><p>也可以修改全局的 binlog_format，这个修改，当 MySQL 重启之后，会失效：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228204206.png" alt></p><p>如果想一劳永逸搞定这事，可以修改 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 配置文件，在配置文件中，添加 binlog_format 选项，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220228204532.png" alt></p><p>这是一个永久性的修改。</p><h2 id="3-常见-binlog-操作"><a href="#3-常见-binlog-操作" class="headerlink" title="3. 常见 binlog 操作"></a>3. 常见 binlog 操作</h2><p>接下来我们再来介绍几个常见的 binlog 操作命令。</p><ol><li>查看所有 binlog 日志</li></ol><p>通过如下方式我们可以查看 binlog 日志列表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">master</span> <span class="hljs-keyword">logs</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20211225162132.png" alt></p><p>可以看到，我这里目前只有一个日志文件，文件名为 <code>javaboy_logbin.000001</code>，File_size 表示这个文件占用的字节大小是 154。</p><ol start="2"><li>查看 master 状态</li></ol><p>这个命令我们在搭建 MySQL 主从的时候经常会用到，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211225163639.png" alt></p><p>这个时候可以看到最新的 binlog 日志文件名称以及最后一个操作事件的 Position 值（这个值有啥用，我们后面会给大家详细介绍）。</p><ol start="3"><li>刷新 binlog</li></ol><p>正常来说，一个 binlog 写满之后，会自动切换到下一个 binlog 开始写，不过我们也可以执行一个 <code>flush logs</code> 命令来手动刷新 binlog，手动刷新 binlog 之后，就会产生一个新的 binlog 日志文件，接下来所有的 binlog 日志都将记录到新的文件中。如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211225164302.png" alt></p><p>由上图可以看到，我们刷新日志之后，再通过 <code>show master logs</code> 去查看日志，发现日志文件已经多了一个新产生的了，然后再通过 <code>show master status</code> 去查看最新的日志文件信息，发现也已经变为 <code>javaboy_logbin.000002</code>。</p><ol start="4"><li>重置 binlog</li></ol><p><code>reset master</code> 可以重置 binlog 日志文件，让日志重新从 000001 开始记录，不过如果当前主机有一个或者多个从机在运行，那么该命令就运行不了（因为从机是通过 binlog 来实现数据库同步的，主机把 binlog 清空了，从机会报找不到 binlog 的错误）。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211225164948.png" alt></p><ol start="5"><li>查看 binlog</li></ol><p>由于 binlog 是二进制日志文件，所以要是直接打开，那肯定是看不了的：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211225165418.png" alt></p><p>没有看到任何有用的信息。</p><p>为了查看 binlog，MySQL 为我们提供了两个官方工具，我们一个一个来看，首先是 <code>mysqlbinlog</code> 命令，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211225170709.png" alt></p><p>虽然看起来乱糟糟的，不过仔细看着其实都有迹可循。因为我这里是一个新安装的数据库，里边只是创建了一个名为 javaboy 的库，然后创建了一个名为 user 的表加了两条数据，其他什么事情都没做，所以创建库的脚本我们其实能够从纷杂的文件中找到。</p><p>产生的日志文件中有一个 end_log_pos 是日志文件的 pos 点，这个将来在数据恢复的时候有用。</p><p>不过这种查看方式不够人性化，我们说 binlog 是按照事件来记录日志的，所以如果我们能够按照事件的方式查看日志，就会好很多，我们再来看看如下一个命令：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">binlog</span> <span class="hljs-keyword">events</span> [<span class="hljs-keyword">IN</span> <span class="hljs-string">'log_name'</span>] [<span class="hljs-keyword">FROM</span> pos] [<span class="hljs-keyword">LIMIT</span> [<span class="hljs-keyword">offset</span>,] <span class="hljs-keyword">row_count</span>];</span><br></pre></td></tr></table></figure><p>这个表示以事件的方式来查看 binlog，这里涉及到几个参数：</p><ul><li>log_name：可以指定要查看的 binlog 日志文件名，如果不指定的话，表示查看最早的 binlog 文件。</li><li>pos：从哪个 pos 点开始查看，凡是 binlog 记录下来的操作都有一个 pos 点，这个其实就是相当于我们可以指定从哪个操作开始查看日志，如果不指定的话，就是从该 binlog 的开头开始查看。</li><li>offset：这是是偏移量，不指定默认就是 0。</li><li>row_count：查看多少行记录，不指定就是查看所有。</li></ul><p>我们来看一个简单的例子：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">binlog</span> <span class="hljs-keyword">events</span> <span class="hljs-keyword">in</span> <span class="hljs-string">'javaboy_logbin.000001'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20211225172005.png" alt></p><p>这下就清晰多了，我们可以看到之前的所有操作，例如：</p><ul><li>在 Pos 219-322 之间创建了一个库。</li><li>在 Pos 387-537 之间创建了一张表。</li><li>在 Pos 677-780 之间添加了一条记录。</li><li>…</li></ul><p>这其实就是 Row 格式的 binlog。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>好啦，今天这篇文章主要是和小伙伴们分享了 MySQL 的 binlog 日志，主要是一些理论知识，下篇文章松哥将通过两个具体的案例，来和大家演示不同的 binlog_format 存在的问题～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL 中的日志比较重要的有 binlog（归档日志）、redo log（重做日志）以及 undo log，那么跟我们本文相关的主要是 binlog，另外两个日志松哥将来有空了再和大家详细介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 为什么需要 redo log？</title>
    <link href="http://www.javaboy.org/2022/0313/mysql_redo_log.html"/>
    <id>http://www.javaboy.org/2022/0313/mysql_redo_log.html</id>
    <published>2022-03-13T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:43.897Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>今天想和大家聊一聊 MySQL 中的 redo log，其实最早我是想聊两阶段提交的，后来想想可能有小伙伴还不了解 binlog，所以就先整了一篇 binlog：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/w4vPFHJkog2nbl68_0LOnw" target="_blank" rel="noopener">手把手教你玩 MySQL 删库不跑路，直接把 MySQL 的 binlog 玩溜！</a></li><li><a href="https://mp.weixin.qq.com/s/tuPYTX0suAkbqgx2knvJPQ" target="_blank" rel="noopener">MySQL删库不跑路（视频版）</a></li></ul><p>binlog 大家懂了之后，接下来还差个 redo log，redo log 大家也懂了，那么再讲两阶段提交相信小伙伴们就很容易懂了，咱们一步一步来。</p><h2 id="1-谁的-redo-log"><a href="#1-谁的-redo-log" class="headerlink" title="1. 谁的 redo log"></a>1. 谁的 redo log</h2><p>学习 redo log，我觉得首先要搞明白一个问题，就是是谁的 redo log？</p><p>我们知道，MySQL 架构整体上分为两层：Server 层和存储引擎层，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/mysql-arch.png" alt></p><p>前面松哥文章+视频跟大家聊的 binlog，是 MySQL 自己提供的 binlog，而 redo log 则不是 MySQL 提供的，而是存储引擎 InnoDB 自己提供的。所以在 MySQL 中就存在两类日志 binlog 和 redo log，存在两类日志既有历史原因（InnoDB 最早不是 MySQL 官方存储引擎）也有技术原因，这个咱们以后再细聊。</p><p>先把这个问题搞清楚，后面很多地方就容易懂了。</p><h2 id="2-buffer-pool"><a href="#2-buffer-pool" class="headerlink" title="2. buffer pool"></a>2. buffer pool</h2><p>在正式介绍 redo log 之前，还有一个 buffer pool 需要大家了解。</p><p>小伙伴们知道，InnoDB 引擎存储数据的时候，是以页为单位的，每个数据页的大小默认是 16KB，我们可以通过如下命令来查看页的大小：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220105223810.png" alt></p><p><code>16384/1024=16</code></p><p>刚好是 16KB。</p><p>计算机在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如 XFS/EXT4）最小单元是块，一个块的大小是 4KB，也就是四个块组成一个 InnoDB 中的页。我们在 MySQL 中针对数据库的增删改查操作，都是操作数据页，说白了，就是操作磁盘。</p><p>但是大家想想，如果每一次操作都操作磁盘，那么就会产生海量的磁盘 IO 操作，如果是传统的机械硬盘，还会涉及到很多随机 IO 操作，效率低的令人发指。这严重影响了 MySQL 的性能。</p><p>为了解决这一问题，MySQL 引入了 buffer pool，也就是我们常说的缓冲池。</p><p>buffer pool 的主要作用就是缓存索引和表数据，以避免每一次操作都要进行磁盘 IO，通过 buffer pool 可以提高数据的访问速度。</p><p>通过如下命令可以查看 buffer pool 的默认大小：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220107222125.png" alt></p><p><code>134217728/1024/1024=128</code></p><p>默认大小是 128MB，因为松哥这里的 MySQL 是安装在 Docker 中，所以这个分配的小一些。一般来说，如果一个服务器只是运行了一个 MySQL 服务，我们可以设置 buffer pool 的大小为服务器内存大小的 75%～80%。</p><h2 id="3-change-buffer"><a href="#3-change-buffer" class="headerlink" title="3. change buffer"></a>3. change buffer</h2><p>在正式介绍 redo log 之前，还有一个 change buffer 需要大家了解。</p><p>前面我们说的 buffer pool 虽然提高了访问速度，但是增删改的效率并没有因此提升，当涉及到增删改的时候，还是需要磁盘 IO，那么效率一样低的令人发指。</p><p>为了解决这个问题，MySQL 中引入了 change buffer。change buffer 以前并不叫这个名字，以前叫 insert buffer，即只针对 insert 操作有效，现在改名叫 change buffer 了，不仅仅针对 insert 有效，对 delete 和 update 操作也是有效的，change buffer 主要是对非唯一的索引有效，如果字段是唯一性索引，那么更新的时候要去检查唯一性，依然无法避免磁盘 IO。</p><p>change buffer 就是说，当我们需要更改数据库中的数据的时候，我们把更改记录到内存中，等到将来数据被读取的时候，再将内存中的数据 merge 到 buffer pool 然后返回，此时 buffer pool 中的数据和磁盘中的数据就会有差异，有差异的数据我们称之为脏页，在满足条件的时候（redo log 写满了、内存写满了、其他空闲时候），InnoDB 会把脏页刷新回磁盘。这种方式可以有效降低写操作的磁盘 IO，提升数据库的性能。</p><p>通过如下命令我们可以查看 change buffer 的大小以及哪些操作会涉及到 change buffer：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220107221306.png" alt></p><ul><li>innodb_change_buffer_max_size：这个配置表示 change buffer 的大小占整个缓冲池的比例，默认值是 <code>25%</code>，最大值是 <code>50%</code>。</li><li>innodb_change_buffering：这个操作表示哪些写操作会用到 change buffer，默认的 all 表示所有写操作，我们也可以自己设置为 <code>none</code>/<code>inserts</code>/<code>deletes</code>/<code>changes</code>/<code>purges</code> 等。</li></ul><p>不过 change buffer 和 buffer pool 都涉及到内存操作，数据不能持久化，那么，当存在脏页的时候，MySQL 如果突然挂了，就有可能造成数据丢失（因为内存中的数据还没写到磁盘上），但是我们在实际使用 MySQL 的时候，其实并不会有这个问题，那么问题是怎么解决的？那就得靠 redo log 了。</p><h2 id="4-redo-log-的诞生"><a href="#4-redo-log-的诞生" class="headerlink" title="4. redo log 的诞生"></a>4. redo log 的诞生</h2><p>在正式介绍 redo log 之前，还需要给大家普及一个概念：WAL。</p><p><code>WAL</code> 全称是 <code>Write-Ahead Logging</code> 中文译作预写日志。啥意思呢？就是说 MySQL 的写操作并不是立刻更新到磁盘上，而是先记录在日志上，然后在合适的时间再更新到磁盘上，这样的好处是错开高峰期的磁盘 IO，提高 MySQL 的性能。</p><p>配合上前面的 buffer pool 和 change buffer，WAL 就是说在操作 buffer pool 和 change buffer 之前，会先把记录写到 redo log 日志中，然后再去更新 buffer pool 或者 change buffer，这样，即使系统突然崩了，将来也可以通过 redo log 恢复数据。当然，redo log 本身又分为：</p><ul><li>日志缓冲（redo log buffer)，该部分日志是易失性的。</li><li>重做日志(redo log file)，这是磁盘上的日志文件，该部分日志是持久的。</li></ul><p>那有人说，写 redo log 不就是磁盘 IO 吗？而写数据到磁盘也是磁盘 IO，既然都是磁盘 IO，那干嘛不把直接把数据写到磁盘呢？还费这事！</p><p>此言差矣。</p><p>写 redo log 跟写数据有一个很大的差异，那就是 <strong>redo log 是顺序 IO，而写数据涉及到随机 IO</strong>，写数据需要寻址，找到对应的位置，然后更新/添加/删除，而写 redo log 则是在一个固定的位置循环写入，是顺序 IO，所以速度要高于写数据。</p><p>如前文所说，redo log 涉及到两个东西：redo log buffer 和 redo log file，这两个东西我们分别来介绍。</p><h3 id="4-1-redo-log-buffer"><a href="#4-1-redo-log-buffer" class="headerlink" title="4.1 redo log buffer"></a>4.1 redo log buffer</h3><p>先来说 redo log buffer。</p><p>我们说数据的变化先写入 redo log 中，并不是上来就写磁盘，也是先写到内存中，即 redo log buffer，在时机成熟时，再写入磁盘，也就是 redo log file。</p><p>我们先来看看 redo log buffer 有多大：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220213195141.png" alt></p><p><code>16777216 ÷ 1024 ÷ 1024 = 16MB</code></p><p>可以看到，这个 redo log buffer 大小刚好是 16MB，如果你觉得这个值有点小，也可以自行修改其大小。</p><p>数据的变更都会首先记录在这块内存中。小伙伴们知道，MySQL 的增删改，如果我们没有显式的开启事务，MySQL 内部也是有一个事务存在的，当内部这个事务 commit 的时候，redo log buffer 会持久化到磁盘中。</p><p>具体来说，有如下几个持久化时机：</p><ol><li>innodb_flush_log_at_trx_commit</li></ol><p>通过 innodb_flush_log_at_trx_commit 参数来控制持久化时机，该参数默认值为 1，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220213200914.png" alt></p><p>当然开发者可根据自己的实际需求修改该参数。该参数有三种取值，含义分别如下：</p><ul><li>0：每秒一次，将 redo log buffer 中的数据刷新到磁盘中。</li><li>1：每次 commit 时，将 redo log buffer 中的数据刷新到磁盘中，即只要 commit 成功，磁盘上就有对应的 redo log 日志，<strong>这是最安全的情况，也是推荐使用的参数</strong>。</li><li>2：每次 commit 时，将 redo log buffer 中的数据刷新到操作系统缓存中，操作系统缓存中的数据每秒刷新一次，会持久化到磁盘中。</li></ul><p>这是第一种 redo log buffer 持久化的时机。</p><ol start="2"><li>当 redo log buffer 的使用量达到 <code>innodb_log_buffer_size</code> 的一半时，将其写入磁盘成为 redo log file。</li><li>MySQL 关闭时，将 redo log buffer 写入磁盘成为 redo log file。</li></ol><p>那如果 redo log buffer 中的数据还没有磁盘，MySQL 就挂了该怎么办？没写入磁盘，说明你还没 commit，既然没 commit，那就数据修改操作都还没有完成，那只能丢了就丢了，如果已经 commit 了，那么数据就会持久化到 redo log file 中，此时即使 MySQL 挂了，将来 MySQL 重启恢复了，数据也是可以被恢复的。具体的恢复逻辑，就涉及到两阶段提交了，这个松哥在后面的文章中再和大家详细介绍。</p><h3 id="4-2-redo-log-落盘"><a href="#4-2-redo-log-落盘" class="headerlink" title="4.2 redo log 落盘"></a>4.2 redo log 落盘</h3><p>还有一个需要大家注意的问题就是 redo log 落盘，落盘的数据从哪里来？是从 redo log 日志中来还是从 buffer pool 中来？</p><p>在前面的文章中我们说过：binlog 是一种逻辑日志，他里边所记录的是一条 SQL 语句的原始逻辑，例如给某一个字段 +1，这区别于 redo log 的物理日志，物理日志记录的是在某个数据页上做了什么修改。</p><p>由于 redo log 并没有记录数据页的完整数据，所以正常的落盘其实用不到 redo log，数据落盘的时机到了时，直接拿着将脏页（buffer pool）持久化到磁盘中即可。</p><p>好啦，今天就和大家分享这么多，redo log 还有一些内容，我们在后面的文章中再继续聊～</p><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/ZhuChangwu/p/14096575.html" target="_blank" rel="noopener">https://www.cnblogs.com/ZhuChangwu/p/14096575.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;今天想和大家聊一聊 MySQL 中的 redo log，其实最早我是想聊两阶段提交的，后来想想可能有小伙伴还不了解 binlog，所以就先整了一篇 binlog：&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 整合定时任务，可以动态编辑的定时任务！</title>
    <link href="http://www.javaboy.org/2022/0309/elastic_job.html"/>
    <id>http://www.javaboy.org/2022/0309/elastic_job.html</id>
    <published>2022-03-09T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:40.538Z</updated>
    
    <content type="html"><![CDATA[<p>定时任务，松哥之前写过多篇文章和大家介绍，上次还自己 DIY 了一个可以动态编辑的定时任务，还录了一个配套视频：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2021/10/tran/20220303100416.png" alt></p><p>相关的资料链接戳这里：</p><ol><li><a href="https://mp.weixin.qq.com/s/skZ7uU7q1iH9QrV2EKiGOg" target="_blank" rel="noopener">Spring 定时任务玩出花！</a></li><li><a href="https://mp.weixin.qq.com/s/z36P3AZN27uAuHj6ski7dA" target="_blank" rel="noopener">手把手教你定制可编辑的定时任务！</a></li><li><a href="https://mp.weixin.qq.com/s/Dmh2WHHTc_1IBkYFqo_rjQ" target="_blank" rel="noopener">开发可配置的定时任务～第二弹</a></li><li><a href="https://mp.weixin.qq.com/s/JgYa-fzwebYRL_tDCG-9Og" target="_blank" rel="noopener">Vue非典型用法，一个简单的管理页面</a></li></ol><p>不过我们当时自己写的这个不支持分布式环境，想要支持倒也不是啥难事，弄一个 zookeeper 或者 redis 作为公共的信息中心，里边记录了定时任务的各种运行情况，有了这个就能支持分布式环境了。</p><p>今天咱们不自己写了，我们来看一个现成的框架：ElasticJob，有一个跟他齐名的 xxljob，这个咱们以后再抽空介绍。</p><h2 id="1-ElasticJob"><a href="#1-ElasticJob" class="headerlink" title="1. ElasticJob"></a>1. ElasticJob</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>ElasticJob 是一个分布式作业调度解决方案，它的官网是：</p><ul><li><a href="http://shardingsphere.apache.org/elasticjob" target="_blank" rel="noopener">http://shardingsphere.apache.org/elasticjob</a></li></ul><p>Elastic Job 的前身是由当当开源的一款分布式任务调度框架 dd-job，不过在 2020 年 5 月 28 日加入到了 Apache 基金会，成为 Apache 下的一个开源项目：</p><ul><li><a href="https://shardingsphere.apache.org/" target="_blank" rel="noopener">https://shardingsphere.apache.org/</a></li></ul><p>ElasticJob 通过弹性调度、资源管控、以及作业治理的功能，打造一个适用于互联网场景的分布式调度解决方案，并通过开放的架构设计，提供多元化的作业生态。</p><p>使用 ElasticJob 能够让开发工程师不再担心任务的线性吞吐量提升等非功能需求，使他们能够更加专注于面向业务编码设计；同时，它也能够解放运维工程师，使他们不必再担心任务的可用性和相关管理需求，只通过轻松的增加服务节点即可达到自动化运维的目的。</p><p>ElasticJob 是面向互联网生态和海量任务的分布式调度解决方案，由两个相互独立的子项目 <code>ElasticJob-Lite</code> 和 <code>ElasticJob-Cloud</code> 组成。</p><p>其中 <code>ElasticJob-Lite</code> 定位为轻量级无中心化解决方案，使用 jar 的形式提供分布式任务的协调服务：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303114132.png" alt></p><p><code>ElasticJob-Cloud</code> 则采用自研 Mesos Framework 的解决方案，额外提供资源治理、应用分发以及进程隔离等功能：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303114158.png" alt></p><p><code>ElasticJob-Lite</code> VS <code>ElasticJob-Cloud</code>：</p><table><thead><tr><th></th><th>ElasticJob-Lite</th><th>ElasticJob-Cloud</th></tr></thead><tbody><tr><td>无中心化</td><td>是</td><td>否</td></tr><tr><td>资源分配</td><td>不支持</td><td>支持</td></tr><tr><td>作业模式</td><td>常驻</td><td>常驻 + 瞬时</td></tr><tr><td>部署依赖</td><td>ZooKeeper</td><td>ZooKeeper + Mesos</td></tr></tbody></table><p>它的各个产品使用统一的作业 API，开发者仅需一次开发，即可随意部署（即 <code>ElasticJob-Lite</code> 和 <code>ElasticJob-Cloud</code> 使用相同的 API，主要是部署方式不同而已）。</p><h3 id="1-2-功能列表"><a href="#1-2-功能列表" class="headerlink" title="1.2 功能列表"></a>1.2 功能列表</h3><ul><li><p>弹性调度</p><ul><li>支持任务在分布式场景下的分片和高可用</li><li>能够水平扩展任务的吞吐量和执行效率</li><li>任务处理能力随资源配备弹性伸缩</li></ul></li><li><p>资源分配</p><ul><li>在适合的时间将适合的资源分配给任务并使其生效</li><li>相同任务聚合至相同的执行器统一处理</li><li>动态调配追加资源至新分配的任务</li></ul></li><li><p>作业治理</p><ul><li>失效转移</li><li>错过作业重新执行</li><li>自诊断修复</li></ul></li><li><p>作业依赖(TODO)</p><ul><li>基于有向无环图（DAG）的作业间依赖</li><li>基于有向无环图（DAG）的作业分片间依赖</li></ul></li><li><p>作业开放生态</p><ul><li>可扩展的作业类型统一接口</li><li>丰富的作业类型库，如数据流、脚本、HTTP、文件、大数据等</li><li>易于对接业务作业，能够与 Spring 依赖注入无缝整合</li></ul></li><li><p>可视化运维平台(<a href="https://github.com/apache/shardingsphere-elasticjob-ui" target="_blank" rel="noopener">https://github.com/apache/shardingsphere-elasticjob-ui</a>)</p><ul><li>作业管控端</li><li>作业执行历史数据追踪</li><li>注册中心管理</li></ul></li></ul><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p>说了这么多，接下来我们通过一个简单的案例来体验一把 ElasticJob 吧。毕竟有代码，感觉更真实。</p><p>首先我们创建一个 Spring Boot 工程，引入 Web 依赖：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303154038.png" alt></p><p>然后手动加入 ElasticJob 的 starter：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shardingsphere.elasticjob<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticjob-lite-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们创建一个作业，作业有几种不同的创建方式，我们先来看一种基于实现 SimpleJob 接口创建的作业：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 江南一点雨</span></span><br><span class="line"><span class="hljs-comment"> * @微信公众号 江南一点雨</span></span><br><span class="line"><span class="hljs-comment"> * @网站 http://www.itboyhub.com</span></span><br><span class="line"><span class="hljs-comment"> * @国际站 http://www.javaboy.org</span></span><br><span class="line"><span class="hljs-comment"> * @微信 a_java_boy</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@GitHub</span> https://github.com/lenve</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@Gitee</span> https://gitee.com/lenve</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFirstJob</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SimpleJob</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(MyFirstJob.class);</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(ShardingContext shardingContext)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"作业名称：&#123;&#125;；作业参数：&#123;&#125;；分片总数：&#123;&#125;；当前分片：&#123;&#125;；分片参数：&#123;&#125;；任务编号：&#123;&#125;"</span>,shardingContext.getJobName(),shardingContext.getJobParameter(),shardingContext.getShardingTotalCount(),shardingContext.getShardingItem(),shardingContext.getShardingParameter(),shardingContext.getTaskId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定时任务执行的时候，execute 方法会被触发，其中参数 ShardingContext 中保存着定时任务相关的参数，这些参数都是我们在 application.properties 中配置的，我们继续来看：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">elasticjob.reg-center.server-lists=zoo1:2181,zoo2:2182,zoo3:2183</span><br><span class="line">elasticjob.reg-center.namespace=javaboy</span><br><span class="line"></span><br><span class="line">elasticjob.jobs.my-first-job.elastic-job-class=org.javaboy.elasticjob.job.MyFirstJob</span><br><span class="line">elasticjob.jobs.my-first-job.cron=0/3 * * * * ?</span><br><span class="line">elasticjob.jobs.my-first-job.sharding-total-count=1</span><br><span class="line">elasticjob.jobs.my-first-job.overwrite=true</span><br><span class="line">elasticjob.jobs.my-first-job.job-parameter=hello javaboy!</span><br><span class="line">elasticjob.jobs.my-first-job.sharding-item-parameters=0=A,1=B,2=C</span><br></pre></td></tr></table></figure><p>这里的配置分为两大类：</p><ul><li>注册中心配置</li><li>定时任务配置</li></ul><p>使用 ElasticJob 需要注册中心 zookeeper，这个也好理解，因为 ElasticJob 支持任务在分布式场景下的分片和高可用，所以必然需要一个调度中心，这个 zk 就是调度中心。我这里开启了一个 zk 集群，里边有三个实例，三个 zk 地址之间用 <code>,</code> 隔开。同时我们还要配置一个 namespace，这个 namespace 的作用是防止不同应用的定时任务冲突了，我们给每个应用取一个不同于其他应用的 namespace，这样就不用担心冲突了。</p><p>接下来是配置作业。</p><p>配置作业的前缀统一是 <code>elasticjob.jobs</code>，紧接着就是作业的名称，这个作业名称可以随意配置，但是最好能一眼看出来是哪个作业，<code>MyFirstJob#execute</code> 方法中的 <code>shardingContext.getJobName()</code> 获取到的就是这个值。</p><p>我们这里一共配置了六个属性，我来一一解释下：</p><ul><li>elastic-job-class：作业的全路径。</li><li>cron：cron 表达式。</li><li>sharding-total-count：分片的总数，即有几个实例执行当前定时任务,<code>MyFirstJob#execute</code> 方法中的 <code>shardingContext.getShardingTotalCount()</code> 获取到的就是这个值。</li><li>overwrite：是否每次启动的时候覆盖之前的配置，如果设置为 false，则如果修改了 cron 表达式等，重启之后不会生效。</li><li>job-parameter：作业的参数,<code>MyFirstJob#execute</code> 方法中的 <code>shardingContext.getJobParameter()</code> 获取到的就是这个值。</li><li>sharding-item-parameters：分片的参数，0、1、2 分别表示第几个分片,<code>MyFirstJob#execute</code> 方法中的 <code>shardingContext.getShardingParameter()</code> 获取到的就是这个值。</li></ul><p>好啦，现在就配置完成了。</p><h2 id="3-运行"><a href="#3-运行" class="headerlink" title="3. 运行"></a>3. 运行</h2><p>现在我们直接启动 Spring Boot 项目，启动之后，控制台就会打印如下日志：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303211444.png" alt></p><p>没问题，每隔三秒钟打印一次日志。</p><p>现在我们再次启动一个当前项目的实例，勾选 <code>Allow parallel run</code> 就可以启动多个实例（启动新实例时记得修改端口号）：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303212716.png" alt></p><p>当新的实例启动之后，我们发现第一次启动的实例中已经没有打印日志了，转而在第二次启动的实例中打印日志，这就是因为我们配置的 <code>sharding-total-count</code> 为 1，即同一时间只有一个实例中的定时任务在运行。</p><h2 id="3-运维平台"><a href="#3-运维平台" class="headerlink" title="3. 运维平台"></a>3. 运维平台</h2><p>ElasticJob 提供了一个运维平台，可以通过这个平台来动态管理定时任务，运维平台地址：</p><ul><li><a href="https://github.com/apache/shardingsphere-elasticjob-ui" target="_blank" rel="noopener">https://github.com/apache/shardingsphere-elasticjob-ui</a></li></ul><p>运维平台使用步骤：</p><ol><li>克隆项目下来：<code>git clone https://github.com/apache/shardingsphere-elasticjob-ui.git</code>。</li><li>进入到目录中：<code>cd shardingsphere-elasticjob-ui</code>。</li><li>打包：<code>mvn clean package -Prelease</code>。</li><li>打包完成后，解压 <code>shardingsphere-elasticjob-ui/shardingsphere-elasticjob-ui-distribution/shardingsphere-elasticjob-lite-ui-bin-distribution/target/apache-shardingsphere-elasticjob-3.1.0-SNAPSHOT-lite-ui-bin.tar.gz</code> 文件，然后执行其 bin 目录下的 startup.sh 脚本启动。</li></ol><p><strong>上面第三步打包，由于网络原因很容易出错，所以小伙伴们要是打包失败，可以在公众号江南一点雨后台回复 <code>shardingsphere-elasticjob-ui</code>，获取松哥打包好的文件。</strong></p><p>运维平台启动之后，浏览器输入 <code>http://localhost:8088</code> 就会跳转到登录页面，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303214439.png" alt></p><p>默认的用户名密码都是 root。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303214551.png" alt></p><p>注册成功之后，先点击注册中心配置，然后选择添加按钮，先来添加注册中心，添加完注册中心之后，这个运维平台会自动从注册中心上读取定时任务信息：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303215259.png" alt></p><p>如实填写就行了，注意命名空间千万别写错了，写成了其他的就读取不到定时任务了。</p><p>接下来点击连接按钮，建立和 zk 之间的连接：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303215425.png" alt></p><p>点击作业维度，就可以查看作业的详细信息，包括作业名称、分片总数、cron 表达式等：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303215526.png" alt></p><p>最后面有四个操作按钮：</p><ul><li>修改：修改作业的详细信息，例如修改作业的 cron 表达式。</li><li>详情：查看作业的详细信息。</li><li>触发：触发作业的执行。</li><li>失效：相当于暂停作业的执行，点击失效按钮之后，会出现生效按钮，点击生效按钮，作业可以生效继续执行。</li><li>终止：停止该作业。</li></ul><p>点击服务器维度，可以查看服务器信息：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220303220133.png" alt></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，今天就通过一个简单的案例，和小伙伴们展示了一下 ElasticJob 的玩法，关于 ElasticJob 的其他玩法，咱们后面有空继续聊～</p><p>本文案例下载地址：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定时任务，松哥之前写过多篇文章和大家介绍，上次还自己 DIY 了一个可以动态编辑的定时任务，还录了一个配套视频：&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="ElasticJob" scheme="http://www.javaboy.org/tags/ElasticJob/"/>
    
  </entry>
  
  <entry>
    <title>一个不留神，索引就创建重复了</title>
    <link href="http://www.javaboy.org/2022/0307/mysql_index.html"/>
    <id>http://www.javaboy.org/2022/0307/mysql_index.html</id>
    <published>2022-03-07T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:36.791Z</updated>
    
    <content type="html"><![CDATA[<p>相信没有人会故意创建重复的冗余的索引，很多重复和冗余的索引都是在不经意间创建的，今天松哥来和大家捋一捋这个问题。</p><a id="more"></a><p>因为我们日常在使用 MySQL 的过程中，基本上都是使用 InnoDB 引擎，所以接下来的讨论主要是基于 InnoDB 引擎的 B+Tree 索引来讨论，其他的哈希索引全文索引等不在讨论范围种。</p><h2 id="1-与联合索引重复"><a href="#1-与联合索引重复" class="headerlink" title="1. 与联合索引重复"></a>1. 与联合索引重复</h2><p>在前面的文章中，松哥通过好几篇文章和大家分享了联合索引，包括它涉及到的覆盖索引、前缀匹配等等，联合索引好用，但是对联合索引理解不到位的话，可能会创建出如下的重复索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user2`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`address`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`password`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`email`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`user_index1`</span> (<span class="hljs-string">`username`</span>,<span class="hljs-string">`address`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`user_index2`</span> (<span class="hljs-string">`username`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>可以看到，这里创建了两个索引：</p><ul><li>user_index1:这个索引包含两个字段，username 在前 address 在后。</li><li>user_index2:这个索引包含一个字段 username。</li></ul><p>在<a href="https://mp.weixin.qq.com/s/gLoD1-C2H_HEnlA0BMOh-g" target="_blank" rel="noopener">其实 MySQL 中的 like 关键字也能用索引！</a>一文中，松哥跟大家聊了索引的最左匹配原则，即：</p><p><strong>(username,address) 索引既可以当成联合索引来用，也可以通过最左匹配原则当成单独的 (username) 索引来用。</strong></p><p>所以，如果再为 username 字段单独创建一个索引就没有必要了，这反而会导致增删改的时候速度变慢。</p><p>不过怎么说呢，上面这个结论适用于 99% 的场景，可能会有一些特殊情况，例如想把 (username) 和某一个特别长的字段建立一个联合索引，此时如果单独使用 username 字段进行搜索的话，效率可能降低，此时视搜索的重要程度，看是否需要创建一个重复的索引。</p><h2 id="2-主键加入联合索引中"><a href="#2-主键加入联合索引中" class="headerlink" title="2. 主键加入联合索引中"></a>2. 主键加入联合索引中</h2><p>来看看下面这个索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user2`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`address`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`password`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`email`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`user_index`</span> (<span class="hljs-string">`username`</span>,<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>一个名为 <code>user_index</code> 的索引中包含了两个字段 username 和 id，其中 id 是主键。</p><p>在<a href="https://mp.weixin.qq.com/s/SSHWKcuGK5x4Uf7ZBC7stQ" target="_blank" rel="noopener">什么是 MySQL 的“回表”？</a>一文中，松哥和大家聊了，索引按照物理存储方式可以分为聚簇索引和非聚簇索引。</p><p>我们日常所说的主键索引，其实就是聚簇索引（Clustered Index）;主键索引之外，其他的都称之为非主键索引，非主键索引也被称为二级索引（Secondary Index），或者叫作辅助索引。</p><p>对于主键索引和非主键索引，使用的数据结构都是 B+Tree，唯一的区别在于叶子结点中存储的内容不同：</p><ul><li>主键索引的叶子结点存储的是一行完整的数据。</li><li>非主键索引的叶子结点存储的则是主键值以及索引列的值。</li></ul><p>这是两者最大的区别。</p><p>既然主键已经存在于叶子结点中，那当然没有在联合索引中加入主键了。</p><p>好啦，几个小小的注意点，希望能给小伙伴们启发。</p><p>参考资料：</p><ul><li>《高性能 MySQL》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信没有人会故意创建重复的冗余的索引，很多重复和冗余的索引都是在不经意间创建的，今天松哥来和大家捋一捋这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一个没有 Postman 好用的工具，不试一下？</title>
    <link href="http://www.javaboy.org/2022/0302/restful_tools.html"/>
    <id>http://www.javaboy.org/2022/0302/restful_tools.html</id>
    <published>2022-03-02T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:31.045Z</updated>
    
    <content type="html"><![CDATA[<p>忘了 postman 是被谁种草的，很长一段时间内 postman 都是我做接口测试的首选工具，之前也有小伙伴跟我安利过 IDEA 中的 RestfulToolkit 插件，但是一直没机会体验，最近抽空玩了一把，<strong>感觉在某些场景下还蛮不错的（不需要认证的场景下）</strong>，和小伙伴们分享下。</p><a id="more"></a><h2 id="1-RestfulToolkit"><a href="#1-RestfulToolkit" class="headerlink" title="1. RestfulToolkit"></a>1. RestfulToolkit</h2><p>RestfulToolkit 是一套 RESTful 服务开发辅助工具集，它主要提供了如下功能：</p><ol><li>根据 URL 直接跳转到对应的方法定义 ( Ctrl \ or Ctrl Alt N );</li><li>提供了一个 Services tree 的显示窗口;</li><li>一个简单的 http 请求工具;</li><li>在请求方法上添加了有用功能: 复制生成 URL;,复制方法参数…</li><li>其他功能: java 类上添加 Convert to JSON 功能，格式化 json 数据 ( Windows: Ctrl + Enter; Mac: Command + Enter )。</li></ol><p>它支持 Spring 体系 (Spring MVC / Spring Boot 1.x,2.x)；支持 JAX-RS；支持 Java 和 Kotlin 语言。</p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><p>在 IDEA 中选择 File-&gt;Plugins，然后搜索 RestfulToolkit，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220226145046.png" alt></p><p>然后点击 install 按钮即可，安装完成后重启 IDEA 即可：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220226145239.png" alt></p><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><p>创建一个项目，在项目的右边可以看到 Rest Services 选项，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220226145707.png" alt></p><p>点开该选项卡，就可以进行 RESTful 接口测试了。</p><p>松哥写了四个测试接口，大家来看一下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/book"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">addBook</span><span class="hljs-params">(Book book)</span> </span>&#123;</span><br><span class="line">        System.out.println(book);</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"添加成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/book/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getBookById</span><span class="hljs-params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">        Book book = <span class="hljs-keyword">new</span> Book();</span><br><span class="line">        book.setId(id);</span><br><span class="line">        <span class="hljs-keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/book"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">updateBook</span><span class="hljs-params">(@RequestBody Book book)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"更新成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/book"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deleteBookById</span><span class="hljs-params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"删除成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这四个借口基本上涵盖了我们日常常见的传参方式，启动项目，我们来看下右边：</p><p>可以看到，项目启动成功后，四个测试接口都会在 RestfulToolkit 工具中展示出来：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220226152203.png" alt></p><p>并且不同的接口，都有对应的默认参数，例如更新接口，参数是 JSON 格式，这里就会自动列出来：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220226152413.png" alt></p><p>开发者只需要根据实际情况重新填一下具体的参数值即可。</p><p>测试成功，结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220226153415.png" alt></p><p>RestfulToolkit 有一个功能，就是点击接口，可以跳转到对应的方法定义上，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220226153536.png" alt></p><p>选中接口，右键单击，有两个选项：</p><ul><li>Copy Full Url：拷贝完整的 URL 地址。</li><li>Jump to Source：跳转到接口定义的代码处。</li></ul><p>除了这个，RestfulToolkit 还能帮我们根据一个类，快速转换为 JSON，有时候我们用 postman 测试的时候，自己写 JSON 太慢了，这是一个好办法，具体操作如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220226153842.png" alt></p><p>选中类名，右键单击，最上面有两个选项，如下：</p><ul><li>Convert to JSON（Compressed）：生成一个压缩后的 JSON，其实就是一行 JSON。</li><li>Convert to JSON：生成一个带格式的 JSON。</li></ul><h2 id="4-一个题外话"><a href="#4-一个题外话" class="headerlink" title="4. 一个题外话"></a>4. 一个题外话</h2><p>有的小伙伴可能会问，用 RestfulToolkit 的话，基于 Cookie+Session 的认证怎么办？其实，一个合格的 RESTful 接口，本身就是无状态的，既然是无状态的，那么认证就不需要 Cookie 了，每个请求都自己带上令牌就行了，反正 RestfulToolkit 也支持修改请求头。</p><p>不过话说回来，如果你的项目就是基于 Cookie + Session 认证的，那么接口测试，我还是建议使用 postman，毕竟这个工具更专业。或者你也可以试试 IDEA 自带的 Http Client 工具，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220226154722.png" alt></p><p>好啦，今天和小伙伴们分享了一个小工具，感兴趣的小伙伴可以去体验一把啦～对了，2020 版之后的 IDEA 可以使用 Restful Tools。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忘了 postman 是被谁种草的，很长一段时间内 postman 都是我做接口测试的首选工具，之前也有小伙伴跟我安利过 IDEA 中的 RestfulToolkit 插件，但是一直没机会体验，最近抽空玩了一把，&lt;strong&gt;感觉在某些场景下还蛮不错的（不需要认证的场景下）&lt;/strong&gt;，和小伙伴们分享下。&lt;/p&gt;
    
    </summary>
    
      <category term="IDEA" scheme="http://www.javaboy.org/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>查询中，有没有可能多个索引一起用呢？</title>
    <link href="http://www.javaboy.org/2022/0301/mysql_multi_index.html"/>
    <id>http://www.javaboy.org/2022/0301/mysql_multi_index.html</id>
    <published>2022-03-01T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:26.906Z</updated>
    
    <content type="html"><![CDATA[<p>其实我们之前所讲的回表，就是两个索引树同时使用，先在二级索引树中搜索到对应的主键值，然后在再去主键索引树中查询完整的记录。</p><p>但是我今天的问题是，两个不同的二级索引树，会同时生效吗？理论上来说，应该是可以同时生效的，不然这个 MySQL 也太笨了。<strong>不过根据松哥日常开发经验，这种事情最好能够避免，如果发生了同时搜索两棵索引树的事情，大概是你的索引设计有问题，此时就要去检查一下索引的设计是否合理。</strong></p><a id="more"></a><p>加粗的是实践经验，但是对于两个索引同时生效的知识点，我们还是要懂，一起来看下。</p><h2 id="1-索引合并"><a href="#1-索引合并" class="headerlink" title="1. 索引合并"></a>1. 索引合并</h2><p>例如我有如下一张表结构：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`address`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`password`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`email`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`username`</span> (<span class="hljs-string">`username`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`address`</span> (<span class="hljs-string">`address`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">100001</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>这个表里边有 username 和 address 两个索引，注意是两个索引，每个索引中有一个字段，这不是联合索引。</p><p>现在我的查询 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'1'</span> <span class="hljs-keyword">or</span> address=<span class="hljs-string">'1'</span>;</span><br></pre></td></tr></table></figure><p>搜索条件有两个，username 和 address，这是两个索引，分属于两棵不同的索引树。那么它在搜索的时候会两棵索引树都去搜索吗？还是只搜索一颗索引树，再用另一个搜索条件过滤第一棵树搜索出来的结果？</p><p>我们来看下数据库执行计划：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220127181705.png" alt></p><p>大致上瞥一眼这个执行计划，大家也能猜出来，这里其实两个索引都用到了，在这个执行计划中有几个新面孔：</p><ul><li>type 为 <code>index_merge</code>。</li><li>Extra 为 <code>Using union(username,address); Using where</code>。</li></ul><p>这个 type 中的 <code>index_merge</code> 就是索引合并。</p><h2 id="2-旧版玩法"><a href="#2-旧版玩法" class="headerlink" title="2. 旧版玩法"></a>2. 旧版玩法</h2><p>当然这个 <code>index_merge</code> 并不是一开始就有的，这是从 MySQL5.0 开始引入的东西。虽然大家现在基本山不会再用到 MySQL5.0 之前的版本了，但是我这里还是说一下，加深大家对 MySQL 的理解。在 MySQL5.0 之前，对于我们上面给出的查询 SQL，是不会走索引的，会全表扫描。在那个年代，如果你想实现上面这个查询，但是又想走索引，你的 SQL 得这样写：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username=<span class="hljs-string">'1'</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> address=<span class="hljs-string">'1'</span> <span class="hljs-keyword">and</span> username!=<span class="hljs-string">'1'</span></span><br></pre></td></tr></table></figure><p>不过这种写法很明显有点笨拙。</p><p>所以，从 MySQL5.0 开始，在查询中可以自动使用多个索引进行扫描，并将结果进行合并，也就是我们前面所说的索引合并（<code>index_merge</code>）。</p><h2 id="3-三种情况"><a href="#3-三种情况" class="headerlink" title="3. 三种情况"></a>3. 三种情况</h2><p>索引合并这种算法有三个变种，我们分别来看。</p><h3 id="3-1-union"><a href="#3-1-union" class="headerlink" title="3.1 union"></a>3.1 union</h3><p>这是求两个索引的并集。</p><p>我们来看如下 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">'1%'</span> <span class="hljs-keyword">or</span> address <span class="hljs-keyword">like</span> <span class="hljs-string">'1%'</span>;</span><br></pre></td></tr></table></figure><p>这个 SQL 在执行的过程中就会涉及到两个索引，需要去两棵索引树中进行搜索，再对搜索结果求并集，我们来看一下该 SQL 的执行计划：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220128113849.png" alt></p><p>可以看到，这个执行计划中已经发生了索引合并（看 type 、key、Extra）。</p><p>那么是不是只要是两个索引查询就总会发送索引合并呢？我们再来看一个栗子：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username&gt;<span class="hljs-string">'a'</span> <span class="hljs-keyword">or</span> address=<span class="hljs-string">'1'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220128115014.png" alt></p><p>大家看一下，只是搜索条件变了一下而已，这里就没用索引合并了，而变成了全表扫描，这是为什么呢？这就引出来索引合并的一个条件，即：每个索引对应的搜索条件，搜到的主键必须是有序的，如果搜到的主键是无序的，抱歉，索引合并用不了。在二级索引中，数据按照二级索引的顺序进行排序，结构类似下面这样：</p><table><thead><tr><th style="text-align:left">username</th><th style="text-align:left">主键</th></tr></thead><tbody><tr><td style="text-align:left">a</td><td style="text-align:left">20</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">18</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">5</td></tr></tbody></table><p>当 username 相同的时候，主键是有序的，当 username 不同的时候，就不能保证主键有序了，如果获取到的主键无序，就无法实现索引合并了。</p><p>这又引出来一个问题，为什么获取到的主键有序才能发生索引合并呢？因为只有当主键是有序的，将来去重（union、sort-union）亦或者求交集（intersect），效率都要高一些。</p><p>从 MySQL5.0 开始，索引合并默认是开启的，当然你也可以选择关闭，关闭 union 索引合并方式如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> optimizer_switch = <span class="hljs-string">'index_merge_union=off'</span>;</span><br></pre></td></tr></table></figure><p>关闭之后再来看执行计划：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220128135357.png" alt></p><p>大家看到，依然发生了索引合并，但是这次不是 union，而是 sort_union 了，那我们接下来就来看下什么是 sort_union。</p><h3 id="3-2-sort-union"><a href="#3-2-sort-union" class="headerlink" title="3.2 sort_union"></a>3.2 sort_union</h3><p>sort_union 基本上和 union 一样，只是多了一个排序的能力。</p><p>因为前面我们说，如果获取到无序的主键，就不会发生索引合并，可能最终会直接上全表扫描。因此 MySQL 里边又搞了一个 sort_union，就是先在 username 索引树和 address 索引树中同时进行搜索，<strong>分别拿到主键值之后先进行排序</strong>，排序完了再进行去重，然后回表拿完整的数据。</p><p>和 union 相比主要是多了加粗的那一步。</p><p>那我们继续，关闭 sort_union，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> optimizer_switch = <span class="hljs-string">'index_merge_sort_union=off'</span>;</span><br></pre></td></tr></table></figure><p>关闭之后，再去看执行计划，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220128142211.png" alt></p><p>此时就没有索引合并了，直接全表扫描。</p><h3 id="3-3-intersect"><a href="#3-3-intersect" class="headerlink" title="3.3 intersect"></a>3.3 intersect</h3><p>这个是求两个索引的交集。</p><p>例如如下 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">'1%'</span> <span class="hljs-keyword">and</span> address <span class="hljs-keyword">like</span> <span class="hljs-string">'1%'</span>;</span><br></pre></td></tr></table></figure><p>这个 SQL 在执行的过程中就有可能出现求交集的情况。当然这并非绝对的，具体还要看优化器优化后的情况。</p><p>松哥尝试了很久，没法复现一个例子出来，主要是我的模拟数据不太对味。如果小伙伴们有现成的 Using intersect 例子欢迎留言分享（执行计划 Extra 中会出现 Using intersect 的）。</p><p>但是我把这个原理这里和大家分享下，我们来看如下一张图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220128105232.png" alt="图片源自网络"></p><p>假设有二级索引 S 和二级索引 T，现在交叉获取主键（<strong>这里有一点需要注意，如果我们是单独在 S 和 T 上搜索，且 S 上搜索条件是 <code>username like &#39;1%&#39;</code>，T 上的搜索条件是 <code>address like &#39;1%&#39;</code>，那么在搜索的过程中，各自拿到的主键 id 是有序的，这也是 intersect 的前提</strong>）：</p><ol><li>首先去二级索引 S 上去搜索，找到第一条满足条件的记录，由于二级索引的叶子结点保存的是主键值，此时拿到主键值之后，先不要急着回表。</li><li>接下来去二级索引 T 上去搜索，找到第一条满足条件的记录，并且拿到对应的主键值。</li><li>比较第一步和第二步搜索拿到的主键值：<br> 3.1 如果主键值不相等，则舍弃值小的主键，留下大的主键，下一次在 S 上搜索的时候，就拿着这个大的主键和 S 上搜索出来的主键进行比较。<br> 3.2 如果主键值相等，则说明这个主键是满足搜索条件的，那就拿着这个主键回表。</li><li>重复前三步，直到各自索引中没有满足条件的记录为止。</li></ol><p>这就是所谓的<strong>交叉获取主键</strong>。</p><p>好啦，这就是索引合并的三种情况。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>很多小伙伴可能会说，既然有索引合并，是不是我索引就可以随便建立了？nonono！索引合并是一种不得已而为之的办法，如果发生了索引合并，大概率是你设计的索引不太合理导致的，所以我们应该去琢磨该如何优化索引。</p><p>参考资料：</p><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html</a></li><li>《MySQL 是怎么运行的》</li><li>《高性能 MySQL》</li><li><a href="https://www.modb.pro/db/29619" target="_blank" rel="noopener">https://www.modb.pro/db/29619</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实我们之前所讲的回表，就是两个索引树同时使用，先在二级索引树中搜索到对应的主键值，然后在再去主键索引树中查询完整的记录。&lt;/p&gt;
&lt;p&gt;但是我今天的问题是，两个不同的二级索引树，会同时生效吗？理论上来说，应该是可以同时生效的，不然这个 MySQL 也太笨了。&lt;strong&gt;不过根据松哥日常开发经验，这种事情最好能够避免，如果发生了同时搜索两棵索引树的事情，大概是你的索引设计有问题，此时就要去检查一下索引的设计是否合理。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 中如何完成 Git 版本回退？</title>
    <link href="http://www.javaboy.org/2022/0228/idea_git_reset.html"/>
    <id>http://www.javaboy.org/2022/0228/idea_git_reset.html</id>
    <published>2022-02-28T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:23.860Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>上周的文章发了后，有小伙伴问如何在 IDEA 中进行 Git 的版本回退？</p><p>其实这个松哥之前写过文章，但是时间久远了，所以今天再和小伙伴们重新捋一捋这个话题，顺便也来聊聊如何在 IDEA 中进行 Git 的版本回退。</p><a id="more"></a><p>Git 中的撤销操作，我们可以归纳为四类：</p><ol><li>工作区的代码想撤销</li><li>add到暂存区的代码想撤销</li><li>提交到本地仓库的代码想撤销</li><li>远程仓库的代码想要撤销</li></ol><h2 id="1-基于命令行"><a href="#1-基于命令行" class="headerlink" title="1. 基于命令行"></a>1. 基于命令行</h2><h3 id="1-1-工作区的代码想撤销"><a href="#1-1-工作区的代码想撤销" class="headerlink" title="1.1 工作区的代码想撤销"></a>1.1 工作区的代码想撤销</h3><p>可能有一天我正在写代码，写了很久发现写错了，想恢复到一开始的状态，一个笨办法就是把刚刚写的代码一行一行的删除，不过这种方式成本太高，我们可以通过<code>git checkout -- &lt;file&gt;</code> 命令来撤销工作区的代码修改。如下图：</p><p><img src="http://www.javaboy.org/images/git/p182.gif" alt="p182"></p><p>首先我们执行了 <code>git status</code> 命令，发现工作区是干净的，然后执行了 cat 命令，发现文件只有两行内容，然后通过 vi 编辑器向文件中添加一行，保存并退出，退出来之后又执行了 <code>git status</code> 命令，此时工作区的状态已经发生变化，然后我们执行了 <code>git checkout -- git01.txt</code> 命令，表示撤销之前的操作，让 <code>git01.txt</code> 恢复到之前的状态，该命令执行成功之后，我们再执行 <code>cat</code> 命令发现文件内容已经恢复了，此时再执行 <code>git status</code>，状态也恢复了。</p><h3 id="1-2-add-到暂存区的代码想撤销"><a href="#1-2-add-到暂存区的代码想撤销" class="headerlink" title="1.2 add 到暂存区的代码想撤销"></a>1.2 add 到暂存区的代码想撤销</h3><p>如果想要撤销，但是代码已经提交到暂存区了，不用担心，也能撤销，分两个步骤：</p><ol><li>将暂存区的代码撤销到工作区</li><li>将工作区的代码撤销(具体操作和 1.1 小节一致)</li></ol><p>将暂存区的代码撤销，我们可以使用 <code>git reset HEAD</code> 命令来实现。如下图：</p><p><img src="http://www.javaboy.org/images/git/p183.gif" alt="p183"></p><p>这里的代码都比较简单，核心的过程就是先执行 <code>git reset HEAD</code> 命令，从暂存区撤销，剩下的操作参考 1.1 小节。</p><h3 id="1-3-提交到本地仓库的代码想撤销"><a href="#1-3-提交到本地仓库的代码想撤销" class="headerlink" title="1.3 提交到本地仓库的代码想撤销"></a>1.3 提交到本地仓库的代码想撤销</h3><p>同样的，提交到本地仓库的代码一样也可以撤销，我们可以利用 <code>git reset --hard &lt;版本号&gt;</code> 命令来实现版本回退，该命令中的版本号有几种不同的写法：</p><ol><li>可以使用 <code>HEAD^</code> 来描述版本，一个 <code>^</code> 表示前一个版本，两个 <code>^^</code> 表示前两个版本，以此类推。</li><li>也可以使用数字来代替 <code>^</code>，比如说前 <code>100</code> 个版本可以写作 <code>HEAD~100</code>。</li><li>也可以直接写版本号，表示跳转到某一个版本处。我们每次提交成功后，都会生成一个哈希码作为版本号，所以这里我们也可以直接填版本号，哈希码很长，但是我们不用全部输入，只需要输入前面几个字符即可，就能识别出来。</li></ol><p>看下面一系列的操作：</p><ol><li>通过 <code>git log</code> 查看当前提交日志：</li></ol><p><img src="http://www.javaboy.org/images/git/p184.png" alt="p184"></p><ol start="2"><li>通过 <code>git reset HEAD^^</code> 向前回退两个版本：</li></ol><p><img src="http://www.javaboy.org/images/git/p185.png" alt="p185"></p><ol start="3"><li>查看日志，发现最后一次提交的版本号是 <code>695ce1fe</code>,利用 <code>git reset --hard 695ce1fe</code> 命令回到回退之前的状态：</li></ol><p><img src="http://www.javaboy.org/images/git/p186.png" alt="p186"></p><ol start="4"><li>通过 <code>git reset --hard HEAD~1</code> 回到上一个版本：  </li></ol><p><img src="http://www.javaboy.org/images/git/p187.png" alt="p187"></p><p><strong>当然以上操作都是基于命令行的，如果你命令行操作比较熟练的话，其实命令行操作比 IDEA 上点点点要快很多。</strong></p><h3 id="1-4-远程仓库撤销"><a href="#1-4-远程仓库撤销" class="headerlink" title="1.4 远程仓库撤销"></a>1.4 远程仓库撤销</h3><p>如果代码提交到远程仓库了，想要撤销，那就如 1.3 小节所讲，先在本地仓库撤销，然后 push 到远程仓库即可。</p><h2 id="2-基于-IDEA"><a href="#2-基于-IDEA" class="headerlink" title="2. 基于 IDEA"></a>2. 基于 IDEA</h2><p>看懂了命令行操作，再看基于 IDEA 的操作就容易多了。</p><h3 id="2-1-未提交就撤销"><a href="#2-1-未提交就撤销" class="headerlink" title="2.1 未提交就撤销"></a>2.1 未提交就撤销</h3><p>对于第一小节的前两种撤销操作，即修改的文件还没 commit，此时想要撤销，方式很简单，点击 IDEA 右上角的撤销按钮：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223212635.png" alt></p><p>如果你修改了文件，无论有没有执行 <code>git add</code> 命令，只要没有 commit，都可以通过这个按钮撤销修改，点击该按钮，弹出如下提示框：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223212805.png" alt></p><p>这里会列出来所有修改但是没有 commit 的文件，想要撤销哪个文件的修改，就勾选该文件，然后点击 Rollback 按钮就完成了撤销操作。</p><h3 id="2-2-commit-了想撤销"><a href="#2-2-commit-了想撤销" class="headerlink" title="2.2 commit 了想撤销"></a>2.2 commit 了想撤销</h3><p>如果已经 commit 了，那么就需要先打开提交日志，点击如下按钮打开：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223213854.png" alt></p><p>也可以直接点击 IDEA 右上角的时钟图标，快速打开提交日志：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223220557.png" alt></p><p>提交日志类似下面这样：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223214031.png" alt></p><p>此时的回退就分情况了。</p><p>首先这个撤销操作分两种：</p><ul><li>Revert Commit</li><li>Undo Commit</li></ul><p>我们分别来看。</p><h4 id="2-2-1-Undo-Commit"><a href="#2-2-1-Undo-Commit" class="headerlink" title="2.2.1 Undo Commit"></a>2.2.1 Undo Commit</h4><p>Undo Commit 这个操作只能在最近一次提交上使用，不能在其他提交上使用，最近一次 commit 上，右键单击，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223214927.png" alt></p><p>其他的 commit 上右键单击：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223215004.png" alt></p><p>既然如此，我们就来看看最近的一次 commit 如何 Undo Commit。</p><p>在最近一次 commit 日志上右键单击后选择 Undo Commit，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223220915.png" alt></p><p>选中后，直接点击 OK，撤销最近一次的 commit。</p><p>这就是撤销最近一次 commit，撤销之后，本地的修改相当于变成了已 add 但是未 commit 的状态，此时我们可以继续开发新代码，然后再 commit，再 push；或者也可以像 2.1 小节介绍的那样，继续撤销操作。</p><p><strong>我电脑上的 IDEA 在这块操作中有个偶发性问题，就是撤销掉 commit 之后，IDEA 检测不到文件处于未提交状态，需要我把 IDEA 关掉重新打开，IDEA 就能发现文件处于未提交状态了，此时就可以按照 2.1 小节的步骤继续回退了，这块小伙伴们在试验的时候可以留意下。</strong></p><h4 id="2-2-2-Revert-Commit"><a href="#2-2-2-Revert-Commit" class="headerlink" title="2.2.2 Revert Commit"></a>2.2.2 Revert Commit</h4><p>Revert Commit 这个操作到处都能用，不同于 Undo Commit，Revert Commit 之后，会产生一条提交记录。相当于 Revert Commit 其实也是提交，只不过提交的内容刚好相反，刚好刷掉已有内容。</p><p>Revert Commit 操作可以用在所有的日志上，而不仅仅是刚刚提交的 commit。</p><p>操作方式如下：</p><p>找到需要回滚的地方，右键单击，选择 Revert Commit：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223222557.png" alt></p><p>此时会弹出来一个提交的对话框，就是一个普普通通的 commit 对话框，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223222646.png" alt></p><p>commit 之后，可以看到内容已经撤销了，提交日志中也多了一条记录，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220223222856.png" alt></p><h3 id="2-3-push-了想撤销"><a href="#2-3-push-了想撤销" class="headerlink" title="2.3 push 了想撤销"></a>2.3 push 了想撤销</h3><p>如果已经 push 到远程仓库了，怎么撤销？</p><p>其实跟 2.2 小节一样，先在本地仓库撤销，撤销完成后，重新修改代码，最后再 force push 就行了，不过 force push 的时候，注意别把同事的代码给覆盖了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，今天和小伙伴们分享了 Git 中的几个撤销问题，有问题的小伙伴欢迎留言讨论呀～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;上周的文章发了后，有小伙伴问如何在 IDEA 中进行 Git 的版本回退？&lt;/p&gt;
&lt;p&gt;其实这个松哥之前写过文章，但是时间久远了，所以今天再和小伙伴们重新捋一捋这个话题，顺便也来聊聊如何在 IDEA 中进行 Git 的版本回退。&lt;/p&gt;
    
    </summary>
    
      <category term="IDEA" scheme="http://www.javaboy.org/categories/IDEA/"/>
    
    
      <category term="Git" scheme="http://www.javaboy.org/tags/Git/"/>
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>可前进可后退，IDEA 中这个功能神了！</title>
    <link href="http://www.javaboy.org/2022/0225/idea_local_history.html"/>
    <id>http://www.javaboy.org/2022/0225/idea_local_history.html</id>
    <published>2022-02-25T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:20.338Z</updated>
    
    <content type="html"><![CDATA[<p>当我写这篇文章的时候，想起来 N 年前一件往事，我一不小心删除了一个刚刚写好的页面，又气又恼，后来趁着还有印象默默的花了半个多小时又重写了一遍，那个时候要是知道 IDEA 中这个功能该有多好呀！</p><p>今天跟小伙伴们介绍一下 IDEA 中的 Local History 功能。</p><a id="more"></a><h2 id="1-Local-History"><a href="#1-Local-History" class="headerlink" title="1. Local History"></a>1. Local History</h2><p>其实 IDEA 中这些小功能可能大家也都知道，但是如果没留意可能就辜负了开发 IDEA 的同行们的一篇苦心了。</p><p>IDEA 中的 Local History 功能可以帮助我们不断跟踪对项目文件所作的更改，并且这个跟踪不受版本控制的影响，换句话说，无论你用不用 Git、Svn 等工具，IDEA 中的 Local History 功能都是可用的。</p><p>IDEA 中的 Local History 功能不需要我们手动 commit，当我们 coding、testing 或者 deploying 项目的时候，它会自动记录我们项目文件的状态。</p><p>通过 IDEA 自带的 Local History 功能，我们恢复已经删除的文件，恢复某个文件的某一次更改或者将文件回滚到历史中的任意时刻，最为关键的是这一切不依赖版本控制工具。</p><p>不过需要注意的是，Local History 功能虽然好用，但是不能用来代替版本控制工具，这主要有如下一些原因：</p><ol><li>Local History 具有保留期，到期之后，版本数据会丢失。</li><li>Local History 有最大大小，因此无法保证版本数据会持续存在。</li><li>安装新版本的 IDEA 时会自动清除本地历史记录。</li><li>用户手动点击了 File-&gt;Invalidate Caches/Restart，也会导致版本数据丢失。</li></ol><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>举几个例子。</p><h3 id="2-1-恢复删除的文件"><a href="#2-1-恢复删除的文件" class="headerlink" title="2.1 恢复删除的文件"></a>2.1 恢复删除的文件</h3><p>假设我有一个项目，叫做 druid_monitor，这个项目没有使用版本控制工具 Git 或者 Svn。</p><p>现在我不小心删除了该项目中的一个名为 <code>RemoveAdFilter</code> 的类，删完之后，我发现删除错误，想要恢复，那怎么办呢？</p><p>选中当前工程，右键单击，依次选择 <code>Local History-&gt;Show History</code>，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220222214320.png" alt></p><p>在打开的页面中，我们可以看到这个项目中的文件变化：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220222214402.png" alt></p><p>第一条记录就是我们刚刚删除的记录，现在我想恢复刚刚删除的文件，那么我们选中第一条日志，右键单击，选择 Revert，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220222214609.png" alt></p><p>数据恢复之后，可以看到又多了一条日志记录：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220222214636.png" alt></p><h3 id="2-2-恢复文件的变化"><a href="#2-2-恢复文件的变化" class="headerlink" title="2.2 恢复文件的变化"></a>2.2 恢复文件的变化</h3><p>如果你有某一个类，想要回到历史中的某一个版本，那么直接选择这个类，然后进行版本回退即可。</p><p>看中了哪个历史版本，选中然后点击 Revert 即可。中间那个就是历史上的状态，右边则是这个类当前的状态：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220222215642.png" alt></p><h3 id="2-3-打标签"><a href="#2-3-打标签" class="headerlink" title="2.3 打标签"></a>2.3 打标签</h3><p>如果某一时间代码的状态比较重要，可以打个标签标记一下，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220222223031.png" alt></p><p>选择 Put Label… 设置一个标签，将来在 Show History 中就可以看到这个标签了，这个有点像 Git 中的 Tag 功能，但是不完全一样。</p><h2 id="3-修改有效期"><a href="#3-修改有效期" class="headerlink" title="3. 修改有效期"></a>3. 修改有效期</h2><p>默认文件的 Local History 保存时间是 5 个 working day，意思就是在五个自然日中修改该文件。例如周一改了文件，周二没动，周三改了文件，那么就算两天。</p><p>不过这个日期可以自己修改，修改方式如下：</p><ol><li>Ctrl+Shift+A，唤出 Action。</li><li>输入 Registry，然后按回车。</li></ol><p><img src="http://img.itboyhub.com/2021/10/tran/20220222223413.png" alt></p><ol start="3"><li>找到 <code>localHistory.daysToKeep</code> 然后进行修改，如下：</li></ol><p><img src="http://img.itboyhub.com/2021/10/tran/20220222223521.png" alt></p><p>将该值置为 0 就关闭了 Local History 功能。</p><h2 id="4-版本内容保存位置"><a href="#4-版本内容保存位置" class="headerlink" title="4. 版本内容保存位置"></a>4. 版本内容保存位置</h2><p>Local History 记录的内容保存在本地，不同系统保存位置分别如下：</p><p><strong>Windows：</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%LOCALAPPDATA%\JetBrains\&lt;product&gt;&lt;version&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\JohnS\AppData\Local\JetBrains\IntelliJIdea2021.3</span><br></pre></td></tr></table></figure><p><strong>Mac：</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Caches/JetBrains/&lt;product&gt;&lt;version&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Caches/JetBrains/IntelliJIdea2021.3</span><br></pre></td></tr></table></figure><p><strong>Linux：</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.cache/JetBrains/&lt;product&gt;&lt;version&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.cache/JetBrains/IntelliJIdea2021.3</span><br></pre></td></tr></table></figure><p>好啦，每天一个小技能～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我写这篇文章的时候，想起来 N 年前一件往事，我一不小心删除了一个刚刚写好的页面，又气又恼，后来趁着还有印象默默的花了半个多小时又重写了一遍，那个时候要是知道 IDEA 中这个功能该有多好呀！&lt;/p&gt;
&lt;p&gt;今天跟小伙伴们介绍一下 IDEA 中的 Local History 功能。&lt;/p&gt;
    
    </summary>
    
      <category term="IDEA" scheme="http://www.javaboy.org/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 中玩转 Git</title>
    <link href="http://www.javaboy.org/2022/0222/idea_git.html"/>
    <id>http://www.javaboy.org/2022/0222/idea_git.html</id>
    <published>2022-02-22T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:16.843Z</updated>
    
    <content type="html"><![CDATA[<p>Git 有很多客户端工具，不过感觉还是命令行操作最好用，方便又快捷，不过命令行操作需要小伙伴们对 Git 命令比较熟练，这可能对有的人来说会有一些难度，所以，客户端工具有时候也不能抛弃，如果非要推荐一个 Git 客户端工具，我觉得还是 IDEA 中的 Git 插件吧。其他的 Git 客户端工具松哥之前也有体验过一些，不过感觉还是 IDEA 中的用起来更加省事。</p><a id="more"></a><p>今天这篇文章算是我第二次教大家在开发工具中使用 Git 了，刚毕业的时候，松哥写过一篇文章，教大家在 Eclipse 中使用 Git，那时候在 Eclipse 中使用 Git 是真的麻烦，光是插件就要安装半天，刚刚翻了一下那篇文章，已经是七年前的事情了。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220122037.png" alt></p><p>七年之后，Eclipse 也没了往日的风光，IDEA 逐渐成了开发的主流工具，咱们今天就来捋一捋 IDEA 中使用 Git。</p><h2 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1. 基本配置"></a>1. 基本配置</h2><p>首先你要安装 Git，这个就不需要我多说了，IDEA 上默认也是安装了 Git 插件，可以直接使用。</p><p>为了给小伙伴们演示方便，我这里使用 GitHub 作为远程仓库，如果还有人不清楚 GitHub 和 Git 的区别，可以在公众号江南一点雨底部菜单栏查看 Git 教程，看完了就明白了。</p><p>从 2021.08.13 号开始，IDEA 上配置 GitHub 有一个小小的变化，即不能使用用户名密码的方式登录了，如果你尝试用用户名/密码的方式登录 GitHub 提交代码，会收到如下提示：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Support for password authentication was removed on August 13, 2021. </span><br><span class="line">Please use a personal access token instead.</span><br></pre></td></tr></table></figure><p>在 IDEA 上使用用户名/密码的方法登录 GitHub 也会报如下错误：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220124429.png" alt></p><p>需要我们点击右上角的 <code>Use Token</code>，使用令牌的方式登录 GitHub，令牌的生成方式如下：</p><ol><li>网页上登录你的 GitHub 账号。</li><li>点击右上角，选择 Settings：</li></ol><p><img src="http://img.itboyhub.com/2021/10/tran/20220220124716.png" alt></p><ol start="3"><li>拉到最下方，选择左边的 Developer settings：</li></ol><p><img src="http://img.itboyhub.com/2021/10/tran/20220220124843.png" alt></p><ol start="4"><li>选择左边的 Personal access tokens，然后点击右上角的 Generate new token：</li></ol><p><img src="http://img.itboyhub.com/2021/10/tran/20220220125027.png" alt></p><ol start="5"><li>填一下基本信息，选一下权限即可（权限需要选择 repo 和 gist，其他根据自己的需求选择）：</li></ol><p><img src="http://img.itboyhub.com/2021/10/tran/20220220125332.png" alt></p><ol start="6"><li>最后会生成一个令牌，拷贝到 IDEA 中即可，如下：</li></ol><p><img src="http://img.itboyhub.com/2021/10/tran/20220220125641.png" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220125621.png" alt></p><p>这就是基本配置。</p><p>小伙伴们在公司做开发，一般是不会将 GitHub 作为远程仓库的，那么这块根据自己实际情况来配置就行了。</p><h2 id="2-clone"><a href="#2-clone" class="headerlink" title="2. clone"></a>2. clone</h2><p>头一天上班，首先上来要先 clone 项目下来，IDEA 中有对应的 clone 工具，我们直接使用即可：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220160624.png" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220160713.png" alt></p><p>这块也可以直接选择下面的 GitHub，然后直接从自己的 GitHub 仓库上拉取新代码。</p><p>clone 完成之后，IDEA 会提示是否打开该项目，选择 yes 即可。</p><p>代码 clone 下来之后，就可以根据松哥前文介绍的 Git Flow 开始开发了。</p><h2 id="3-分支"><a href="#3-分支" class="headerlink" title="3. 分支"></a>3. 分支</h2><p>假设我们先创建 develop 和 release 分支，创建方式如下，选中当前工程，右键单击，然后依次选择 <code>Git-&gt;Repository-&gt;Branches...</code>：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220161745.png" alt></p><p>或者依次点击顶部的 <code>VCS-&gt;Git-&gt;Branches...</code>：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220161935.png" alt></p><p>当然两个方式都比较麻烦，直接点击 IDEA 的右下角最为省事，也是最常用的办法，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220162142.png" alt></p><p>选择 New Branch，然后创建新的分支，勾选上 Checkout 表示分支创建成功后，切换到该分支上，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220162228.png" alt></p><p>选择一个分支，然后点击 Checkout，可以切换到该分支上：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220162639.png" alt></p><p>接下来我们把 develop 分支提交到远程仓库，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220163730.png" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220163812.png" alt></p><p>我们没有修改代码，所以直接点击 Push 按钮提交即可。</p><p>提交完成后，develop 后面多了 origin 前缀，Remote Branches 中也多了 develop 分支，说明提交成功。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220163857.png" alt></p><p>现在假设我们想从 develop 上拉一个名为 feature-login 的分支，来完成登录功能，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220164419.png" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220164447.png" alt></p><p>从创建的日志中，我们能看到 feature-login 确实是来自 develop：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220164516.png" alt></p><p>好啦，接下来我们就可以愉快的开启一天的工作啦～</p><p>feature-login 上的功能开发完成后，首先点击 IDEA 的右上角完成本地仓库的提交，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220164913.png" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220165252.png" alt></p><p>填入提交的 Message，下方也能看到不同版本的内容对比，点击右下角完成代码提交，注意这个只是提交到本地仓库。</p><p>由于我们并不会将 feature-login 提交到远程仓库，所以接下来我们要将 feature-login 合并到 develop 然后将最新的 develop push 到远程仓库，操作方式如下：</p><ol><li>切换回 develop 分支。</li><li>选择 feature-login-&gt;Merge into Current 进行合并。</li></ol><p><img src="http://img.itboyhub.com/2021/10/tran/20220220165612.png" alt></p><p>合并完成后，如需删除 feature-login 分支，也可以在 IDEA 日志中顺手删除：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220165831.png" alt></p><p>不过上面介绍的合并是快速合并，即让 develop 的指针指向了 feature-login，很多时候我们可能需要加上 <code>--no-ff</code> 参数来合并，那么步骤如下：</p><p>从 feature-login 切换回 develop 分支，然后如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220171101.png" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220171215.png" alt></p><p>此时我们看一眼提交日志，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220171324.png" alt></p><p>从这日志中也可以看出，此时不是快速合并模式了！</p><p>最后，选择 develop-&gt;Push，将代码提交到远程仓库。</p><h2 id="4-pull"><a href="#4-pull" class="headerlink" title="4. pull"></a>4. pull</h2><p>在 IDEA 中，如需从远程仓库中更新代码，点击右上角的按钮即可，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220220171731.png" alt></p><p>好啦，这就是一个大致的流程。</p><p>当然 Git 博大精深，IDEA 中支持的功能也非常多，其他功能就需要小伙伴们自己来摸索了，有不明白的欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 有很多客户端工具，不过感觉还是命令行操作最好用，方便又快捷，不过命令行操作需要小伙伴们对 Git 命令比较熟练，这可能对有的人来说会有一些难度，所以，客户端工具有时候也不能抛弃，如果非要推荐一个 Git 客户端工具，我觉得还是 IDEA 中的 Git 插件吧。其他的 Git 客户端工具松哥之前也有体验过一些，不过感觉还是 IDEA 中的用起来更加省事。&lt;/p&gt;
    
    </summary>
    
      <category term="IDEA" scheme="http://www.javaboy.org/categories/IDEA/"/>
    
    
      <category term="Git" scheme="http://www.javaboy.org/tags/Git/"/>
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Git 最佳实践，什么才是最佳工作流？</title>
    <link href="http://www.javaboy.org/2022/0221/git_flow.html"/>
    <id>http://www.javaboy.org/2022/0221/git_flow.html</id>
    <published>2022-02-21T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:13.360Z</updated>
    
    <content type="html"><![CDATA[<p>很久以前我出过一个 Git 教程，小伙伴们要是还不懂 Git 的用法，可以在公众号底部菜单中，有一个教程合集，里边有 Git 教程的索引。</p><p>今天我们不聊基本用法，聊一聊 Git 到底应该怎么用？我们知道相比于 Svn，Git 最牛的地方在于它的分支，分支很灵活，但是如果缺乏一个使用套路，又会用的乱糟糟的，特别是在团队协作中，该怎么玩 Git 分支？</p><a id="more"></a><p>咱们也不发明什么轮子，也不设计什么全新流程，本文主要是和大家介绍三种常见的工作流：Git Flow、GitHub Flow 以及 GitLab Flow。介绍完成后，在谈谈松哥的一些使用体验。</p><h2 id="1-Git-Flow"><a href="#1-Git-Flow" class="headerlink" title="1. Git Flow"></a>1. Git Flow</h2><p>先来看 Git Flow。</p><p>Git Flow 是最早诞生也是最早被广泛使用的工作流程。</p><p>在 Git Flow 中，有两个长期存在且不会被删除的分支：<strong>master</strong> 和 <strong>develop</strong>。</p><p>在这两个分支中，master 主要用于对外发布稳定的新版本，该分支时常保持着软件可以正常运行的状态，由于要维护这一状态，所以不允许开发者直接对 master 分支的代码进行修改和提交，其他分支的开发工作进展到可以发布的程度后，将会与 master 分支进行合并，并且这一合并只在发版时进行，发布时将会附加版本编号的 Git 标签。</p><p>develop 则用来存放我们最新开发的代码，这个分支是我们开发过程中代码中心分支，这个分支也不允许开发者直接进行修改和提交。程序员要以 develop 分支为起点新建 feature 分支，在 feature 分支中进行新功能的开发或者代码的修正，也就是说 develop 分支维系着开发过程中的最新代码，以便程序员创建 feature 分支进行自己的工作。</p><p>注意 develop 合并的时候，不要使用 fast-farward merge，建议加上 <code>--no-ff</code> 参数，这样在 master 上就会有合并记录，关于这两个的区别，大家可以参数松哥之前的 Git 教程，这里不再赘述。</p><p>除了这两个永久分支，还有三个临时分支：feature branches、hotfixes 以及 release branches。我们分别来看：</p><p><strong>feature branches</strong></p><p>这个是特性分支，也叫功能分支，当你需要开发一个新的功能的时候，可以新建一个 feature-xxx 的分支，在里边开发新功能，这也是我们日常工作的大本营，开发完成后，将之并入 develop 分支中，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/feature-develop.png" alt></p><p><strong>hotfixes branches</strong></p><p>这个分支看名字就是用来修复 BUG 的，当我们的项目上线后，发现有 BUG 需要修复，那么就从 Master 上拉一个名为 fixbug-xxx 的分支，然后进行 BUG 修复，修复完成后，再将代码合并到 Master 和 Develop 两个分支中，然后删除 hotfix 分支，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/hotfix-xxx.png" alt></p><p><strong>release branches</strong></p><p>这个是发版的时候拉的分支，当我们所有的功能做完之后，准备要将代码合并到 master 的时候，从 develop 上拉一个 release-xxx 分支出来，这个分支一般处理发版前的一些提交以及客户体验之后小 BUG 的修复（BUG 修复后也可以将之合并进 develop），不要在这个里边去开发功能，在预发布结束后，将该分支合并进 develop 以及 master，然后删除 release，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/release-xxx.png" alt></p><p>大概就是这个意思。</p><p>松哥工作中用的其实就是类似于 Git Flow 的工作流，为什么说是类似呢？<strong>我们项目中主要是保证了 master、develop 以及 release 三个分支，在此基础之上，其他随意。</strong></p><h2 id="2-GitHub-Flow"><a href="#2-GitHub-Flow" class="headerlink" title="2. GitHub Flow"></a>2. GitHub Flow</h2><p>GitHub Flow 相比于 Git Flow 就要容易很多了，GitHub Flow 也是 GitHub 上使用的工作流程，如果你想参与 GitHub 上的某一个开源项目，那么不妨看看 GitHub Flow。</p><p>官方给的 GitHub Flow 流程如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220216224318.png" alt></p><p>它的流程是这样的：</p><ol><li>需要开发新功能或者修复 BUG 的时候，从 master 上拉一个新的分支下来。</li><li>新的分支开发完成后，或者说当你遇到困难开发不下去的时候，都可以发起一个 pr（Pull Request）。</li><li>pr 既提交代码，也让其他同事 review 你的代码，在这个过程中，你可以不断提交 pr。</li><li>最终你的 pr 被接受，合并进 master。</li></ol><p>GitHub 工作流虽然用着很简单，但是他的问题也很明显，就是没有对常见的工作场景中的问题提出解决办法。</p><h2 id="3-GitLab-Flow"><a href="#3-GitLab-Flow" class="headerlink" title="3. GitLab Flow"></a>3. GitLab Flow</h2><p>GitLab Flow 结合了 Git Flow 与 GitHub Flow 的优点，它不像 Git Flow 有那么多容易把新手绕晕的分支，同时它又可以适应不同的开发环境。</p><p>GitLab Flow 的最大原则叫做 upstream first，中文译作“上游优先”：即只存在一个主分支 master，它是所有其他分支的 upstream，只有上游分支采纳的代码变化，才能应用到其他分支。</p><p>对于“持续发布”的项目，我们可以在 master 分支以外，再建立不同的环境分支。例如开发的分支是 master，预发布的分支是 pre-production，生产环境的分支是 production。</p><p>在这里开发分支是预发分支的 upstream，预发分支又是生产分支的 upstream。代码的变化，必须由<code>上游</code>向<code>下游</code>发展。比如，生产环境出现了 bug，这时就要新建一个功能分支，先把它合并到 master，确认没有问题，再 cherry-pick 到 pre-production，这一步也没有问题，才进入 production，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/gitlab-xxx.png" alt></p><p>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p><p>有稳定的版本需要发布时，我们就从 master 上拉一个新的分支出来，作为发版时候的分支，这些分支上不要开发新功能，只有修补 BUG 的时候</p><p>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。</p><p>以后，只有修补bug，才允许将代码合并到这些分支，并且此时要更新小版本号即可。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦这就是常见的三个 Git 玩转流程，其实我们自己开发不必这么死板，结合自己的项目来就行了，松哥的项目，master、develop 以及 release 三个分支是固定的，这三个分支的作用跟前面介绍的 Git Flow 也是一致的，在此基础之上，其他的基本上没有太多限制，比较自由。</p><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/sloong/p/5868292.html" target="_blank" rel="noopener">https://www.cnblogs.com/sloong/p/5868292.html</a></li><li><a href="https://medium.com/@lf2lf2111/%E4%B8%89%E7%A8%AE%E7%89%88%E6%8E%A7%E6%B5%81%E7%A8%8B-29c82f5d4469" target="_blank" rel="noopener">https://medium.com/@lf2lf2111/%E4%B8%89%E7%A8%AE%E7%89%88%E6%8E%A7%E6%B5%81%E7%A8%8B-29c82f5d4469</a></li><li><a href="https://cloud.tencent.com/developer/article/1646937" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1646937</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久以前我出过一个 Git 教程，小伙伴们要是还不懂 Git 的用法，可以在公众号底部菜单中，有一个教程合集，里边有 Git 教程的索引。&lt;/p&gt;
&lt;p&gt;今天我们不聊基本用法，聊一聊 Git 到底应该怎么用？我们知道相比于 Svn，Git 最牛的地方在于它的分支，分支很灵活，但是如果缺乏一个使用套路，又会用的乱糟糟的，特别是在团队协作中，该怎么玩 Git 分支？&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://www.javaboy.org/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.javaboy.org/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Jpa 中怎么玩一对多？</title>
    <link href="http://www.javaboy.org/2022/0218/jpa_one_to_many.html"/>
    <id>http://www.javaboy.org/2022/0218/jpa_one_to_many.html</id>
    <published>2022-02-18T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:10.098Z</updated>
    
    <content type="html"><![CDATA[<p>Jpa 中的一对一、一对多没搞明白的话，总会觉得有点绕，今天咱们来简单聊聊这个话题。</p><h2 id="1-一对一"><a href="#1-一对一" class="headerlink" title="1. 一对一"></a>1. 一对一</h2><p>比如说一个学校有一个地址，一个地址只有一个学校。</p><a id="more"></a><p>那么我们可以按照如下方式来设计类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-meta">@Entity</span></span><br><span class="line"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"t_address"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer aid;</span><br><span class="line">    <span class="hljs-keyword">private</span> String province;</span><br><span class="line">    <span class="hljs-keyword">private</span> String city;</span><br><span class="line">    <span class="hljs-keyword">private</span> String area;</span><br><span class="line">    <span class="hljs-keyword">private</span> String phone;</span><br><span class="line">    <span class="hljs-meta">@OneToOne</span>(cascade = CascadeType.ALL)</span><br><span class="line">    <span class="hljs-keyword">private</span> School school;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-meta">@Entity</span></span><br><span class="line"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"t_school"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">School</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer sid;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-meta">@OneToOne</span>(cascade = CascadeType.ALL)</span><br><span class="line">    <span class="hljs-keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一对一的关系，可以只在 School 中维护，也可以只在 Address 中维护，也可以两者都维护，具体哪种，那就看需求了。</p><p>在上面的例子中，我们在 School 和 Address 中都通过 @OneToOne 注解来维护了一对一的关系。</p><p>cascade 用来配置级联操作，有如下取值：</p><ul><li>ALL：所有操作</li><li>PERSIST：级联添加</li><li>MERGE：级联更新</li><li>REMOVE：级联删除</li><li>REFRESH：级联刷新</li></ul><p>根据自己需求选择合适的就行。</p><p>这样，最终创建出来的 t_school 表和 t_address 表中，会分别多出来一个字段 address_aid 和 school_sid，这两个字段都是外键，正是通过外键，将两张表中不同的记录关联起来。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220210222243.png" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/20220210222309.png" alt></p><p>有的人可能不习惯这种自动添加的字段，那也可以自定义该字段，反正该字段总是要有的，自定义的方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-meta">@Entity</span></span><br><span class="line"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"t_address"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer aid;</span><br><span class="line">    <span class="hljs-keyword">private</span> String province;</span><br><span class="line">    <span class="hljs-keyword">private</span> String city;</span><br><span class="line">    <span class="hljs-keyword">private</span> String area;</span><br><span class="line">    <span class="hljs-keyword">private</span> String phone;</span><br><span class="line">    <span class="hljs-meta">@OneToOne</span>(cascade = CascadeType.ALL)</span><br><span class="line">    <span class="hljs-meta">@JoinColumn</span>(name = <span class="hljs-string">"sid"</span>,referencedColumnName = <span class="hljs-string">"sid"</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> School school;</span><br><span class="line">    <span class="hljs-meta">@Column</span>(insertable = <span class="hljs-keyword">false</span>,updatable = <span class="hljs-keyword">false</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer sid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-meta">@Entity</span></span><br><span class="line"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"t_school"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">School</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer sid;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-meta">@OneToOne</span>(cascade = CascadeType.ALL)</span><br><span class="line">    <span class="hljs-meta">@JoinColumn</span>(name = <span class="hljs-string">"aid"</span>,referencedColumnName = <span class="hljs-string">"aid"</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> Address address;</span><br><span class="line">    <span class="hljs-meta">@Column</span>(insertable = <span class="hljs-keyword">false</span>,updatable = <span class="hljs-keyword">false</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer aid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Address 中自定义一个 sid，并设置该字段不可添加和修改，然后通过 @JoinColumn 注解去指定关联关系，@JoinColumn 注解中的 name 表示的是当前类中的属性名，referencedColumnName 表示的则是 School 类中对应的属性名。</p><p>在 School 类中做相似的操作。</p><p>最后启动项目去观察 MySQL 中生成的表。</p><h2 id="2-一对多"><a href="#2-一对多" class="headerlink" title="2. 一对多"></a>2. 一对多</h2><p>一个班级中有多个学生，而一个学生只属于一个班级，我们可以这样来定义实体类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"t_student"</span>)</span><br><span class="line"><span class="hljs-meta">@Entity</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer sid;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-meta">@ManyToOne</span>(cascade = CascadeType.ALL)</span><br><span class="line">    <span class="hljs-keyword">private</span> Clazz clazz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"t_clazz"</span>)</span><br><span class="line"><span class="hljs-meta">@Entity</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clazz</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer cid;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-meta">@OneToMany</span>(cascade = CascadeType.ALL,fetch = FetchType.EAGER)</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student 和 Clazz 的关系是多对一，用 @ManyToOne 注解，Clazz 和 Student 的关系是一对多，用 @OneToMany 注解。</p><p>Student 和 Clazz 的关系是多对一，将来的 t_student 表中会多出来一个属性 clazz_cid，通过这个外键将 Student 和 Clazz 关联起来。如果我们不想要自动生成的 clazz_cid，那么也可以自定义，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"t_student"</span>)</span><br><span class="line"><span class="hljs-meta">@Entity</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer sid;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-meta">@ManyToOne</span>(cascade = CascadeType.ALL)</span><br><span class="line">    <span class="hljs-meta">@JoinColumn</span>(name = <span class="hljs-string">"cid"</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> Clazz clazz;</span><br><span class="line">    <span class="hljs-meta">@Column</span>(insertable = <span class="hljs-keyword">false</span>,updatable = <span class="hljs-keyword">false</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer cid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 cid 属性，并设置为不可编辑和不可添加，然后通过 @JoinColumn 注解配置 cid 属性为外键。</p><p>Clazz 和 Student 的关系是一对多，这个是通过一个自动生成的第三张表来实现的，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220210225206.png" alt></p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><h3 id="3-1-添加测试"><a href="#3-1-添加测试" class="headerlink" title="3.1 添加测试"></a>3.1 添加测试</h3><p>先来个一对一的添加测试，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SchoolRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">School</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@SpringBootTest</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JpaOneToManyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    SchoolRepository schoolRepository;</span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        School school = <span class="hljs-keyword">new</span> School();</span><br><span class="line">        school.setSid(<span class="hljs-number">1</span>);</span><br><span class="line">        school.setName(<span class="hljs-string">"哈佛大学"</span>);</span><br><span class="line">        Address address = <span class="hljs-keyword">new</span> Address();</span><br><span class="line">        address.setAid(<span class="hljs-number">1</span>);</span><br><span class="line">        address.setProvince(<span class="hljs-string">"黑龙江"</span>);</span><br><span class="line">        address.setCity(<span class="hljs-string">"哈尔滨"</span>);</span><br><span class="line">        address.setArea(<span class="hljs-string">"某地"</span>);</span><br><span class="line">        address.setPhone(<span class="hljs-string">"123456"</span>);</span><br><span class="line">        school.setAddress(address);</span><br><span class="line">        schoolRepository.save(school);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个测试过程中，关联关系是由 t_school 一方来维护了，因此将来填充的外键是 t_school 中的 aid。添加结果如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220211192215.png" alt="t_school"></p><p><img src="http://img.itboyhub.com/2021/10/tran/20220211192234.png" alt="t_address"></p><p>这是一个简单的添加案例。</p><p>更新也是调用 save 方法，更新的时候会先判断这个 id 是否存在，存在的话就更新，不存在就添加。</p><p>再来看班级的添加，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ClazzRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Clazz</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">ClazzRepository clazzRepository;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Clazz c = <span class="hljs-keyword">new</span> Clazz();</span><br><span class="line">    c.setCid(<span class="hljs-number">1</span>);</span><br><span class="line">    c.setName(<span class="hljs-string">"三年级二班"</span>);</span><br><span class="line">    List&lt;Student&gt; students = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Student s1 = <span class="hljs-keyword">new</span> Student();</span><br><span class="line">    s1.setSid(<span class="hljs-number">1</span>);</span><br><span class="line">    s1.setName(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    students.add(s1);</span><br><span class="line">    Student s2 = <span class="hljs-keyword">new</span> Student();</span><br><span class="line">    s2.setSid(<span class="hljs-number">2</span>);</span><br><span class="line">    s2.setName(<span class="hljs-string">"张三"</span>);</span><br><span class="line">    students.add(s2);</span><br><span class="line">    c.setStudents(students);</span><br><span class="line">    clazzRepository.save(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，添加的是班级，所以班级和学生之间关系就由第三张表来维护，而不是由学生来维护。</p><h3 id="3-2-查询测试"><a href="#3-2-查询测试" class="headerlink" title="3.2 查询测试"></a>3.2 查询测试</h3><p>再来一个简单的查询，假设我们现在想根据省份来搜索学校，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SchoolRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">School</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;School&gt; <span class="hljs-title">findSchoolByAddressProvince</span><span class="hljs-params">(String province)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">SchoolRepository schoolRepository;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;School&gt; list = schoolRepository.findSchoolByAddressProvince(<span class="hljs-string">"黑龙江"</span>);</span><br><span class="line">    System.out.println(<span class="hljs-string">"list = "</span> + list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>松哥给大家捋一下 Spring Data 如何解析上面自定义的查询方法：</p><ol><li>首先截取掉 findSchoolByAddressProvince 的前缀，剩下 AddressProvince。</li><li>检查 School 是否有 addressProvince 属性，有就按照该属性查询，对于我们的案例，并没有 addressProvince 属性，所以继续下一步。</li><li>从右侧驼峰开始拆分，拆掉第一个驼峰后面的内容，我们这里拆分之后只剩下 Address 了，判断 School 是否存在 Address 属性，不存在就继续重复该步骤，继续切掉右侧第一个驼峰。</li><li>在上文案例中，School 中有 address 属性，所以接下来就去检查 address 中是否有 province 属性，因为我们这里只剩下一个 province 了，如果剩下的字符串类似于 provinceAaaBbb 这种，那么继续按照第三步去解析。</li></ol><p>上面这个写法有一个小小的风险，假设 School 中刚好就有一个属性叫做 addressProvince，那么此时的分析就会出错。所以，对于上面的查询，我们也可以定义成如下方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SchoolRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">School</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;School&gt; <span class="hljs-title">findSchoolByAddress_Province</span><span class="hljs-params">(String province)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就不会产生歧义了，系统就知道 province 是 address 的属性了。</p><p>再来一个班级的查询，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ClazzRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Clazz</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Clazz&gt; list = clazzRepository.findAll();</span><br><span class="line">    System.out.println(<span class="hljs-string">"list = "</span> + list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在查询的过程中，需要对学生进行排序，可以添加如下属性：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"t_clazz"</span>)</span><br><span class="line"><span class="hljs-meta">@Entity</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clazz</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer cid;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-meta">@OneToMany</span>(cascade = CascadeType.ALL,fetch = FetchType.EAGER)</span><br><span class="line">    <span class="hljs-meta">@OrderBy</span>(<span class="hljs-string">"sid desc"</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @OrderBy(“sid desc”) 可以设置查询的 student 排序。</p><p>好啦，几个小小的案例，希望对大家有所帮助，公众号后台回复 <strong>jpa02</strong>，获取本文案例下载链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jpa 中的一对一、一对多没搞明白的话，总会觉得有点绕，今天咱们来简单聊聊这个话题。&lt;/p&gt;
&lt;h2 id=&quot;1-一对一&quot;&gt;&lt;a href=&quot;#1-一对一&quot; class=&quot;headerlink&quot; title=&quot;1. 一对一&quot;&gt;&lt;/a&gt;1. 一对一&lt;/h2&gt;&lt;p&gt;比如说一个学校有一个地址，一个地址只有一个学校。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Jpa" scheme="http://www.javaboy.org/tags/Jpa/"/>
    
      <category term="SpringDataJpa" scheme="http://www.javaboy.org/tags/SpringDataJpa/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 发送邮件，端口号大有玄机！</title>
    <link href="http://www.javaboy.org/2022/0216/mail_port.html"/>
    <id>http://www.javaboy.org/2022/0216/mail_port.html</id>
    <published>2022-02-16T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:05.549Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Spring Boot 发送邮件，松哥之前专门写过文章，这里就不啰嗦了。还不懂 Spring Boot 如何发送邮件的小伙伴，翻到本文后半部分，有介绍。</p><p>今天想和大家聊一下 SMTP 服务器的端口问题，这个也是一个小伙伴提的问题，SMTP 服务器有众多端口：25、465、587 各自间有什么区别？可以随意使用吗？希望今天这篇文章能给你答案。</p><a id="more"></a><h2 id="1-什么是-SMTP"><a href="#1-什么是-SMTP" class="headerlink" title="1. 什么是 SMTP"></a>1. 什么是 SMTP</h2><p>SMTP 代表简单邮件传输协议，简而言之，它是通过 Internet 发送电子邮件的过程。计算机端口是个人计算机连接到网络并完成数据传输的方式。SMTP 端口是两者的组合：设计用于通过网络向其收件人发送电子邮件的端口。</p><p>下图展示了 SMTP 协议在邮件发送过程的作用：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220215194627.png" alt></p><p>当然，就像有多个计算机端口一样，可以使用的 SMTP 端口也有很多。</p><h2 id="2-SMTP-Port"><a href="#2-SMTP-Port" class="headerlink" title="2. SMTP Port"></a>2. SMTP Port</h2><h3 id="2-1-25"><a href="#2-1-25" class="headerlink" title="2.1 25"></a>2.1 25</h3><p>1982 年，南加州大学向 Internet 工程任务组 (IETF) 提交了一份提案，即 Request For Comments (RFC) 821，将端口 25 建立为 Internet 电子邮件的默认传输通道。40 年过去了，如今我们依然可以使用 25 这个端口在两个邮件服务器之间传输邮件。</p><p>不过最初的设计没有考虑安全问题，在 1998 年 12 月，R. Gellens 和 J. Klensin 提交了 RFC2476，在这个规范中，RFC 提议将传统的消息提交和消息中继概念分开，RFC 定义消息提交应通过端口 587 进行（即我们通过邮件客户端等工具提交邮件的时候，应该使用 587 端口），以确保新的策略和安全要求不会干扰消息中继端口 25 上的传统中继流量。</p><p>这么一拆分，端口 25 就主要用于 SMTP 中继，也就是将邮件从一个电子邮件服务器传输到另一个电子邮件服务器。</p><p>在大多数情况下，SMTP 电子邮件客户端（Foxmail、Microsoft Outlook、Mail、Thunderbird 等）不应使用 25 端口，以遏制垃圾邮件的数量，所以这个 25 端口和我们个人使用的关系就不大。</p><h3 id="2-2-587"><a href="#2-2-587" class="headerlink" title="2.2 587"></a>2.2 587</h3><p>这是默认的邮件提交端口，当用户提交一封电子邮件到邮件服务器时，可以使用该端口，我们自己通过 Java 代码发送邮件，也可以使用该端口。</p><p>端口 587 与 TLS 加密相结合，可确保安全提交电子邮件并遵循 IETF 制定的指导方针。</p><h3 id="2-3-465"><a href="#2-3-465" class="headerlink" title="2.3 465"></a>2.3 465</h3><p>那按理说我们发送邮件的时候就该使用 587 端口呀，465 又是干嘛的？</p><p>IETF 从未将端口 465 发布为官方 SMTP 传输或提交端口，然而维护大部分核心互联网基础设施的 IANA 为 SMTPS 分配了端口 465。目的是为 SMTP 建立一个端口，以便使用安全套接字层 (SSL) 进行操作，这样使得邮件发送更加安全。</p><p>所以 465 和 587 其实都是为了邮件安全，但是两者的思路不一样，465 是 SSL，587 则是 TLS，SSL 和 TLS 有啥区别呢？这个就说来话长了，简单一句话就是：<strong>TLS（传输层安全）是更为安全的升级版 SSL，TLS 是 SSL 标准化后的产物。</strong></p><p>按理说 465 应该被撤销，大家都用 587，但是由于 465 曾经被 IANA 认定为有效，因此可能存在仅能够使用此端口连接的遗留系统，所以该端口并没有被废弃，也可以使用。</p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p>好啦，这就是这几个端口的区别。一般来说，我们用 Spring Boot 发送邮件的时候，465 和 587 都能用，但是不建议使用 25。另外在使用 465 或者 587 的时候，有的个别邮箱如 139 邮箱需要配置如下属性：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.properties.mail.smtp.ssl.enable=true</span><br></pre></td></tr></table></figure><h2 id="3-号外"><a href="#3-号外" class="headerlink" title="3. 号外"></a>3. 号外</h2><p>可能还有小伙伴不懂 Spring Boot 邮件发送，再来回顾下。</p><p>邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，接下来我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。</p><h3 id="3-1-邮件基础"><a href="#3-1-邮件基础" class="headerlink" title="3.1 邮件基础"></a>3.1 邮件基础</h3><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。</p><p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。</p><p>生活中我们投递一封邮件要经过如下几个步骤：</p><ol><li>深圳的小王先将邮件投递到深圳的邮局</li><li>深圳的邮局将邮件运送到上海的邮局</li><li>上海的小张来邮局取邮件 </li></ol><p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> ：</p><ol><li><a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器</li><li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器</li><li><a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 登录网易的邮件服务器查看邮件</li></ol><p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。</p><p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件与 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><p>最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。</p><h3 id="3-2-准备工作"><a href="#3-2-准备工作" class="headerlink" title="3.2 准备工作"></a>3.2 准备工作</h3><p>目前国内大部分的邮件服务商都不允许直接使用用户名/密码的方式来在代码中发送邮件，都是要先申请授权码，这里以 QQ 邮箱为例，向大家演示授权码的申请流程：首先我们需要先登录 QQ 邮箱网页版，点击上方的设置按钮：</p><p><img src="http://img.itboyhub.com/2021/springboot2/43-1.jpg" alt></p><p>然后点击账户选项卡：</p><p><img src="http://img.itboyhub.com/2021/springboot2/43-2.jpg" alt></p><p>在账户选项卡中找到开启POP3/SMTP选项，如下：</p><p><img src="http://img.itboyhub.com/2021/springboot2/43-3.jpg" alt></p><p>点击开启，开启相关功能，开启过程需要手机号码验证，按照步骤操作即可，不赘述。开启成功之后，即可获取一个授权码，将该号码保存好，一会使用。</p><h3 id="3-3-项目创建"><a href="#3-3-项目创建" class="headerlink" title="3.3 项目创建"></a>3.3 项目创建</h3><p>接下来，我们就可以创建项目了，Spring Boot 中，对于邮件发送提供了自动配置类，开发者只需要加入相关依赖，然后配置一下邮箱的基本信息，就可以发送邮件了。</p><ul><li>首先创建一个 Spring Boot 项目，引入邮件发送依赖：</li></ul><p><img src="http://img.itboyhub.com/2021/springboot2/43-4.png" alt></p><p>创建完成后，项目依赖如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置邮箱基本信息</li></ul><p>项目创建成功后，接下来在 application.properties 中配置邮箱的基本信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=587</span><br><span class="line">spring.mail.username=1510161612@qq.com</span><br><span class="line">spring.mail.password=ubknfzhjkhrbbabe</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory</span><br><span class="line">spring.mail.properties.mail.debug=true</span><br></pre></td></tr></table></figure><p>配置含义分别如下：</p><ul><li>配置 SMTP 服务器地址</li><li>SMTP 服务器的端口</li><li>配置邮箱用户名</li><li>配置密码，注意，不是真正的密码，而是刚刚申请到的授权码</li><li>默认的邮件编码</li><li>配饰 SSL 加密工厂</li><li>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</li></ul><p>如果不知道 smtp 服务器的端口或者地址的的话，可以参考 腾讯的邮箱文档</p><ul><li><a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371" target="_blank" rel="noopener">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371</a></li></ul><p>做完这些之后，Spring Boot 就会自动帮我们配置好邮件发送类，相关的配置在 <code>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration</code> 类中，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; MimeMessage.class, MimeType.class, MailSender.class &#125;)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(MailSender.class)</span><br><span class="line"><span class="hljs-meta">@Conditional</span>(MailSenderCondition.class)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(MailProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，可以看到，导入了另外一个配置 <code>MailSenderPropertiesConfiguration</code> 类，这个类中，提供了邮件发送相关的工具类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mail"</span>, name = <span class="hljs-string">"host"</span>)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderPropertiesConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MailProperties properties;</span><br><span class="line">        MailSenderPropertiesConfiguration(MailProperties properties) &#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> JavaMailSenderImpl <span class="hljs-title">mailSender</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                JavaMailSenderImpl sender = <span class="hljs-keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">                applyProperties(sender);</span><br><span class="line">                <span class="hljs-keyword">return</span> sender;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里创建了一个 <code>JavaMailSenderImpl</code> 的实例， <code>JavaMailSenderImpl</code> 是 <code>JavaMailSender</code> 的一个实现，我们将使用 <code>JavaMailSenderImpl</code> 来完成邮件的发送工作。</p><p>做完如上两步，邮件发送的准备工作就算是完成了，接下来就可以直接发送邮件了。</p><p>具体的发送，有 5 种不同的方式，我们一个一个来看。</p><h4 id="3-3-1-发送简单邮件"><a href="#3-3-1-发送简单邮件" class="headerlink" title="3.3.1 发送简单邮件"></a>3.3.1 发送简单邮件</h4><p>简单邮件就是指邮件内容是一个普通的文本文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JavaMailSender javaMailSender;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSimpleMail</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();</span><br><span class="line">    message.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    message.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    message.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    message.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    message.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    message.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    message.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    javaMailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上往下，代码含义分别如下：</p><ol><li>构建一个邮件对象</li><li>设置邮件主题</li><li>设置邮件发送者</li><li>设置邮件接收者，可以有多个接收者</li><li>设置邮件抄送人，可以有多个抄送人</li><li>设置隐秘抄送人，可以有多个</li><li>设置邮件发送日期</li><li>设置邮件的正文</li><li>发送邮件</li></ol><p>最后执行该方法，就可以实现邮件的发送，发送效果图如下：</p><p><img src="http://img.itboyhub.com/2021/springboot2/43-5.png" alt></p><h4 id="3-3-2-发送带附件的邮件"><a href="#3-3-2-发送带附件的邮件" class="headerlink" title="3.3.2 发送带附件的邮件"></a>3.3.2 发送带附件的邮件</h4><p>邮件的附件可以是图片，也可以是普通文件，都是支持的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAttachFileMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    helper.addAttachment(<span class="hljs-string">"javaboy.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里在构建邮件对象上和前文有所差异，这里是通过 javaMailSender 来获取一个复杂邮件对象，然后再利用 MimeMessageHelper 对邮件进行配置，MimeMessageHelper 是一个邮件配置的辅助工具类，创建时候的 true 表示构建一个 multipart message 类型的邮件，有了 MimeMessageHelper 之后，我们针对邮件的配置都是由 MimeMessageHelper 来代劳。</p><p>最后通过 addAttachment 方法来添加一个附件。</p><p>执行该方法，邮件发送效果图如下：</p><p><img src="http://img.itboyhub.com/2021/springboot2/43-6.png" alt></p><h4 id="3-3-3-发送带图片资源的邮件"><a href="#3-3-3-发送带图片资源的邮件" class="headerlink" title="3.3.3 发送带图片资源的邮件"></a>3.3.3 发送带图片资源的邮件</h4><p>图片资源和附件有什么区别呢？图片资源是放在邮件正文中的，即一打开邮件，就能看到图片。但是一般来说，不建议使用这种方式，一些公司会对邮件内容的大小有限制（因为这种方式是将图片一起发送的）。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendImgResMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"&lt;p&gt;hello 大家好，这是一封测试邮件，这封邮件包含两种图片，分别如下&lt;/p&gt;&lt;p&gt;第一张图片：&lt;/p&gt;&lt;img src='cid:p01'/&gt;&lt;p&gt;第二张图片：&lt;/p&gt;&lt;img src='cid:p02'/&gt;"</span>,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p01"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>)));</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p02"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy2.png"</span>)));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的邮件 text 是一个 HTML 文本，里边涉及到的图片资源先用一个占位符占着，setText 方法的第二个参数 true 表示第一个参数是一个 HTML 文本。</p><p>setText 之后，再通过 addInline 方法来添加图片资源。</p><p>最后执行该方法，发送邮件，效果如下：</p><p><img src="http://img.itboyhub.com/2021/springboot2/43-7.png" alt></p><p>在公司实际开发中，第一种和第三种都不是使用最多的邮件发送方案。因为正常来说，邮件的内容都是比较的丰富的，所以大部分邮件都是通过 HTML 来呈现的，如果直接拼接 HTML 字符串，这样以后不好维护，为了解决这个问题，一般邮件发送，都会有相应的邮件模板。最具代表性的两个模板就是 <code>Freemarker</code> 模板和 <code>Thyemeleaf</code> 模板了。</p><h4 id="3-3-4-使用-Freemarker-作邮件模板"><a href="#3-3-4-使用-Freemarker-作邮件模板" class="headerlink" title="3.3.4 使用 Freemarker 作邮件模板"></a>3.3.4 使用 Freemarker 作邮件模板</h4><p>首先需要引入 Freemarker 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>resources/templates</code> 目录下创建一个 <code>mail.ftl</code> 作为邮件发送模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;salary&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，将邮件模板渲染成 HTML ，然后发送即可。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFreemarkerMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException, IOException, TemplateException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    <span class="hljs-comment">//构建 Freemarker 的基本配置</span></span><br><span class="line">    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_0);</span><br><span class="line">    <span class="hljs-comment">// 配置模板位置</span></span><br><span class="line">    ClassLoader loader = MailApplication.class.getClassLoader();</span><br><span class="line">    configuration.setClassLoaderForTemplateLoading(loader, <span class="hljs-string">"templates"</span>);</span><br><span class="line">    <span class="hljs-comment">//加载模板</span></span><br><span class="line">    Template template = configuration.getTemplate(<span class="hljs-string">"mail.ftl"</span>);</span><br><span class="line">    User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    user.setNum(<span class="hljs-number">1</span>);</span><br><span class="line">    user.setSalary((<span class="hljs-keyword">double</span>) <span class="hljs-number">99999</span>);</span><br><span class="line">    StringWriter out = <span class="hljs-keyword">new</span> StringWriter();</span><br><span class="line">    <span class="hljs-comment">//模板渲染，渲染的结果将被保存到 out 中 ，将out 中的 html 字符串发送即可</span></span><br><span class="line">    template.process(user, out);</span><br><span class="line">    helper.setText(out.toString(),<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，虽然引入了 <code>Freemarker</code> 的自动化配置，但是我们在这里是直接 <code>new Configuration</code> 来重新配置 <code>Freemarker</code> 的，所以 Freemarker 默认的配置这里不生效，因此，在填写模板位置时，值为 <code>templates</code> 。</p><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://img.itboyhub.com/2021/springboot2/43-8.png" alt></p><h4 id="3-3-5-使用-Thymeleaf-作邮件模板"><a href="#3-3-5-使用-Thymeleaf-作邮件模板" class="headerlink" title="3.3.5 使用 Thymeleaf 作邮件模板"></a>3.3.5 使用 Thymeleaf 作邮件模板</h4><p>推荐在 Spring Boot 中使用 Thymeleaf 来构建邮件模板。因为 Thymeleaf 的自动化配置提供了一个 TemplateEngine，通过 TemplateEngine 可以方便的将 Thymeleaf 模板渲染为 HTML ，同时，Thymeleaf 的自动化配置在这里是继续有效的 。</p><p>首先，引入 Thymeleaf 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，创建 <code>Thymeleaf</code> 邮件模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;username&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;num&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;salary&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来发送邮件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendThymeleafMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    Context context = <span class="hljs-keyword">new</span> Context();</span><br><span class="line">    context.setVariable(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"num"</span>,<span class="hljs-string">"000001"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"salary"</span>, <span class="hljs-string">"99999"</span>);</span><br><span class="line">    String process = templateEngine.process(<span class="hljs-string">"mail.html"</span>, context);</span><br><span class="line">    helper.setText(process,<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://img.itboyhub.com/2021/springboot2/43-8.png" alt></p><p>好了，这就是我们今天说的 5 种邮件发送姿势，不知道你掌握了没有呢？</p><p>本文案例已经上传到 GitHub：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a>。</p><p>有问题欢迎留言讨论。</p><p>参考资料：</p><ul><li><a href="https://www.mailgun.com/blog/which-smtp-port-understanding-ports-25-465-587" target="_blank" rel="noopener">https://www.mailgun.com/blog/which-smtp-port-understanding-ports-25-465-587</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Spring Boot 发送邮件，松哥之前专门写过文章，这里就不啰嗦了。还不懂 Spring Boot 如何发送邮件的小伙伴，翻到本文后半部分，有介绍。&lt;/p&gt;
&lt;p&gt;今天想和大家聊一下 SMTP 服务器的端口问题，这个也是一个小伙伴提的问题，SMTP 服务器有众多端口：25、465、587 各自间有什么区别？可以随意使用吗？希望今天这篇文章能给你答案。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Mail" scheme="http://www.javaboy.org/tags/Mail/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 如何监控 SQL 运行情况？</title>
    <link href="http://www.javaboy.org/2022/0215/druid_monitor.html"/>
    <id>http://www.javaboy.org/2022/0215/druid_monitor.html</id>
    <published>2022-02-15T10:42:33.000Z</published>
    <updated>2022-04-05T12:15:01.066Z</updated>
    
    <content type="html"><![CDATA[<p>今天想和大家聊一聊 Druid 中的监控功能。</p><a id="more"></a><p>Druid 数据库连接池相信很多小伙伴都用过，个人感觉 Druid 是阿里比较成功的开源项目了，不像 Fastjson 那么多槽点，Druid 各方面一直都比较出色，功能齐全，使用也方便，基本的用法就不说了，今天我们来看看 Druid 中的监控功能。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>首先我们来创建一个 Spring Boot 工程，引入 MyBatis 等，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220214194812.png" alt></p><p>选一下 MyBatis 和 MySQL 驱动，做一个简单的测试案例。</p><p>先来连接一下数据库：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123</span><br><span class="line">spring.datasource.url=jdbc:mysql:///test05?serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><p>创建一个 User 实体类，做一个简单的查询案例，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line">    <span class="hljs-keyword">private</span> String email;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(String username)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> userMapper.getUserByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getUser</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> userService.getUserByUsername(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserMapper.xml 如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="hljs-meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="hljs-meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"org.javaboy.druid_monitor.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserByUsername"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.druid_monitor.model.User"</span>&gt;</span></span><br><span class="line">        select * from user where username=#&#123;username&#125;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个很简单的测试，没啥好说的。</p><p>这个环境搭建大家随意，如果你已经有持久化的案例了，那就直接看第二小节引入 Druid。</p><p>现在这个工程默认的使用的数据库连接池是 HikariDataSource，这是 Spring Boot 中默认的一个数据库连接池，其实这个也还不错。</p><h2 id="2-引入-Druid"><a href="#2-引入-Druid" class="headerlink" title="2. 引入 Druid"></a>2. 引入 Druid</h2><p>接下来我们引入 Druid：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，Spring Boot 引入的 Druid 是上面这个，这个将来配置监控的时候方便一些。</p><p>接下来我们在 application.properties 中配置 WebStatFilter，WebStatFilter 用于采集 web-jdbc 关联监控的数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 启用 WebStatFilter</span><br><span class="line">spring.datasource.druid.web-stat-filter.enabled=true</span><br><span class="line"># 配置拦截规则</span><br><span class="line">spring.datasource.druid.web-stat-filter.url-pattern=/*</span><br><span class="line"># 排除一些不必要的 url，这些 URL 不会涉及到 SQL 查询</span><br><span class="line">spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*</span><br><span class="line"># 开启 session 统计功能</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-enable=true</span><br><span class="line"># 缺省 sessionStatMaxCount 是 1000 个，我们可以按需要进行配置</span><br><span class="line">spring.datasource.druid.web-stat-filter.session-stat-max-count=1000</span><br><span class="line"># 配置 principalSessionName，使得 druid 能够知道当前的 session 的用户是谁</span><br><span class="line"># 根据需要，这个参数的值是 user 信息保存在 session 中的 sessionName</span><br><span class="line">#spring.datasource.druid.web-stat-filter.principal-session-name=</span><br><span class="line"># 下面这个配置的作用和上面配置的作用类似，这个是通过 Cookie 来识别用户</span><br><span class="line">#spring.datasource.druid.web-stat-filter.principal-cookie-name=</span><br><span class="line"># 开启 profile 后就能够监控单个 URL 地址调用列表</span><br><span class="line">#spring.datasource.druid.web-stat-filter.profile-enable=</span><br></pre></td></tr></table></figure><p>我们配置前面五个就可以了，后面三个可以不用配置，各项配置的含义松哥已经在代码中列出来了。</p><p>接下来开启 StatViewServlet 的配置，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 启用内置的监控页面</span><br><span class="line">spring.datasource.druid.stat-view-servlet.enabled=true</span><br><span class="line"># 内置监控页面的地址</span><br><span class="line">spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*</span><br><span class="line"># 开启 Reset All 功能</span><br><span class="line">spring.datasource.druid.stat-view-servlet.reset-enable=true</span><br><span class="line"># 设置登录用户名</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-username=javaboy</span><br><span class="line"># 设置登录密码</span><br><span class="line">spring.datasource.druid.stat-view-servlet.login-password=123</span><br><span class="line"># 白名单（如果allow没有配置或者为空，则允许所有访问）</span><br><span class="line">spring.datasource.druid.stat-view-servlet.allow=127.0.0.1</span><br><span class="line"># 黑名单（deny 优先于 allow，如果在 deny 列表中，就算在 allow 列表中，也会被拒绝）</span><br><span class="line">spring.datasource.druid.stat-view-servlet.deny=</span><br></pre></td></tr></table></figure><p>配置一下页面地址，配置一下黑白名单即可。</p><p><strong>需要注意的是，reset-enable 属性即使设置为 false，重置按钮也会显示，只是点击该按钮并不会重置而已。</strong></p><p>好啦，这就完事了。</p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>好啦，接下来我们启动 Spring Boot 项目进行测试。</p><p>Spring Boot 项目启动成功后，首先访问如下地址：</p><ul><li><a href="http://localhost:8080/druid/login.html" target="_blank" rel="noopener">http://localhost:8080/druid/login.html</a></li></ul><p>此时我们会看到登录认证页面，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220214211355.png" alt></p><p>输入我们前面配置的用户名/密码（javaboy/123）进行登录，登录成功后，可以看到如下页面：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220214211452.png" alt></p><p>从标题栏就可以看到，数据源、SQL 监控、SQL 防火墙等功能都是一应俱全。</p><p>接下来我们访问 <code>http://localhost:8080/user?username=aaa</code> 地址，执行一条 SQL，执行完成后，我们来查看 SQL 监控：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220214211733.png" alt></p><p>可以看到，此时就有 SQL 执行的监控记录了。</p><p>其他的监控数据也都可以看到，我就不一一列举了。如果小伙伴们觉得这里展示的数据不直观，想自己画 HTML 页面，那也是可以的，点击最后面的 JSON API，可以看到每一个监控项的 JSON 地址，拿着 JSON 自己想怎么显示就怎么显示。</p><h2 id="4-去广告"><a href="#4-去广告" class="headerlink" title="4. 去广告"></a>4. 去广告</h2><p>如果想直接用这个监控页面，这个上面有阿里的广告，如下图，公司用的话就特别别扭：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220214215600.png" alt></p><p>我们可能想去掉这个广告，这也很容易。</p><p>首先，经过分析，我们发现广告是由一个叫做 common.js 的文件构建出来的，该文件位于 <code>druid-1.2.8.jar!/support/http/resources/js/common.js</code> 这里，common.js 文件中有如下几行：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.buildFooter();</span><br><span class="line">druid.lang.init();</span><br><span class="line">&#125;,</span><br><span class="line">buildFooter : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> html =<span class="hljs-string">''</span>;</span><br><span class="line">$(<span class="hljs-built_in">document</span>.body).append(html);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>大概逻辑就是上面这样，buildFooter 方法负责构建页面末尾的广告，在 init 方法中完成对 buildFooter 方法的调用。</p><p>那么想要去除广告，就别调用 buildFooter 方法就行了。</p><p>所以我们的去广告思路也很简单，写一个过滤器，拦截下对 common.js 的请求，然后做一点点修改，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebFilter</span>(urlPatterns = <span class="hljs-string">"/druid/js/common.js"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RemoveAdFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String text = Utils.readFromResource(<span class="hljs-string">"support/http/resources/js/common.js"</span>);</span><br><span class="line">        text = text.replace(<span class="hljs-string">"this.buildFooter();"</span>, <span class="hljs-string">""</span>);</span><br><span class="line">        servletResponse.getWriter().write(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个过滤器就是拦截 <code>/druid/js/common.js</code> 请求，拦截到之后，自己去文件中读取 common.js 文件，然后手动替换掉 <code>this.buildFooter();</code> 这一句就行了，最后再把文件写出去就行了。</p><p>当然，记得在启动类中扫描 Filter，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span></span><br><span class="line"><span class="hljs-meta">@ServletComponentScan</span>(<span class="hljs-string">"org.javaboy.druid_monitor.filter"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidMonitorApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DruidMonitorApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，这就可以啦，有了这个过滤器，广告就没了。</p><p>公众号后台回复 <strong>druid_monitor</strong> 可以下载本文案例。</p><p>参考资料：</p><ul><li><a href="https://github.com/alibaba/druid/wiki/" target="_blank" rel="noopener">https://github.com/alibaba/druid/wiki/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想和大家聊一聊 Druid 中的监控功能。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Druid" scheme="http://www.javaboy.org/tags/Druid/"/>
    
  </entry>
  
  <entry>
    <title>GET！Spring Data Jpa 中竟然有 10 种默认方法前缀</title>
    <link href="http://www.javaboy.org/2022/0214/spring_data_method_prefix.html"/>
    <id>http://www.javaboy.org/2022/0214/spring_data_method_prefix.html</id>
    <published>2022-02-14T10:42:33.000Z</published>
    <updated>2022-04-05T12:14:57.672Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>我一直觉得 Spring Data Jpa 用的少，没想到最近有好几个小伙伴问 Jpa 的问题，想了想，我就把我知道的关于 Jpa 的一些知识点，整理一下写几篇文章和大家分享下，今天就先来看个简单的。</p><a id="more"></a><p>小伙伴们都知道，Spring Data Jpa 有一个“神奇”的功能，就是我们只需要按照既定的规则去定义方法名，就不用自己写 SQL 了，至于具体的实现原理，松哥在 2019 年的文章中就已经介绍过了，这里就不啰嗦了（公号后台回复 2019 有当年的文章索引）。</p><p>今天是想和大家捋一捋 Spring Data Jpa 所支持的方法前缀问题。</p><p>我们日常开发中，如果用到了 Spring Data Jpa，用的最多的就是 findXXX 了，有的人可能是用 getXXX 或者 readXXX，我觉得这几个是用的最多的几个了，其实 Spring Data Jpa 支持的方法前缀多达 11 种，我们来瞅瞅：</p><p>相关的源码在 <code>org.springframework.data.repository.query.parser.PartTree</code> 类中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUERY_PATTERN = <span class="hljs-string">"find|read|get|query|search|stream"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String COUNT_PATTERN = <span class="hljs-string">"count"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXISTS_PATTERN = <span class="hljs-string">"exists"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELETE_PATTERN = <span class="hljs-string">"delete|remove"</span>;</span><br></pre></td></tr></table></figure><p>接下来松哥举几个例子我们一起来捋一捋。如果小伙伴们对 Spring Data Jpa 处于从来没用过的状态，那么可以在公众号后台回复 666，松哥在之前的 Spring Boot 教程中介绍过，可以先学习下，否则学习本文可能会有点摸不着头脑。</p><h2 id="1-查询"><a href="#1-查询" class="headerlink" title="1. 查询"></a>1. 查询</h2><p>先来看查询。</p><p>find/get/read/query/search 都算是常规前缀，我们来看几个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 根据用户名查询用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">findUserByUsername</span><span class="hljs-params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 根据用户地址查询用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> address</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserByAddress</span><span class="hljs-params">(String address)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 查询某个日期之后出生的用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> birthday</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">readUserByBirthdayAfter</span><span class="hljs-params">(LocalDate birthday)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 查询某个日期之前出生的用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> birthday</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">queryUserByBirthdayBefore</span><span class="hljs-params">(LocalDate birthday)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 根据性别查询用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> gender</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">searchUserByGender</span><span class="hljs-params">(String gender)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法的含义我都给注释上了，这里就不啰嗦了。</p><p><strong>需要注意的是，在 IDEA 中写的时候，前面四个都有提示，最后那个 search 没有提示，没有提示小伙伴们自己写注意可别敲错了。</strong>。</p><p>除了上面这五个常规的，还有一个稍微特殊一点的，就是 stream，其实也不算特殊，毕竟 Java 的版本一年一个样，从 JDK8 到现在都快十年了，stream 早该掌握了（还不懂 stream 的小伙伴，可以在公众号后台回复 2021，有松哥去年文章索引，去年我在 WebFlux 系列中详细介绍过 stream）。</p><p>我们来看一个 stream 的例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 根据地址查询用户，返回 stream 流</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> address</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">Stream&lt;User&gt; <span class="hljs-title">findUserByAddress</span><span class="hljs-params">(String address)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值是一个 stream 流即可。</p><p>这里有一个需要注意的地方，就是调用返回值为 stream 流的方法时，需要加事务，如果不加事务，会报如下错误：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.dao.InvalidDataAccessApiUsageException: You're trying to <span class="hljs-keyword">execute</span> a streaming <span class="hljs-keyword">query</span> method <span class="hljs-keyword">without</span> a surrounding <span class="hljs-keyword">transaction</span> that keeps the <span class="hljs-keyword">connection</span> <span class="hljs-keyword">open</span> so that the Stream can actually be consumed. Make sure the code consuming the stream uses @<span class="hljs-keyword">Transactional</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">any</span> other way <span class="hljs-keyword">of</span> declaring a (<span class="hljs-keyword">read</span>-<span class="hljs-keyword">only</span>) transaction.</span><br></pre></td></tr></table></figure><p>这个错误的意思很明确，就是你要把 stream 查询放到一个事务中，进而确保 stream 操作是数据库连接没有关闭。<strong>因为 stream 中并不保存数据，所以要是 Connection 关闭了，就没法操作数据了。</strong></p><p>松哥给大家看一个简单的 stream 方法调用案例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">UserRepository userRepository;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@Transactional</span>(readOnly = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; list = userRepository.findUserByAddress(<span class="hljs-string">"深圳"</span>).map(u -&gt; &#123;</span><br><span class="line">        u.setAddress(<span class="hljs-string">"中国 "</span> + u.getAddress());</span><br><span class="line">        <span class="hljs-keyword">return</span> u;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="hljs-string">"list = "</span> + list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数据库中查询到数据之后，给所有的 address 都加上”中国”二字。</p><h2 id="2-统计"><a href="#2-统计" class="headerlink" title="2. 统计"></a>2. 统计</h2><p>count 关键字可以用来做统计，来看下面一个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 统计某个地址有多少用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> address</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">Long <span class="hljs-title">countByAddress</span><span class="hljs-params">(String address)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 去重统计某个地址有多少用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> address</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">Long <span class="hljs-title">countDistinctByAddress</span><span class="hljs-params">(String address)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个统计的例子，第二个是去重之后统计。</p><h2 id="3-判断"><a href="#3-判断" class="headerlink" title="3. 判断"></a>3. 判断</h2><p>exists 可以用来做判断，来看个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 判断某个地址是否存在用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> address</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">Boolean <span class="hljs-title">existsUserByAddress</span><span class="hljs-params">(String address)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><p>用 delete 或者 remove 关键字可以做删除，来看两个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 根据地址删除用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> address</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">Integer <span class="hljs-title">deleteUserByAddress</span><span class="hljs-params">(String address)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 根据地址删除用户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> address</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">Integer <span class="hljs-title">removeUserByAddress</span><span class="hljs-params">(String address)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，删除的方法也是要在事务中调用。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>好啦，这就是松哥跟大家介绍的 Spring Data Jpa 中数据库操作方法默认的 10 种前缀，当然，如果这些前缀无法满足操作，那么就可以上 @Query 注解了，这是另外一个话题了，以后聊。</p><p>公众号后台回复 <strong>jpa01</strong>，获取本文案例下载地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;我一直觉得 Spring Data Jpa 用的少，没想到最近有好几个小伙伴问 Jpa 的问题，想了想，我就把我知道的关于 Jpa 的一些知识点，整理一下写几篇文章和大家分享下，今天就先来看个简单的。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="SpringData" scheme="http://www.javaboy.org/tags/SpringData/"/>
    
      <category term="Jpa" scheme="http://www.javaboy.org/tags/Jpa/"/>
    
  </entry>
  
  <entry>
    <title>前缀索引，中看也中用！</title>
    <link href="http://www.javaboy.org/2022/0211/mysql_prefix_index.html"/>
    <id>http://www.javaboy.org/2022/0211/mysql_prefix_index.html</id>
    <published>2022-02-11T10:42:33.000Z</published>
    <updated>2022-04-05T12:14:54.360Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>最近几篇文章，都是在和大家聊索引的问题，今天我们来看看前缀索引。</p><h2 id="1-什么是前缀索引"><a href="#1-什么是前缀索引" class="headerlink" title="1.什么是前缀索引"></a>1.什么是前缀索引</h2><a id="more"></a><p>所谓前缀索引<strong>说白了就是对文本的前几个字符建立索引（具体是几个字符在建立索引时指定）</strong>，这样建立起来的索引更小，所以查询更快。这有点类似于 Oracle 中对字段使用 Left 函数来建立函数索引，只不过 MySQL 的这个前缀索引在查询时是内部自动完成匹配的，并不需要使用 Left 函数。</p><p>那么为什么不对整个字段建立索引呢？一般来说使用前缀索引，可能都是因为整个字段的数据量太大，没有必要针对整个字段建立索引，前缀索引仅仅是选择一个字段的部分字符作为索引，这样一方面可以节约索引空间，另一方面则可以提高索引效率，当然很明显，这种方式也会降低索引的选择性。</p><p>这里又涉及到一个概念，什么是<strong>索引选择性</strong>？</p><h2 id="2-什么是索引选择性"><a href="#2-什么是索引选择性" class="headerlink" title="2.什么是索引选择性"></a>2.什么是索引选择性</h2><p>关于索引的选择性（Index Selectivity），它是指不重复的索引值（也称为基数 cardinality)和数据表的记录总数的比值，取值范围在 <code>[0,1]</code> 之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。</p><p>那有小伙伴要问了，是不是选择性越高的索引越好呢？当然不是！索引选择性最高为 1，如果索引选择性为 1，就是唯一索引了，搜索的时候就能直接通过搜索条件定位到具体一行记录！这个时候虽然性能最好，但是也是最费空间的，<strong>这不符合我们创建前缀索引的初衷</strong>。</p><p>我们一开始之所以要创建前缀索引而不是唯一索引，<strong>就是希望能够在索引的性能和空间之间找到一个平衡</strong>，我们希望能够选择足够长的前缀以保证较高的选择性（这样在查询的过程中就不需要扫描很多行），但是又希望索引不要太过于占用存储空间。</p><p>那么我们该如何选择一个合适的索引选择性呢？索引前缀应该足够长，以便前缀索引的选择性接近于索引的整个列，即前缀的基数应该接近于完整列的基数。</p><p>首先我们可以通过如下 SQL 得到全列选择性：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> column_name) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>然后再通过如下 SQL 得到某一长度前缀的选择性：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">LEFT</span>(column_name, prefix_length)) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>在上面这条 SQL 执行的时候，我们要注意选择合适的 prefix_length，直至计算结果约等于全列选择性的时候，就是最佳结果了。</p><h2 id="3-创建前缀索引"><a href="#3-创建前缀索引" class="headerlink" title="3.创建前缀索引"></a>3.创建前缀索引</h2><h3 id="3-1-一个小案例"><a href="#3-1-一个小案例" class="headerlink" title="3.1 一个小案例"></a>3.1 一个小案例</h3><p>举个例子，我们来创建一个前缀索引看看。</p><p>松哥这里使用的数据样例是网上找的一个测试脚本，有 300W+ 条数据，做 SQL 测试优化是够用了，小伙伴们在公众号后台回复 <code>mysql-data-samples</code> 获取脚本下载链接。</p><p>我们来大致上看下这个表结构：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220124203829.png" alt></p><p>这个表有一个 user_uuid 字段，我们就在这个字段上做文章。</p><blockquote><p>Git 小伙伴们应该都会用吧？不同于 Svn，Git 上的版本号不是数字而是一个 Hash 字符串，但是我们在具体应用的时候，比如你要做版本回退，此时并不需要输入完整的的版本号，只需要输入版本号前几个字符就行了，因为根据前面这一部分就能确定出版本号了。</p></blockquote><p>那么这张表里边的 user_uuid 字段也是这意思，如果我们想给 user_uuid 字段建立索引，就没有必要给完整的字符串建立索引，我们只需要给一部分字符串建立索引。</p><p>可能有小伙伴还是不太明白，我举一个例子，比如说我现在想按照 user_uuid 字段来查询，但是查询条件我没有必要写完整的 user_uuid，我只需要写前面一部分就可以区分出我想要的记录了，我们来看如下一条 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220124205000.png" alt></p><p>大家看到，user_uuid 我只需要给出一部分就能唯一锁定一条记录。</p><blockquote><p>当然，上面这个 SQL 是松哥测试过的，给定的 <code>&#39;39352f%&#39;</code> 条件不能再短了，再短就会查出来两条甚至多条记录。</p></blockquote><p>通过上面这个例子我们就可以看出来，如果给 user_uuid 字段建立索引，可能并不需要给完整的字符串建立索引，只需要给一部分前缀字符串建立索引。</p><p>那么给前面几个字符串建立索引呢？这个可不是拍脑门，需要科学计算，我们继续往下看。</p><h3 id="3-2-前缀索引"><a href="#3-2-前缀索引" class="headerlink" title="3.2 前缀索引"></a>3.2 前缀索引</h3><p>首先我们通过如下 SQL 来看一下 user_uuid 全列索引选择性是多少：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> user_uuid) / <span class="hljs-keyword">COUNT</span>(*) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">system_user</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220124205705.png" alt></p><p>可以看到，结果为 1。全列选择性为 1 说明这一列的值都是唯一不重复的。</p><p>接下来我们先来试几个不同的 prefix_length，看看选择性如何。</p><p>松哥这里一共测试了 5 个不同的 prefix_length，大家来看看各自的选择性：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220124210448.png" alt></p><p>8 和 9 的选择性是一样的，因为在 uuid 字符串中，第 9 个字符串是 <code>-</code>，所有的 uuid 第九个字符串都一样，所以 8 个字符和 9 个字符串的区分度就一样。</p><p>当 prefix_length 为 10 的时候，选择性就已经是 1 了，意思是，在这 300W+ 条数据中，如果我用 user_uuid 这个字段去查询的话，只需要输入前十个字符，就能唯一定位到一条具体的记录了。</p><p>那还等啥，赶紧创建前缀索引呗：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">system_user</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">index</span> user_uuid_index(user_uuid(<span class="hljs-number">10</span>));</span><br></pre></td></tr></table></figure><p>查看刚刚创建的前缀索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">system_user</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220124211058.png" alt></p><p>可以看到，第二行就是我们刚刚创建的前缀索引。</p><p>接下来我们分析查询语句中是否用到该索引：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">system_user</span> <span class="hljs-keyword">where</span> user_uuid=<span class="hljs-string">'39352f81-165e-4405-9715-75fcdf7f7068'</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/10/tran/20220124215251.png" alt></p><p>可以看到，这个前缀索引已经用上了。</p><p>具体搜索流程是这样：</p><ol><li>从 <code>user_uuid_index</code> 索引中找到第一个值为 <code>39352f81-1</code> 的记录（user_uuid 的前十个字符）。</li><li>由于 user_uuid 是二级索引，叶子结点保存的是主键值，所以此时拿到了主键 id 为 1。</li><li>拿着主键 id 去回表，在主键索引上找到 id 为 1 的行的完整记录，返回给 server 层。</li><li>server 层判断其 user_uuid 是不是 <code>39352f81-165e-4405-9715-75fcdf7f7068</code>（所以执行计划的 Extra 为 Using where）。<ol><li>如果不是，这行记录丢弃。</li><li>如果是，将该记录加入结果集。</li></ol></li><li>索引叶子结点上数据之间是有单向链表维系的，所以接着第一步查找的结果，继续向后读取下一条记录，然后重复 2、3、4 步，直到在 user_uuid_index 上取到的值不为 <code>39352f81-1</code> 时，循环结束。</li></ol><p><strong>如果我们建立了前缀索引并且前缀索引的选择性为 1，那么就不需要第 5 步了，如果前缀索引选择性小于 1，就需要第五步。</strong></p><p>从上面的案例中，小伙伴们看到，我们既节省了空间，又提高了搜索效率。</p><h3 id="3-3-一个问题"><a href="#3-3-一个问题" class="headerlink" title="3.3 一个问题"></a>3.3 一个问题</h3><p>使用了前缀索引后，我们来看一个问题，大家来看如下一条查询 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> user_uuid <span class="hljs-keyword">from</span> <span class="hljs-keyword">system_user</span> <span class="hljs-keyword">where</span> user_uuid=<span class="hljs-string">'39352f81-165e-4405-9715-75fcdf7f7068'</span>;</span><br></pre></td></tr></table></figure><p>这次不是 <code>select *</code>，而是 <code>select user_uuid</code>，按照松哥之前的文章（<a href="https://mp.weixin.qq.com/s/1xeJUCj4FuDfQj-e-4ac8w" target="_blank" rel="noopener">是时候检查一下使用索引的姿势是否正确了！</a>），大家知道，这里应该是要用到覆盖索引，我们来看看执行计划：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220124230401.png" alt></p><p>咦，说好的索引覆盖呢？（注意看 Extra 是 Using where）。</p><p>大家想想，前缀索引中，B+Tree 里保存的就不是完整的 <code>user_uuid</code> 字段的值，必须要回表才能拿到需要的数据。<strong>所以，用了前缀索引，就用不了覆盖索引了。</strong></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，这就是前缀索引，请大家结合自己项目的实际需求使用。今天就先聊这么多，剩下的我们以后再扯吧～</p><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/dhrome/article/details/72853153" target="_blank" rel="noopener">https://blog.csdn.net/dhrome/article/details/72853153</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;最近几篇文章，都是在和大家聊索引的问题，今天我们来看看前缀索引。&lt;/p&gt;
&lt;h2 id=&quot;1-什么是前缀索引&quot;&gt;&lt;a href=&quot;#1-什么是前缀索引&quot; class=&quot;headerlink&quot; title=&quot;1.什么是前缀索引&quot;&gt;&lt;/a&gt;1.什么是前缀索引&lt;/h2&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>留深还是回老家？</title>
    <link href="http://www.javaboy.org/2022/0209/life_2.html"/>
    <id>http://www.javaboy.org/2022/0209/life_2.html</id>
    <published>2022-02-09T10:42:33.000Z</published>
    <updated>2022-04-05T12:14:50.735Z</updated>
    
    <content type="html"><![CDATA[<p>昨天小伙伴们留言说中国人不卷中国人，那么，今天就不卷技术了，说说我最近的一些想法，这些想法不对小伙伴们构成任何建议，单纯只是我自己的一些琢磨。</p><p>松哥是 2015 年毕业的，至今六年有余。2015 年春招的时候，我在西安，在各大高校间奔波了快两周，拿到了四五个 offer，我起初的想法是想留在西安，因为那个时候媳妇已经被推免到西安读研了，我留在西安，就能经常相见了，而且我家离西安也就二十来公里，回家也方便。</p><a id="more"></a><p>可惜西安的薪水太低了，应届生 4000+，无奈之下只好选择了一个广州的 offer，当时我的想法是：对男人来说，去闯荡去赚钱，这比整天跟媳妇腻歪在一起更重要，只有自己的能力提高了，和媳妇的感情也会更加稳固。媳妇对我的选择也表示支持，事实证明这个想法在我和媳妇之间是行得通的，今年是我们在一起第 11 个年头，去年我们在一起十年的时候，结婚了。</p><p>刚到广州的时候，对于将来回西安这个问题我远没有现在这么纠结，那个时候的想法就是必回，将来有一天一定要回去。我刚毕业 6000+ 的薪水望着天河区 4W+ 的房价，望尘莫及。于是，在 2016 年赶上了移动互联网最后一波红利，攒了一点点钱，年底赶在西安房价暴涨之前上车了。</p><p>从此以后就更加铁了心将来要回西安了。</p><p>回西安最大的问题就是工作问题了，回去要降薪，那怎么能不降薪呢？我想了很多办法，一个就是接外包。所以在 17-18 年间我做了好几个外包项目，也能赚到一些钱，但是做久了，我总结的经验就是外包都是辛苦钱，牺牲自己学习和休息的时间换钱，这似乎不是一个很好的方案。</p><p>在做外包的同时，我也在尝试一些远程工作，因为票圈有好几个小伙伴做远程工作，我感觉也还不错，不过由于种种原因，我的远程工作尝试最终无疾而终。</p><p>但是不管怎么样，就是一直在折腾，没停，一直在为某一天回老家做准备。</p><p>然而与此同时，工作这些年，收入也在慢慢增加，人心也在慢慢膨胀，曾经觉得遥不可及的事情，慢慢都在变得触手可及。慢慢的，发现在深圳咬咬牙似乎也能上车，既然可以留在深圳，那还要不要回西安呢？于是我动摇了。</p><p>纠结、迷茫了好几个月，无数个深圳到广州的夜车上，我在琢磨这事，后来终于想通了：我虽然可以回西安，可以通过远程/外包等方式补充收入，但是媳妇不行，媳妇在深圳某头部大厂，她也有自己的前程，不能因为我想回西安，她就要放弃自己的事业和前程（需要说明的是，媳妇从始至终都是支持我回西安的，她也一起回，这点我是真的非常感激），所以，我给了自己留下来的理由。</p><p>另一方面，我有一个关系特别好的小伙伴，从小玩到大，他毕业后一直在华为西研所工作，我们老家在一个村，离西安也就二十来公里，开车二十来分钟，但是他告诉我，他在虽然西安上班，一年到头回老家两次：国庆节一次，过年一次。我心想，这一年到头回家两次的话，那跟我呆在深圳似乎也没区别，我在深圳平均下来一年也回家两次。我觉得我要是回西安了一年到头回家两次似乎也有可能，我在西安读高中的时候，高三每个学期都没回去，宅在学校。</p><p>反正就是各种给自己找留在深圳的理由，想办法说服自己。</p><p>终于说服自己了，剩下的事情就好办了，把工作这些年的积蓄都拿出来，没用家里一分钱（父母都是农民也没钱支持我们），我和媳妇在深圳看了几个月的房，转了好多工地，排队、摇号、拼积分。。。最终我们上车了，每个月房贷 2W+。</p><p>故事到这，似乎就该结束了，从此留在深圳努力搬砖。</p><p>然而今年过年回家，我又发现自己留在深圳的决心似乎也没有那么坚定。一开始没打算过年回家，临近春节的时候，西安下了好几场雪，看到老母亲发在群里的下雪视频，我实在是按耐不住了，家门口被厚厚的雪覆盖，这太有过年的感觉了，我突然就很想回去，于是临时决定回家。当翻过秦岭后，熟悉的山坡、熟悉的房屋建筑风格、熟悉的冬天光秃秃的树枝，内心那个激动呀，回家一路都是风景（走的时候就无心看这些了。。。）。</p><p>老家这些年发展也是愈发好了，西安今年开通了沿灞河的旅游专线，灞河边被重新修整了下，边上修了绿道、公园等，自然环境也变好了，这些都和我们老家的小镇相关。甚至镇上都有了商品房，还是万科开发的，房价 9000+，我都惊呆了。我们在大城市的格子间敲代码搬砖，觉得自己很牛逼，可是看一看留在老家的小伙伴们，他们日子也过的不错美滋滋的，而且他们很多人家庭收入也都不错，并没有很低。</p><p>在老家的时候，还有一件事让我特别有感触。媳妇拿驾照好多年了想练练车，在深圳我都不知道该去哪里，不知道哪里车少哪里车多，但是在老家就不一样了，我立马就能找到一条二三十公里长的双向四车道的城市公路，路上没啥车，练车的好地方。在老家就有一种一切都在掌握之中的感觉，<strong>而在深圳，就觉得自己是一粒尘埃</strong>，买房之前是这种感觉，买房之后还是这种感觉。</p><p>在家里美滋滋呆了三天，带上老母亲蒸的包子烙的锅盔，又跟着媳妇回娘家了，没几天又回深圳了。</p><p>回到深圳后，就像老黄牛反刍一样，过年期间的事情一件件重新在脑子里再过一遍，发现还是呆在老家舒服，深圳太卷了。但是转头一想，我今年还不到 30 岁，还不到而立之年，似乎还卷的动，哪一天卷不动了，再重新思考回西安这个问题。反正从深圳回西安容易，回去了再想出来就有些挑战了。</p><p>好啦，不知不觉又水了一篇～</p><p>以上内容不对小伙伴们构成任何留深建议，说不定我过些年还是会回去，那是后话了，以后再说吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天小伙伴们留言说中国人不卷中国人，那么，今天就不卷技术了，说说我最近的一些想法，这些想法不对小伙伴们构成任何建议，单纯只是我自己的一些琢磨。&lt;/p&gt;
&lt;p&gt;松哥是 2015 年毕业的，至今六年有余。2015 年春招的时候，我在西安，在各大高校间奔波了快两周，拿到了四五个 offer，我起初的想法是想留在西安，因为那个时候媳妇已经被推免到西安读研了，我留在西安，就能经常相见了，而且我家离西安也就二十来公里，回家也方便。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
</feed>
