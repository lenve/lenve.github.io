<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2024-05-10T10:41:02.274Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>答读者问：BeanFactoryPostProcessor 似乎失效了？</title>
    <link href="http://www.javaboy.org/2023/1106/spring-bean-factory-post-processor.html"/>
    <id>http://www.javaboy.org/2023/1106/spring-bean-factory-post-processor.html</id>
    <published>2023-11-06T10:02:33.000Z</published>
    <updated>2024-05-10T10:41:02.274Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴在学习 Spring 源码视频的时候，看了松哥讲的 BeanFactoryPostProcessor 的用法之后，提出了这样一个问题：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2022/08/20231104083254.png" alt><br><img src="http://img.itboyhub.com/2022/08/20231104083321.png" alt></p><p>我来跟大家补充一下这个问题的上下文：</p><p>我讲了 BeanFactoryPostProcessor，分析了其原理，也讲了具体的使用场景，一个典型的使用场景是我们在 XML 中定义 Bean 的时候，如果 Bean 的属性是使用了 properties 文件占位符如 <code>${db.username}</code> 这种，那么在 BeanFactoryPostProcessor 阶段，就会对这个占位符进行处理，将其替换成真正的 value。然后我还顺手给大家举了一个例子，我在 XML 文件中定义 Bean 的时候，给 Bean 的某一个属性设置 value 为 ^username，然后在 BeanFactoryPostProcessor 中，我将 ^username 改为某一个字符串。</p><p>小伙伴看了松哥讲的内容之后，也照着写了一个，就是上面图片中的代码，不同的是，他是将 XML 配置改为了 Java 代码配置，结果发现属性 <code>hok</code> 并未变为 <code>NB</code>，因此有了上述问题。</p><p>我觉得这个问题问的很好，给了小伙伴们一个从其他方面理解 Spring 的机会，这也是我前面一直强调的，这次的 Spring 视频需要各位小伙伴一起发力，大家有关于 Spring 的任何问题都可以提，我负责通过源码来回答你。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这个问题的分析，得先从 BeanDefinition 开始。在讲 BeanFactoryPostProcessor 之前，松哥已经和小伙伴们分析过 BeanDefinition 了，无论我们是通过 Java 代码还是通过 XML 文件定义的 Bean 对象，在解析称为 Bean 对象之前，得先解析成为 BeanDefinition，BeanDefinition 则有不同的分类，对于 XML 文件定义的 Bean，最终解析为 GenericBeanDefinition，而通过 @Bean 注解定义的 Bean 则解析为 ConfigurationClassBeanDefinition。</p><p>但是这两个的处理原理显然是有差异的。</p><p>对于 XML 定义的 Bean 来说，很明显 XML 中的所有属性都要先解析到 BeanDefinition 中，包括我们在 XML 中配置的 Bean 的各种属性，这一步是在 Spring 容器 refresh 方法中构建 BeanFactory 的时候完成的（obtainFreshBeanFactory 方法），这一步完成之后，在后面的步骤会去执行容器中所有的 BeanFactoryPostProcessor（invokeBeanFactoryPostProcessors），此时就会把前面解析出来的 BeanDefinition 中带有占位符的属性给替换过来，最后在 refresh 方法中执行 finishBeanFactoryInitialization 方法完成 Bean 的初始化。</p><p>按照上面这一套流程顺序，占位符被解析成为正常字符串没什么问题。</p><p>但是，如果是 @Bean 注解配置的 Bean，则会有所差异。</p><p>首先，@Bean 注解所标记的方法要被解析为一个 ConfigurationClassBeanDefinition，这个过程本身是通过 ConfigurationClassPostProcessor 来完成的，而 ConfigurationClassPostProcessor 本质上其实就是一个 BeanFactoryPostProcessor，换言之，@Bean 注解标记的方法是在 BeanFactoryPostProcessor 中被解析为 ConfigurationClassBeanDefinition 的。ConfigurationClassBeanDefinition 这个 BeanDefinition 主要用来记录 @Bean 注解所标记的方法所属的对象、方法的名称、方法对象、方法参数、注解的参数等等信息，把这些信息记录下来，将来在初始化 Bean 的时候，通过反射执行目标方法就可以了，即方法里边的内容是什么，ConfigurationClassBeanDefinition 其实并不关心。</p><p>最后则是和 XML 一样，在 finishBeanFactoryInitialization 方法中完成 Bean 的初始化。</p><p>经过上面分析，小伙伴们可以看到，通过 @Bean 注解定义的 Bean，我们为属性赋值是在方法内部完成的，这些方法内部的逻辑其实并未被解析到 BeanDefinition 中，显然也没有必要把方法内部的逻辑解析到 BeanDefinition 上去，因此，通过 @Bean 注解定义的 Bean，如果属性中使用了占位符，是无法通过 BeanFactoryPostProcessor 自动解析的。</p><p>好啦，现在小伙伴提出的问题大家伙都明白了吧？</p><blockquote><p>以上的分析中，方法的具体逻辑在 Spring 源码中都有详细讲解，<strong>所以这里我只是和大家梳理了思路</strong>，具体实现小伙伴可以参考我们的源码视频。</p></blockquote><p>欢迎各位小伙伴在学习过程中继续提出高质量问题，一起把这套 Spring 源码教程做扎实了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有小伙伴在学习 Spring 源码视频的时候，看了松哥讲的 BeanFactoryPostProcessor 的用法之后，提出了这样一个问题：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何让 Bean 深度感知 Spring 容器</title>
    <link href="http://www.javaboy.org/2023/1103/spring-container.html"/>
    <id>http://www.javaboy.org/2023/1103/spring-container.html</id>
    <published>2023-11-03T10:02:08.000Z</published>
    <updated>2024-05-10T10:40:52.088Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 有一个特点，就是创建出来的 Bean 对容器是无感的，一个 Bean 是怎么样被容器从一个 Class 整成一个 Bean 的，对于 Bean 本身来说是不知道的，当然也不需要知道，也就是 Bean 对容器的存在是无感的。</p><a id="more"></a><p>但是有时候我们可能会遇到一些场景，这些场景让我们去感知容器的存在，松哥举几个例子：</p><ol><li>Spring 容器提供的功能不止 IoC、AOP 这些，常见的 I18N 也是 Spring 的能力之一，如果我们想要在自己的 Bean 中去使用 I18N，那就得去找 Spring，这样就感知到了 Spring 容器的存在了。</li><li>Spring 提供了资源加载器，如果我们想要使用这个资源加载器去加载配置，那就得去找 Spring 要，这样就感知到了 Spring 容器的存在了。</li><li>想根据 beanName 去 Spring 容器中查找 Bean，那不用多说，肯定得知道 Spring 容器的存在。</li><li>…</li></ol><p>也就是说，虽然 Spring 中的 Bean 可以不用去感知 Spring 容器的存在，但是在实际开发中，我们往往还是需要 Spring 容器提供的各种能力，这样就迫使我们的 Bean 不得不去感知到 Spring 容器的存在。</p><p>那么 Spring 中的 Bean 如何感知到 Spring 容器的存在呢？</p><h2 id="1-Aware"><a href="#1-Aware" class="headerlink" title="1. Aware"></a>1. Aware</h2><p>Aware 本身就有感知的意思。</p><p>Spring Aware 是 Spring 框架中的一个特性，它允许我们的应用程序或组件与 Spring 容器进行交互。当一个类实现了 Spring Aware 接口并注册到 Spring 容器中时，该类就能够感知到 Spring 容器的存在，并且可以获取容器的一些资源或进行一些特定的操作。</p><p>Spring Aware 接口包括了多个子接口，每个子接口对应于不同的 Spring 容器资源或功能。</p><p>Aware 的实现有很多，大的方向来说主要有如下一些：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220622075948.png" alt></p><p>每一个 Aware 的作用如下：</p><ul><li>ApplicationEventPublisherAware：实现该接口的对象可以获取事件发布的能力。</li><li>ServletContextAware：实现该接口的对象可以获取到 ServletContext 对象。</li><li>MessageSourceAware：实现该接口的对象可以获取到 MessageSource 对象，MessageSource 支持多消息源，主要用于主要用于国际化。</li><li>ResourceLoaderAware：实现该接口的对象可以获取到一个 ResourceLoader，Spring ResourceLoader 则为我们提供了一个统一的 getResource() 方法来通过资源路径检索外部资源，例如文本文件、XML 文件、属性文件或图像文件等。</li><li>ApplicationStartupAware：实现该接口的对象可以获取到一个 ApplicationStartup 对象，这个比较新，是 Spring 5.3 中新推出的，通过 ApplicationStartup 可以标记应用程序启动期间的步骤，并收集有关执行上下文或其处理时间的数据。</li><li>NotificationPublisherAware：实现该接的对象可以获取到一个 NotificationPublisher 对象，通过该对象可以实现通知的发送。</li><li>EnvironmentAware：实现该接口的对象可以获取到一个 Environment 对象，通过 Environment 可以获取到容器的环境信息。</li><li>BeanFactoryAware：实现该接口的对象可以获取到一个 BeanFactory 对象，通过 BeanFactory 可以完成 Bean 的查询等操作。</li><li>ImportAware：实现该接口的对象可以获取到一个 AnnotationMetadata 对象，ImportAware 接口是需要和 @Import 注解一起使用的。在 @Import 作为元注解使用时，通过 @Import 导入的配置类如果实现了 ImportAware 接口就可以获取到导入该配置类接口的数据配置。</li><li>EmbeddedValueResolverAware：实现该接口的对象可以获取到一个 StringValueResolver 对象，通过 StringValueResolver 对象，可以读取到 Spring 容器中的 properties 配置的值（YAML 配置也可以）。</li><li>ServletConfigAware：实现该接口的对象可以获取到一个 ServletConfig 对象，不过这个似乎没什么用，我们很少自己去配置 ServletConfig。</li><li>LoadTimeWeaverAware：实现该接口的对象可以获取到一个 LoadTimeWeaver 对象，通过该对象可以获取加载 Spring Bean 时织入的第三方模块，如 AspectJ 等。</li><li>BeanClassLoaderAware：实现该接口的对象可以获取到一个 ClassLoader 对象，ClassLoader 能干嘛不需要我多说了吧。</li><li>BeanNameAware：实现该接口的对象可以获取到一个当前 Bean 的名称。</li><li>ApplicationContextAware：实现该接口的对象可以获取到一个 ApplicationContext 对象，通过 ApplicationContext 可以获取容器中的 Bean、环境等信息。</li></ul><p>通过实现这些接口，我们可以在应用程序中获取 Spring 容器提供的各种资源，并与容器进行交互，以实现更灵活和可扩展的功能。</p><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p>举两个例子小伙伴们来感受下 Aware 的具体用法。</p><h3 id="2-1-案例"><a href="#2-1-案例" class="headerlink" title="2.1 案例"></a>2.1 案例</h3><p>例如我想在 Bean 中感知到当前 Bean 的名字，那么我们可以按照如下方式来使用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanNameAware</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String beanName;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"UserService&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"beanName='"</span> + beanName + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让当前 bean 实现 BeanNameAware 接口，并重写 setBeanName 方法，这个方法会在 Spring 容器初始化 Bean 的时候自动被调用，我们就可以据此获取到 bean 的名称了。</p><p>再比如我想做一个工具 Bean，用来查找其他 Bean，那么我可以使用如下方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanUtils</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BeanFactory beanFactory;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (T) beanFactory.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让当前 Bean 实现 BeanFactoryAware 接口并重写 setBeanFactory 方法，在系统初始化当前 Bean 的时候，会自动调用 setBeanFactory 方法，进而将 beanFactory 变量传进来。</p><h3 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h3><p>当 Spring 容器创建一个 Bean 的时候，大致的流程是<code>创建实例对象</code> -&gt; <code>属性填充</code> -&gt; <code>Bean 初始化</code>。</p><p>最后这个 Bean 的初始化，就是调用 init 方法、afterPropertiesSet 方法以及 BeanPostProcessor 中的方法的，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="hljs-keyword">null</span> ? mbd.getResourceDescription() : <span class="hljs-keyword">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法一进来，首先有一个 invokeAwareMethods，这个就是用来触发 Aware 的，来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAwareMethods</span><span class="hljs-params">(String beanName, Object bean)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware beanNameAware) &#123;</span><br><span class="line">beanNameAware.setBeanName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware beanClassLoaderAware) &#123;</span><br><span class="line">ClassLoader bcl = getBeanClassLoader();</span><br><span class="line"><span class="hljs-keyword">if</span> (bcl != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">beanClassLoaderAware.setBeanClassLoader(bcl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware beanFactoryAware) &#123;</span><br><span class="line">beanFactoryAware.setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们可以看到，BeanNameAware、BeanClassLoaderAware 以及 BeanFactoryAware 这三种类型的 Aware 是在这里触发的。</p><p>每种 Aware 因为功能不同，因此作用的时机也不同。</p><p>invokeAwareMethods 方法执行完毕之后，接下来是执行 applyBeanPostProcessorsBeforeInitialization 方法，这个我们之前分析过，这个方法最终会触发 BeanPostProcessor#postProcessBeforeInitialization 方法的执行，而 BeanPostProcessor 有一个子类专门处理 Aware 的，就是 ApplicationContextAwareProcessor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!(bean <span class="hljs-keyword">instanceof</span> EnvironmentAware || bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware || bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">bean <span class="hljs-keyword">instanceof</span> MessageSourceAware || bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware ||</span><br><span class="line">bean <span class="hljs-keyword">instanceof</span> ApplicationStartupAware)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAwareInterfaces</span><span class="hljs-params">(Object bean)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EnvironmentAware environmentAware) &#123;</span><br><span class="line">environmentAware.setEnvironment(<span class="hljs-keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware embeddedValueResolverAware) &#123;</span><br><span class="line">embeddedValueResolverAware.setEmbeddedValueResolver(<span class="hljs-keyword">this</span>.embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ResourceLoaderAware resourceLoaderAware) &#123;</span><br><span class="line">resourceLoaderAware.setResourceLoader(<span class="hljs-keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationEventPublisherAware applicationEventPublisherAware) &#123;</span><br><span class="line">applicationEventPublisherAware.setApplicationEventPublisher(<span class="hljs-keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> MessageSourceAware messageSourceAware) &#123;</span><br><span class="line">messageSourceAware.setMessageSource(<span class="hljs-keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationStartupAware applicationStartupAware) &#123;</span><br><span class="line">applicationStartupAware.setApplicationStartup(<span class="hljs-keyword">this</span>.applicationContext.getApplicationStartup());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> ApplicationContextAware applicationContextAware) &#123;</span><br><span class="line">applicationContextAware.setApplicationContext(<span class="hljs-keyword">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看下，这七种类型的 Aware 是在这里被触发的。</p><p>另外像 ImportAware 是在 ImportAwareBeanPostProcessor#postProcessBeforeInitialization 方法中处理的；LoadTimeWeaverAware 是在 、LoadTimeWeaverAwareProcessor#postProcessBeforeInitialization 方法中处理的。</p><p>基本上，大部分的 Aware 接口都是在 BeanPostProcessor 中处理的。</p><p>好啦，现在小伙伴们理解 Aware 了吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 有一个特点，就是创建出来的 Bean 对容器是无感的，一个 Bean 是怎么样被容器从一个 Class 整成一个 Bean 的，对于 Bean 本身来说是不知道的，当然也不需要知道，也就是 Bean 对容器的存在是无感的。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如果你正在纠结毕设，不妨看看这个！</title>
    <link href="http://www.javaboy.org/2023/1031/tienchin-video.html"/>
    <id>http://www.javaboy.org/2023/1031/tienchin-video.html</id>
    <published>2023-10-31T10:01:50.000Z</published>
    <updated>2024-05-10T10:41:05.349Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我得先声明一点，松哥教大家的是技术，面向企业开发的技术。这套技术用来应付毕设绰绰有余，掌握了技术，就可以自己去实现各种各样不同需求的毕设了。</strong></p><a id="more"></a><p><img src="http://img.itboyhub.com/2022/08/20231030194213.png" alt></p><p>又到了一年毕设选题的季节了，最近有不少小伙伴加松哥微信，想要 vhr 的完整代码，但是我对 vhr 的定位是一个脚手架，大家可以在 vhr 这个脚手架上自己去填充业务，对于一般的毕设项目来说，这个应该也是够用了。</p><p>毕竟毕设不可能所有人都做一模一样的东西，不同的系统，业务有差别，但是技术点基本上不会有大的差别，站在技术角度来看，不管你做什么样的系统，最终使用的技术栈其实都差不多。</p><p>当然，这并不是我今天要说的，我要说的是松哥的另外一个项目 TienChin。</p><p>vhr 是一个脚手架，而 TienChin 则是一个业务完成度超 90% 的项目，而且 TienChin 中除了常规的 Spring Boot、Vue3、MyBatisPlus、Flowable、Redis 等，还跟小伙伴们详细介绍了分布式事务解决方案、详细介绍了工作流解决方案（低代码平台常见方案）、多数据源方案等都作了详细介绍，相比于 vhr，TienChin 业务完成度更高，技术栈也更加丰富，可扩展性也更强。</p><blockquote><p>要提醒大家的是，vhr 只需要有 SSM+js 基础就可以学习，而 TienChin 需要有 Spring Boot+Vue 基础才可以学习。如果不懂 Spring Boot 和 Vue，那么看 TienChin 可能会有些吃力，对于这种情况，建议先通过 vhr 掌握 Spring Boot 和 Vue 的用法。</p></blockquote><p>其他的我就不多说了，无论你是找工作还是做毕设，都不妨看看 TienChin，相信对你一定会有启发：</p><ul><li><a href="https://mp.weixin.qq.com/s/WsSILBSUq7HROur105Hicg" target="_blank" rel="noopener">TienChin 项目介绍</a></li><li><a href="https://mp.weixin.qq.com/s/3oeSrcrOhKPsCmmU8PvHzQ" target="_blank" rel="noopener">TienChin 试看视频</a></li><li><a href="https://mp.weixin.qq.com/s/LAfLrEFw6lhVjcBp0EFKMA" target="_blank" rel="noopener">TienChin 视频目录</a></li></ul><p>如果还有不清楚的地方，欢迎添加松哥咨询，备注 TienChin：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;我得先声明一点，松哥教大家的是技术，面向企业开发的技术。这套技术用来应付毕设绰绰有余，掌握了技术，就可以自己去实现各种各样不同需求的毕设了。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
  </entry>
  
  <entry>
    <title>Spring 冷知识：一个提前 AOP 的机会</title>
    <link href="http://www.javaboy.org/2023/1030/spring-early-aop.html"/>
    <id>http://www.javaboy.org/2023/1030/spring-early-aop.html</id>
    <published>2023-10-30T10:01:19.000Z</published>
    <updated>2024-05-10T10:40:48.670Z</updated>
    
    <content type="html"><![CDATA[<p>今天再来聊一个 Spring 中的冷门知识：Bean 的处理不走正常流程，而是提前进行 AOP。</p><a id="more"></a><p>本文算是前面文章（<a href="https://mp.weixin.qq.com/s/5111ksSFh6LuCr-8QmXoeg" target="_blank" rel="noopener">Spring Bean 名称暗藏玄机，这样取名就不会被代理</a>）内容的一个补充，如果还没阅读前文，建议先阅读，这样有利于更好的理解本文。</p><h2 id="1-Bean-创建流程"><a href="#1-Bean-创建流程" class="headerlink" title="1. Bean 创建流程"></a>1. Bean 创建流程</h2><p><a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw" target="_blank" rel="noopener">前面文章</a>中，松哥和大家梳理了，在 Bean 创建的过程中，会先给 BeanPostProcessor 一个返回代理对象的机会：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略。。。</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="hljs-string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Finished creating instance of bean '"</span> + beanName + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看，这里的 resolveBeforeInstantiation 方法就是给 BeanPostProcessor 一个返回代理对象的机会，在这个方法中，最终就会触发到 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation 方法，而在 postProcessBeforeInstantiation 方法中，会先判断当前 bean 是否是 AOP 相关类等：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (targetSource != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="hljs-keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面 if 分支中的内容，松哥在<a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw" target="_blank" rel="noopener">前面的文章</a>中已经和大家分析过了，这里就不再赘述。</p><p>这里主要来说说 getCustomTargetSource 中的逻辑。</p><p>先来说什么情况下会走到 getCustomTargetSource 方法：当前 Bean 不是代理对象，也不是 AOP 相关的类，就是一个普普通通的常规类，那么就会走到 getCustomTargetSource 方法这里来，这里失去查找到一个 TargetSource 对象，然后根据该对象创建当前 bean 的代理对象并返回，如果返回了代理对象，那么后续的 bean 创建流程就不执行了。</p><p>我们来看下这个方法的源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> TargetSource <span class="hljs-title">getCustomTargetSource</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// We can't create fancy target sources for directly registered singletons.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.customTargetSourceCreators != <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line"><span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.beanFactory.containsBean(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (TargetSourceCreator tsc : <span class="hljs-keyword">this</span>.customTargetSourceCreators) &#123;</span><br><span class="line">TargetSource ts = tsc.getTargetSource(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (ts != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// No custom TargetSource found.</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就是当前类 AbstractAutoProxyCreator 中有一个 customTargetSourceCreators 变量，现在就是遍历该变量，通过这个集合中保存的 TargetSourceCreator 来创建 TargetSource 对象。</p><p>TargetSourceCreator 是一个接口，这个接口只有一个抽象类 AbstractBeanFactoryBasedTargetSourceCreator，我们来看下 AbstractBeanFactoryBasedTargetSourceCreator 中的 getTargetSource 方法是怎么执行的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> TargetSource <span class="hljs-title">getTargetSource</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">AbstractBeanFactoryBasedTargetSource targetSource =</span><br><span class="line">createBeanFactoryBasedTargetSource(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (targetSource == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultListableBeanFactory internalBeanFactory = getInternalBeanFactoryForBean(beanName);</span><br><span class="line"><span class="hljs-comment">// We need to override just this bean definition, as it may reference other beans</span></span><br><span class="line"><span class="hljs-comment">// and we're happy to take the parent's definition for those.</span></span><br><span class="line"><span class="hljs-comment">// Always use prototype scope if demanded.</span></span><br><span class="line">BeanDefinition bd = getConfigurableBeanFactory().getMergedBeanDefinition(beanName);</span><br><span class="line">GenericBeanDefinition bdCopy = <span class="hljs-keyword">new</span> GenericBeanDefinition(bd);</span><br><span class="line"><span class="hljs-keyword">if</span> (isPrototypeBased()) &#123;</span><br><span class="line">bdCopy.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">&#125;</span><br><span class="line">internalBeanFactory.registerBeanDefinition(beanName, bdCopy);</span><br><span class="line"><span class="hljs-comment">// Complete configuring the PrototypeTargetSource.</span></span><br><span class="line">targetSource.setTargetBeanName(beanName);</span><br><span class="line">targetSource.setBeanFactory(internalBeanFactory);</span><br><span class="line"><span class="hljs-keyword">return</span> targetSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，TargetSource 对象是通过 createBeanFactoryBasedTargetSource 方法来创建的，这个方法是一个抽象方法，将来在子类中被实现。</p><p>接下来会调用 getInternalBeanFactoryForBean 方法创建一个新的内部容器 internalBeanFactory，本质上这个 internalBeanFactory 其实是一个子容器，现有的容器将作为这个子容器的父容器。</p><p>接下来就是获取到当前 beanName 所对应的 BeanDefinition，然后进行属性配置，并注册到内部容器中，最后返回 targetSource 对象。</p><p>我们来看下这里的 getInternalBeanFactoryForBean 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> DefaultListableBeanFactory <span class="hljs-title">getInternalBeanFactoryForBean</span><span class="hljs-params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.internalBeanFactories) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.internalBeanFactories.computeIfAbsent(beanName,</span><br><span class="line">name -&gt; buildInternalBeanFactory(getConfigurableBeanFactory()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> DefaultListableBeanFactory <span class="hljs-title">buildInternalBeanFactory</span><span class="hljs-params">(ConfigurableBeanFactory containingFactory)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Set parent so that references (up container hierarchies) are correctly resolved.</span></span><br><span class="line">DefaultListableBeanFactory internalBeanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory(containingFactory);</span><br><span class="line"><span class="hljs-comment">// Required so that all BeanPostProcessors, Scopes, etc become available.</span></span><br><span class="line">internalBeanFactory.copyConfigurationFrom(containingFactory);</span><br><span class="line"><span class="hljs-comment">// Filter out BeanPostProcessors that are part of the AOP infrastructure,</span></span><br><span class="line"><span class="hljs-comment">// since those are only meant to apply to beans defined in the original factory.</span></span><br><span class="line">internalBeanFactory.getBeanPostProcessors().removeIf(beanPostProcessor -&gt;</span><br><span class="line">beanPostProcessor <span class="hljs-keyword">instanceof</span> AopInfrastructureBean);</span><br><span class="line"><span class="hljs-keyword">return</span> internalBeanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个其实就是正常的容器创建，倒也没啥好说的，但是有几个需要注意的点：</p><ol><li>在调用 buildInternalBeanFactory 方法构建容器的时候，会先调用 getConfigurableBeanFactory 方法获取到当前容器作为父容器，如果当前容器不存在，那么就会抛出异常。这就意味着，当我们自己提供 TargetSourceCreator 实例的时候，一定要指定一个容器。</li><li>在创建了内部容器之后，会从内部容器中移除所有 AopInfrastructureBean 类型的 BeanPostProcessor，也就是内部容器将来创建出来的 bean，不再走 AopInfrastructureBean 类型后置处理器，因为这种类型的后置处理器主要是用来处理 AOP 的，现在，AOP 代理当场就生成了，就不再需要这些后置处理器了。</li></ol><p>好了，这就是大致的 AOP 提前生成原理，接下来松哥写一个案例我们一起来看下。</p><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p>首先，我们先来自定义一个 TargetSource：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceTargetSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanFactoryBasedTargetSource</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> getBeanFactory().getBean(getTargetBeanName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 TargetSource 本身，松哥在之前的 Spring 源码视频中已经和大家介绍过很多了，这里我就不再啰嗦了。</p><p>接下来自定义 TargetSourceCreator：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTargetSourceCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanFactoryBasedTargetSourceCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AbstractBeanFactoryBasedTargetSource <span class="hljs-title">createBeanFactoryBasedTargetSource</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (getBeanFactory() <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (beanClass.isAssignableFrom(UserService.class)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserServiceTargetSource();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要创建的 bean 是 UserService 的话，那么就给返回一个 UserServiceTargetSource 对象。</p><p>最后，也是最关键的一步，根据前面的分析，TargetSourceCreator 是存在于 AnnotationAwareAspectJAutoProxyCreator 这样一个 InstantiationAwareBeanPostProcessor 类型的后置处理器中的，因此，我们要想办法把自定义的 TargetSourceCreator 设置给 AnnotationAwareAspectJAutoProxyCreator，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetCustomTargetSourceCreator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span>, <span class="hljs-title">PriorityOrdered</span>, <span class="hljs-title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(bean <span class="hljs-keyword">instanceof</span> AnnotationAwareAspectJAutoProxyCreator) &#123;</span><br><span class="line">            AnnotationAwareAspectJAutoProxyCreator annotationAwareAspectJAutoProxyCreator = (AnnotationAwareAspectJAutoProxyCreator)bean;</span><br><span class="line">            CustomTargetSourceCreator customTargetSourceCreator = <span class="hljs-keyword">new</span> CustomTargetSourceCreator();</span><br><span class="line">            customTargetSourceCreator.setBeanFactory(beanFactory);</span><br><span class="line">            annotationAwareAspectJAutoProxyCreator.setCustomTargetSourceCreators(customTargetSourceCreator);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnnotationAwareAspectJAutoProxyCreator 本身就是一个 BeanPostProcessor，我们现在要做的就是修改这个 BeanPostProcessor，BeanPostProcessor 是在 Spring 容器启动时候的 refresh 方法中去初始化的，整个的初始化过程松哥在之前的<a href="https://mp.weixin.qq.com/s/ULpQBRGCqmtXapR3PGYBCA" target="_blank" rel="noopener">BeanPostProcessor 是在何时介入 Bean 创建的？</a>一文中已经详细介绍过了。</p><p>BeanPostProcessor 初始化的时候，先初始化实现了 PriorityOrdered 接口的，再初始化实现了 Ordered 接口的，最后再去初始化那些没有实现任何排序接口的 BeanPostProcessor。</p><p>而我们这里 SetCustomTargetSourceCreator 一定要赶在 AnnotationAwareAspectJAutoProxyCreator 之前进行初始化，这样，当 AnnotationAwareAspectJAutoProxyCreator 进行初始化的时候，就会用到 SetCustomTargetSourceCreator 这样一个后置处理器，进而在该处理器中修改 AnnotationAwareAspectJAutoProxyCreator 的属性。</p><p>AnnotationAwareAspectJAutoProxyCreator 类间接实现了 Ordered 接口，默认优先级是最低，但是在 Spring 容器启动时，在处理 BeanFactoryPostProcessor 时（具体是 ConfigurationClassPostProcessor），将其优先级设置为最高。</p><p>所以，我们如果想要让自定义的 SetCustomTargetSourceCreator 抢在 AnnotationAwareAspectJAutoProxyCreator 之前执行，那么就只能让 SetCustomTargetSourceCreator 去实现 PriorityOrdered 接口了，实现 PriorityOrdered 接口之后，重写 getOrder 方法，这个方法返回值是什么无所谓，反正都会在实现了 Ordered 接口的 BeanPostProcessor 之前执行。</p><p>最后，我们再在启动类上开启自动代理即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成。</p><p>这样，当 Spring 容器创建一个 Bean 的时候，就会提前被 BeanPostProcessor 拦截，然后给出一个 TargetSource，进而据此创建代理对象，这样就不需要后续常规的 Bean 创建流程了。好啦，感兴趣的小伙伴可以自己去试一试哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天再来聊一个 Spring 中的冷门知识：Bean 的处理不走正常流程，而是提前进行 AOP。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一个不太好用的 IDEA 代码生成插件</title>
    <link href="http://www.javaboy.org/2023/1026/idea-plugin.html"/>
    <id>http://www.javaboy.org/2023/1026/idea-plugin.html</id>
    <published>2023-10-26T10:01:05.000Z</published>
    <updated>2024-05-10T10:40:55.274Z</updated>
    
    <content type="html"><![CDATA[<p>之前松哥跟小伙伴们推荐了一个基于 ChatGPT-4 的 IDEA 智能助手，小伙伴们可以参考：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/ZOsOa1arNo0WbQDQOrcEFg" target="_blank" rel="noopener">手把手教大家玩一款基于 ChatGPT-4 的 IDEA 智能助手</a></li></ul><p>今天我们再给小伙伴们介绍另外一个免费的代码辅助插件 AWS Toolkit。从名字上可以看出来，这是一个方便大家在 IDEA 上使用 AWS 服务的插件，这个插件中有一个好玩的功能那就是 Amazon CodeWhisperer。</p><h2 id="1-安装与配置"><a href="#1-安装与配置" class="headerlink" title="1. 安装与配置"></a>1. 安装与配置</h2><p>插件安装好说，大家直接在 IDEA 插件商店搜索 AWS Toolkit，安装完成后重启 IDEA：</p><p><img src="http://img.itboyhub.com/2022/08/20231025115800.png" alt></p><p>安装完成之后，重启 IDEA，重启之后，就可以看到 AWS Toolkit 插件了：</p><p><img src="http://img.itboyhub.com/2022/08/20231025115917.png" alt></p><p>安装好之后，首次使用需要先配置一下，这个配置是比较容易的，我们点击 CodeWhisperer 下面的 Start 按钮，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20231025120246.png" alt></p><p>这里只需要用邮箱简单注册一下，不需要额外费用，选择第一项，然后点击 connect 按钮，此时会自动在浏览器打开 AWS 登录页面（不需要魔法）：</p><p><img src="http://img.itboyhub.com/2022/08/20231025120541.png" alt></p><p>点击确认按钮即可，接下来，会需要一个邮箱地址注册一下即可，如果已经有 AWS 账号可以直接登录：</p><p><img src="http://img.itboyhub.com/2022/08/20231025121028.png" alt></p><p>输入验证码：</p><p><img src="http://img.itboyhub.com/2022/08/20231025121347.png" alt></p><p>最后再输入一下密码，然后点击 Allow 就可以了：</p><p><img src="http://img.itboyhub.com/2022/08/20231025123408.png" alt></p><p>再次回到 IDEA，就可以看到如下页面了：</p><p><img src="http://img.itboyhub.com/2022/08/20231025123520.png" alt></p><p>从这里可以看出来，CodeWhisperer 支持 15 种开发语言：</p><p><img src="http://img.itboyhub.com/2022/08/20231025124748.png" alt></p><p>好啦，准备工作妥当，接下来我们就来简单体验一把 CodeWhisperer 的用法吧。</p><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><h3 id="2-1-根据注释生成代码"><a href="#2-1-根据注释生成代码" class="headerlink" title="2.1 根据注释生成代码"></a>2.1 根据注释生成代码</h3><p>先来看 CodeWhisperer 根据注释生成代码这个能力：</p><p><img src="http://img.itboyhub.com/2022/08/20231025125519.png" alt></p><p>进入后，我们直接写需求，写完需求之后，按回车，就会自动生成代码了，自动生成代码的过程中，一般会生成多个建议，可以按左右箭头去选择，选择完成后，按 tab 键进行代码插入：</p><p><img src="http://img.itboyhub.com/2022/08/20231025130044.png" alt></p><p>上图是官方已经写好的注释，我们自己也来写一个：</p><p><img src="http://img.itboyhub.com/2022/08/20231025130343.png" alt></p><p>啊。。这。。。</p><p>算了，试下一个功能吧。</p><h3 id="2-2-生成代码建议"><a href="#2-2-生成代码建议" class="headerlink" title="2.2 生成代码建议"></a>2.2 生成代码建议</h3><p>这个是自动分析上下文代码然后给出建议，这个功能要是做成了那真是牛！</p><p><img src="http://img.itboyhub.com/2022/08/20231025130651.png" alt></p><p>小伙伴们看提示，这段代码从 19 行开始是自动生成的，前面的代码写好之后，将光标放在 18 行，按回车，就会自动给出代码建议，觉得建议 OK，就按 tab 键插入代码。</p><blockquote><p>这个功能目前只能根据你的代码写出来类似代码，其他的还办不到。</p></blockquote><p>不过这个功能，相比于 IDEA 中自带的提示还是智能一些，当我们按回车之后，他会给出来一些代码建议，安装了该插件之后，这个功能我觉得是最有用的一个了。</p><h3 id="2-3-代码安全检查"><a href="#2-3-代码安全检查" class="headerlink" title="2.3 代码安全检查"></a>2.3 代码安全检查</h3><p>点击安全扫描，可以对当前项目中的类进行安全检查：</p><p><img src="http://img.itboyhub.com/2022/08/20231025132325.png" alt></p><p>假设我留一个资源不释放的漏洞，我们来看下检查结果：</p><p><img src="http://img.itboyhub.com/2022/08/20231025132533.png" alt></p><p>可以看到，ctx 没有关闭，存在资源泄漏的风险。</p><h3 id="2-4-推荐配置"><a href="#2-4-推荐配置" class="headerlink" title="2.4 推荐配置"></a>2.4 推荐配置</h3><p>建议关闭 CodeWhisperer 的代码导入功能，这个功能 IDEA 自己有，也挺好用，AI 推断的反而有时候不准确，并且关闭代码分享，这是为了安全：</p><p><img src="http://img.itboyhub.com/2022/08/20231025132813.png" alt></p><p>大致就这些吧。整体感受：一般般，不好用（估计就是生成 AWS 自家的代码好用）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前松哥跟小伙伴们推荐了一个基于 ChatGPT-4 的 IDEA 智能助手，小伙伴们可以参考：&lt;/p&gt;
    
    </summary>
    
      <category term="IDEA" scheme="http://www.javaboy.org/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean 名称暗藏玄机，这样取名就不会被代理</title>
    <link href="http://www.javaboy.org/2023/1024/spring-bean-proxy-name.html"/>
    <id>http://www.javaboy.org/2023/1024/spring-bean-proxy-name.html</id>
    <published>2023-10-24T10:00:48.000Z</published>
    <updated>2024-05-10T10:40:45.011Z</updated>
    
    <content type="html"><![CDATA[<p>一些使用小细节就是在不断的源码探索中逐步发现的，今天就来和小伙伴们聊一下通过 beanName 的设置，可以让一个 bean 拒绝被代理！</p><a id="more"></a><h2 id="1-代码实践"><a href="#1-代码实践" class="headerlink" title="1. 代码实践"></a>1. 代码实践</h2><p>假设我有如下一个切面：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Aspect</span></span><br><span class="line"><span class="hljs-meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* org.javaboy.demo.service.*.*(..))"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pc</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"pc()"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        String name = jp.getSignature().getName();</span><br><span class="line">        System.out.println(name + <span class="hljs-string">" 方法开始执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个切面要拦截的方法是 <code>org.javaboy.demo.service</code> 包下的所有类的所有方法，现在，这个包下有一个 BookService 类，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span>(<span class="hljs-string">"org.javaboy.demo.service.BookService.ORIGINAL"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"hello bs"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 BookService 的 beanName 我没有使用默认的 beanName，而是自己配置了一个 beanName，这个 beanName 的配置方式是 <code>类名的完整路径+.ORIGINAL</code>。</p><p>当我们按照这样的规则给 bean 取名之后，那么即使当前 bean 已经包含在切点所定义的范围内，这个 bean 也不会被代理了。</p><p>这是 Spring5.1 开始的新玩法。</p><p>这种写法的原理是什么呢？</p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h2><p>在 Spring 创建 Bean 的时候，小伙伴们都知道，bean 创建完成之后会去各种后置处理器（BeanPostProcessor）中走一圈，所以一般我们认为 BeanPostProcessor 是在 bean 实例创建完成之后执行。但是，BeanPostProcessor 中有一个特例 InstantiationAwareBeanPostProcessor，这个接口继承自 BeanPostProcessor，但是在 BeanPostProcessor 的基础之上，增加了额外的能力：</p><ol><li>在 bean 实例化之前先做一些预处理，例如直接创建代理对象，代替后续的 bean 生成。</li><li>在 bean 实例化之后但是属性填充之前，可以自定义一些属性注入策略。</li></ol><p>大致上就是这两方面的能力。</p><p>具体到代码上，就是在创建 bean 的 createBean 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略。。。</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="hljs-string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Finished creating instance of bean '"</span> + beanName + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看，这里的 resolveBeforeInstantiation 方法就是给 BeanPostProcessor 一个返回代理对象的机会，在这个方法中，最终就会触发到 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation 方法，我们来看看这里涉及到的跟 AOP 相关的 AbstractAutoProxyCreator#postProcessBeforeInstantiation 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line"><span class="hljs-comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line"><span class="hljs-comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line">TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (targetSource != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="hljs-keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法实际上干了两件事：</p><ol><li>检查当前 bean 是否需要代理，如果不需要代理，那么就存入到一个 map 集合 advisedBeans 中，key 是 bean 的名字，value 如果为 true 则表示这个 bean 是需要代理的，value 为 false，则表示这个 bean 是不需要代理的。</li><li>如果有我们有自定义的 TargetSource，则根据自定义的 TargetSource 去创建代理对象。</li></ol><p>这里我要和大家说的是第一点。</p><p>在判断一个 bean 是否需要代理的时候，主要依据两个方法：</p><ol><li>isInfrastructureClass：这个方法主要是检查当前 bean 是否是 Advice/Advisor/Pointcut 等类型，或者这个类上是否有 @Aspect 注解，这个松哥在之前的文章中其实和大家介绍过了：<a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw" target="_blank" rel="noopener">听说 Spring Bean 的创建还有一条捷径？</a>。</li><li>shouldSkip：如果 isInfrastructureClass 方法返回 false，那么就要执行 shouldSkip 了，我们来仔细看下 shouldSkip 方法。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider optimization by caching the list of the aspect names</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor pointcutAdvisor &amp;&amp;</span><br><span class="line">pointcutAdvisor.getAspectName().equals(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先找到系统中所有的切面，找到之后挨个遍历，遍历的时候判断如果当前要创建的 bean 刚好就是切面，那切面肯定是不需要代理的，直接返回 true。否则就会去调用父类的 shouldSkip 方法，我们再来瞅一眼父类的 shouldSkip 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> AutoProxyUtils.isOriginalInstance(beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOriginalInstance</span><span class="hljs-params">(String beanName, Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || beanName.length() !=</span><br><span class="line">beanClass.getName().length() + AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX.length()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> (beanName.startsWith(beanClass.getName()) &amp;&amp;</span><br><span class="line">beanName.endsWith(AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类 shouldSkip 方法主要是调用了一个静态工具方法 isOriginalInstance 来判断当前 bean 是否是一个不需要代理的 bean，这个具体的判断逻辑就是检查这个 beanName 是否按照 <code>类名的完整路径+.ORIGINAL</code> 的方式命名的，如果是则返回 true。</p><p>当 shouldSkip 方法返回 true 的时候，就会进入到 postProcessBeforeInstantiation 方法的 if 分支中，该分支将当前 beanName 存入到 advisedBeans 集合中，存储的 key 就是 beanName，value 则是 false，然后将方法 return。</p><p>当 bean 创建完成之后，再进入到 AbstractAutoProxyCreator#postProcessAfterInitialization 方法中处理的时候，就会发现这个 bean 已经存入到 advisedBeans 集合中，并且 value 是 false，这就意味着这个 bean 不需要代理，那么就针对该 bean 就不会进行 AOP 处理了，直接 return 即可。</p><p>好啦，一个小小细节，加深大家对 Spring AOP 的理解，感兴趣的小伙伴可以去试试哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些使用小细节就是在不断的源码探索中逐步发现的，今天就来和小伙伴们聊一下通过 beanName 的设置，可以让一个 bean 拒绝被代理！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>BeanPostProcessor 是在何时介入 Bean 创建的？</title>
    <link href="http://www.javaboy.org/2023/1023/spring-bean-post-processor.html"/>
    <id>http://www.javaboy.org/2023/1023/spring-bean-post-processor.html</id>
    <published>2023-10-23T10:00:25.000Z</published>
    <updated>2024-05-10T10:40:41.061Z</updated>
    
    <content type="html"><![CDATA[<p>今天来和各位小伙伴详细分析一下 BeanPostProcessor。今天这篇是原理分析，基本用法松哥之前已经讲过了，有视频也有文章，对视频感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>。</p><p>不同于前面和大家分享的 BeanFactoryPostProcessor，BeanPostProcessor 从名字上就能看出来，这是一个 Bean 的后置处理器，也就是说，BeanPostProcessor 其实主要是对已经创建出来的 Bean 做一些后置处理，而 BeanFactoryPostProcessor 主要是针对 BeanDefinition 做后置处理（此时 Bean 对象还没创建出来）。</p><a id="more"></a><p>但是，BeanPostProcessor 家族里边也有例外，即 MergedBeanDefinitionPostProcessor，这是一个 BeanPostProcessor，但是却可以处理 BeanDefinition。</p><p>这一切都是咋回事呢？我们今天就来分析分析。</p><h2 id="1-BeanPostProcessor"><a href="#1-BeanPostProcessor" class="headerlink" title="1. BeanPostProcessor"></a>1. BeanPostProcessor</h2><p>首先我们先来看一下 BeanPostProcessor 接口的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是两个方法，理解这两个方法有一个大的前提，就是此时 Spring 容器已经通过 Java 反射创建出来 Bean 对象了，只不过在初始化这个 Bean 对象的时候，又提供了一些配置接口：</p><ul><li>postProcessBeforeInitialization：这个是在 Bean 初始化之前触发，此时我们已经有一个 Bean 对象了，但是 Bean 中一些生命周期方法如 InitializingBean 接口的 afterPropertiesSet 方法、自定义的 init-method 方法等都尚未执行，在这些方法执行之前触发 postProcessBeforeInitialization 方法。</li><li>postProcessAfterInitialization：类似于上面，在 afterPropertiesSet 和自定义的 init-method 之后触发该方法。</li></ul><p>BeanPostProcessor 的应用非常广泛，在整个 Spring 体系中，也扮演了非常重要的角色，如 @Bean 注解的解析、AOP 动态代理的生成等等许多我们日常使用的功能，都是通过 BeanPostProcessor 来实现的。</p><h2 id="2-MergedBeanDefinitionPostProcessor"><a href="#2-MergedBeanDefinitionPostProcessor" class="headerlink" title="2. MergedBeanDefinitionPostProcessor"></a>2. MergedBeanDefinitionPostProcessor</h2><p>MergedBeanDefinitionPostProcessor 算是整个 BeanPostProcessor 家族中比较另类的一个接口了，它虽然是 BeanPostProcessor，但是却可以处理 BeanDefinition。MergedBeanDefinitionPostProcessor 介入的时机就是 Bean 创建成功之后，Bean 中各个属性填充之前。</p><p>MergedBeanDefinitionPostProcessor 用于在 Bean 定义合并之后对合并后的 Bean 进行后置处理。它的作用是允许开发者在 Bean 定义合并完成后，对合并后的 Bean 进行自定义的修改或扩展操作。通常情况下，这个接口用于处理带有注解的 Bean 定义，例如 @Autowired 或 @Value 等注解的处理。通过实现 MergedBeanDefinitionPostProcessor 接口，开发者可以在 Bean 定义合并后，对这些注解进行解析和处理，以实现自定义的逻辑。</p><p>来看下 MergedBeanDefinitionPostProcessor 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MergedBeanDefinitionPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resetBeanDefinition</span><span class="hljs-params">(String beanName)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就两个方法，一个是处理合并后的 BeanDefinition，还有一个是重置 Bean 的。</p><h2 id="3-收集-BeanPostProcessor"><a href="#3-收集-BeanPostProcessor" class="headerlink" title="3. 收集 BeanPostProcessor"></a>3. 收集 BeanPostProcessor</h2><p>接下来我们来看 BeanPostProcessor 的处理流程，首先第一步就是在容器启动的时候，收集到用户注册在系统中的 BeanPostProcessor，无论是 Java 配置还是 XML 配置，在 refresh 方法中都会调用到 registerBeanPostProcessors，这个方法就是用来收集 BeanPostProcessor 的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="hljs-number">1</span> + postProcessorNames.length;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">priorityOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">orderedPostProcessors.add(pp);</span><br><span class="line"><span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">nonOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="hljs-keyword">if</span> (pp <span class="hljs-keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line">sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码我就不逐行解释了，我来说一下整体的处理思路。</p><p>这里用来存储 BeanPostProcessor 的集合一共有四个，分别是：</p><ul><li>priorityOrderedPostProcessors：由于 BeanPostProcessor 可能存在多个，所以我们需要给这多个 BeanPostProcessor 进行排序，排序的方式有两种，一种就是在定义 BeanPostProcessor 的时候，让其实现 PriorityOrdered 接口，那么这里就是把所有实现了 PriorityOrdered 接口的 BeanPostProcessor 收集到一起。</li><li>orderedPostProcessors：类似于上面的，这里是收集所有实现了 Ordered 接口的 BeanPostProcessor。</li><li>nonOrderedPostProcessors：这个里边保存了所有不需要排序的 BeanPostProcessor。</li><li>internalPostProcessors：这个里边保存了 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor，前三种互相之间不会重复，而 internalPostProcessors 可能会和前三种有重复。</li></ul><p>将收集并且排序好的 BeanPostProcessor，调用 registerBeanPostProcessors 方法进行注册：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanPostProcessors</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ConfigurableListableBeanFactory beanFactory, List&lt;? extends BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory abstractBeanFactory) &#123;</span><br><span class="line"><span class="hljs-comment">// Bulk addition is more efficient against our CopyOnWriteArrayList there</span></span><br><span class="line">abstractBeanFactory.addBeanPostProcessors(postProcessors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终就是把收集到的 BeanPostProcessor 添加到容器的 beanPostProcessors 变量中。</p><p>现在，容器中已经有了 BeanPostProcessor 了，接下来看什么时候执行。</p><h2 id="4-触发-BeanPostProcessor"><a href="#4-触发-BeanPostProcessor" class="headerlink" title="4. 触发 BeanPostProcessor"></a>4. 触发 BeanPostProcessor</h2><p>BeanPostProcessor 的执行分为两种情况，一种是执行 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor，还有一种是执行普通的 BeanPostProcessor，我们分别来看。</p><p>在创建 Bean 的关键方法 AbstractAutowireCapableBeanFactory#doCreateBean 中，有这样几个关键步骤：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 初始化 Bean 实例</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line">Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="hljs-string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.markAsPostProcessed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//省略</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//省略</span></span><br><span class="line"><span class="hljs-keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到，在初始化 Bean 实例之后，有一个 applyMergedBeanDefinitionPostProcessors 方法，这个方法就是用来触发 MergedBeanDefinitionPostProcessor 执行的。</p><p>populateBean 方法是给 Bean 的各个属性填充值的，填充完成之后，调用 initializeBean 方法进行剩余的初始化工作，在 initializeBean 方法中，调用了其余的 BeanPostProcessor。</p><h3 id="4-1-触发-MergedBeanDefinitionPostProcessor"><a href="#4-1-触发-MergedBeanDefinitionPostProcessor" class="headerlink" title="4.1 触发 MergedBeanDefinitionPostProcessor"></a>4.1 触发 MergedBeanDefinitionPostProcessor</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyMergedBeanDefinitionPostProcessors</span><span class="hljs-params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (MergedBeanDefinitionPostProcessor processor : getBeanPostProcessorCache().mergedDefinition) &#123;</span><br><span class="line">processor.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-触发其他-BeanPostProcessor"><a href="#4-2-触发其他-BeanPostProcessor" class="headerlink" title="4.2 触发其他 BeanPostProcessor"></a>4.2 触发其他 BeanPostProcessor</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="hljs-keyword">null</span> ? mbd.getResourceDescription() : <span class="hljs-keyword">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看这个顺序，先是调 applyBeanPostProcessorsBeforeInitialization，这个里边最终就触发到了 BeanPostProcessor#postProcessBeforeInitialization 方法；然后调用 invokeInitMethods，afterPropertiesSet 和自定义的 init-method 都在这里被触发；最后调用 applyBeanPostProcessorsAfterInitialization，这个里边最终就触发到 BeanPostProcessor#postProcessAfterInitialization 方法。</p><p>好啦，这就是和小伙伴们梳理的 BeanPostProcessor 原理了，感兴趣的小伙伴可以自己 DEBUG 跑一遍哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来和各位小伙伴详细分析一下 BeanPostProcessor。今天这篇是原理分析，基本用法松哥之前已经讲过了，有视频也有文章，对视频感兴趣的小伙伴戳这里：&lt;a href=&quot;https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring源码应该怎么学？&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不同于前面和大家分享的 BeanFactoryPostProcessor，BeanPostProcessor 从名字上就能看出来，这是一个 Bean 的后置处理器，也就是说，BeanPostProcessor 其实主要是对已经创建出来的 Bean 做一些后置处理，而 BeanFactoryPostProcessor 主要是针对 BeanDefinition 做后置处理（此时 Bean 对象还没创建出来）。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>面试题解答：Spring Lifecycle 和 SmartLifecycle 有何区别？</title>
    <link href="http://www.javaboy.org/2023/1018/spring-lifecycle-smartlifecycle.html"/>
    <id>http://www.javaboy.org/2023/1018/spring-lifecycle-smartlifecycle.html</id>
    <published>2023-10-18T10:00:13.000Z</published>
    <updated>2024-05-10T10:40:37.242Z</updated>
    
    <content type="html"><![CDATA[<p>当我们想在 Spring 容器启动或者关闭的时候，做一些初始化操作或者对象销毁操作，我们可以怎么做？</p><a id="more"></a><p>注意我这里说的是容器启动或者关闭的时候，不是某一个 Bean 初始化或者销毁的时候～</p><h2 id="1-Lifecycle"><a href="#1-Lifecycle" class="headerlink" title="1. Lifecycle"></a>1. Lifecycle</h2><p>对于上面提到的问题，如果小伙伴们稍微研究过 Spring，应该是了解其里边有一个 Lifecycle 接口，通过这个接口，我们可以在 Spring 容器启动或者关闭的时候，做一些自己需要的事情。</p><p>我们先来看下 Lifecycle 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lifecycle</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口一共就三个方法：</p><ul><li>start：启动组件，该方法在执行之前，先调用 isRunning 方法判断组件是否已经启动了，如果已经启动了，就不重复启动了。</li><li>stop：停止组件，该方法在执行之前，先调用 isRunning 方法判断组件是否已经停止运行了，如果已经停止运行了，就不再重复停止了。</li><li>isRunning：这个是返回组件是否已经处于运行状态了，对于容器来说，只有当容器中的所有<strong>适用组件</strong>都处于运行状态时，这个方法返回 true，否则返回 false。</li></ul><p>如果我们想自定义一个 Lifecycle，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLifeCycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> running;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="hljs-keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="hljs-string">"start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="hljs-keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="hljs-string">"stop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> running;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要自定义一个 running 变量，该变量用来描述当前组件是否处于运行/停止状态，因为系统在调用 start 和 stop 方法的时候，都会先调用 isRunning 方法，用以确认是否需要真的调用 start/stop 方法。</p><p>接下来创建配置类，扫描上述组件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们启动容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">        ctx.start();</span><br><span class="line">        ctx.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动之后，我们就可以看到控制台打印出来的信息：</p><p><img src="http://img.itboyhub.com/2022/08/20230911165859.png" alt></p><p>可以看到，在容器启动和停止的时候，相应的方法会被触发。</p><p>不过 Lifecycle 有一个问题，就是必须显式的调用 start 或者 stop 方法才会触发 Lifecycle 中的方法。当然，如果你没有调用 stop 方法，而是调用了 close 方法，那么在 close 方法内部也会触发 stop 方法。</p><p>如果我们想要 start 方法被自动触发呢？那就得一个更加智能的 Lifecycle 了— SmartLifecycle。</p><h2 id="2-SmartLifecycle"><a href="#2-SmartLifecycle" class="headerlink" title="2. SmartLifecycle"></a>2. SmartLifecycle</h2><p>相比于 LifeCycle，SmartLifecycle 中多了几个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SmartLifecycle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Lifecycle</span>, <span class="hljs-title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> DEFAULT_PHASE = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAutoStartup</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">stop();</span><br><span class="line">callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPhase</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> DEFAULT_PHASE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看一下，这里首先多了一个 isAutoStartup 方法，这个方法就表示是否自动执行 startup 方法，这个方法返回 true，则 startup 方法会被自动触发，这个方法要是返回 false，则 startup 方法就不会被自动触发（那么效果就等同于 LifeCycle 了）。</p><p>这里多了一个重载的 stop 方法，这个重载的 stop 方法会传入一个线程对象，然后在 stop 中触发，这个 callback 回调是为了告诉容器，我们销毁组件的工作已经完成了。如果使用了 SmartLifecycle，那么 Lifecycle 中的 stop 方法就不会被直接触发了，除非我们在 SmartLifecycle#stop 中手动去触发 Lifecycle#stop 方法。</p><p>另外这里还有一个 getPhase 方法，这个当存在多个 SmartLifecycle 实例的时候，我们需要为其执行顺序排序，getPhase 方法就是返回执行顺序，数字越小，优先级越高，默认优先级最小。</p><p>我们来写一个 SmartLifecycle 的案例来试下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLifeCycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartLifecycle</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> running;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="hljs-keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="hljs-string">"start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="hljs-keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="hljs-string">"stop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> running;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAutoStartup</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> SmartLifecycle.<span class="hljs-keyword">super</span>.isAutoStartup();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">        stop();</span><br><span class="line">        callback.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPhase</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-原理分析"><a href="#3-原理分析" class="headerlink" title="3. 原理分析"></a>3. 原理分析</h2><p>那么 Lifecycle 到底是如何被触发的呢？我们来分析一下源码。</p><p>由于系统中可能存在多个 Lifecycle，因此这多个 Lifecycle 需要一个统一的管理，这个管理者就是 LifecycleProcessor，这也是一个接口，这个接口中只有两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LifecycleProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Lifecycle</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onRefresh：这个是在上下文刷新的时候被触发，例如在容器启动的时候这个方法被触发。</li><li>onClose：这个是在上下文关闭的时候被触发，例如在容器停止运行的时候这个方法被触发。</li></ul><p>LifecycleProcessor 只有一个实现类 DefaultLifecycleProcessor，所以很好分析，这个 DefaultLifecycleProcessor 中，重写了上面的 onRefresh 和 onClose 两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">startBeans(<span class="hljs-keyword">true</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.running = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClose</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">stopBeans();</span><br><span class="line"><span class="hljs-keyword">this</span>.running = <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-start"><a href="#3-1-start" class="headerlink" title="3.1 start"></a>3.1 start</h3><p>小伙伴们看到，在容器启动的时候，这里会去调用 startBeans 方法，在这个方法中就会触发 Lifecycle#start 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startBeans</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">Map&lt;Integer, LifecycleGroup&gt; phases = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!autoStartupOnly || (bean <span class="hljs-keyword">instanceof</span> SmartLifecycle smartLifecycle &amp;&amp; smartLifecycle.isAutoStartup())) &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> phase = getPhase(bean);</span><br><span class="line">phases.computeIfAbsent(</span><br><span class="line">phase,</span><br><span class="line">p -&gt; <span class="hljs-keyword">new</span> LifecycleGroup(phase, <span class="hljs-keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly)</span><br><span class="line">).add(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">phases.values().forEach(LifecycleGroup::start);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，首先调用 getLifecycleBeans 方法，这个方法的作用是去 Spring 容器中查找所有 Lifecycle 类型的 Bean，并把查找结果封装到一个 Map 集合中返回。</p><p>接下来就去遍历这个 Map，遍历的时候由于 autoStartupOnly 变量传进来的时候是 true，取反之后就是 false 了，所以就会去判断这个 Bean 是否为 SmartLifecycle 类型，如果是该类型并且 isAutoStartup 方法返回 true，就表示要自动执行 start 方法。</p><p>如果确定是 SmartLifecycle 类型的 Bean，那么就调用 getPhase 方法获取其 phase，这个表示执行的优先级，然后将之存入到 phases 集合中，存储的时候，phase 是 key，value 则是一个 LifecycleGroup，phases 是一个 TreeMap，小伙伴们知道，TreeMap 是有序的，也就是存入进去的数据，会自动按照 phase 进行排序。LifecycleGroup 是将 phase 相同的 SmartLifecycle 分组之后的对象。</p><blockquote><p>经过上面的分析，相信大家已经明白了为什么直接实现 Lifecycle 接口，就一定需要手动调用 start 方法（因为上面 if 中的条件不满足）。</p></blockquote><p>最后就是遍历 phases，调用每一个 LifecycleGroup 中的 start 方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.members.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(<span class="hljs-keyword">this</span>.members);</span><br><span class="line"><span class="hljs-keyword">for</span> (LifecycleGroupMember member : <span class="hljs-keyword">this</span>.members) &#123;</span><br><span class="line">doStart(<span class="hljs-keyword">this</span>.lifecycleBeans, member.name, <span class="hljs-keyword">this</span>.autoStartupOnly);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doStart</span><span class="hljs-params">(Map&lt;String, ? extends Lifecycle&gt; lifecycleBeans, String beanName, <span class="hljs-keyword">boolean</span> autoStartupOnly)</span> </span>&#123;</span><br><span class="line">Lifecycle bean = lifecycleBeans.remove(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span> &amp;&amp; bean != <span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">String[] dependenciesForBean = getBeanFactory().getDependenciesForBean(beanName);</span><br><span class="line"><span class="hljs-keyword">for</span> (String dependency : dependenciesForBean) &#123;</span><br><span class="line">doStart(lifecycleBeans, dependency, autoStartupOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!bean.isRunning() &amp;&amp;</span><br><span class="line">(!autoStartupOnly || !(bean <span class="hljs-keyword">instanceof</span> SmartLifecycle smartLifecycle) || smartLifecycle.isAutoStartup())) &#123;</span><br><span class="line">bean.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 doStart 方法中，从集合中取出来 Lifecycle，然后查找一下该 Lifecycle 是否有依赖的 Bean，如果有，就继续递归调用 doStart 方法。否则，在 isRunning 返回 false（即该组件还没有运行），且 bean 不是 SmartLifecycle 类型（那就只能是 Lifecycle 类型）或者 bean 是 SmartLifecycle 类型且 isAutoStartup 方法为 true 的情况下，调用 bean 的 start 方法。</p><blockquote><p>小伙伴们注意，上面的分析是从 onRefresh 方法开始的，该方法中调用 startBeans 的时候，传入的参数是 true，也就是上面这个判断里边 autoStartupOnly 为 true，取反之后这个条件就不满足了，如果是我们手动调用 start 方法的话，这个参数默认传入的是 false，取反之后上面这个条件就满足了，也就是无论是手动还是自动，最终都是在这个地方触发 start 方法的。</p></blockquote><h3 id="3-2-stop"><a href="#3-2-stop" class="headerlink" title="3.2 stop"></a>3.2 stop</h3><p>再来看 stop 方法的逻辑。从 onClose 方法开始，也是先调用 stopBeans 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopBeans</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Map&lt;String, Lifecycle&gt; lifecycleBeans = getLifecycleBeans();</span><br><span class="line">Map&lt;Integer, LifecycleGroup&gt; phases = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">lifecycleBeans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">int</span> shutdownPhase = getPhase(bean);</span><br><span class="line">LifecycleGroup group = phases.get(shutdownPhase);</span><br><span class="line"><span class="hljs-keyword">if</span> (group == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">group = <span class="hljs-keyword">new</span> LifecycleGroup(shutdownPhase, <span class="hljs-keyword">this</span>.timeoutPerShutdownPhase, lifecycleBeans, <span class="hljs-keyword">false</span>);</span><br><span class="line">phases.put(shutdownPhase, group);</span><br><span class="line">&#125;</span><br><span class="line">group.add(beanName, bean);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">if</span> (!phases.isEmpty()) &#123;</span><br><span class="line">List&lt;Integer&gt; keys = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(phases.keySet());</span><br><span class="line">keys.sort(Collections.reverseOrder());</span><br><span class="line"><span class="hljs-keyword">for</span> (Integer key : keys) &#123;</span><br><span class="line">phases.get(key).stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块的逻辑跟 start 差不多，就是排序的方案有一些差别。这里用了 HashMap，没有用 TreeMap，然后在具体调用的时候，再去给 key 排序的。</p><p>这里调用到的也是 LifecycleGroup 的 stop 方法，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.members.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.members.sort(Collections.reverseOrder());</span><br><span class="line">CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-keyword">this</span>.smartMemberCount);</span><br><span class="line">Set&lt;String&gt; countDownBeanNames = Collections.synchronizedSet(<span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">Set&lt;String&gt; lifecycleBeanNames = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-keyword">this</span>.lifecycleBeans.keySet());</span><br><span class="line"><span class="hljs-keyword">for</span> (LifecycleGroupMember member : <span class="hljs-keyword">this</span>.members) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (lifecycleBeanNames.contains(member.name)) &#123;</span><br><span class="line">doStop(<span class="hljs-keyword">this</span>.lifecycleBeans, member.name, latch, countDownBeanNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (member.bean <span class="hljs-keyword">instanceof</span> SmartLifecycle) &#123;</span><br><span class="line"><span class="hljs-comment">// Already removed: must have been a dependent bean from another phase</span></span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">latch.await(<span class="hljs-keyword">this</span>.timeout, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="hljs-keyword">if</span> (latch.getCount() &gt; <span class="hljs-number">0</span> &amp;&amp; !countDownBeanNames.isEmpty() &amp;&amp; logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="hljs-string">"Failed to shut down "</span> + countDownBeanNames.size() + <span class="hljs-string">" bean"</span> +</span><br><span class="line">(countDownBeanNames.size() &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">"s"</span> : <span class="hljs-string">""</span>) + <span class="hljs-string">" with phase value "</span> +</span><br><span class="line"><span class="hljs-keyword">this</span>.phase + <span class="hljs-string">" within timeout of "</span> + <span class="hljs-keyword">this</span>.timeout + <span class="hljs-string">"ms: "</span> + countDownBeanNames);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看一下，这里的 doStop 方法，最终就会触发到 Lifecycle 的 stop，这个里边的代码简单，我们就不去细看了。需要提醒大家的时候，这里使用到了这样一个计数器，初始值就是 members 的数量，每当调用一个 member 的 stop 方法之后，这个计数器减一，这样，到下面调用 await 的时候，就刚刚好不用等。</p><p>await 方法的等待时间是 this.timeout，这个属性默认值是 30s，也就是如果 stop 方法在子线程中执行，那么执行时间不能超过 30s，否则就会抛出异常。</p><p>如果我们想要自定义这个超时时间，可以自己在 Spring 容器中提供如下 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DefaultLifecycleProcessor <span class="hljs-title">lifecycleProcessor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DefaultLifecycleProcessor processor = <span class="hljs-keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">        processor.setTimeoutPerShutdownPhase(<span class="hljs-number">2000</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> processor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个案例中设置了超时时间为 2s。</p><p>好啦，这就是关于 Lifecycle 的整体触发流程。</p><p>接下来我们来看下自动触发和手动触发分别是在哪里触发的。</p><h3 id="3-3-自动触发"><a href="#3-3-自动触发" class="headerlink" title="3.3 自动触发"></a>3.3 自动触发</h3><p>先来看自动触发。</p><p>经过前面的讲解，现在小伙伴们都知道，Spring 容器初始化的时候，会调用到 refresh 方法，这个刷新要做的事情比较多，其中最后一件事情是调用 finishRefresh 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishRefresh</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">clearResourceCaches();</span><br><span class="line"><span class="hljs-comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"><span class="hljs-comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"><span class="hljs-comment">// Publish the final event.</span></span><br><span class="line">publishEvent(<span class="hljs-keyword">new</span> ContextRefreshedEvent(<span class="hljs-keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个方法跟本文相关，一个是 initLifecycleProcessor，这个是初始化 LifecycleProcessor，就是去 Spring 容器中查找 LifecycleProcessor，找到就用，没找到就创建新的。</p><p>然后就是 getLifecycleProcessor().onRefresh(); 方法，这个就是触发了 DefaultLifecycleProcessor#onRefresh 方法，而关于该方法的逻辑，松哥在前面已经介绍过了。</p><p>来看下 initLifecycleProcessor 方法是如何做初始化操作的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initLifecycleProcessor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.lifecycleProcessor =</span><br><span class="line">beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">DefaultLifecycleProcessor defaultProcessor = <span class="hljs-keyword">new</span> DefaultLifecycleProcessor();</span><br><span class="line">defaultProcessor.setBeanFactory(beanFactory);</span><br><span class="line"><span class="hljs-keyword">this</span>.lifecycleProcessor = defaultProcessor;</span><br><span class="line">beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, <span class="hljs-keyword">this</span>.lifecycleProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家注意，LIFECYCLE_PROCESSOR_BEAN_NAME 常量的值是 lifecycleProcessor，为什么要强调这个，如果我们是自定义 DefaultLifecycleProcessor，那么 beanName 必须是 lifecycleProcessor，否则系统会以为我们没有自定义 DefaultLifecycleProcessor。</p><p>那么这里的逻辑就是如果用户自定义了 DefaultLifecycleProcessor，那么就使用用户自定义的 DefaultLifecycleProcessor，否则就创建一个新的 DefaultLifecycleProcessor，并注册到 Spring 容器中。</p><p>这就是自动触发的逻辑。</p><h3 id="3-4-手动触发"><a href="#3-4-手动触发" class="headerlink" title="3.4 手动触发"></a>3.4 手动触发</h3><p>手动触发需要我们自己调用 start 方法，start 方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">getLifecycleProcessor().start();</span><br><span class="line">publishEvent(<span class="hljs-keyword">new</span> ContextStartedEvent(<span class="hljs-keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于直接调用了 DefaultLifecycleProcessor 的 start 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">startBeans(<span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.running = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个跟 DefaultLifecycleProcessor 的 onRefresh 方法内容基本一致，唯一的区别在于调用 startBeans 的时候，传入的参数为 false，这个参数带来的变化，这个松哥在前面的内容中已经分析过了，这里就不再啰嗦啦。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，这就是松哥和大家分享的 Spring Lifecycle 和 SmartLifecycle 的区别。老实说，我们自己开发需要自定义这两个的场景其实并不多，但是在 Spring Boot 中，SmartLifecycle 的应用还是比较多的，有了今天这个内容作基础，将来小伙伴们分析 Spring Boot 的时候就会容易很多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们想在 Spring 容器启动或者关闭的时候，做一些初始化操作或者对象销毁操作，我们可以怎么做？&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>@Scope 注解失效了？咋回事</title>
    <link href="http://www.javaboy.org/2023/1012/spring-scope.html"/>
    <id>http://www.javaboy.org/2023/1012/spring-scope.html</id>
    <published>2023-10-12T09:59:56.000Z</published>
    <updated>2024-05-10T10:40:32.860Z</updated>
    
    <content type="html"><![CDATA[<p>scope 属性，相信大家都知道，一共有六种：</p><a id="more"></a><table><thead><tr><th>取值</th><th>含义</th><th>生效条件</th></tr></thead><tbody><tr><td>singleton</td><td>表示这个 Bean 是单例的，在 Spring 容器中，只会存在一个实例。</td></tr><tr><td>prototype</td><td>多例模式，每次从 Spring 容器中获取 Bean 的时候，才会创建 Bean 的实例出来。</td></tr><tr><td>request</td><td>当有一个新的请求到达的时候，会创建一个 Bean 的实例处理。</td><td>web 环境下生效</td></tr><tr><td>session</td><td>当有一个新的会话的时候，会创建一个 Bean 的实例出来。</td><td>web 环境下生效</td></tr><tr><td>application</td><td>这个表示在项目的整个生命周期中，只有一个 Bean。</td><td>web 环境下生效</td></tr><tr><td>gloablsession</td><td>有点类似于 application，但是这个是在 portlet 环境下使用的。</td><td>web 环境下生效</td></tr></tbody></table><p>这个用法也很简单，通过配置就可以设置一个 Bean 是否为单例模式。</p><h2 id="1-问题呈现"><a href="#1-问题呈现" class="headerlink" title="1. 问题呈现"></a>1. 问题呈现</h2><p>今天我要说的不是基础用法，是另外一个问题，假设我现在有如下两个 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Repository</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 UserService 中注入 UserDao，由于两者都没有声明 scope，所以默认都是单例的。</p><p>现在，如果我给 UserDao 设置 Scope，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Repository</span></span><br><span class="line"><span class="hljs-meta">@Scope</span>(value = <span class="hljs-string">"prototype"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 prototype 表示如果我们从 Spring 容器中多次获取 UserDao 的实例，拿到的是同一个实例。</p><p>但是！！！</p><p>我现在是在 UserService 里边注入 UserDao 的，UserService 是单例的，也就是 UserService 只初始化了一次，按理说 UserService 也只跟 Spring 容器要了一次 UserDao，这就导致我们最终从 UserService 中拿到的 UserDao 始终是同一个。</p><p>测试方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">UserService us = ctx.getBean(UserService.class);</span><br><span class="line">UserService us2 = ctx.getBean(UserService.class);</span><br><span class="line">System.out.println(us.userDao == us2.userDao);</span><br></pre></td></tr></table></figure><p>最终打印结果为 true。</p><p>其实，这个也没啥问题，因为你确实只跟 Spring 容器只要了一次 UserDao。但是现在如果我的需求就是 UserService 是单例，UserDao 每次都获取不同的实例呢？阁下该如何应对？</p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><p>Spring 已经考虑到这个问题了，解决方案就是通过代理来实现。</p><p>在我们使用 @Scope 注解的时候，该注解还有另外一个属性 proxyMode，这个属性的取值有四种，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ScopedProxyMode &#123;</span><br><span class="line">DEFAULT,</span><br><span class="line">NO,</span><br><span class="line">INTERFACES,</span><br><span class="line">TARGET_CLASS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT：这个是默认值，默认就是 NO，即不使用代理。</li><li>NO：不使用代理。</li><li>INTERFACES：使用 JDK 动态代理，要求当前 Bean 得有接口。</li><li>TARGET_CLASS：使用 CGLIB 动态代理。</li></ul><p>可以通过设置 proxyMode 属性来为 Bean 产生动态代理对象，进而实现 Bean 的多例。</p><p>现在我修改 UserDao 上的注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Repository</span></span><br><span class="line"><span class="hljs-meta">@Scope</span>(value = <span class="hljs-string">"prototype"</span>,proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，再去执行测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">UserService us = ctx.getBean(UserService.class);</span><br><span class="line">UserService us2 = ctx.getBean(UserService.class);</span><br><span class="line">System.out.println(us==us2);</span><br><span class="line">System.out.println(<span class="hljs-string">"us.userDao = "</span> + us.userDao);</span><br><span class="line">System.out.println(<span class="hljs-string">"us2.userDao = "</span> + us2.userDao);</span><br><span class="line">System.out.println(<span class="hljs-string">"us.userDao.getClass() = "</span> + us.userDao.getClass());</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230909111024.png" alt></p><p>可以看到，UserService 是单例，userDao 确实是不同实例了，并且 userDao 是一个 CGLIB 动态代理对象。</p><p>那么，如果是 XML 配置该怎么配置呢？</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.demo.p2.UserDao"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userDao"</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.demo.p2.UserService"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"userDao"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"userDao"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个跟普通的 AOP 配置方式不一样，不过也很好理解，对照上面的注解配置来理解即可。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>那么这一切是怎么实现的呢？</p><p>Spring 中提供了专门的工具方法 <code>AnnotationConfigUtils#applyScopedProxyMode</code> 来处理此事：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> BeanDefinitionHolder <span class="hljs-title">applyScopedProxyMode</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line"><span class="hljs-keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> definition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line"><span class="hljs-keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以看到，如果代理模式是 NO/Default 的话，那么直接返回原本的 definition，否则就要调用 <code>ScopedProxyCreator.createScopedProxy</code> 方法去生成代理对象了，这里还涉及到一个 proxyTargetClass 参数，这个参数是用来判断是 JDK 动态代理还是 CGLIB 动态代理的，如果设置了 <code>proxyMode = ScopedProxyMode.TARGET_CLASS</code> 那么 proxyTargetClass 变量就为 true，表示 CGLIB 动态代理，否则就是 JDK 动态代理。</p><p>来继续看 <code>ScopedProxyCreator.createScopedProxy</code> 方法，该方法内部调用到了 <code>ScopedProxyUtils#createScopedProxy</code> 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BeanDefinitionHolder <span class="hljs-title">createScopedProxy</span><span class="hljs-params">(BeanDefinitionHolder definition,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">BeanDefinitionRegistry registry, <span class="hljs-keyword">boolean</span> proxyTargetClass)</span> </span>&#123;</span><br><span class="line">String originalBeanName = definition.getBeanName();</span><br><span class="line">BeanDefinition targetDefinition = definition.getBeanDefinition();</span><br><span class="line">String targetBeanName = getTargetBeanName(originalBeanName);</span><br><span class="line"><span class="hljs-comment">// Create a scoped proxy definition for the original bean name,</span></span><br><span class="line"><span class="hljs-comment">// "hiding" the target bean in an internal target definition.</span></span><br><span class="line">RootBeanDefinition proxyDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition(ScopedProxyFactoryBean.class);</span><br><span class="line">proxyDefinition.setDecoratedDefinition(<span class="hljs-keyword">new</span> BeanDefinitionHolder(targetDefinition, targetBeanName));</span><br><span class="line">proxyDefinition.setOriginatingBeanDefinition(targetDefinition);</span><br><span class="line">proxyDefinition.setSource(definition.getSource());</span><br><span class="line">proxyDefinition.setRole(targetDefinition.getRole());</span><br><span class="line">proxyDefinition.getPropertyValues().add(<span class="hljs-string">"targetBeanName"</span>, targetBeanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">targetDefinition.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line"><span class="hljs-comment">// ScopedProxyFactoryBean's "proxyTargetClass" default is TRUE, so we don't need to set it explicitly here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">proxyDefinition.getPropertyValues().add(<span class="hljs-string">"proxyTargetClass"</span>, Boolean.FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Copy autowire settings from original bean definition.</span></span><br><span class="line">proxyDefinition.setAutowireCandidate(targetDefinition.isAutowireCandidate());</span><br><span class="line">proxyDefinition.setPrimary(targetDefinition.isPrimary());</span><br><span class="line"><span class="hljs-keyword">if</span> (targetDefinition <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition abd) &#123;</span><br><span class="line">proxyDefinition.copyQualifiersFrom(abd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// The target bean should be ignored in favor of the scoped proxy.</span></span><br><span class="line">targetDefinition.setAutowireCandidate(<span class="hljs-keyword">false</span>);</span><br><span class="line">targetDefinition.setPrimary(<span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-comment">// Register the target bean as separate bean in the factory.</span></span><br><span class="line">registry.registerBeanDefinition(targetBeanName, targetDefinition);</span><br><span class="line"><span class="hljs-comment">// Return the scoped proxy definition as primary bean definition</span></span><br><span class="line"><span class="hljs-comment">// (potentially an inner bean).</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanDefinitionHolder(proxyDefinition, originalBeanName, definition.getAliases());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里边的代码其实没啥好解释的，就是创建了一个新的 RootBeanDefinition 对象，变量名就是 proxyDefinition，从这里也能看出来这就是用来创建代理对象的，然后把之前旧的 BeanDefinition 对象的各个属性值都拷贝进去，最后把新的代理的 proxyDefinition 返回。</p><p>这里有一个值得关注的点就是创建 proxyDefinition 的时候，构造方法传入的参数是 ScopedProxyFactoryBean，意思就是这个 BeanDefinition 将来要产生的对象是 ScopedProxyFactoryBean 的对象，那我们继续来看 ScopedProxyFactoryBean，从名字上可以看出来这是一个 FactoryBean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScopedProxyFactoryBean</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProxyConfig</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Object</span>&gt;, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">AopInfrastructureBean</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SimpleBeanTargetSource scopedTargetSource = <span class="hljs-keyword">new</span> SimpleBeanTargetSource();</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> String targetBeanName;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> Object proxy;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ScopedProxyFactoryBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">setProxyTargetClass(<span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.scopedTargetSource.setBeanFactory(beanFactory);</span><br><span class="line">ProxyFactory pf = <span class="hljs-keyword">new</span> ProxyFactory();</span><br><span class="line">pf.copyFrom(<span class="hljs-keyword">this</span>);</span><br><span class="line">pf.setTargetSource(<span class="hljs-keyword">this</span>.scopedTargetSource);</span><br><span class="line">Class&lt;?&gt; beanType = beanFactory.getType(<span class="hljs-keyword">this</span>.targetBeanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (!isProxyTargetClass() || beanType.isInterface() || Modifier.isPrivate(beanType.getModifiers())) &#123;</span><br><span class="line">pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line">ScopedObject scopedObject = <span class="hljs-keyword">new</span> DefaultScopedObject(cbf, <span class="hljs-keyword">this</span>.scopedTargetSource.getTargetBeanName());</span><br><span class="line">pf.addAdvice(<span class="hljs-keyword">new</span> DelegatingIntroductionInterceptor(scopedObject));</span><br><span class="line">pf.addInterface(AopInfrastructureBean.class);</span><br><span class="line"><span class="hljs-keyword">this</span>.proxy = pf.getProxy(cbf.getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.proxy != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.proxy.getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.scopedTargetSource.getTargetClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 getObject 方法返回的就是 proxy 对象，而 proxy 对象是在 setBeanFactory 方法中初始化的（setBeanFactory 方法是在 Bean 初始化之后，属性填充完毕之后触发调用的）。</p><p>setBeanFactory 方法中就是去创建代理对象，设置的 targetSource 就是 scopedTargetSource，这个里边封装了被代理的对象，scopedTargetSource 是一个 SimpleBeanTargetSource 类型的 Bean，SimpleBeanTargetSource 的特点就是每次获取代理对象的时候，都会重新去调用 getTarget 方法，而在 SimpleBeanTargetSource 的 getTarget 方法中就是根据原始的 Bean 名称去 Spring 容器中查找 Bean 并返回，也就是说，在这里代理对象中，被代理的对象实际上就是原始的 Bean，对应上文案例来说，被代理的对象就是 userDao。</p><p>另外一个需要关注的点就是添加的拦截器 DelegatingIntroductionInterceptor 了，这是为代理对象增强的内容（setBeanFactory 方法中其他内容都是常规的 AOP 代码，我就不多说了，不熟悉的小伙伴可以看看松哥最近录制的 Spring 源码视频哦<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>）。</p><p>DelegatingIntroductionInterceptor 拦截器传入了 scopedObject 作为参数，这个参数实际上就表示了被代理的对象，也就是被代理的对象是一个 ScopedObject。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingIntroductionInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IntroductionInfoSupport</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">IntroductionInterceptor</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> Object delegate;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DelegatingIntroductionInterceptor</span><span class="hljs-params">(Object delegate)</span> </span>&#123;</span><br><span class="line">init(delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">DelegatingIntroductionInterceptor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">init(<span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Object delegate)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.delegate = delegate;</span><br><span class="line">implementInterfacesOnObject(delegate);</span><br><span class="line">suppressInterface(IntroductionInterceptor.class);</span><br><span class="line">suppressInterface(DynamicIntroductionAdvice.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isMethodOnIntroducedInterface(mi)) &#123;</span><br><span class="line">Object retVal = AopUtils.invokeJoinpointUsingReflection(<span class="hljs-keyword">this</span>.delegate, mi.getMethod(), mi.getArguments());</span><br><span class="line"><span class="hljs-keyword">if</span> (retVal == <span class="hljs-keyword">this</span>.delegate &amp;&amp; mi <span class="hljs-keyword">instanceof</span> ProxyMethodInvocation pmi) &#123;</span><br><span class="line">Object proxy = pmi.getProxy();</span><br><span class="line"><span class="hljs-keyword">if</span> (mi.getMethod().getReturnType().isInstance(proxy)) &#123;</span><br><span class="line">retVal = proxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> doProceed(mi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doProceed</span><span class="hljs-params">(MethodInvocation mi)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mi.proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DelegatingIntroductionInterceptor 实现了 IntroductionInterceptor 接口，这就是典型的引介增强，这个松哥之前也写过文章专门跟大家讲过：<a href="https://mp.weixin.qq.com/s/opcyaV5iLjYHaJuD9yEMUA" target="_blank" rel="noopener">Spring 中一个少见的引介增强 IntroductionAdvisor</a>，看过之前的文章这里的内容应该都能懂。由于是引介增强，所以最终生成的代理对象，既是 UserDao 的实例，也是 ScopedObject 的实例。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>经过上面的分析，我们可以得出如下几个结论：</p><ol><li>从 UserService 中多次获取到的 UserDao，其实也是 ScopedObject 对象。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">UserService us1 = ctx.getBean(UserService.class);</span><br><span class="line">UserService us2 = ctx.getBean(UserService.class);</span><br><span class="line">UserDao userDao1 = us1.getUserDao();</span><br><span class="line">UserDao userDao2 = us2.getUserDao();</span><br><span class="line">ScopedObject scopedObject1 = (ScopedObject) userDao1;</span><br><span class="line">ScopedObject scopedObject2 = (ScopedObject) userDao2;</span><br><span class="line">System.out.println(<span class="hljs-string">"userDao1 = "</span> + userDao1);</span><br><span class="line">System.out.println(<span class="hljs-string">"userDao2 = "</span> + userDao2);</span><br><span class="line">System.out.println(<span class="hljs-string">"scopedObject1 = "</span> + scopedObject1);</span><br><span class="line">System.out.println(<span class="hljs-string">"scopedObject2 = "</span> + scopedObject2);</span><br></pre></td></tr></table></figure><p>上面这段代码不会报错，这就是引介增强。</p><ol start="2"><li>生成的代理对象本身其实是同一个，因为 UserService 是单例的，毕竟只注入一次 UserDao，但是代理对象中被代理的 Bean 则是会变化的。</li></ol><p>表现出来的现象就是第一点中的四个对象，如果去比较其内存地址，userDao1、userDao2、scopedObject1 以及 scopedObject2 是同一个内存地址，因为是同一个代理对象。</p><p>但是被代理的对象则是不同的。DEBUG 之后大家可以看到，前面四个表示代理对象的地址都是同一个，后面被代理的 UserDao 则是不同的对象。</p><p><img src="http://img.itboyhub.com/2022/08/20230909155803.png" alt></p><p>出现这个现象的原因，就是在 ScopedProxyFactoryBean 的 setBeanFactory 方法中，我们设置的 TargetSource 是一个 SimpleBeanTargetSource，这个 TargetSource 的特点就是每次代理的时候，都会去 Spring 容器中查找 Bean，而由于 UserDao 在 Spring 容器中是多例的，因此 Spring 每次返回的 UserDao 就不是同一个，就实现了 UserDao 的多例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleBeanTargetSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanFactoryBasedTargetSource</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getBeanFactory().getBean(getTargetBeanName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第二点的内容，如果小伙伴们还不理解，可以翻看松哥之前的文章：<a href="https://mp.weixin.qq.com/s/SMqA78Mca7Zhb_CYTc1OJA" target="_blank" rel="noopener">AOP 中被代理的对象是单例的吗？</a>。</p><p>好啦，现在小伙伴们搞明白怎么回事了吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;scope 属性，相信大家都知道，一共有六种：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 接口一个 JSON 字符串用两个对象去接收，这能行吗？</title>
    <link href="http://www.javaboy.org/2023/1010/handler-method-argument-resolver.html"/>
    <id>http://www.javaboy.org/2023/1010/handler-method-argument-resolver.html</id>
    <published>2023-10-10T09:59:35.000Z</published>
    <updated>2024-05-10T10:40:12.767Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>这是最近一个小伙伴的提问，我觉得很有意思，和大伙聊一下。</p><p>小伙伴在工作中遇到类似下面这样一段代码：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/book"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(@RequestBody Book book, @RequestBody Page page)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"book = "</span> + book);</span><br><span class="line">        System.out.println(<span class="hljs-string">"page = "</span> + page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照他的理解，@RequestBody 注解的作用就是把请求体中的值解析为一个对象，一个请求只有一个请求体，请求体中的数据是通过 IO 流读取出来的，IO 有一个特点是读一次就没了。<strong>所以我们在日常开发中，一般接口方法的参数中只存在一个 @RequestBody 注解，不会存在两个该注解。</strong></p><p>但是这个小伙伴在项目中遇到了类似上面的代码，他不理解为什么可以写两个 @RequestBody 注解，今天松哥就来和大家分析一下这问题。</p><h2 id="1-参数解析原理"><a href="#1-参数解析原理" class="headerlink" title="1. 参数解析原理"></a>1. 参数解析原理</h2><h3 id="1-1-参数解析器"><a href="#1-1-参数解析器" class="headerlink" title="1.1 参数解析器"></a>1.1 参数解析器</h3><p>HandlerMethodArgumentResolver 就是我们口口声声说的参数解析器，它的实现类还是蛮多的，因为每一种类型的参数都对应了一个参数解析器：</p><p><img src="http://img.itboyhub.com/2021/02/20210315143417.png" alt></p><p>为了理解方便，我们可以将这些参数解析器分为四大类：</p><ul><li>xxxMethodArgumentResolver：这就是一个普通的参数解析器。</li><li>xxxMethodProcessor：不仅可以当作参数解析器，还可以处理对应类型的返回值。</li><li>xxxAdapter：这种不做参数解析，仅仅用来作为 WebArgumentResolver 类型的参数解析器的适配器。</li><li>HandlerMethodArgumentResolverComposite：这个看名字就知道是一个组合解析器，它是一个代理，具体代理其他干活的那些参数解析器。</li></ul><p>大致上可以分为这四类，其中最重要的当然就是前两种了。</p><h3 id="1-2-参数解析器概览"><a href="#1-2-参数解析器概览" class="headerlink" title="1.2 参数解析器概览"></a>1.2 参数解析器概览</h3><p>接下来我们来先来大概看看这些参数解析器分别都是用来干什么的。</p><p><strong>MapMethodProcessor</strong></p><p>这个用来处理 Map/ModelMap 类型的参数，解析完成后返回 model。</p><p><strong>PathVariableMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@PathVariable</code> 注解并且参数类型不为 Map 的参数，参数类型为 Map 则使用 <code>PathVariableMapMethodArgumentResolver</code> 来处理。</p><p><strong>PathVariableMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>ErrorsMethodArgumentResolver</strong></p><p>这个用来处理 Error 参数，例如我们做参数校验时的 BindingResult。</p><p><strong>AbstractNamedValueMethodArgumentResolver</strong></p><p>这个用来处理 key/value 类型的参数，如请求头参数、使用了 <code>@PathVariable</code> 注解的参数以及 Cookie 等。</p><p><strong>RequestHeaderMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@RequestHeader</code> 注解，并且参数类型不是 Map 的参数（参数类型是 Map 的使用 <code>RequestHeaderMapMethodArgumentResolver</code>）。</p><p><strong>RequestHeaderMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>RequestAttributeMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@RequestAttribute</code> 注解的参数。</p><p><strong>RequestParamMethodArgumentResolver</strong></p><p>这个功能就比较广了。使用了 <code>@RequestParam</code> 注解的参数、文件上传的类型 MultipartFile、或者一些没有使用任何注解的基本类型（Long、Integer）以及 String 等，都使用该参数解析器处理。需要注意的是，如果 <code>@RequestParam</code> 注解的参数类型是 Map，则该注解必须有 name 值，否则解析将由 <code>RequestParamMapMethodArgumentResolver</code> 完成。</p><p><strong>RequestParamMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>AbstractCookieValueMethodArgumentResolver</strong></p><p>这个是一个父类，处理使用了 <code>@CookieValue</code> 注解的参数。</p><p><strong>ServletCookieValueMethodArgumentResolver</strong></p><p>这个处理使用了 <code>@CookieValue</code> 注解的参数。</p><p><strong>MatrixVariableMethodArgumentResolver</strong></p><p>这个处理使用了 <code>@MatrixVariable</code> 注解并且参数类型不是 Map 的参数，如果参数类型是 Map，则使用 <code>MatrixVariableMapMethodArgumentResolver</code> 来处理。</p><p><strong>MatrixVariableMapMethodArgumentResolver</strong></p><p>见上。</p><p><strong>SessionAttributeMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@SessionAttribute</code> 注解的参数。</p><p><strong>ExpressionValueMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@Value</code> 注解的参数。</p><p><strong>ServletResponseMethodArgumentResolver</strong></p><p>这个用来处理 ServletResponse、OutputStream 以及 Writer 类型的参数。</p><p><strong>ModelMethodProcessor</strong></p><p>这个用来处理 Model 类型参数，并返回 model。</p><p><strong>ModelAttributeMethodProcessor</strong></p><p>这个用来处理使用了 <code>@ModelAttribute</code> 注解的参数。</p><p><strong>SessionStatusMethodArgumentResolver</strong></p><p>这个用来处理 SessionStatus 类型的参数。</p><p><strong>PrincipalMethodArgumentResolver</strong></p><p>这个用来处理 Principal 类型参数，这个松哥在前面的文章中和大家介绍过了（<a href>SpringBoot 中如何自定义参数解析器？</a>）。</p><p><strong>AbstractMessageConverterMethodArgumentResolver</strong></p><p>这是一个父类，当使用 HttpMessageConverter 解析 requestbody 类型参数时，相关的处理类都会继承自它。</p><p><strong>RequestPartMethodArgumentResolver</strong></p><p>这个用来处理使用了 <code>@RequestPart</code> 注解、MultipartFile 以及 Part 类型的参数。</p><p><strong>AbstractMessageConverterMethodProcessor</strong></p><p>这是一个工具类，不承担参数解析任务。</p><p><strong>RequestResponseBodyMethodProcessor</strong></p><p>这个用来处理添加了 <code>@RequestBody</code> 注解的参数。</p><p><strong>HttpEntityMethodProcessor</strong></p><p>这个用来处理 HttpEntity 和 RequestEntity 类型的参数。</p><p><strong>ContinuationHandlerMethodArgumentResolver</strong></p><p><strong>AbstractWebArgumentResolverAdapter</strong></p><p>这种不做参数解析，仅仅用来作为 WebArgumentResolver 类型的参数解析器的适配器。</p><p><strong>ServletWebArgumentResolverAdapter</strong></p><p>这个给父类提供 request。</p><p><strong>UriComponentsBuilderMethodArgumentResolver</strong></p><p>这个用来处理 UriComponentsBuilder 类型的参数。</p><p><strong>ServletRequestMethodArgumentResolver</strong></p><p>这个用来处理 WebRequest、ServletRequest、MultipartRequest、HttpSession、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId 类型的参数。</p><p><strong>HandlerMethodArgumentResolverComposite</strong></p><p>这个看名字就知道是一个组合解析器，它是一个代理，具体代理其他干活的那些参数解析器。</p><p><strong>RedirectAttributesMethodArgumentResolver</strong></p><p>这个用来处理 RedirectAttributes 类型的参数，RedirectAttributes 松哥在之前的文章中和大家介绍过：<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>。</p><p>好了，各个参数解析器的大致功能就给大家介绍完了，接下来我们选择其中一种，来具体说说它的源码。</p><h3 id="1-3-AbstractNamedValueMethodArgumentResolver"><a href="#1-3-AbstractNamedValueMethodArgumentResolver" class="headerlink" title="1.3 AbstractNamedValueMethodArgumentResolver"></a>1.3 AbstractNamedValueMethodArgumentResolver</h3><p>AbstractNamedValueMethodArgumentResolver 是一个抽象类，一些键值对类型的参数解析器都是通过继承它实现的，它里边定义了很多这些键值对类型参数解析器的公共操作。</p><p>AbstractNamedValueMethodArgumentResolver 中也是应用了很多模版模式，例如它没有实现 supportsParameter 方法，该方法的具体实现在不同的子类中，resolveArgument 方法它倒是实现了，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);</span><br><span class="line">MethodParameter nestedParameter = parameter.nestedIfOptional();</span><br><span class="line">Object resolvedName = resolveEmbeddedValuesAndExpressions(namedValueInfo.name);</span><br><span class="line"><span class="hljs-keyword">if</span> (resolvedName == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="hljs-string">"Specified name must not resolve to null: ["</span> + namedValueInfo.name + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (namedValueInfo.defaultValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">""</span>.equals(arg) &amp;&amp; namedValueInfo.defaultValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">arg = resolveEmbeddedValuesAndExpressions(namedValueInfo.defaultValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (binderFactory != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, <span class="hljs-keyword">null</span>, namedValueInfo.name);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ConversionNotSupportedException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),</span><br><span class="line">namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),</span><br><span class="line">namedValueInfo.name, parameter, ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Check for null value after conversion of incoming argument value</span></span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span> &amp;&amp; namedValueInfo.defaultValue == <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line">namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) &#123;</span><br><span class="line">handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);</span><br><span class="line"><span class="hljs-keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先根据当前请求获取一个 NamedValueInfo 对象，这个对象中保存了参数的三个属性：参数名、参数是否必须以及参数默认值。具体的获取过程就是先去缓存中拿，缓存中如果有，就直接返回，缓存中如果没有，则调用 createNamedValueInfo 方法去创建，将创建结果缓存起来并返回。createNamedValueInfo 方法是一个模版方法，具体的实现在子类中。</li><li>接下来处理 Optional 类型参数。</li><li>resolveEmbeddedValuesAndExpressions 方法是为了处理注解中使用了 SpEL 表达式的情况，例如如下接口：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello2</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">"$&#123;aa.bb&#125;"</span>)</span> String name) </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数名使用了表达式，那么 resolveEmbeddedValuesAndExpressions 方法的目的就是解析出表达式的值，如果没用到表达式，那么该方法会将原参数原封不动返回。</p><ol start="4"><li>接下来调用 resolveName 方法解析出参数的具体值，这个方法也是一个模版方法，具体的实现在子类中。</li><li>如果获取到的参数值为 null，先去看注解中有没有默认值，然后再去看参数值是否是必须的，如果是，则抛异常出来，否则就设置为 null 即可。</li><li>如果解析出来的参数值为空字符串 <code>&quot;&quot;</code>，则也去 resolveEmbeddedValuesAndExpressions 方法中走一遭。</li><li>最后则是 WebDataBinder 的处理，解决一些全局参数的问题，WebDataBinder 松哥在之前的文章中也有介绍过，传送门：<a href="https://mp.weixin.qq.com/s/Qd0BAUdUtBuBUBmy1G0Z4w" target="_blank" rel="noopener">@ControllerAdvice 的三种使用场景</a>。</li></ol><p>大致的流程就是这样。</p><p>在这个流程中，我们看到主要有如下两个方法是在子类中实现的：</p><ul><li>createNamedValueInfo</li><li>resolveName</li></ul><p>在加上 supportsParameter 方法，子类中一共有三个方法需要我们重点分析。</p><p>那么接下来我们就以 RequestParamMethodArgumentResolver 为例，来看下这三个方法。</p><h3 id="1-4-RequestParamMethodArgumentResolver"><a href="#1-4-RequestParamMethodArgumentResolver" class="headerlink" title="1.4 RequestParamMethodArgumentResolver"></a>1.4 RequestParamMethodArgumentResolver</h3><h4 id="1-4-1-supportsParameter"><a href="#1-4-1-supportsParameter" class="headerlink" title="1.4.1 supportsParameter"></a>1.4.1 supportsParameter</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (parameter.hasParameterAnnotation(RequestParam.class)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) &#123;</span><br><span class="line">RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="hljs-keyword">return</span> (requestParam != <span class="hljs-keyword">null</span> &amp;&amp; StringUtils.hasText(requestParam.name()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (parameter.hasParameterAnnotation(RequestPart.class)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line"><span class="hljs-keyword">if</span> (MultipartResolutionDelegate.isMultipartArgument(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useDefaultResolution) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> BeanUtils.isSimpleProperty(parameter.getNestedParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSimpleProperty</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> isSimpleValueType(type) || (type.isArray() &amp;&amp; isSimpleValueType(type.getComponentType()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSimpleValueType</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (Void.class != type &amp;&amp; <span class="hljs-keyword">void</span>.class != type &amp;&amp;</span><br><span class="line">(ClassUtils.isPrimitiveOrWrapper(type) ||</span><br><span class="line">Enum.class.isAssignableFrom(type) ||</span><br><span class="line">CharSequence.class.isAssignableFrom(type) ||</span><br><span class="line">Number.class.isAssignableFrom(type) ||</span><br><span class="line">Date.class.isAssignableFrom(type) ||</span><br><span class="line">Temporal.class.isAssignableFrom(type) ||</span><br><span class="line">URI.class == type ||</span><br><span class="line">URL.class == type ||</span><br><span class="line">Locale.class == type ||</span><br><span class="line">Class.class == type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 supportsParameter 方法中可以非常方便的看出支持的参数类型：</p><ol><li>首先参数如果有 <code>@RequestParam</code> 注解的话，则分两种情况：参数类型如果是 Map，则 <code>@RequestParam</code> 注解必须配置 name 属性，否则不支持；如果参数类型不是 Map，则直接返回 true，表示总是支持（想想自己平时使用的时候是不是这样）。</li><li>参数如果含有 <code>@RequestPart</code> 注解，则不支持。</li><li>检查下是不是文件上传请求，如果是，返回 true 表示支持。</li><li>如果前面都没能返回，则使用默认的解决方案，判断是不是简单类型，主要就是 Void、枚举、字符串、数字、日期等等。</li></ol><p>这块代码其实很简单，支持谁不支持谁，一目了然。</p><h4 id="1-4-2-createNamedValueInfo"><a href="#1-4-2-createNamedValueInfo" class="headerlink" title="1.4.2 createNamedValueInfo"></a>1.4.2 createNamedValueInfo</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> NamedValueInfo <span class="hljs-title">createNamedValueInfo</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">RequestParam ann = parameter.getParameterAnnotation(RequestParam.class);</span><br><span class="line"><span class="hljs-keyword">return</span> (ann != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> RequestParamNamedValueInfo(ann) : <span class="hljs-keyword">new</span> RequestParamNamedValueInfo());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestParamNamedValueInfo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NamedValueInfo</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestParamNamedValueInfo</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(<span class="hljs-string">""</span>, <span class="hljs-keyword">false</span>, ValueConstants.DEFAULT_NONE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestParamNamedValueInfo</span><span class="hljs-params">(RequestParam annotation)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(annotation.name(), annotation.required(), annotation.defaultValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取注解，读取注解中的属性，构造 RequestParamNamedValueInfo 对象返回。</p><h4 id="1-4-3-resolveName"><a href="#1-4-3-resolveName" class="headerlink" title="1.4.3 resolveName"></a>1.4.3 resolveName</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveName</span><span class="hljs-params">(String name, MethodParameter parameter, NativeWebRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mpArg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object arg = <span class="hljs-keyword">null</span>;</span><br><span class="line">MultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequest != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line"><span class="hljs-keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">arg = (files.size() == <span class="hljs-number">1</span> ? files.get(<span class="hljs-number">0</span>) : files);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String[] paramValues = request.getParameterValues(name);</span><br><span class="line"><span class="hljs-keyword">if</span> (paramValues != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">arg = (paramValues.length == <span class="hljs-number">1</span> ? paramValues[<span class="hljs-number">0</span>] : paramValues);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法思路也比较清晰：</p><ol><li>前面两个 if 主要是为了处理文件上传请求。</li><li>如果不是文件上传请求，则调用 <code>request.getParameterValues</code> 方法取出参数返回即可。</li></ol><p>整个过程还是比较 easy 的。小伙伴们可以在此基础之上自行分析 PathVariableMethodArgumentResolver 的原理，也很容易。</p><h2 id="2-RequestResponseBodyMethodProcessor"><a href="#2-RequestResponseBodyMethodProcessor" class="headerlink" title="2. RequestResponseBodyMethodProcessor"></a>2. RequestResponseBodyMethodProcessor</h2><p>再来看一下和我们今天内容关联度比较大的 RequestResponseBodyMethodProcessor，这个是专门用来处理 JSON 参数的。</p><h3 id="2-1-supportsParameter"><a href="#2-1-supportsParameter" class="headerlink" title="2.1 supportsParameter"></a>2.1 supportsParameter</h3><p>先来看 supportsParameter 方法，这个方法的逻辑很简单，只要方法参数上有 @RequestBody 注解就表示这个参数可以由 RequestResponseBodyMethodProcessor 负责解析。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-resolveArgument"><a href="#2-2-resolveArgument" class="headerlink" title="2.2 resolveArgument"></a>2.2 resolveArgument</h3><p>resolveArgument 方法就是核心的解析方法了，这个方法本身比较长，接下来的内容我仅列出来关键代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line">Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Object <span class="hljs-title">readWithMessageConverters</span><span class="hljs-params">(NativeWebRequest webRequest, MethodParameter parameter,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Type paramType)</span> <span class="hljs-keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">ServletServerHttpRequest inputMessage = <span class="hljs-keyword">new</span> ServletServerHttpRequest(servletRequest);</span><br><span class="line">Object arg = readWithMessageConverters(inputMessage, parameter, paramType);</span><br><span class="line"><span class="hljs-keyword">if</span> (arg == <span class="hljs-keyword">null</span> &amp;&amp; checkRequired(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpMessageNotReadableException(<span class="hljs-string">"Required request body is missing: "</span> +</span><br><span class="line">parameter.getExecutable().toGenericString(), inputMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readWithMessageConverters 方法就是去做参数解析，其实我们从这个方法名字上也能看出来，方法参数的解析是通过 HttpMessageConverter 来完成的。</p><p>在 readWithMessageConverters 方法中，会把当前请求重新包装为一个 ServletServerHttpRequest 对象，将来就从这个新的对象 inputMessage 中读取请求体的内容。</p><p>接下来继续调用一个重载的 readWithMessageConverters 方法进行解析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Object <span class="hljs-title">readWithMessageConverters</span><span class="hljs-params">(HttpInputMessage inputMessage, MethodParameter parameter,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Type targetType)</span> <span class="hljs-keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">message = <span class="hljs-keyword">new</span> EmptyBodyCheckingHttpInputMessage(inputMessage);</span><br><span class="line"><span class="hljs-keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="hljs-keyword">this</span>.messageConverters) &#123;</span><br><span class="line">Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();</span><br><span class="line">GenericHttpMessageConverter&lt;?&gt; genericConverter =</span><br><span class="line">(converter <span class="hljs-keyword">instanceof</span> GenericHttpMessageConverter ghmc ? ghmc : <span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (genericConverter != <span class="hljs-keyword">null</span> ? genericConverter.canRead(targetType, contextClass, contentType) :</span><br><span class="line">(targetClass != <span class="hljs-keyword">null</span> &amp;&amp; converter.canRead(targetClass, contentType))) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (message.hasBody()) &#123;</span><br><span class="line">HttpInputMessage msgToUse =</span><br><span class="line">getAdvice().beforeBodyRead(message, parameter, targetType, converterType);</span><br><span class="line">body = (genericConverter != <span class="hljs-keyword">null</span> ? genericConverter.read(targetType, contextClass, msgToUse) :</span><br><span class="line">((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));</span><br><span class="line">body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">body = getAdvice().handleEmptyBody(<span class="hljs-keyword">null</span>, message, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法核心的部分就是遍历系统中的所有 HttpMessageConverter，然后挨个去检查，看哪个 HttpMessageConverter 可以处理当前参数，如果能够处理（canRead 方法返回 true），那么就去检查当前请求体中是否有内容（message.hasBody），如果有，那么就调用 genericConverter.read 方法进行处理，这个方法内部实际上就是 JSON 的转换逻辑了，常规的 JSON 操作，就和 SpringMVC 没有关系了，我们这里就不展开了。</p><p>那么这里就有一个问题了！</p><p><strong>在处理请求体的时候（genericConverter.read），需要从 message 中通过 IO 流把请求体的内容读取出来。由于 IO 流只能读取一次，所以，对于本文一开始的接口来说，在处理 Book 参数的时候没问题，当 Book 参数处理完毕之后，再去处理 Page 参数的时候就有问题了，因为此时请求体已经空了，没有数据了。</strong></p><p>所以，默认情况下，参数中只能添加一个 @RequestBody 注解，添加多个的话会出错。</p><p>要解决这个问题也很简单，只需要实现请求体中的数据通过 IO 可以重复读取就行了。</p><h2 id="3-请求体重复读取"><a href="#3-请求体重复读取" class="headerlink" title="3. 请求体重复读取"></a>3. 请求体重复读取</h2><p>这里我们可以利用装饰者模式对 HttpServletRequest 的功能进行增强，具体做法也很简单，我们重新定义一个 HttpServletRequest：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RepeatedlyRequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RepeatedlyRequestWrapper</span><span class="hljs-params">(HttpServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(request);</span><br><span class="line">        request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">        body = request.getReader().readLine().getBytes(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> BufferedReader <span class="hljs-title">getReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(getInputStream()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletInputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> ByteArrayInputStream bais = <span class="hljs-keyword">new</span> ByteArrayInputStream(body);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServletInputStream() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> bais.read();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">available</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> body.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFinished</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReady</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReadListener</span><span class="hljs-params">(ReadListener readListener)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码并不难，很好懂。</p><p>首先在构造 RepeatedlyRequestWrapper 的时候，就通过 IO 流将数据读取出来并存入到一个 byte 数组中，然后重写 getReader 和 getInputStream 方法，在这两个读取 IO 流的方法中，都从 byte 数组中返回 IO 流数据出来，这样就实现了反复读取了。</p><p>接下来我们定义一个过滤器，让这个装饰后的 Request 生效：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RepeatableFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        ServletRequest requestWrapper = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (request <span class="hljs-keyword">instanceof</span> HttpServletRequest</span><br><span class="line">                &amp;&amp; StringUtils.startsWithIgnoreCase(request.getContentType(), MediaType.APPLICATION_JSON_VALUE)) &#123;</span><br><span class="line">            requestWrapper = <span class="hljs-keyword">new</span> RepeatedlyRequestWrapper((HttpServletRequest) request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == requestWrapper) &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            chain.doFilter(requestWrapper, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一下，如果请求数据类型是 JSON 的话，就把 HttpServletRequest “偷梁换柱”改为 RepeatedlyRequestWrapper，然后让过滤器继续往下走。</p><p>最后再配置一下这个过滤器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">FilterRegistrationBean&lt;RepeatableFilter&gt; <span class="hljs-title">repeatableFilterBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean&lt;RepeatableFilter&gt; bean = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">    bean.addUrlPatterns(<span class="hljs-string">"/*"</span>);</span><br><span class="line">    bean.setFilter(<span class="hljs-keyword">new</span> RepeatableFilter());</span><br><span class="line">    <span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦大功告成。</p><p>以后，我们的 JSON 数据就可以通过 IO 流反复读取了，现在，在一个接口中，就可以使用多个 @RequestBody 注解了。</p><p><strong>其实一个接口中写多个 @RequestBody 注解不是一个好的设计，大伙在开发中还是要尽量避免，本文仅作技术层面讨论。</strong></p><p>好啦，欢迎学习视频教程的小伙伴多多提问，也给松哥一些写作素材嘿嘿～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;这是最近一个小伙伴的提问，我觉得很有意思，和大伙聊一下。&lt;/p&gt;
&lt;p&gt;小伙伴在工作中遇到类似下面这样一段代码：&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP 中被代理的对象一定是单例吗？</title>
    <link href="http://www.javaboy.org/2023/1008/spring-aop-proxy-obj.html"/>
    <id>http://www.javaboy.org/2023/1008/spring-aop-proxy-obj.html</id>
    <published>2023-10-08T09:59:15.000Z</published>
    <updated>2024-05-10T10:40:29.135Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来思考这样一个问题：在 Spring AOP 中，被代理的对象是单例的吗？当我们每次获取到代理对象的时候，都会重新获取一个新的被代理对象吗？还是被代理的对象始终是同一个？</p><a id="more"></a><p>为什么要思考这个问题，因为在松哥接下来要讲的 @Scope 注解高级用法中涉及到这个知识点。</p><h2 id="1-问题呈现"><a href="#1-问题呈现" class="headerlink" title="1. 问题呈现"></a>1. 问题呈现</h2><p>假设我有如下一个计算器接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后给这个接口提供一个实现类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a + <span class="hljs-string">"+"</span> + b + <span class="hljs-string">"="</span> + (a + b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minus</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设我要生成一个代理对象，利用编程式的方式，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.setTarget(<span class="hljs-keyword">new</span> CalculatorImpl());</span><br><span class="line">proxyFactory.addInterface(ICalculator.class);</span><br><span class="line">proxyFactory.addAdvice(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        System.out.println(name+<span class="hljs-string">" 方法开始执行了。。。"</span>);</span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        System.out.println(name+<span class="hljs-string">" 方法执行结束了。。。"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ICalculator calculator = (ICalculator) proxyFactory.getProxy();</span><br><span class="line">calculator.add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br></pre></td></tr></table></figure><p>这里几个方法应该都好理解：</p><ol><li>setTarget 方法是设置真正的被代理对象。这个在我们之前的 <a href="https://mp.weixin.qq.com/s/GjI4xPGXscCGQtcalwnJKQ" target="_blank" rel="noopener">@Lazy 注解为啥就能破解死循环？</a>一文中大家已经接触过了。</li><li>addInterface，基于 JDK 的动态代理是需要有接口的，这个方法就是设置代理对象的接口。</li><li>addAdvice 方法就是添加增强/通知。</li><li>最后通过 getProxy 方法获取到一个代理对象然后去执行。</li></ol><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230716201918.png" alt></p><p>这是一个简单的 AOP 案例。</p><p>现在我们的问题在于 setTarget 方法上。</p><p>我们点进来到 setTarget 方法上看一下这个方法做了什么：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;</span><br><span class="line">setTargetSource(<span class="hljs-keyword">new</span> SingletonTargetSource(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，setTarget 方法内部调用了 setTargetSource 方法，这个方法设置了一个 SingletonTargetSource 来作为 targetSource，从名字上就能看出来，这个 SingletonTargetSource 是一个单例的 targetSource。</p><p>因此，对于上面的代码，我们可以推断，多个不同的代理对象中持有的相同的被代理对象，例如下面这段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.setTarget(<span class="hljs-keyword">new</span> CalculatorImpl());</span><br><span class="line">proxyFactory.addInterface(ICalculator.class);</span><br><span class="line">proxyFactory.addAdvice(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        System.out.println(name+<span class="hljs-string">" 方法开始执行了。。。"</span>);</span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        System.out.println(name+<span class="hljs-string">" 方法执行结束了。。。"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">ICalculator calculator = (ICalculator) proxyFactory.getProxy();</span><br><span class="line">ICalculator calculator2 = (ICalculator) proxyFactory.getProxy();</span><br><span class="line">calculator2.add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br></pre></td></tr></table></figure><p>我们分别获取了 calculator 和 calculator2 两个代理对象，但是实际上，这两个代理对象中持有的是同一个被代理对象，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20230911100258.png" alt></p><p>从这张图可以看出，代理对象不是同一个，但是被代理对象其实是同一个。</p><h2 id="2-TargetSource"><a href="#2-TargetSource" class="headerlink" title="2. TargetSource"></a>2. TargetSource</h2><p>在 Spring AOP 中，否则处理代理对象的接口是 TargetSource，TargetSource 有诸多实现类，不同实现类具备不同的能力：</p><p><img src="http://img.itboyhub.com/2022/08/TargetSource202309111005.png" alt></p><p>很多实现类单纯从名字上就能看出来其特点了。</p><p>我们先来看下 TargetSource 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TargetSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TargetClassAware</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getTargetClass();</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseTarget</span><span class="hljs-params">(Object target)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口一共是四个方法：</p><ol><li>getTargetClass：这个是返回被代理对象的类型。</li><li>isStatic：这个方法判断被代理对象是否是不变的，也可以理解为返回被代理对象是否是单例的，不过这个方法并不控制单例的实现，这个方法存在意义在于，如果该方法返回 true，表示被代理的对象是单例的，那么将来就不用调用 releaseTarget 方法去释放对象，反之，如果这个方法返回 false，表示被代理的对象不是单例的，那么就需要在使用完被代理的对象之后，调用 releaseTarget 方法将之释放掉。</li><li>getTarget：这个方法就是返回被代理对象。</li><li>releaseTarget：释放被代理的对象。</li></ol><p>TargetSource 的实现类比较多，我们来看几个典型的实现类。</p><h3 id="2-1-SingletonTargetSource"><a href="#2-1-SingletonTargetSource" class="headerlink" title="2.1 SingletonTargetSource"></a>2.1 SingletonTargetSource</h3><p>先来看这个类的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonTargetSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetSource</span>, <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"serial"</span>)</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SingletonTargetSource</span><span class="hljs-params">(Object target)</span> </span>&#123;</span><br><span class="line">Assert.notNull(target, <span class="hljs-string">"Target object must not be null"</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.target.getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// nothing to do</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果被代理的对象是单例的，那么我们就会选择使用 SingletonTargetSource，被代理的对象总是在 getTarget 方法中被调用，然而这个方法返回的总是同一个对象，所以最终被代理的对象就是单例的。</p><p>同时，由于被代理对象是单例的，因此 isStatic 方法返回 true，releaseTarget 中不需要额外操作。</p><h3 id="2-2-SimpleBeanTargetSource"><a href="#2-2-SimpleBeanTargetSource" class="headerlink" title="2.2 SimpleBeanTargetSource"></a>2.2 SimpleBeanTargetSource</h3><p>SimpleBeanTargetSource 比较典型，这个是每当需要的时候，就去 Spring 容器中查找相应的被代理的 Bean，至于这个被代理的 Bean 是否为单例，就由 Spring 容器来控制了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleBeanTargetSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanFactoryBasedTargetSource</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getBeanFactory().getBean(getTargetBeanName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBeanFactoryBasedTargetSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetSource</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> String targetBeanName;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Class&lt;?&gt; targetClass;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTargetBeanName</span><span class="hljs-params">(String targetBeanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.targetBeanName = targetBeanName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTargetBeanName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Assert.state(<span class="hljs-keyword">this</span>.targetBeanName != <span class="hljs-keyword">null</span>, <span class="hljs-string">"Target bean name not set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.targetBeanName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTargetClass</span><span class="hljs-params">(Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.targetClass = targetClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanFactory <span class="hljs-title">getBeanFactory</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Assert.state(<span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span>, <span class="hljs-string">"BeanFactory not set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = <span class="hljs-keyword">this</span>.targetClass;</span><br><span class="line"><span class="hljs-keyword">if</span> (targetClass != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> targetClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">targetClass = <span class="hljs-keyword">this</span>.targetClass;</span><br><span class="line"><span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.beanFactory != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.targetBeanName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">targetClass = <span class="hljs-keyword">this</span>.beanFactory.getType(<span class="hljs-keyword">this</span>.targetBeanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object beanInstance = <span class="hljs-keyword">this</span>.beanFactory.getBean(<span class="hljs-keyword">this</span>.targetBeanName);</span><br><span class="line">targetClass = beanInstance.getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.targetClass = targetClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> targetClass;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseTarget</span><span class="hljs-params">(Object target)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Nothing to do here.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这段源码中大家可以看到，SimpleBeanTargetSource 在使用的时候，需要传入 targetBeanName，也就是被代理的 bean 名称，还需要传入 Spring 容器 BeanFactory，这样，在每次需要被代理对象的时候去调用 getTarget 方法的时候，就直接从容器中查询出来目标 Bean。因此，被代理的对象到底是不是单例，就要看 Spring 容器返回的对象到底是不是单例！</p><p><strong>小伙伴们要记着 SimpleBeanTargetSource 的特点，因为在下一篇文章中，松哥要和大家聊的 @Scope 注解的高级用法，就涉及到这一点了。</strong></p><h3 id="2-3-LazyInitTargetSource"><a href="#2-3-LazyInitTargetSource" class="headerlink" title="2.3 LazyInitTargetSource"></a>2.3 LazyInitTargetSource</h3><p>LazyInitTargetSource 有点类似于 SimpleBeanTargetSource，也是从 Spring 容器中查找被代理的 Bean，不同的是，LazyInitTargetSource 具备延迟初始化的能力，也就是在第一次进行调用的时候才会去获取被代理对象：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyInitTargetSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBeanFactoryBasedTargetSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.target == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.target = getBeanFactory().getBean(getTargetBeanName());</span><br><span class="line">postProcessTargetObject(<span class="hljs-keyword">this</span>.target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessTargetObject</span><span class="hljs-params">(Object targetObject)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，其他的类我就不挨个说了，感兴趣的小伙伴可以自行查看，这一块的源码还是比较好理解的～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来思考这样一个问题：在 Spring AOP 中，被代理的对象是单例的吗？当我们每次获取到代理对象的时候，都会重新获取一个新的被代理对象吗？还是被代理的对象始终是同一个？&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>是谁去读取 BeanDefinition 的？</title>
    <link href="http://www.javaboy.org/2023/0921/spring-load-bean-definition.html"/>
    <id>http://www.javaboy.org/2023/0921/spring-load-bean-definition.html</id>
    <published>2023-09-21T09:58:46.000Z</published>
    <updated>2024-05-10T10:40:25.389Z</updated>
    
    <content type="html"><![CDATA[<p>前面松哥写文章和小伙伴们仔细捋了捋 Spring 中的 BeanDefinition 存在的几种情况，那么 BeanDefinition 是谁来加载呢？如果是 Java 代码配置，那不用说，都是注解扫描去加载 BeanDefinition 的，但是如果是 XML 或者其他格式的配置文件，则有专门的 BeanDefinition 加载器，今天咱们就来看看这个专门的 BeanDefinition 加载器。</p><a id="more"></a><h2 id="1-BeanDefinitionReader"><a href="#1-BeanDefinitionReader" class="headerlink" title="1. BeanDefinitionReader"></a>1. BeanDefinitionReader</h2><p>这是一个接口，从名字上就能看出来专门用来读取 BeanDefinition，接口如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">ResourceLoader <span class="hljs-title">getResourceLoader</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">ClassLoader <span class="hljs-title">getBeanClassLoader</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">BeanNameGenerator <span class="hljs-title">getBeanNameGenerator</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里几个方法我来说一下：</p><ul><li>getRegistry：这个是获取一个 BeanDefinition 的注册器，就是把 BeanDefinition 加载出来之后，我们要将之注册到容器中，所以这里的 BeanDefinitionRegistry 说白了其实就是某一个容器。</li><li>getResourceLoader：这个是获取配置资源的加载器，像我们平时加载 XML 配置文件的时候，只需要写文件名即可，系统会自动去 classpath 下查找文件，就依赖于这里的 ResourceLoader。</li><li>getBeanClassLoader：这个地方就是返回类加载器。</li><li>getBeanNameGenerator：这个是获取 beanName 的生成器，有的时候，我们在 XML 文件中配置的时候，可能没有给 Bean 设置 name 或者 id 属性，那么将会通过这个生成器去生成 beanName，这个松哥在最近录制的 Spring 源码分析视频中已经详细分析过了，这里就不再啰嗦了。</li><li>loadBeanDefinitions：这是四个重载方法，都是根据传入的配置文件，去加载 BeanDefinition。虽然有四个重载方法，真正去加载 BeanDefinition 的方法其实是 <code>loadBeanDefinitions(Resource resource)</code>，另外三个方法兜兜转转最终都会来到这个方法中。</li></ul><h2 id="2-AbstractBeanDefinitionReader"><a href="#2-AbstractBeanDefinitionReader" class="headerlink" title="2. AbstractBeanDefinitionReader"></a>2. AbstractBeanDefinitionReader</h2><p>BeanDefinitionReader 是接口，定义了操作规范，而 AbstractBeanDefinitionReader 为这个接口提供基本的实现。AbstractBeanDefinitionReader 也还有子类，不过 AbstractBeanDefinitionReader 的子类主要是为了处理不同类型的配置文件，如 properties 配置、XML 配置等，其他的通用操作基本上就由 AbstractBeanDefinitionReader 来完成了。</p><p>这个类的源码比较长，我这里就不贴出来了。该类主要解决了 getRegistry、getResourceLoader、getBeanClassLoader 以及 getBeanNameGenerator 方法的返回值，这四个方法的返回值其实都好处理，传入对应的值返回就行了。</p><p>loadBeanDefinitions 由于存在四个重载方法，这个方法的大致处理流程是 <code>loadBeanDefinitions(String... locations)</code> 调用 <code>loadBeanDefinitions(String location)</code>，<code>loadBeanDefinitions(String location)</code> 调用 <code>loadBeanDefinitions(Resource... resources)</code>，<code>loadBeanDefinitions(Resource... resources)</code> 则调用 <code>loadBeanDefinitions(Resource resource)</code>，所以最后的重任都落在 <code>loadBeanDefinitions(Resource resource)</code> 方法上了，另外三个重载方法只是为了处理加载的配置资源而已。而真正干活的 <code>loadBeanDefinitions(Resource resource)</code> 方法在 AbstractBeanDefinitionReader 类中并未重写，这个将来要在各个具体的实现类里边去完成了。</p><h3 id="2-1-PropertiesBeanDefinitionReader"><a href="#2-1-PropertiesBeanDefinitionReader" class="headerlink" title="2.1 PropertiesBeanDefinitionReader"></a>2.1 PropertiesBeanDefinitionReader</h3><p>这个是用来读取 properties 配置文件的，我们平时可能通过 XML 文件来配置 Bean，其实 Spring 里边也支持使用 properties 来配置 Bean，不过 properties 配置起来比较麻烦，所以这个配置目前已经废弃了。</p><h3 id="2-2-XmlBeanDefinitionReader"><a href="#2-2-XmlBeanDefinitionReader" class="headerlink" title="2.2 XmlBeanDefinitionReader"></a>2.2 XmlBeanDefinitionReader</h3><p>这个就是各位小伙伴最熟悉的通过 XML 文件来配置 Bean 了。经过前面的解析，小伙伴们已经知道了 XmlBeanDefinitionReader 是重写了 <code>loadBeanDefinitions(Resource resource)</code> 方法，然后通过这个方法去加载配置文件的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里将传入的 resource 包装为一个 EncodedResource 对象，然后调用另外一个重载方法，EncodedResource 对象主要是处理配置文件的编码问题，防止出现乱码。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">Set&lt;EncodedResource&gt; currentResources = <span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"><span class="hljs-keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="hljs-string">"Detected cyclic loading of "</span> + encodedResource + <span class="hljs-string">" - check your import definitions!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line">InputSource inputSource = <span class="hljs-keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="hljs-keyword">if</span> (encodedResource.getEncoding() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="hljs-string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="hljs-keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前类里边定义了一个 resourcesCurrentlyBeingLoaded 对象，这是一个 ThreadLocal，用来保存当前正在解析的 XML 文件，首先会尝试将当前的要解析的 encodedResource 加入到 currentResources 集合中，如果加不进去，说明当前的 encodedResource 正在处理中，那么就抛出异常。</p><p>否则就去读取 encodedResource 中的内容，并将之转为一个 InputSource，这个 InputSource 是 XML 解析中用到的对象。然后调用 doLoadBeanDefinitions 方法去做进一步的解析。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="hljs-keyword">int</span> count = registerBeanDefinitions(doc, resource);</span><br><span class="line"><span class="hljs-keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先调用 doLoadDocument 将 XML 文件解析为一个 Document 对象。</p><blockquote><p>Document 就是 XML 解析时获取到的文档对象，Document 对象代表了一个 XML 文档的模型树，所有的其他 Node 都以一定的顺序包含在 Document 对象之内，排列成一个树状结构，以后对 XML 文档的所有操作都与解析器无关，直接在这个 Document 对象上进行操作即可。主流的 XML 解析方式有 SAX 解析、DOM 解析以及 Pull 解析。如果大家对于 XML 文件解析不熟悉的话，可以自行复习，松哥这里就不再啰嗦了。</p></blockquote><p>接下来就是调用 registerBeanDefinitions 方法去解析这个 doc 对象，这个方法的返回值就是一共发现了多少个 BeanDefinition。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line"><span class="hljs-keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"><span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里又有了一个新的对象是 BeanDefinitionDocumentReader，这是一个接口，该接口只有一个实现类 DefaultBeanDefinitionDocumentReader，并且这个接口中也只有一个 registerBeanDefinitions 方法，这个方法就是用来解析 Document 对象并注册成为 BeanDefinition 的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.readerContext = readerContext;</span><br><span class="line">doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> </span>&#123;</span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="hljs-keyword">this</span>.delegate;</span><br><span class="line"><span class="hljs-keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="hljs-keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="hljs-keyword">this</span>.delegate);</span><br><span class="line">postProcessXml(root);</span><br><span class="line"><span class="hljs-keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，从 doRegisterBeanDefinitions 方法就开始 XML 解析了，这里首先读取节点的 profile 属性，由于 profile 属性在配置的时候，可以有多个，多个的话用 <code>,</code>、<code>;</code> 或者空格隔开，所以这里拿到 profile 之后，先用 <code>MULTI_VALUE_ATTRIBUTE_DELIMITERS</code> 去做一个字符串拆分（还记得松哥之前讲的 name 属性的配置方式吗？就是那个！），将 profile 属性值拆分为一个数组 specifiedProfiles，然后判断系统当前环境是否包含 profile 中的值，如果不包含，就直接 return，后面的内容就不需要解析了。</p><p>接下来就是 XML 处理了，有预处理和后置处理两个方法，但是这两个目前都是空方法，没有实现。中间的 parseBeanDefinitions 方法是 XML 解析方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element ele) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是遍历 XML 中的所有子节点，遍历然后判断这个子节点是默认标签还是自定义标签，像我们平时写的 <code>import</code>、<code>alias</code>、<code>bean</code>、<code>beans</code> 这些都算是默认标签，而像导入 properties 的 <code>&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</code> 这种标签就属于自定义标签。</p><p>我们先来看默认标签的解析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="hljs-comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到，根据不同的节点类型，调用不同的解析方法。如果节点是 beans，beans 中还是定义 bean 的，所以对于 beans 标签递归调用 doRegisterBeanDefinitions 方法进行解析。</p><p>咱们看一个比较常见的 bean 标签解析吧，其他标签解析也都差不多：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"><span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Register the final decorated instance.</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="hljs-string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.getBeanName() + <span class="hljs-string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Send registration event.</span></span><br><span class="line">getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法做了三件事：</p><ol><li>首先调用 <code>delegate.parseBeanDefinitionElement</code> 方法去解析 Element，解析 XML 标签中的各种属性值，解析完成之后，将属性值填充到 BeanDefinition 对象中并返回，这里创建的 BeanDefinition 类型就是 GenericBeanDefinition 类型的。</li><li><code>delegate.decorateBeanDefinitionIfRequired</code> 方法去检查当前 Bean 的各种属性是否需要装饰。什么样的情况需要装饰呢？这个主要是针对一些比较特殊的属性，例如我们之前讲 Bean 的属性注入的时候，有一种叫做 p namespace 的属性注入，就是在标签中添加 <code>p:username=&#39;javaboy&#39;</code> 来实现属性值的注入，那么这种属性就需要特殊处理，这个方法就是用来解决这一类问题的。</li><li>调用 <code>BeanDefinitionReaderUtils.registerBeanDefinition</code> 方法完成 BeanDefinition 的注册，注册到一个 Map 集合中，集合的 key 就是 beanName，集合的 value 则是 BeanDefinition 对象。</li></ol><p>好啦，这就是 XmlBeanDefinitionReader 中的一个大致流程。</p><h3 id="2-3-GroovyBeanDefinitionReader"><a href="#2-3-GroovyBeanDefinitionReader" class="headerlink" title="2.3 GroovyBeanDefinitionReader"></a>2.3 GroovyBeanDefinitionReader</h3><p>这个是使用 groovy 脚本配置 Bean，groovy 我们这里就不展开了。</p><p>今天就主要和小伙伴们介绍了 Spring 中 XML 文件的加载规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面松哥写文章和小伙伴们仔细捋了捋 Spring 中的 BeanDefinition 存在的几种情况，那么 BeanDefinition 是谁来加载呢？如果是 Java 代码配置，那不用说，都是注解扫描去加载 BeanDefinition 的，但是如果是 XML 或者其他格式的配置文件，则有专门的 BeanDefinition 加载器，今天咱们就来看看这个专门的 BeanDefinition 加载器。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>简单把 Spring 容器分为了两大类！</title>
    <link href="http://www.javaboy.org/2023/0919/spring-container-category.html"/>
    <id>http://www.javaboy.org/2023/0919/spring-container-category.html</id>
    <published>2023-09-19T09:58:32.000Z</published>
    <updated>2024-05-10T10:40:21.741Z</updated>
    
    <content type="html"><![CDATA[<p>这个问题松哥想了很久要怎么和大家展开介绍，最早我是想整一篇文章把 Spring 容器整个从头到尾捋一遍，但是，东西太多显然不现实，我还是倾向于通过不同的文章，从不同的角度来介绍 Spring 容器的一些使用细节，最后再将整体串通起来～</p><a id="more"></a><p>因此，今天我想先和大家聊一个小的话题，就是我们先来捋一捋 Spring 中真正干活的容器到底是哪个？</p><p>说到 Spring 容器，我们很容易想到 BeanFactory，大家很容易拿到这张图：</p><p><img src="http://img.itboyhub.com/2022/08/BeanFactory202308280004.png" alt></p><p>这张图大致上一看，有七八个能干活的容器，难道 Spring 中真的有这么多种不同的容器吗？那我们不妨想一想，容器的核心职责是什么？我们是否真的需要这么多容器？</p><p>其实，Spring 中，跟 Bean 最核心的功能相关的容器，只有三个！接下来我们来分析一下。</p><h2 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a>1. BeanFactory</h2><p>BeanFactory 是所有容器的根，它里边提供了规范了最基本的容器方法和判断方法，例如如下一些方法：</p><ol><li>getBean(String name)：根据给定的 Bean 名称获取对应的实例对象。此方法允许通过名称检索 Bean，如果找到匹配的 Bean，则返回该 Bean 的实例。</li><li>getBean(String name, Class<t> requiredType)：根据给定的 Bean 名称和类型获取对应的实例对象。此方法允许通过名称和类型检索 Bean，如果找到匹配的 Bean，则返回该 Bean 的实例。</t></li><li>getBean(Class<t> requiredType)：根据给定的类型获取对应的实例对象。此方法允许通过类型检索 Bean，如果找到匹配的 Bean，则返回该 Bean 的实例。</t></li><li>getBean(Class<t>, Object…)：根据给定类型返回对应的实例对象，第二个参数是在构造给定的实例时构造方法所使用的参数。</t></li><li>getBean(String, Object…)：这个跟上一个方法类似，区别在于第一个参数传入的是 Bean 名称。</li><li>getBeanProvider(Class<t>)：这个的作用是获取一个用于访问和管理 Bean 的提供者（BeanProvider）。BeanProvider 是一个泛型接口，它提供了一种延迟加载和按需获取 Bean 的机制。通过 getBeanProvider 方法，可以获取一个 BeanProvider 对象，然后可以使用该对象来获取特定类型的 Bean 实例。BeanProvider 具有延迟加载、按需获取以及安全访问等功能，这是 Spring5.1 刚刚推出的方法，所以大家目前来说应该见到的并不多。</t></li><li>getBeanProvider(ResolvableType)：这个等同于上面的方法，只不过传入的参数类型有差别。</li><li>getType(String name)：获取指定名称的 Bean 的类型。如果找到匹配的 Bean，则返回 Bean 的类型；如果找不到匹配的 Bean，则返回 null。</li><li>getType(String, boolean)：这个作用也是等价于上面这个方法，不同的是，多了一个 boolean 类型的参数，表示在获取类型的时候，是否提前将 FactoryBean 初始化，在之前的文章<a href="https://mp.weixin.qq.com/s/zVtedq-kwlhqeQB7GZz6Qw" target="_blank" rel="noopener">FactoryBean 和它的兄弟SmartFactoryBean！</a>中松哥和大家聊了 FactoryBean 具备天然的延迟加载特性，这个方法也是 Spring5.2 开始才有的。</li><li>containsBean(String name)：检查容器中是否包含指定名称的 Bean。如果容器中存在具有给定名称的 Bean，则返回 true，否则返回 false。</li><li>isSingleton(String name)：检查指定名称的 Bean 是否为单例。如果指定名称的 Bean 是单例，则返回 true，否则返回 false。</li><li>isPrototype(String name)：检查指定名称的 Bean 是否为原型。如果指定名称的 Bean 是原型，则返回 true，否则返回 false。</li><li>getAliases(String name)：获取给定名称的 Bean 的所有别名。如果存在别名，则返回别名的数组；如果不存在别名，则返回空数组。</li><li>isTypeMatch(String,ResolvableType)：这个方法是判断给定的 Bean 名称是否和给定的类型相匹配。</li><li>isTypeMatch(String,Class&lt;?&gt;)：作用等价于上面这个方法。</li></ol><p>BeanFactory 中常见的方法主要就是这些。这也是容器操作中最最核心的方法。</p><p>在本文一开始的类继承图中，BeanFactory 有很多实现类，那么是哪些实现类实现了上面这些方法呢？其实只有三个，分别是：</p><ul><li>DefaultListableBeanFactory</li><li>StaticListableBeanFactory</li><li>SimpleJndiBeanFactory</li></ul><p>别看实现类很多，但是其实干活的就是这三个。</p><h3 id="1-1-DefaultListableBeanFactory"><a href="#1-1-DefaultListableBeanFactory" class="headerlink" title="1.1 DefaultListableBeanFactory"></a>1.1 DefaultListableBeanFactory</h3><p>DefaultListableBeanFactory 是 Spring 框架中最常用的 bean 工厂之一。它是 BeanFactory 接口的一个实现类，同时也是 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 接口的实现类。DefaultListableBeanFactory 提供了丰富的功能来管理和访问 bean。</p><p>DefaultListableBeanFactory 的主要特点和功能包括：</p><ol><li>Bean 定义的注册和获取：DefaultListableBeanFactory 可以通过注册 BeanDefinition 对象来定义和配置 Bean。它提供了方法来注册、获取和移除 Bean 的定义。这使得我们可以在运行时动态地添加、修改和删除 Bean。</li><li>Bean 的实例化和获取：DefaultListableBeanFactory 负责实例化和管理 Bean 的生命周期。它可以根据 Bean 的定义创建 Bean 的实例，并提供方法来获取 Bean 的实例。它支持单例、原型和其他作用域的 Bean。</li><li>依赖注入：DefaultListableBeanFactory 支持自动装配和显式依赖注入。它可以解析 Bean 之间的依赖关系，并在需要时自动注入依赖。它支持构造函数注入、属性注入和方法注入。</li><li>AOP 支持：DefaultListableBeanFactory 支持面向切面编程 (AOP)。它可以通过配置切面和通知，实现横切关注点的模块化。</li><li>Bean 生命周期管理：DefaultListableBeanFactory 提供了对 Bean 生命周期的管理。它可以在 Bean 初始化之前和销毁之后执行相应的回调方法。</li><li>Bean 列表和查询：DefaultListableBeanFactory 实现了 ListableBeanFactory 接口，提供了一系列方法来获取 Bean 的列表信息。它支持按名称、类型和条件进行 Bean 的查询和获取。</li></ol><p>总的来说，DefaultListableBeanFactory 是 Spring 框架中最常用的 Bean 工厂，它提供了丰富的功能来定义、配置、管理和访问 Bean，它的功能最完整也最成熟。它是实现依赖注入和控制反转 (IoC) 的核心组件之一。</p><p>我们平时开发用的各种“容器”其实都是 DefaultListableBeanFactory。</p><p>例如在松哥之前和大家讲的基本用法中，我们常用的两个类分别是 ClassPathXmlApplicationContext 和 AnnotationConfigApplicationContext，这两个底层使用的容器其实就是 DefaultListableBeanFactory。</p><h3 id="1-2-StaticListableBeanFactory"><a href="#1-2-StaticListableBeanFactory" class="headerlink" title="1.2 StaticListableBeanFactory"></a>1.2 StaticListableBeanFactory</h3><p>StaticListableBeanFactory 这个容器我们其实很少用到，但是这里大家也了解一下。</p><p>这个容器从名字上就能看出其特点：静态。不错，这是一个静态容器，它里边定义了一个 Map 集合，当你想要存储一个 Bean 的时候，它就给你存到这个 Map 集合中，当你想要获取一个 Bean 的时候，它就给你从这个 Map 集合中读取出来。</p><p>StaticListableBeanFactory 的主要特点和功能包括：</p><ol><li>静态：StaticListableBeanFactory 在初始化时加载所有的 Bean 定义，并在运行时保持不变。这意味着它不支持在运行时动态修改或删除 Bean，适用于那些不需要动态修改 Bean 的场景，动态添加新的 Bean 是可以的。</li><li>列表化：StaticListableBeanFactory 实现了 ListableBeanFactory 接口，提供了一系列方法来获取 Bean 的列表信息。它可以通过名称、类型、注解等方式来获取 Bean，还支持按条件过滤和排序。</li><li>高效访问：由于所有的 Bean 定义在初始化时就加载完成，StaticListableBeanFactory 提供了高效访问 Bean 的能力。它不需要在运行时进行 Bean 的查找和创建，从而提供了更快的性能。</li><li>配置方式：StaticListableBeanFactory 可以通过配置文件或编程方式进行配置。它支持使用 XML、注解或 Java 配置类来定义和配置 Bean。</li></ol><p>总的来说，StaticListableBeanFactory 提供了一种静态且列表化的方式来管理和访问 Bean。它适用于那些在运行时不需要动态修改 Bean 的应用场景，并且提供了方便的方法来获取和操作 Bean 的列表信息。</p><h3 id="1-3-SimpleJndiBeanFactory"><a href="#1-3-SimpleJndiBeanFactory" class="headerlink" title="1.3 SimpleJndiBeanFactory"></a>1.3 SimpleJndiBeanFactory</h3><p>SimpleJndiBeanFactory 是 Spring 框架中的一个类，它是 BeanFactory 接口的一个实现类。SimpleJndiBeanFactory 使用简单的 JNDI (Java Naming and Directory Interface) 技术来管理和访问 Bean。</p><p>JNDI 是 Java 平台提供的一种标准 API，用于访问命名和目录服务。</p><p>SimpleJndiBeanFactory 利用 JNDI 的功能，可以从 JNDI 中查找和获取 Bean，以及执行与 JNDI 相关的操作。</p><p>SimpleJndiBeanFactory 的主要特点和功能包括：</p><ol><li>JNDI 支持：SimpleJndiBeanFactory 支持使用 JNDI 技术来管理和访问 Bean。它可以从 JNDI 中查找和获取 Bean，以及执行与 JNDI 相关的操作，如绑定、解绑等。</li><li>简单易用：SimpleJndiBeanFactory 提供了一种简单易用的方式来访问 JNDI 中的 Bean。它封装了 JNDI API 的复杂性，提供了更简洁的接口和方法。</li><li>配置方式：SimpleJndiBeanFactory 可以通过配置文件或编程方式进行配置。它支持使用简单的 properties 文件来配置 JNDI 上下文和 Bean 的绑定关系。</li><li>跨平台性：由于 JNDI 是 Java 平台的标准 API，SimpleJndiBeanFactory 具有良好的跨平台性，可以在不同的 Java 环境中使用。</li></ol><p>老实说，这个 SimpleJndiBeanFactory 最大的特点就是利用了 JNDI 技术，然而，我们平时开发实际上很少会用到 JNDI 技术，所以这个容器其实用的并不多。</p><p>Spring 中的基础容器就这三个，其中被大量使用的是第一个 DefaultListableBeanFactory。</p><h2 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2. ApplicationContext"></a>2. ApplicationContext</h2><p>如果前面所说的三个容器（BeanFactory）是一个发动机，那么 ApplicationContext 就是一辆汽车，回顾本文一开始的类结构图，其实除了前面三个 BeanFactory 之外，其他的都算是 ApplicationContext 了。</p><p>BeanFactory 提供了 Bean 的核心功能，但是依然缺乏很多东西，例如配置文件要怎么加载？带注解的类谁去扫描？国际化怎么实现？事件的处理等等。。。这些功能上面三个核心类都没有！那么谁有呢？那就是 ApplicationContext 有。另外，Spring 中许多通过 BeanPostProcessor 实现的功能，通过 BeanFactory 也无法实现，因为直接使用 BeanFactory 并不会触发 BeanPostProcessor，如果非要使用，得自己手动去触发这些后置处理器的执行。</p><p>ApplicationContext 并非一个全新的容器，本质上，它里边使用的是 DefaultListableBeanFactory 容器，只不过在该容器的基础上继续增强了许多功能。</p><p>在 ApplicationContext 中，容器的初始化都是从 refresh 方法开始，该方法会调用 obtainFreshBeanFactory 方法去获取一个 ConfigurableListableBeanFactory 类型的容器，问题是 ConfigurableListableBeanFactory 只有一个实现类，那就是 DefaultListableBeanFactory，所以我们说，在 ApplicationContext 中使用的都是 DefaultListableBeanFactory 容器。</p><p>因此，在具体实践中，如果能够使用 ApplicationContext，就尽量不要直接使用 DefaultListableBeanFactory 或者其他容器，除非你想完全控制容器的运行。</p><p>下面这张表格列出来了 BeanFactory 和 ApplicationContext 之间的一些差别。</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">BeanFactory</th><th style="text-align:left">ApplicationContext</th></tr></thead><tbody><tr><td style="text-align:center">Bean 的实例化/注入</td><td style="text-align:center">支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:center">Bean 生命周期管理</td><td style="text-align:center">不支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:center">自动触发 BeanPostProcessor</td><td style="text-align:center">不支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:center">自动触发 BeanFactoryPostProcessor</td><td style="text-align:center">不支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:center">国际化（I18N）</td><td style="text-align:center">不支持</td><td style="text-align:left">支持</td></tr><tr><td style="text-align:center">内置 ApplicationEvent 发布机制</td><td style="text-align:center">不支持</td><td style="text-align:left">支持</td></tr></tbody></table><p>好啦，这样梳理一下，容器应该就好理解很多了，接下来的文章松哥会通过具体的案例，来和小伙伴们演示不同 BeanFactory 以及 ApplicationContext 的用法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个问题松哥想了很久要怎么和大家展开介绍，最早我是想整一篇文章把 Spring 容器整个从头到尾捋一遍，但是，东西太多显然不现实，我还是倾向于通过不同的文章，从不同的角度来介绍 Spring 容器的一些使用细节，最后再将整体串通起来～&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring BeanFactoryPostProcessor 的作用时机详解</title>
    <link href="http://www.javaboy.org/2023/0914/spring-bean-factory-post-processor.html"/>
    <id>http://www.javaboy.org/2023/0914/spring-bean-factory-post-processor.html</id>
    <published>2023-09-14T09:58:15.000Z</published>
    <updated>2024-05-10T10:40:18.286Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章中，松哥已经和大家分享了 BeanPostProcessor 和 BeanFactoryPostProcessor 的基本用法以及差别，但是没有去分析其原理，今天我们就来聊一聊这两个后置处理器的工作原理。</p><a id="more"></a><p>基本用法我这里就不罗嗦了，不熟悉的小伙伴可以参考之前的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZjN1XPamDaYZmvFbyI1KTQ" target="_blank" rel="noopener">BeanFactoryPostProcessor 和 BeanPostProcessor 有什么区别？</a></li></ul><p>原理我打算从两个方面来讲，第一方面就是在容器初始化的时候，将系统中存在的 BeanFactoryPostProcessor 和 BeanPostProcessor 收集起来，第二步则是在适当的时机去应用对应的处理器，我们分别来。</p><h2 id="1-收集后置处理器"><a href="#1-收集后置处理器" class="headerlink" title="1. 收集后置处理器"></a>1. 收集后置处理器</h2><p>收集后置处理器就是在项目启动的时候，将项目中的后置处理器都收集起来，将来在某一个时间点去使用。</p><p>小伙伴们知道，我们平时开发基本上都是使用的 ApplicationContext 容器，那么容器的初始化基本上就是从 refresh 方法开始的。</p><p>在 refresh 方法中，会调用到 invokeBeanFactoryPostProcessors 方法，这个方法看名字就是调用所有的 BeanFactoryPostProcessor 的，我们来看下这个方法的具体内容：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"><span class="hljs-comment">//省略其他</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry registry) &#123;</span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor registryProcessor) &#123;</span><br><span class="line">registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">registryProcessors.add(registryProcessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">regularPostProcessors.add(postProcessor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line"><span class="hljs-keyword">boolean</span> reiterate = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">while</span> (reiterate) &#123;</span><br><span class="line">reiterate = <span class="hljs-keyword">false</span>;</span><br><span class="line">postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">processedBeans.add(ppName);</span><br><span class="line">reiterate = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());</span><br><span class="line">currentRegistryProcessors.clear();</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">String[] postProcessorNames =</span><br><span class="line">beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"></span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">&#125;</span><br><span class="line">invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line">beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看第一个 invokeBeanFactoryPostProcessors 方法，这个虽然在调用代理的 invokeBeanFactoryPostProcessors 方法时传入了一个 BeanFactoryPostProcessor 集合，但是一般情况下，这个集合是空的，所以真正需要处理的 BeanFactoryPostProcessor 都是在下面的方法中现场查询出来的。</p><p>那么核心的逻辑就处于第二个方法之中了。第二个方法特别长，但是逻辑其实并不难懂。</p><blockquote><p>不过在看第二个方法之前，需要大家先了解一个前置知识，即 BeanFactoryPostProcessor 有一个名为 BeanDefinitionRegistryPostProcessor 的子类，BeanDefinitionRegistryPostProcessor 是 Spring 框架中的一个接口，它的作用是在应用程序上下文启动时，对 BeanDefinitionRegistry 进行后置处理。具体来说，BeanDefinitionRegistryPostProcessor 可以用于修改或扩展应用程序上下文中的 BeanDefinition，即在 Bean 实例化之前对 BeanDefinition 进行修改。它可以添加、删除或修改 BeanDefinition 的属性，甚至可以动态地注册新的 BeanDefinition。通过实现 BeanDefinitionRegistryPostProcessor 接口，我们可以在 Spring 容器启动过程中干预 Bean 的定义，以满足特定的需求。这使得我们可以在应用程序上下文加载之前对 Bean 进行一些自定义的操作，例如动态注册 Bean 或者修改 Bean 的属性。<strong>需要注意的是，BeanDefinitionRegistryPostProcessor 在 BeanFactoryPostProcessor 之前被调用，因此它可以影响到 BeanFactoryPostProcessor 的行为。</strong></p></blockquote><p>有了这个前置知识，那么再去理解上面的代码就容易多了，上面在处理的过程中，会先判断是不是 BeanDefinitionRegistryPostProcessor 类型的后置处理器，如果是，就先解决这个问题，把所有的 BeanDefinitionRegistryPostProcessor 类型的后置处理器都处理完毕，才会处理 BeanFactoryPostProcessor。</p><blockquote><p>悄悄告诉大家，其实 BeanDefinitionRegistryPostProcessor 只有一个实现类，这个实现类用来处理 @Configuration 注解，相关内容松哥之前已经发了<a href="https://mp.weixin.qq.com/s/D84pWlXs7wbHFYvCE5TAVQ" target="_blank" rel="noopener">一道经典面试题：@Configuration 和 @Component 有何区别？</a>。</p></blockquote><p>再回到 invokeBeanFactoryPostProcessors 方法，我们看到，方法首先定义了 processedBeans 变量，这个变量用来记录所有已经处理过的后置处理器。</p><p>接下来会去判断容器的类型是否为 BeanDefinitionRegistry，只有是 BeanDefinitionRegistry 类型的容器，BeanDefinitionRegistryPostProcessor 才能被处理。如果容器是 BeanDefinitionRegistry 类型，那么就声明两个变量，分别是 regularPostProcessors 和 registryProcessors，其中，前者用来保存 BeanFactoryPostProcessor 类型的后置处理器，后者用来保存 BeanDefinitionRegistryPostProcessor 类型的处理器。</p><p>接下来就对传入的集合进行遍历，判断是否为 BeanDefinitionRegistryPostProcessor 类型的后置处理器，如果是，则直接调用 <code>registryProcessor.postProcessBeanDefinitionRegistry(registry);</code> 方法去执行后置处理器，然后将后置处理器存入到 registryProcessors 集合中（以便于将来执行其 postProcessBeanFactory 方法）；如果不是 BeanDefinitionRegistryPostProcessor 类型的后置处理器，那么就先将后置处理器存入到 regularPostProcessors 集合中（以便于将来执行其 postProcessBeanFactory 方法），后续统一调用。由于 BeanDefinitionRegistryPostProcessor 继承自 BeanFactoryPostProcessor，所以对于 BeanDefinitionRegistryPostProcessor 类型的处理器，不仅有来自 BeanFactoryPostProcessor 的 postProcessBeanFactory 方法，还有它自身的 postProcessBeanDefinitionRegistry 方法。后续代码的整体处理思路是遇到 postProcessBeanDefinitionRegistry 方法就先执行，然后把 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor 都有的 postProcessBeanFactory 方法放到最后统一执行，前面说的 regularPostProcessors 和 registryProcessors 两个变量就是干这个事情的。</p><p>接下来从 Spring 容器中查找所有的 BeanDefinitionRegistryPostProcessor，找到之后，如果这些 BeanDefinitionRegistryPostProcessor 实现了 PriorityOrdered 接口，则将之收集到 currentRegistryProcessors 集合中，同时也记录到 processedBeans 集合中，接下来对 currentRegistryProcessors 集合按照 PriorityOrdered 接口及逆行排序，并将排序后的结果存入到 registryProcessors 中（以便于将来执行其 postProcessBeanFactory 方法），然后执行 invokeBeanDefinitionRegistryPostProcessors 方法，该方法最终就会触发 postProcessBeanDefinitionRegistry。</p><p>接下来的一段代码和上面的逻辑类似，只不过这次是处理实现了 Ordered 接口的 BeanDefinitionRegistryPostProcessor。</p><p>带排序功能的 BeanDefinitionRegistryPostProcessor 处理完成后，接下来就是处理哪些不带有排序功能的 BeanDefinitionRegistryPostProcessor，也就是 while 循环中的内容了。</p><p>当所有的 BeanDefinitionRegistryPostProcessor 都处理完成之后，接下来调用 invokeBeanFactoryPostProcessors 方法去处理 regularPostProcessors 和 registryProcessors 集合中的对象，最终都是执行 postProcessBeanFactory 方法。</p><p>BeanDefinitionRegistryPostProcessor 的处理到此结束，接下来就是 BeanFactoryPostProcessor 的处理了。</p><p>首先去 Spring 容器中查找所有的 BeanFactoryPostProcessor，并将查询结果保存在 postProcessorNames 变量中，接下来声明了三个变量：</p><ul><li>priorityOrderedPostProcessors：这个集合用来保存实现了 PriorityOrdered 接口的 BeanFactoryPostProcessor。</li><li>orderedPostProcessorNames：这个集合用来保存实现了 Ordered 接口的 BeanFactoryPostProcessor。</li><li>nonOrderedPostProcessorNames：这个集合用来保存不具备排序能力的 BeanFactoryPostProcessor。</li></ul><p>一共就这三个集合，接下来遍历 postProcessorNames，给这三个集合填充数据，填充的时候，判断一下 bean 是否已经存在于 processedBeans 集合中，如果存在，就不用处理了。</p><p>最后，该排序的排序，排完序之后，调用 invokeBeanFactoryPostProcessors 方法继续处理即可。</p><h2 id="2-应用后置处理器"><a href="#2-应用后置处理器" class="headerlink" title="2. 应用后置处理器"></a>2. 应用后置处理器</h2><p>上面涉及到后置处理器应用的主要是两个方法，分别是：</p><ul><li>invokeBeanDefinitionRegistryPostProcessors</li><li>invokeBeanFactoryPostProcessors</li></ul><p>这两个方法的逻辑都比较简单，就一起看了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanDefinitionRegistryPostProcessors</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">StartupStep postProcessBeanDefRegistry = applicationStartup.start(<span class="hljs-string">"spring.context.beandef-registry.post-process"</span>)</span><br><span class="line">.tag(<span class="hljs-string">"postProcessor"</span>, postProcessor::toString);</span><br><span class="line">postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">postProcessBeanDefRegistry.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">StartupStep postProcessBeanFactory = beanFactory.getApplicationStartup().start(<span class="hljs-string">"spring.context.bean-factory.post-process"</span>)</span><br><span class="line">.tag(<span class="hljs-string">"postProcessor"</span>, postProcessor::toString);</span><br><span class="line">postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">postProcessBeanFactory.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是遍历，然后执行目标方法。</p><h2 id="3-具体应用"><a href="#3-具体应用" class="headerlink" title="3. 具体应用"></a>3. 具体应用</h2><h3 id="3-1-ConfigurationClassPostProcessor"><a href="#3-1-ConfigurationClassPostProcessor" class="headerlink" title="3.1 ConfigurationClassPostProcessor"></a>3.1 ConfigurationClassPostProcessor</h3><p>这个类就是 BeanDefinitionRegistryPostProcessor 的一种，它的作用是用来处理 @Configuration 注解的 Full 模式和 Lite 模式。这个松哥在之前的文章中已经详细介绍过了，感兴趣的小伙伴可以参考这里：<a href="https://mp.weixin.qq.com/s/D84pWlXs7wbHFYvCE5TAVQ" target="_blank" rel="noopener">一道经典面试题：@Configuration 和 @Component 有何区别？</a>。</p><h3 id="3-2-Properties-文件处理"><a href="#3-2-Properties-文件处理" class="headerlink" title="3.2 Properties 文件处理"></a>3.2 Properties 文件处理</h3><p>Properties 文件处理也是通过 BeanFactoryPostProcessor 来实现的。</p><p>当我们在 Spring 容器中配置数据源的时候，一般都是按照下面这样的方式进行配置的。</p><p>首先创建 db.properties，将数据源各种信息写入进去：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.username=root</span><br><span class="line">db.password=123</span><br><span class="line">db.url=jdbc:mysql:///db01?serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><p>然后在 Spring 的配置文件中，首先把这个配置文件加载进来，然后就可以在 Spring Bean 中去使用对应的值了，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是大家知道，对于 DruidDataSource 来说，毫无疑问，它要的是具体的 username、password 以及 url，而上面的配置很明显中间还有一个转换的过程，即把 <code>${db.username}</code>、<code>${db.password}</code> 以及 <code>${db.url}</code> 转为具体对应的值。那么这个转换是怎么实现的呢？</p><p>这就得分析 <code>&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</code> 配置了，小伙伴们知道，这个配置实际上是一个简化的配置，点击去可以看到真正配置的 Bean 是 <code>PropertySourcesPlaceholderConfigurer</code>，而 <code>PropertySourcesPlaceholderConfigurer</code> 恰好就是 <code>BeanFactoryPostProcessor</code> 的子类，我们来看下这里是如何重写 postProcessBeanFactory 方法的：</p><p>源码比较长，松哥这里把一些关键部分列出来和小伙伴们展示：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertySources == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">//这里主要是如果没有加载到 properties 文件，就会尝试从环境中加载</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//这个就是具体的属性转换的方法了</span></span><br><span class="line">processProperties(beanFactory, <span class="hljs-keyword">new</span> PropertySourcesPropertyResolver(<span class="hljs-keyword">this</span>.propertySources));</span><br><span class="line"><span class="hljs-keyword">this</span>.appliedPropertySources = <span class="hljs-keyword">this</span>.propertySources;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 这个属性转换方法中，对配置文件又做了一些预处理，最后调用 doProcessProperties 方法处理属性</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processProperties</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactoryToProcess,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span> ConfigurablePropertyResolver propertyResolver)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">propertyResolver.setPlaceholderPrefix(<span class="hljs-keyword">this</span>.placeholderPrefix);</span><br><span class="line">propertyResolver.setPlaceholderSuffix(<span class="hljs-keyword">this</span>.placeholderSuffix);</span><br><span class="line">propertyResolver.setValueSeparator(<span class="hljs-keyword">this</span>.valueSeparator);</span><br><span class="line">StringValueResolver valueResolver = strVal -&gt; &#123;</span><br><span class="line">String resolved = (<span class="hljs-keyword">this</span>.ignoreUnresolvablePlaceholders ?</span><br><span class="line">propertyResolver.resolvePlaceholders(strVal) :</span><br><span class="line">propertyResolver.resolveRequiredPlaceholders(strVal));</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.trimValues) &#123;</span><br><span class="line">resolved = resolved.trim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> (resolved.equals(<span class="hljs-keyword">this</span>.nullValue) ? <span class="hljs-keyword">null</span> : resolved);</span><br><span class="line">&#125;;</span><br><span class="line">doProcessProperties(beanFactoryToProcess, valueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doProcessProperties</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactoryToProcess,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">StringValueResolver valueResolver)</span> </span>&#123;</span><br><span class="line">BeanDefinitionVisitor visitor = <span class="hljs-keyword">new</span> BeanDefinitionVisitor(valueResolver);</span><br><span class="line">String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String curName : beanNames) &#123;</span><br><span class="line"><span class="hljs-comment">// Check that we're not parsing our own bean definition,</span></span><br><span class="line"><span class="hljs-comment">// to avoid failing on unresolvable placeholders in properties file locations.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!(curName.equals(<span class="hljs-keyword">this</span>.beanName) &amp;&amp; beanFactoryToProcess.equals(<span class="hljs-keyword">this</span>.beanFactory))) &#123;</span><br><span class="line">BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">visitor.visitBeanDefinition(bd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// New in Spring 2.5: resolve placeholders in alias target names and aliases as well.</span></span><br><span class="line">beanFactoryToProcess.resolveAliases(valueResolver);</span><br><span class="line"><span class="hljs-comment">// New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.</span></span><br><span class="line">beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面第三个 doProcessProperties 方法我要稍微和小伙伴们说两句：</p><p>使用 PropertySourcesPlaceholderConfigurer 对配置中的占位符进行处理，虽然我们只是在 DruidDataSource 中用到了相关变量，但是系统在处理的时候，除了当前这个配置类之外，其他的 Bean 都要处理（因为你可以在任意 Bean 中注入那三个变量）。</p><p>这就是 BeanFactoryPostProcessor 一个经典实践，即在 Bean 初始化之前，把 Bean 定义时候的一些占位符给改过来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的文章中，松哥已经和大家分享了 BeanPostProcessor 和 BeanFactoryPostProcessor 的基本用法以及差别，但是没有去分析其原理，今天我们就来聊一聊这两个后置处理器的工作原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>松哥我好迷茫呀，给点建议吧～</title>
    <link href="http://www.javaboy.org/2023/0913/suggest.html"/>
    <id>http://www.javaboy.org/2023/0913/suggest.html</id>
    <published>2023-09-13T09:57:26.000Z</published>
    <updated>2024-05-10T10:40:59.210Z</updated>
    
    <content type="html"><![CDATA[<p>经常会有小伙伴在微信上发消息这样说，这个问题真的很难回答，我想结合我的经验和小伙伴们一起来聊一聊这个话题。</p><a id="more"></a><p>问这个问题的小伙伴，大部分都情况类似：目前的工作没有挑战，在传统软件公司做业务开发，天天 CRUD，技术没有长进，想跳槽又不敢，想躺平也不敢，想加薪公司也不给加。。。</p><p>所以感到迷茫。</p><p>这次我得把托尔斯泰在安娜卡列尼娜中的开篇反着说了：牛逼的人各有过人之处，平凡的人却各个相似。</p><p>我大学是在经管学院，本科学位证是管理学学士。我从大二的时候开始接触 Java，当我确定要走 Java 这条路之后，我不知道要从哪里开始学起，农村孩子，大一的时候我连键盘都敲不利索，而且那个时候没有百度网盘、B 站也还不是学习网站，远不像今天各种学习资料满天飞。我也很迷茫，我想找个人了解一下该怎么学，从哪开始学，但是身边的同学也都是经管学院的，没有人能给我建议，我也是社恐，只能自己摸索。</p><p>我记得当时想做一个网站，不知道该怎么下手，在网上搜索，有人说用三剑客（Dreamweaver，Fireworks，Flash），有人说用 jsp，都说的头头是道，我就很懵。那怎么办？简单，我就把这些都学了！于是，我差不多花了一个暑假，用网页三剑客整了一个静态页面网站，整出来之后，我发现这个网站有点怪，内容都是提前在页面上编辑好的，不能从数据库读取，这个时候我大概就懂了 jsp 是干嘛的了。</p><p>我的自学之路基本上就这样，走了很多弯路，学了很多在现在看来根本用不上的东西，<strong>但是，在这个过程中，锻炼了我的学习能力，对于很多技术的理解，不是别人强行灌输给我的，而是我自己日复一日琢磨懂的，一旦自己琢磨透了，这个东西就永远印在你的记忆中了，你不用担心忘记，因为即使忘了，你还可以自己重新推导出来。</strong></p><p>工作之后，我们要学习的东西要掌握的东西就更多了，我差不多也是刚工作的时候开始写博客，因为那个时候我发现自己每天要输入很多东西，但是输入完后，很容易就忘记了，缺乏一个消化的过程，于是我就开始写博客，我把输入的东西按照自己的思路重新整理，重新记录下来，这个过程也是一个重新思考的过程，这些经过自己重新思考并且输出的东西，就会在脑子里留下比较深刻的印象。日积月累，技术就慢慢成长起来了。所以我其实很早之前就在公众号上说建议各位搞技术的小伙伴都去写博客，对于大家的技术成长是有很大的帮助的。</p><p>所以，避免迷茫和焦虑的最好办法就是动起来，迷茫是因为你不知道该往哪个方向走，那么不妨每个方向都去尝试一下，看看哪个适合你，不要怕走错，每一步都是成长，哪怕这个方向不适合你，在这个过程中你一定是有所收获，有所感悟的。</p><p>请教别人，那都是别人的经验，不一定适合你。当然也不是说从此闭门造车，自己一个人玩，适当的时候别人可以指点一下，但那是当你有了足够的积累，别人指点一下，拨开云雾见青天，如果自己没有任何积累，别人的指点作用有限。很多小伙伴认识松哥是因为我从 2019 年开始做公众号开始的，在哪之前我已经写了 5 年博客的，公众号也搞了两年了，但是一直没 GET 到公众号的玩法，虽然没有 GET 到公众号的玩法，但是我一直在坚持写作。所以在 2019 年华为云 open day 的时候，认识了微笑哥，他稍微点了我几句，我就知道怎么玩了，从那个时候搞公众号一直到现在。我在想，要是我没有之前写博客的积累，别说微笑哥点我几句，哪怕他天天带着我，我这公众号怕也是做不起来。而在那之前，我已经连续写了 4 年博客，平均下来一周一篇，一毛钱收入都没有，虽然没有收入，但是我觉得这个事情是有价值的，是值得坚持的，所以我坚持了下来，坚持下来的好处就是收到了出版社的邀请出了书，被微笑哥点拨后把公众号做了，而又因为书和公众号，我认识了这么多小伙伴。</p><p>不知道小伙伴能不能从我的经验中 GET 到，我破解迷茫焦虑的方式就是让自己动起来，行动起来，不要怕走错，有问题就调整方向，每一步都不会白走。前几天我还在朋友圈说我的感受：</p><p><img src="http://img.itboyhub.com/2022/08/20230902210538.png" alt></p><p>我用学习缓解焦虑。</p><p>我今年 3 月份 TienChin 项目杀青之后，我想着休息一下吧，短期内不想再做课程了，于是从三月份开始，每天按时上下班，按时回家，看着挺轻松的，但是实际上整个人却非常焦虑迷茫。到了 8 月份，终于下定决心做 Spring 源码了，整个人又精神了，因为没有时间去焦虑了去迷茫了，一下班，就想要课程要怎么做，该讲哪里了，该准备哪些内容了。</p><p>所以，迷茫的小伙伴，可能都是想的多做的少，不妨行动起来，就是我前面说的，不要怕错，因为每一步路都不会白走。我从接触 Java 到今天，走了很多跟 Java 无关的路，但是我不觉得走错了浪费了时间，每一次的尝试，都积累了未来做事的经验。另一方面就是认定的事要坚持，一年、两年没有收益没关系，只要你觉得正确的方向，就要坚持，会有收获的时候。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常会有小伙伴在微信上发消息这样说，这个问题真的很难回答，我想结合我的经验和小伙伴们一起来聊一聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中三种 BeanName 生成器！</title>
    <link href="http://www.javaboy.org/2023/0912/spring-beanname-generator.html"/>
    <id>http://www.javaboy.org/2023/0912/spring-beanname-generator.html</id>
    <published>2023-09-12T09:21:04.000Z</published>
    <updated>2023-09-12T09:39:46.021Z</updated>
    
    <content type="html"><![CDATA[<p>无论我们是通过 XML 文件，还是 Java 代码，亦或是包扫描的方式去注册 Bean，都可以不设置 BeanName，而 Spring 均会为之提供默认的 beanName，今天我们就来看看 Spring 中三种处理不同情况的 beanName 生成器。</p><a id="more"></a><h2 id="1-BeanNameGenerator"><a href="#1-BeanNameGenerator" class="headerlink" title="1. BeanNameGenerator"></a>1. BeanNameGenerator</h2><p>Spring 中提供了一个名为 BeanNameGenerator 的接口，这个接口就只有一个需要实现的方法就是 generateBeanName，从名字就能看出来，这就是专门用来生成 beanName 的方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有两个参数：</p><ul><li>definition：这个是要生成的 Bean 定义。</li><li>registry：这个是将来 BeanDefinition 的注册器。</li></ul><p>BeanNameGenerator 有三个不同的实现类，对应不同的处理场景：</p><p><img src="http://img.itboyhub.com/2022/08/BeanNameGenerator202309071905.png" alt></p><ul><li>AnnotationBeanNameGenerator：这个专门用来处理包扫描的时候扫到的 Bean，对于这些 Bean，其 name 属性该如何处理，由这个类来解决，当然，小伙伴们都知道，通过 @Component/@Service/@Repository/@Controller 这些注解定义的 Bean，默认情况下，beanName 就是类名首字母小写。</li><li>FullyQualifiedAnnotationBeanNameGenerator：这个继承自 AnnotationBeanNameGenerator，并重写了 AnnotationBeanNameGenerator#buildDefaultBeanName 方法，这个是使用类的全路径来作为 Bean 的默认名称。</li><li>DefaultBeanNameGenerator：这个是专门用来解决 XML 文件中定义的 Bean 如果没有设置 beanName，那么就通过 DefaultBeanNameGenerator 来为其生成 beanName。</li></ul><p>看了上面三个场景之后，可能有小伙伴发现一个 BUG，那么 @Bean 注解定义的 Bean，其 beanName 属性是在哪里处理的呢？这个其实比较特殊，是当场处理的，没用到 BeanNameGenerator，松哥后面单独说。</p><p>接下来我们详细看下上面这三个实现类。</p><h2 id="2-AnnotationBeanNameGenerator"><a href="#2-AnnotationBeanNameGenerator" class="headerlink" title="2. AnnotationBeanNameGenerator"></a>2. AnnotationBeanNameGenerator</h2><p>咱们直接来看最关键的 generateBeanName 方法吧：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (definition <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="hljs-comment">// Explicit bean name found.</span></span><br><span class="line"><span class="hljs-keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line"><span class="hljs-keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先判断 definition 是否为 AnnotatedBeanDefinition 类型，根据我们前面文章对 BeanDefinition 的介绍（<a href="https://mp.weixin.qq.com/s/G5_wqgjbpVp0qmscIkFaTg" target="_blank" rel="noopener">七种 BeanDefinition，各显其能！</a>），大家知道，AnnotatedBeanDefinition 的实现类主要是针对三种情况：@Bean 注解定义的 Bean、@Service/@Controller/@Component/@Repository 等注解标记的 Bean 以及系统的启动配置类，如果是这三种情况，那么就去调用 determineBeanNameFromAnnotation 方法，这个方法会尝试从注解中提取出来 beanName，如果不是上面三种情况，那么就调用 buildDefaultBeanName 方法去生成 beanName。</p><p>那我们先来看 determineBeanNameFromAnnotation 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determineBeanNameFromAnnotation</span><span class="hljs-params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">String beanName = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (String type : types) &#123;</span><br><span class="line">AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line"><span class="hljs-keyword">if</span> (attributes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Set&lt;String&gt; metaTypes = <span class="hljs-keyword">this</span>.metaAnnotationTypesCache.computeIfAbsent(type, key -&gt; &#123;</span><br><span class="line">Set&lt;String&gt; result = amd.getMetaAnnotationTypes(key);</span><br><span class="line"><span class="hljs-keyword">return</span> (result.isEmpty() ? Collections.emptySet() : result);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">if</span> (isStereotypeWithNameValue(type, metaTypes, attributes)) &#123;</span><br><span class="line">Object value = attributes.get(<span class="hljs-string">"value"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String strVal) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (beanName != <span class="hljs-keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Stereotype annotations suggest inconsistent "</span> +</span><br><span class="line"><span class="hljs-string">"component names: '"</span> + beanName + <span class="hljs-string">"' versus '"</span> + strVal + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">beanName = strVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先会去获取类上的注解信息，拿到 amd 之后，获取到所有的注解类型，然后进行遍历。</p><p>遍历的时候，首先获取到注解上的所有属性 attributes，当 attributes 不为空的时候，继续去读取当前注解的元注解，并将读取到的结果存入到 metaAnnotationTypesCache 集合中。这个是干嘛呢？大家知道，Spring 中用来标记 Bean 的注解大部分衍生自 @Component，甚至我们也可以自定义注解，那么如果自定义注解了，这个地方就没法判断了，因为每个人自定义出来的注解都不一样。所以，万变不离其宗，这里就去找各个注解的元注解。例如如果我们在类上添加的是 @Configuration，那么 @Configuration 的元注解有两个，分别是 @Component 和 @Indexed。</p><p>接下来的 isStereotypeWithNameValue 方法就是判断 type 是不是 @Component 或者 Jakarta 中自带的 @ManagedBean、@Named，亦或者 metaTypes 里是否包含 @Component。如果确定是 @Component 衍生出来的注解，亦或者是 @ManagedBean、@Named 注解标记的 Bean，那么就将其 value 属性读取出来，作为 beanName，如果包含多个有效注解，且各自配置的 beanName 不一致，就会抛出异常。</p><p>例如下面这种情况：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(<span class="hljs-string">"j"</span>)</span><br><span class="line"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"a"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个 beanName 不一致，运行时就会出错。</p><p>同时，经过上面的分析，小伙伴也看到了，我们其实可以通过自定义注解为 Bean 设置名称，例如我有如下注解：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyBeanName &#123;</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解衍生自 @Component，那么它的用法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@MyBeanName</span>(<span class="hljs-string">"f"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 f 就是当前类生成的 beanName。</p><p>以上是从注解中去提取 beanName，但是注解中可能没有提供 beanName，那么就得调用 buildDefaultBeanName 方法去自动生成了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> buildDefaultBeanName(definition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">String beanClassName = definition.getBeanClassName();</span><br><span class="line">Assert.state(beanClassName != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No bean class name set"</span>);</span><br><span class="line">String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line"><span class="hljs-keyword">return</span> StringUtils.uncapitalizeAsProperty(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就很好懂了，先拿到 bean 的完整类名，然后提取出来 shortName，也就是去除包名之后的名字，然后首字母小写之后返回。</p><p>这就是 @Component 注解体系下的 beanName 生成流程。</p><h2 id="3-FullyQualifiedAnnotationBeanNameGenerator"><a href="#3-FullyQualifiedAnnotationBeanNameGenerator" class="headerlink" title="3. FullyQualifiedAnnotationBeanNameGenerator"></a>3. FullyQualifiedAnnotationBeanNameGenerator</h2><p>FullyQualifiedAnnotationBeanNameGenerator 类只是重写了 AnnotationBeanNameGenerator 的 buildDefaultBeanName 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">String beanClassName = definition.getBeanClassName();</span><br><span class="line">Assert.state(beanClassName != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No bean class name set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> beanClassName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写后的方法就是获取类的完整路径返回。</p><p>FullyQualifiedAnnotationBeanNameGenerator 默认情况下并不会直接使用，需要自己手动配置，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(nameGenerator = FullyQualifiedAnnotationBeanNameGenerator.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，生成的 Bean 的默认名称就是类的全路径了。</p><h2 id="4-DefaultBeanNameGenerator"><a href="#4-DefaultBeanNameGenerator" class="headerlink" title="4. DefaultBeanNameGenerator"></a>4. DefaultBeanNameGenerator</h2><p>这个是专门用来处理 XML 中默认的 beanName 的。这个在最近录制的 Spring 源码视频中已经详细介绍过了，这里就不再啰嗦了，感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>。</p><h2 id="5-Bean-处理特殊情况"><a href="#5-Bean-处理特殊情况" class="headerlink" title="5. @Bean 处理特殊情况"></a>5. @Bean 处理特殊情况</h2><p>如果类是被 @Bean 注解标记的，那么处理情况就特殊一些，直接现场处理，方法在 <code>org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod</code> 位置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForBeanMethod</span><span class="hljs-params">(BeanMethod beanMethod)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Consider name and any aliases</span></span><br><span class="line">List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(bean.getStringArray(<span class="hljs-string">"name"</span>)));</span><br><span class="line">String beanName = (!names.isEmpty() ? names.remove(<span class="hljs-number">0</span>) : methodName);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Register aliases even when overridden</span></span><br><span class="line"><span class="hljs-keyword">for</span> (String alias : names) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到，如果一开始配置了 name 属性，那么就把 names 集合中的第一个值拿出来作为 beanName，集合中的其他值则当作别名来处理，如果没有配置 name 属性值，那么就使用方法名作为 beanName。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>好啦，这就是松哥和大家讲的 Spring 中默认的 beanName 生成策略，感兴趣的小伙伴可以试试哦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论我们是通过 XML 文件，还是 Java 代码，亦或是包扫描的方式去注册 Bean，都可以不设置 BeanName，而 Spring 均会为之提供默认的 beanName，今天我们就来看看 Spring 中三种处理不同情况的 beanName 生成器。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 条件注解没生效？咋回事</title>
    <link href="http://www.javaboy.org/2023/0911/spring-condition.html"/>
    <id>http://www.javaboy.org/2023/0911/spring-condition.html</id>
    <published>2023-09-11T09:20:52.000Z</published>
    <updated>2023-09-12T09:40:46.652Z</updated>
    
    <content type="html"><![CDATA[<p>条件注解相信各位小伙伴都用过，Spring 中的多环境配置 profile 底层就是通过条件注解来实现的，松哥在之前的 Spring 视频中也有和大家详细介绍过条件注解的使用，感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>。</p><a id="more"></a><p>从 Spring4.0 开始，Spring 提供了一个更加细粒度的条件注解： ConfigurationCondition。从名字上就可以看出来这个是搭配 @Configuration 注解一起使用的，ConfigurationCondition 提供了一种更加细粒度的条件匹配，可以在配置或者 Bean 注册的时候去评估条件注解是否满足。</p><p>也就是说，当一个类上存在条件注解的时候，我们可以有两个评估条件注解是否满足的时机：</p><ol><li>在配置的时候去评估。</li><li>在 Bean 注册的时候评估。</li></ol><p>在配置的时候评估，可能会导致当前类都不会被加载，在 Bean 注册的时候再去评估，意味着当前类就会被加载。</p><h2 id="1-ConfigurationCondition"><a href="#1-ConfigurationCondition" class="headerlink" title="1. ConfigurationCondition"></a>1. ConfigurationCondition</h2><p>我们先来看下这个类的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ConfigurationCondition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Condition</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">ConfigurationPhase <span class="hljs-title">getConfigurationPhase</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">enum</span> ConfigurationPhase &#123;</span><br><span class="line">PARSE_CONFIGURATION,</span><br><span class="line">REGISTER_BEAN</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到，这里其实就是定义了两个枚举值，然后提供了一个方法返回枚举值。</p><ul><li>PARSE_CONFIGURATION：这个表示 Condition 条件应该在解析 @Configuration 类时进行评估，如果评估不通过，则不会将 @Configuration 添加到容器中。</li><li>REGISTER_BEAN：这个表示添加常规 Bean 的时候去评估 Condition 条件（常规 Bean 就是指非配置类，例如添加搭配 @Bean 注解使用的条件注解），这个条件不会阻止注册 @Configuration 类到容器中。</li></ul><p>其实道理很好懂，就是加载配置类的时候就根据条件注解判断要不要加载配置类，还是等到注册 Bean 的时候再去看条件注解是否满足条件。</p><h2 id="2-案例分析"><a href="#2-案例分析" class="headerlink" title="2. 案例分析"></a>2. 案例分析</h2><p>松哥通过一个简单案例来和小伙伴们演示一下。</p><p>假设我现在有如下条件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConfigurationCondition</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurationPhase <span class="hljs-title">getConfigurationPhase</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ConfigurationPhase.PARSE_CONFIGURATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> context.getBeanFactory().containsBean(<span class="hljs-string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件我没有直接实现 Condition 接口，而是实现类 ConfigurationCondition 接口，在这个接口中，getConfigurationPhase 方法返回了 PARSE_CONFIGURATION，表示在加载配置类的时候就去评估条件是否满足，matches 方法则是去判断容器中是否存在一个名为 a 的 Bean。</p><p>现在我有两个配置类，分别是 A 和 B，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(MyCondition.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A 配置类正常加载，B 配置类有一个加载条件，就是得 A 存在，B 才会加载。</p><p>现在，在容器中加载 B 和 A 两个配置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.register(B.class,A.class);</span><br><span class="line">ctx.refresh();</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    System.out.println(beanDefinitionName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家注意，加载的时候，我先加载了 B，后加载了 A，这点很重要，加载 B 的时候，由于此时容器中还不存在一个名为 a 的 Bean，而我们的评估时机是在处理配置类的时候，因此就会导致 B 配置类不会被加载，最终打印出来的 BeanName 就没有 b。</p><p>但是，如果我们将 MyCondition 中，条件注解的评估时机改为 <code>ConfigurationPhase.REGISTER_BEAN</code>，那么就表示在系统启动的时候，并不会去评估条件注解是否满足，而是会将 @Configuration 配置类进行解析，此时启动系统，就会发现最终打印出来的 beanName 里既有 a 又有 b。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>接下来我们再来从源码的角度来分析一下上述行为。</p><p>在 Spring 中，提供了一个专门的内部类 ConditionEvaluator 来处理要不要跳过条件注解，该类中有一个名为 shouldSkip 的方法，用来处理此事：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> shouldSkip(metadata, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (metadata == <span class="hljs-keyword">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (phase == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (metadata <span class="hljs-keyword">instanceof</span> AnnotationMetadata annotationMetadata &amp;&amp;</span><br><span class="line">ConfigurationClassUtils.isConfigurationCandidate(annotationMetadata)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Condition&gt; conditions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String conditionClass : conditionClasses) &#123;</span><br><span class="line">Condition condition = getCondition(conditionClass, <span class="hljs-keyword">this</span>.context.getClassLoader());</span><br><span class="line">conditions.add(condition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAwareOrderComparator.sort(conditions);</span><br><span class="line"><span class="hljs-keyword">for</span> (Condition condition : conditions) &#123;</span><br><span class="line">ConfigurationPhase requiredPhase = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (condition <span class="hljs-keyword">instanceof</span> ConfigurationCondition configurationCondition) &#123;</span><br><span class="line">requiredPhase = configurationCondition.getConfigurationPhase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> ((requiredPhase == <span class="hljs-keyword">null</span> || requiredPhase == phase) &amp;&amp; !condition.matches(<span class="hljs-keyword">this</span>.context, metadata)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个方法不用多说，我们来看第二个重载方法，重载方法多了一个参数 ConfigurationPhase，这个就表示配置的阶段，也就是条件注解生效的阶段。</p><p>首先会去判断当前注解是否是一个条件注解，如果不是条件注意，那么就不能跳过，要继续后面的解析（继续后面的解析时 Bean 将会被注册），如果是条件注解，则继续后面的判断。继续判断，如果没有传递 phase 进来，说明没有指定应该在哪个阶段去评估条件注解，那么这个时候就去判断，如果当前注解是一个配置类上的注解，那么就设置 phase 为 PARSE_CONFIGURATION，然后继续调用 shouldSkip 方法，否则就设置 phase 为 REGISTER_BEAN 然后继续调用 shouldSkip 方法。</p><blockquote><p>那么什么样的情况会被认为是一个配置类上的注解呢？如果当前类上添加的注解时 @Component、@ComponentScan、@Import、@ImportResource 以及这四种注解衍生出来的注解，亦或者当前类中有 @Bean 注解标记的方法，那么当前类就是一个配置类，就会设置 phase 为 PARSE_CONFIGURATION。</p></blockquote><p>第二次进入 shouldSkip 方法的时候，就已经有明确的 phase 了。这次进来后，把所有的条件注解的条件收集起来，存入到 conditions 集合中，然后再对该集合进行排序。然后遍历该集合。遍历的时候就去判断这个条件注解是不是 ConfigurationCondition 类型的，如果是，则提取出来其中的 phase 为 requiredPhase，这个就表示这个条件注意希望自己被处理的阶段，接下来去判断，如果 requiredPhase 为空，说明条件并未指定自己的执行时间，那么就执行 matches 方法进行条件评估；如果 requiredPhase 不为空，并且和传入的 phase 相等，那么也是当前评估。其实这个判断核心逻辑就是以参数传入进来的 phase 为准，要么条件没有设置评估时机，要么设置了，但是得和参数传进来的 phase 一致，只有满足这两个条件，才会当场进行评估。</p><p>这就是系统条件注解的评估逻辑。</p><p>对于配置类来说，是在 <code>AnnotatedBeanDefinitionReader#doRegisterBean</code> 方法中调用评估逻辑的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass, @Nullable String name,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line">AnnotatedGenericBeanDefinition abd = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候并未明确指定 phase，所以会在进入到 shouldSkip 方法后，自行分析是哪个阶段评估条件注解。</p><p>对于 @Bean 注解标记的类来说，是在 <code>ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod</code> 方法中调用评估逻辑的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForBeanMethod</span><span class="hljs-params">(BeanMethod beanMethod)</span> </span>&#123;</span><br><span class="line">ConfigurationClass configClass = beanMethod.getConfigurationClass();</span><br><span class="line">MethodMetadata metadata = beanMethod.getMetadata();</span><br><span class="line">String methodName = metadata.getMethodName();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">configClass.skippedBeanMethods.add(methodName);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个调用的时候，就传入了 phase 了，直接指定了是在 Bean 初始化的时候评估。</p><p>好啦，这就是条件注解条件评估时机的两种情况。在 Spring Boot 中定义的条件注解里，有不少都用到了 ConfigurationCondition，而不是传统的 Condition，感兴趣的小伙伴可以自行查看哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;条件注解相信各位小伙伴都用过，Spring 中的多环境配置 profile 底层就是通过条件注解来实现的，松哥在之前的 Spring 视频中也有和大家详细介绍过条件注解的使用，感兴趣的小伙伴戳这里：&lt;a href=&quot;https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring源码应该怎么学？&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>七种 BeanDefinition，各显其能！</title>
    <link href="http://www.javaboy.org/2023/0906/spring-7-beandefinition.html"/>
    <id>http://www.javaboy.org/2023/0906/spring-7-beandefinition.html</id>
    <published>2023-09-06T09:20:39.000Z</published>
    <updated>2023-09-12T09:40:42.194Z</updated>
    
    <content type="html"><![CDATA[<p>聚沙成塔！不知不觉 Spring 源码已经连续更了两个月啦，视频也录制了不少了，对 Spring 源码分析感兴趣的小伙伴戳这里哦<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>～</p><a id="more"></a><p>今天我们继续来看 Spring 源码中一个非常重要的概念：BeanDefinition。</p><h2 id="1-BeanDefinition"><a href="#1-BeanDefinition" class="headerlink" title="1.BeanDefinition"></a>1.BeanDefinition</h2><p>在 Spring 容器中，我们广泛使用的是一个一个的 Bean，BeanDefinition 从名字上就可以看出是关于 Bean 的定义。</p><p>事实上就是这样，我们在 XML 文件中配置的 Bean 的各种属性，亦或者用注解定义出来的 Bean 的各种属性，在真正生成 Bean 直接，我们需要先对这些设置的属性进行解析，解析的结果需要有一个对象来承载，很明显，这个对象就是 BeanDefinition。</p><p>无论是通过 XML 中定义的 Bean 属性还是通过 Java 代码定义的 Bean 属性，都会先加载到 BeanDefinition 上，然后通过 BeanDefinition 来生成一个 Bean，从这个角度来说，BeanDefinition 和 Bean 的关系有点类似于类和对象的关系，BeanDefinition 是模板，Bean 是模板具体化之后的产物。</p><p>要理解 BeanDefinition，我们从 BeanDefinition 的继承关系开始看起。</p><p><img src="http://img.itboyhub.com/2020/BeanDefinition.png" alt></p><p>BeanDefinition 是一个接口，继承自 BeanMetadataElement 和 AttributeAccessor 接口。</p><ul><li>BeanMetadataElement：该接口只有一个方法 getSource，该方法返回 Bean 的来源。</li><li>AttributeAccessor：该接口主要规范了问任意对象元数据的方法。</li></ul><p>我们来看下 AttributeAccessor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AttributeAccessor</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, @Nullable Object value)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">removeAttribute</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAttribute</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">String[] attributeNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了元数据的访问接口，具体的实现则是 AttributeAccessorSupport，这些数据采用 LinkedHashMap 进行存储。</p><p>这是 BeanDefinition 所继承的两个接口。接下来我们来看下 BeanDefinition 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeAccessor</span>, <span class="hljs-title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"><span class="hljs-keyword">int</span> ROLE_APPLICATION = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ROLE_SUPPORT = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ROLE_INFRASTRUCTURE = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParentName</span><span class="hljs-params">(@Nullable String parentName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getParentName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBeanClassName</span><span class="hljs-params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getBeanClassName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setScope</span><span class="hljs-params">(@Nullable String scope)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getScope</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLazyInit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isLazyInit</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDependsOn</span><span class="hljs-params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">String[] getDependsOn();</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAutowireCandidate</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAutowireCandidate</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPrimary</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> primary)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrimary</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFactoryBeanName</span><span class="hljs-params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getFactoryBeanName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFactoryMethodName</span><span class="hljs-params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getFactoryMethodName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">ConstructorArgumentValues <span class="hljs-title">getConstructorArgumentValues</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasConstructorArgumentValues</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function">MutablePropertyValues <span class="hljs-title">getPropertyValues</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPropertyValues</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInitMethodName</span><span class="hljs-params">(@Nullable String initMethodName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getInitMethodName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDestroyMethodName</span><span class="hljs-params">(@Nullable String destroyMethodName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getDestroyMethodName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setRole</span><span class="hljs-params">(<span class="hljs-keyword">int</span> role)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRole</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDescription</span><span class="hljs-params">(@Nullable String description)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">ResolvableType <span class="hljs-title">getResolvableType</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAbstract</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getResourceDescription</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">BeanDefinition <span class="hljs-title">getOriginatingBeanDefinition</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinition 中的方法虽然多，但是结合我们平时在 XML/Java 中的配置，这些方法其实都很好理解：</p><ol><li>首先一开始定义了两个变量用来描述 Bean 是不是单例的，后面的 setScope/getScope 方法可以用来修改/获取 scope 属性。</li><li>ROLE_xxx 用来描述一个 Bean 的角色，ROLE_APPLICATION 表示这个 Bean 是用户自己定义的 Bean；ROLE_SUPPORT 表示这个 Bean 是某些复杂配置的支撑部分；ROLE_INFRASTRUCTURE 表示这是一个 Spring 内部的 Bean，通过 setRole/getRole 可以修改。</li><li>setParentName/getParentName 用来配置 parent 的名称，这块可能有的小伙伴使用较少，这个对应着 XML 中的 <code>&lt;bean parent=&quot;&quot;&gt;</code> 配置，在之前的视频中松哥已经和大家讲过了 Spring 中 parent 的使用了。</li><li>setBeanClassName/getBeanClassName 这个就是配置 Bean 的 Class 全路径，对应 XML 中的 <code>&lt;bean class=&quot;&quot;&gt;</code> 配置。</li><li>setLazyInit/isLazyInit 配置/获取 Bean 是否懒加载，这个对应了 XML 中的 <code>&lt;bean lazy-init=&quot;&quot;&gt;</code> 配置。</li><li>setDependsOn/getDependsOn 配置/获取 Bean 的依赖对象，这个对应了 XML 中的 <code>&lt;bean depends-on=&quot;&quot;&gt;</code> 配置。</li><li>setAutowireCandidate/isAutowireCandidate 配置/获取 Bean 是否是自动装配，对应了 XML 中的 <code>&lt;bean autowire-candidate=&quot;&quot;&gt;</code> 配置。</li><li>setPrimary/isPrimary 配置/获取当前 Bean 是否为首选的 Bean，对应了 XML 中的 <code>&lt;bean primary=&quot;&quot;&gt;</code> 配置。</li><li>setFactoryBeanName/getFactoryBeanName 配置/获取 FactoryBean 的名字，对应了 XML 中的 <code>&lt;bean factory-bean=&quot;&quot;&gt;</code> 配置，factory-bean 松哥在之前的视频中讲过，小伙伴们可以参考这里:<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>。</li><li>setFactoryMethodName/getFactoryMethodName 和上一条成对出现的，对应了 XML 中的 <code>&lt;bean factory-method=&quot;&quot;&gt;</code> 配置，不再赘述。</li><li>getConstructorArgumentValues 返回该 Bean 构造方法的参数值。</li><li>hasConstructorArgumentValues 判断上一条是否是空对象。</li><li>getPropertyValues 这个是获取普通属性的集合。</li><li>hasPropertyValues 判断上一条是否为空对象。</li><li>setInitMethodName/setDestroyMethodName 配置 Bean 的初始化方法、销毁方法。</li><li>setDescription/getDescription 配置/返回 Bean 的描述。</li><li>isSingleton Bean 是否为单例。</li><li>isPrototype Bean 是否为原型。</li><li>isAbstract Bean 是否抽象。</li><li>getResourceDescription 返回定义 Bean 的资源描述。</li><li>getOriginatingBeanDefinition 如果当前 BeanDefinition 是一个代理对象，那么该方法可以用来返回原始的 BeanDefinition 。</li></ol><p>这个就是 BeanDefinition 的定义以及它里边方法的含义。</p><h2 id="2-BeanDefinition-实现类"><a href="#2-BeanDefinition-实现类" class="headerlink" title="2.BeanDefinition 实现类"></a>2.BeanDefinition 实现类</h2><p>上面只是 BeanDefinition 接口的定义，BeanDefinition 还拥有诸多实现类，我们也来大致了解下。</p><p>先来看一张继承关系图：</p><p><img src="http://img.itboyhub.com/2022/08/BeanDefinition202309051544.png" alt></p><p>这么多实现类看着有点眼花缭乱，不过搞清楚了每一个接口和类的作用，再看就很容易了。</p><h3 id="2-1-AbstractBeanDefinition"><a href="#2-1-AbstractBeanDefinition" class="headerlink" title="2.1 AbstractBeanDefinition"></a>2.1 AbstractBeanDefinition</h3><p>AbstractBeanDefinition 是一个抽象类，它根据 BeanDefinition 中定义的接口提供了相应的属性，并实现了 BeanDefinition 中定义的一部分方法。BeanDefinition 中原本只是定义了一系列的 get/set 方法，并没有提供对应的属性，在 AbstractBeanDefinition 中将所有的属性定义出来了。</p><p>后面其他的实现类也基本上都是在 AbstractBeanDefinition 的基础上完成的。</p><h3 id="2-2-RootBeanDefinition"><a href="#2-2-RootBeanDefinition" class="headerlink" title="2.2 RootBeanDefinition"></a>2.2 RootBeanDefinition</h3><p>这是一个比较常用的实现类，对应了一般的元素标签。</p><h3 id="2-3-ChildBeanDefinition"><a href="#2-3-ChildBeanDefinition" class="headerlink" title="2.3 ChildBeanDefinition"></a>2.3 ChildBeanDefinition</h3><p>可以让子 BeanDefinition 定义拥有从父 BeanDefinition 那里继承配置的能力，如果子 Bean 从父 Bean 获取配置，可以参考松哥之前的这篇文章：<a href="https://mp.weixin.qq.com/s/C8EnAU4A-6bvgm5jr3AK4w" target="_blank" rel="noopener">Spring BeanDefinition 也分父子？</a>。</p><h3 id="2-4-GenericBeanDefinition"><a href="#2-4-GenericBeanDefinition" class="headerlink" title="2.4 GenericBeanDefinition"></a>2.4 GenericBeanDefinition</h3><p>GenericBeanDefinition 是从 Spring2.5 以后新加入的 BeanDefinition 实现类。GenericBeanDefinition 可以动态设置父 Bean，同时兼具 RootBeanDefinition 和 ChildBeanDefinition 的功能，因此，自从有了 GenericBeanDefinition 之后，RootBeanDefinition 和 ChildBeanDefinition 现在相对就用的少了。</p><h3 id="2-5-AnnotatedBeanDefinition"><a href="#2-5-AnnotatedBeanDefinition" class="headerlink" title="2.5 AnnotatedBeanDefinition"></a>2.5 AnnotatedBeanDefinition</h3><p>这个表示注解类型 BeanDefinition，用于表示通过注解配置的 Bean 定义。通过 AnnotatedBeanDefinition，我们可以获取到被注解的 Bean 的相关信息，包括注解类型、属性值、方法等。这个接口提供了一种方便的方式来处理通过注解方式配置的 Bean，并且可以在运行时动态地获取和操作这些注解信息，当然，这是一个接口，它有三个实现类，分别是 AnnotatedGenericBeanDefinition、ScannedGenericBeanDefinition 以及 ConfigurationClassBeanDefinition。</p><h3 id="2-6-AnnotatedGenericBeanDefinition"><a href="#2-6-AnnotatedGenericBeanDefinition" class="headerlink" title="2.6 AnnotatedGenericBeanDefinition"></a>2.6 AnnotatedGenericBeanDefinition</h3><p>作为系统配置类的类会解析为 AnnotatedGenericBeanDefinition。</p><h3 id="2-7-ScannedGenericBeanDefinition"><a href="#2-7-ScannedGenericBeanDefinition" class="headerlink" title="2.7 ScannedGenericBeanDefinition"></a>2.7 ScannedGenericBeanDefinition</h3><p>这个是通过包扫描自动注册的 Bean，就会被解析为 ScannedGenericBeanDefinition。</p><h3 id="2-8-ConfigurationClassBeanDefinition"><a href="#2-8-ConfigurationClassBeanDefinition" class="headerlink" title="2.8 ConfigurationClassBeanDefinition"></a>2.8 ConfigurationClassBeanDefinition</h3><p>这是一个私有的内部类。我们通过 @Bean 注解定义的 Bean，最终会被解析为 ConfigurationClassBeanDefinition。</p><h3 id="2-9-ClassDerivedBeanDefinition"><a href="#2-9-ClassDerivedBeanDefinition" class="headerlink" title="2.9 ClassDerivedBeanDefinition"></a>2.9 ClassDerivedBeanDefinition</h3><p>ClassDerivedBeanDefinition 的作用是扩展并描述一个类派生的Bean的元数据。它是 AnnotatedBeanDefinition 接口的一个实现类，在 Spring 框架中用于表示通过类派生方式配置的Bean定义。</p><h3 id="2-10-CreateFromClassBeanDefinition"><a href="#2-10-CreateFromClassBeanDefinition" class="headerlink" title="2.10 CreateFromClassBeanDefinition"></a>2.10 CreateFromClassBeanDefinition</h3><p>这个是按照类型创建 Bean 的时候会用到。</p><p>差不多就这么多了，大部分我们日常开发中其实都用不上，接下来松哥通过几个具体的案例来和小伙伴们演示这些 BeanDefinition 的具体用法。后面的文章，我们再来分析这些 BeanDefinition 在 Spring 源码中是如何应用的。</p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3.实践"></a>3.实践</h2><p>接下来我通过几个具体的案例来和小伙伴们演示各种不同的 BeanDefinition 的用法，今天我主要和小伙伴们演示我们纯手动使用 BeanDefinition，然后分析一下我们平时的配置本质上使用的 BeanDefinition 是哪一个，今天我们先不去源码分析，单纯的就看看效果。</p><h3 id="3-1-GenericBeanDefinition"><a href="#3-1-GenericBeanDefinition" class="headerlink" title="3.1 GenericBeanDefinition"></a>3.1 GenericBeanDefinition</h3><p>先来看 GenericBeanDefinition，这个功能相对比较全，兼具 RootBeanDefinition 和 ChildBeanDefinition 的能力。</p><p>先来看一个简单用法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">GenericBeanDefinition bd = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">bd.setBeanClass(User.class);</span><br><span class="line">MutablePropertyValues pValues = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pValues.add(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">bd.setPropertyValues(pValues);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"user"</span>, bd);</span><br><span class="line">User user = beanFactory.getBean(<span class="hljs-string">"user"</span>, User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>小伙伴们看到，我们这里向 Spring 容器注册了一个 GenericBeanDefinition 类型的 BeanDefinition，GenericBeanDefinition 中包含了具体的 class 以及 Bean 的各个属性值。</p><p>如果我们在 Bean 定义的时候，想要使用继承特性，也可以使用 GenericBeanDefinition：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">GenericBeanDefinition parentBD = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">GenericBeanDefinition childBD = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">parentBD.setBeanClass(Animal.class);</span><br><span class="line">MutablePropertyValues pValues = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pValues.add(<span class="hljs-string">"name"</span>, <span class="hljs-string">"小黄"</span>);</span><br><span class="line">parentBD.setPropertyValues(pValues);</span><br><span class="line">childBD.setBeanClass(Dog.class);</span><br><span class="line">childBD.setParentName(<span class="hljs-string">"animal"</span>);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"animal"</span>, parentBD);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"dog"</span>, childBD);</span><br><span class="line">Dog dog = beanFactory.getBean(<span class="hljs-string">"dog"</span>, Dog.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"dog = "</span> + dog);</span><br></pre></td></tr></table></figure><p>这次我直接定义了两个 GenericBeanDefinition，一个作为 parent，另外一个作为 child，为 child 设置 parentName，则 child 可以继承 parent 中的属性。上面的案例中，最终打印出来 dog 的 name 属性就是 <strong>小黄</strong>，这块小伙伴们可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/C8EnAU4A-6bvgm5jr3AK4w" target="_blank" rel="noopener">Spring BeanDefinition 也分父子？</a>。</p><p>我们平时通过 XML 文件定义的 Bean，最终解析后就是 GenericBeanDefinition。</p><p>例如下面这样：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.demo.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载 XML 文件，创建容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans.xml"</span>);</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    BeanDefinition bd = ctx.getBeanFactory().getBeanDefinition(beanDefinitionName);</span><br><span class="line">    System.out.println(beanDefinitionName + <span class="hljs-string">"&gt;&gt;&gt;"</span> + bd.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230905161741.png" alt></p><p>这个也好理解，毕竟我们在 XML 中配置的时候，可能存在 parent，也可能不存在，用 GenericBeanDefinition 就能够应对各种情况。</p><h3 id="3-2-RootBeanDefinition-ChildBeanDefinition"><a href="#3-2-RootBeanDefinition-ChildBeanDefinition" class="headerlink" title="3.2 RootBeanDefinition/ChildBeanDefinition"></a>3.2 RootBeanDefinition/ChildBeanDefinition</h3><p>这两个常规的功能其实都有，但是 RootBeanDefinition 一般可以用来做 parent，不能用作 child，即给 RootBeanDefinition 不能配置 parentName 属性。强行设置会抛出如下异常：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParentName</span><span class="hljs-params">(@Nullable String parentName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (parentName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Root bean cannot be changed into a child bean with parent reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChildBeanDefinition 则既可以做 parent 也可以做 child，但是 ChildBeanDefinition 在使用的使用必须指定 parent，即使 ChildBeanDefinition 作为 parent，也必须指定 parent，所以 ChildBeanDefinition 在使用的过程中有一点点局限性，因此目前被 GenericBeanDefinition 代替了。</p><p>来看一个简单的案例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">RootBeanDefinition parentBD = <span class="hljs-keyword">new</span> RootBeanDefinition();</span><br><span class="line">parentBD.setBeanClass(Animal.class);</span><br><span class="line">MutablePropertyValues pValues = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pValues.add(<span class="hljs-string">"name"</span>, <span class="hljs-string">"小黄"</span>);</span><br><span class="line">parentBD.setPropertyValues(pValues);</span><br><span class="line">ChildBeanDefinition childBD = <span class="hljs-keyword">new</span> ChildBeanDefinition(<span class="hljs-string">"animal"</span>);</span><br><span class="line">childBD.setBeanClass(Dog.class);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"animal"</span>, parentBD);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"dog"</span>, childBD);</span><br><span class="line">Dog dog = beanFactory.getBean(<span class="hljs-string">"dog"</span>, Dog.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"dog = "</span> + dog);</span><br></pre></td></tr></table></figure><h3 id="3-3-AnnotatedGenericBeanDefinition"><a href="#3-3-AnnotatedGenericBeanDefinition" class="headerlink" title="3.3 AnnotatedGenericBeanDefinition"></a>3.3 AnnotatedGenericBeanDefinition</h3><p>对于使用 @Configuration 注解标记的类，最终解析出来的 BeanDefinition 就是 AnnotatedGenericBeanDefinition。例如我有一个配置类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载配置类并启动容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    BeanDefinition beanDefinition = ctx.getBeanFactory().getBeanDefinition(beanDefinitionName);</span><br><span class="line">    System.out.println(beanDefinitionName + <span class="hljs-string">" &gt;&gt;&gt; "</span> + beanDefinition.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230905201527.png" alt></p><h3 id="3-4-ScannedGenericBeanDefinition"><a href="#3-4-ScannedGenericBeanDefinition" class="headerlink" title="3.4 ScannedGenericBeanDefinition"></a>3.4 ScannedGenericBeanDefinition</h3><p>这个是那些通过包扫描注册到 Spring 容器中的 Bean，在一开始定义出来的 BeanDefinition 就是 ScannedGenericBeanDefinition。</p><p>例如我有如下 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后配置包扫描：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    BeanDefinition beanDefinition = ctx.getBeanFactory().getBeanDefinition(beanDefinitionName);</span><br><span class="line">    System.out.println(beanDefinitionName + <span class="hljs-string">" &gt;&gt;&gt; "</span> + beanDefinition.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230905202035.png" alt></p><h3 id="3-5-ConfigurationClassBeanDefinition"><a href="#3-5-ConfigurationClassBeanDefinition" class="headerlink" title="3.5 ConfigurationClassBeanDefinition"></a>3.5 ConfigurationClassBeanDefinition</h3><p>当我们通过 @Bean 注解去定义 Bean 的时候，那么被 @Bean 注解标记的类就会被解析为 ConfigurationClassBeanDefinition。</p><p>例如下面这个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看解析后的 BeanDefinition 如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230905202930.png" alt></p><h3 id="3-6-CreateFromClassBeanDefinition"><a href="#3-6-CreateFromClassBeanDefinition" class="headerlink" title="3.6 CreateFromClassBeanDefinition"></a>3.6 CreateFromClassBeanDefinition</h3><p>这个其实用的少，但是咱么既然讲到 Spring，松哥也说两句。</p><p>这个是当我们想要创建一个对象，我们希望这个对象能够自动走一遍 Spring 中的各种后置处理器的时候，那么可以调用 createBean 方法，该方法内部使用了 CreateFromClassBeanDefinition。</p><p>例如如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = ctx.getBeanFactory();</span><br><span class="line">User user = beanFactory.createBean(User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>使用这种方式去创建一个 Bean，这个 Bean 会走一遍 Spring 中 Bean 的后置处理器，其中，createBean 方法的内部就使用了 CreateFromClassBeanDefinition。</p><h3 id="3-7-ClassDerivedBeanDefinition"><a href="#3-7-ClassDerivedBeanDefinition" class="headerlink" title="3.7 ClassDerivedBeanDefinition"></a>3.7 ClassDerivedBeanDefinition</h3><p>ClassDerivedBeanDefinition 和 CreateFromClassBeanDefinition 其实比较像，差别在于二者处理构造方法的方式不同。</p><p>而且 ClassDerivedBeanDefinition 是一个相当冷门的 BeanDefinition，在 GenericApplicationContext 的实现类中，可以使用 GenericXmlApplicationContext、StaticApplicationContext 或者 GenericGroovyApplicationContext，只有这三个类中 registerBean 方法用到了 ClassDerivedBeanDefinition，我们常见的 AnnotationConfigApplicationContext 由于方法重写的缘故并未使用 ClassDerivedBeanDefinition。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StaticApplicationContext ctx = <span class="hljs-keyword">new</span> StaticApplicationContext();</span><br><span class="line">ctx.registerBean(User.class,()-&gt;&#123;</span><br><span class="line">    User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> user;</span><br><span class="line">&#125;);</span><br><span class="line">User user = ctx.getBean(User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    BeanDefinition bd = ctx.getBeanDefinition(beanDefinitionName);</span><br><span class="line">    System.out.println(beanDefinitionName + <span class="hljs-string">"&gt;&gt;&gt;"</span> + bd.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以调用 registerBean 方法向 Spring 容器中注入一个 Bean，该方法第二个参数是一个 Bean 的生产者，如果不指定生产者，那么这个方法最终就是通过第一个参数反射创建 Bean，registerBean 方法的内部就是使用了 ClassDerivedBeanDefinition。</p><p>好啦，BeanDefinition 一共就是这七种，接下来我会通过几篇文章和大家重点介绍 GenericBeanDefinition、AnnotatedGenericBeanDefinition、ScannedGenericBeanDefinition 以及 ConfigurationClassBeanDefinition 这四种最为常见的 BeanDefinition。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聚沙成塔！不知不觉 Spring 源码已经连续更了两个月啦，视频也录制了不少了，对 Spring 源码分析感兴趣的小伙伴戳这里哦&lt;a href=&quot;https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring源码应该怎么学？&lt;/a&gt;～&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean 别名处理原理分析</title>
    <link href="http://www.javaboy.org/2023/0905/spring-alias.html"/>
    <id>http://www.javaboy.org/2023/0905/spring-alias.html</id>
    <published>2023-09-05T09:20:24.000Z</published>
    <updated>2023-09-12T09:40:38.935Z</updated>
    
    <content type="html"><![CDATA[<p>今天来和小伙伴们聊一聊 Spring 中关于 Bean 别名的处理逻辑。</p><a id="more"></a><h2 id="1-Alias"><a href="#1-Alias" class="headerlink" title="1. Alias"></a>1. Alias</h2><p>别名，顾名思义就是给一个 Bean 去两个甚至多个名字。整体上来说，在 Spring 中，有两种不同的别名定义方式：</p><ol><li>定义 Bean 的 name 属性，name 属性在真正的处理过程中，实际上就是按照别名来处理的。</li><li>通过 alias 标签定义专门的别名，通过 alias 定义出来的别名和 name 属性定义的别名最终都是合并在一起处理的，所以<strong>这两种定义别名的方式最终是殊途同归</strong>。</li></ol><p>那么定义的别名是保存在哪里呢？</p><p>大家知道，Bean 解析出来之后被保存在容器中，别名其实也是一样的，容器中存在一个 aliasMap 专门用来保存 Bean 的别名，保存的格式是 alias-&gt;name，例如有一个 Bean 的名字是 user，别名是 userAlias，那么保存在 aliasMap 中就是 userAlias-&gt;user。</p><p>举个简单例子：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.demo.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user4,user5,user6"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"user2"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user2"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"user3"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在上面这段定义中，user2、user3、user4、user5、user6 都是别名。</p><h2 id="2-AliasRegistry"><a href="#2-AliasRegistry" class="headerlink" title="2. AliasRegistry"></a>2. AliasRegistry</h2><h3 id="2-1-AliasRegistry"><a href="#2-1-AliasRegistry" class="headerlink" title="2.1 AliasRegistry"></a>2.1 AliasRegistry</h3><p>Spring 中为别名的处理提供了 AliasRegistry 接口，这个接口中提供了别名处理的主要方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AliasRegistry</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(String name, String alias)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeAlias</span><span class="hljs-params">(String alias)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlias</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>registerAlias：这个方法用来添加别名，核心逻辑就是向 aliasMap 中添加数据。</li><li>removeAlias：这个方法用来从 aliasMap 中移除一个别名。</li><li>isAlias：判断给定的 name 是否是一个别名。</li><li>getAliases：根据给定的名字去获取所有的别名。</li></ul><p>方法就这四个，看一下这个接口的实现类有哪些。</p><p><img src="http://img.itboyhub.com/2022/08/AliasRegistry202308261044.png" alt></p><p>大家看到，AliasRegistry 的实现类其实还是蛮多的，但是大部分都是容器，真正实现了 AliasRegistry 中四个方法的只有 SimpleAliasRegistry，其他的容器大部分其实都是为了具备别名管理的能力，继承了 SimpleAliasRegistry。</p><p>所以真正给我们整活的其实是 SimpleAliasRegistry。</p><h3 id="2-2-SimpleAliasRegistry"><a href="#2-2-SimpleAliasRegistry" class="headerlink" title="2.2 SimpleAliasRegistry"></a>2.2 SimpleAliasRegistry</h3><p>SimpleAliasRegistry 类中的内容比较多，为了讲解方便，我就挨个贴属性和方法出来，贴出来后和大家分享。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);</span><br></pre></td></tr></table></figure><p>首先，SimpleAliasRegistry 中定义了一个 aliasMap，这个就是用来保存别名的，这是一个 Map 集合，接下来所有的操作都是围绕这个集合展开。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAlias</span><span class="hljs-params">(String alias)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.aliasMap) &#123;</span><br><span class="line">String name = <span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line"><span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No alias '"</span> + alias + <span class="hljs-string">"' registered"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来移除别名，移除的思路很简单，就是从 aliasMap 中移除数据即可，如果 remove 方法返回值为 null 那就说明要移除的别名不存在，那么直接抛出异常。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlias</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.aliasMap.containsKey(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是判断是否包含某一个别名，这个判断简单。有一个跟它容易产生歧义的方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAlias</span><span class="hljs-params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">String registeredName = <span class="hljs-keyword">this</span>.aliasMap.get(alias);</span><br><span class="line"><span class="hljs-keyword">return</span> ObjectUtils.nullSafeEquals(registeredName, name) ||</span><br><span class="line">(registeredName != <span class="hljs-keyword">null</span> &amp;&amp; hasAlias(name, registeredName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是判断给定的 name 和 alias 之间是否具备关联关系。判断的逻辑就是先去 aliasMap 中，根据 alias 查出来这个 alias 所对应的真实 beanName，即 registeredName，然后判断 registeredName 和 name 是否相等，如果相等就直接返回，如果不相等就继续递归调用，为什么要递归呢？因为 aliasMap 中存在的别名可能是这样的：</p><ul><li>a-&gt;b</li><li>b-&gt;c</li><li>c-&gt;d</li></ul><p>即 a 是 b 的别名，b 是 c 的别名，c 是 d 的别名，现在如果想要判断 a 和 d 之间的关系，那么根据 a 查出来的 b 显然不等于 d，所以要继续递归，再根据 b 查 c，根据 c 查到 d，这样就能确定 a 和 d 是否有关系了。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> String[] getAliases(String name) &#123;</span><br><span class="line">List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.aliasMap) &#123;</span><br><span class="line">retrieveAliases(name, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">retrieveAliases</span><span class="hljs-params">(String name, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.forEach((alias, registeredName) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">result.add(alias);</span><br><span class="line">retrieveAliases(alias, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAliases 方法是根据传入的 name 找到其对应的别名，但是由于别名可能存在多个，所以调用 retrieveAliases 方法递归去查找所有的别名，将找到的别名都存入到一个集合中，最终将集合转为数组返回。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForAliasCircle</span><span class="hljs-params">(String name, String alias)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (hasAlias(alias, name)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot register alias '"</span> + alias +</span><br><span class="line"><span class="hljs-string">"' for name '"</span> + name + <span class="hljs-string">"': Circular reference - '"</span> +</span><br><span class="line">name + <span class="hljs-string">"' is a direct or indirect alias for '"</span> + alias + <span class="hljs-string">"' already"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来检查别名是否存在死结，即 a 是 b 的别名，b 是 a 的别名这种情况。检查的方式很简单，就是调用 hasAlias 方法，但是将传入的两个参数颠倒过来就可以了。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resolveAliases</span><span class="hljs-params">(StringValueResolver valueResolver)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.aliasMap) &#123;</span><br><span class="line">Map&lt;String, String&gt; aliasCopy = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-keyword">this</span>.aliasMap);</span><br><span class="line">aliasCopy.forEach((alias, registeredName) -&gt; &#123;</span><br><span class="line">String resolvedAlias = valueResolver.resolveStringValue(alias);</span><br><span class="line">String resolvedName = valueResolver.resolveStringValue(registeredName);</span><br><span class="line"><span class="hljs-keyword">if</span> (resolvedAlias == <span class="hljs-keyword">null</span> || resolvedName == <span class="hljs-keyword">null</span> || resolvedAlias.equals(resolvedName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!resolvedAlias.equals(alias)) &#123;</span><br><span class="line">String existingName = <span class="hljs-keyword">this</span>.aliasMap.get(resolvedAlias);</span><br><span class="line"><span class="hljs-keyword">if</span> (existingName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (existingName.equals(resolvedName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"Cannot register resolved alias '"</span> + resolvedAlias + <span class="hljs-string">"' (original: '"</span> + alias +</span><br><span class="line"><span class="hljs-string">"') for name '"</span> + resolvedName + <span class="hljs-string">"': It is already registered for name '"</span> +</span><br><span class="line">registeredName + <span class="hljs-string">"'."</span>);</span><br><span class="line">&#125;</span><br><span class="line">checkForAliasCircle(resolvedName, resolvedAlias);</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.put(resolvedAlias, resolvedName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!registeredName.equals(resolvedName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.put(alias, resolvedName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是处理别名是占位符的情况，例如当引入了一个 <code>.properties</code> 文件之后，那么在配置别名的时候就可以引用 <code>.properties</code> 中的变量，那么上面这个方法就是用来解析变量的。</p><p>例如下面这种情况，我有一个 alias.properties，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=user</span><br><span class="line">alias=javaboy</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中使用这个 properties 文件，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:alias.properties"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"$&#123;name&#125;"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"$&#123;alias&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对于这种情况，一开始存入到 aliasMap 中的就是占位符了，resolveAliases 方法就是要将这些占位符解析为具体的字符串。</p><p>大家看到，首先这里将 aliasMap 复制一份，生成一个 aliasCopy，然后进行遍历。在遍历时，根据 valueResolver 将引用使用的占位符解析为真正的字符，如果解析出来的。如果解析出来的 name 和别名是相同的，那么显然是有问题的，就需要把这个别名移除掉。</p><p>继续判断，如果解析出来的别名和原本的别名不相等（说明别名使用了占位符），那么就去检查一下这个别名对应的 name，如果这个 name 已经存在，且等于占位符解析出来的 name，说明这个别名已经被定义过了，即重复定义，那么就把别名移除掉即可。如果这个别名指向的 name 和占位符解析出来的 name 不相等，说明试图让一个别名指向两个 bean，那么就直接抛出异常了。</p><p>如果解析出来的别名还没有指向 name 属性的话，那么就正常处理，检查是否存在死结、移除带占位符的别名，存入解析之后的别名。</p><p>最后，如果原本的名称和解析之后的属性名称不相等，那么就直接保存这个别名即可。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(String name, String alias)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.aliasMap) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">String registeredName = <span class="hljs-keyword">this</span>.aliasMap.get(alias);</span><br><span class="line"><span class="hljs-keyword">if</span> (registeredName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot define alias '"</span> + alias + <span class="hljs-string">"' for name '"</span> +</span><br><span class="line">name + <span class="hljs-string">"': It is already registered for name '"</span> + registeredName + <span class="hljs-string">"'."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">checkForAliasCircle(name, alias);</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是使用最多的别名注册了，传入的参数分别是 bean 的 name 和 alias，如果 alias 跟 name 相等，二话不说直接移除，这个 alias 有问题。</p><p>否则就去查询这个 alias，检查这个 alias 是否已经有对应的 name 了，如果有，且等于传入的 name，那么直接返回就行了，不用注册，因为已经注册过了；如果有且不等于传入的 name，那么就抛出异常，因为一个 alias 不能指向两个 name。最后就是检查和保存了。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">canonicalName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">String canonicalName = name;</span><br><span class="line">String resolvedName;</span><br><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line">resolvedName = <span class="hljs-keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line"><span class="hljs-keyword">if</span> (resolvedName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">canonicalName = resolvedName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">while</span> (resolvedName != <span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来解析出来别名里边顶格的名字，例如有一个 bean 有很多别名，a-&gt;b,b-&gt;c,c-&gt;d，那么这个方法的目的就是传入 a、b、c 中任意一个，返回 d 即可。因为 Spring 容器在处理的时候，并不用管这么多别名问题，容器只需要专注一个名字即可，因为最后一个别名实际上就是指向真实的 beanId 了，所以最终拿到的 bean 名称其实相当于 bean 的 ID 了。</p><p>别名的处理主要就是这些方法。</p><h2 id="3-原理分析"><a href="#3-原理分析" class="headerlink" title="3. 原理分析"></a>3. 原理分析</h2><p>前面我们说了，别名的来源主要是两个地方：name 属性和 alias 标签，我们分别来看。</p><h3 id="3-1-name-处理"><a href="#3-1-name-处理" class="headerlink" title="3.1 name 处理"></a>3.1 name 处理</h3><p>对于 name 属性的处理，有两个地方，一个是在 bean 定义解析的时候，将 name 属性解析为 alias，具体在 BeanDefinitionParserDelegate#parseBeanDefinitionElement 方法中（这个方法在之前跟大家讲 bean 的默认名称生成策略的时候，见过）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就从 XML 节点中提取出来 name 属性，然后切分为一个数组，并将之存入到 aliases 属性中。接下来在后续的 BeanDefinitionReaderUtils#registerBeanDefinition 方法中，再把 aliases 中的值注册一下，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="hljs-keyword">if</span> (aliases != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 XML 中的 name 属性是如何变为别名的。</p><h3 id="3-2-别名标签处理"><a href="#3-2-别名标签处理" class="headerlink" title="3.2 别名标签处理"></a>3.2 别名标签处理</h3><p>别名的另一个来源是别名标签，在 Spring 解析 XML 标签的时候，有针对别名标签的专门处理，具体位置是在 DefaultBeanDefinitionDocumentReader#parseDefaultElement 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="hljs-comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会去判断标签的类型，如果是别名，就调用 processAliasRegistration 方法进行处理：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processAliasRegistration</span><span class="hljs-params">(Element ele)</span> </span>&#123;</span><br><span class="line">String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line"><span class="hljs-keyword">boolean</span> valid = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">getReaderContext().error(<span class="hljs-string">"Name must not be empty"</span>, ele);</span><br><span class="line">valid = <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">getReaderContext().error(<span class="hljs-string">"Alias must not be empty"</span>, ele);</span><br><span class="line">valid = <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (valid) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="hljs-string">"Failed to register alias '"</span> + alias +</span><br><span class="line"><span class="hljs-string">"' for bean with name '"</span> + name + <span class="hljs-string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里也是从 XML 文件中的别名标签上，提取出来 name 和 alias 属性值，最后调用 registerAlias 方法进行注册。</p><p>好啦，这就是 Spring 中关于别名的处理流程啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来和小伙伴们聊一聊 Spring 中关于 Bean 别名的处理逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一段让人抓心挠肝的源码</title>
    <link href="http://www.javaboy.org/2023/0904/instanceof-optimize.html"/>
    <id>http://www.javaboy.org/2023/0904/instanceof-optimize.html</id>
    <published>2023-09-04T09:20:11.000Z</published>
    <updated>2023-09-12T09:40:36.003Z</updated>
    
    <content type="html"><![CDATA[<p>加了松哥微信的小伙伴可能注意到松哥前两天发的一个朋友圈了，就是我在录制 Spring 源码的时候，发现了这样一段代码：</p><a id="more"></a><p>为了大家阅读方便，我这里只贴出来一些关键的部分：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getObjectForBeanInstance</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//省略</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean&lt;?&gt; factoryBean)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line"><span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line">object = getObjectFromFactoryBean(factoryBean, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里有一个比较好玩的地方就是使用了 JDK16 中引入的增强类型推断，以前我们用 instanceof 的时候可能是这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> B)&#123;</span><br><span class="line">  B b = (B)a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样比较麻烦，所以从 JDK16 开始，支持一种新的写法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> B b)&#123;</span><br><span class="line">  <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码跟上面的代码的作用是一模一样的。</p><p>最上面的 Spring 源码其实就是用了这个最新的写法。</p><p>但是！！！</p><p>我今天想和各位小伙伴聊的其实还不是这个问题，而是在上面的 Spring 源码中，factoryBean 变量是在 if 分支中定义的，按理说，它的作用域就存在于 if 分支中，但是各位小伙伴注意，factoryBean 变量却可以在下面的 if 中使用，这是咋回事呢？</p><p>大家看下下面这个截图，这个是 Spring 框架在 2022.01.26 的提交日志，就是这一次提交修改了上面这个 getObjectForBeanInstance 方法：</p><p><img src="http://img.itboyhub.com/2022/08/20230902192108.png" alt></p><p>从这段变更中，我们其实可以看到，在之前的 Spring 源码中，是有专门的一行 <code>FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</code> 去做类型转换的，然后在接下来的方法中去使用该变量，但是现在没有这样一句了，很明显，现在是在 if 中做 instanceof 判断时顺手定义的 factoryBean 变量，在下面的 if 分支中使用了，这和我们理解的 Java 中变量的作用域似乎不太一样。</p><p>这是咋回事呢？</p><p>前两天我发个朋友圈之后，有小伙伴说这是语法糖，这显然不是，因为如果是语法糖，这很容易造成歧义，变量的作用域岂不是全乱了？</p><p>也有小伙伴说这是新特性，这个很聪明，不认识的写法统一都是新特性。但是新在哪里？什么样的情况下可以在 if 之外使用 if 判断条件里声明的变量？什么样的情况下不可以？</p><p><strong>今天这个问题松哥就不说教了，欢迎各位小伙伴评论区说出你的答案！</strong></p><p><strong>松哥会从评论区选出来 3 位小伙伴，各送一本《Spring Boot+Spring Cloud+Vue+Element 项目实战·徐丽健著》。</strong></p><p>松哥最近在录的 Spring 源码视频，不是枯燥的源码分析，我会从每一个组件的用法入手，跟各位小伙伴分析它怎么用，为什么这样用，它的原理是什么，从浅到深，一步一步推理。在这个过程中也会小伙伴们聊一聊 Spring6 中引入的一些 JDK 新语法，源码阅读技巧分析技巧等，感兴趣的小伙伴戳<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">这里</a>查看详情上车吧～<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加了松哥微信的小伙伴可能注意到松哥前两天发的一个朋友圈了，就是我在录制 Spring 源码的时候，发现了这样一段代码：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
      <category term="JDK16" scheme="http://www.javaboy.org/tags/JDK16/"/>
    
  </entry>
  
</feed>
