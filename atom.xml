<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2022-12-20T11:05:46.170Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于幻读，该捋清楚了！</title>
    <link href="http://www.javaboy.org/2022/1219/mysql-phantom-rows.html"/>
    <id>http://www.javaboy.org/2022/1219/mysql-phantom-rows.html</id>
    <published>2022-12-19T10:25:17.000Z</published>
    <updated>2022-12-20T11:05:46.170Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>小伙伴们都知道，MySQL 有四种不同的隔离级别，四种不同的隔离级别会带来三种不同的问题，今天我想再和大家捋一捋这个问题。</p><a id="more"></a><h2 id="1-隔离级别"><a href="#1-隔离级别" class="headerlink" title="1. 隔离级别"></a>1. 隔离级别</h2><h3 id="1-1-理论"><a href="#1-1-理论" class="headerlink" title="1.1 理论"></a>1.1 理论</h3><p>MySQL 中事务的隔离级别一共分为四种，分别如下：</p><ul><li>序列化（SERIALIZABLE）</li><li>可重复读（REPEATABLE READ）</li><li>提交读（READ COMMITTED）</li><li>未提交读（READ UNCOMMITTED）</li></ul><p>四种不同的隔离级别含义分别如下：</p><ol><li>SERIALIZABLE</li></ol><blockquote><p>如果隔离级别为序列化，则用户之间通过一个接一个顺序地执行当前的事务，这种隔离级别提供了事务之间最大限度的隔离。</p></blockquote><ol start="2"><li>REPEATABLE READ</li></ol><blockquote><p>在可重复读在这一隔离级别上，事务不会被看成是一个序列。不过，当前正在执行事务的变化仍然不能被外部看到，也就是说，如果用户在另外一个事务中执行同条 SELECT 语句数次，结果总是相同的。（因为正在执行的事务所产生的数据变化不能被外部看到）。</p></blockquote><ol start="3"><li>READ COMMITTED</li></ol><blockquote><p>READ COMMITTED 隔离级别的安全性比 REPEATABLE READ 隔离级别的安全性要差。处于 READ COMMITTED 级别的事务可以看到其他事务对数据的修改。也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个 SELECT 语句可能返回不同的结果。</p></blockquote><ol start="4"><li>READ UNCOMMITTED</li></ol><blockquote><p>READ UNCOMMITTED 提供了事务之间最小限度的隔离。除了容易产生虚幻的读操作和不能重复的读操作外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，这就导致了大量的数据变化。</p></blockquote><p><strong>在 MySQL 数据库中，默认的事务隔离级别是 REPEATABLE READ。</strong></p><h3 id="1-2-SQL-实践"><a href="#1-2-SQL-实践" class="headerlink" title="1.2 SQL 实践"></a>1.2 SQL 实践</h3><p>接下来通过几条简单的 SQL 向读者验证上面的理论。</p><h4 id="1-2-1-查看隔离级别"><a href="#1-2-1-查看隔离级别" class="headerlink" title="1.2.1 查看隔离级别"></a>1.2.1 查看隔离级别</h4><p>通过如下 SQL 可以查看数据库实例默认的全局隔离级别和当前 session 的隔离级别：</p><p>MySQL8 之前使用如下命令查看 MySQL 隔离级别：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> @@GLOBAL.tx_isolation, @@tx_isolation;</span><br></pre></td></tr></table></figure><p>查询结果如图： </p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409102944.png" alt></p><p>可以看到，默认的隔离级别为 REPEATABLE-READ，全局隔离级别和当前会话隔离级别皆是如此。</p><p><strong>MySQL8 开始，通过如下命令查看 MySQL 默认隔离级别</strong>：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> @@GLOBAL.transaction_isolation, @@transaction_isolation;</span><br></pre></td></tr></table></figure><p>就是关键字变了，其他都一样。</p><p>通过如下命令可以修改隔离级别（建议开发者在修改时修改当前 session 隔离级别即可，不用修改全局的隔离级别）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure><p>上面这条 SQL 表示将当前 session 的数据库隔离级别设置为 READ UNCOMMITTED，设置成功后，再次查询隔离级别，发现当前 session 的隔离级别已经变了，如图1-2：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409103050.png" alt></p><p><strong>注意，如果只是修改了当前 session 的隔离级别，则换一个 session 之后，隔离级别又会恢复到默认的隔离级别，所以我们测试时，修改当前 session 的隔离级别即可。</strong></p><h4 id="1-2-2-READ-UNCOMMITTED"><a href="#1-2-2-READ-UNCOMMITTED" class="headerlink" title="1.2.2 READ UNCOMMITTED"></a>1.2.2 READ UNCOMMITTED</h4><h5 id="1-2-2-1-准备测试数据"><a href="#1-2-2-1-准备测试数据" class="headerlink" title="1.2.2.1 准备测试数据"></a>1.2.2.1 准备测试数据</h5><p>READ UNCOMMITTED 是最低隔离级别，这种隔离级别中存在<strong>脏读、不可重复读以及幻象读</strong>问题，所以这里我们先来看这个隔离级别，借此大家可以搞懂这三个问题到底是怎么回事。</p><p>下面分别予以介绍。</p><p>首先创建一个简单的表，预设两条数据，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409103216.png" alt></p><p>表的数据很简单，有 javaboy 和 itboyhub 两个用户，两个人的账户各有 1000 人民币。现在模拟这两个用户之间的一个转账操作。</p><p><strong>注意，如果读者使用的是 Navicat 的话，不同的查询窗口就对应了不同的 session，如果读者使用了 SQLyog 的话，不同查询窗口对应同一个 session，因此如果使用 SQLyog，需要读者再开启一个新的连接，在新的连接中进行查询操作。</strong></p><h5 id="1-2-2-2-脏读"><a href="#1-2-2-2-脏读" class="headerlink" title="1.2.2.2 脏读"></a>1.2.2.2 脏读</h5><p>一个事务读到另外一个事务还没有提交的数据，称之为脏读。具体操作如下：</p><ol><li>首先打开两个会话窗口，假设分别为 A 和 B。</li><li>执行如下 SQL，设置会话 A 的隔离级别为 <code>READ UNCOMMITTED</code>：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED;</span><br></pre></td></tr></table></figure><p>然后我们按照如下顺序执行 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409110028.png" alt></p><p>SQL1 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409110118.png" alt></p><p>SQL2 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409110154.png" alt></p><p>SQL3 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409110222.png" alt></p><p>可以看到，在 Session A 中看到了 Session B 尚未提交的事务。</p><p>这就是<strong>脏读</strong>问题。</p><h5 id="1-2-2-3-不可重复读"><a href="#1-2-2-3-不可重复读" class="headerlink" title="1.2.2.3 不可重复读"></a>1.2.2.3 不可重复读</h5><p>不可重复读是指一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。具体操作步骤如下（操作之前先将两个账户的钱都恢复为1000）：</p><p>首先打开两个查询会话 A 和 B ，并且将 A 的数据库事务隔离级别设置为 READ UNCOMMITTED。具体 SQL 参考上文，这里不赘述。</p><p>接下来执行如下 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409112642.png" alt></p><p>SQL1 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409112327.png" alt></p><p>SQL2 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409112729.png" alt></p><p>SQL3 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409112451.png" alt></p><p>可以看到，在 SessionA 中查询同一条记录，多次查询最终的结果可能不一样，这就是<strong>不可重复读</strong>。</p><p><strong>和脏读的区别在于，脏读是看到了其他事务未提交的数据，而不可重复读是看到了其他事务已经提交的数据（由于当前 SQL 也是在事务中，因此有可能并不想看到其他事务已经提交的数据）。</strong></p><h5 id="1-2-2-4-幻象读"><a href="#1-2-2-4-幻象读" class="headerlink" title="1.2.2.4 幻象读"></a>1.2.2.4 幻象读</h5><p>幻象读和不可重复读非常像，看名字就是产生幻觉了。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`age`</span> (<span class="hljs-string">`age`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>id 是主键，age 是唯一非空索引。</p><p>表中数据如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409113352.png" alt></p><p>现在我们有两个会话 Session A 和 Session B，Session A 隔离级别是 READ UNCOMMITTED，Session B 是默认的隔离级别，执行的 SQL 如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220409113818.png" alt></p><p>注意，在 SQL1 中用了一个当前读，按理说它会锁住 age 大于 80 的记录，其实也确实锁住了 89 和 99 这样的值，但是对于一开始就不存在的 100 就没能锁住了，这就导致在 SQL3 执行的时候，看到了 SQL2 插入的语句。</p><p>这就是<strong>幻读，幻读专指看到了新插入的行。</strong>。</p><p>看了上面的案例，大家应该明白了<strong>脏读</strong>、<strong>不可重复读</strong>以及<strong>幻读</strong>各自是什么含义了。</p><h4 id="1-2-3-READ-COMMITTED"><a href="#1-2-3-READ-COMMITTED" class="headerlink" title="1.2.3 READ COMMITTED"></a>1.2.3 READ COMMITTED</h4><p>和 READ UNCOMMITTED 相比，READ COMMITTED 主要解决了脏读的问题，对于不可重复读和幻象读则未解决。</p><p>将事务的隔离级别改为 <code>READ COMMITTED</code> 之后，重复上面关于脏读案例的测试，发现已经不存在脏读问题了；重复上面关于不可重复读案例的测试，发现不可重复读和幻读问题依然存在。</p><h4 id="1-2-4-REPEATABLE-READ"><a href="#1-2-4-REPEATABLE-READ" class="headerlink" title="1.2.4 REPEATABLE READ"></a>1.2.4 REPEATABLE READ</h4><p>和 READ COMMITTED 相比，REPEATABLE READ 进一步解决了不可重复读的问题，对于幻读问题，REPEATABLE READ 也有一个自己的方案。</p><p>具体是什么方案呢？松哥第二小节和大家细聊。</p><p><strong>注意，REPEATABLE READ 也是 InnoDB 引擎的默认数据库事务隔离级别</strong></p><h4 id="1-2-5-SERIALIZABLE"><a href="#1-2-5-SERIALIZABLE" class="headerlink" title="1.2.5 SERIALIZABLE"></a>1.2.5 SERIALIZABLE</h4><p>SERIALIZABLE 提供了事务之间最大限度的隔离，在这种隔离级别中，事务一个接一个顺序的执行，不会发生脏读、不可重复读以及幻象读问题，最安全。</p><p>如果设置当前事务隔离级别为 SERIALIZABLE，那么此时开启其他事务时，就会阻塞，必须等当前事务提交了，其他事务才能开启成功，因此前面的脏读、不可重复读以及幻象读问题这里都不会发生。</p><h2 id="2-幻读怎么解决"><a href="#2-幻读怎么解决" class="headerlink" title="2. 幻读怎么解决"></a>2. 幻读怎么解决</h2><p>脏读、不可重复读这两个问题通过修改事务的隔离级别就可以解决，那么幻读该如何解决呢？MySQL 中提出了 Next-Key Lock 来解决幻读问题，当然这个方案也只在 REPEATABLE READ 这个隔离级别下生效。要把这个问题理解透，你得搞明白三把锁：Record Lock、Gap Lock 以及 Next-Key Lock。</p><h3 id="2-1-Record-Lock"><a href="#2-1-Record-Lock" class="headerlink" title="2.1 Record Lock"></a>2.1 Record Lock</h3><p>Record Lock 也就是我们所说的记录锁，记录锁是对索引记录的锁，注意，它是针对<strong>索引记录</strong>，即它只锁定记录这一行数据。</p><p>例如如下一条 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span>=<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;</span><br></pre></td></tr></table></figure><p>注意，id 是索引，id 如果不是索引，上面这条 SQL 所加的排他锁就不是一个 Record Lock。</p><p>我们来看如下一个例子：</p><p>首先我们将系统变量 <code>innodb_status_output_locks</code> 设置为 ON，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220403232144.png" alt></p><p>接下来我们执行如下 SQL，锁定一行数据，此时会自动为表加上 IX 锁：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220403232442.png" alt></p><p>接下来我们在一个新的会话中执行如下指令来查看 InnoDB 存储引擎的情况：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G</span><br></pre></td></tr></table></figure><p>输出的信息很多，我们重点关注 TRANSACTIONS，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220403233056.png" alt></p><p>可以看到：</p><ul><li><code>TABLE LOCK table test08.user trx id 3564804 lock mode IX</code>：这句就是说事务 id 为 3564804 的事务，为 user 表添加了意向排他锁（IX）。</li><li><code>RECORD LOCKS space id 851 page no 3 n bits 80 index PRIMARY of table test08.user trx id 3564804 lock_mode X locks rec but not gap</code>：这个就是一个锁结构的记录，这里的索引是 PRIMARY，加的锁也是正儿八经的记录锁（not gap）。</li></ul><p>看到了 <code>LOCKS REC BUT NOT GAP</code>，就说明这是一个记录锁。</p><p>那么这个 Record Lock 和我们之前所讲的 S 锁以及 X 锁有什么区别呢？S 锁是共享锁，X 锁是排他锁，当我们加 S 锁或者 X 锁的时候，如果用到了索引，锁加在了某一条具体的记录上，那么这个锁也是一个记录锁（其实，记录锁，S 锁，X 锁，概念有一些重复的地方，但是描述的重点不一样）。</p><p>或者也可以理解为记录锁又细分为 S 锁和 X 锁，它们之间的兼容性如下图：</p><table><thead><tr><th style="text-align:center">兼容性</th><th style="text-align:center">S 型记录锁</th><th style="text-align:center">X 型记录锁</th></tr></thead><tbody><tr><td style="text-align:center">S 型记录锁</td><td style="text-align:center">兼容</td><td style="text-align:center">不兼容</td></tr><tr><td style="text-align:center">X 型记录锁</td><td style="text-align:center">不兼容</td><td style="text-align:center">不兼容</td></tr></tbody></table><h3 id="2-2-Gap-Lock"><a href="#2-2-Gap-Lock" class="headerlink" title="2.2 Gap Lock"></a>2.2 Gap Lock</h3><p>Gap Lock 也叫做间隙锁，它的存在可以解决幻读问题，另外需要注意，Gap Lock 也只在 REPEATABLE READ 隔离级别下有效。先来看看什么是幻读，我们来看如下一个表格：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405102112.png" alt></p><p>有两个会话，A 和 B，先在会话 A 中开启事务，然后查询 age 为 99 的用户总数，注意使用当前读，因为在默认的隔离级别下，默认的快照读并不能读到其他事务提交的数据，至于快照读和当前读的区别，大家参考：<a href="https://mp.weixin.qq.com/s/MJGUSFHrz-2-eEvVtK-4Iw" target="_blank" rel="noopener">S 锁与 X 锁，当前读与快照读！</a>。当会话 A 中第一次查询过后，会话 B 中向数据库添加了一行记录，等到会话 A 中第二次查询的时候，就查到了和第一次查询不一样的结果，这就是幻读（注意幻读专指数据插入引起的不一致）。</p><p><strong>在 MySQL 默认的隔离级别 REPEATABLE READ 下，上图所描述的情况无法复现。无法复现的原因在于，在 MySQL 的 REPEATABLE READ 隔离级别中，它已经帮我们解决了幻读问题，解决的方案就是 Gap Lock。</strong></p><p>大家想想，之所以出现幻读的问题，是因为记录之间存在缝隙，用户可以往这些缝隙中插入数据，这就导致了幻读问题，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405104923.png" alt></p><p>如图所示，id 之间有缝隙，有缝隙就有漏洞。前面我们所说的记录锁只能锁住一条具体的记录，但是对于记录之间的空隙却无能无力，这就导致了幻读（其他事务可往缝隙中插入数据）。</p><p>现在 Gap Lock 间隙锁，就是要把这些记录之间的间隙也给锁住，间隙锁住了，就不用担心幻读问题了，<strong>这也是 Gap Lock 存在的意义</strong>。</p><p>给一条记录加 Gap Lock，是锁住了这条记录前面的空隙，例如给 id 为 1 的记录加 Gap Lock，锁住的范围是 (-∞,1)，给 id 为 3 的记录加 Gap Lock，锁住的范围是 (1,3)，那么 id 为 10 后面的空隙怎么锁定呢？MySQL 提供了一个 Supremum 表示当前页面中的最大记录，所以最后针对 Supremum 锁住的范围就是 (10,+∞)，这样，所有的间隙都被覆盖到了，由于锁定的是间隙，所以都是开区间。</p><p>那么我们怎么样能看到 Gap Lock 呢？我给大家举一个简单的例子，假设我有如下一张表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`age`</span> (<span class="hljs-string">`age`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">5</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>一个简单的表，id 是主键，age 是普通索引，表中有如下几条记录：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405155210.png" alt></p><p>接下来我们执行如下 SQL，锁定一行数据，此时也会产生间隙锁：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405160054.png" alt></p><p>接下来我们在一个新的会话中执行如下指令来查看 InnoDB 存储引擎的情况：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status\G</span><br></pre></td></tr></table></figure><p>输出的信息很多，我们重点关注 TRANSACTIONS，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405160201.png" alt></p><p>红色框选中的，就是一个间隙锁的加锁记录，可以看到，在某一个记录之前加了间隙锁。</p><p>这就是间隙锁。非常重要的一点需要大家牢记：<strong>Gap Lock 只在 REPEATABLE READ 隔离级别下有效</strong>。</p><h3 id="2-3-Next-Key-Lock"><a href="#2-3-Next-Key-Lock" class="headerlink" title="2.3 Next-Key Lock"></a>2.3 Next-Key Lock</h3><p>以下内容都是基于 MySQL 默认的隔离级别 REPEATABLE READ。</p><p>如果我们既想锁定一行，又想锁定行之间的记录，那么就是 Next-Key Lock 了，换言之，Next-Key Lock 是 Record Lock 和 Gap Lock 的结合体。</p><p>正常来说，我们<strong>加行锁的基本单位就是 Next-Key Lock</strong>，即既有记录锁又有间隙锁，但是有时候 Next-Key Lock 会退化，我们通过几个简单的例子来分析一下。</p><p>首先我们来看看 Next-Key Lock 的加锁规则：</p><ol><li>锁的范围是左开右闭。</li><li>如果是唯一非空索引的等值查询，Next-Key Lock 会退化成 Record Lock。</li><li>普通索引上的等值查询，向后遍历时，最后一个不满足等值条件的时候，Next-Key Lock 会退化成 Gap Lock。</li></ol><p>我们通过几个简单的例子来分析下。</p><h4 id="2-3-1-唯一非空索引"><a href="#2-3-1-唯一非空索引" class="headerlink" title="2.3.1 唯一非空索引"></a>2.3.1 唯一非空索引</h4><p>假设我有一个学生表，学生表中有学生的姓名和成绩，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`student`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`score`</span> <span class="hljs-keyword">double</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">KEY</span> <span class="hljs-string">`score`</span> (<span class="hljs-string">`score`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>id 是主键，score 是成绩，其中 score 是唯一非空索引。</p><p>现在表中有如下数据：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405161748.png" alt></p><p>假设我们执行如下 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405162034.png" alt></p><p>在这个例子中，由于 score 是唯一非空索引，所以 Next-Key Lock 会退化成 Record Lock，换句话说，这行 SQL 只给 score 为 90 的记录加锁，不存在 Gap Lock，即我们新开一个会话，插入一条 score 为 88 的记录也是 OK 的。</p><p>不过这里有一个特例，如果锁定的是一个不存在的记录，那么也会产生间隙锁，例如下面这个：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405171719.png" alt></p><p>由于并不存在 score 为 91 的记录，所以这里会产生一个范围为 (90,95) 的间隙锁，我们执行如下 SQL 可以验证：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405171943.png" alt></p><p>可以看到，90.1、94.9 都会被阻塞（我按了 Ctrl C，所以大家看到查询终止）。</p><p>90、95 则不符合唯一非空索引的条件。</p><p>95.1 则可以插入成功。</p><p>没问题。</p><h4 id="2-3-2-非空索引"><a href="#2-3-2-非空索引" class="headerlink" title="2.3.2 非空索引"></a>2.3.2 非空索引</h4><p>现在我们重新开始，将 score 索引改为普通索引，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`student`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`score`</span> <span class="hljs-keyword">double</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`score`</span> (<span class="hljs-string">`score`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">8</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>数据还是跟前面一样，此时我们来执行如下 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405163124.png" alt></p><p>我们来分析下。</p><p>此时要锁定的是 id 为 90 的记录，那么首先加间隙锁，上一个 score 为 89，所以这次加的间隙锁范围是 (89,90)，同时要锁定 id 为 90 的记录，所以进一步优化为 (89,90]。</p><p>同时，这里还有一条规则，就是满足条件的上一条记录，也需要被锁住，所以最终的锁范围就是 [89,90]。</p><p>由于 score 不是唯一性索引，所以还需要继续向后查找，找到的下一条记录是 95，由于此时 Next-Key Lock 会退化成 Gap Lock，所以锁定的范围是 (90,95)。综上，最终锁定的范围是 [89,95)。</p><p>接下来我们可以新开一个会话，我们分别尝试添加如下数据看看是否能够添加成功：</p><p>可以看到，score 为 88 是可以的，但是为 89.1 就不行。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405163722.png" alt></p><p>score 为 95 也是可以的，但是为 94.9 就不行。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405163835.png" alt></p><p>再试一下 89 是否可以：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405170523.png" alt></p><p>说明我们上面分析的加锁范围是正确的。</p><p>再来看如下一条 SQL：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405164654.png" alt></p><p>跟前面的案例相比，这次多了 <code>limit 1</code>，limit 1 表示只要一条记录，所以这次查找到 90 之后就不会再往后查找了，那么最终的锁就是间隙锁+一个记录锁，最终的范围就是 [89,90]。</p><p>此时新开一个会话，分别插入 score 为 88.9、89、90、91 的 记录，验证我们上面所分析的加锁范围：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405170833.png" alt></p><p>88.9 和 89 的插入结果跟我们预想的一致。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220405171002.png" alt></p><p>可以看到，这里 90 也能插入，能插入的原因是因为缺乏 90 往后的间隙锁。</p><p>这三把锁搞明白了，也就理解了在 REPEATABLE READ 中，是如何解决幻读的了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>总的来说，隔离级别和脏读、不可重复读以及幻象读的对应关系如下：</p><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻象读</th></tr></thead><tbody><tr><td style="text-align:left">READ UNCOMMITTED</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">READ COMMITED</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">REPEATABLE READ</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td></tr></tbody></table><p>性能关系如图：</p><p><img src="http://img.itboyhub.com/2021/07/1-72222.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;小伙伴们都知道，MySQL 有四种不同的隔离级别，四种不同的隔离级别会带来三种不同的问题，今天我想再和大家捋一捋这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Flowable系列杀青啦！251 页PDF文档免费下载</title>
    <link href="http://www.javaboy.org/2022/1216/tienchin-flowable-pdf.html"/>
    <id>http://www.javaboy.org/2022/1216/tienchin-flowable-pdf.html</id>
    <published>2022-12-16T10:25:04.000Z</published>
    <updated>2022-12-20T11:05:42.603Z</updated>
    
    <content type="html"><![CDATA[<p>松哥今年最早是在 4 月份发过一篇 Flowable 教程，中间基本上就断了没再更新了，9 月份开始重新拾起，一口气更新了两个多月，如今，这个系列总算完结杀青啦。</p><a id="more"></a><p>为了方便小伙伴们阅读学习，我把这个系列的文章做成了 PDF，一共是 251 页，供大家免费下载学习，我们先来瞅一眼目录吧：</p><p><img src="http://img.itboyhub.com/2022/08/20221214163344.png" alt></p><p>251 页，差不多一本薄薄的书了，这本电子书中不仅有 Flowable 的基础用法，最后也有一个完整的请假案例可供小伙伴们参考，小伙伴们一定不要错过哦。</p><p>当然，考虑到有的小伙伴可能希望阅读在线的教程，所以，松哥也准备了文章索引，如下：</p><ol><li><a href="https://mp.weixin.qq.com/s/H1TNq5eUEN4H-B0oR12mpg" target="_blank" rel="noopener">工作流入门</a></li><li><a href="https://mp.weixin.qq.com/s/VOGB9JRQKxjs1bVxYJuYpA" target="_blank" rel="noopener">Flowable源码编译</a></li><li><a href="https://mp.weixin.qq.com/s/tc5OdOUONt5qPbT9ZbmQYQ" target="_blank" rel="noopener">Flowable-UI</a></li><li><a href="https://mp.weixin.qq.com/s/5Mcs73Xn8ZZi3S0euPnoSg" target="_blank" rel="noopener">Flowable表结构分析</a></li><li><a href="https://mp.weixin.qq.com/s/9S7RLcE_Xox6i3yju3q_dw" target="_blank" rel="noopener">用户和用户组</a></li><li><a href="https://mp.weixin.qq.com/s/EgbDiYjURD9yU0oFMeZowA" target="_blank" rel="noopener">流程部署与删除</a></li><li><a href="https://mp.weixin.qq.com/s/3UTii7TzyPGJIOc-68YThw" target="_blank" rel="noopener">流程实例</a></li><li><a href="https://mp.weixin.qq.com/s/uXgorkmhHcDq_VTHJNLhZw" target="_blank" rel="noopener">流程历史</a></li><li><a href="https://mp.weixin.qq.com/s/WSKc6LVtnCo7dgSbqcUqeg" target="_blank" rel="noopener">流程暂停与激活</a></li><li><a href="https://mp.weixin.qq.com/s/CbqaQMMDlJ9HLuH-bOP3ew" target="_blank" rel="noopener">DataObject 与租户</a></li><li><a href="https://mp.weixin.qq.com/s/f55gKMhvp1AQ47Bw1gaPMA" target="_blank" rel="noopener">ReceiveTask</a></li><li><a href="https://mp.weixin.qq.com/s/GnYHXlLrzxCBYvo0uv_j_w" target="_blank" rel="noopener">设置任务处理人的四种方式</a></li><li><a href="https://mp.weixin.qq.com/s/wCPkTnm93kiobSOaK_LpOw" target="_blank" rel="noopener">任务认领与回退</a></li><li><a href="https://mp.weixin.qq.com/s/ftVZghFQKaukZI6H0DhbOg" target="_blank" rel="noopener">按角色分配任务</a></li><li><a href="https://mp.weixin.qq.com/s/k4zi7PhJfQFVKDWGBc7K2g" target="_blank" rel="noopener">ServiceTask</a></li><li><a href="https://mp.weixin.qq.com/s/BBuJU5EZRJYwWMmcPT96_g" target="_blank" rel="noopener">ScriptTask</a></li><li><a href="https://mp.weixin.qq.com/s/VqQ0Zp-YXvydZb6Gy5Iyag" target="_blank" rel="noopener">三种网关</a></li><li><a href="https://mp.weixin.qq.com/s/qvm8tGucb7V_JOzAyiXcmQ" target="_blank" rel="noopener">流程变量设置</a></li><li><a href="https://mp.weixin.qq.com/s/1qgDJ63Q09vNOzMGpzA-iA" target="_blank" rel="noopener">历史流程</a></li><li><a href="https://mp.weixin.qq.com/s/jHLj_vwF5yiYWz3E8wRUWw" target="_blank" rel="noopener">定时器</a></li><li><a href="https://mp.weixin.qq.com/s/gk_hp8YUZB5L3gpdy7aCPw" target="_blank" rel="noopener">动态表单</a></li><li><a href="https://mp.weixin.qq.com/s/DKPc9SWk6nWqLS9RQLV79Q" target="_blank" rel="noopener">HTML表单</a></li><li><a href="https://mp.weixin.qq.com/s/KnUH8uerQa0fWPdAkl8zCQ" target="_blank" rel="noopener">JSON表单</a></li><li><a href="https://mp.weixin.qq.com/s/lZ4l_1WGNP5S4g8QBTUdAg" target="_blank" rel="noopener">会签与或签</a></li><li><a href="https://mp.weixin.qq.com/s/ETgKwsaceoUDp3cqKVtVtQ" target="_blank" rel="noopener">绘制实时流程图</a></li><li><a href="https://mp.weixin.qq.com/s/gd66C3YsCugm5_hZAqbMWw" target="_blank" rel="noopener">bpmn.js</a></li><li><a href="https://mp.weixin.qq.com/s/nr4jUGd4ReEE0FzjOx_D_g" target="_blank" rel="noopener">流程图绘制工具</a></li><li><a href="https://mp.weixin.qq.com/s/Pd0MEkZu12vdmGGBT9ZV-w" target="_blank" rel="noopener">SpringBoot+Vue+Flowable</a></li><li><a href="https://mp.weixin.qq.com/s/OTqIsuvCltIYkSYZCQgk3Q" target="_blank" rel="noopener">SpringSecurity+Vue+Flowable</a></li></ol><p>好啦，这是在线的文章索引。</p><p>文档资料都是免费的，这套文档也有配套的视频教程，手把手教大家玩 Flowable，视频目录如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">103.【workflow】状态机解决流程问题.mp4</span><br><span class="line">104.【workflow】报销审批流程.mp4</span><br><span class="line">105.【workflow】笔记本电脑生产流程.mp4</span><br><span class="line">106.【workflow】三大主流工作流.mp4</span><br><span class="line">107.【workflow】BPMN流程图规范.mp4</span><br><span class="line">108.【workflow】BPMN流程图元素.mp4</span><br><span class="line">109.【workflow】常见的流程绘制工具梳理.mp4</span><br><span class="line">110.【workflow】使用IDEA插件绘制流程图.mp4</span><br><span class="line">111.【workflow】分析流程图的XML文件.mp4</span><br><span class="line">112.【workflow】flowable-ui两种安装方式.mp4</span><br><span class="line">113.【workflow】flowable-ui四大核心功能.mp4</span><br><span class="line">114.【workflow】flowable-ui身份管理.mp4</span><br><span class="line">115.【workflow】flowable-ui管理员功能.mp4</span><br><span class="line">116.【workflow】flowable-ui建模器应用程序-报销流程介绍.mp4</span><br><span class="line">117.【workflow】flowable-ui建模器应用程序-绘制流程图.mp4</span><br><span class="line">118.【workflow】flowable-ui建模器应用程序-填写报销材料.mp4</span><br><span class="line">119.【workflow】flowable-ui建模器应用程序-小于等于1000审批流程.mp4</span><br><span class="line">120.【workflow】flowable-ui建模器应用程序-大于1000审批流程.mp4</span><br><span class="line">121.【workflow】flowable-ui建模器应用程序-流程图下载.mp4</span><br><span class="line">122.【workflow】flowable-ui建模器应用程序-创建流程应用.mp4</span><br><span class="line">123.【workflow】flowable-ui建模器应用程序-细节梳理.mp4</span><br><span class="line">124.【workflow】flowable-ui建模器应用程序-流程监控.mp4</span><br><span class="line">125.【workflow】flowable源码目录结构.mp4</span><br><span class="line">126.【workflow】flowable源码编译.mp4</span><br><span class="line">127.【workflow】flowable源码启动.mp4</span><br><span class="line">128.【workflow】flowable源码接入MySQL数据库.mp4</span><br><span class="line">129.【workflow】flowable源码接口分析.mp4</span><br><span class="line">130.【workflow】flowable添加用户.mp4</span><br><span class="line">131.【workflow】flowable修改和删除用户.mp4</span><br><span class="line">132.【workflow】flowable查询用户.mp4</span><br><span class="line">133.【workflow】flowable用户组的添加与删除.mp4</span><br><span class="line">134.【workflow】flowable用户组的更新与查询.mp4</span><br><span class="line">135.【workflow】flowable查看表详细信息.mp4</span><br><span class="line">136.【workflow】flowable流程自动部署.mp4</span><br><span class="line">137.【workflow】flowable流程自动升级.mp4</span><br><span class="line">138.【workflow】flowable修改流程定义的分类.mp4</span><br><span class="line">139.【workflow】flowable流程自动部署配置.mp4</span><br><span class="line">140.【workflow】flowable手动部署流程.mp4</span><br><span class="line">141.【workflow】flowable查询API.mp4</span><br><span class="line">142.【workflow】flowable自定义流程定义查询SQL.mp4</span><br><span class="line">143.【workflow】flowable自定义流程部署查询SQL.mp4</span><br><span class="line">144.【workflow】flowable删除流程定义.mp4</span><br><span class="line">145.【workflow】flowable流程实例与执行实例.mp4</span><br><span class="line">146.【workflow】flowable启动一个流程实例.mp4</span><br><span class="line">147.【workflow】flowable另一种流程启动方式.mp4</span><br><span class="line">148.【workflow】flowable流程执行.mp4</span><br><span class="line">149.【workflow】flowable判断流程是否执行结束.mp4</span><br><span class="line">150.【workflow】flowable查看运行活动节点.mp4</span><br><span class="line">151.【workflow】flowable删除流程实例.mp4</span><br><span class="line">156.【workflow】flowable中的租户.mp4</span><br><span class="line">157.【workflow】flowable中的ReceiveTask.mp4</span><br><span class="line">158.【workflow】UserTask直接指定处理人.mp4</span><br><span class="line">159.【workflow】UserTask委派或者自己处理.mp4</span><br><span class="line">160.【workflow】通过变量指定UserTask处理人.mp4</span><br><span class="line">161.【workflow】通过监听器指定UserTask处理人.mp4</span><br><span class="line">162.【workflow】设置UserTask处理人为流程发起人.mp4</span><br><span class="line">163.【workflow】设置UserTask候选人.mp4</span><br><span class="line">164.【workflow】UserTask认领任务.mp4</span><br><span class="line">165.【workflow】通过变量或者监听器为UserTask设置处理人.mp4</span><br><span class="line">166.【workflow】UserTask任务回退.mp4</span><br><span class="line">167.【workflow】UserTask候选人的添加与删除.mp4</span><br><span class="line">168.【workflow】UserTask按角色分配.mp4</span><br><span class="line">169.【workflow】UserTask通过变量设置角色.mp4</span><br><span class="line">170.【workflow】通过监听器配置ServiceTask.mp4</span><br><span class="line">171.【workflow】ServiceTask监听器类设置属性.mp4</span><br><span class="line">172.【workflow】ServiceTask委托表达式.mp4</span><br><span class="line">173.【workflow】ServiceTask表达式.mp4</span><br><span class="line">174.【workflow】脚本任务之JavaScript.mp4</span><br><span class="line">175.【workflow】脚本任务之Groovy.mp4</span><br><span class="line">176.【workflow】脚本任务之Juel.mp4</span><br><span class="line">177.【workflow】流程网关之排他网关.mp4</span><br><span class="line">178.【workflow】流程网关之并行网关.mp4</span><br><span class="line">179.【workflow】流程网关之包容网关.mp4</span><br><span class="line">180.【workflow】全局流程变量-启动时设置.mp4</span><br><span class="line">181.【workflow】全局流程变量-Task设置.mp4</span><br><span class="line">182.【workflow】全局流程变量-完成任务时设置.mp4</span><br><span class="line">183.【workflow】全局流程变量-通过执行实例设置.mp4</span><br><span class="line">184.【workflow】本地流程变量-1.mp4</span><br><span class="line">185.【workflow】本地流程变量-2.mp4</span><br><span class="line">186.【workflow】临时流程变量.mp4</span><br><span class="line">187.【workflow】流程历史信息-环境准备.mp4</span><br><span class="line">188.【workflow】流程历史信息-历史流程.mp4</span><br><span class="line">189.【workflow】流程历史信息-历史任务.mp4</span><br><span class="line">190.【workflow】流程历史信息-历史活动.mp4</span><br><span class="line">191.【workflow】流程历史信息-历史变量.mp4</span><br><span class="line">192.【workflow】流程历史信息-历史日志.mp4</span><br><span class="line">193.【workflow】流程历史信息-历史权限.mp4</span><br><span class="line">194.【workflow】流程历史信息-自定义SQL.mp4</span><br><span class="line">195.【workflow】流程历史信息-日志级别.mp4</span><br><span class="line">196.【workflow】流程定义定时激活.mp4</span><br><span class="line">197.【workflow】流程定义定时挂起.mp4</span><br><span class="line">198.【workflow】定时任务表分析.mp4</span><br><span class="line">199.【workflow】流程表单分类.mp4</span><br><span class="line">200.【workflow】动态表单定义.mp4</span><br><span class="line">201.【workflow】查询启动节点上的表单定义.mp4</span><br><span class="line">202.【workflow】启动带表单的实例.mp4</span><br><span class="line">203.【workflow】查询UserTask上的表单.mp4</span><br><span class="line">204.【workflow】动态表单的保存与完成.mp4</span><br><span class="line">205.【workflow】开发外置表单.mp4</span><br><span class="line">206.【workflow】部署带外置表单的流程.mp4</span><br><span class="line">207.【workflow】查看流程启动节点上的外置表单.mp4</span><br><span class="line">208.【workflow】带外置表单的流程审批.mp4</span><br><span class="line">209.【workflow】JSON格式的外置表单.mp4</span><br><span class="line">210.【workflow】根据流程定义绘制流程图.mp4</span><br><span class="line">211.【workflow】根据流程实例绘制流程图.mp4</span><br><span class="line">212.【workflow】根据流程历史绘制流程图.mp4</span><br><span class="line">213.【workflow】综合实践-项目介绍.mp4</span><br><span class="line">214.【workflow】综合实践-绘制流程图.mp4</span><br><span class="line">215.【workflow】综合实践-用户体系问题.mp4</span><br><span class="line">216.【workflow】综合实践-工程创建.mp4</span><br><span class="line">217.【workflow】综合实践-创建用户表.mp4</span><br><span class="line">218.【workflow】综合实践-自定义用户登录.mp4</span><br><span class="line">219.【workflow】综合实践-服务类开发.mp4</span><br><span class="line">220.【workflow】综合实践-流程部署.mp4</span><br><span class="line">221.【workflow】综合实践-提交请假申请.mp4</span><br><span class="line">222.【workflow】综合实践-开发请假页面.mp4</span><br><span class="line">223.【workflow】综合实践-选择审批人.mp4</span><br><span class="line">224.【workflow】综合实践-提交请假申请.mp4</span><br><span class="line">225.【workflow】综合实践-待审批流程接口.mp4</span><br><span class="line">226.【workflow】综合实践-待审批流程页面.mp4</span><br><span class="line">227.【workflow】综合实践-添加流程实例ID.mp4</span><br><span class="line">228.【workflow】综合实践-返回流程实时进度.mp4</span><br><span class="line">229.【workflow】综合实践-展示流程实时进度.mp4</span><br><span class="line">230.【workflow】综合实践-当前用户待审批的任务.mp4</span><br><span class="line">231.【workflow】综合实践-网页展示待审批任务.mp4</span><br><span class="line">232.【workflow】综合实践-请假任务审批.mp4</span><br><span class="line">233.【workflow】综合实践-查看请假历史接口.mp4</span><br><span class="line">234.【workflow】综合实践-页面展示历史请假.mp4</span><br><span class="line">235.【workflow】综合实践-查看流程进度图.mp4</span><br></pre></td></tr></table></figure><p>视频总共 130+ 集，20+ 小时，视频录制成本较高，因此这套视频是<strong>付费</strong>的，售价 ¥219，算是全网性价比比较高的 Flowable 视频教程了。</p><p>当然，如果你购买了 TienChin 项目，这套 Flowable 视频是免费赠送的，TienChin 原价 ¥399，目前有七折优惠，只要 279（由于 TienChin 项目已经进入到做项目阶段了，所以接下来可能优惠力度没这么大了），TienChin 项目介绍：<a href="https://mp.weixin.qq.com/s/iESPDUWO63Boh52oLI3Eiw" target="_blank" rel="noopener">TienChin 项目配套视频来啦</a>。</p><p>有需要 Flowable 配套视频教程的小伙伴可以添加如下微信咨询：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png" alt></p><p>好啦，小伙伴们在公众号后台回复 flowable，可以获取 PDF 下载链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥今年最早是在 4 月份发过一篇 Flowable 教程，中间基本上就断了没再更新了，9 月份开始重新拾起，一口气更新了两个多月，如今，这个系列总算完结杀青啦。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>来聊一聊 ElasticSearch 最新版的 Java 客户端</title>
    <link href="http://www.javaboy.org/2022/1214/elasticsearch-java-client.html"/>
    <id>http://www.javaboy.org/2022/1214/elasticsearch-java-client.html</id>
    <published>2022-12-14T10:24:52.000Z</published>
    <updated>2022-12-20T11:05:39.054Z</updated>
    
    <content type="html"><![CDATA[<p>可能不少小伙伴都注意到了，从 ElasticSearch7.17 这个版本开始，原先的 Java 高级客户端<br>Java High Level REST Client 废弃了，不支持了。老实说，ElasticSearch 算是我用过的所有 Java 工具中，更新最为激进的一个了，在 Es7 中废弃了 TransportClient，7.17 又废弃了 TransportClient，那么现在用啥呢？现在的客户端叫做 Elasticsearch Java API Client。</p><a id="more"></a><p>一直偷懒选择无视 Elasticsearch Java API Client，不过最近工作中用到了，所以还是整篇文章和小伙伴们简单梳理一下 Elasticsearch Java API Client 的玩法。</p><p>下面的介绍我主要从索引操作和文档操作两个方面来给大家介绍。</p><p>不过需要跟大家强调的是，ElasticSearch 的 Java 客户端想要用的 6，必须要熟悉 ElasticSearch 的查询脚本，大家平时在工作中遇到 Es 相关的问题，我也都是建议先在 Kibana 中把操作脚本写好，然后再翻译成 Java 代码，或者直接拷贝到 Java 代码中，<strong>非常不建议上来就整 Java 代码</strong>，那样很容易出错。</p><p>如果你对 Es 的操作不熟悉，松哥录了免费的视频教程，大家可以参考：</p><ul><li><a href="https://www.bilibili.com/video/BV1ft4y1e7tq/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ft4y1e7tq/</a></li></ul><p><img src="http://img.itboyhub.com/2022/08/20221214102250.png" alt></p><p>不想看视频，也可以在微信公众号后台回复 es，有文档教程。</p><h2 id="1-Elasticsearch-Java-API-Client"><a href="#1-Elasticsearch-Java-API-Client" class="headerlink" title="1. Elasticsearch Java API Client"></a>1. Elasticsearch Java API Client</h2><p>Elasticsearch Java API Client 是 Elasticsearch 的官方 Java API，这个客户端为所有 Elasticsearch APIs 提供强类型的请求和响应。</p><blockquote><p>这里跟大家解释下什么是强类型的请求和响应：因为所有的 Elasticsearch APIs 本质上都是一个 RESTful 风格的 HTTP 请求，所以当我们调用这些 Elasticsearch APIs 的时候，可以就当成普通的 HTTP 接口来对待，例如使用 HttpUrlConnection 或者 RestTemplate 等工具来直接调用，如果使用这些工具直接调用，就需要我们自己组装 JSON 参数，然后自己解析服务端返回的 JSON。而强类型的请求和响应则是系统把请求参数封装成一个对象了，我们调用对象中的方法去设置就可以了，不需要自己手动拼接 JSON 参数了，请求的结果系统也会封装成一个对象，不需要自己手动去解析 JSON 参数了。</p></blockquote><p>小伙伴们看一下下面这个例子，我想查询 books 索引中，书名中包含 Java 关键字的图书：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsDemo02</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"http://localhost:9200/books/_search?pretty"</span>);</span><br><span class="line">        HttpURLConnection con = (HttpURLConnection) url.openConnection();</span><br><span class="line">        con.setRequestMethod(<span class="hljs-string">"GET"</span>);</span><br><span class="line">        con.setRequestProperty(<span class="hljs-string">"content-type"</span>,<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        <span class="hljs-comment">//允许输出流/允许参数</span></span><br><span class="line">        con.setDoOutput(<span class="hljs-keyword">true</span>);</span><br><span class="line">        <span class="hljs-comment">//获取输出流</span></span><br><span class="line">        OutputStream out = con.getOutputStream();</span><br><span class="line">        String params = <span class="hljs-string">"&#123;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"  \"query\": &#123;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"    \"term\": &#123;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"      \"name\": &#123;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"        \"value\": \"java\"\n"</span> +</span><br><span class="line">                <span class="hljs-string">"      &#125;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"    &#125;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"  &#125;\n"</span> +</span><br><span class="line">                <span class="hljs-string">"&#125;"</span>;</span><br><span class="line">        out.write(params.getBytes());</span><br><span class="line">        <span class="hljs-keyword">if</span> (con.getResponseCode() == <span class="hljs-number">200</span>) &#123;</span><br><span class="line">            BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(con.getInputStream()));</span><br><span class="line">            String str = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">while</span> ((str = br.readLine()) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这就是一个普通的 HTTP 请求，请求参数就是查询的条件，这个条件是一个 JSON 字符串，需要我们自己组装，请求的返回值也是一个 JSON 字符串，这个 JSON 字符串也需要我们自己手动去解析，这种可以算是弱类型的请求和响应。</p><p>Elasticsearch Java API Client 具有如下特性：</p><ul><li>为所有 Elasticsearch APIs 提供强类型的请求和响应。</li><li>所有 API 都有阻塞和异步版本。</li><li>使用构建器模式，在创建复杂的嵌套结构时，可以编写简洁而可读的代码。</li><li>通过使用对象映射器（如 Jackson 或任何实现了 JSON-B 的解析器），实现应用程序类的无缝集成。</li><li>将协议处理委托给一个 http 客户端，如 Java Low Level REST Client，它负责所有传输级的问题。HTTP 连接池、重试、节点发现等等由它去完成。</li></ul><p>关于第三点，松哥吐槽一句，确实简洁，但是可读性一般般吧。</p><p>另外还有两点需要注意：</p><ul><li>Elasticsearch Java 客户端是向前兼容的，即该客户端支持与 Elasticsearch 的更大或相等的次要版本进行通信。</li><li>Elasticsearch Java 客户端只向后兼容默认的发行版本，并且没有做出保证。</li></ul><p>好了，那就不废话了，开整吧。</p><h2 id="2-引入-Elasticsearch-Java-API-Client"><a href="#2-引入-Elasticsearch-Java-API-Client" class="headerlink" title="2. 引入 Elasticsearch Java API Client"></a>2. 引入 Elasticsearch Java API Client</h2><p>首先需要我们加依赖，对 JDK 的版本要求是 1.8，我们需要添加如下两个依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>co.elastic.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是 Spring Boot 项目，就不用添加第二个依赖了，因为 Spring Boot 的 Web 中默认已经加了这个依赖了，但是 Spring Boot 一般需要额外添加下面这个依赖，出现这个原因是由于从 JavaEE 过渡到 JakartaEE 时衍生出来的一些问题，这里我就不啰嗦了，咱们直接加依赖即可：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.json<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.json-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-建立连接"><a href="#3-建立连接" class="headerlink" title="3. 建立连接"></a>3. 建立连接</h2><p>接下来我们需要用我们的 Java 客户端和 ElasticSearch 之间建立连接，建立连接的方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestClient restClient = RestClient.builder(</span><br><span class="line">    <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">    restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里一共有三个步骤：</p><ol><li>首先创建一个低级客户端，这个其实松哥之前的视频中和大家讲过低级客户端的用法，这里就不再赘述。</li><li>接下来创建一个通信 Transport，并利用 JacksonJsonpMapper 做数据的解析。</li><li>最后创建一个阻塞的 Java 客户端。</li></ol><p>上面这个是创建了一个阻塞的 Java 客户端，当然我们也可以创建非阻塞的 Java 客户端，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RestClient restClient = RestClient.builder(</span><br><span class="line">        <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">        restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">ElasticsearchAsyncClient client = <span class="hljs-keyword">new</span> ElasticsearchAsyncClient(transport);</span><br></pre></td></tr></table></figure><p>只有第三步和前面的不一样，其他都一样。</p><blockquote><p>利用阻塞的 Java 客户端操作 Es 的时候会发生阻塞，也就是必须等到 Es 给出响应之后，代码才会继续执行；非阻塞的 Java 客户端则不会阻塞后面的代码执行，非阻塞的 Java 客户端一般通过回调函数处理请求的响应值。</p></blockquote><p>有时候，我们可能还需要和 Es 之间建立 HTTPS 连接，那么需要在前面代码的基础之上，再套上一层 SSL，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String fingerprint = <span class="hljs-string">"&lt;certificate fingerprint&gt;"</span>;</span><br><span class="line">SSLContext sslContext = TransportUtils</span><br><span class="line">    .sslContextFromCaFingerprint(fingerprint); </span><br><span class="line">BasicCredentialsProvider credsProv = <span class="hljs-keyword">new</span> BasicCredentialsProvider(); </span><br><span class="line">credsProv.setCredentials(</span><br><span class="line">    AuthScope.ANY, <span class="hljs-keyword">new</span> UsernamePasswordCredentials(login, password)</span><br><span class="line">);</span><br><span class="line">RestClient restClient = RestClient</span><br><span class="line">    .builder(<span class="hljs-keyword">new</span> HttpHost(host, port, <span class="hljs-string">"https"</span>)) </span><br><span class="line">    .setHttpClientConfigCallback(hc -&gt; hc</span><br><span class="line">        .setSSLContext(sslContext) </span><br><span class="line">        .setDefaultCredentialsProvider(credsProv)</span><br><span class="line">    )</span><br><span class="line">    .build();</span><br><span class="line">ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br></pre></td></tr></table></figure><p>好了，关于建立连接，差不多就这些点。</p><h2 id="4-索引操作"><a href="#4-索引操作" class="headerlink" title="4. 索引操作"></a>4. 索引操作</h2><p>Elasticsearch Java API Client 中最大的特色就是建造者模式+Lambda 表达式。例如，我想创建一个索引，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test99</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    CreateIndexResponse createIndexResponse = client.indices().create(</span><br><span class="line">            c -&gt;</span><br><span class="line">                    c.index(<span class="hljs-string">"javaboy_books"</span>)</span><br><span class="line">                            .settings(s -&gt;</span><br><span class="line">                                    s.numberOfShards(<span class="hljs-string">"3"</span>)</span><br><span class="line">                                            .numberOfReplicas(<span class="hljs-string">"1"</span>))</span><br><span class="line">                            .mappings(m -&gt;</span><br><span class="line">                                    m.properties(<span class="hljs-string">"name"</span>, p -&gt; p.text(f -&gt; f.analyzer(<span class="hljs-string">"ik_max_word"</span>)))</span><br><span class="line">                                            .properties(<span class="hljs-string">"birthday"</span>, p -&gt; p.date(d -&gt; d.format(<span class="hljs-string">"yyyy-MM-dd"</span>))))</span><br><span class="line">                            .aliases(<span class="hljs-string">"books_alias"</span>, f -&gt; f.isWriteIndex(<span class="hljs-keyword">true</span>)));</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.acknowledged() = "</span> + createIndexResponse.acknowledged());</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.index() = "</span> + createIndexResponse.index());</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.shardsAcknowledged() = "</span> + createIndexResponse.shardsAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里都是建造者模式和 Lambda 表达式，方法名称其实都很好理解（前提是你得熟悉 ElasticSearch 操作脚本），例如：</p><ul><li>index 方法表示设置索引名称</li><li>settings 方法表示配置 setting 中的参数</li><li>numberOfShards 表示索引的分片数</li><li>numberOfReplicas 表示配置索引的副本数</li><li>mapping 表示配置索引中的映射规则</li><li>properties 表示配置索引中的具体字段</li><li>text 方法表示字段是 text 类型的</li><li>analyzer 表示配置字段的分词器</li><li>aliases 表示配置索引的别名</li></ul><p>反正这里的方法都是见名知义的，上面这个就类似于下面这个请求：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT javaboy_books</span><br><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"number_of_replicas"</span>: <span class="hljs-number">1</span>,</span><br><span class="line">    <span class="hljs-attr">"number_of_shards"</span>: <span class="hljs-number">3</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="hljs-attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"properties"</span>: &#123;</span><br><span class="line">      <span class="hljs-attr">"name"</span>:&#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"text"</span>,</span><br><span class="line">        <span class="hljs-attr">"analyzer"</span>: <span class="hljs-string">"ik_max_word"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="hljs-attr">"birthday"</span>:&#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span>: <span class="hljs-string">"date"</span>,</span><br><span class="line">        <span class="hljs-attr">"format"</span>: <span class="hljs-string">"yyyy-MM-dd"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="hljs-attr">"aliases"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"xxxx"</span>:&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们在写的时候，脑子里要先有下面这个脚本，然后 Java 方法可以顺手拈来了。</p><p>最终创建好的索引如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221214102322.png" alt></p><p>有的小伙伴可能觉得调这一大堆方法太啰里啰唆了，来个简单的，直接上 JSON，那也不是不可以，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test98</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    StringReader json = <span class="hljs-keyword">new</span> StringReader(<span class="hljs-string">"&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  \"settings\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"number_of_replicas\": 1,\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"number_of_shards\": 3\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  &#125;,\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  \"mappings\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"properties\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      \"name\":&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"type\": \"text\",\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"analyzer\": \"ik_max_word\"\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      &#125;,\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      \"birthday\":&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"type\": \"date\",\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"format\": \"yyyy-MM-dd\"\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  &#125;,\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  \"aliases\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"xxxx\":&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      \n"</span> +</span><br><span class="line">            <span class="hljs-string">"    &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"&#125;"</span>);</span><br><span class="line">    CreateIndexResponse createIndexResponse = client.indices().create(</span><br><span class="line">            c -&gt;</span><br><span class="line">                    c.index(<span class="hljs-string">"javaboy_books"</span>).withJson(json));</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.acknowledged() = "</span> + createIndexResponse.acknowledged());</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.index() = "</span> + createIndexResponse.index());</span><br><span class="line">    System.out.println(<span class="hljs-string">"createResponse.shardsAcknowledged() = "</span> + createIndexResponse.shardsAcknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是直接把 JSON 参数给拼接出来，就不需要一堆建造者+Lambda 了。</p><p>如果你想删除索引呢？如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    <span class="hljs-comment">//删除一个索引</span></span><br><span class="line">    DeleteIndexResponse delete = client.indices().delete(f -&gt;</span><br><span class="line">            f.index(<span class="hljs-string">"my-index"</span>)</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="hljs-string">"delete.acknowledged() = "</span> + delete.acknowledged());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表示删除一个名为 <code>my-index</code> 的索引。</p><p>好了，关于索引的操作我就说这两点。</p><p>可能有的小伙伴会说，ElasticSearch 中创建索引可以配置很多参数你都没讲。在我看来，哪些很多参数其实跟这个 Java API 没有多大关系，只要你会写查询脚本，就自然懂得 Java API 中该调用哪个方法，退一万步讲，你会脚本，不懂 Java API 的方法，那么就像上面那样，直接把你的 JSON 拷贝过来，作为 Java API 的参数即可。</p><h2 id="5-文档操作"><a href="#5-文档操作" class="headerlink" title="5. 文档操作"></a>5. 文档操作</h2><h3 id="5-1-添加文档"><a href="#5-1-添加文档" class="headerlink" title="5.1 添加文档"></a>5.1 添加文档</h3><p>先来看文档的添加操作。</p><p>如下表示我想给一个名为 books 的索引中添加一个 id 为 890 的书：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    Book book = <span class="hljs-keyword">new</span> Book();</span><br><span class="line">    book.setId(<span class="hljs-number">890</span>);</span><br><span class="line">    book.setName(<span class="hljs-string">"深入理解Java虚拟机"</span>);</span><br><span class="line">    book.setAuthor(<span class="hljs-string">"xxx"</span>);</span><br><span class="line">    <span class="hljs-comment">//添加一个文档</span></span><br><span class="line">    <span class="hljs-comment">//这是一个同步请求，请求会卡在这里</span></span><br><span class="line">    IndexResponse response = client.index(i -&gt; i.index(<span class="hljs-string">"books"</span>).document(book).id(<span class="hljs-string">"890"</span>));</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.result() = "</span> + response.result());</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.id() = "</span> + response.id());</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.seqNo() = "</span> + response.seqNo());</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.index() = "</span> + response.index());</span><br><span class="line">    System.out.println(<span class="hljs-string">"response.shards() = "</span> + response.shards());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加成功之后，返回的 IndexResponse 对象其实就是对下面这个 JSON 的封装：</p><p><img src="http://img.itboyhub.com/2022/08/20221214102339.png" alt></p><p>现在我们只需要调用相应的方法，就可以获取到 JSON 相关的属性了。</p><h3 id="5-2-删除文档"><a href="#5-2-删除文档" class="headerlink" title="5.2 删除文档"></a>5.2 删除文档</h3><p>如下表示删除 books 索引中 id 为 891 的文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test09</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchAsyncClient client = <span class="hljs-keyword">new</span> ElasticsearchAsyncClient(transport);</span><br><span class="line">    client.delete(d -&gt; d.index(<span class="hljs-string">"books"</span>).id(<span class="hljs-string">"891"</span>)).whenComplete((resp, e) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"resp.result() = "</span> + resp.result());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除这里我用了异步非阻塞的客户端来给小伙伴们演示的，异步非阻塞的话，就使用 whenComplete 方法处理回调就行了，里边有两个参数，一个是正常情况下返回的对象，另外一个则是出错时候的异常。</p><h3 id="5-3-查询文档"><a href="#5-3-查询文档" class="headerlink" title="5.3 查询文档"></a>5.3 查询文档</h3><p>最后，就是查询了。这应该是大家日常开发中使用较多的功能项了，不过我还是前面的态度，查询的关键不在 Java API，而在于你对 ElasticSearch 脚本的掌握程度。</p><p>所以我这里举个简单的例子，小伙伴们大致了解下 Java API 的方法即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest.Builder()</span><br><span class="line">            <span class="hljs-comment">//去哪个索引里搜索</span></span><br><span class="line">            .index(<span class="hljs-string">"books"</span>)</span><br><span class="line">            .query(QueryBuilders.term().field(<span class="hljs-string">"name"</span>).value(<span class="hljs-string">"java"</span>).build()._toQuery())</span><br><span class="line">            .build();</span><br><span class="line">    SearchResponse&lt;Book&gt; search = client.search(request, Book.class);</span><br><span class="line">    System.out.println(<span class="hljs-string">"search.toString() = "</span> + search.toString());</span><br><span class="line">    <span class="hljs-keyword">long</span> took = search.took();</span><br><span class="line">    System.out.println(<span class="hljs-string">"took = "</span> + took);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> b = search.timedOut();</span><br><span class="line">    System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br><span class="line">    ShardStatistics shards = search.shards();</span><br><span class="line">    System.out.println(<span class="hljs-string">"shards = "</span> + shards);</span><br><span class="line">    HitsMetadata&lt;Book&gt; hits = search.hits();</span><br><span class="line">    TotalHits total = hits.total();</span><br><span class="line">    System.out.println(<span class="hljs-string">"total = "</span> + total);</span><br><span class="line">    Double maxScore = hits.maxScore();</span><br><span class="line">    System.out.println(<span class="hljs-string">"maxScore = "</span> + maxScore);</span><br><span class="line">    List&lt;Hit&lt;Book&gt;&gt; list = hits.hits();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Hit&lt;Book&gt; bookHit : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.source() = "</span> + bookHit.source());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.score() = "</span> + bookHit.score());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.index() = "</span> + bookHit.index());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子是一个 term 查询，查询 books 索引中书名 name 中包含 java 关键字的图书，等价于下面这个查询：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"query"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"term"</span>: &#123;</span><br><span class="line">      <span class="hljs-attr">"name"</span>: &#123;</span><br><span class="line">        <span class="hljs-attr">"value"</span>: <span class="hljs-string">"java"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望能够对查询关键字分词之后查询，那么可以使用 match 查询，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    SearchResponse&lt;Book&gt; search = client.search(s -&gt; &#123;</span><br><span class="line">        s.index(<span class="hljs-string">"books"</span>)</span><br><span class="line">                .query(q -&gt; &#123;</span><br><span class="line">                    q.match(m -&gt; &#123;</span><br><span class="line">                        m.field(<span class="hljs-string">"name"</span>).query(<span class="hljs-string">"美术计算机"</span>);</span><br><span class="line">                        <span class="hljs-keyword">return</span> m;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="hljs-keyword">return</span> q;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="hljs-keyword">return</span> s;</span><br><span class="line">    &#125;, Book.class);</span><br><span class="line">    System.out.println(<span class="hljs-string">"search.toString() = "</span> + search.toString());</span><br><span class="line">    <span class="hljs-keyword">long</span> took = search.took();</span><br><span class="line">    System.out.println(<span class="hljs-string">"took = "</span> + took);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> b = search.timedOut();</span><br><span class="line">    System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br><span class="line">    ShardStatistics shards = search.shards();</span><br><span class="line">    System.out.println(<span class="hljs-string">"shards = "</span> + shards);</span><br><span class="line">    HitsMetadata&lt;Book&gt; hits = search.hits();</span><br><span class="line">    TotalHits total = hits.total();</span><br><span class="line">    System.out.println(<span class="hljs-string">"total = "</span> + total);</span><br><span class="line">    Double maxScore = hits.maxScore();</span><br><span class="line">    System.out.println(<span class="hljs-string">"maxScore = "</span> + maxScore);</span><br><span class="line">    List&lt;Hit&lt;Book&gt;&gt; list = hits.hits();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Hit&lt;Book&gt; bookHit : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.source() = "</span> + bookHit.source());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.score() = "</span> + bookHit.score());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.index() = "</span> + bookHit.index());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了让小伙伴们看到这个 Java 客户端的不同用法，上面两个查询的例子，我分别使用了构造查询请求和建造者+Lambda 的方式。</p></blockquote><p>match 查询就调用 match 方法就行了，设置查询关键字即可，这个查询等价于下面这个查询：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET books/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"query"</span>: &#123;</span><br><span class="line">    <span class="hljs-attr">"match"</span>: &#123;</span><br><span class="line">      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"美术计算机"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你觉得这种调用各种方法拼接参数的方式不习惯，那么也可以直接上 JSON，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RestClient restClient = RestClient.builder(</span><br><span class="line">            <span class="hljs-keyword">new</span> HttpHost(<span class="hljs-string">"localhost"</span>, <span class="hljs-number">9200</span>)).build();</span><br><span class="line">    ElasticsearchTransport transport = <span class="hljs-keyword">new</span> RestClientTransport(</span><br><span class="line">            restClient, <span class="hljs-keyword">new</span> JacksonJsonpMapper());</span><br><span class="line">    ElasticsearchClient client = <span class="hljs-keyword">new</span> ElasticsearchClient(transport);</span><br><span class="line">    String key = <span class="hljs-string">"java"</span>;</span><br><span class="line">    StringReader sr = <span class="hljs-keyword">new</span> StringReader(<span class="hljs-string">"&#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  \"query\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    \"term\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      \"name\": &#123;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"        \"value\": \""</span> + key + <span class="hljs-string">"\"\n"</span> +</span><br><span class="line">            <span class="hljs-string">"      &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"    &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"  &#125;\n"</span> +</span><br><span class="line">            <span class="hljs-string">"&#125;"</span>);</span><br><span class="line">    SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest.Builder()</span><br><span class="line">            .withJson(sr)</span><br><span class="line">            .build();</span><br><span class="line">    SearchResponse&lt;Book&gt; search = client.search(request, Book.class);</span><br><span class="line">    System.out.println(<span class="hljs-string">"search.toString() = "</span> + search.toString());</span><br><span class="line">    <span class="hljs-keyword">long</span> took = search.took();</span><br><span class="line">    System.out.println(<span class="hljs-string">"took = "</span> + took);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> b = search.timedOut();</span><br><span class="line">    System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br><span class="line">    ShardStatistics shards = search.shards();</span><br><span class="line">    System.out.println(<span class="hljs-string">"shards = "</span> + shards);</span><br><span class="line">    HitsMetadata&lt;Book&gt; hits = search.hits();</span><br><span class="line">    TotalHits total = hits.total();</span><br><span class="line">    System.out.println(<span class="hljs-string">"total = "</span> + total);</span><br><span class="line">    Double maxScore = hits.maxScore();</span><br><span class="line">    System.out.println(<span class="hljs-string">"maxScore = "</span> + maxScore);</span><br><span class="line">    List&lt;Hit&lt;Book&gt;&gt; list = hits.hits();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Hit&lt;Book&gt; bookHit : list) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.source() = "</span> + bookHit.source());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.score() = "</span> + bookHit.score());</span><br><span class="line">        System.out.println(<span class="hljs-string">"bookHit.index() = "</span> + bookHit.index());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，直接把查询的 JSON 参数传进来也是可以的。这样我们就可以先在 Kibana 中写好脚本，然后直接将脚本拷贝到 Java 代码中来执行就行了。</p><p>好啦，关于 Es 中新的 Java 客户端，我就和大家说这么多，最后再强调一下，这其实不是重点，玩 Es 的重点是把 Es 的各种查询参数搞懂，那么 Java 代码其实就是顺手拈来的事了。</p><p>最后，如果大家对 Es 不熟悉，可以看看松哥录的这个免费视频教程：</p><ul><li><a href="https://www.bilibili.com/video/BV1ft4y1e7tq/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ft4y1e7tq/</a></li></ul><p><img src="http://img.itboyhub.com/2022/08/20221214102357.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可能不少小伙伴都注意到了，从 ElasticSearch7.17 这个版本开始，原先的 Java 高级客户端&lt;br&gt;Java High Level REST Client 废弃了，不支持了。老实说，ElasticSearch 算是我用过的所有 Java 工具中，更新最为激进的一个了，在 Es7 中废弃了 TransportClient，7.17 又废弃了 TransportClient，那么现在用啥呢？现在的客户端叫做 Elasticsearch Java API Client。&lt;/p&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/categories/ElasticSearch/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP在项目中的典型应用场景</title>
    <link href="http://www.javaboy.org/2022/1208/spring-aop.html"/>
    <id>http://www.javaboy.org/2022/1208/spring-aop.html</id>
    <published>2022-12-08T10:24:35.000Z</published>
    <updated>2022-12-20T11:05:34.803Z</updated>
    
    <content type="html"><![CDATA[<p>学过 Spring 的小伙伴相信都知道 AOP，AOP 学的好的小伙伴相信对 AOP 的概念也是轻车熟路：面向切面编程、切点、切面、通知，Aspect、Pointcut、Advice 等如数家珍。</p><a id="more"></a><p>AOP 之所以这么重要，是因为它在项目中有着非常广泛的应用，今天这篇文章，松哥就来和大家总结一下，我们在日常开发中，都有哪些典型场景需要用到 AOP。</p><blockquote><p>先来一句话总结下，AOP 的使用，基本上都会涉及到自定义注解，一个非常常见的组合，就是自定义注解+AOP。</p></blockquote><p>在日常的开发中，有很多重复的代码，我们总是希望将之简化，AOP 就是一个非常常用的简化手段。简化的思路一般是这样：</p><ol><li>首先，自定义一个注解。</li><li>定义 AOP 切面，在切面中，定义切点和通知，切点，也就是方法的拦截规则，我们可以按照注解来拦截，也就是某一个带有自定义注解的方法，将被我拦截下来。</li><li>拦截下来之后，前置通知、后置通知、异常通知、返回通知还是环绕通知，就可以随便写了。</li></ol><p>所以，这些涉及到自定义注解的地方，基本上都可以算是 AOP 的使用场景了，因为自定义注解，需要用 AOP 来解析。</p><p>接下来我们来看几个比较典型的例子。</p><h2 id="1-幂等性处理"><a href="#1-幂等性处理" class="headerlink" title="1. 幂等性处理"></a>1. 幂等性处理</h2><p>接口幂等性的处理，其实有很多种不同的方案，例如：</p><ol><li>Token 机制</li><li>去重表</li><li>利用 Redis 的 setnx</li><li>设置状态字段</li><li>上锁</li></ol><p>无论是哪种方案处理幂等性，每个方法里边都去写一遍幂等性的处理显然是不现实的，因此，一般都是将幂等性的处理通过自定义注解+AOP给封装起来，大致的思路如下：</p><ol><li>首先自定义一个注解。</li><li>自定义切点，拦截所有加了自定义注解的方法。</li><li>定义环绕通知，在环绕通知中，先通过上述五种思路中的任意一种，对方法执行的幂等性进行判断，判断通过了，再执行目标方法，判断不通过，则直接抛出异常，不执行目标方法。</li></ol><p>这就是自定义注解+AOP 的一个典型应用场景。</p><p>如果你对上面的表述云里雾里，不妨看看松哥之前发的这个视频，有详细的手把手教程：<a href="https://mp.weixin.qq.com/s/qSXS401IX2libPKVVVuChQ" target="_blank" rel="noopener">处理接口幂等性的两种常见方案|手把手教你</a>。</p><h2 id="2-接口限流"><a href="#2-接口限流" class="headerlink" title="2. 接口限流"></a>2. 接口限流</h2><p>对于接口限流，目前来说，一个比较成熟的方案是使用 Alibaba 的 Sentienl，简单配置一下就可以实现接口限流了。</p><p>但是如果没有用这个工具呢？如果是我们自己写呢？毫无疑问，还是自定义注解+AOP，思路大致如下：</p><ol><li>自定义注解。</li><li>在需要进行限流的接口方法上添加自定义注解，同时还可以设置一些限流的参数，例如时间窗口值、流量大小等。</li><li>自定义切点，拦截规则就是所有添加了自定义注解的方法，拦截到方法之后，在环绕通知中，可以通过 Redis 插件 redis-cell、通过漏斗算法去处理限流，这个我这里就不罗嗦了，之前的文章中都写过了。限流计算没问题的话，就执行目标方法，否则将操作拦截下来。</li></ol><p>大致思路如上，说白了就是自定义注解+ AOP，道理虽然简单，但是真正做起来，还是有很多细节，感兴趣的小伙伴可以参考松哥之前的这篇文章：<a href="https://mp.weixin.qq.com/s/rzz2tgBBJpWz7gjmEfz2XQ" target="_blank" rel="noopener">Redis 做接口限流，一个注解的事！</a>。</p><h2 id="3-日志处理"><a href="#3-日志处理" class="headerlink" title="3. 日志处理"></a>3. 日志处理</h2><p>说到 AOP，所有人都能想到的使用场景了，这个我就不罗嗦了，松哥之前也有过专门的文章介绍，没看过的小伙伴们戳这里：<a href="https://mp.weixin.qq.com/s/29WX3G7FC5BXiD0lS1tnbw" target="_blank" rel="noopener">记录项目日志，一个注解搞定</a>。</p><h2 id="4-多数据源处理"><a href="#4-多数据源处理" class="headerlink" title="4. 多数据源处理"></a>4. 多数据源处理</h2><p>有时候我们项目中存在多个不同的数据源，在实际使用中需要进行切换，网上也有一些开源的解决方案，不过这个东西其实并不难，我们也可以自己写。</p><p>自定义多数据源的处理，大致上思路如下：</p><p>从 Spring2.0.1 中引入了 AbstractRoutingDataSource 类，（注意是 Spring2.0.1 不是 Spring Boot2.0.1，所以这其实也算是 Spring 一个非常古老的特性了）, 该类充当了 DataSource 的路由中介，它能够在运行时, 根据某种 key 值来动态切换到真正的 DataSource 上。</p><p>大致的用法就是你提前准备好各种数据源，存入到一个 Map 中，Map 的 key 就是这个数据源的名字，Map 的 value 就是这个具体的数据源，然后再把这个 Map 配置到 AbstractRoutingDataSource 中，最后，每次执行数据库查询的时候，拿一个 key 出来，AbstractRoutingDataSource 会找到具体的数据源去执行这次数据库操作。</p><p>基于以上知识，我们可以自定义一个注解，在需要切换数据源的方法上，添加这个注解，然后通过 AOP 去解析这个自定义注解，当目标方法被拦截下来的时候，我们跟进注解中的配置，重新设置要执行的数据源，这样将来 service 中的方法在执行的过程中，就会使用到切换之后的数据源了。</p><p>思路并不难，松哥之前也写过详细的教程，小伙伴们参考这里：</p><ul><li><a href="https://mp.weixin.qq.com/s/g71F3cnLtD4zqJGFCeJckQ" target="_blank" rel="noopener">手把手教你玩多数据源动态切换！</a></li><li><a href="https://mp.weixin.qq.com/s/JmVUDyyFT8OB_F8fj3FvqQ" target="_blank" rel="noopener">网页上点一下，就能切换不同数据源？松哥手把手教你！</a></li></ul><h2 id="5-方法权限处理"><a href="#5-方法权限处理" class="headerlink" title="5. 方法权限处理"></a>5. 方法权限处理</h2><p>这个其实也跟前面的差不多。</p><p>方法级别的权限处理，一般来说也是基于注解来完成的。如果你使用了 Spring Security 之类的权限框架，就不用自己解析权限注解了，按照框架的要求直接来使用就行了。</p><p>有的时候，我们可能没有使用 Spring Security，想自己处理权限注解，也是可以的。用户自定义权限注解，为注解添加属性，然后将注解添加到目标方法上，再通过 AOP 去解析这个注解，AOP 将目标方法的执行拦截下来，然后判断用户是否具备所需要的权限，如果具备，就执行目标方法，否则就不执行。</p><p>前两天松哥刚刚分享的在微服务中，服务内部的权限校验，就是自定义一个注解，将从其他微服务上来的请求给拦截下来，然后判断请求的来源，如果是从其他微服务上来的，就执行目标方法，如果不是从其他微服务上来的，而是从外部来的请求，那么就将之拦截下来抛出异常，不执行目标方法，参见：<a href="https://mp.weixin.qq.com/s/BVeBr4Wjb5XpzPwXc7iZ7g" target="_blank" rel="noopener">微服务中的鉴权该怎么做？</a>。</p><h2 id="6-事务处理"><a href="#6-事务处理" class="headerlink" title="6. 事务处理"></a>6. 事务处理</h2><p>这个倒是不需要自定义注解，对于声明式事务，直接用现成的注解就行了，但是本质上也是 AOP，如果有小伙伴在 Spring 的 XML 中配置过事务的话，就知道这个东西底层也是 AOP。</p><p>好啦，梳理了几个简单的案例，希望小伙伴们了解到 AOP 并不是屠龙术，而是在日常开发中有着广泛应用的技术。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学过 Spring 的小伙伴相信都知道 AOP，AOP 学的好的小伙伴相信对 AOP 的概念也是轻车熟路：面向切面编程、切点、切面、通知，Aspect、Pointcut、Advice 等如数家珍。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 事务失效的六种情况</title>
    <link href="http://www.javaboy.org/2022/1206/spring-transaction.html"/>
    <id>http://www.javaboy.org/2022/1206/spring-transaction.html</id>
    <published>2022-12-06T10:24:23.000Z</published>
    <updated>2022-12-20T11:05:30.607Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><img src="http://img.itboyhub.com/2022/08/20221205223550.png" alt></p><p>最近有小伙伴告诉松哥说面试中被问到这个问题了，不知道该怎么回答，这能忍？捋一篇文章和小伙伴们分享下吧。</p><a id="more"></a><p>既然捋成文章，就连同 Spring 事务一起梳理下吧。</p><h2 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务"></a>1. 什么是事务</h2><p>数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么一起成功，要么一起失败，是一个不可分割的工作单元。</p><p>在我们日常工作中，涉及到事务的场景非常多，一个 service 中往往需要调用不同的 dao 层方法，这些方法要么同时成功要么同时失败，我们需要在 service 层确保这一点。</p><p>说到事务最典型的案例就是转账了：</p><blockquote><p>张三要给李四转账 500 块钱，这里涉及到两个操作，从张三的账户上减去 500 块钱，给李四的账户添加 500 块钱，这两个操作要么同时成功要么同时失败，如何确保他们同时成功或者同时失败呢？答案就是事务。</p></blockquote><p>事务有四大特性（ACID）：</p><p><img src="http://img.itboyhub.com/2021/07/20211012195927.png" alt></p><ul><li><strong>原子性（Atomicity）：</strong> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read Uncommitted）、提交读（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</li><li><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>这就是事务的四大特性。</p><h2 id="2-Spring-中的事务"><a href="#2-Spring-中的事务" class="headerlink" title="2. Spring 中的事务"></a>2. Spring 中的事务</h2><h3 id="2-1-两种用法"><a href="#2-1-两种用法" class="headerlink" title="2.1 两种用法"></a>2.1 两种用法</h3><p>Spring 作为 Java 开发中的基础设施，对于事务也提供了很好的支持，总体上来说，Spring 支持两种类型的事务，声明式事务和编程式事务。</p><p>编程式事务类似于 Jdbc 事务的写法，需要将事务的代码嵌入到业务逻辑中，这样代码的耦合度较高，而声明式事务通过 AOP 的思想能够有效的将事务和业务逻辑代码解耦，因此在实际开发中，声明式事务得到了广泛的应用，而编程式事务则较少使用，考虑到文章内容的完整，本文对两种事务方式都会介绍。</p><h3 id="2-2-三大基础设施"><a href="#2-2-三大基础设施" class="headerlink" title="2.2 三大基础设施"></a>2.2 三大基础设施</h3><p>Spring 中对事务的支持提供了三大基础设施，我们先来了解下。</p><ol><li>PlatformTransactionManager</li><li>TransactionDefinition</li><li>TransactionStatus</li></ol><p>这三个核心类是 Spring 处理事务的核心类。</p><h4 id="2-2-1-PlatformTransactionManager"><a href="#2-2-1-PlatformTransactionManager" class="headerlink" title="2.2.1 PlatformTransactionManager"></a>2.2.1 PlatformTransactionManager</h4><p>PlatformTransactionManager 是事务处理的核心，它有诸多的实现类，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/3-1.png" alt></p><p>PlatformTransactionManager 的定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">TransactionStatus <span class="hljs-title">getTransaction</span><span class="hljs-params">(@Nullable TransactionDefinition definition)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>PlatformTransactionManager</code> 中定义了基本的事务操作方法，这些事务操作方法都是平台无关的，具体的实现都是由不同的子类来实现的。</p><p>这就像 JDBC 一样，SUN 公司制定标准，其他数据库厂商提供具体的实现。这么做的好处就是我们 Java 程序员只需要掌握好这套标准即可，不用去管接口的具体实现。以 <code>PlatformTransactionManager</code> 为例，它有众多实现，如果你使用的是 JDBC 那么可以将 <code>DataSourceTransactionManager</code> 作为事务管理器；如果你使用的是 Hibernate，那么可以将 <code>HibernateTransactionManager</code> 作为事务管理器；如果你使用的是 JPA，那么可以将 <code>JpaTransactionManager</code> 作为事务管理器。<code>DataSourceTransactionManager</code>、<code>HibernateTransactionManager</code> 以及 <code>JpaTransactionManager</code> 都是 <code>PlatformTransactionManager</code> 的具体实现，但是我们并不需要掌握这些具体实现类的用法，我们只需要掌握好 <code>PlatformTransactionManager</code> 的用法即可。</p><p><code>PlatformTransactionManager</code> 中主要有如下三个方法：</p><p><strong>1.getTransaction()</strong></p><p>getTransaction() 是根据传入的 TransactionDefinition 获取一个事务对象，TransactionDefinition 中定义了一些事务的基本规则，例如传播性、隔离级别等。</p><p><strong>2.commit()</strong></p><p>commit() 方法用来提交事务。</p><p><strong>3.rollback()</strong></p><p>rollback() 方法用来回滚事务。</p><h4 id="2-2-2-TransactionDefinition"><a href="#2-2-2-TransactionDefinition" class="headerlink" title="2.2.2 TransactionDefinition"></a>2.2.2 TransactionDefinition</h4><p><code>TransactionDefinition</code> 用来描述事务的具体规则，也称作事务的属性。事务有哪些属性呢？看下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211012204524.png" alt></p><p>可以看到，主要是五种属性：</p><ol><li>隔离性</li><li>传播性</li><li>回滚规则</li><li>超时时间</li><li>是否只读</li></ol><p>这五种属性接下来松哥会和大家详细介绍。</p><p><code>TransactionDefinition</code> 类中的方法如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/3-3.png" alt></p><p>可以看到一共有五个方法：</p><ol><li>getIsolationLevel()，获取事务的隔离级别</li><li>getName()，获取事务的名称</li><li>getPropagationBehavior()，获取事务的传播性</li><li>getTimeout()，获取事务的超时时间</li><li>isReadOnly()，获取事务是否是只读事务</li></ol><p>TransactionDefinition 也有诸多的实现类，如下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/3-4.png" alt></p><p>如果开发者使用了编程式事务的话，直接使用 <code>DefaultTransactionDefinition</code> 即可。</p><h4 id="2-2-3-TransactionStatus"><a href="#2-2-3-TransactionStatus" class="headerlink" title="2.2.3 TransactionStatus"></a>2.2.3 TransactionStatus</h4><p>TransactionStatus 可以直接理解为事务本身，该接口源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TransactionStatus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SavepointManager</span>, <span class="hljs-title">Flushable</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isNewTransaction</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasSavepoint</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setRollbackOnly</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRollbackOnly</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCompleted</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>isNewTransaction() 方法获取当前事务是否是一个新事务。</li><li>hasSavepoint() 方法判断是否存在 savePoint()。</li><li>setRollbackOnly() 方法设置事务必须回滚。</li><li>isRollbackOnly() 方法获取事务只能回滚。</li><li>flush() 方法将底层会话中的修改刷新到数据库，一般用于 Hibernate/JPA 的会话，对如 JDBC 类型的事务无任何影响。</li><li>isCompleted() 方法用来获取是一个事务是否结束。</li></ol><p><strong>这就是 Spring 中支持事务的三大基础设施。</strong></p><h2 id="3-编程式事务"><a href="#3-编程式事务" class="headerlink" title="3. 编程式事务"></a>3. 编程式事务</h2><p>我们先来看看编程式事务怎么玩。</p><p>通过 PlatformTransactionManager 或者 TransactionTemplate 可以实现编程式事务。如果是在 Spring Boot 项目中，这两个对象 Spring Boot 会自动提供，我们直接使用即可。但是如果是在传统的 SSM 项目中，则需要我们通过配置来提供这两个对象，松哥给一个简单的配置参考，如下（简单起见，数据库操作我们使用 JdbcTemplate）：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql:///spring_tran?serverTimezone=Asia/Shanghai"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.transaction.support.TransactionTemplate"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.core.JdbcTemplate"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有了这两个对象，接下来的代码就简单了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    PlatformTransactionManager txManager;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DefaultTransactionDefinition definition = <span class="hljs-keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">        TransactionStatus status = txManager.getTransaction(definition);</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            jdbcTemplate.update(<span class="hljs-string">"update user set account=account+100 where username='zhangsan'"</span>);</span><br><span class="line">            <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">            jdbcTemplate.update(<span class="hljs-string">"update user set account=account-100 where username='lisi'"</span>);</span><br><span class="line">            txManager.commit(status);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            txManager.rollback(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单，没啥好解释的，在 <code>try...catch...</code> 中进行业务操作，没问题就 commit，有问题就 rollback。如果我们需要配置事务的隔离性、传播性等，可以在 DefaultTransactionDefinition 对象中进行配置。</p><p>上面的代码是通过 PlatformTransactionManager 实现的编程式事务，我们也可以通过 TransactionTemplate 来实现编程式事务，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TransactionTemplate tranTemplate;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        tranTemplate.execute(<span class="hljs-keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInTransactionWithoutResult</span><span class="hljs-params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    jdbcTemplate.update(<span class="hljs-string">"update user set account=account+100 where username='zhangsan'"</span>);</span><br><span class="line">                    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">                    jdbcTemplate.update(<span class="hljs-string">"update user set account=account-100 where username='lisi'"</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接注入 TransactionTemplate，然后在 execute 方法中添加回调写核心的业务即可，当抛出异常时，将当前事务标注为只能回滚即可。注意，execute 方法中，如果不需要获取事务执行的结果，则直接使用 TransactionCallbackWithoutResult 类即可，如果要获取事务执行结果，则使用 TransactionCallback 即可。</p><p>这就是两种编程式事务的玩法。</p><p>编程式事务由于代码入侵太严重了，因为在实际开发中使用的很少，我们在项目中更多的是使用声明式事务。</p><h2 id="4-声明式事务"><a href="#4-声明式事务" class="headerlink" title="4. 声明式事务"></a>4. 声明式事务</h2><p>声明式事务如果使用 <code>XML</code> 配置，可以做到无侵入；如果使用 <code>Java</code> 配置，也只有一个 <code>@Transactional</code> 注解侵入而已，相对来说非常容易。</p><p><strong>以下配置针对传统 SSM 项目（因为在 Spring Boot 项目中，事务相关的组件已经配置好了）：</strong></p><h3 id="4-1-XML-配置"><a href="#4-1-XML-配置" class="headerlink" title="4.1 XML 配置"></a>4.1 XML 配置</h3><p>XML 配置声明式事务大致上可以分为三个步骤，如下：</p><ol><li>配置事务管理器</li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql:///spring_tran?serverTimezone=Asia/Shanghai"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置事务通知</li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m4"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置 AOP</li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pc1"</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* org.javaboy.demo.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"pc1"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步和第三步中定义出来的方法交集，就是我们要添加事务的方法。</p><p>配置完成后，如下一些方法就自动具备事务了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update user set money=997 where username=?"</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-Java-配置"><a href="#4-2-Java-配置" class="headerlink" title="4.2 Java 配置"></a>4.2 Java 配置</h3><p>我们也可以使用 Java 配置来实现声明式事务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-comment">//开启事务注解支持</span></span><br><span class="line"><span class="hljs-meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DriverManagerDataSource ds = <span class="hljs-keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setPassword(<span class="hljs-string">"123"</span>);</span><br><span class="line">        ds.setUsername(<span class="hljs-string">"root"</span>);</span><br><span class="line">        ds.setUrl(<span class="hljs-string">"jdbc:mysql:///test01?serverTimezone=Asia/Shanghai"</span>);</span><br><span class="line">        ds.setDriverClassName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要配置的东西其实和 XML 中配置的都差不多，最最关键的就两个：</p><ul><li>事务管理器 PlatformTransactionManager。</li><li>@EnableTransactionManagement 注解开启事务支持。</li></ul><p>配置完成后，接下来，哪个方法需要事务就在哪个方法上添加 <code>@Transactional</code> 注解即可，向下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(noRollbackFor = ArithmeticException.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update4</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">998</span>, <span class="hljs-string">"lisi"</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这个稍微有点代码入侵，不过问题不大，日常开发中这种方式使用较多。当<code>@Transactional</code> 注解加在类上面的时候，表示该类的所有方法都有事务，该注解加在方法上面的时候，表示该方法有事务。</p><h3 id="4-3-混合配置"><a href="#4-3-混合配置" class="headerlink" title="4.3 混合配置"></a>4.3 混合配置</h3><p>也可以 Java 代码和 XML 混合配置来实现声明式事务，就是一部分配置用 XML 来实现，一部分配置用 Java 代码来实现：</p><p>假设 XML 配置如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">&lt;!--</span></span><br><span class="line"><span class="hljs-comment">    开启事务的注解配置，添加了这个配置，就可以直接在代码中通过 @Transactional 注解来开启事务了</span></span><br><span class="line"><span class="hljs-comment">    --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么 Java 代码中的配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-meta">@ImportResource</span>(locations = <span class="hljs-string">"classpath:applicationContext3.xml"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DriverManagerDataSource ds = <span class="hljs-keyword">new</span> DriverManagerDataSource();</span><br><span class="line">        ds.setPassword(<span class="hljs-string">"123"</span>);</span><br><span class="line">        ds.setUsername(<span class="hljs-string">"root"</span>);</span><br><span class="line">        ds.setUrl(<span class="hljs-string">"jdbc:mysql:///test01?serverTimezone=Asia/Shanghai"</span>);</span><br><span class="line">        ds.setDriverClassName(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 配置中通过 @ImportResource 注解导入了 XML 配置，XML 配置中的内容就是开启 <code>@Transactional</code> 注解的支持，所以 Java 配置中省略了 @EnableTransactionManagement 注解。</p><p>这就是声明式事务的几种配置方式。好玩吧！</p><h2 id="5-事务属性"><a href="#5-事务属性" class="headerlink" title="5. 事务属性"></a>5. 事务属性</h2><p>在前面的配置中，我们只是简单说了事务的用法，并没有和大家详细聊一聊事务的一些属性细节，那么接下来我们就来仔细捋一捋事务中的五大属性。</p><h3 id="5-1-隔离性"><a href="#5-1-隔离性" class="headerlink" title="5.1 隔离性"></a>5.1 隔离性</h3><p>首先就是事务的隔离性，也就是事务的隔离级别。</p><p>MySQL 中有四种不同的隔离级别，这四种不同的隔离级别在 Spring 中都得到了很好的支持。Spring 中默认的事务隔离级别是 default，即数据库本身的隔离级别是啥就是啥，default 就能满足我们日常开发中的大部分场景。</p><p>不过如果项目有需要，我们也可以调整事务的隔离级别。</p><p>调整方式如下：</p><h4 id="5-1-1-编程式事务隔离级别"><a href="#5-1-1-编程式事务隔离级别" class="headerlink" title="5.1.1 编程式事务隔离级别"></a>5.1.1 编程式事务隔离级别</h4><p>如果是编程式事务，通过如下方式修改事务的隔离级别：</p><p><strong>TransactionTemplate</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br></pre></td></tr></table></figure><p>TransactionDefinition 中定义了各种隔离级别。</p><p><strong>PlatformTransactionManager</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//创建事务的默认配置</span></span><br><span class="line">    DefaultTransactionDefinition definition = <span class="hljs-keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">    definition.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line">    TransactionStatus status = platformTransactionManager.getTransaction(definition);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">999</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-comment">//提交事务</span></span><br><span class="line">        platformTransactionManager.commit(status);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        <span class="hljs-comment">//回滚</span></span><br><span class="line">        platformTransactionManager.rollback(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是在 DefaultTransactionDefinition 对象中设置事务的隔离级别。</p><h4 id="5-1-2-声明式事务隔离级别"><a href="#5-1-2-声明式事务隔离级别" class="headerlink" title="5.1.2 声明式事务隔离级别"></a>5.1.2 声明式事务隔离级别</h4><p>如果是声明式事务通过如下方式修改隔离级别：</p><p>XML：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-comment">&lt;!--以 add 开始的方法，添加事务--&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add*"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"insert*"</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">"SERIALIZABLE"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Java：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(isolation = Isolation.SERIALIZABLE)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update4</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">998</span>, <span class="hljs-string">"lisi"</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-传播性"><a href="#5-2-传播性" class="headerlink" title="5.2 传播性"></a>5.2 传播性</h3><p>先来说说何谓事务的传播性：</p><blockquote><p>事务传播行为是为了解决业务层方法之间互相调用的事务问题，当一个事务方法被另一个事务方法调用时，事务该以何种状态存在？例如新方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行，等等，这些规则就涉及到事务的传播性。</p></blockquote><p>关于事务的传播性，Spring 主要定义了如下几种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Propagation &#123;</span><br><span class="line">REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line">SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line">MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line">REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line">NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line">NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line">NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;</span><br><span class="line">Propagation(<span class="hljs-keyword">int</span> value) &#123; <span class="hljs-keyword">this</span>.value = value; &#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体含义如下：</p><table><thead><tr><th style="text-align:left">传播性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">REQUIRED</td><td style="text-align:left">如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</td></tr><tr><td style="text-align:left">SUPPORTS</td><td style="text-align:left">如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</td></tr><tr><td style="text-align:left">MANDATORY</td><td style="text-align:left">如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</td></tr><tr><td style="text-align:left">REQUIRES_NEW</td><td style="text-align:left">创建一个新的事务，如果当前存在事务，则把当前事务挂起</td></tr><tr><td style="text-align:left">NOT_SUPPORTED</td><td style="text-align:left">以非事务方式运行，如果当前存在事务，则把当前事务挂起</td></tr><tr><td style="text-align:left">NEVER</td><td style="text-align:left">以非事务方式运行，如果当前存在事务，则抛出异常</td></tr><tr><td style="text-align:left">NESTED</td><td style="text-align:left">如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED</td></tr></tbody></table><p>一共是七种传播性，具体配置也简单：</p><p><strong>TransactionTemplate中的配置</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br></pre></td></tr></table></figure><p><strong>PlatformTransactionManager中的配置</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//创建事务的默认配置</span></span><br><span class="line">    DefaultTransactionDefinition definition = <span class="hljs-keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">    definition.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line">    definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">    TransactionStatus status = platformTransactionManager.getTransaction(definition);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">999</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-comment">//提交事务</span></span><br><span class="line">        platformTransactionManager.commit(status);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        <span class="hljs-comment">//回滚</span></span><br><span class="line">        platformTransactionManager.rollback(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明式事务的配置（XML）</strong></p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-comment">&lt;!--以 add 开始的方法，添加事务--&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add*"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"insert*"</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">"SERIALIZABLE"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>声明式事务的配置（Java）</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(noRollbackFor = ArithmeticException.class,propagation = Propagation.REQUIRED)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update4</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update account set money = ? where username=?;"</span>, <span class="hljs-number">998</span>, <span class="hljs-string">"lisi"</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用就是这么来用，至于七种传播的具体含义，松哥来和大家一个一个说。</p><h4 id="5-2-1-REQUIRED"><a href="#5-2-1-REQUIRED" class="headerlink" title="5.2.1 REQUIRED"></a>5.2.1 REQUIRED</h4><p>REQUIRED 表示如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p>例如我有如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="hljs-meta">@Transactional</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update user set money = ? where id=?;"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountService2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AccountService accountService;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="hljs-string">"update user set money = ? where username=?;"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">        accountService.handle1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在 handle2 方法中调用 handle1。</p><p>那么：</p><ol><li>如果 handle2 方法本身是有事务的，则 handle1 方法就会加入到 handle2 方法所在的事务中，这样两个方法将处于同一个事务中，一起成功或者一起失败（不管是 handle2 还是 handle1 谁抛异常，都会导致整体回滚）。</li><li>如果 handle2 方法本身是没有事务的，则 handle1 方法就会自己开启一个新的事务，自己玩。</li></ol><p>举一个简单的例子：handle2 方法有事务，handle1 方法也有事务（小伙伴们根据前面的讲解自行配置事务），项目打印出来的事务日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.spring_tran02.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@875256468 wrapping com.mysql.cj.jdbc.ConnectionImpl@9753d50] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@875256468 wrapping com.mysql.cj.jdbc.ConnectionImpl@9753d50] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Participating in existing transaction</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@875256468 wrapping com.mysql.cj.jdbc.ConnectionImpl@9753d50]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@875256468 wrapping com.mysql.cj.jdbc.ConnectionImpl@9753d50] after transaction</span><br></pre></td></tr></table></figure><p>从日志中可以看到，前前后后一共就开启了一个事务，日志中有这么一句：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Participating in existing transaction</span><br></pre></td></tr></table></figure><p>这个就说明 handle1 方法没有自己开启事务，而是加入到 handle2 方法的事务中了。</p><h4 id="5-2-2-REQUIRES-NEW"><a href="#5-2-2-REQUIRES-NEW" class="headerlink" title="5.2.2 REQUIRES_NEW"></a>5.2.2 REQUIRES_NEW</h4><p>REQUIRES_NEW 表示创建一个新的事务，如果当前存在事务，则把<strong>当前事务挂起</strong>。换言之，不管外部方法是否有事务，REQUIRES_NEW 都会开启自己的事务。</p><p>这块松哥要多说两句，有的小伙伴可能觉得 REQUIRES_NEW 和 REQUIRED 太像了，似乎没啥区别。其实你要是单纯看最终回滚效果，可能确实看不到啥区别。但是，大家注意松哥上面的加粗，在 REQUIRES_NEW 中可能会同时存在两个事务，外部方法的事务被挂起，内部方法的事务独自运行，而在 REQUIRED 中则不会出现这种情况，如果内外部方法传播性都是 REQUIRED，那么最终也只是一个事务。</p><p>还是上面那个例子，假设 handle1 和 handle2 方法都有事务，handle2 方法的事务传播性是 REQUIRED，而 handle1 方法的事务传播性是 REQUIRES_NEW，那么最终打印出来的事务日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.spring_tran02.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@422278016 wrapping com.mysql.cj.jdbc.ConnectionImpl@732405c2] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@422278016 wrapping com.mysql.cj.jdbc.ConnectionImpl@732405c2] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Suspending current transaction, creating new transaction with name [org.javaboy.spring_tran02.AccountService.handle1]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@247691344 wrapping com.mysql.cj.jdbc.ConnectionImpl@14ad4b95] for JDBC transaction</span><br><span class="line">com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@14ad4b95</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@247691344 wrapping com.mysql.cj.jdbc.ConnectionImpl@14ad4b95] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@247691344 wrapping com.mysql.cj.jdbc.ConnectionImpl@14ad4b95]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@247691344 wrapping com.mysql.cj.jdbc.ConnectionImpl@14ad4b95] after transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Resuming suspended transaction after completion of inner transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@422278016 wrapping com.mysql.cj.jdbc.ConnectionImpl@732405c2]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@422278016 wrapping com.mysql.cj.jdbc.ConnectionImpl@732405c2] after transaction</span><br></pre></td></tr></table></figure><p>分析这段日志我们可以看到：</p><ol><li>首先为 handle2 方法开启了一个事务。</li><li>执行完 handle2 方法的 SQL 之后，事务被刮起（Suspending）。</li><li>为 handle1 方法开启了一个新的事务。</li><li>执行 handle1 方法的 SQL。</li><li>提交 handle1 方法的事务。</li><li>恢复被挂起的事务（Resuming）。</li><li>提交 handle2 方法的事务。</li></ol><p>从这段日志中大家可以非常明确的看到 REQUIRES_NEW 和 REQUIRED 的区别。</p><p>松哥再来简单总结下(假设 handle1 方法的事务传播性是 REQUIRES_NEW)：</p><ol><li>如果 handle2 方法没有事务，handle1 方法自己开启一个事务自己玩。</li><li>如果 handle2 方法有事务，handle1 方法还是会开启一个事务。此时，如果 handle2 发生了异常进行回滚，并不会导致 handle1 方法回滚，因为 handle1 方法是独立的事务；如果 handle1 方法发生了异常导致回滚，并且 handle1 方法的异常没有被捕获处理传到了 handle2 方法中，那么也会导致 handle2 方法回滚。</li></ol><blockquote><p>这个地方小伙伴们要稍微注意一下，我们测试的时候，由于是两个更新 SQL，如果更新的查询字段不是索引字段，那么 InnoDB 将使用表锁，这样就会发生死锁（handle2 方法执行时开启表锁，导致 handle1 方法陷入等待中，而必须 handle1 方法执行完，handle2 才能释放锁）。所以，在上面的测试中，我们要将 username 字段设置为索引字段，这样默认就使用行锁了。</p></blockquote><h4 id="5-2-3-NESTED"><a href="#5-2-3-NESTED" class="headerlink" title="5.2.3 NESTED"></a>5.2.3 NESTED</h4><p>NESTED 表示如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED。</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 NESTED，那么最终执行的事务日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.demo.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@2025689131 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ed3628e] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@2025689131 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ed3628e] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating nested transaction with name [org.javaboy.demo.AccountService.handle1]</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing transaction savepoint</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@2025689131 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ed3628e]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@2025689131 wrapping com.mysql.cj.jdbc.ConnectionImpl@2ed3628e] after transaction</span><br></pre></td></tr></table></figure><p>关键一句在 <code>Creating nested transaction</code>。</p><p>此时，NESTED 修饰的内部方法（handle1）属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务（需要处理掉内部子事务的异常）。</p><h4 id="5-2-4-MANDATORY"><a href="#5-2-4-MANDATORY" class="headerlink" title="5.2.4 MANDATORY"></a>5.2.4 MANDATORY</h4><p>MANDATORY 表示如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p><p>这个好理解，我举两个例子：</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 MANDATORY，那么最终执行的事务日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.demo.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@768820610 wrapping com.mysql.cj.jdbc.ConnectionImpl@14840df2] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@768820610 wrapping com.mysql.cj.jdbc.ConnectionImpl@14840df2] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Participating in existing transaction</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@768820610 wrapping com.mysql.cj.jdbc.ConnectionImpl@14840df2]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@768820610 wrapping com.mysql.cj.jdbc.ConnectionImpl@14840df2] after transaction</span><br></pre></td></tr></table></figure><p>从这段日志可以看出：</p><ol><li>首先给 handle2 方法开启事务。</li><li>执行 handle2 方法的 SQL。</li><li>handle1 方法加入到已经存在的事务中。</li><li>执行 handle1 方法的 SQL。</li><li>提交事务。</li></ol><p>假设 handle2 方法无事务，handle1 方法有事务且传播性为 MANDATORY，那么最终执行时会抛出如下异常：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No existing transaction found for transaction marked with propagation &apos;mandatory&apos;</span><br></pre></td></tr></table></figure><p>由于没有已经存在的事务，所以出错了。</p><h4 id="5-2-5-SUPPORTS"><a href="#5-2-5-SUPPORTS" class="headerlink" title="5.2.5 SUPPORTS"></a>5.2.5 SUPPORTS</h4><p>SUPPORTS 表示如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p><p>这个也简单，举两个例子大家就明白了。</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 SUPPORTS，那么最终事务执行日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.demo.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@1780573324 wrapping com.mysql.cj.jdbc.ConnectionImpl@44eafcbc] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@1780573324 wrapping com.mysql.cj.jdbc.ConnectionImpl@44eafcbc] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Participating in existing transaction</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@1780573324 wrapping com.mysql.cj.jdbc.ConnectionImpl@44eafcbc]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@1780573324 wrapping com.mysql.cj.jdbc.ConnectionImpl@44eafcbc] after transaction</span><br></pre></td></tr></table></figure><p>这段日志很简单，没啥好说的，认准 <code>Participating in existing transaction</code> 表示加入到已经存在的事务中即可。</p><p>假设 handle2 方法无事务，handle1 方法有事务且传播性为 SUPPORTS，这个最终就不会开启事务了，也没有相关日志。</p><h4 id="5-2-6-NOT-SUPPORTED"><a href="#5-2-6-NOT-SUPPORTED" class="headerlink" title="5.2.6 NOT_SUPPORTED"></a>5.2.6 NOT_SUPPORTED</h4><p>NOT_SUPPORTED 表示以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 NOT_SUPPORTED，那么最终事务执行日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Creating new transaction with name [org.javaboy.demo.AccountService2.handle2]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Acquired Connection [HikariProxyConnection@1365886554 wrapping com.mysql.cj.jdbc.ConnectionImpl@3198938b] for JDBC transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Switching JDBC Connection [HikariProxyConnection@1365886554 wrapping com.mysql.cj.jdbc.ConnectionImpl@3198938b] to manual commit</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where username=?;]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Suspending current transaction</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL update</span><br><span class="line">o.s.jdbc.core.JdbcTemplate               : Executing prepared SQL statement [update user set money = ? where id=?;]</span><br><span class="line">o.s.jdbc.datasource.DataSourceUtils      : Fetching JDBC Connection from DataSource</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Resuming suspended transaction after completion of inner transaction</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Initiating transaction commit</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Committing JDBC transaction on Connection [HikariProxyConnection@1365886554 wrapping com.mysql.cj.jdbc.ConnectionImpl@3198938b]</span><br><span class="line">o.s.jdbc.support.JdbcTransactionManager  : Releasing JDBC Connection [HikariProxyConnection@1365886554 wrapping com.mysql.cj.jdbc.ConnectionImpl@3198938b] after transaction</span><br></pre></td></tr></table></figure><p>这段日志大家认准这两句就行了 ： <code>Suspending current transaction</code> 表示挂起当前事务；<code>Resuming suspended transaction</code> 表示恢复挂起的事务。 </p><h4 id="5-2-7-NEVER"><a href="#5-2-7-NEVER" class="headerlink" title="5.2.7 NEVER"></a>5.2.7 NEVER</h4><p>NEVER 表示以非事务方式运行，如果当前存在事务，则抛出异常。</p><p>假设 handle2 方法有事务，handle1 方法也有事务且传播性为 NEVER，那么最终会抛出如下异常：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Existing transaction found for transaction marked with propagation &apos;never&apos;</span><br></pre></td></tr></table></figure><h3 id="5-3-回滚规则"><a href="#5-3-回滚规则" class="headerlink" title="5.3 回滚规则"></a>5.3 回滚规则</h3><p>默认情况下，事务只有遇到运行期异常（RuntimeException 的子类）以及 Error 时才会回滚，在遇到检查型（Checked Exception）异常时不会回滚。</p><p>像 1/0，空指针这些是 RuntimeException，而 IOException 则算是 Checked Exception，换言之，默认情况下，如果发生 IOException 并不会导致事务回滚。</p><p>如果我们希望发生 IOException 时也能触发事务回滚，那么可以按照如下方式配置：</p><p>Java 配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(rollbackFor = IOException.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update user set money = ? where username=?;"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">    accountService.handle1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">"java.io.IOException"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，我们也可以指定在发生某些异常时不回滚，例如当系统抛出 ArithmeticException 异常并不要触发事务回滚，配置方式如下：</p><p>Java 配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(noRollbackFor = ArithmeticException.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="hljs-string">"update user set money = ? where username=?;"</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"zhangsan"</span>);</span><br><span class="line">    accountService.handle1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span> <span class="hljs-attr">no-rollback-for</span>=<span class="hljs-string">"java.lang.ArithmeticException"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-是否只读"><a href="#5-4-是否只读" class="headerlink" title="5.4 是否只读"></a>5.4 是否只读</h3><p>只读事务一般设置在查询方法上，但不是所有的查询方法都需要只读事务，要看具体情况。</p><p>一般来说，如果这个业务方法只有一个查询 SQL，那么就没必要添加事务，强行添加最终效果适得其反。</p><p>但是如果一个业务方法中有多个查询 SQL，情况就不一样了：多个查询 SQL，默认情况下，每个查询 SQL 都会开启一个独立的事务，这样，如果有并发操作修改了数据，那么多个查询 SQL 就会查到不一样的数据。此时，如果我们开启事务，并设置为只读事务，那么多个查询 SQL 将被置于同一个事务中，多条相同的 SQL 在该事务中执行将会获取到相同的查询结果。</p><p>设置事务只读的方式如下：</p><p>Java 配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(readOnly = <span class="hljs-keyword">true</span>)</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-5-超时时间"><a href="#5-5-超时时间" class="headerlink" title="5.5 超时时间"></a>5.5 超时时间</h3><p>超时时间是说一个事务允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><p>事务超时时间配置方式如下(单位为秒)：</p><p>Java 配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span>(timeout = <span class="hljs-number">10</span>)</span><br></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txAdvice"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"m3"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>TransactionDefinition</code> 中以 int 的值来表示超时时间，其单位是秒，默认值为-1。</p><h2 id="6-事务失效"><a href="#6-事务失效" class="headerlink" title="6. 事务失效"></a>6. 事务失效</h2><p>那么什么情况下事务会失效呢？</p><h3 id="6-1-方法自调用"><a href="#6-1-方法自调用" class="headerlink" title="6.1 方法自调用"></a>6.1 方法自调用</h3><p>这个主要是针对声明式事务的，经过前面的介绍，小伙伴们其实也能够看出来，声明式事务底层其实就是 AOP，所以在声明式事务中，我们我们拿到的服务类并不是服务类本身，而是一个代理对象，在这个代理对象中的代理方法中，自动添加了事务的逻辑，所以如果我们直接方法自调用，没有经过这个代理对象，事务就会失效。</p><p>我写一段<strong>伪代码</strong>小伙伴们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span></span>&#123;</span><br><span class="line">   <span class="hljs-meta">@Transactional</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，如果我们在 UserController 中注入 UserService，那么拿到的并不是 UserService 对象本身，而是通过动态代理为 UserService 生成的一个动态代理类，这个动态代理就类似下面这样（<strong>伪代码</strong>）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserService</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">            <span class="hljs-comment">//开启事务</span></span><br><span class="line">            <span class="hljs-comment">//调用父类 sayHello</span></span><br><span class="line">            <span class="hljs-comment">//提交事务</span></span><br><span class="line">        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="hljs-comment">//回滚事务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以你最终调用的并不是 UserService 本身的方法，而是动态代理对象中的方法。</p><p>因此，如果存在这样的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span></span>&#123;</span><br><span class="line">   <span class="hljs-meta">@Transactional</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;&#125;</span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">useSayHello</span><span class="hljs-params">()</span></span>&#123;sayHello();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 useSayHello 中调用 sayHello 方法，sayHello 方法上虽然有事务注解，但是这里的事务不生效（因为调用的不是的动态代理对象中的 sayHello 方法，而是当前对象 this 的 sayHello 方法）。</p><h3 id="6-2-异常被捕获"><a href="#6-2-异常被捕获" class="headerlink" title="6.2 异常被捕获"></a>6.2 异常被捕获</h3><p>搞明白了 6.1，再来看 6.2 小节就很容易懂了。</p><p>如果我们在 sayHello 方法中将异常捕获了，那么动态代理类中的方法，就感知不知道目标方法发生异常了，自然也就不会自动处理事务回滚了。还是以前面的 UserServiceProxy 为例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserService</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">            <span class="hljs-comment">//开启事务</span></span><br><span class="line">            <span class="hljs-comment">//调用父类 sayHello</span></span><br><span class="line">            <span class="hljs-comment">//提交事务</span></span><br><span class="line">        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="hljs-comment">//回滚事务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果调用 <code>调用父类 sayHello</code> 的时候，sayHello 方法自动将异常捕获了，那么很明显，这里就不会进行异常回滚了。</p><h3 id="6-3-方法非-public"><a href="#6-3-方法非-public" class="headerlink" title="6.3 方法非 public"></a>6.3 方法非 public</h3><p>这个算是 Spring 官方的一个强制要求了，声明式事务方法只能是 public，对于非 public 的方法如果想用声明式事务，那得上 AspectJ。</p><h3 id="6-4-非运行时异常"><a href="#6-4-非运行时异常" class="headerlink" title="6.4 非运行时异常"></a>6.4 非运行时异常</h3><p>这个前面 5.3 小节介绍过了，默认情况下，只会捕获 RuntimeException，如果想扩大捕获范围，可以自行配置。</p><h3 id="6-5-不是-Spring-Bean"><a href="#6-5-不是-Spring-Bean" class="headerlink" title="6.5 不是 Spring Bean"></a>6.5 不是 Spring Bean</h3><p>基于 6.1 小节的理解，来看这个应该也很好懂。声明式事务主要是通过动态代理来处理事务的，如果你拿到手的 UserService 对象就是原原本本的 UserService（如果自己 new 了一个 UserService 就是这种情况），那么事务代码在哪里？没有事务处理的代码，事务自然不会生效。</p><blockquote><p><strong>声明式事务的核心，就是动态代理生成的那个对象，没有用到那个对象，事务就没戏。</strong></p></blockquote><h3 id="6-6-数据库不支持事务"><a href="#6-6-数据库不支持事务" class="headerlink" title="6.6 数据库不支持事务"></a>6.6 数据库不支持事务</h3><p>这个没啥好说，数据库不支持，Spring 咋配都没用。</p><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p>好啦，这就是松哥和大家分享的 Spring 事务的玩法，不知道小伙伴们搞明白没有？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.itboyhub.com/2022/08/20221205223550.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;最近有小伙伴告诉松哥说面试中被问到这个问题了，不知道该怎么回答，这能忍？捋一篇文章和小伙伴们分享下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用 SpringBoot 开发微信公众号后台</title>
    <link href="http://www.javaboy.org/2022/1205/springboot-weixin.html"/>
    <id>http://www.javaboy.org/2022/1205/springboot-weixin.html</id>
    <published>2022-12-05T10:24:11.000Z</published>
    <updated>2022-12-20T11:07:26.430Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Hello 各位小伙伴，松哥今天要和大家聊一个有意思的话题，就是使用 Spring Boot 开发微信公众号后台。</p><a id="more"></a><p>很多小伙伴可能注意到松哥的微信公众号后台有一个回复关键字如 <code>666</code> 或者 <code>888</code> 可以获取学习资料的功能，这是松哥基于 Spring Boot 写的一个简单后台，今天我们就来简单聊聊这个如何实现。</p><h2 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1. 实现思路"></a>1. 实现思路</h2><p>其实松哥这个回复关键字获取学习资料实现原理很简单，说白了，就是一个数据查询操作而已，回复的口令是查询关键字，回复的内容则是查询结果。这个原理很简单。</p><p>另一方面大家需要明白微信公众号后台开发消息发送的一个流程，大家看下面这张图：</p><p><img src="http://img.itboyhub.com/2021/springboot2/46-2.jpeg" alt></p><p>这是大家在公众号后台回复关键字的情况。那么这个消息是怎么样一个传递流程呢？我们来看看下面这张图：</p><p><img src="http://img.itboyhub.com/2021/springboot2/46-1.png" alt></p><p>这张图，我给大家稍微解释下：</p><ol><li>首先 <code>javaboy4096</code> 这个字符从公众号上发送到了微信服务器</li><li>接下来微信服务器会把 <code>javaboy4096</code> 转发到我自己的服务器上</li><li>我收到 <code>javaboy4096</code> 这个字符之后，就去数据库中查询，将查询的结果，按照腾讯要求的 XML 格式进行返回</li><li>微信服务器把从我的服务器收到的信息，再发回到微信上，于是小伙伴们就看到了返回结果了</li></ol><p>大致的流程就是这个样子。</p><p>接下来我们就来看一下实现细节。</p><h2 id="2-公众号后台配置"><a href="#2-公众号后台配置" class="headerlink" title="2. 公众号后台配置"></a>2. 公众号后台配置</h2><p>开发的第一步，是微信服务器要验证我们自己的服务器是否有效。</p><p>首先我们登录微信公众平台官网后，在公众平台官网的 <strong>开发-基本设置</strong> 页面，勾选协议成为开发者，然后点击“修改配置”按钮，填写：</p><ul><li>服务器地址（URL）</li><li>Token</li><li>EncodingAESKey</li></ul><p><img src="http://img.itboyhub.com/2021/springboot2/46-3.jpeg" alt></p><p>这里的 URL 配置好之后，我们需要针对这个 URL 开发两个接口，一个是 GET 请求的接口，这个接口用来做服务器有效性验证，另一个则是 POST 请求的接口，这个用来接收微信服务器发送来的消息。也就是说，微信服务器的消息都是通过 POST 请求发给我的。</p><p>Token 可由开发者可以任意填写，用作生成签名（该 Token 会和接口 URL 中包含的 Token 进行比对，从而验证安全性）。</p><p>EncodingAESKey 由开发者手动填写或随机生成，将用作消息体加解密密钥。</p><p>同时，开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。明文模式就是我们自己的服务器收到微信服务器发来的消息是明文字符串，直接就可以读取并且解析，安全模式则是我们收到微信服务器发来的消息是加密的消息，需要我们手动解析后才能使用。</p><h2 id="3-开发"><a href="#3-开发" class="headerlink" title="3. 开发"></a>3. 开发</h2><p>公众号后台配置完成后，接下来我们就可以写代码了。</p><h3 id="3-1-服务器有效性校验"><a href="#3-1-服务器有效性校验" class="headerlink" title="3.1 服务器有效性校验"></a>3.1 服务器有效性校验</h3><p>我们首先来创建一个普通的 Spring Boot 项目，创建时引入 <code>spring-boot-starter-web</code> 依赖，项目创建成功后，我们创建一个 Controller ，添加如下接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/verify_wx_token"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    String signature = request.getParameter(<span class="hljs-string">"signature"</span>);</span><br><span class="line">    String timestamp = request.getParameter(<span class="hljs-string">"timestamp"</span>);</span><br><span class="line">    String nonce = request.getParameter(<span class="hljs-string">"nonce"</span>);</span><br><span class="line">    String echostr = request.getParameter(<span class="hljs-string">"echostr"</span>);</span><br><span class="line">    PrintWriter out = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        out = response.getWriter();</span><br><span class="line">        <span class="hljs-keyword">if</span> (CheckUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">            out.write(echostr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这段代码，我做如下解释：</p><ol><li>首先通过 request.getParameter 方法获取到微信服务器发来的 signature、timestamp、nonce 以及 echostr 四个参数，这四个参数中：signature 表示微信加密签名，signature 结合了开发者填写的 token 参数和请求中的timestamp参数、nonce参数；timestamp 表示时间戳；nonce    表示随机数；echostr    则表示一个随机字符串。</li><li>开发者通过检验 signature 对请求进行校验，如果确认此次 GET 请求来自微信服务器，则原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。</li><li>具体的校验就是松哥这里的 CheckUtil.checkSignature 方法，在这个方法中，首先将token、timestamp、nonce 三个参数进行字典序排序，然后将三个参数字符串拼接成一个字符串进行 sha1 加密，最后开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信。</li></ol><p>校验代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckUtil</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String token = <span class="hljs-string">"123456"</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkSignature</span><span class="hljs-params">(String signature, String timestamp, String nonce)</span> </span>&#123;</span><br><span class="line">        String[] str = <span class="hljs-keyword">new</span> String[]&#123;token, timestamp, nonce&#125;;</span><br><span class="line">        <span class="hljs-comment">//排序</span></span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        <span class="hljs-comment">//拼接字符串</span></span><br><span class="line">        StringBuffer buffer = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            buffer.append(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//进行sha1加密</span></span><br><span class="line">        String temp = SHA1.encode(buffer.toString());</span><br><span class="line">        <span class="hljs-comment">//与微信提供的signature进行匹对</span></span><br><span class="line">        <span class="hljs-keyword">return</span> signature.equals(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SHA1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] HEX_DIGITS = &#123;<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>,</span><br><span class="line">            <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>&#125;;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getFormattedText</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = bytes.length;</span><br><span class="line">        StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(len * <span class="hljs-number">2</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            buf.append(HEX_DIGITS[(bytes[j] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>]);</span><br><span class="line">            buf.append(HEX_DIGITS[bytes[j] &amp; <span class="hljs-number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encode</span><span class="hljs-params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string">"SHA1"</span>);</span><br><span class="line">            messageDigest.update(str.getBytes());</span><br><span class="line">            <span class="hljs-keyword">return</span> getFormattedText(messageDigest.digest());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，完成之后，我们的校验接口就算是开发完成了。接下来就可以开发消息接收接口了。</p><h3 id="3-2-消息接收接口"><a href="#3-2-消息接收接口" class="headerlink" title="3.2 消息接收接口"></a>3.2 消息接收接口</h3><p>接下来我们来开发消息接收接口，消息接收接口和上面的服务器校验接口地址是一样的，都是我们一开始在公众号后台配置的地址。只不过消息接收接口是一个 POST 请求。</p><p>我在公众号后台配置的时候，消息加解密方式选择了明文模式，这样我在后台收到的消息直接就可以处理了。微信服务器给我发来的普通文本消息格式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">xml</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">CreateTime</span>&gt;</span>1348831860<span class="hljs-tag">&lt;/<span class="hljs-name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span>&lt;![CDATA[this is a test]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">MsgId</span>&gt;</span>1234567890123456<span class="hljs-tag">&lt;/<span class="hljs-name">MsgId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些参数含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ToUserName</td><td style="text-align:left">开发者微信号</td></tr><tr><td style="text-align:left">FromUserName</td><td style="text-align:left">发送方帐号（一个OpenID）</td></tr><tr><td style="text-align:left">CreateTime</td><td style="text-align:left">消息创建时间 （整型）</td></tr><tr><td style="text-align:left">MsgType</td><td style="text-align:left">消息类型，文本为text</td></tr><tr><td style="text-align:left">Content</td><td style="text-align:left">文本消息内容</td></tr><tr><td style="text-align:left">MsgId</td><td style="text-align:left">消息id，64位整型</td></tr></tbody></table><p>看到这里，大家心里大概就有数了，当我们收到微信服务器发来的消息之后，我们就进行 XML 解析，提取出来我们需要的信息，去做相关的查询操作，再将查到的结果返回给微信服务器。</p><p>这里我们先来个简单的，我们将收到的消息解析并打印出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/verify_wx_token"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    Map&lt;String, String&gt; parseXml = MessageUtil.parseXml(request);</span><br><span class="line">    String msgType = parseXml.get(<span class="hljs-string">"MsgType"</span>);</span><br><span class="line">    String content = parseXml.get(<span class="hljs-string">"Content"</span>);</span><br><span class="line">    String fromusername = parseXml.get(<span class="hljs-string">"FromUserName"</span>);</span><br><span class="line">    String tousername = parseXml.get(<span class="hljs-string">"ToUserName"</span>);</span><br><span class="line">    System.out.println(msgType);</span><br><span class="line">    System.out.println(content);</span><br><span class="line">    System.out.println(fromusername);</span><br><span class="line">    System.out.println(tousername);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; <span class="hljs-title">parseXml</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    InputStream inputStream = request.getInputStream();</span><br><span class="line">    SAXReader reader = <span class="hljs-keyword">new</span> SAXReader();</span><br><span class="line">    Document document = reader.read(inputStream);</span><br><span class="line">    Element root = document.getRootElement();</span><br><span class="line">    List&lt;Element&gt; elementList = root.elements();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Element e : elementList)</span><br><span class="line">        map.put(e.getName(), e.getText());</span><br><span class="line">    inputStream.close();</span><br><span class="line">    inputStream = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到其实都是一些常规代码，没有什么难度。</p><p>做完这些之后，我们将项目打成 jar 包在服务器上部署启动。启动成功之后，确认微信的后台配置也没问题，我们就可以在公众号上发一条消息了，这样我们自己的服务端就会打印出来刚刚消息的信息。</p><h2 id="4-消息分类"><a href="#4-消息分类" class="headerlink" title="4. 消息分类"></a>4. 消息分类</h2><p>在讨论如何给微信服务器回复消息之前，我们需要先来了解下微信服务器发来的消息主要有哪些类型以及我们回复给微信的消息都有哪些类型。</p><p>在前文中大家了解到，微信发送来的 xml 消息中有一个 MsgType 字段，这个字段就是用来标记消息的类型。这个类型可以标记出这条消息是普通消息还是事件消息还是图文消息等。</p><p>普通消息主要是指：</p><ul><li>文本消息</li><li>图片消息</li><li>语音消息</li><li>视频消息</li><li>小视频消息</li><li>地址位置消息</li><li>链接消息</li></ul><p>不同的消息类型，对应不同的 MsgType，这里我还是以普通消息为例，如下：</p><table><thead><tr><th style="text-align:left">消息类型</th><th style="text-align:left">MsgType</th></tr></thead><tbody><tr><td style="text-align:left">文本消息</td><td style="text-align:left">text</td></tr><tr><td style="text-align:left">图片消息</td><td style="text-align:left">image</td></tr><tr><td style="text-align:left">语音消息</td><td style="text-align:left">voice</td></tr><tr><td style="text-align:left">视频消息</td><td style="text-align:left">video</td></tr><tr><td style="text-align:left">小视频消息</td><td style="text-align:left">shortvideo</td></tr><tr><td style="text-align:left">地址位置消息</td><td style="text-align:left">location</td></tr><tr><td style="text-align:left">链接消息</td><td style="text-align:left">link</td></tr></tbody></table><p>大家千万不要以为不同类型消息的格式是一样的，其实是不一样的，也就是说，MsgType 为 text 的消息和 MsgType 为 image 的消息，微信服务器发给我们的消息内容是不一样的，这样带来一个问题就是我无法使用一个 Bean 去接收不同类型的数据，因此这里我们一般使用 Map 接收即可。</p><p>这是消息的接收，除了消息的接收之外，还有一个消息的回复，我们回复的消息也有很多类型，可以回复普通消息，也可以回复图片消息，回复语音消息等，不同的回复消息我们可以进行相应的封装。因为不同的返回消息实例也是有一些共同的属性的，例如消息是谁发来的，发给谁，消息类型，消息 id 等，所以我们可以将这些共同的属性定义成一个父类，然后不同的消息再去继承这个父类。</p><h2 id="5-返回消息类型定义"><a href="#5-返回消息类型定义" class="headerlink" title="5. 返回消息类型定义"></a>5. 返回消息类型定义</h2><p>首先我们来定义一个公共的消息类型：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String ToUserName;</span><br><span class="line">    <span class="hljs-keyword">private</span> String FromUserName;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> CreateTime;</span><br><span class="line">    <span class="hljs-keyword">private</span> String MsgType;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> MsgId;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li>ToUserName 表示开发者的微信号</li><li>FromUserName 表示发送方账号（用户的 OpenID）</li><li>CreateTime 消息的创建时间</li><li>MsgType 表示消息的类型</li><li>MsgId 表示消息 id</li></ul><p>这是我们的基本消息类型，就是说，我们返回给用户的消息，无论是什么类型的消息，都有这几个基本属性。然后在此基础上，我们再去扩展出文本消息、图片消息 等。</p><p>我们来看下文本消息的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String Content;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文本消息在前面消息的基础上多了一个 Content 属性，因此文本消息继承自 BaseMessage ，再额外添加一个 Content 属性即可。</p><p>其他的消息类型也是类似的定义，我就不一一列举了，至于其他消息的格式，大家可以参考微信开放文档（<a href="http://1t.click/aPXK）。" target="_blank" rel="noopener">http://1t.click/aPXK）。</a></p><h2 id="6-返回消息生成"><a href="#6-返回消息生成" class="headerlink" title="6. 返回消息生成"></a>6. 返回消息生成</h2><p>消息类型的 Bean 定义完成之后，接下来就是将实体类生成 XML。</p><p>首先我们定义一个消息工具类，将常见的消息类型枚举出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：文本</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_TEXT = <span class="hljs-string">"text"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：音乐</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_MUSIC = <span class="hljs-string">"music"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：图文</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_NEWS = <span class="hljs-string">"news"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：图片</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Image = <span class="hljs-string">"image"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：语音</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Voice = <span class="hljs-string">"voice"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：视频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Video = <span class="hljs-string">"video"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：文本</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_TEXT = <span class="hljs-string">"text"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：图片</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_IMAGE = <span class="hljs-string">"image"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：链接</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_LINK = <span class="hljs-string">"link"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：地理位置</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_LOCATION = <span class="hljs-string">"location"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：音频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_VOICE = <span class="hljs-string">"voice"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：视频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_VIDEO = <span class="hljs-string">"video"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：推送</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_EVENT = <span class="hljs-string">"event"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：subscribe(订阅)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_SUBSCRIBE = <span class="hljs-string">"subscribe"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：unsubscribe(取消订阅)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_UNSUBSCRIBE = <span class="hljs-string">"unsubscribe"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：CLICK(自定义菜单点击事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_CLICK = <span class="hljs-string">"CLICK"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：VIEW(自定义菜单 URl 视图)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_VIEW = <span class="hljs-string">"VIEW"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：LOCATION(上报地理位置事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_LOCATION = <span class="hljs-string">"LOCATION"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：LOCATION(上报地理位置事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_SCAN = <span class="hljs-string">"SCAN"</span>;</span><br></pre></td></tr></table></figure><p>大家注意这里消息类型的定义，以 RESP 开头的表示返回的消息类型，以 REQ 表示微信服务器发来的消息类型。然后在这个工具类中再定义两个方法，用来将返回的对象转换成 XML：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">textMessageToXml</span><span class="hljs-params">(TextMessage textMessage)</span> </span>&#123;</span><br><span class="line">    xstream.alias(<span class="hljs-string">"xml"</span>, textMessage.getClass());</span><br><span class="line">    <span class="hljs-keyword">return</span> xstream.toXML(textMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> XStream xstream = <span class="hljs-keyword">new</span> XStream(<span class="hljs-keyword">new</span> XppDriver() &#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HierarchicalStreamWriter <span class="hljs-title">createWriter</span><span class="hljs-params">(Writer out)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PrettyPrintWriter(out) &#123;</span><br><span class="line">            <span class="hljs-keyword">boolean</span> cdata = <span class="hljs-keyword">true</span>;</span><br><span class="line">            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"rawtypes"</span>)</span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startNode</span><span class="hljs-params">(String name, Class clazz)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">super</span>.startNode(name, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeText</span><span class="hljs-params">(QuickWriter writer, String text)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (cdata) &#123;</span><br><span class="line">                    writer.write(<span class="hljs-string">"&lt;![CDATA["</span>);</span><br><span class="line">                    writer.write(text);</span><br><span class="line">                    writer.write(<span class="hljs-string">"]]&gt;"</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    writer.write(text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>textMessageToXML 方法用来将 TextMessage 对象转成 XML 返回给微信服务器，类似的方法我们还需要定义 imageMessageToXml、voiceMessageToXml 等，不过定义的方式都基本类似，我就不一一列出来了。</p><h2 id="7-返回消息分发"><a href="#7-返回消息分发" class="headerlink" title="7. 返回消息分发"></a>7. 返回消息分发</h2><p>由于用户发来的消息可能存在多种情况，我们需要分类进行处理，这个就涉及到返回消息的分发问题。因此我在这里再定义一个返回消息分发的工具类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">processMessage</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        String openid = map.get(<span class="hljs-string">"FromUserName"</span>); <span class="hljs-comment">//用户 openid</span></span><br><span class="line">        String mpid = map.get(<span class="hljs-string">"ToUserName"</span>);   <span class="hljs-comment">//公众号原始 ID</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (map.get(<span class="hljs-string">"MsgType"</span>).equals(MessageUtil.REQ_MESSAGE_TYPE_TEXT)) &#123; </span><br><span class="line">            <span class="hljs-comment">//普通文本消息</span></span><br><span class="line">            TextMessage txtmsg = <span class="hljs-keyword">new</span> TextMessage();</span><br><span class="line">            txtmsg.setToUserName(openid);</span><br><span class="line">            txtmsg.setFromUserName(mpid);</span><br><span class="line">            txtmsg.setCreateTime(<span class="hljs-keyword">new</span> Date().getTime());</span><br><span class="line">            txtmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">            txtmsg.setContent(<span class="hljs-string">"这是返回消息"</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> MessageUtil.textMessageToXml(txtmsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">processEvent</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//在这里处理事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还可以多加几个 elseif 去判断不同的消息类型，我这里因为只有普通文本消息，所以一个 if 就够用了。</p><p>在这里返回值我写死了，实际上这里需要根据微信服务端传来的 Content 去数据中查询，将查询结果返回，数据库查询这一套相信大家都能搞定，我这里就不重复介绍了。</p><p>最后在消息接收 Controller 中调用该方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(value = <span class="hljs-string">"/verify_wx_token"</span>,produces = <span class="hljs-string">"application/xml;charset=utf-8"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handler</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = MessageUtil.parseXml(request);</span><br><span class="line">    String msgType = map.get(<span class="hljs-string">"MsgType"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (MessageUtil.REQ_MESSAGE_TYPE_EVENT.equals(msgType)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageDispatcher.processEvent(map);</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageDispatcher.processMessage(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Controller 中，我们首先判断消息是否是事件，如果是事件，进入到事件处理通道，如果不是事件，则进入到消息处理通道。</p><p><strong>注意，这里需要配置一下返回消息的编码，否则可能会出现中文乱码。</strong></p><p>如此之后，我们的服务器就可以给公众号返回消息了。</p><p>好了，本文我们就先说到这里。</p><p>最后再来送一波书吧，《Spring Boot+Vue 全栈开发实战》六本，小伙伴们留言说说你为什么需要这本书，我会从留言的小伙伴中选出来六位幸运小伙伴，包邮到家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Hello 各位小伙伴，松哥今天要和大家聊一个有意思的话题，就是使用 Spring Boot 开发微信公众号后台。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>微服务中的鉴权该怎么做？</title>
    <link href="http://www.javaboy.org/2022/1202/springcloud-auth.html"/>
    <id>http://www.javaboy.org/2022/1202/springcloud-auth.html</id>
    <published>2022-12-02T10:23:50.000Z</published>
    <updated>2022-12-20T11:07:09.834Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚好有小伙伴在微信上问到这个问题，松哥就来和大家聊一聊，本文主要和小伙伴们聊一聊思路，不写代码，小伙伴们可以结合松哥之前的文章，应该能够自己写出来本文的代码。当然，思路也只是我自己的一点实践经验，不一定是最完美的方案，欢迎小伙伴们在留言中一起探讨。</p><a id="more"></a><h2 id="1-认证与授权"><a href="#1-认证与授权" class="headerlink" title="1. 认证与授权"></a>1. 认证与授权</h2><p>首先小伙伴们知道，无论我们学习 Shiro 还是 Spring Security，里边的功能无论有哪些，核心都是两个：</p><ol><li>认证</li><li>授权</li></ol><p>所以，我们在微服务中处理鉴权问题，也可以从这两个方面来考虑。</p><h3 id="1-1-认证"><a href="#1-1-认证" class="headerlink" title="1.1 认证"></a>1.1 认证</h3><p>认证，说白了就是登录。传统的 Web 登录是 Cookie+Session 的方案，这种方案依赖于服务器本地内存，在微服务中，由于服务众多，这种方案显然不再合适。</p><blockquote><p>可能会有小伙伴说用 Redis+SpringSession 做 Session 共享，这是个办法，但是不是最佳方案，因为这种方案的性能以及可扩展性都比较差。</p></blockquote><p>所以，微服务中的认证，还是建议使用令牌的方式，可以选择 JWT 令牌，这也是目前使用较多的一种方案。但是熟悉 JWT 的小伙伴都知道，纯粹的无状态登录无法实现注销，这就很头大，所以在实际应用中，单纯的使用 JWT 是不行的，一般还是要结合 Redis 一起，将生成的 JWT 字符串在 Redis 上也保存一份，并设置过期时间，判断用户是否登录时，需要先去 Redis 上查看 JWT 字符串是否存在，存在的话再对 JWT 字符串做解析操作，如果能成功解析，就没问题，如果不能成功解析，就说明令牌不合法。</p><p>这样有状态登录+无状态登录混在一起的方式，虽然看起来有点不伦不类，但是就当下来说，这个折衷的办法算是一个可行的方案了。</p><blockquote><p>其实，上面的方案，说白了，跟传统的 Cookie+Session 没什么两样，思路几乎都是完全 copy 的：传统的 Session 用 Redis 代替了；传统穿梭于服务端和浏览器之间的 jsessionId 被 JWT 字符串代替了；传统的 jsessionId 通过 Cookie 来传输，现在的 JWT 则通过开发者手动设置后通过请求头来传输；传统的 Session 可以自动续签，现在用 JWT 就是手动续签，每次请求到达服务端的时候，就去看下 Redis 上令牌的过期时间，快过期了，就重新设置一下，其他都一模一样。</p></blockquote><p>这是认证方案的选择。</p><h3 id="1-2-授权"><a href="#1-2-授权" class="headerlink" title="1.2 授权"></a>1.2 授权</h3><p>微服务中授权，也可以使用 Shiro 或者 Spring Security 框架来做，省事一些。考虑到微服务技术栈都是 Spring 家族的产品，所以在权限框架这块也是建议大家首选 Spring Security（如果有小伙伴对 Spring Security 还不熟悉的话，可以在微信公众号后台回复 ss，有教程）。</p><p>当然，如果觉得 Spring Security 比较复杂想自己搞的话，也是可以的。自己搞的话，也是可以借助于 Spring Security 的思路的，松哥最近的一个项目就是这样：</p><blockquote><p>请求到达微服务之后，先找到当前用户的各种信息，包括当前用户所拥有的角色和权限等信息，然后存入到和当前线程绑定的 ThreadLocal 对象中。另一方面自定义权限注解和角色注解，在切面中对这些注解进行解析，检查当前用户是否具备所需要的角色/权限等。</p></blockquote><p>当然，如果你使用了 Spring Security 的话，上面这个就不需要自定义注解了，直接使用 Spring Security 中自带的即可，还可以体验 Spring Security 中更多的丰富的安全功能。</p><h2 id="2-认证服务"><a href="#2-认证服务" class="headerlink" title="2. 认证服务"></a>2. 认证服务</h2><p>那么认证和授权在哪里做？</p><p>先来说认证，认证我们可以简单分为两个步骤：</p><ol><li>登录</li><li>校验</li></ol><h3 id="2-1-登录"><a href="#2-1-登录" class="headerlink" title="2.1 登录"></a>2.1 登录</h3><p>一般来说，登录我们可以单独做一个认证服务。<strong>当登录请求到达网关之后，我们将之转发到认证服务上</strong>，完成认证操作。</p><p>在认证服务上，我们就去检查用户名/密码是否 OK，用户状态是否都 OK，都没问题的话，生成 JWT 字符串，同时再把数据存入到 Redis 上，然后把 JWT 字符串返回。</p><blockquote><p>如果系统有注册功能的话，注册功能也是放在这个微服务上来完成。</p></blockquote><h3 id="2-2-校验"><a href="#2-2-校验" class="headerlink" title="2.2 校验"></a>2.2 校验</h3><p>校验是指每一个请求到达的时候，校验用户是否已经登录。</p><p>这个当然可以和 2.1 放到一起去做，但是松哥不建议。问题在于，假如是一个创建订单的请求，这个请求原本是要经过网关转发到订单服务上的，但是，此时就得先在网关上调用 2.1 小节的服务进行登录校验，没问题再转发到订单服务上，这样做很明显很费事，也不合理。</p><p>一个比较好的办法是直接在网关上去校验请求的令牌是否合法，这个校验本身也比较容易，校验令牌是否合法，我们只需要看 Redis 上是否存在这个令牌，并且这个 JWT 令牌能够被顺利解析就行，这个操作完全可以在网关上做。</p><p>以 Gateway 网关为例，我们可以自定义全局过滤器，在全局过滤器中校验每一个请求的令牌，校验通过了，再进行请求的转发，否则就不转发。</p><p>校验通过之后，在转发到具体的微服务之后，我们可以将解析出来的用户 id 以及用户名等信息放到请求头中，然后再转发，这样到达各个具体的微服务之后，就知道这个请求是谁发来的，这人都有哪些角色/权限，方便做下一步的权限校验。</p><blockquote><p>松哥的做法是定义了一个公共模块，所有的微服务都依赖这个公共模块，这个公共模块中定义了一个拦截器，会拦截下来每一个请求，从请求头中取出用户 ID，然后从 Redis 中拿到具体的用户信息，存入到 ThreadLocal 中，这样在后续的方法调用中，如果需要判断用户是否具备某一个权限，就可以通过 ThreadLocal 去获取了。</p></blockquote><p>大致上就是这样一个流程。</p><h2 id="3-授权服务"><a href="#3-授权服务" class="headerlink" title="3. 授权服务"></a>3. 授权服务</h2><p>授权没法放到网关上做，还是得在各个微服务上去完成。</p><p>微服务上的授权我们又可以将之大致上分为两类：</p><ol><li>前端发送来的请求（外部请求）。</li><li>别的微服务发送来的请求（内部请求）。</li></ol><h3 id="3-1-外部请求"><a href="#3-1-外部请求" class="headerlink" title="3.1 外部请求"></a>3.1 外部请求</h3><p>对于外部请求来说，就按正常的权限校验对待就行了，自定义注解亦或者使用 Spring Security 等框架都是可以的，如果是自定义注解的话，就结合 AOP 一起，定义切面自己去处理权限注解，当然，这些功能基本上每一个微服务都是需要的，所以可以将之抽取成为一个公共的模块，在不同的微服务中依赖即可。</p><h3 id="3-2-内部请求"><a href="#3-2-内部请求" class="headerlink" title="3.2 内部请求"></a>3.2 内部请求</h3><p>对于内部的请求来说，正常是不需要鉴权的，内部请求可以直接处理。问题是如果使用了 OpenFeign，数据都是通过接口暴露出去的，不鉴权的话，又会担心从外部来的请求调用这个接口，对于这个问题，我们也可以自定义注解+AOP，然后在内部请求调用的时候，额外加一个头字段加以区分。</p><p>当然，内部请求到达微服务的时候，也是需要进行认证的，就行请求从网关转发到每一个具体的微服务上时需要认证一样，不过很明显，我们没必要每次使用 OpenFeign 调用别的服务的时候，都去传一堆认证信息，我们可以通过实现 <code>feign.RequestInterceptor</code> 接口来定义一个 OpenFeign 的请求拦截器，在拦截器中，统一为 OpenFeign 请求设置请求头信息。</p><p>好啦，关于微服务中的鉴权，我们目前是这么做的，欢迎小伙伴们留言一起探讨。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刚好有小伙伴在微信上问到这个问题，松哥就来和大家聊一聊，本文主要和小伙伴们聊一聊思路，不写代码，小伙伴们可以结合松哥之前的文章，应该能够自己写出来本文的代码。当然，思路也只是我自己的一点实践经验，不一定是最完美的方案，欢迎小伙伴们在留言中一起探讨。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://www.javaboy.org/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://www.javaboy.org/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>十一月最后一天～给小伙伴们汇报下 TienChin 项目视频进度</title>
    <link href="http://www.javaboy.org/2022/1130/tienchin-video.html"/>
    <id>http://www.javaboy.org/2022/1130/tienchin-video.html</id>
    <published>2022-11-30T10:23:37.000Z</published>
    <updated>2022-12-20T11:07:22.492Z</updated>
    
    <content type="html"><![CDATA[<p>距离上次跟小伙伴们汇报 TienChin 项目视频进度已经过去一个月啦，今天是 11 月 30 号，再来汇报一下十月份视频的进展。</p><a id="more"></a><p>其实也没啥好说的，直接上目录吧！</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line">000.开篇.mp4</span><br><span class="line">001.运行RuoYi-Vue.mp4</span><br><span class="line">002.代码格式化.mp4</span><br><span class="line">003.项目结构大改造.mp4</span><br><span class="line">004.项目改造完善.mp4</span><br><span class="line">005.项目结构分析.mp4</span><br><span class="line">006.验证码响应结果分析.mp4</span><br><span class="line">007.验证码生成接口分析.mp4</span><br><span class="line">008.验证码配置分析.mp4</span><br><span class="line">009.验证码的校验.mp4</span><br><span class="line">010.登录流程分析.mp4</span><br><span class="line">011.登录JWT校验.mp4</span><br><span class="line">012.SpringSecurity登录配置分析.mp4</span><br><span class="line">013.自定义多数据源思路分析.mp4</span><br><span class="line">014.自定义多数据源-1.mp4</span><br><span class="line">015.自定义多数据源-2.mp4</span><br><span class="line">016.手动实现网页上切换数据源.mp4</span><br><span class="line">017.RateLimiter注解简介.mp4</span><br><span class="line">018.自定义限流注解-1.mp4</span><br><span class="line">019.自定义限流注解-2.mp4</span><br><span class="line">020.RuoYi脚手架限流注解分析.mp4</span><br><span class="line">021.幂等性实现的6中思路梳理.mp4</span><br><span class="line">022.实现JSON格式参数多次读取.mp4</span><br><span class="line">023.防止请求重复提交.mp4</span><br><span class="line">024.防止接口重复提交注解分析.mp4</span><br><span class="line">025.数据权限注解介绍.mp4</span><br><span class="line">026.数据权限案例准备工作.mp4</span><br><span class="line">027.权限注解实现思路分析.mp4</span><br><span class="line">028.自定义数据权限注解@DataScope.mp4</span><br><span class="line">029.数据权限过滤角色数据.mp4</span><br><span class="line">030.数据权限过滤用户数据.mp4</span><br><span class="line">031.数据权限注解总结.mp4</span><br><span class="line">032.操作日志记录.mp4</span><br><span class="line">033.修改日志方法名称.mp4</span><br><span class="line">034.理解Aware接口.mp4</span><br><span class="line">035.自定义注解+AOP整理.mp4</span><br><span class="line">036.TienChin细化到按钮的权限实现思路.mp4</span><br><span class="line">037.理解TienChin项目中的权限注解.mp4</span><br><span class="line">038.角色和权限概念梳理.mp4</span><br><span class="line">039.Spring Security中角色和权限的区别.mp4</span><br><span class="line">040.SpringSecurity中的权限处理逻辑.mp4</span><br><span class="line">041.SpringSecurity中使用权限通配符.mp4</span><br><span class="line">042.SpringSecurity另一种权限判断方式.mp4</span><br><span class="line">043.自定义权限表达式.mp4</span><br><span class="line">044.使用POSTMAN测试项目接口.mp4</span><br><span class="line">045.自定义TienChin项目权限判断表达式.mp4</span><br><span class="line">046.登录鉴权流程梳理.mp4</span><br><span class="line">047.运行RuoYi-Vue3.mp4</span><br><span class="line">048.动态菜单实现思路.mp4</span><br><span class="line">049.动态菜单JSON分析.mp4</span><br><span class="line">050.动态菜单的path问题.mp4</span><br><span class="line">051.服务端查询当前登录用户菜单.mp4</span><br><span class="line">052.服务端构建动态菜单.mp4</span><br><span class="line">053.动态菜单实现思路梳理.mp4</span><br><span class="line">054.Vue3中的动态菜单递归渲染.mp4</span><br><span class="line">055.前端固定路由定义.mp4</span><br><span class="line">056.前端轻量级状态管理框架Pinia.mp4</span><br><span class="line">057.前端网络请求封装思路.mp4</span><br><span class="line">058.前端登录请求执行流程.mp4</span><br><span class="line">059.前端动态菜单加载思路.mp4</span><br><span class="line">060.动态菜单为什么不能存在localStorage.mp4</span><br><span class="line">061.动态菜单为什么不能存在localStorage-2.mp4</span><br><span class="line">062.前端路由导航守卫源码分析.mp4</span><br><span class="line">063.前端动态菜单加载四个核心变量.mp4</span><br><span class="line">064.routes变量多级菜单铺平.mp4</span><br><span class="line">065.component字符串转对象.mp4</span><br><span class="line">066.前端多级菜单铺平.mp4</span><br><span class="line">067.过滤前端本地动态路由.mp4</span><br><span class="line">068.前端generateRoutes方法.mp4</span><br><span class="line">069.前端回调地狱.mp4</span><br><span class="line">070.Promise初体验.mp4</span><br><span class="line">071.then方法的各种情况.mp4</span><br><span class="line">072.Promise中的catch代码块.mp4</span><br><span class="line">073.Promise中的finally代码块.mp4</span><br><span class="line">074.Promise中的静态方法.mp4</span><br><span class="line">075.TienChin项目Vue3中的Promise.mp4</span><br><span class="line">076.Vue3中的变量定义方式.mp4</span><br><span class="line">077.Vue3中方法的定义.mp4</span><br><span class="line">078.Vue3中钩子函数的定义.mp4</span><br><span class="line">079.Vue3中的计算属性.mp4</span><br><span class="line">080.Vue3中的watch函数.mp4</span><br><span class="line">081.Vue3中的ref和reactive.mp4</span><br><span class="line">082.Vue3中的setup函数.mp4</span><br><span class="line">083.Vue3中自定义全局方法.mp4</span><br><span class="line">084.Vue3中router和store的调用.mp4</span><br><span class="line">085.插件和全局方法的区别.mp4</span><br><span class="line">086.在Vue3中定义一个插件.mp4</span><br><span class="line">087.在插件中注册全局组件.mp4</span><br><span class="line">088.在插件中自定义全局指令.mp4</span><br><span class="line">089.Vue3自定义插件时传入参数.mp4</span><br><span class="line">090.自定义插件中的provide和inject.mp4</span><br><span class="line">091.什么是Vue中的指令.mp4</span><br><span class="line">092.Vue3自定义局部指令.mp4</span><br><span class="line">093.Vue3全局自定义指令.mp4</span><br><span class="line">094.Vue3自定义指令同时传递两个参数.mp4</span><br><span class="line">095.自定义插件传递动态参数.mp4</span><br><span class="line">096.Vue3中自定义权限指令.mp4</span><br><span class="line">097.Vite简介.mp4</span><br><span class="line">098.创建一个基于Vite的项目.mp4</span><br><span class="line">099.Vite项目安装vue-router.mp4</span><br><span class="line">100.Vue3方法自动导入插件.mp4</span><br><span class="line">101.Vite中省略组件后缀.mp4</span><br><span class="line">102.Vue3简化组件名称配置.mp4</span><br><span class="line">103.【workflow】状态机解决流程问题.mp4</span><br><span class="line">104.【workflow】报销审批流程.mp4</span><br><span class="line">105.【workflow】笔记本电脑生产流程.mp4</span><br><span class="line">106.【workflow】三大主流工作流.mp4</span><br><span class="line">107.【workflow】BPMN流程图规范.mp4</span><br><span class="line">108.【workflow】BPMN流程图元素.mp4</span><br><span class="line">109.【workflow】常见的流程绘制工具梳理.mp4</span><br><span class="line">110.【workflow】使用IDEA插件绘制流程图.mp4</span><br><span class="line">111.【workflow】分析流程图的XML文件.mp4</span><br><span class="line">112.【workflow】flowable-ui两种安装方式.mp4</span><br><span class="line">113.【workflow】flowable-ui四大核心功能.mp4</span><br><span class="line">114.【workflow】flowable-ui身份管理.mp4</span><br><span class="line">115.【workflow】flowable-ui管理员功能.mp4</span><br><span class="line">116.【workflow】flowable-ui建模器应用程序-报销流程介绍.mp4</span><br><span class="line">117.【workflow】flowable-ui建模器应用程序-绘制流程图.mp4</span><br><span class="line">118.【workflow】flowable-ui建模器应用程序-填写报销材料.mp4</span><br><span class="line">119.【workflow】flowable-ui建模器应用程序-小于等于1000审批流程.mp4</span><br><span class="line">120.【workflow】flowable-ui建模器应用程序-大于1000审批流程.mp4</span><br><span class="line">121.【workflow】flowable-ui建模器应用程序-流程图下载.mp4</span><br><span class="line">122.【workflow】flowable-ui建模器应用程序-创建流程应用.mp4</span><br><span class="line">123.【workflow】flowable-ui建模器应用程序-细节梳理.mp4</span><br><span class="line">124.【workflow】flowable-ui建模器应用程序-流程监控.mp4</span><br><span class="line">125.【workflow】flowable源码目录结构.mp4</span><br><span class="line">126.【workflow】flowable源码编译.mp4</span><br><span class="line">127.【workflow】flowable源码启动.mp4</span><br><span class="line">128.【workflow】flowable源码接入MySQL数据库.mp4</span><br><span class="line">129.【workflow】flowable源码接口分析.mp4</span><br><span class="line">130.【workflow】flowable添加用户.mp4</span><br><span class="line">131.【workflow】flowable修改和删除用户.mp4</span><br><span class="line">132.【workflow】flowable查询用户.mp4</span><br><span class="line">133.【workflow】flowable用户组的添加与删除.mp4</span><br><span class="line">134.【workflow】flowable用户组的更新与查询.mp4</span><br><span class="line">135.【workflow】flowable查看表详细信息.mp4</span><br><span class="line">136.【workflow】flowable流程自动部署.mp4</span><br><span class="line">137.【workflow】flowable流程自动升级.mp4</span><br><span class="line">138.【workflow】flowable修改流程定义的分类.mp4</span><br><span class="line">139.【workflow】flowable流程自动部署配置.mp4</span><br><span class="line">140.【workflow】flowable手动部署流程.mp4</span><br><span class="line">141.【workflow】flowable查询API.mp4</span><br><span class="line">142.【workflow】flowable自定义流程定义查询SQL.mp4</span><br><span class="line">143.【workflow】flowable自定义流程部署查询SQL.mp4</span><br><span class="line">144.【workflow】flowable删除流程定义.mp4</span><br><span class="line">145.【workflow】flowable流程实例与执行实例.mp4</span><br><span class="line">146.【workflow】flowable启动一个流程实例.mp4</span><br><span class="line">147.【workflow】flowable另一种流程启动方式.mp4</span><br><span class="line">148.【workflow】flowable流程执行.mp4</span><br><span class="line">149.【workflow】flowable判断流程是否执行结束.mp4</span><br><span class="line">150.【workflow】flowable查看运行活动节点.mp4</span><br><span class="line">151.【workflow】flowable删除流程实例.mp4</span><br><span class="line">156.【workflow】flowable中的租户.mp4</span><br><span class="line">157.【workflow】flowable中的ReceiveTask.mp4</span><br><span class="line">158.【workflow】UserTask直接指定处理人.mp4</span><br><span class="line">159.【workflow】UserTask委派或者自己处理.mp4</span><br><span class="line">160.【workflow】通过变量指定UserTask处理人.mp4</span><br><span class="line">161.【workflow】通过监听器指定UserTask处理人.mp4</span><br><span class="line">162.【workflow】设置UserTask处理人为流程发起人.mp4</span><br><span class="line">163.【workflow】设置UserTask候选人.mp4</span><br><span class="line">164.【workflow】UserTask认领任务.mp4</span><br><span class="line">165.【workflow】通过变量或者监听器为UserTask设置处理人.mp4</span><br><span class="line">166.【workflow】UserTask任务回退.mp4</span><br><span class="line">167.【workflow】UserTask候选人的添加与删除.mp4</span><br><span class="line">168.【workflow】UserTask按角色分配.mp4</span><br><span class="line">169.【workflow】UserTask通过变量设置角色.mp4</span><br><span class="line">170.【workflow】通过监听器配置ServiceTask.mp4</span><br><span class="line">171.【workflow】ServiceTask监听器类设置属性.mp4</span><br><span class="line">172.【workflow】ServiceTask委托表达式.mp4</span><br><span class="line">173.【workflow】ServiceTask表达式.mp4</span><br><span class="line">174.【workflow】脚本任务之JavaScript.mp4</span><br><span class="line">175.【workflow】脚本任务之Groovy.mp4</span><br><span class="line">176.【workflow】脚本任务之Juel.mp4</span><br><span class="line">177.【workflow】流程网关之排他网关.mp4</span><br><span class="line">178.【workflow】流程网关之并行网关.mp4</span><br><span class="line">179.【workflow】流程网关之包容网关.mp4</span><br><span class="line">180.【workflow】全局流程变量-启动时设置.mp4</span><br><span class="line">181.【workflow】全局流程变量-Task设置.mp4</span><br><span class="line">182.【workflow】全局流程变量-完成任务时设置.mp4</span><br><span class="line">183.【workflow】全局流程变量-通过执行实例设置.mp4</span><br><span class="line">184.【workflow】本地流程变量-1.mp4</span><br><span class="line">185.【workflow】本地流程变量-2.mp4</span><br><span class="line">186.【workflow】临时流程变量.mp4</span><br><span class="line">187.【workflow】流程历史信息-环境准备.mp4</span><br><span class="line">188.【workflow】流程历史信息-历史流程.mp4</span><br><span class="line">189.【workflow】流程历史信息-历史任务.mp4</span><br><span class="line">190.【workflow】流程历史信息-历史活动.mp4</span><br><span class="line">191.【workflow】流程历史信息-历史变量.mp4</span><br><span class="line">192.【workflow】流程历史信息-历史日志.mp4</span><br><span class="line">193.【workflow】流程历史信息-历史权限.mp4</span><br><span class="line">194.【workflow】流程历史信息-自定义SQL.mp4</span><br><span class="line">195.【workflow】流程历史信息-日志级别.mp4</span><br><span class="line">196.【workflow】流程定义定时激活.mp4</span><br><span class="line">197.【workflow】流程定义定时挂起.mp4</span><br><span class="line">198.【workflow】定时任务表分析.mp4</span><br><span class="line">199.【workflow】流程表单分类.mp4</span><br><span class="line">200.【workflow】动态表单定义.mp4</span><br><span class="line">201.【workflow】查询启动节点上的表单定义.mp4</span><br><span class="line">202.【workflow】启动带表单的实例.mp4</span><br><span class="line">203.【workflow】查询UserTask上的表单.mp4</span><br><span class="line">204.【workflow】动态表单的保存与完成.mp4</span><br><span class="line">205.【workflow】开发外置表单.mp4</span><br><span class="line">206.【workflow】部署带外置表单的流程.mp4</span><br><span class="line">207.【workflow】查看流程启动节点上的外置表单.mp4</span><br><span class="line">208.【workflow】带外置表单的流程审批.mp4</span><br><span class="line">209.【workflow】JSON格式的外置表单.mp4</span><br><span class="line">210.【workflow】根据流程定义绘制流程图.mp4</span><br><span class="line">211.【workflow】根据流程实例绘制流程图 Audio Extracted.pkf</span><br><span class="line">211.【workflow】根据流程实例绘制流程图 Audio Extracted.wav</span><br><span class="line">211.【workflow】根据流程实例绘制流程图.mp4</span><br><span class="line">212.【workflow】根据流程历史绘制流程图.mp4</span><br><span class="line">213.【workflow】综合实践-项目介绍.mp4</span><br><span class="line">214.【workflow】综合实践-绘制流程图.mp4</span><br><span class="line">215.【workflow】综合实践-用户体系问题.mp4</span><br><span class="line">216.【workflow】综合实践-工程创建.mp4</span><br><span class="line">217.【workflow】综合实践-创建用户表.mp4</span><br><span class="line">218.【workflow】综合实践-自定义用户登录.mp4</span><br><span class="line">219.【workflow】综合实践-服务类开发.mp4</span><br><span class="line">220.【workflow】综合实践-流程部署.mp4</span><br><span class="line">221.【workflow】综合实践-提交请假申请.mp4</span><br><span class="line">222.【workflow】综合实践-开发请假页面.mp4</span><br><span class="line">223.【workflow】综合实践-选择审批人.mp4</span><br><span class="line">224.【workflow】综合实践-提交请假申请.mp4</span><br><span class="line">【号外001】.登录流程解析.mp4</span><br><span class="line">【号外002】.分布式事务开篇.mp4</span><br><span class="line">【号外003】.分布式事务seata三个核心概念.mp4</span><br><span class="line">【号外004】.分布式事务seata四种事务模式.mp4</span><br><span class="line">【号外005】.分布式事务seata中的at模式.mp4</span><br><span class="line">【号外006】.分布式事务安装seata-server.mp4</span><br><span class="line">【号外007】.分布式事务seata-at模式实战.mp4</span><br><span class="line">【号外008】.分布式事务seata-at模式总结.mp4</span><br><span class="line">【号外009】.多数据源如何处理事务问题.mp4</span><br><span class="line">【号外010】.分布式事务seata-at模式补充.mp4</span><br><span class="line">【号外011】.分布式事务seata-tcc模式简介.mp4</span><br><span class="line">【号外012】.分布式事务seata-tcc模式实战-1.mp4</span><br><span class="line">【号外013】.分布式事务seata-tcc模式实战-2.mp4</span><br><span class="line">【号外014】.分布式事务seata-tcc模式实战-3.mp4</span><br><span class="line">【号外015】.分布式事务seata-tcc模式实战-4.mp4</span><br><span class="line">【号外016】.分布式事务seata-tcc总结.mp4</span><br><span class="line">【号外017】.分布式事务seata-xa简介.mp4</span><br><span class="line">【号外018】.MySQL中的XA事务实践.mp4</span><br><span class="line">【号外019】.分布式事务seata-xa模式实战-1.mp4</span><br><span class="line">【号外020】.分布式事务seata-xa模式实战-2.mp4</span><br><span class="line">【号外021】.分布式事务总结-1.mp4</span><br><span class="line">【号外022】.分布式事务总结-2.mp4</span><br><span class="line">【号外023】.动态代理的两种实现方式.mp4</span><br><span class="line">【号外024】.解决多数据源注解失效问题.mp4</span><br></pre></td></tr></table></figure><p><strong>目前已经录的总共是 224+24=248 集，约 54 个小时。</strong> 十月份的更新主要是讲了 Flowable 的各种玩法，目前 Flowable 的玩法已经讲的差不多了，再更一两次 Flowable 就更完了，Flowable 的知识点更新完毕后，就正式开始做项目了（估计本月就开始啦）。</p><p>虽然我感觉自己一直在吆喝，但是还是不少小伙伴来了第一句话是“松哥又有新教程啦？”：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113711.png" alt></p><p>因此这里再跟大伙啰嗦一下：</p><blockquote><p>TienChin 项目是一个健身会员管理系统，基于 RuoYi-Vue 脚手架来做，使用 Spring Boot + Vue3 开发，不同于之前的 vhr 是一个脚手架，TienChin 项目的业务完成度会超过 90%。这个项目的视频教程整体上分为两大块：第一块主要是解剖 RuoYi-Vue 脚手架，让小伙伴们能够熟练掌握这个脚手架的使用，在这个过程中，我会讲许多技术点，前面列出来的视频目录都属于这一部分的内容，这个过程中我不会带领大家从头敲一边 RuoYi-Vue 脚手架，但是对项目里边的一些技术点，会有针对性的讲解，也会写一些案例来帮助大家理解这些技术点。第二块内容则主要是业务功能的完成了，业务功能涉及到的技术点主要有：SpringBoot、Vue、MyBatis Plus、MySQL、Redis、Flowable、EasyExcel、NodeJS 等。</p></blockquote><p>目前更新的视频主要出于第一阶段，不过按照目前的进度，应该很快就会进入到第二阶段。</p><p>这些视频基本上都是工作之余录制的，大部分都是早上 6-8 点之间录的，也有一些是利用周末的晚上录制的，所以是付费视频，视频定价是 399，不过目前可以 7 折上车，也就是 279，之前买过 vhr 的小伙伴可在此基础上再优惠 30，即只要 249，随着视频的录制，内容越来越多，折扣力度也会变小，这个之前买过 vhr 视频的小伙伴应该都懂，无论你何时上车，当前价格都是你在未来能够买到的最低价格啦。</p><p>录视频还是蛮辛苦的，一方面赚点小钱养家糊口，另一方面也是小伙伴们的认可在支撑着我把这件事做下去，得瑟一下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/996.jpg" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/995.jpg" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/013.jpeg" alt></p><p><strong>有时候看小伙伴们发的，我真的特别动容。虽然大家看我天天写文章聊技术，其实我在生活中除了工作之外很少和人交流，真的特别想给这些爱学习会说话的小伙伴们点赞，他们肯定会混的比我好。</strong></p><hr><p>好啦，最后再统一回答大家几个关于视频的问题。</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码一人一码。至于小伙伴们推荐的阿里网盘等，由于空间、分享文件类型等限制，并无法用在 TienChin 项目视频分发中。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：视频可以试看吗？</strong></p><p>其实我最近在公号发的视频，大家都可以当作试看的，反正的录视频风格是不变的。和 vhr 视频相比，现在的 TienChin 项目视频音质是杠杠滴，下面三个视频是我最近发过的，小伙伴们可以当作试看的视频：</p><p><strong>Q4：可以砍价吗？</strong></p><p>不可以，这个价格已经很便宜了，没法砍了（悄悄告诉大家，从 vhr 到 tienchin，暂时没有人砍价成功过）。</p><p><strong>Q5：视频多久更新完毕？</strong></p><p>其实如果单纯带着大家写业务功能，这个项目不会花太多时间，这样虽然大家完整的做了一个项目，但是技术却不会有太多长进，而我则希望在这个过程中多整点活，能让小伙伴们技术也有一些提升，这样内容一加，最终何时更完就不确定了。不过，有一点是可以保证的，每周至少一次，每周至少更一个半小时精品视频。</p><p><strong>Q6：知识星球是什么？</strong></p><p>星球主要是用来更新视频下载地址的地方，大家在这套视频教程时遇到问题时，都可以在星球上提问，小伙伴们购买视频后，我会拉你进星球。</p><p><strong>Q7：这套视频适合哪些人看？</strong></p><p>学习这套视频，首先需要有 SSM 基础，如果没有，可以在公众号后台回复 SSM，有我录制的免费视频教程；另外也需要一些 Spring Boot 基础和 Vue 基础，要是没接触过 Spring Boot 和 Vue 的话，那么建议先看看 vhr，戳这里：<a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><p><strong>Q8：看视频有问题可以问吗？</strong></p><p>参考 Q6。</p><p><strong>Q9：这套视频我能学到啥？</strong></p><p>TienChin 项目基于 RuoYi-Vue 脚手架（Spring Boot+Vue3），这套视频学完后，小伙伴们对 RuoYi-Vue 脚手架基本上就融会贯通了，并能在 RuoYi-Vue 脚手架上随心所欲的开发常规的企业后台应用。并且对于分布式事务 seata、Flowable 流程引擎等框架也能熟练使用并掌握其原理，对于 Redis 在项目中的各种实际应用场景也会有较好的掌握。</p><hr><p><strong>好啦，七折 279 抄底就在今天啦！Flowable 更完之后，可能优惠力度就没有现在这么大了。</strong></p><p>P.s.：可能有小伙伴加了松哥多个微信，其实没有必要重复添加，任意一个都能找到我。当然，如果你还没有松哥微信，扫码加微信，转账 279 上车吧（买过 vhr 的小伙伴可在此基础上再优惠 ¥30 哦）～</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离上次跟小伙伴们汇报 TienChin 项目视频进度已经过去一个月啦，今天是 11 月 30 号，再来汇报一下十月份视频的进展。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>什么是插入意向锁？</title>
    <link href="http://www.javaboy.org/2022/1128/mysql-insert-intention-lock.html"/>
    <id>http://www.javaboy.org/2022/1128/mysql-insert-intention-lock.html</id>
    <published>2022-11-28T10:23:24.000Z</published>
    <updated>2022-12-20T11:07:19.439Z</updated>
    
    <content type="html"><![CDATA[<p>Insert Intention Lock，中文我们也称之为插入意向锁。</p><a id="more"></a><p>这个可以算是对我们之前所讲的 Gap Lock 的一个补充，关于 Gap Lock，如果还有小伙伴不懂，可以参考：<a href="https://mp.weixin.qq.com/s/Zh7GSzXJg_zt2ug3X5TwEQ" target="_blank" rel="noopener">记录锁、间隙锁与 Next-Key Locks</a>。</p><h2 id="1-为什么需要插入意向锁"><a href="#1-为什么需要插入意向锁" class="headerlink" title="1. 为什么需要插入意向锁"></a>1. 为什么需要插入意向锁</h2><p>我们之前已经有 Gap Lock 了，Gap Lock 可以帮我们在一定程度上解决幻读问题，但是，之前的似乎有点问题。</p><p>假设我有如下一张表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`age`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`age`</span> (<span class="hljs-string">`age`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">10</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>id 是主键自增；age 是一个普通索引，现在表中有如下数据：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220407222706.png" alt></p><p>假设我想执行如下的插入 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">begin</span>;</span><br><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(username,age) <span class="hljs-keyword">values</span>(<span class="hljs-string">'wangwu'</span>,<span class="hljs-number">95</span>);</span><br></pre></td></tr></table></figure><p>注意，这个 SQL 执行了但是事务还没有提交。</p><p>按照我们之前学习的关于 Gap Lock 的知识分析一下，此时间隙锁的范围是 (89,99)，意思是这个范围的 age 都不可以插入。</p><p>如果是这样的话，小伙伴们会发现数据插入的效率可就太低了，很容易发生锁冲突，那么怎么办？</p><p>我们今天要介绍的插入意向锁就是用来解决这个问题的。</p><h2 id="2-什么是插入意向锁"><a href="#2-什么是插入意向锁" class="headerlink" title="2. 什么是插入意向锁"></a>2. 什么是插入意向锁</h2><p>我们来看看 MySQL 官网的介绍：</p><blockquote><p>An insert intention lock is a type of gap lock set by INSERT operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.</p></blockquote><p>大致翻译下一下就是这样：</p><p>插入意向锁是一种在 INSERT 操作之前设置的一种间隙锁，插入意向锁表示了一种插入意图，即当多个不同的事务，同时往同一个索引的同一个间隙中插入数据的时候，它们互相之间无需等待，即不会阻塞（要是单纯按照之前间隙锁的理论，必须要等一个间隙锁释放了，下一个事务才可以往相同的间隙处插入数据）。假设有值为 4 和 7 的索引记录，现在有两个事务，分别尝试插入值为 5 和 6 的记录，在获得插入行的排他锁之前，每个事务使用插入意向锁锁定 4 和 7 之间的间隙，但是这两个事务不会相互阻塞，因为行是不冲突的。</p><p>这就是插入意向锁。</p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h2><p>小伙伴们注意，松哥之前和大家聊 Gap Lock，说过这个是可重复读（REPEATABLE READ）这个隔离级别下特有的产物，那么现在 Insert Intention Lock 是一种特殊的 Gap Lock，当然也是在可重复读这个隔离级别下生效。</p><p>接下来我们通过两个个简单的案例来演示一下插入意向锁。</p><h3 id="3-1-案例一"><a href="#3-1-案例一" class="headerlink" title="3.1 案例一"></a>3.1 案例一</h3><p>我们的表结构以及数据和第一小节一致。</p><p>首先我们在会话 A 中，执行如下代码：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220407225239.png" alt></p><p>现在会话 A 中的事务没有提交。</p><p>接下来我们在会话 B 中，也执行一个插入操作：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220407225428.png" alt></p><p>我们发现会话 B 也可以正常执行，没有发生阻塞。</p><p>这说明，两个插入意向锁之间是兼容的，可以共存的。</p><h3 id="3-2-案例二"><a href="#3-2-案例二" class="headerlink" title="3.2 案例二"></a>3.2 案例二</h3><p>我们再来看一个不兼容的例子。</p><p>首先在会话 A 中执行如下 SQL 查询 age 大于 80 的记录，并添加排他锁：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220407230931.png" alt></p><p>接下来在会话 B 中，执行如下代码插入一行数据：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220407231113.png" alt></p><p>小伙伴们看到，这个操作会被阻塞！阻塞的原因在于，插入意向锁和排他锁之间是互斥的。</p><p>趁着发生阻塞的这会，在会话 C 中，我们通过在前面文章中所使用的 <code>show engine innodb status\G</code> 指令，来查看下加锁的情况，重点看 TRANSACTION 节点：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220407231629.png" alt></p><p>在输出的内容中，红色框选中的地方，清楚的表明了插入意向锁的存在。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>总结一下：</p><ol><li>插入意向锁虽然名字中有意向二字，但实际上是一个特殊的间隙锁。</li><li>插入意向锁之间不互斥。</li><li>插入意向锁和排他锁之间互斥。</li></ol><p>好啦，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Insert Intention Lock，中文我们也称之为插入意向锁。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>一图胜千言，实时掌握流程走到哪一步了！</title>
    <link href="http://www.javaboy.org/2022/1124/tienchin-flowable-process-image.html"/>
    <id>http://www.javaboy.org/2022/1124/tienchin-flowable-process-image.html</id>
    <published>2022-11-24T10:23:11.000Z</published>
    <updated>2022-12-20T11:07:16.598Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中，松哥和大家展示过 Flowable 中的一个功能，就是我们可以绘制一张图片，来实时展示某一个流程走到哪一步了。不过当时没有跟大家详细介绍这个图片到底是如何绘制出来的，今天我们就来聊一聊这个话题。</p><a id="more"></a><h2 id="1-效果图"><a href="#1-效果图" class="headerlink" title="1. 效果图"></a>1. 效果图</h2><p>首先我们先来看一下绘制出来的效果图，如下：</p><p><img src="http://img.itboyhub.com/2022/08/1.png" alt></p><p>已经执行的节点和连线用红色标记出来。大致上就是这么一个效果，今天就跟大家聊一聊这里的实现细节。</p><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p>将一个流程图绘制成图片，相关的 API 在 flowable 中其实都是有提供的，流程图片的绘制，是根据流程的定义来绘制的，所以只需要提供一个流程定义的 ID 即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProcessDefinition pd = repositoryService.createProcessDefinitionQuery().processDefinitionKey(<span class="hljs-string">"ExclusiveGatewayDemo01"</span>).latestVersion().singleResult();</span><br><span class="line">BpmnModel bpmnModel = repositoryService.getBpmnModel(pd.getId());</span><br><span class="line">DefaultProcessDiagramGenerator generator = <span class="hljs-keyword">new</span> DefaultProcessDiagramGenerator();</span><br><span class="line">InputStream inputStream = generator.generatePngDiagram(bpmnModel, <span class="hljs-number">1.0</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">FileUtils.copyInputStreamToFile(inputStream, <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/Users/sang/Downloads/1.png"</span>));</span><br></pre></td></tr></table></figure><p>这五行代码应该都好理解：</p><ol><li>查找到流程定义对象。</li><li>根据流程定义对象，获取到一个 BpmnModel 对象。</li><li>创建一个图片生成器对象 DefaultProcessDiagramGenerator。</li><li>调用 generatePngDiagram 方法生成这个流程定义所对应的图片，参数有三个，分别是：前面查询到的 bpmnModel 对象；缩放因子以及是否在绘制流程图的时候，在连线上加上描述文字，generatePngDiagram 方法的返回值则是一个输入流。</li><li>最后将这个输入流打印出来，就是一张图片了。</li></ol><p>上面这个方法执行结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/1fasdjflkajkldfjakljfdk.png" alt></p><p>可以看到，这就是普通的流程图，没有高亮。</p><p>如果希望已经执行的节点变成高亮的，那么可以使用如下方法：</p><p><img src="http://img.itboyhub.com/2022/08/20221106174240.png" alt></p><p>这个方法参数比较多，我们挨个来说下：</p><ol><li>流程的 bpmnModel 对象。</li><li>生成的图片类型。</li><li>高亮的活动节点。</li><li>高亮的连线。</li><li>缩放因子。</li><li>是否在绘制连线的时候添加文字描述。</li></ol><p>这里的关键就是第三个和第四个参数。这个流程图中哪些节点哪些连线需要高亮，我们将之列出来即可。</p><p>根据我们之前文章中的介绍，小伙伴们知道，一个流程在执行过程中的活动信息，都是保存在 <code>ACT_RU_ACTINST</code> 表中，所以我们只需要根据流程实例的 ID 在 <code>ACT_RU_ACTINST</code> 表中查询到即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ProcessDefinition pd = repositoryService.createProcessDefinitionQuery().processDefinitionKey(<span class="hljs-string">"ExclusiveGatewayDemo01"</span>).latestVersion().singleResult();</span><br><span class="line">    BpmnModel bpmnModel = repositoryService.getBpmnModel(pd.getId());</span><br><span class="line">    ProcessInstance pi = runtimeService.createProcessInstanceQuery().singleResult();</span><br><span class="line">    List&lt;String&gt; highLightedActivities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; hightLightedFlows = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">double</span> scaleFactor = <span class="hljs-number">1.0</span>;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> drawSqquenceFlowNameWithNoLabelDI = <span class="hljs-keyword">true</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pi == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;ActivityInstance&gt; list = runtimeService.createActivityInstanceQuery().list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (ActivityInstance ai : list) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (ai.getActivityType().equals(<span class="hljs-string">"sequenceFlow"</span>)) &#123;</span><br><span class="line">            hightLightedFlows.add(ai.getActivityId());</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            highLightedActivities.add(ai.getActivityId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DefaultProcessDiagramGenerator generator = <span class="hljs-keyword">new</span> DefaultProcessDiagramGenerator();</span><br><span class="line">    InputStream inputStream = generator.generateDiagram(bpmnModel, <span class="hljs-string">"PNG"</span>, highLightedActivities, hightLightedFlows, scaleFactor, drawSqquenceFlowNameWithNoLabelDI);</span><br><span class="line">    FileUtils.copyInputStreamToFile(inputStream, <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/Users/sang/Downloads/1.png"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，我们这里使用 <code>highLightedActivities</code> 和 <code>hightLightedFlows</code> 两个集合，分别存一个流程已经执行的活动 ID 和连线的 ID。</p><p>通过 <code>runtimeService.createActivityInstanceQuery().list();</code> 来查询到所有已经执行的活动，然后遍历，遍历的时候注意区分是不是 <code>sequenceFlow</code>，如果是 <code>sequenceFlow</code> 则将之添加到 <code>hightLightedFlows</code> 集合中，否则将之添加到 <code>highLightedActivities</code> 结合中。</p><p>最终，执行生成的图片就是本文已开始大家看到的图片。</p><p>按照上面这种方式，对于一个已经执行完毕的流程来说，似乎就画不出来流程图了，因为当一个流程执行完毕之后，<code>ACT_RU_ACTINST</code> 表中的数据就会自动清空。</p><p>不过。。。根据我们前面文章的介绍，执行完毕的活动信息还可以去 <code>ACT_HI_ACTINST</code> 表中进行查询，因此，我们这个流程图还可以这样画：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ProcessDefinition pd = repositoryService.createProcessDefinitionQuery().processDefinitionKey(<span class="hljs-string">"ExclusiveGatewayDemo01"</span>).latestVersion().singleResult();</span><br><span class="line">    BpmnModel bpmnModel = repositoryService.getBpmnModel(pd.getId());</span><br><span class="line">    HistoricProcessInstance hpi = historyService.createHistoricProcessInstanceQuery().singleResult();</span><br><span class="line">    <span class="hljs-keyword">if</span> (hpi == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; highLightedActivities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; hightLightedFlows = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">double</span> scaleFactor = <span class="hljs-number">1.0</span>;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> drawSqquenceFlowNameWithNoLabelDI = <span class="hljs-keyword">true</span>;</span><br><span class="line">    List&lt;HistoricActivityInstance&gt; list = historyService.createHistoricActivityInstanceQuery().processInstanceId(hpi.getId()).list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricActivityInstance hai : list) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (hai.getActivityType().equals(<span class="hljs-string">"sequenceFlow"</span>)) &#123;</span><br><span class="line">            hightLightedFlows.add(hai.getActivityId());</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            highLightedActivities.add(hai.getActivityId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DefaultProcessDiagramGenerator generator = <span class="hljs-keyword">new</span> DefaultProcessDiagramGenerator();</span><br><span class="line">    InputStream inputStream = generator.generateDiagram(bpmnModel, <span class="hljs-string">"PNG"</span>, highLightedActivities, hightLightedFlows, scaleFactor, drawSqquenceFlowNameWithNoLabelDI);</span><br><span class="line">    FileUtils.copyInputStreamToFile(inputStream, <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/Users/sang/Downloads/1.png"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当一个流程实例执行完毕的时候，我们可以去历史表中查询这个流程实例，同时也去历史表中查询这个流程实例所执行过的活动 ID，找到之后，还是按照之前的办法，填充给 <code>hightLightedFlows</code> 和 <code>highLightedActivities</code> 两个变量。最终绘制出来的结果如下图：</p><p><img src="http://img.itboyhub.com/2022/08/1jfdajkdja9823490jdjal.png" alt></p><p>好啦，绘制流程图差不多就这些内容，小伙伴们快去试试吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的文章中，松哥和大家展示过 Flowable 中的一个功能，就是我们可以绘制一张图片，来实时展示某一个流程走到哪一步了。不过当时没有跟大家详细介绍这个图片到底是如何绘制出来的，今天我们就来聊一聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>使用 JSON 格式来定义 Flowable 外置表单</title>
    <link href="http://www.javaboy.org/2022/1122/tienchin-flowable-json-form.html"/>
    <id>http://www.javaboy.org/2022/1122/tienchin-flowable-json-form.html</id>
    <published>2022-11-22T10:22:57.000Z</published>
    <updated>2022-12-20T11:07:12.889Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的案例中，我们定义的表单使用了 HTML，实际上这个表单不仅可以使用 HTML，也可以使用 JSON 来定义表单，可能也有不少小伙伴在网上已经看到过一些使用 JSON 来定义表单的案例，今天这篇文章松哥就来和大家分享一下如何使用 JSON 来定义 Flowable 表单。</p><a id="more"></a><h2 id="1-默认规则"><a href="#1-默认规则" class="headerlink" title="1. 默认规则"></a>1. 默认规则</h2><p>使用 JSON 来定义 Flowable 表单，我们刚好可以利用 Spring Boot 中的默认机制，即将表单文件置于 classpath:forms 目录下，那么在系统启动的时候，表单文件就会被自动部署。并且默认情况下，表单文件的后缀是 <code>.form</code>。</p><p>不过对于默认的表单文件位置和表单文件后缀，我们也可以通过在 application.properties 配置文件中添加如下内容进行修改：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 默认的表单文件后缀</span><br><span class="line">flowable.form.resource-suffixes=**.form</span><br><span class="line"># 默认的表单文件位置</span><br><span class="line">flowable.form.resource-location=classpath*:/forms/</span><br></pre></td></tr></table></figure><h2 id="2-创建表单"><a href="#2-创建表单" class="headerlink" title="2. 创建表单"></a>2. 创建表单</h2><p>还是以我们的请假请求为例，我来创建一个表单文件，文件名为 <code>application_form.form</code>，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-string">"key"</span>: <span class="hljs-string">"application_form.form"</span>,</span><br><span class="line">    <span class="hljs-string">"name"</span>: <span class="hljs-string">"经理审批表单"</span>,</span><br><span class="line">    <span class="hljs-string">"fields"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-string">"id"</span>: <span class="hljs-string">"days"</span>,</span><br><span class="line">            <span class="hljs-string">"name"</span>: <span class="hljs-string">"请假天数"</span>,</span><br><span class="line">            <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,</span><br><span class="line">            <span class="hljs-string">"required"</span>: <span class="hljs-keyword">true</span>,</span><br><span class="line">            <span class="hljs-string">"placeholder"</span>: <span class="hljs-string">"empty"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-string">"id"</span>: <span class="hljs-string">"reason"</span>,</span><br><span class="line">            <span class="hljs-string">"name"</span>: <span class="hljs-string">"请假原因"</span>,</span><br><span class="line">            <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,</span><br><span class="line">            <span class="hljs-string">"required"</span>: <span class="hljs-keyword">true</span>,</span><br><span class="line">            <span class="hljs-string">"placeholder"</span>: <span class="hljs-string">"empty"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-string">"id"</span>: <span class="hljs-string">"startTime"</span>,</span><br><span class="line">            <span class="hljs-string">"name"</span>: <span class="hljs-string">"开始时间"</span>,</span><br><span class="line">            <span class="hljs-string">"type"</span>: <span class="hljs-string">"date"</span>,</span><br><span class="line">            <span class="hljs-string">"required"</span>: <span class="hljs-keyword">true</span>,</span><br><span class="line">            <span class="hljs-string">"placeholder"</span>: <span class="hljs-string">"empty"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-string">"id"</span>: <span class="hljs-string">"endTime"</span>,</span><br><span class="line">            <span class="hljs-string">"name"</span>: <span class="hljs-string">"结束时间"</span>,</span><br><span class="line">            <span class="hljs-string">"type"</span>: <span class="hljs-string">"date"</span>,</span><br><span class="line">            <span class="hljs-string">"required"</span>: <span class="hljs-keyword">true</span>,</span><br><span class="line">            <span class="hljs-string">"placeholder"</span>: <span class="hljs-string">"empty"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 key 就是表单的唯一标识符，当有多个表单的时候，这个该值不可以重复，name 是表单是名称，fields 则定义了具体的字段，这里一共有四个。</p><p>在每一个 filed 的定义中，id 表示字段名，name 则是字段的中文名称，type 表示字段的类型，require 则表示这个字段是否是必填字段，placeholder 不用多说，跟我们日常使用的 input 标签中的 placeholder 的含义一致。</p><p>OK，这样，我们的表单现在就创建好了。</p><blockquote><p>由于 <code>.form</code> 文件，在 <code>IDEA</code> 中，默认会被当成 Swing 里边的 form 去处理，所以需要小伙伴提前先用其他的编辑器写好 <code>.form</code> 文件，然后再拷贝到 IDEA 中即可。</p></blockquote><h2 id="3-创建流程"><a href="#3-创建流程" class="headerlink" title="3. 创建流程"></a>3. 创建流程</h2><p>接下来我们来创建一个流程图，流程中中引用这个表单。流程图如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221102211130.png" alt></p><p>在流程图的三个 UserTask 中，分别通过如下方式去配置表单的标识：</p><p><img src="http://img.itboyhub.com/2022/08/20221102211239.png" alt></p><p>关于流程图的其他细节我这里就不多说了，前面和大家介绍了很多了。</p><p>最后我们下载这个流程图，将之放在 Spring Boot 项目的 classpath:/processes/ 目录下，这样当项目启动的时候，这个流程图会被自动部署。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>接下来，我们启动 Spring Boot 项目，启动之后，流程和表单都会被自动部署好，我们执行如下代码启动一个流程实例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    runtimeService.startProcessInstanceByKey(<span class="hljs-string">"askforleave"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程启动成功之后，进入到 <code>提交请假申请</code> 环节，该环节有一个表单需要填写，我们可以先通过如下代码来查看需要填写的表单内容：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    FormInfo formInfo = taskService.getTaskFormModel(task.getId());</span><br><span class="line">    SimpleFormModel formModel = (SimpleFormModel) formInfo.getFormModel();</span><br><span class="line">    System.out.println(<span class="hljs-string">"formInfo.getId() = "</span> + formInfo.getId());</span><br><span class="line">    System.out.println(<span class="hljs-string">"formInfo.getName() = "</span> + formInfo.getName());</span><br><span class="line">    System.out.println(<span class="hljs-string">"formInfo.getKey() = "</span> + formInfo.getKey());</span><br><span class="line">    List&lt;FormField&gt; fields = formModel.getFields();</span><br><span class="line">    <span class="hljs-keyword">for</span> (FormField field : fields) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"field.getId() = "</span> + field.getId());</span><br><span class="line">        System.out.println(<span class="hljs-string">"field.getName() = "</span> + field.getName());</span><br><span class="line">        System.out.println(<span class="hljs-string">"field.getValue() = "</span> + field.getValue());</span><br><span class="line">        System.out.println(<span class="hljs-string">"field.getType() = "</span> + field.getType());</span><br><span class="line">        System.out.println(<span class="hljs-string">"==============="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印出来的内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">formInfo.getId() = a5b1306a-5ab0-11ed-b35b-acde48001122</span><br><span class="line">formInfo.getName() = 经理审批表单</span><br><span class="line">formInfo.getKey() = application_form.form</span><br><span class="line">field.getId() = days</span><br><span class="line">field.getName() = 请假天数</span><br><span class="line">field.getValue() = null</span><br><span class="line">field.getType() = text</span><br><span class="line">===============</span><br><span class="line">field.getId() = reason</span><br><span class="line">field.getName() = 请假原因</span><br><span class="line">field.getValue() = null</span><br><span class="line">field.getType() = text</span><br><span class="line">===============</span><br><span class="line">field.getId() = startTime</span><br><span class="line">field.getName() = 开始时间</span><br><span class="line">field.getValue() = null</span><br><span class="line">field.getType() = date</span><br><span class="line">===============</span><br><span class="line">field.getId() = endTime</span><br><span class="line">field.getName() = 结束时间</span><br><span class="line">field.getValue() = null</span><br><span class="line">field.getType() = date</span><br></pre></td></tr></table></figure><p>小伙伴们看到，打印出来的 value 都是 null，这是因为我们还没有填写表单。</p><p>接下来我们先来完成 <code>提交请假申请</code> 这一任务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    Map&lt;String, Object&gt; vars = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    vars.put(<span class="hljs-string">"days"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"玩一下"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-string">"2022-10-10"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"endTime"</span>, <span class="hljs-string">"2022-11-10"</span>);</span><br><span class="line">    taskService.complete(task.getId(),vars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成之后，此时任务进入到 <code>组长审批</code> 这一环节，现在我们再去执行 test01 方法，此时查询的就是 <code>组长审批</code> 这个任务的表单信息，最终打印出来日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">formInfo.getId() = a5b1306a-5ab0-11ed-b35b-acde48001122</span><br><span class="line">formInfo.getName() = 经理审批表单</span><br><span class="line">formInfo.getKey() = application_form.form</span><br><span class="line">field.getId() = days</span><br><span class="line">field.getName() = 请假天数</span><br><span class="line">field.getValue() = 10</span><br><span class="line">field.getType() = text</span><br><span class="line">===============</span><br><span class="line">field.getId() = reason</span><br><span class="line">field.getName() = 请假原因</span><br><span class="line">field.getValue() = 玩一下</span><br><span class="line">field.getType() = text</span><br><span class="line">===============</span><br><span class="line">field.getId() = startTime</span><br><span class="line">field.getName() = 开始时间</span><br><span class="line">field.getValue() = 2022-10-10</span><br><span class="line">field.getType() = date</span><br><span class="line">===============</span><br><span class="line">field.getId() = endTime</span><br><span class="line">field.getName() = 结束时间</span><br><span class="line">field.getValue() = 2022-11-10</span><br><span class="line">field.getType() = date</span><br></pre></td></tr></table></figure><p>可以看到，此时都有对应的 value 了。</p><p>后续的流程就不需要我多说了吧，小伙伴们可以自行尝试下～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的案例中，我们定义的表单使用了 HTML，实际上这个表单不仅可以使用 HTML，也可以使用 JSON 来定义表单，可能也有不少小伙伴在网上已经看到过一些使用 JSON 来定义表单的案例，今天这篇文章松哥就来和大家分享一下如何使用 JSON 来定义 Flowable 表单。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>Nacos 中的配置文件如何实现加密传输</title>
    <link href="http://www.javaboy.org/2022/1121/nacos-crypt.html"/>
    <id>http://www.javaboy.org/2022/1121/nacos-crypt.html</id>
    <published>2022-11-21T10:22:45.000Z</published>
    <updated>2022-12-20T11:07:06.978Z</updated>
    
    <content type="html"><![CDATA[<p>小伙伴们知道，Spring Cloud Config 很早就提供了配置文件的加解密功能，并且支持对称加密和非对称加密两种不同的模式。Nacos 作为分布式配置中心+服务注册中心的合体，在配置文件加密这块一直差点意思，不过好在，如果你使用的 Nacos 版本大于 2.0.4 这个版本，那么现在也可以通过插件的方式来实现配置文件加密了。</p><a id="more"></a><h2 id="1-配置文件加密"><a href="#1-配置文件加密" class="headerlink" title="1. 配置文件加密"></a>1. 配置文件加密</h2><p>松哥在之前的微服务视频中讲过，Spring Cloud Config 的对称加密和非对称加密，加密后的文件格式类似下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=&#123;cipher&#125;密文</span><br><span class="line">password=&#123;cipher&#125;密文</span><br></pre></td></tr></table></figure><p>可以看到，在 Spring Cloud Config 中，对配置文件的加密是针对字段一个一个加密的。</p><p>而 Nacos 中的加密，则是对整个配置文件的内容进行加密，这点和 Spring Cloud Config 不同。</p><p>Nacos 中是通过 SPI 的机制抽象出加密和解密的操作，Nacos 默认提供 AES 对称加密的实现，不过用户也可以自定义加解密的实现方式。</p><p>在 Nacos 服务端启动的时候就会加载所有依赖的加解密算法，然后通过发布配置的 dataId 的前缀来进行匹配是否需要加解密和使用的加解密算法。</p><p>客户端发布的配置会在客户端通过 filter 完成加解密，也就是配置在传输过程中都是密文的，而控制台发布的配置会在服务端进行处理。</p><p>换言之，用了 Nacos 的配置文件加密插件之后，我们在 Nacos 管理页面上配置的配置文件，将会以加密的密文形式存储在数据库中，也会以密文的形式传输到客户端，然后在客户端自动完成解密操作。大致上就是这样一个过程。接下来我们就来看看具体的用法。</p><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p>首先我们需要下载 nacos 源码进行编译，编译完成之后，需要将之安装到本地 Maven 仓库（因为编译加密插件需要用到 Nacos）。</p><p>首先 clone nacos 源码，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/alibaba/nacos.git</span><br></pre></td></tr></table></figure><p>下载之后，个人建议用 IDEA 去编译，操作方便一些（因为后续还有其他操作）。</p><p>所以我们先用 IDEA 打开项目，确认项目所需依赖均已下载完毕，然后点击 install 按钮，将项目编译安装到本地仓库：</p><p><img src="http://img.itboyhub.com/2022/08/20221116221137.png" alt></p><p>接下来 clone 配置文件加解密的插件，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/nacos-group/nacos-plugin.git</span><br></pre></td></tr></table></figure><p>也用 IDEA 打开这个插件项目。这个插件编译要用到我们刚刚编译安装好的 Nacos，但是给的版本号不对，需要我们手动修改下，位置在 <code>nacos-plugin/pom.xml</code>，修改里边 Nacos 的版本号，从 <code>2.2.0-SNAPSHOT</code> 改为 <code>2.2.0-BETA</code>（我刚刚编译安装的是这个版本，大家根据自己的实际情况选择）：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">alibaba-nacos.version</span>&gt;</span>2.2.0-BETA<span class="hljs-tag">&lt;/<span class="hljs-name">alibaba-nacos.version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改完之后也执行 install 操作，将所有的插件都安装到本地仓库：</p><p><img src="http://img.itboyhub.com/2022/08/20221116221751.png" alt></p><p>接下来回到一开始的 Nacos 项目中，在 Nacos 项目中引入这个插件的依赖，建议在 config 模块中引入，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221116222035.png" alt></p><p>引入内容如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.nacos<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>nacos-aes-encryption-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加了这个依赖之后，我们的 Nacos 就具备了配置文件加密功能了。</p><p>现在我再改一下 <code>console/src/main/resources/application.properties</code> 配置文件，让 Nacos 将数据存入到本地数据库中，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">### Count of DB:</span><br><span class="line">db.num=1</span><br><span class="line">spring.sql.init.platform=mysql</span><br><span class="line">### Connect URL of DB:</span><br><span class="line">db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">db.user=root</span><br><span class="line">db.password=123</span><br></pre></td></tr></table></figure><p>配置完成后，本地提前准备好一个名为 nacos_config 的数据库，并执行 <code>distribution/conf/mysql-schema.sql</code> 脚本文件，将所需的表先创建出来。</p><p>接下来，为项目添加启动参数，我们以单机而不是集群的方式来启动 Nacos，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221116222734.png" alt></p><p>上图大家重点看两个地方，一个是启动类所处的位置，另外一个则是启动参数。</p><p>好啦，现在我们就可以像启动 Spring Boot 项目那样启动 Nacos 了。</p><h2 id="3-发布"><a href="#3-发布" class="headerlink" title="3. 发布"></a>3. 发布</h2><p>如果我们想将项目打包发布的话，松哥建议大家先从 GitHub 上下载官方的压缩包，官方的压缩包里边，有一个 target 目录，这个目录下有一个 nacos-server.jar 文件，这个就是 nacos 的启动包了。对于这个官方的压缩包，大家正常配置就行了。</p><p>然后，在 IDEA 中，对我们刚刚处理过的 nacos，重新打包，不过记得打包的时候设置一下环境，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221116225910.png" alt></p><p>设置好环境之后，然后对项目重新进行打包。打包完成后，生成了新的 nacos-server.jar，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221116230648.png" alt></p><p>用这个 jar 包替换掉官方压缩包中的 jar，然后启动 nacos 即可。</p><h2 id="4-访问"><a href="#4-访问" class="headerlink" title="4. 访问"></a>4. 访问</h2><p>启动成功之后，我们就可以直接访问 nacos 了，用法和平时用法都一样，不同的是，在创建配置文件的时候，文件名有一个固定的前缀 <code>cipher-aes-</code>，有了这个前缀，这个配置文件就会自动加密，否则就不会加密。</p><p>例如我现在创建如下配置文件：</p><p><img src="http://img.itboyhub.com/2022/08/20221116231727.png" alt></p><p>创建完成后，我们去数据库中看一下这个配置文件：</p><p><img src="http://img.itboyhub.com/2022/08/20221116231821.png" alt></p><p>可以看到，这个 content 字段已经是一个加密的字符串了（如果没有我们没有加密，则 content 字段保存的就是明文 <code>name=javaboy</code>）。</p><p>现在我们创建一个项目，来加载这个加密的配置文件。</p><p>创建项目时候，选择 Nacos Configuration，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221116232112.png" alt></p><p>创建好之后，记得手动加上刚刚的那个加密插件的依赖（解密的时候会用到）。</p><p>项目名称记得设置为 <code>cipher-aes-nacos</code>：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 应用名称</span><br><span class="line">spring.application.name=cipher-aes-nacos</span><br><span class="line"># 应用服务 WEB 访问端口</span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure><p>其他都正常配置即可。</p><p>好啦，大功告成！Nacos 配置文件加密就实现啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小伙伴们知道，Spring Cloud Config 很早就提供了配置文件的加解密功能，并且支持对称加密和非对称加密两种不同的模式。Nacos 作为分布式配置中心+服务注册中心的合体，在配置文件加密这块一直差点意思，不过好在，如果你使用的 Nacos 版本大于 2.0.4 这个版本，那么现在也可以通过插件的方式来实现配置文件加密了。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://www.javaboy.org/categories/SpringCloud/"/>
    
    
      <category term="Nacos" scheme="http://www.javaboy.org/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>如何不重新编译让 Spring Boot 配置文件生效？</title>
    <link href="http://www.javaboy.org/2022/1116/springboot-properties.html"/>
    <id>http://www.javaboy.org/2022/1116/springboot-properties.html</id>
    <published>2022-11-16T10:22:18.000Z</published>
    <updated>2022-12-20T11:07:04.055Z</updated>
    
    <content type="html"><![CDATA[<p>今天聊一个小伙伴在星球上的提问：</p><p><img src="http://img.itboyhub.com/2022/08/20221114193934.png" alt></p><a id="more"></a><p>问题不难，解决方案也有很多，因此我决定撸一篇文章和大家仔细说说这个问题。</p><h2 id="1-配置文件位置"><a href="#1-配置文件位置" class="headerlink" title="1. 配置文件位置"></a>1. 配置文件位置</h2><p>首先小伙伴们要明白，Spring Boot 默认加载的配置文件是 application.properties 或者 application.yaml，默认的加载位置一共有五个，五个位置可以分为两类：</p><p><strong>从 classpath 下加载</strong>，这个又细分为两种：</p><ol><li>直接读取 classpath 下的配置文件，对应到 Spring Boot 项目中，就是 resources 目录下的配置。</li><li>读取 classpath:/config/ 目录下的文件，对应到 Spring Boot 项目中就是 resources/config 目录下的配置。</li></ol><p>这两种情况如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221114194724.png" alt></p><p><strong>从项目所在的当前目录下加载</strong>，这个又细分为三种情况：</p><ol><li>从项目当前目录下加载配置文件。</li><li>从项目当前目录下的 config 文件夹中加载配置文件。</li><li>从项目当前目录下的 config 文件夹的子文件夹中加载（孙子文件夹不可以）。</li></ol><p>这三种情况如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221114194853.png" alt></p><blockquote><p>config 目录下的配置文件可以被加载，config/a 目录下的配置文件也可以被加载，但是 config/a/b 目录下的配置文件不会被加载，因为不是直接子文件夹。</p></blockquote><p>配置文件可以放在这么多不同的位置，如果同一个属性在多个配置文件中都写了，那么后面加载的配置会覆盖掉前面的。例如在 <code>classpath:application.yaml</code> 中设置项目端口号是 8080，在 <code>项目当前目录/config/a/application.yaml</code> 中设置项目端口是 8081，那么最终的项目端口号就是 8081。</p><p>这是默认的文件位置。</p><p>如果你不想让自己的配置文件叫 application.properties 或者 application.yaml，那么也可以自定义配置文件名称，只需要在项目启动的时候指定配置文件名即可，例如我想设置我的配置文件名为 app.yaml，那么我们可以在启动 jar 包的时候按照如下方式配置，此时系统会自动去上面提到的五个位置查找对应的配置文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar boot_config_file-0.0.1-SNAPSHOT.jar --spring.config.name=app</span><br></pre></td></tr></table></figure><blockquote><p>如果项目已经打成 jar 包启动了，那么前面所说的目录中，后三个中的项目当前目录就是指 jar 包所在的目录。</p></blockquote><p>如果你不想去这五个位置查找，那么也可以在启动 jar 包的时候明确指定配置文件的位置和名称，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar boot_config_file-0.0.1-SNAPSHOT.jar --spring.config.location=optional:classpath:/app.yaml</span><br></pre></td></tr></table></figure><p>注意，我在 classpath 前面加上了 <code>optional:</code> 表示如果这个配置文件不存在，则按照默认的方式启动，而不会报错说找不到这个配置文件。如果不加这个前缀，那么当系统找不到指定的配置文件时，就会抛出 <code>ConfigDataLocationNotFoundException</code> 异常，进而导致应用启动失败。</p><p>如果配置文件和 jar 包在相同的目录结构下，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221114201400.png" alt></p><p>那么启动脚本如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar boot_config_file-0.0.1-SNAPSHOT.jar --spring.config.location=optional:javaboy/app.yaml</span><br></pre></td></tr></table></figure><p>如果 spring.config.location 的配置，只是指定了目录，那么必须以 / 结尾，例如上面这个启动脚本，也可以按照如下方式启动：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar boot_config_file-0.0.1-SNAPSHOT.jar --spring.config.location=optional:javaboy/ --spring.config.name=app</span><br></pre></td></tr></table></figure><p>通过 spring.config.location 属性锁定配置文件的位置，通过 spring.config.name 属性锁定配置文件的文件名。</p><h2 id="2-额外位置"><a href="#2-额外位置" class="headerlink" title="2. 额外位置"></a>2. 额外位置</h2><p>前面我们关于配置文件位置的设置，都是覆盖掉已有的配置，如果不想覆盖掉 Spring Boot 默认的配置文件查找策略，又想加入自己的，那么可以按照如下方式指定配置文件位置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar boot_config_file-0.0.1-SNAPSHOT.jar --spring.config.additional-location=optional:javaboy/app.yaml</span><br></pre></td></tr></table></figure><p>如果这个额外指定的配置文件和已有的配置文件有冲突，那么还是以后来者为准。</p><h2 id="3-位置通配符"><a href="#3-位置通配符" class="headerlink" title="3. 位置通配符"></a>3. 位置通配符</h2><p>有一种情况，假设我有 redis 和 mysql 的配置，我想将之放在两个不同的文件夹中以便于管理，像下面这样：</p><p><img src="http://img.itboyhub.com/2022/08/20221114204205.png" alt></p><p>那么在项目启动时，可以通过通配符 * 批量扫描相应的文件夹：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar boot_config_file-0.0.1-SNAPSHOT.jar --spring.config.location=optional:config/*/</span><br></pre></td></tr></table></figure><p>使用通配符批量扫描 mysql 和 redis 目录时，默认的加载顺序是按照文件夹的字母排序，即先加载 mysql 目录后加载 redis 目录。</p><blockquote><p>需要注意的是，通配符只能用在外部目录中，不可以用在 classpath 中的目录上。另外，包含了通配符的目录，只能有一个通配符 <code>*</code>，不可以有多个，并且还必须是以 <code>*/</code> 结尾，即一个目录的最后部分可以不确定。</p></blockquote><h2 id="4-导入外部配置"><a href="#4-导入外部配置" class="headerlink" title="4. 导入外部配置"></a>4. 导入外部配置</h2><p>从 Spring Boot2.4 开始，我们也可以使用 <code>spring.config.import</code> 方法来导入配置文件，相比于 <code>additional-location</code> 配置，这个 import 导入更加灵活，可以导入任意名称的配置文件。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.config.import=optional:file:./dev.properties</span><br></pre></td></tr></table></figure><p>甚至，这个 <code>spring.config.import</code> 还可以导入无扩展名的配置文件，例如我有一个配置文件，是 properties 格式的，但是这个这个配置文件没有扩展名，现在我想将之作为 properties 格式的配置文件导入，方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.config.import=optional:file:/Users/sang/dev[.properties]</span><br></pre></td></tr></table></figure><p>好啦，看完上面的内容，文章一开始的问题答案就不用我多说了吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天聊一个小伙伴在星球上的提问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.itboyhub.com/2022/08/20221114193934.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Flowable 外置的 HTML 表单怎么玩？</title>
    <link href="http://www.javaboy.org/2022/1114/tienchin-flowable-html-form.html"/>
    <id>http://www.javaboy.org/2022/1114/tienchin-flowable-html-form.html</id>
    <published>2022-11-14T10:22:05.000Z</published>
    <updated>2022-12-20T11:07:00.431Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们一起学习了 Flowable 中的动态表单，动态表单说白了就是把变量打包定义，零存整取。但是小伙伴们可能很难实实在在 GET 到动态表单一些有创造性的功能，所以今天我们就来继续看看 Flowable 中的外置表单怎么玩，这个跟动态表单有一些本质上的差别。</p><a id="more"></a><h2 id="1-外置表单"><a href="#1-外置表单" class="headerlink" title="1. 外置表单"></a>1. 外置表单</h2><p>首先，所谓的外置表单，其实说白了，类似我们平时在 HTML 中写的 form 表单。</p><blockquote><p>现在的 flowable 中，我们既可以利用 JSON 的形式来定义 form 表单，也可以直接就使用 HTML 来定义，都是 OK 的。本文为了直观，松哥这里采用 HTML 来定义表单。</p></blockquote><p>现在假设我有如下一个请假流程：</p><p><img src="http://img.itboyhub.com/2022/08/20221030120943.png" alt></p><p>在开始节点中，我们需要一个表单来输入用户提交的请假信息，在组长审批和经理审批这两个节点中我们希望能够看到用户提交的请假信息，那么我们准备两个表单文件，第一个是提交请假信息的表单文件 <code>askleave.html</code>：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">""</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>请假天数：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"days"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>请假理由：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"reason"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>起始时间：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"startTime"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>结束时间：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"endTime"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小伙伴们看到，这其实就是一个普通的 HTML 页面，这里为了省事，我就没写 form 的 action 了。</p><p>还有一个是查看用户提交的请假信息的表单 <code>leader_approval.html</code>：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">""</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>请假天数：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"days"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;days&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>请假理由：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"reason"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;reason&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>起始时间：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"startTime"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;startTime&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>结束时间：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"endTime"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$&#123;endTime&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>和前面的 <code>askleave.html</code> 文件相比，<code>leader_approval.html</code> 文件中，各个表单属性只是多了 value 属性而已，value 给了一个预填的变量，其他都是一样的。</p><p>两个表单文件定义完成之后，接下来我们为我们的流程来配置这两个表单文件，如下图，为开始节点设置表单 key 为 <code>askforleave.html</code>，为组长审批和经理审批节点设置表单 key 为 <code>leader_approval.html</code>：</p><p><img src="http://img.itboyhub.com/2022/08/20221030121602.png" alt></p><p><img src="http://img.itboyhub.com/2022/08/20221030121633.png" alt></p><blockquote><p>另：在 Spring Boot 项目中，外置表单默认放在 <code>resources/forms</code> 目录下，也就是说，凡是放在这个目录下的表单文件，会被自动部署（要求文件后缀为 <code>.form</code>）。</p></blockquote><p>好啦，这样我们的流程图就准备完成了。</p><h2 id="2-流程部署"><a href="#2-流程部署" class="headerlink" title="2. 流程部署"></a>2. 流程部署</h2><p>小伙伴们需要注意，外置表单的部署需要和流程图一起部署，只有一起部署，他们才会有相同的 <code>DEPLOYMENT_ID</code>，否则两者的 <code>DEPLOYMENT_ID</code> 不同，在后续的查找中就找不到对应的表单。</p><p>因此，我们来修改一下流程部署的接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessDeployController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RepositoryService repositoryService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/deploy"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deploy</span><span class="hljs-params">(MultipartFile[] files)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        DeploymentBuilder deploymentBuilder = repositoryService.createDeployment()</span><br><span class="line">                .category(<span class="hljs-string">"javaboy的工作流分类"</span>)</span><br><span class="line">                .name(<span class="hljs-string">"javaboy的工作流名称"</span>)</span><br><span class="line">                .key(<span class="hljs-string">"javaboy的工作流key666"</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">            MultipartFile file = files[i];</span><br><span class="line">            deploymentBuilder.addInputStream(file.getOriginalFilename(), file.getInputStream());</span><br><span class="line">        &#125;</span><br><span class="line">        Deployment deployment = deploymentBuilder</span><br><span class="line">                .deploy();</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"部署成功"</span>, deployment.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里我将上传文件改为了数组，也就是流程图、form 表单等统统都以文件的形式上传，然后在部署的时候，统一都调用 <code>addInputStream</code> 方法进行添加。</p><p>我们来看下使用 POSTMAN 部署的方式：</p><p><img src="http://img.itboyhub.com/2022/08/20221030122447.png" alt></p><p>部署成功之后，我们来看下 <code>ACT_GE_BYTEARRAY</code> 表中的记录，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221030122706.png" alt></p><p>小伙伴们看到，四条记录具有相同的 <code>DEPLOYMENT_ID</code>，这一点尤为重要。</p><h2 id="3-流程开启与执行"><a href="#3-流程开启与执行" class="headerlink" title="3. 流程开启与执行"></a>3. 流程开启与执行</h2><p>在流程开启之前，我们首先可以通过如下方式查询启动节点上的表单内容：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ProcessDefinition pd = repositoryService.createProcessDefinitionQuery().latestVersion().processDefinitionKey(<span class="hljs-string">"FormDemo02"</span>).singleResult();</span><br><span class="line">    String startFormKey = formService.getStartFormKey(pd.getId());</span><br><span class="line">    String renderedStartForm = (String) formService.getRenderedStartForm(pd.getId());</span><br><span class="line">    System.out.println(<span class="hljs-string">"startFormKey = "</span> + startFormKey);</span><br><span class="line">    System.out.println(<span class="hljs-string">"renderedStartForm = "</span> + renderedStartForm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出的内容如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221030123617.png" alt></p><p>可以看到，表单的内容就被输出来了。</p><blockquote><p>如果我们这里是一个 Web 工程，那么可以通过 Ajax 来请求到这个表单数据，并动态渲染到前端，然后在前端输入对应的值，点击提交按钮，就可以在服务端开启一个流程了。</p></blockquote><p>服务端开启流程方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ProcessDefinition pd = repositoryService.createProcessDefinitionQuery().processDefinitionKey(<span class="hljs-string">"FormDemo02"</span>).latestVersion().singleResult();</span><br><span class="line">    Map&lt;String, String&gt; vars = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    vars.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-string">"2022-10-10 10:10"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"endTime"</span>, <span class="hljs-string">"2022-10-12 10:10"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"玩两天"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"days"</span>, <span class="hljs-string">"3"</span>);</span><br><span class="line">    ProcessInstance pi = formService.submitStartFormData(pd.getId(), vars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 submitStartFormData 方法来开启一个流程，我这里参数直接硬编码了。</p><p>流程开启之后，接下来组长 zhangsan 要来审批这个流程，审批之前他需要先查看一下用户提交的表单信息，查看方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().taskAssignee(<span class="hljs-string">"zhangsan"</span>).singleResult();</span><br><span class="line">    String renderedTaskForm = (String) formService.getRenderedTaskForm(task.getId());</span><br><span class="line">    System.out.println(<span class="hljs-string">"renderedTaskForm = "</span> + renderedTaskForm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们注意，这个 <code>getRenderedTaskForm</code> 方法只有外置表单才有，动态表单调用这个方法是没有东西的，因为动态表单单纯的就只是变量的传递，不涉及到渲染问题，我们来看下这里打印出来的结果：</p><p><img src="http://img.itboyhub.com/2022/08/20221030124809.png" alt></p><blockquote><p>小伙伴们看到，和前面的表单相比，这里的表单都渲染出来了对应的值。如果这是一个 Web 项目，那么我们就可以使用 Ajax 请求这个渲染后的表单，并展示在前端页面。当然实际审批中，这里可以有更多的字段，组长填完之后，进入到下一个环节。</p></blockquote><p>zhangsan 进行流程审批的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test08</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().taskAssignee(<span class="hljs-string">"zhangsan"</span>).singleResult();</span><br><span class="line">    Map&lt;String, String&gt; vars = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    vars.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-string">"2022-10-30 10:10"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"endTime"</span>, <span class="hljs-string">"2022-12-30 10:10"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"玩十天"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"days"</span>, <span class="hljs-string">"10"</span>);</span><br><span class="line">    formService.submitTaskFormData(task.getId(),vars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>formService#submitTaskFormData</code> 方法进行审批，也可以使用 <code>taskService.complete</code> 方法进行审批。</p><p>剩下的玩法就和普通流程一样了。</p><p>好啦，这就是和大家介绍的外置表单。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们一起学习了 Flowable 中的动态表单，动态表单说白了就是把变量打包定义，零存整取。但是小伙伴们可能很难实实在在 GET 到动态表单一些有创造性的功能，所以今天我们就来继续看看 Flowable 中的外置表单怎么玩，这个跟动态表单有一些本质上的差别。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>流程表单初体验</title>
    <link href="http://www.javaboy.org/2022/1108/tienchin-flowable-form.html"/>
    <id>http://www.javaboy.org/2022/1108/tienchin-flowable-form.html</id>
    <published>2022-11-08T10:21:44.000Z</published>
    <updated>2022-12-20T11:06:57.483Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>有小伙伴在星球上催了好几次了，今天松哥就来和大家聊一聊流程中的表单。</p><a id="more"></a><h2 id="1-表单分类"><a href="#1-表单分类" class="headerlink" title="1. 表单分类"></a>1. 表单分类</h2><p>整体上来说，我们可以将表单分为三种不同的类型：</p><ol><li>动态表单：这种表单定义方式我们可以配置表单中每一个字段的可读性、可写性、是否必填等信息，不过不能定义完整的表单页面。</li><li>外置表单：外置表单我们只需要定义一下表单的 key，至于这个 key 对应的表单是什么样子，则由开发者自己去维护。</li><li>内置表单：这是内置的表单定义以及渲染引擎，松哥在之前的<a href="https://mp.weixin.qq.com/s/tc5OdOUONt5qPbT9ZbmQYQ" target="_blank" rel="noopener">一个不用写代码的案例，来看看Flowable到底给我们提供了哪些功能？</a>一文中所使用的表单，就是这种。</li></ol><p>另外小伙伴们需要注意，Flowable 中有很多不同类型的节点，但是只有开始节点和任务节点是支持表单定义的，其他节点均不支持表单定义。</p><h2 id="2-动态表单"><a href="#2-动态表单" class="headerlink" title="2. 动态表单"></a>2. 动态表单</h2><p>今天我们就先来看看动态表单的玩法。</p><p>假设我有如下一个请假流程：</p><p><img src="http://img.itboyhub.com/2022/08/20221024221853.png" alt></p><p>在第一个任务节点中，需要填写请假的基本信息，那么我们选中该节点，然后点击动态表单属性，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221024222135.png" alt></p><p>然后就可以开启动态表单属性的配置了：</p><p><img src="http://img.itboyhub.com/2022/08/20221024222341.png" alt></p><p>我这里一共配置了四个属性，这些属性的含义应该都好理解，我就不一一赘述了。</p><p>接下来我们来下载这个流程图。</p><p>流程的 XML 文件下载下来之后，我们可以在看到在 UserTask 节点中多了 <code>flowable:formProperty</code> 标签，现在，如果我想将 UserTask 节点中的动态表单属性拷贝到启动节点中，直接拷贝即可，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">process</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"FormDemo01"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"FormDemo01"</span> <span class="hljs-attr">isExecutable</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">documentation</span>&gt;</span>FormDemo01<span class="hljs-tag">&lt;/<span class="hljs-name">documentation</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">startEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"startEvent1"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">flowable:formProperty</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"startTime"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"请假开始时间"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">datePattern</span>=<span class="hljs-string">"yyyy-MM-dd HH:mm"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">flowable:formProperty</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">flowable:formProperty</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"endTime"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"请假结束时间"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">datePattern</span>=<span class="hljs-string">"yyyy-MM-dd HH:mm"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">flowable:formProperty</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">flowable:formProperty</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"reason"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"请假理由"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">flowable:formProperty</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">flowable:formProperty</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"days"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"请假天数"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"long"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">flowable:formProperty</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">startEvent</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-F4DE03F1-D09F-4527-9267-0E5C276D08B8"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"提交请假申请"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">flowable:formProperty</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"startTime"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"请假开始时间"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">datePattern</span>=<span class="hljs-string">"yyyy-MM-dd HH:mm"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">flowable:formProperty</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">flowable:formProperty</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"endTime"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"请假结束时间"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"date"</span> <span class="hljs-attr">datePattern</span>=<span class="hljs-string">"yyyy-MM-dd HH:mm"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">flowable:formProperty</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">flowable:formProperty</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"reason"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"请假理由"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"string"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">flowable:formProperty</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">flowable:formProperty</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"days"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"请假天数"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"long"</span> <span class="hljs-attr">required</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">flowable:formProperty</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-2A8D19F2-927C-4FCE-AF31-534425B1CA18"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"startEvent1"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-F4DE03F1-D09F-4527-9267-0E5C276D08B8"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-9136F312-F00B-467E-A61B-F2932BA9068A"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"请假审批"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-877A95AB-B8A4-47FE-BC9F-0998FEAEC52C"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-F4DE03F1-D09F-4527-9267-0E5C276D08B8"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-9136F312-F00B-467E-A61B-F2932BA9068A"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">endEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-E26593D4-C67B-4784-98EE-772B9659F805"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">endEvent</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-1A5C4E8C-6705-4148-A0E3-E7769631BFD9"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-9136F312-F00B-467E-A61B-F2932BA9068A"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-E26593D4-C67B-4784-98EE-772B9659F805"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">process</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在 <code>startEvent</code> 和第一个 <code>userTask</code> 中都有 <code>flowable:formProperty</code> 标签。</p><p>接下来，按照我们之前所讲的，我们来部署一下这个流程。部署完成之后，我们可以通过如下方式来查询流程中的动态表单信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">FormService formService;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ProcessDefinition pd = repositoryService.createProcessDefinitionQuery().processDefinitionKey(<span class="hljs-string">"FormDemo01"</span>).latestVersion().singleResult();</span><br><span class="line">    StartFormData startFormData = formService.getStartFormData(pd.getId());</span><br><span class="line">    System.out.println(<span class="hljs-string">"startFormData.getDeploymentId() = "</span> + startFormData.getDeploymentId());</span><br><span class="line">    System.out.println(<span class="hljs-string">"startFormData.getFormKey() = "</span> + startFormData.getFormKey());</span><br><span class="line">    List&lt;FormProperty&gt; formProperties = startFormData.getFormProperties();</span><br><span class="line">    <span class="hljs-keyword">for</span> (FormProperty fp : formProperties) &#123;</span><br><span class="line">        String value = fp.getValue();</span><br><span class="line">        String id = fp.getId();</span><br><span class="line">        <span class="hljs-keyword">boolean</span> readable = fp.isReadable();</span><br><span class="line">        <span class="hljs-keyword">boolean</span> writable = fp.isWritable();</span><br><span class="line">        <span class="hljs-keyword">boolean</span> required = fp.isRequired();</span><br><span class="line">        String name = fp.getName();</span><br><span class="line">        FormType type = fp.getType();</span><br><span class="line">        String key = <span class="hljs-string">""</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> EnumFormType) &#123;</span><br><span class="line">            key = <span class="hljs-string">"values"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> DateFormType) &#123;</span><br><span class="line">            key = <span class="hljs-string">"datePattern"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object information = type.getInformation(key);</span><br><span class="line">        logger.info(<span class="hljs-string">"value:&#123;&#125;,id:&#123;&#125;,readable:&#123;&#125;,writeable:&#123;&#125;,required:&#123;&#125;,name:&#123;&#125;,info:&#123;&#125;"</span>, value, id, readable, writable, required, name, information);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们可以看到，这个查询是通过流程定义查询的，所以这里查询到的信息，其实也是和流程实例无关的。只是单纯的查看一下启动节点上有哪些动态表单需要输入，以及这些动态表单的类型。最终输出日志如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221025205246.png" alt></p><h2 id="3-启动带表单的实例"><a href="#3-启动带表单的实例" class="headerlink" title="3. 启动带表单的实例"></a>3. 启动带表单的实例</h2><p>动态表单，其实跟普通的变量有点像，启动的时候我们可以通过表单服务类来启动，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ProcessDefinition pd = repositoryService.createProcessDefinitionQuery().processDefinitionKey(<span class="hljs-string">"FormDemo01"</span>).latestVersion().singleResult();</span><br><span class="line">    Map&lt;String, String&gt; vars = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    vars.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-string">"2022-10-10 10:10"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"endTime"</span>, <span class="hljs-string">"2022-10-12 10:10"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"玩两天"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"days"</span>, <span class="hljs-string">"3"</span>);</span><br><span class="line">    ProcessInstance pi = formService.submitStartFormData(pd.getId(), vars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，我们这里通过 <code>formService.submitStartFormData</code> 方法来启动流程实例，启动的时候，传入了 vars 变量。</p><p>流程实例启动成功之后，我们在 <code>ACT_RU_VARIABLE</code> 表中就可以看到这些动态表单的信息。</p><p><img src="http://img.itboyhub.com/2022/08/20221025210525.png" alt></p><p>从这里可以看到我们刚刚存入的数据。</p><h2 id="4-查询任务上的表单"><a href="#4-查询任务上的表单" class="headerlink" title="4. 查询任务上的表单"></a>4. 查询任务上的表单</h2><p>现在我们的流程走到了 <code>提交请假申请</code> 这一步了，我们在绘制流程图的时候，<code>提交请假申请</code> 这个 UserTask 中也是有动态表单的，前面启动流程时传递的动态表单信息，现在已经传到 <code>提交请假申请</code> 这一步了，我们可以通过如下方式来进行查询：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    TaskFormData taskFormData = formService.getTaskFormData(task.getId());</span><br><span class="line">    List&lt;FormProperty&gt; formProperties = taskFormData.getFormProperties();</span><br><span class="line">    <span class="hljs-keyword">for</span> (FormProperty fp : formProperties) &#123;</span><br><span class="line">        String value = fp.getValue();</span><br><span class="line">        String id = fp.getId();</span><br><span class="line">        <span class="hljs-keyword">boolean</span> readable = fp.isReadable();</span><br><span class="line">        <span class="hljs-keyword">boolean</span> writable = fp.isWritable();</span><br><span class="line">        <span class="hljs-keyword">boolean</span> required = fp.isRequired();</span><br><span class="line">        String name = fp.getName();</span><br><span class="line">        FormType type = fp.getType();</span><br><span class="line">        String key = <span class="hljs-string">""</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> EnumFormType) &#123;</span><br><span class="line">            key = <span class="hljs-string">"values"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type <span class="hljs-keyword">instanceof</span> DateFormType) &#123;</span><br><span class="line">            key = <span class="hljs-string">"datePattern"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object information = type.getInformation(key);</span><br><span class="line">        logger.info(<span class="hljs-string">"value:&#123;&#125;,id:&#123;&#125;,readable:&#123;&#125;,writeable:&#123;&#125;,required:&#123;&#125;,name:&#123;&#125;,info:&#123;&#125;"</span>, value, id, readable, writable, required, name, information);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，调用 <code>formService.getTaskFormData</code> 方法传入 TaskId 即可进行查询。这个时候查询出来的内容就有值了：</p><p><img src="http://img.itboyhub.com/2022/08/20221025213552.png" alt></p><p>可能有的小伙伴会说，这跟用变量有啥区别呀，用变量不也是这样吗？</p><p><strong>变量是散的，而表单是整的。</strong></p><p>在上面的代码中，一个方法就可以提取出来所有的表单信息了，然后就遍历就行了。</p><p>另外还需要注意，如果 <code>提交请假申请</code> 中的动态表单和启动节点的动态表单不一致的话，<code>提交请假申请</code> 节点中有哪些动态表单，就能拿到哪些数据，其他的数据就不能通过表单拿到。</p><p>以上面的案例来说，startEvent 中有 startTime、endTime、reason 以及 days 四个动态表单属性，如果 <code>提交请假申请</code> 中只有 reason 和 days 两个动态表单属性的话，那么就只能获取这两个动态表单属性，其他的动态表单属性则可以通过变量去获取。</p><h2 id="5-保存与完成"><a href="#5-保存与完成" class="headerlink" title="5. 保存与完成"></a>5. 保存与完成</h2><p>对于 UserTask 上的表单，我们首先可以通过如下方式来提交表单数据：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    Map&lt;String, String&gt; vars = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    vars.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-string">"2022-10-11 11:11"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"endTime"</span>, <span class="hljs-string">"2022-10-19 11:11"</span>);</span><br><span class="line">    formService.saveFormData(task.getId(), vars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法只是保存动态表单变量，并不会完成当前 Task。</p><p>如果想在提交表单变量的同时顺便完成当前 UserTask，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    Map&lt;String, String&gt; vars = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    vars.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-string">"2022-10-11 11:11"</span>);</span><br><span class="line">    vars.put(<span class="hljs-string">"endTime"</span>, <span class="hljs-string">"2022-10-19 11:11"</span>);</span><br><span class="line">    formService.submitTaskFormData(task.getId(), vars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在提交表单变量的同时，还会顺便 complete 当前 UserTask。</p><p>好啦，这就是关于动态表单松哥和大家介绍的内容啦～</p><p>动态表单用法简单，很多小伙伴想不明白为什么要用表单，用变量不行吗？技术上来说，变量当然可以，但是变量是一个一个的，是零散的，而表单是整的，整存整取的。</p><p>just this。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;有小伙伴在星球上催了好几次了，今天松哥就来和大家聊一聊流程中的表单。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>Flowable 定时器的各种玩法</title>
    <link href="http://www.javaboy.org/2022/1102/tienchin-flowable-timer.html"/>
    <id>http://www.javaboy.org/2022/1102/tienchin-flowable-timer.html</id>
    <published>2022-11-02T10:21:26.000Z</published>
    <updated>2022-12-20T11:06:54.549Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>今天我们来聊一聊 Flowable 中的定时器。</p><a id="more"></a><h2 id="1-流程定义定时激活"><a href="#1-流程定义定时激活" class="headerlink" title="1. 流程定义定时激活"></a>1. 流程定义定时激活</h2><p>在之前松哥给小伙伴们介绍流程定义的时候，流程都是定义好之后立马就激活了，其实在流程定义的这个过程中，我们还可以设置一个激活时间，也就是流程定义好之后，并不会立马激活（不激活就不能据此流程定义创建新流程），而是在延迟某一个固定时间之后，才会激活，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessDeployController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RepositoryService repositoryService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/deploy"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">deploy</span><span class="hljs-params">(MultipartFile file,String tenantId)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        DeploymentBuilder deploymentBuilder = repositoryService.createDeployment()</span><br><span class="line">                .category(<span class="hljs-string">"javaboy的工作流分类"</span>)</span><br><span class="line">                .name(<span class="hljs-string">"javaboy的工作流名称"</span>)</span><br><span class="line">                .addInputStream(<span class="hljs-string">"fff.bpmn"</span>, file.getInputStream())</span><br><span class="line">                .tenantId(tenantId)</span><br><span class="line">                .activateProcessDefinitionsOn(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>))</span><br><span class="line">                .key(<span class="hljs-string">"javaboy的工作流key666"</span>);</span><br><span class="line">        Deployment deployment = deploymentBuilder</span><br><span class="line">                .deploy();</span><br><span class="line">        <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"部署成功"</span>,deployment.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.activateProcessDefinitionsOn(new Date(System.currentTimeMillis() + 1000 * 60))</code> 表示流程在延迟一分钟之后，才激活。</p><p>此时，我们启动项目，然后调用该接口部署一个流程，部署完成之后，如果立马调用流程启动方法去启动流程，就会抛出如下异常：</p><p><img src="http://img.itboyhub.com/2022/08/20221020195205.png" alt></p><p>可以看到，这里也说的很明确了，这个流程定义目前是一个挂起的状态，无法启动。</p><p>这个时候，我们去查看 <code>ACT_RU_TIMER_JOB</code> 表，就会发现该表中多了一条定时任务执行计划：</p><p><img src="http://img.itboyhub.com/2022/08/20221020200012.png" alt></p><p>该表有一个 <code>DUEDATE_</code> 字段，这个字段描述了这个定时任务执行的具体时间，在到达时间后，定时任务会自动执行，将 <code>ACT_RE_PROCDEF</code> 表中，流程的状态字段 <code>SUSPENSION_STATE_</code> 由 2 改为 1。</p><h2 id="2-流程实例定时挂起"><a href="#2-流程实例定时挂起" class="headerlink" title="2. 流程实例定时挂起"></a>2. 流程实例定时挂起</h2><p>除了流程定义可以定时挂起外，流程实例也可以定时挂起。方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">RepositoryService repositoryService;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test23</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    repositoryService.suspendProcessDefinitionByKey(<span class="hljs-string">"UserTaskDemo"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">120</span> * <span class="hljs-number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个执行完成后，也会在 <code>ACT_RU_TIMER_JOB</code> 表中添加一条定时任务，在两分钟之后，会自动挂起这个流程定义以及与之相对应的流程。实际上就是将对应表中的 <code>SUSPENSION_STATE_</code> 字段值由 1 改为 2。</p><h2 id="3-定时任务执行过程"><a href="#3-定时任务执行过程" class="headerlink" title="3. 定时任务执行过程"></a>3. 定时任务执行过程</h2><p>前面两个小节，松哥都和大家提到，<code>ACT_RU_TIMER_JOB</code> 表中会保存定时任务信息，时间到了就会自动执行。</p><p>但是小伙伴们注意，定时任务每次执行的时候，其实并不是去 <code>ACT_RU_TIMER_JOB</code> 表中查询数据，而是去 <code>ACT_RU_JOB</code> 表中查询数据并执行。</p><p>当定时的时间到了后，Flowable 会自动将数据从 <code>ACT_RU_TIMER_JOB</code> 表中移动到 <code>ACT_RU_JOB</code> 表中，然后定时器查询到 <code>ACT_RU_JOB</code> 表中的数据之后，就立马自动执行了。大致上就是这样一个流程。</p><p>我给大家手动演示一个。</p><p>我现在的流程定义和流程实例都挂起了，我想要在 4 分钟之后，将之全部启动，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test24</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    repositoryService.activateProcessDefinitionByKey(<span class="hljs-string">"UserTaskDemo"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">240</span> * <span class="hljs-number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这行代码执行之后，4 分钟之后，流程定义和流程实例就全部都启动了。但是我现在忽然就不想等四分钟了，我想立马执行，那么我们可以去 <code>ACT_RU_TIMER_JOB</code> 表中找到这个定时任务的 ID，然后执行如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">ManagementService managementService;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test25</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    managementService.moveTimerToExecutableJob(<span class="hljs-string">"b7e9501d-5075-11ed-9706-acde48001122"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码表示将 ID 为 <code>b7e9501d-5075-11ed-9706-acde48001122</code> 的记录由 <code>ACT_RU_TIMER_JOB</code> 表移动到 <code>ACT_RU_JOB</code> 表中，移动完成后，这个任务就会被立马执行。</p><p>当一个定时任务开启了，还能不能取消呢？当然可以！我们将这个定时任务放到私信队列表即可，私信队列表是 <code>ACT_RU_DEADLETTER_JOB</code>，具体操作方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test27</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    managementService.moveJobToDeadLetterJob(<span class="hljs-string">"6b95dc62-5081-11ed-a00f-acde48001122"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法执行的参数是 <code>ACT_RU_TIMER_JOB</code> 表中的任务 ID，执行完成后，<code>ACT_RU_TIMER_JOB</code> 表中对应的记录就会被移动到 <code>ACT_RU_DEADLETTER_JOB</code> 表中，所以定时任务就不会被执行了。</p><p>对于已经移动到私信队列的定时任务，也可以再通过如下方法移动回 <code>ACT_RU_JOB</code> 表中被立马执行（即使时间没到也会立马执行），如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test26</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    managementService.moveDeadLetterJobToExecutableJob(<span class="hljs-string">"6b95dc62-5081-11ed-a00f-acde48001122"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数就是任务 ID。</p><p>好啦，几个简单的例子和小伙伴们分享了下 Flowable 中定时器的玩法，感兴趣的小伙伴可以去试试啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;今天我们来聊一聊 Flowable 中的定时器。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>十月结束了～给小伙伴们汇报下 TienChin 项目视频进度</title>
    <link href="http://www.javaboy.org/2022/1101/tienchin-video.html"/>
    <id>http://www.javaboy.org/2022/1101/tienchin-video.html</id>
    <published>2022-11-01T10:21:11.000Z</published>
    <updated>2022-12-20T11:06:51.428Z</updated>
    
    <content type="html"><![CDATA[<p>忙的晕头转向，昨天忘发了，囧。</p><p>距离上次跟小伙伴们汇报 TienChin 项目视频进度已经过去一个月啦，今天是 11 月 1 号，再来汇报一下十月份视频的进展。</p><a id="more"></a><p>其实也没啥好说的，直接上目录吧！</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">000.开篇.mp4</span><br><span class="line">001.运行RuoYi-Vue.mp4</span><br><span class="line">002.代码格式化.mp4</span><br><span class="line">003.项目结构大改造.mp4</span><br><span class="line">004.项目改造完善.mp4</span><br><span class="line">005.项目结构分析.mp4</span><br><span class="line">006.验证码响应结果分析.mp4</span><br><span class="line">007.验证码生成接口分析.mp4</span><br><span class="line">008.验证码配置分析.mp4</span><br><span class="line">009.验证码的校验.mp4</span><br><span class="line">010.登录流程分析.mp4</span><br><span class="line">011.登录JWT校验.mp4</span><br><span class="line">012.SpringSecurity登录配置分析.mp4</span><br><span class="line">013.自定义多数据源思路分析.mp4</span><br><span class="line">014.自定义多数据源-1.mp4</span><br><span class="line">015.自定义多数据源-2.mp4</span><br><span class="line">016.手动实现网页上切换数据源.mp4</span><br><span class="line">017.RateLimiter注解简介.mp4</span><br><span class="line">018.自定义限流注解-1.mp4</span><br><span class="line">019.自定义限流注解-2.mp4</span><br><span class="line">020.RuoYi脚手架限流注解分析.mp4</span><br><span class="line">021.幂等性实现的6中思路梳理.mp4</span><br><span class="line">022.实现JSON格式参数多次读取.mp4</span><br><span class="line">023.防止请求重复提交.mp4</span><br><span class="line">024.防止接口重复提交注解分析.mp4</span><br><span class="line">025.数据权限注解介绍.mp4</span><br><span class="line">026.数据权限案例准备工作.mp4</span><br><span class="line">027.权限注解实现思路分析.mp4</span><br><span class="line">028.自定义数据权限注解@DataScope.mp4</span><br><span class="line">029.数据权限过滤角色数据.mp4</span><br><span class="line">030.数据权限过滤用户数据.mp4</span><br><span class="line">031.数据权限注解总结.mp4</span><br><span class="line">032.操作日志记录.mp4</span><br><span class="line">033.修改日志方法名称.mp4</span><br><span class="line">034.理解Aware接口.mp4</span><br><span class="line">035.自定义注解+AOP整理.mp4</span><br><span class="line">036.TienChin细化到按钮的权限实现思路.mp4</span><br><span class="line">037.理解TienChin项目中的权限注解.mp4</span><br><span class="line">038.角色和权限概念梳理.mp4</span><br><span class="line">039.Spring Security中角色和权限的区别.mp4</span><br><span class="line">040.SpringSecurity中的权限处理逻辑.mp4</span><br><span class="line">041.SpringSecurity中使用权限通配符.mp4</span><br><span class="line">042.SpringSecurity另一种权限判断方式.mp4</span><br><span class="line">043.自定义权限表达式.mp4</span><br><span class="line">044.使用POSTMAN测试项目接口.mp4</span><br><span class="line">045.自定义TienChin项目权限判断表达式.mp4</span><br><span class="line">046.登录鉴权流程梳理.mp4</span><br><span class="line">047.运行RuoYi-Vue3.mp4</span><br><span class="line">048.动态菜单实现思路.mp4</span><br><span class="line">049.动态菜单JSON分析.mp4</span><br><span class="line">050.动态菜单的path问题.mp4</span><br><span class="line">051.服务端查询当前登录用户菜单.mp4</span><br><span class="line">052.服务端构建动态菜单.mp4</span><br><span class="line">053.动态菜单实现思路梳理.mp4</span><br><span class="line">054.Vue3中的动态菜单递归渲染.mp4</span><br><span class="line">055.前端固定路由定义.mp4</span><br><span class="line">056.前端轻量级状态管理框架Pinia.mp4</span><br><span class="line">057.前端网络请求封装思路.mp4</span><br><span class="line">058.前端登录请求执行流程.mp4</span><br><span class="line">059.前端动态菜单加载思路.mp4</span><br><span class="line">060.动态菜单为什么不能存在localStorage.mp4</span><br><span class="line">061.动态菜单为什么不能存在localStorage-2.mp4</span><br><span class="line">062.前端路由导航守卫源码分析.mp4</span><br><span class="line">063.前端动态菜单加载四个核心变量.mp4</span><br><span class="line">064.routes变量多级菜单铺平.mp4</span><br><span class="line">065.component字符串转对象.mp4</span><br><span class="line">066.前端多级菜单铺平.mp4</span><br><span class="line">067.过滤前端本地动态路由.mp4</span><br><span class="line">068.前端generateRoutes方法.mp4</span><br><span class="line">069.前端回调地狱.mp4</span><br><span class="line">070.Promise初体验.mp4</span><br><span class="line">071.then方法的各种情况.mp4</span><br><span class="line">072.Promise中的catch代码块.mp4</span><br><span class="line">073.Promise中的finally代码块.mp4</span><br><span class="line">074.Promise中的静态方法.mp4</span><br><span class="line">075.TienChin项目Vue3中的Promise.mp4</span><br><span class="line">076.Vue3中的变量定义方式.mp4</span><br><span class="line">077.Vue3中方法的定义.mp4</span><br><span class="line">078.Vue3中钩子函数的定义.mp4</span><br><span class="line">079.Vue3中的计算属性.mp4</span><br><span class="line">080.Vue3中的watch函数.mp4</span><br><span class="line">081.Vue3中的ref和reactive.mp4</span><br><span class="line">082.Vue3中的setup函数.mp4</span><br><span class="line">083.Vue3中自定义全局方法.mp4</span><br><span class="line">084.Vue3中router和store的调用.mp4</span><br><span class="line">085.插件和全局方法的区别.mp4</span><br><span class="line">086.在Vue3中定义一个插件.mp4</span><br><span class="line">087.在插件中注册全局组件.mp4</span><br><span class="line">088.在插件中自定义全局指令.mp4</span><br><span class="line">089.Vue3自定义插件时传入参数.mp4</span><br><span class="line">090.自定义插件中的provide和inject.mp4</span><br><span class="line">091.什么是Vue中的指令.mp4</span><br><span class="line">092.Vue3自定义局部指令.mp4</span><br><span class="line">093.Vue3全局自定义指令.mp4</span><br><span class="line">094.Vue3自定义指令同时传递两个参数.mp4</span><br><span class="line">095.自定义插件传递动态参数.mp4</span><br><span class="line">096.Vue3中自定义权限指令.mp4</span><br><span class="line">097.Vite简介.mp4</span><br><span class="line">098.创建一个基于Vite的项目.mp4</span><br><span class="line">099.Vite项目安装vue-router.mp4</span><br><span class="line">100.Vue3方法自动导入插件.mp4</span><br><span class="line">101.Vite中省略组件后缀.mp4</span><br><span class="line">102.Vue3简化组件名称配置.mp4</span><br><span class="line">103.【workflow】状态机解决流程问题.mp4</span><br><span class="line">104.【workflow】报销审批流程.mp4</span><br><span class="line">105.【workflow】笔记本电脑生产流程.mp4</span><br><span class="line">106.【workflow】三大主流工作流.mp4</span><br><span class="line">107.【workflow】BPMN流程图规范.mp4</span><br><span class="line">108.【workflow】BPMN流程图元素.mp4</span><br><span class="line">109.【workflow】常见的流程绘制工具梳理.mp4</span><br><span class="line">110.【workflow】使用IDEA插件绘制流程图.mp4</span><br><span class="line">111.【workflow】分析流程图的XML文件.mp4</span><br><span class="line">112.【workflow】flowable-ui两种安装方式.mp4</span><br><span class="line">113.【workflow】flowable-ui四大核心功能.mp4</span><br><span class="line">114.【workflow】flowable-ui身份管理.mp4</span><br><span class="line">115.【workflow】flowable-ui管理员功能.mp4</span><br><span class="line">116.【workflow】flowable-ui建模器应用程序-报销流程介绍.mp4</span><br><span class="line">117.【workflow】flowable-ui建模器应用程序-绘制流程图.mp4</span><br><span class="line">118.【workflow】flowable-ui建模器应用程序-填写报销材料.mp4</span><br><span class="line">119.【workflow】flowable-ui建模器应用程序-小于等于1000审批流程.mp4</span><br><span class="line">120.【workflow】flowable-ui建模器应用程序-大于1000审批流程.mp4</span><br><span class="line">121.【workflow】flowable-ui建模器应用程序-流程图下载.mp4</span><br><span class="line">122.【workflow】flowable-ui建模器应用程序-创建流程应用.mp4</span><br><span class="line">123.【workflow】flowable-ui建模器应用程序-细节梳理.mp4</span><br><span class="line">124.【workflow】flowable-ui建模器应用程序-流程监控.mp4</span><br><span class="line">125.【workflow】flowable源码目录结构.mp4</span><br><span class="line">126.【workflow】flowable源码编译.mp4</span><br><span class="line">127.【workflow】flowable源码启动.mp4</span><br><span class="line">128.【workflow】flowable源码接入MySQL数据库.mp4</span><br><span class="line">129.【workflow】flowable源码接口分析.mp4</span><br><span class="line">130.【workflow】flowable添加用户.mp4</span><br><span class="line">131.【workflow】flowable修改和删除用户.mp4</span><br><span class="line">132.【workflow】flowable查询用户.mp4</span><br><span class="line">133.【workflow】flowable用户组的添加与删除.mp4</span><br><span class="line">134.【workflow】flowable用户组的更新与查询.mp4</span><br><span class="line">135.【workflow】flowable查看表详细信息.mp4</span><br><span class="line">136.【workflow】flowable流程自动部署.mp4</span><br><span class="line">137.【workflow】flowable流程自动升级.mp4</span><br><span class="line">138.【workflow】flowable修改流程定义的分类.mp4</span><br><span class="line">139.【workflow】flowable流程自动部署配置.mp4</span><br><span class="line">140.【workflow】flowable手动部署流程.mp4</span><br><span class="line">141.【workflow】flowable查询API.mp4</span><br><span class="line">142.【workflow】flowable自定义流程定义查询SQL.mp4</span><br><span class="line">143.【workflow】flowable自定义流程部署查询SQL.mp4</span><br><span class="line">144.【workflow】flowable删除流程定义.mp4</span><br><span class="line">145.【workflow】flowable流程实例与执行实例.mp4</span><br><span class="line">146.【workflow】flowable启动一个流程实例.mp4</span><br><span class="line">147.【workflow】flowable另一种流程启动方式.mp4</span><br><span class="line">148.【workflow】flowable流程执行.mp4</span><br><span class="line">149.【workflow】flowable判断流程是否执行结束.mp4</span><br><span class="line">150.【workflow】flowable查看运行活动节点.mp4</span><br><span class="line">151.【workflow】flowable删除流程实例.mp4</span><br><span class="line">156.【workflow】flowable中的租户.mp4</span><br><span class="line">157.【workflow】flowable中的ReceiveTask.mp4</span><br><span class="line">158.【workflow】UserTask直接指定处理人.mp4</span><br><span class="line">159.【workflow】UserTask委派或者自己处理.mp4</span><br><span class="line">160.【workflow】通过变量指定UserTask处理人.mp4</span><br><span class="line">161.【workflow】通过监听器指定UserTask处理人.mp4</span><br><span class="line">162.【workflow】设置UserTask处理人为流程发起人.mp4</span><br><span class="line">163.【workflow】设置UserTask候选人.mp4</span><br><span class="line">164.【workflow】UserTask认领任务.mp4</span><br><span class="line">165.【workflow】通过变量或者监听器为UserTask设置处理人.mp4</span><br><span class="line">166.【workflow】UserTask任务回退.mp4</span><br><span class="line">167.【workflow】UserTask候选人的添加与删除.mp4</span><br><span class="line">168.【workflow】UserTask按角色分配.mp4</span><br><span class="line">169.【workflow】UserTask通过变量设置角色.mp4</span><br><span class="line">170.【workflow】通过监听器配置ServiceTask.mp4</span><br><span class="line">171.【workflow】ServiceTask监听器类设置属性.mp4</span><br><span class="line">172.【workflow】ServiceTask委托表达式.mp4</span><br><span class="line">173.【workflow】ServiceTask表达式.mp4</span><br><span class="line">174.【workflow】脚本任务之JavaScript.mp4</span><br><span class="line">175.【workflow】脚本任务之Groovy.mp4</span><br><span class="line">176.【workflow】脚本任务之Juel.mp4</span><br><span class="line">177.【workflow】流程网关之排他网关.mp4</span><br><span class="line">178.【workflow】流程网关之并行网关.mp4</span><br><span class="line">179.【workflow】流程网关之包容网关.mp4</span><br><span class="line">【号外001】.登录流程解析.mp4</span><br><span class="line">【号外002】.分布式事务开篇.mp4</span><br><span class="line">【号外003】.分布式事务seata三个核心概念.mp4</span><br><span class="line">【号外004】.分布式事务seata四种事务模式.mp4</span><br><span class="line">【号外005】.分布式事务seata中的at模式.mp4</span><br><span class="line">【号外006】.分布式事务安装seata-server.mp4</span><br><span class="line">【号外007】.分布式事务seata-at模式实战.mp4</span><br><span class="line">【号外008】.分布式事务seata-at模式总结.mp4</span><br><span class="line">【号外009】.多数据源如何处理事务问题.mp4</span><br><span class="line">【号外010】.分布式事务seata-at模式补充.mp4</span><br><span class="line">【号外011】.分布式事务seata-tcc模式简介.mp4</span><br><span class="line">【号外012】.分布式事务seata-tcc模式实战-1.mp4</span><br><span class="line">【号外013】.分布式事务seata-tcc模式实战-2.mp4</span><br><span class="line">【号外014】.分布式事务seata-tcc模式实战-3.mp4</span><br><span class="line">【号外015】.分布式事务seata-tcc模式实战-4.mp4</span><br><span class="line">【号外016】.分布式事务seata-tcc总结.mp4</span><br><span class="line">【号外017】.分布式事务seata-xa简介.mp4</span><br><span class="line">【号外018】.MySQL中的XA事务实践.mp4</span><br><span class="line">【号外019】.分布式事务seata-xa模式实战-1.mp4</span><br><span class="line">【号外020】.分布式事务seata-xa模式实战-2.mp4</span><br><span class="line">【号外021】.分布式事务总结-1.mp4</span><br><span class="line">【号外022】.分布式事务总结-2.mp4</span><br><span class="line">【号外023】.动态代理的两种实现方式.mp4</span><br><span class="line">【号外024】.解决多数据源注解失效问题.mp4</span><br></pre></td></tr></table></figure><p><strong>目前已经录的总共是 180+24=204 集，约 45 个小时。</strong> 十月份的更新主要是讲了 Flowable 的各种玩法，目前 Flowable 的玩法已经讲的差不多了，再更一两次 Flowable 就更完了，Flowable 的知识点更新完毕后，就正式开始做项目了（估计本月就开始啦）。</p><p>虽然我感觉自己一直在吆喝，但是还是不少小伙伴来了第一句话是“松哥又有新教程啦？”：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113711.png" alt></p><p>因此这里再跟大伙啰嗦一下：</p><blockquote><p>TienChin 项目是一个健身会员管理系统，基于 RuoYi-Vue 脚手架来做，使用 Spring Boot + Vue3 开发，不同于之前的 vhr 是一个脚手架，TienChin 项目的业务完成度会超过 90%。这个项目的视频教程整体上分为两大块：第一块主要是解剖 RuoYi-Vue 脚手架，让小伙伴们能够熟练掌握这个脚手架的使用，在这个过程中，我会讲许多技术点，前面列出来的视频目录都属于这一部分的内容，这个过程中我不会带领大家从头敲一边 RuoYi-Vue 脚手架，但是对项目里边的一些技术点，会有针对性的讲解，也会写一些案例来帮助大家理解这些技术点。第二块内容则主要是业务功能的完成了，业务功能涉及到的技术点主要有：SpringBoot、Vue、MyBatis Plus、MySQL、Redis、Flowable、EasyExcel、NodeJS 等。</p></blockquote><p>目前更新的视频主要出于第一阶段，不过按照目前的进度，应该很快就会进入到第二阶段。</p><p>这些视频基本上都是工作之余录制的，大部分都是早上 6-8 点之间录的，也有一些是利用周末的晚上录制的，所以是付费视频，视频定价是 399，不过目前可以 7 折上车，也就是 279，之前买过 vhr 的小伙伴可在此基础上再优惠 30，即只要 249，随着视频的录制，内容越来越多，折扣力度也会变小，这个之前买过 vhr 视频的小伙伴应该都懂，无论你何时上车，当前价格都是你在未来能够买到的最低价格啦。</p><p>录视频还是蛮辛苦的，一方面赚点小钱养家糊口，另一方面也是小伙伴们的认可在支撑着我把这件事做下去，得瑟一下：</p><p><img src="http://img.itboyhub.com/2021/10/tran/996.jpg" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/995.jpg" alt></p><p><img src="http://img.itboyhub.com/2021/10/tran/013.jpeg" alt></p><p><strong>有时候看小伙伴们发的，我真的特别动容。虽然大家看我天天写文章聊技术，其实我在生活中除了工作之外很少和人交流，真的特别想给这些爱学习会说话的小伙伴们点赞，他们肯定会混的比我好。</strong></p><hr><p>好啦，最后再统一回答大家几个关于视频的问题。</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码一人一码。至于小伙伴们推荐的阿里网盘等，由于空间、分享文件类型等限制，并无法用在 TienChin 项目视频分发中。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：视频可以试看吗？</strong></p><p>其实我最近在公号发的视频，大家都可以当作试看的，反正的录视频风格是不变的。和 vhr 视频相比，现在的 TienChin 项目视频音质是杠杠滴，下面三个视频是我最近发过的，小伙伴们可以当作试看的视频：</p><p><strong>Q4：可以砍价吗？</strong></p><p>不可以，这个价格已经很便宜了，没法砍了（悄悄告诉大家，从 vhr 到 tienchin，暂时没有人砍价成功过）。</p><p><strong>Q5：视频多久更新完毕？</strong></p><p>其实如果单纯带着大家写业务功能，这个项目不会花太多时间，这样虽然大家完整的做了一个项目，但是技术却不会有太多长进，而我则希望在这个过程中多整点活，能让小伙伴们技术也有一些提升，这样内容一加，最终何时更完就不确定了。不过，有一点是可以保证的，每周至少一次，每周至少更一个半小时精品视频。</p><p><strong>Q6：知识星球是什么？</strong></p><p>星球主要是用来更新视频下载地址的地方，大家在这套视频教程时遇到问题时，都可以在星球上提问，小伙伴们购买视频后，我会拉你进星球。</p><p><strong>Q7：这套视频适合哪些人看？</strong></p><p>学习这套视频，首先需要有 SSM 基础，如果没有，可以在公众号后台回复 SSM，有我录制的免费视频教程；另外也需要一些 Spring Boot 基础和 Vue 基础，要是没接触过 Spring Boot 和 Vue 的话，那么建议先看看 vhr，戳这里：<a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><p><strong>Q8：看视频有问题可以问吗？</strong></p><p>参考 Q6。</p><p><strong>Q9：这套视频我能学到啥？</strong></p><p>TienChin 项目基于 RuoYi-Vue 脚手架（Spring Boot+Vue3），这套视频学完后，小伙伴们对 RuoYi-Vue 脚手架基本上就融会贯通了，并能在 RuoYi-Vue 脚手架上随心所欲的开发常规的企业后台应用。并且对于分布式事务 seata、Flowable 流程引擎等框架也能熟练使用并掌握其原理，对于 Redis 在项目中的各种实际应用场景也会有较好的掌握。</p><hr><p><strong>好啦，七折 279 抄底就在今天啦！</strong></p><p>P.s.：可能有小伙伴加了松哥多个微信，其实没有必要重复添加，任意一个都能找到我。当然，如果你还没有松哥微信，扫码加微信，转账 279 上车吧（买过 vhr 的小伙伴可在此基础上再优惠 ¥30 哦）～</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忙的晕头转向，昨天忘发了，囧。&lt;/p&gt;
&lt;p&gt;距离上次跟小伙伴们汇报 TienChin 项目视频进度已经过去一个月啦，今天是 11 月 1 号，再来汇报一下十月份视频的进展。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>Flowable 已经执行完毕的流程去哪找？</title>
    <link href="http://www.javaboy.org/2022/1031/tienchin-flowale-process-history.html"/>
    <id>http://www.javaboy.org/2022/1031/tienchin-flowale-process-history.html</id>
    <published>2022-10-31T10:20:58.000Z</published>
    <updated>2022-12-20T11:06:48.409Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在之前的文章中松哥和小伙伴们聊过，正在执行的流程信息是保存在以 <code>ACT_RU_</code> 为前缀的表中，执行完毕的流程信息则保存在以 <code>ACT_HI_</code> 为前缀的表中，也就是流程历史信息表，当然这个历史信息表继续细分的话，还有好多种，今天我们就来聊一聊这个话题。</p><a id="more"></a><p>假设我有如下一个流程：</p><p><img src="http://img.itboyhub.com/2022/08/20221015111609.png" alt></p><p>当这个流程执行完毕后，以 <code>ACT_RU_</code> 为前缀的表中的数据均已清空，现在如果想查看刚刚执行过的流程信息，我们就得去以 <code>ACT_HI_</code> 为前缀的表中。</p><h2 id="1-历史流程信息"><a href="#1-历史流程信息" class="headerlink" title="1. 历史流程信息"></a>1. 历史流程信息</h2><p>历史流程信息查看，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HistoricProcessInstance&gt; list = historyService.createHistoricProcessInstanceQuery().finished().list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricProcessInstance hpi : list) &#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"name:&#123;&#125;,startTime:&#123;&#125;,endTime:&#123;&#125;"</span>,hpi.getName(),hpi.getStartTime(),hpi.getEndTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候执行的 <code>finished()</code> 方法表示查询已经执行完毕的流程信息（从这里也可以看出，对于未执行完毕的流程信息也会保存在历史表中）。</p><p>我们来看下这个查询对应的 SQL，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> RES.* , DEF.KEY_ <span class="hljs-keyword">as</span> PROC_DEF_KEY_, DEF.NAME_ <span class="hljs-keyword">as</span> PROC_DEF_NAME_, DEF.VERSION_ <span class="hljs-keyword">as</span> PROC_DEF_VERSION_, DEF.DEPLOYMENT_ID_ <span class="hljs-keyword">as</span> DEPLOYMENT_ID_ <span class="hljs-keyword">from</span> ACT_HI_PROCINST RES <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> ACT_RE_PROCDEF <span class="hljs-keyword">DEF</span> <span class="hljs-keyword">on</span> RES.PROC_DEF_ID_ = DEF.ID_ <span class="hljs-keyword">WHERE</span> RES.END_TIME_ <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> RES.ID_ <span class="hljs-keyword">asc</span></span><br></pre></td></tr></table></figure><p>从这个 SQL 中可以看到，这个查询本质上就是查询的 <code>ACT_HI_PROCINST</code> 表。如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221015173150.png" alt></p><p>如果我们在查询的时候不限制流程是否执行完毕，那么我们的查询方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HistoricProcessInstance&gt; list = historyService.createHistoricProcessInstanceQuery().list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricProcessInstance hpi : list) &#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"name:&#123;&#125;,startTime:&#123;&#125;,endTime:&#123;&#125;"</span>,hpi.getName(),hpi.getStartTime(),hpi.getEndTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的查询 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> RES.* , DEF.KEY_ <span class="hljs-keyword">as</span> PROC_DEF_KEY_, DEF.NAME_ <span class="hljs-keyword">as</span> PROC_DEF_NAME_, DEF.VERSION_ <span class="hljs-keyword">as</span> PROC_DEF_VERSION_, DEF.DEPLOYMENT_ID_ <span class="hljs-keyword">as</span> DEPLOYMENT_ID_ <span class="hljs-keyword">from</span> ACT_HI_PROCINST RES <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> ACT_RE_PROCDEF <span class="hljs-keyword">DEF</span> <span class="hljs-keyword">on</span> RES.PROC_DEF_ID_ = DEF.ID_ <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> RES.ID_ <span class="hljs-keyword">asc</span></span><br></pre></td></tr></table></figure><p>和前面的 SQL 相比，后面的 SQL 少了 <code>WHERE RES.END_TIME_ is not NULL</code> 条件，也就是说，判断一个流程是否执行完毕，就看它的 <code>END_TIME_</code> 是否为空，不为空就表示流程已经执行结束了，为空就表示流程尚在执行中。</p><h2 id="2-历史任务查询"><a href="#2-历史任务查询" class="headerlink" title="2. 历史任务查询"></a>2. 历史任务查询</h2><p>刚刚我们查询的是历史流程，接下来我们来看下历史任务，也就是查询一个流程中执行过的 Task 信息，如下表示查询所有的历史流程任务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HistoricTaskInstance&gt; list = historyService.createHistoricTaskInstanceQuery().list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricTaskInstance hti : list) &#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"name:&#123;&#125;,assignee:&#123;&#125;,createTime:&#123;&#125;,endTime:&#123;&#125;"</span>,hti.getName(),hti.getAssignee(),hti.getCreateTime(),hti.getEndTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询对应的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> RES.* <span class="hljs-keyword">from</span> ACT_HI_TASKINST RES <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> RES.ID_ <span class="hljs-keyword">asc</span></span><br></pre></td></tr></table></figure><p>可以看到，历史任务表就是 <code>ACT_HI_TASKINST</code>，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221015173629.png" alt></p><p>当然，这里还有很多其他的玩法，例如查询某一个流程已经执行完毕的历史任务，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HistoricProcessInstance&gt; instanceList = historyService.createHistoricProcessInstanceQuery().list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricProcessInstance hpi : instanceList) &#123;</span><br><span class="line">        List&lt;HistoricTaskInstance&gt; list = historyService.createHistoricTaskInstanceQuery().processInstanceId(hpi.getId()).finished().list();</span><br><span class="line">        <span class="hljs-keyword">for</span> (HistoricTaskInstance hti : list) &#123;</span><br><span class="line">            logger.info(<span class="hljs-string">"name:&#123;&#125;,assignee:&#123;&#125;,createTime:&#123;&#125;,endTime:&#123;&#125;"</span>, hti.getName(), hti.getAssignee(), hti.getCreateTime(), hti.getEndTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里边的查询历史任务的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> RES.* <span class="hljs-keyword">from</span> ACT_HI_TASKINST RES <span class="hljs-keyword">WHERE</span> RES.PROC_INST_ID_ = ? <span class="hljs-keyword">and</span> RES.END_TIME_ <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> RES.ID_ <span class="hljs-keyword">asc</span></span><br></pre></td></tr></table></figure><p>可以看到，跟前面相比，多了两个条件：</p><ol><li>流程实例 ID</li><li>流程结束时间不为 null</li></ol><p>从这里也可以看出来，这个 finish 方法的执行逻辑跟我们前面讲的是一样的。</p><h2 id="3-历史活动查询"><a href="#3-历史活动查询" class="headerlink" title="3. 历史活动查询"></a>3. 历史活动查询</h2><p>历史任务就是各种 Task，历史活动则包括跟多内容，像开始/结束节点，连线等等这些信息都算是活动，这个在之前的文章中松哥已经和大家介绍过了。</p><p>查询代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test08</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HistoricActivityInstance&gt; list = historyService.createHistoricActivityInstanceQuery().list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricActivityInstance hai : list) &#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"name:&#123;&#125;,startTime:&#123;&#125;,assignee:&#123;&#125;,type:&#123;&#125;"</span>,hai.getActivityName(),hai.getStartTime(),hai.getAssignee(),hai.getActivityType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询对应的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> RES.* <span class="hljs-keyword">from</span> ACT_HI_ACTINST RES <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> RES.ID_ <span class="hljs-keyword">asc</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>ACT_HI_ACTINST</code> 表中保存了历史活动信息。</p><h2 id="4-历史变量查询"><a href="#4-历史变量查询" class="headerlink" title="4. 历史变量查询"></a>4. 历史变量查询</h2><p>查询流程执行的历史变量，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test09</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    HistoricProcessInstance pi = historyService.createHistoricProcessInstanceQuery().singleResult();</span><br><span class="line">    List&lt;HistoricVariableInstance&gt; list = historyService.createHistoricVariableInstanceQuery().processInstanceId(pi.getId()).list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricVariableInstance hvi : list) &#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"name:&#123;&#125;,type:&#123;&#125;,value:&#123;&#125;"</span>, hvi.getVariableName(), hvi.getVariableTypeName(), hvi.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询对应的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> RES.* <span class="hljs-keyword">from</span> ACT_HI_VARINST RES <span class="hljs-keyword">WHERE</span> RES.PROC_INST_ID_ = ? <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> RES.ID_ <span class="hljs-keyword">asc</span></span><br></pre></td></tr></table></figure><p>可以看到流程的历史变量信息保存在 <code>ACT_HI_VARINST</code> 表中。</p><h2 id="5-历史日志查询"><a href="#5-历史日志查询" class="headerlink" title="5. 历史日志查询"></a>5. 历史日志查询</h2><p>有的小伙伴看到日志这两个字可能会觉得奇怪，咦？流程执行还有日志吗？没听说过呀！</p><p>其实历史日志查询就是前面那几种的一个集大成者，用法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test10</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    HistoricProcessInstance pi = historyService.createHistoricProcessInstanceQuery().singleResult();</span><br><span class="line">    ProcessInstanceHistoryLog historyLog = historyService.createProcessInstanceHistoryLogQuery(pi.getId())</span><br><span class="line">            <span class="hljs-comment">//包括历史活动</span></span><br><span class="line">            .includeActivities()</span><br><span class="line">            <span class="hljs-comment">//包括历史任务</span></span><br><span class="line">            .includeTasks()</span><br><span class="line">            <span class="hljs-comment">//包括历史变量</span></span><br><span class="line">            .includeVariables()</span><br><span class="line">            .singleResult();</span><br><span class="line">    logger.info(<span class="hljs-string">"id:&#123;&#125;,startTime:&#123;&#125;,endTime:&#123;&#125;"</span>, historyLog.getId(), historyLog.getStartTime(), historyLog.getEndTime());</span><br><span class="line">    List&lt;HistoricData&gt; historicData = historyLog.getHistoricData();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricData data : historicData) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> HistoricActivityInstance) &#123;</span><br><span class="line">            HistoricActivityInstance hai = (HistoricActivityInstance) data;</span><br><span class="line">            logger.info(<span class="hljs-string">"name:&#123;&#125;,type:&#123;&#125;"</span>, hai.getActivityName(), hai.getActivityType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> HistoricTaskInstance) &#123;</span><br><span class="line">            HistoricTaskInstance hti = (HistoricTaskInstance) data;</span><br><span class="line">            logger.info(<span class="hljs-string">"name:&#123;&#125;,assignee:&#123;&#125;"</span>, hti.getName(), hti.getAssignee());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> HistoricVariableInstance) &#123;</span><br><span class="line">            HistoricVariableInstance hvi = (HistoricVariableInstance) data;</span><br><span class="line">            logger.info(<span class="hljs-string">"name:&#123;&#125;,type:&#123;&#125;,value:&#123;&#125;"</span>, hvi.getVariableName(), hvi.getVariableTypeName(), hvi.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里边，首先是查询基本的流程日志信息，这个本质上就是查询历史流程实例信息，对应的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> RES.*, DEF.KEY_ <span class="hljs-keyword">as</span> PROC_DEF_KEY_, DEF.NAME_ <span class="hljs-keyword">as</span> PROC_DEF_NAME_, DEF.VERSION_ <span class="hljs-keyword">as</span> PROC_DEF_VERSION_, DEF.DEPLOYMENT_ID_ <span class="hljs-keyword">as</span> DEPLOYMENT_ID_ <span class="hljs-keyword">from</span> ACT_HI_PROCINST RES <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> ACT_RE_PROCDEF <span class="hljs-keyword">DEF</span> <span class="hljs-keyword">on</span> RES.PROC_DEF_ID_ = DEF.ID_ <span class="hljs-keyword">where</span> PROC_INST_ID_ = ?</span><br></pre></td></tr></table></figure><p>接下来我写了三个 include，每一个 include 都对应一句 SQL：</p><p>includeActivities 对应的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> RES.* <span class="hljs-keyword">from</span> ACT_HI_ACTINST RES <span class="hljs-keyword">WHERE</span> RES.PROC_INST_ID_ = ? <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> RES.ID_ <span class="hljs-keyword">asc</span></span><br></pre></td></tr></table></figure><p>includeTasks 对应的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> RES.* <span class="hljs-keyword">from</span> ACT_HI_TASKINST RES <span class="hljs-keyword">WHERE</span> RES.PROC_INST_ID_ = ? <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> RES.ID_ <span class="hljs-keyword">asc</span></span><br></pre></td></tr></table></figure><p>includeVariables 对应的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> RES.* <span class="hljs-keyword">from</span> ACT_HI_VARINST RES <span class="hljs-keyword">WHERE</span> RES.PROC_INST_ID_ = ? <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> RES.ID_ <span class="hljs-keyword">asc</span></span><br></pre></td></tr></table></figure><p>最终查询完成后，调用 <code>getHistoricData</code> 方法可以查看这些额外的数据，List 集合中存放的 HistoricData 也分为不同的类型：</p><ul><li>includeActivities 方法对应最终查询出来的类型是 HistoricActivityInstance。</li><li>includeTasks 方法对应最终查询出来的类型是 HistoricTaskInstance。</li><li>includeVariables 方法对应最终查询出来的类型是 HistoricVariableInstance。</li></ul><p>在遍历的时候通过类型判断去查看具体是哪一种变量类型。</p><p>综上，这个历史日志查询其实就是一个集大成者。</p><h2 id="6-历史权限查询"><a href="#6-历史权限查询" class="headerlink" title="6. 历史权限查询"></a>6. 历史权限查询</h2><p>这个是用来查询流程或者任务的处理人，例如查询流程的处理人，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test11</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    HistoricProcessInstance pi = historyService.createHistoricProcessInstanceQuery().singleResult();</span><br><span class="line">    List&lt;HistoricIdentityLink&gt; links = historyService.getHistoricIdentityLinksForProcessInstance(pi.getId());</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricIdentityLink link : links) &#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"userId:&#123;&#125;"</span>,link.getUserId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是查询流程对应的处理人，对应的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> ACT_HI_IDENTITYLINK <span class="hljs-keyword">where</span> PROC_INST_ID_ = ?</span><br></pre></td></tr></table></figure><p>如果想查询任务的处理人，对应的方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test12</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    String taskName = <span class="hljs-string">"提交请假申请"</span>;</span><br><span class="line">    HistoricTaskInstance hti = historyService.createHistoricTaskInstanceQuery().taskName(taskName).singleResult();</span><br><span class="line">    List&lt;HistoricIdentityLink&gt; links = historyService.getHistoricIdentityLinksForTask(hti.getId());</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricIdentityLink link : links) &#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"&#123;&#125; 任务的处理人是 &#123;&#125;"</span>,taskName,link.getUserId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询对应的 SQL 如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> ACT_HI_IDENTITYLINK <span class="hljs-keyword">where</span> TASK_ID_ = ?</span><br></pre></td></tr></table></figure><p>和前面的相比，其实就多了一个查询条件 <code>TASK_ID_</code>。</p><h2 id="7-自定义查询-SQL"><a href="#7-自定义查询-SQL" class="headerlink" title="7. 自定义查询 SQL"></a>7. 自定义查询 SQL</h2><p>和前面讲的很多查询类似，当我们弄懂了每一个历史查询的 API 操作的是哪一个数据表，就会发现，历史数据的查询，也可以自定义 SQL。</p><p>举个例子和小伙伴们看下，例如查询某一个流程已经执行完毕的历史任务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test13</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;HistoricProcessInstance&gt; instanceList = historyService.createHistoricProcessInstanceQuery().list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricProcessInstance hpi : instanceList) &#123;</span><br><span class="line">        List&lt;HistoricTaskInstance&gt; list = historyService.createNativeHistoricTaskInstanceQuery()</span><br><span class="line">                .sql(<span class="hljs-string">"SELECT RES.* from ACT_HI_TASKINST RES WHERE RES.PROC_INST_ID_ = #&#123;pid&#125; and RES.END_TIME_ is not null order by RES.ID_ asc"</span>)</span><br><span class="line">                .parameter(<span class="hljs-string">"pid"</span>,hpi.getId()).list();</span><br><span class="line">        <span class="hljs-keyword">for</span> (HistoricTaskInstance hti : list) &#123;</span><br><span class="line">            logger.info(<span class="hljs-string">"name:&#123;&#125;,assignee:&#123;&#125;,createTime:&#123;&#125;,endTime:&#123;&#125;"</span>, hti.getName(), hti.getAssignee(), hti.getCreateTime(), hti.getEndTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flowable 底层是 MyBatis，所有 SQL 中参数的传递形式和 MyBatis 一致。</p><h2 id="8-历史数据记录级别"><a href="#8-历史数据记录级别" class="headerlink" title="8. 历史数据记录级别"></a>8. 历史数据记录级别</h2><p>Flowable 需要记录哪些历史数据，有一个日志级别用来描述这个事情，默认有四种级别：</p><ul><li>None: 这个表示不存储任何历史信息，好处是流程执行的时候效率会比较快，坏处是流程执行结束后，看不到曾经执行过的流程信息了。</li><li>Activity: 这个会存储所有流程实例和活动实例，在流程实例结束时，顶级流程实例变量的最新值将复制到历史变量实例中，不会存储详细信息。</li><li>Audit: 在 Activity 的基础上，还会存储历史详细信息，包括权限信息等。默认的日志记录级别即次。</li><li>Full: 这个是在 Audit 的基础上，还会存储变量的变化信息，这会记录大量的数据，也会导致流程执行变慢。</li></ul><p>一共就这四种级别，在 Spring Boot 项目中，如果我们想要配置这个日志记录的级别，其实非常方便，直接在 application.properties 中进行配置即可，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flowable.history-level=none</span><br></pre></td></tr></table></figure><p>配置加了这个配置，我们随便启动一个流程，然后去查询 <code>ACT_HI_</code> 系列的表，发现都是空的，没有数据。</p><p>如果我们将历史日志记录的级别改为 activity，那么就会记录下来流程信息以及活动信息，但是像执行的 Task 这些信息都是没有的（<code>ACT_HI_TASKINST</code>），包括流程参与者的信息（<code>ACT_HI_IDENTITYLINK</code>）等都不会记录下来。</p><p>如果我们将历史日志记录的级别改为 audit，则上面提到的这几种日志就都会记录下来。但是 <code>ACT_HI_DETAIL</code> 表还是空的，详细一个流程变量的变化过程不会被记录下来。</p><p>如果我们将日志记录级别改为 full，那么将会记录下更多的信息。<code>ACT_HI_DETAIL</code> 表中会记录下流程变量的详细信息。</p><p>整个过程我就不给小伙伴们演示了大家可以自行尝试。</p><p>好啦，关于历史数据的查询，松哥先和小伙伴们聊这么多～下篇文章我们继续～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在之前的文章中松哥和小伙伴们聊过，正在执行的流程信息是保存在以 &lt;code&gt;ACT_RU_&lt;/code&gt; 为前缀的表中，执行完毕的流程信息则保存在以 &lt;code&gt;ACT_HI_&lt;/code&gt; 为前缀的表中，也就是流程历史信息表，当然这个历史信息表继续细分的话，还有好多种，今天我们就来聊一聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>Flowable 设置流程变量的四种方式</title>
    <link href="http://www.javaboy.org/2022/1027/tienchin-flowable-process-variable.html"/>
    <id>http://www.javaboy.org/2022/1027/tienchin-flowable-process-variable.html</id>
    <published>2022-10-27T10:20:45.000Z</published>
    <updated>2022-12-20T11:06:45.441Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在之前的文章中，松哥也有和小伙伴们使用过流程变量，然而没有和大家系统的梳理过流程变量的具体玩法以及它对应的数据表详情，今天我们就来看看 Flowable 中流程变量的详细玩法。</p><a id="more"></a><h2 id="1-为什么需要流程变量"><a href="#1-为什么需要流程变量" class="headerlink" title="1. 为什么需要流程变量"></a>1. 为什么需要流程变量</h2><p>首先我们来看看为什么需要流程变量。</p><p>举一个简单的例子，假设我们有如下一个流程：</p><p><img src="http://img.itboyhub.com/2022/08/20221015111609.png" alt></p><p>这是一个请假流程，那么谁请假、请几天、起始时间、请假理由等等，这些都需要说明，不然领导审批的依据是啥？那么如何传递这些数据，我们就需要流程变量。</p><h2 id="2-流程变量的分类"><a href="#2-流程变量的分类" class="headerlink" title="2. 流程变量的分类"></a>2. 流程变量的分类</h2><p>整体上来说，目前流程变量可以分为三种类型：</p><ol><li>全局流程变量：在整个流程执行期间，这个流程变量都是有效的。</li><li>本地流程变量：这个只针对流程中某一个具体的 Task（任务）有效，这个任务执行完毕后，这个流程变量就失效了。</li><li>临时流程变量：顾名思义就是临时的，这个不会存入到数据库中。</li></ol><p>在接下来的内容中，我会跟大家挨个介绍这些流程变量的用法。</p><h2 id="3-全局流程变量"><a href="#3-全局流程变量" class="headerlink" title="3. 全局流程变量"></a>3. 全局流程变量</h2><p>假设我们就是上面这个请假流程，我们一起来看下流程变量的设置和获取。</p><h3 id="3-1-启动时设置"><a href="#3-1-启动时设置" class="headerlink" title="3.1 启动时设置"></a>3.1 启动时设置</h3><p>第一种方式，就是我们可以在流程启动的时候，设置流程变量，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    variables.put(<span class="hljs-string">"days"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    variables.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"休息一下"</span>);</span><br><span class="line">    variables.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-keyword">new</span> Date());</span><br><span class="line">    ProcessInstance pi = runtimeService.startProcessInstanceByKey(<span class="hljs-string">"demo01"</span>, variables);</span><br><span class="line">    logger.info(<span class="hljs-string">"id:&#123;&#125;,activityId:&#123;&#125;"</span>, pi.getId(), pi.getActivityId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在启动的时候为流程设置变量，小伙伴们注意到，流程变量的 value 也可以是一个对象（不过这个对象要能够序列化，即实现了 Serializable 接口），然后在启动的时候传入这个变量即可。</p><p>我们在流程启动日志中搜索 <code>休息一下</code> 四个字，可以找到和流程变量相关的 SQL，一共有两条，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> ACT_HI_VARINST (ID_, PROC_INST_ID_, EXECUTION_ID_, TASK_ID_, NAME_, REV_, VAR_TYPE_, SCOPE_ID_, SUB_SCOPE_ID_, SCOPE_TYPE_, BYTEARRAY_ID_, DOUBLE_, LONG_ , TEXT_, TEXT2_, CREATE_TIME_, LAST_UPDATED_TIME_) <span class="hljs-keyword">values</span> ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> ACT_RU_VARIABLE (ID_, REV_, TYPE_, NAME_, PROC_INST_ID_, EXECUTION_ID_, TASK_ID_, SCOPE_ID_, SUB_SCOPE_ID_, SCOPE_TYPE_, BYTEARRAY_ID_, DOUBLE_, LONG_ , TEXT_, TEXT2_) <span class="hljs-keyword">VALUES</span> ( ?, <span class="hljs-number">1</span>, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, <span class="hljs-number">1</span>, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) , ( ?, <span class="hljs-number">1</span>, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )</span><br></pre></td></tr></table></figure><p>从标名称上大概就能看出来，<code>ACT_HI_VARINST</code> 是存储流程执行的历史信息的，<code>ACT_RU_VARIABLE</code> 则是保存流程运行时候的信息的。</p><p>我们打开 <code>ACT_RU_VARIABLE</code> 表来看一下：</p><p><img src="http://img.itboyhub.com/2022/08/20221015122213.png" alt></p><p>从表中我们可以看到，每一个流程变量都有对应的流程实例 ID，这就说明这些流程变量是属于某一个流程实例的，所以我们可以按照如下方式来查询流程变量：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Execution&gt; list = runtimeService.createExecutionQuery().list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Execution execution : list) &#123;</span><br><span class="line">        Object reason = runtimeService.getVariable(execution.getId(), <span class="hljs-string">"reason"</span>);</span><br><span class="line">        logger.info(<span class="hljs-string">"reason:&#123;&#125;"</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的查询 SQL 如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">: ==&gt;  Preparing: select * from ACT_RU_VARIABLE WHERE EXECUTION_ID_ = ? AND TASK_ID_ is null AND NAME_ = ?</span><br><span class="line">: ==&gt; Parameters: 6fdd2007-4c3a-11ed-aa7e-acde48001122(String), reason(String)</span><br><span class="line">: &lt;==      Total: 1</span><br></pre></td></tr></table></figure><p>可以看到，这个就是去 <code>ACT_RU_VARIABLE</code> 表中进行查询，查询条件中包含了变量的名称。</p><p>当然，我们也可以直接查询某一个流程的所有变量，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Execution&gt; list = runtimeService.createExecutionQuery().list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Execution execution : list) &#123;</span><br><span class="line">        Map&lt;String,Object&gt; variables = runtimeService.getVariables(execution.getId());</span><br><span class="line">        logger.info(<span class="hljs-string">"variables:&#123;&#125;"</span>, variables);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对应的查询 SQL 如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">: ==&gt;  Preparing: select * from ACT_RU_VARIABLE WHERE EXECUTION_ID_ = ? AND TASK_ID_ is null</span><br><span class="line">: ==&gt; Parameters: 6fdd2007-4c3a-11ed-aa7e-acde48001122(String)</span><br><span class="line">: &lt;==      Total: 3</span><br></pre></td></tr></table></figure><p>可以看到，这个跟上面的那个差不多，只不过少了 <code>NAME_</code> 这个条件。</p><h3 id="3-2-通过-Task-设置"><a href="#3-2-通过-Task-设置" class="headerlink" title="3.2 通过 Task 设置"></a>3.2 通过 Task 设置</h3><p>我们也可以在流程启动成功之后，再去设置流程变量，步骤如下：</p><p>首先启动一个流程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ProcessInstance pi = runtimeService.startProcessInstanceByKey(<span class="hljs-string">"demo01"</span>);</span><br><span class="line">    logger.info(<span class="hljs-string">"id:&#123;&#125;,activityId:&#123;&#125;"</span>, pi.getId(), pi.getActivityId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置流程变量：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    taskService.setVariable(task.getId(), <span class="hljs-string">"days"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    variables.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"休息一下"</span>);</span><br><span class="line">    variables.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-keyword">new</span> Date());</span><br><span class="line">    taskService.setVariables(task.getId(),variables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询到某一个 Task，然后设置流程变量，上面这段代码和小伙伴们演示了两种设置方式：</p><ul><li>逐个设置</li><li>直接设置一个 Map</li></ul><p>上面这个设置流程变量的方式，本质上还是往 <code>ACT_HI_VARINST</code> 和 <code>ACT_RU_VARIABLE</code> 表中插入数据。具体的 SQL 也和前面的一样，我就不贴出来了。</p><h3 id="3-3-完成任务时设置"><a href="#3-3-完成任务时设置" class="headerlink" title="3.3 完成任务时设置"></a>3.3 完成任务时设置</h3><p>也可以在完成一个任务的时候设置流程变量，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    variables.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"休息一下"</span>);</span><br><span class="line">    variables.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-keyword">new</span> Date());</span><br><span class="line">    variables.put(<span class="hljs-string">"days"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    taskService.complete(task.getId(),variables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层涉及到的 SQL 都跟前面一样，我就不赘述了。</p><h3 id="3-4-通过流程设置"><a href="#3-4-通过流程设置" class="headerlink" title="3.4 通过流程设置"></a>3.4 通过流程设置</h3><p>由于是全局流程变量，所以我们也可以通过 <code>RuntimeService</code> 来进行设置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Execution execution = runtimeService.createExecutionQuery().singleResult();</span><br><span class="line">    runtimeService.setVariable(execution.getId(), <span class="hljs-string">"days"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    variables.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"休息一下"</span>);</span><br><span class="line">    variables.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-keyword">new</span> Date());</span><br><span class="line">    runtimeService.setVariables(execution.getId(), variables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，一共就是这四种方式。</p><h2 id="4-本地流程变量"><a href="#4-本地流程变量" class="headerlink" title="4. 本地流程变量"></a>4. 本地流程变量</h2><p>第三小节我们说的全局流程变量是和某一个具体的流程绑定的，而本地流程变量则不同，本地流程变量和某一个 Task 绑定。</p><h3 id="4-1-通过-Task-设置"><a href="#4-1-通过-Task-设置" class="headerlink" title="4.1 通过 Task 设置"></a>4.1 通过 Task 设置</h3><p>假设我们启动流程之后，通过 Task 来设置一个本地流程变量，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    taskService.setVariableLocal(task.getId(), <span class="hljs-string">"days"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    variables.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"休息一下"</span>);</span><br><span class="line">    variables.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-keyword">new</span> Date());</span><br><span class="line">    taskService.setVariables(task.getId(),variables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码中，我设置了一个本地变量，两个全局变量，设置完成后，我们去 <code>ACT_RU_VARIABLE</code> 表中来查看一下具体的效果。</p><p><img src="http://img.itboyhub.com/2022/08/20221015135228.png" alt></p><p>大家看到，由于 days 是本地变量，所以它的 TASK_ID_ 有值，这个好理解，说明 days 这个变量和这个具体的 Task 是有关的。</p><p>此时如果我们完成这个 Task，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成之后，再来查看 <code>ACT_RU_VARIABLE</code> 表，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221015135606.png" alt></p><p>我们发现本地变量 days 已经没有了。因为上一个 Task 都已经执行完毕了，这个时候如果还是按照第三小节介绍的方式去查询变量，就查不到 days 了。此时如果需要查询到曾经的 days 变量，得去历史表中查询了，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ProcessInstance pi = runtimeService.createProcessInstanceQuery().singleResult();</span><br><span class="line">    List&lt;HistoricVariableInstance&gt; list = historyService.createHistoricVariableInstanceQuery().processInstanceId(pi.getId()).list();</span><br><span class="line">    <span class="hljs-keyword">for</span> (HistoricVariableInstance hvi : list) &#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"name:&#123;&#125;,type:&#123;&#125;,value:&#123;&#125;"</span>, hvi.getVariableName(), hvi.getVariableTypeName(), hvi.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是流程本地变量的特点，当然相关的方法还有好几个，这里列出来给小伙伴们参考：</p><ul><li>org.flowable.engine.TaskService#complete(java.lang.String, java.util.Map&lt;java.lang.String,java.lang.Object&gt;, boolean)：在完成一个 Task 的时候，如果传递了变量，则可以通过第三个参数来控制这个变量是全局的还是本地的，true 表示这个变量是本地的。</li><li>org.flowable.engine.RuntimeService#setVariableLocal：为某一个执行实例设置本地变量。</li><li>org.flowable.engine.RuntimeService#setVariablesLocal：同上，批量设置。</li></ul><p>好啦，这就是本地流程变量。</p><h2 id="5-临时流程变量"><a href="#5-临时流程变量" class="headerlink" title="5. 临时流程变量"></a>5. 临时流程变量</h2><p>临时流程变量是不存数据库的，一般来说我们可以在启动流程或者完成任务的时候使用，用法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test21</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    variables.put(<span class="hljs-string">"reason"</span>, <span class="hljs-string">"休息一下"</span>);</span><br><span class="line">    variables.put(<span class="hljs-string">"startTime"</span>, <span class="hljs-keyword">new</span> Date());</span><br><span class="line">    ProcessInstance pi = runtimeService</span><br><span class="line">            .createProcessInstanceBuilder()</span><br><span class="line">            .transientVariable(<span class="hljs-string">"days"</span>, <span class="hljs-number">10</span>)</span><br><span class="line">            .transientVariables(variables)</span><br><span class="line">            .processDefinitionKey(<span class="hljs-string">"demo01"</span>)</span><br><span class="line">            .start();</span><br><span class="line">    logger.info(<span class="hljs-string">"id:&#123;&#125;,activityId:&#123;&#125;"</span>, pi.getId(), pi.getActivityId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码涉及到的流程变量就是临时流程变量，它是不会存入到数据库中的。</p><p>也可以在完成一个任务的时候设置临时变量，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test22</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Task task = taskService.createTaskQuery().singleResult();</span><br><span class="line">    Map&lt;String, Object&gt; transientVariables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    transientVariables.put(<span class="hljs-string">"days"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    taskService.complete(task.getId(), <span class="hljs-keyword">null</span>, transientVariables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个临时变量也是不会存入到数据库中的。</p><p>好啦，关于流程变量，今天就和小伙伴们先说这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在之前的文章中，松哥也有和小伙伴们使用过流程变量，然而没有和大家系统的梳理过流程变量的具体玩法以及它对应的数据表详情，今天我们就来看看 Flowable 中流程变量的详细玩法。&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
  <entry>
    <title>体验一把 Flowable 三种常见网关</title>
    <link href="http://www.javaboy.org/2022/1025/tienchin-flowable-gateway.html"/>
    <id>http://www.javaboy.org/2022/1025/tienchin-flowable-gateway.html</id>
    <published>2022-10-25T10:20:31.000Z</published>
    <updated>2022-12-20T11:06:41.214Z</updated>
    
    <content type="html"><![CDATA[<p>Flowable 中网关类型其实也不少，常见的主要有三种类型，分别是：</p><a id="more"></a><ol><li>排他网关</li><li>并行网关</li><li>包容网关</li></ol><p>这三个里边最常用的当然就是排他网关了，今天松哥就来和小伙伴们聊一聊这三种网关，一起来体验一把这三种网关各自的特征。</p><h2 id="1-排他网关"><a href="#1-排他网关" class="headerlink" title="1. 排他网关"></a>1. 排他网关</h2><p>首先就是排他网关了，这个也叫互斥网关，长得像下图这样：</p><p><img src="http://img.itboyhub.com/2022/08/20220825123232.png" alt></p><p>排他网关可以有 N 个入口，但是只有一个有效出口。</p><p>松哥举一个例子：</p><p>假设我有一个请假流程，请假 1 天，组长审批，请假小于 3 天，项目经理审批，请假大于 3 天，总监审批，据此，我们可以绘制如下流程图：</p><p><img src="http://img.itboyhub.com/2022/08/20221012201551.png" alt></p><p>在这个流程图中，当流程从排他网关出来的时候，我们设置一个变量，根据变量的值，来决定下一个走哪一个 Task，例如组长审批，我们做如下配置：</p><p><img src="http://img.itboyhub.com/2022/08/20221012202253.png" alt></p><p>这个流条件表示当 days 这个变量的值小于等于 1 的时候，就会进入到组长审批这个 Task。</p><p>按照类似的方式，我们来设置经理审批：</p><p><img src="http://img.itboyhub.com/2022/08/20221012202448.png" alt></p><p>最后，总监审批的条件如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221012202526.png" alt></p><p>最终，我们来看下这个流程对应的 XML 文件，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">process</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo01"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"测试流程"</span> <span class="hljs-attr">isExecutable</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">documentation</span>&gt;</span>测试流程<span class="hljs-tag">&lt;/<span class="hljs-name">documentation</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">startEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"startEvent1"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">startEvent</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">exclusiveGateway</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-C4E389D6-C507-4B8E-8469-2288AA5B44A5"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusiveGateway</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-DF97CC8B-3AD5-447D-AE67-1082CAB7B189"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"startEvent1"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-C4E389D6-C507-4B8E-8469-2288AA5B44A5"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-B4CD08AF-52B5-44F2-AC45-B2F5E154A5F0"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"组长审批"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-07B7951C-4E76-4639-989C-407C610C5BA8"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"经理审批"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-1A81B40F-D8D4-4158-B0B9-26DB8FB7DD2E"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"总监审批"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">endEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-0F56FE56-1A8C-4B47-8F0D-196700DDF7B8"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">endEvent</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-E4B4B580-F078-4BB9-B5D3-966E80737C4C"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-B4CD08AF-52B5-44F2-AC45-B2F5E154A5F0"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-0F56FE56-1A8C-4B47-8F0D-196700DDF7B8"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">endEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-F05670CB-A8F4-44A3-B53D-46CFB6F65581"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">endEvent</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-3EC62E5D-ACDA-480E-93B4-C24D8F6E9042"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-07B7951C-4E76-4639-989C-407C610C5BA8"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-F05670CB-A8F4-44A3-B53D-46CFB6F65581"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">endEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-52711414-1769-4EC3-9AE5-6BA426123095"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">endEvent</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-C81500B2-D1EA-429F-8402-A3D8C8CA0E29"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-1A81B40F-D8D4-4158-B0B9-26DB8FB7DD2E"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-52711414-1769-4EC3-9AE5-6BA426123095"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-807C7B79-4AFA-4525-847F-4D0FE1C0F0F3"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"小于1天"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-C4E389D6-C507-4B8E-8469-2288AA5B44A5"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-B4CD08AF-52B5-44F2-AC45-B2F5E154A5F0"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">conditionExpression</span> <span class="hljs-attr">xsi:type</span>=<span class="hljs-string">"tFormalExpression"</span>&gt;</span>&lt;![CDATA[$&#123;days&lt;=1&#125;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">conditionExpression</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-3D3DF742-BF47-4536-9EE9-747CD284A1BA"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"1-3天"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-C4E389D6-C507-4B8E-8469-2288AA5B44A5"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-07B7951C-4E76-4639-989C-407C610C5BA8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">conditionExpression</span> <span class="hljs-attr">xsi:type</span>=<span class="hljs-string">"tFormalExpression"</span>&gt;</span>&lt;![CDATA[$&#123;days&gt;1 &amp;&amp; days&lt;=3&#125;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">conditionExpression</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-2AD41E43-AFEC-47A1-B8D1-0B4299434BF8"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"大于3天"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-C4E389D6-C507-4B8E-8469-2288AA5B44A5"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-1A81B40F-D8D4-4158-B0B9-26DB8FB7DD2E"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">conditionExpression</span> <span class="hljs-attr">xsi:type</span>=<span class="hljs-string">"tFormalExpression"</span>&gt;</span>&lt;![CDATA[$&#123;days&gt;3&#125;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">conditionExpression</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">process</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，在 sequenceFlow 标签中，有一个 conditionExpression 标签，这个标签的内容就是具体的条件了。</p><p>现在，我们部署一下这个流程，然后按照如下方式来启动：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    variables.put(<span class="hljs-string">"days"</span>, <span class="hljs-number">3</span>);</span><br><span class="line">    ProcessInstance pi = runtimeService.startProcessInstanceByKey(<span class="hljs-string">"demo01"</span>, variables);</span><br><span class="line">    logger.info(<span class="hljs-string">"id:&#123;&#125;,activityId:&#123;&#125;"</span>, pi.getId(), pi.getActivityId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个启动的时候，传入一个 days 变量，系统将来会根据这个变量来决定这个流程要走到哪一个 Task。流程启动成功之后，我们去观察 <code>ACT_RU_TASK</code> 表，就可以看到流程的执行是否和我们所预想的一致。</p><h2 id="2-并行网关"><a href="#2-并行网关" class="headerlink" title="2. 并行网关"></a>2. 并行网关</h2><p>并行网关，从名字上大概也能看出来，这种网关一般用在并行任务上，并行网关如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20220825123325.png" alt></p><p>并行网关一般是成对出现的，一个出现的并行网关用来分流，第二个出现的并行网关用来聚合。</p><p>我画一个简单的并行网关的例子，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221012204245.png" alt></p><p>小伙伴们看到，这是一个简化的生产笔记本的流程图，当屏幕和键盘都生产好之后，再进行组装，整个流程图中存在两个并行网关（成对出现）。</p><p>在这个流程图中，连接线上是不需要设置条件的（不同于拍他网关），这里即使你设置了条件，这个条件也是不会生效的。</p><p>我们来看下这个并行网关流程图对应的 XML 文件，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">process</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"demo01"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"测试流程"</span> <span class="hljs-attr">isExecutable</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">documentation</span>&gt;</span>测试流程<span class="hljs-tag">&lt;/<span class="hljs-name">documentation</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">startEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-4F7F76BA-526A-4D8C-B45A-02FC1C56CA47"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">startEvent</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-11130848-EA1F-458A-A45D-49CBC49428C8"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-4F7F76BA-526A-4D8C-B45A-02FC1C56CA47"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-6D01D4BE-C475-4270-8745-92752EA2C038"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">parallelGateway</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-6D01D4BE-C475-4270-8745-92752EA2C038"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parallelGateway</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-54DD6BFA-FE6C-4DE7-9038-3DEEAF85002C"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"生产屏幕"</span> <span class="hljs-attr">flowable:assignee</span>=<span class="hljs-string">"zhangsan"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">modeler:initiator-can-complete</span> <span class="hljs-attr">xmlns:modeler</span>=<span class="hljs-string">"http://flowable.org/modeler"</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-8DD3383C-45D1-4EAF-9A22-702A5B9D0869"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-6D01D4BE-C475-4270-8745-92752EA2C038"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-54DD6BFA-FE6C-4DE7-9038-3DEEAF85002C"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-7797ED55-155F-4D17-8EA5-DE40434C421B"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"生产键盘"</span> <span class="hljs-attr">flowable:assignee</span>=<span class="hljs-string">"lisi"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">modeler:initiator-can-complete</span> <span class="hljs-attr">xmlns:modeler</span>=<span class="hljs-string">"http://flowable.org/modeler"</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-6E992E8B-CF71-411D-B537-42FEDF4F4209"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-6D01D4BE-C475-4270-8745-92752EA2C038"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-7797ED55-155F-4D17-8EA5-DE40434C421B"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-8DCA9516-FFED-4781-9ACC-530DC6E63755"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-7797ED55-155F-4D17-8EA5-DE40434C421B"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-98D3C336-9AD9-4964-9CCB-496C850EE40F"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-EE80AE42-D021-4B9F-A91E-BD37C512EE65"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-54DD6BFA-FE6C-4DE7-9038-3DEEAF85002C"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-98D3C336-9AD9-4964-9CCB-496C850EE40F"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-4FFE361A-E2AF-4481-BACF-1E618E8C4A26"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"组装"</span> <span class="hljs-attr">flowable:assignee</span>=<span class="hljs-string">"javaboy"</span> <span class="hljs-attr">flowable:formFieldValidation</span>=<span class="hljs-string">"true"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">modeler:initiator-can-complete</span> <span class="hljs-attr">xmlns:modeler</span>=<span class="hljs-string">"http://flowable.org/modeler"</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">extensionElements</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-8CABC6E8-E36A-4814-B897-817D4A9F231C"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-98D3C336-9AD9-4964-9CCB-496C850EE40F"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-4FFE361A-E2AF-4481-BACF-1E618E8C4A26"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">endEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-BF02170B-8138-4867-AE01-E3B29505183D"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">endEvent</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-F72B2A15-913F-436E-8AD7-6A6FB190E197"</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">"sid-4FFE361A-E2AF-4481-BACF-1E618E8C4A26"</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">"sid-BF02170B-8138-4867-AE01-E3B29505183D"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">parallelGateway</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sid-98D3C336-9AD9-4964-9CCB-496C850EE40F"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parallelGateway</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">process</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在我们把这个流程部署并启动。</p><p>流程启动成功之后，我们发现在 <code>ACT_RU_TASK</code> 表中有两个需要执行的 Task，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20221012210051.png" alt></p><p>这两个 Task，如果只执行掉其中一个，那么还剩下另外一个 Task，如果两个都执行了，那么你就会看到一个新的 Task，如下图（两个并行任务执行完成后，进入到下一个任务）：</p><p><img src="http://img.itboyhub.com/2022/08/20221012210253.png" alt></p><p>好啦，这就是并行网关。</p><h2 id="3-包容网关"><a href="#3-包容网关" class="headerlink" title="3. 包容网关"></a>3. 包容网关</h2><p>包容网关，有时候也叫相容网关、兼容网关等，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20220825123255.png" alt></p><p>包容谁呢？包容排他网关和并行网关。也就是说，这种包容网关可以根据实际条件转为排他网关或者并行网关。</p><p>举个栗子：</p><p>假如说报销金额大于 500，zhangsan 审批，报销金额大于 1000，则需要 zhangsan 和 lisi 同时审批，且 zhangsan 和 lisi 审批无先后顺序。</p><p>据此，我绘制如下流程图：</p><p><img src="http://img.itboyhub.com/2022/08/20221012214402.png" alt></p><p>在报销金额大于 500 上设置如下条件：</p><p><img src="http://img.itboyhub.com/2022/08/20221012214521.png" alt></p><p>大于 1000 上设置如下条件：</p><p><img src="http://img.itboyhub.com/2022/08/20221012214552.png" alt></p><p>接下来我们来部署好这个流程。</p><p>部署好之后，我们首先来启动流程，第一次启动的时候，我们设置报销金额为 666，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    variables.put(<span class="hljs-string">"money"</span>, <span class="hljs-number">666</span>);</span><br><span class="line">    ProcessInstance pi = runtimeService.startProcessInstanceByKey(<span class="hljs-string">"demo01"</span>, variables);</span><br><span class="line">    logger.info(<span class="hljs-string">"id:&#123;&#125;,activityId:&#123;&#125;"</span>, pi.getId(), pi.getActivityId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程启动之后，我们在 <code>ACT_RU_TASK</code> 表中可以看到，该 zhangsan 审批了，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20221012212647.png" alt></p><p>zhangsan 审批之后，就是 wangwu 审批了，我就不演示了。</p><p>假设我们启动流程的时候，报销金额为 2000，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    variables.put(<span class="hljs-string">"money"</span>, <span class="hljs-number">2000</span>);</span><br><span class="line">    ProcessInstance pi = runtimeService.startProcessInstanceByKey(<span class="hljs-string">"demo01"</span>, variables);</span><br><span class="line">    logger.info(<span class="hljs-string">"id:&#123;&#125;,activityId:&#123;&#125;"</span>, pi.getId(), pi.getActivityId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时你就会看到，在 <code>ACT_RU_TASK</code> 表中，出现了两条记录，分别是 zhangsan 审批和 lisi 审批，<strong>此时这两个审批就是一个并行任务了</strong>:</p><p><img src="http://img.itboyhub.com/2022/08/20221012215045.png" alt></p><p>接下来就按并行任务的模式来，这两个人都审批了，才会进入到 wangwu 审批。</p><p>这就是兼容网关的特点，即根据实际情况，会变成排他网关或者并行网关。</p><p>好啦，三种常见的网关就和小伙伴们分享完啦，感兴趣的小伙伴赶紧试一试吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flowable 中网关类型其实也不少，常见的主要有三种类型，分别是：&lt;/p&gt;
    
    </summary>
    
      <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
      <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
      <category term="Flowable" scheme="http://www.javaboy.org/tags/Flowable/"/>
    
  </entry>
  
</feed>
