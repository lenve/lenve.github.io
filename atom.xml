<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2021-05-25T10:07:32.857Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebFlux 前置知识（二）</title>
    <link href="http://www.javaboy.org/2021/0525/method-reference.html"/>
    <id>http://www.javaboy.org/2021/0525/method-reference.html</id>
    <published>2021-05-25T10:04:30.000Z</published>
    <updated>2021-05-25T10:07:32.857Z</updated>
    
    <content type="html"><![CDATA[<p>先来说说上周送书的事。小伙伴们太热情了，留言有 300 多条，但是受微信限制，只能精选100条，所以还有很多小伙伴的留言没有精选，但是松哥都认真看了，还请小伙伴们理解。每次留言送书都会选择困难，不知道书送给谁，每个人我都想送，但是只有六本。。。不停的纠结，每次选幸运小伙伴都要花费一小时以上，下次送书还是考虑抽奖吧，省事哈哈。</p><a id="more"></a><p>上篇文章和小伙伴们聊了 Lambda 表达式和函数接口，今天我们一起来看下 方法引用、变量引用、类型推断以及级联表达式四个点，也算是 WebFlux 的一个前置知识点。</p><p>废话不多说，开整。</p><h2 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1 方法引用"></a>1 方法引用</h2><p>到今天，方法引用估计很多小伙伴可能多多少少都见过，即使自己没写过，可能也看别人写过。用过的小伙伴可能会感觉这个用着真爽，cool！没用过的小伙伴可能就要吐槽这什么鬼代码。</p><p>不管怎么样，我们今天还是来看看方法引用，也算是我们学习 WebFlux 的一个前置知识。</p><h3 id="1-1-什么是方法引用"><a href="#1-1-什么是方法引用" class="headerlink" title="1.1 什么是方法引用"></a>1.1 什么是方法引用</h3><p>什么是方法引用？</p><p>简单说，方法引用就是一个 Lambda 表达式，操作符就是 <code>::</code>，有的小伙伴们可能会觉得所谓的 Lambda 就是 <code>-&gt;</code> 代替匿名内部类，其实不然！Lambda 中包含的东西还是蛮多的，方法引用就算是其中之一。</p><p>有的时候，我们使用 Lambda，需要自己写方法的实现，但是有的时候，我们可能不需要自己写方法的实现，就是单纯的调用一下方法，这种时候，通过方法名称来调用，会更加清晰，可读性更高，也更加简洁易懂。</p><p>方法引用不仅可以用来访问类或者实例中已经存在的方法，也可以用来访问构造方法。</p><h3 id="2-2-四种方法引用"><a href="#2-2-四种方法引用" class="headerlink" title="2.2 四种方法引用"></a>2.2 四种方法引用</h3><h4 id="2-2-1-静态方法引用"><a href="#2-2-1-静态方法引用" class="headerlink" title="2.2.1 静态方法引用"></a>2.2.1 静态方法引用</h4><p>例如我定义一个 Lambda，该 Lambda 中有一个方法可以完成对数字格式的转换，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo05</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;Integer, String&gt; func = a -&gt; String.valueOf(a);</span><br><span class="line">        String s = func.apply(<span class="hljs-number">99</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"s = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的这个 Function 中，我们将一个 Integer 类型数字转为了一个字符串，由于在 Lambda 中并没有其他代码，就是一个简单的类型转换，因为我们可以将之简写成如下方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo05</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;Integer, String&gt; func = String::valueOf;</span><br><span class="line">        String s = func.apply(<span class="hljs-number">99</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"s = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，比如我们有一个 Consumer，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span><br><span class="line">consumer.accept(<span class="hljs-string">"javaboy"</span>);</span><br></pre></td></tr></table></figure><p>Consumer 消费一个字符串，消费的方式就是控制台打印，这种时候我们可以简写成如下方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">consumer.accept(<span class="hljs-string">"javaboy"</span>);</span><br></pre></td></tr></table></figure><p>这就是静态方法引用。</p><p>再举个例子，用 Lambda 写一个给参数求次幂的函数，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;Integer, Integer, Double&gt; func = (a, b) -&gt; Math.pow(a, b);</span><br><span class="line">Double result = func.apply(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"result = "</span> + result);</span><br></pre></td></tr></table></figure><p>传入两个参数类型都是 Integer，返回的数据类型是 Double，调用 Math.pow 计算次幂。</p><p>上面这段代码我们也可以通过静态方法引用简化：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;Integer, Integer, Double&gt; func = Math::pow;</span><br><span class="line">Double result = func.apply(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"result = "</span> + result);</span><br></pre></td></tr></table></figure><h4 id="2-2-2-实例方法引用"><a href="#2-2-2-实例方法引用" class="headerlink" title="2.2.2 实例方法引用"></a>2.2.2 实例方法引用</h4><p>方法引用也可以用在实例方法上。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">IntUnaryOperator func = i -&gt; random.nextInt(i);</span><br><span class="line">Integer r = func.applyAsInt(<span class="hljs-number">10</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"r = "</span> + r);</span><br></pre></td></tr></table></figure><p>这段代码也可以使用方法引用，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">IntUnaryOperator func = random::nextInt;</span><br><span class="line">Integer r = func.applyAsInt(<span class="hljs-number">10</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"r = "</span> + r);</span><br></pre></td></tr></table></figure><p>就是把类换成实例而已，其他都是一样的。</p><p>不过需要注意的是，字符串的实例稍微特殊一些，如下一个字符串排序方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123;<span class="hljs-string">"Barbara"</span>, <span class="hljs-string">"Mary"</span>, <span class="hljs-string">"James"</span>&#125;;</span><br><span class="line">Arrays.sort(stringArray,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">System.out.println(Arrays.toString(stringArray));</span><br></pre></td></tr></table></figure><p>如果使用方法引用，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123;<span class="hljs-string">"Barbara"</span>, <span class="hljs-string">"Mary"</span>, <span class="hljs-string">"James"</span>&#125;;</span><br><span class="line">Arrays.sort(stringArray, String::compareToIgnoreCase);</span><br><span class="line">System.out.println(Arrays.toString(stringArray));</span><br></pre></td></tr></table></figure><p>这个感觉有点像静态方法引用，其实不是的，Lambda 的第一个参数会成为调用实例方法的对象。</p><p>在实例方法引用中，如果需要指定泛型，泛型放在 <code>::</code> 后面。</p><h4 id="2-2-3-构造方法引用"><a href="#2-2-3-构造方法引用" class="headerlink" title="2.2.3 构造方法引用"></a>2.2.3 构造方法引用</h4><p>例如如下方法提供一个 Cat 实例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Cat&gt; supplier = () -&gt; <span class="hljs-keyword">new</span> Cat();</span><br><span class="line">Cat cat = supplier.get();</span><br></pre></td></tr></table></figure><p>通过方法引用，可以简写成如下形式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Cat&gt; supplier = Cat::<span class="hljs-keyword">new</span>;</span><br><span class="line">Cat cat = supplier.get();</span><br></pre></td></tr></table></figure><h4 id="2-2-4-数组构造方法引用"><a href="#2-2-4-数组构造方法引用" class="headerlink" title="2.2.4 数组构造方法引用"></a>2.2.4 数组构造方法引用</h4><p>例如创建一个长度为 10 的数组，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;<span class="hljs-keyword">int</span>[]&gt; func = (i) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[i];</span><br><span class="line"><span class="hljs-keyword">int</span>[] arr = func.apply(<span class="hljs-number">10</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"arr.length = "</span> + arr.length);</span><br></pre></td></tr></table></figure><p>使用构造方法引用，可以简写成如下方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;<span class="hljs-keyword">int</span>[]&gt; func = <span class="hljs-keyword">int</span>[]::<span class="hljs-keyword">new</span>;</span><br><span class="line"><span class="hljs-keyword">int</span>[] arr = func.apply(<span class="hljs-number">10</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"arr.length = "</span> + arr.length);</span><br></pre></td></tr></table></figure><h2 id="3-变量引用"><a href="#3-变量引用" class="headerlink" title="3. 变量引用"></a>3. 变量引用</h2><p>内部类中使用外部定义的变量，需要这个变量是一个 final 类型的，如果用了 Lambda 表达式，这个规则依然适用。</p><p>如下；</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="hljs-string">"javaboy"</span>;</span><br><span class="line">Consumer&lt;String&gt; consumer = s1 -&gt; System.out.println(s1 + s);</span><br><span class="line">consumer.accept(<span class="hljs-string">"hello "</span>);</span><br></pre></td></tr></table></figure><p>此时虽然不用给 s 变量添加 final 标记，但是它实际上已经是 final 类型的了，如果强行修改，就会报错：</p><p><img src="http://img.itboyhub.com/2021/02/20210519232242.png" alt></p><h2 id="4-类型推断"><a href="#4-类型推断" class="headerlink" title="4. 类型推断"></a>4. 类型推断</h2><p>大部分情况下，Lambda 表达式都是可以推断出自己的类型的，个别情况下可能推断不出，比如出现方法重载的时候，这个时候可能就需要我们类型强转了，例如如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator2</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator3</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo06</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        calculator((ICalculator2) (a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculator</span><span class="hljs-params">(ICalculator2 iCalculator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculator</span><span class="hljs-params">(ICalculator3 iCalculator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了两个计算器 ICalculator2 和 ICalculator3，然后有一个重载的方法分别用到了 ICalculator2 和 ICalculator3，这就导致在使用 Lambda 表达式时无法推断出到底使用哪个对象，此时我们就需要显式的进行类型强转。</p><h2 id="5-级联表达式"><a href="#5-级联表达式" class="headerlink" title="5. 级联表达式"></a>5. 级联表达式</h2><p>Lambda 表达式也可以写成 N 多层，具体则看需求。</p><p>例如三个数相加，可以写成如下形式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Function&lt;Integer, IntFunction&lt;Integer&gt;&gt;&gt; func = x -&gt; y -&gt; z -&gt; x + y + z;</span><br><span class="line">Integer i = func.apply(<span class="hljs-number">3</span>).apply(<span class="hljs-number">4</span>).apply(<span class="hljs-number">5</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"i = "</span> + i);</span><br></pre></td></tr></table></figure><p>这个表达式从右往左看可能容易理解。</p><p><code>z-&gt;x+y+z</code> 对应的是 <code>IntFunction&lt;Integer&gt;</code>。</p><p><code>z-&gt;x+y+z</code> 整体作为返回，y 作为输入，对应的是 <code>Function&lt;Integer, IntFunction&lt;Integer&gt;&gt;</code>。</p><p><code>y -&gt; z -&gt; x + y + z</code> 整体作为返回，x 作为输入，对应的就是 <code>Function&lt;Integer, Function&lt;Integer, IntFunction&lt;Integer&gt;&gt;&gt;</code>。</p><p>that’s all。</p><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/sun_promise/article/details/51190256" target="_blank" rel="noopener">https://blog.csdn.net/sun_promise/article/details/51190256</a></li><li><a href="https://www.jianshu.com/p/4a3da6a11b58" target="_blank" rel="noopener">https://www.jianshu.com/p/4a3da6a11b58</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来说说上周送书的事。小伙伴们太热情了，留言有 300 多条，但是受微信限制，只能精选100条，所以还有很多小伙伴的留言没有精选，但是松哥都认真看了，还请小伙伴们理解。每次留言送书都会选择困难，不知道书送给谁，每个人我都想送，但是只有六本。。。不停的纠结，每次选幸运小伙伴都要花费一小时以上，下次送书还是考虑抽奖吧，省事哈哈。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 前置知识（一）</title>
    <link href="http://www.javaboy.org/2021/0525/method-lambda.html"/>
    <id>http://www.javaboy.org/2021/0525/method-lambda.html</id>
    <published>2021-05-25T10:04:18.000Z</published>
    <updated>2021-05-25T10:07:09.128Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>最近太忙了，发文频率有点不稳定，理解万岁。前面和大家说了要更 WebFlux，学习 WebFlux 之前，我们先来学习一些前置知识。</p><a id="more"></a><blockquote><p>Rome was not built in a day。</p></blockquote><p>WebFlux 也不是一帮人拍脑门突然发明的，它是一个漫长的过程，WebFlux 本身在逐步完善，各种配套工具/理论也在逐步发展。</p><p>因此当松哥想写 WebFlux 的时候，发现没法直接从 WebFlux 本身开始写起，对于很多没有接触过函数式编程的人来说，上来就整 WebFlux 还是有一些挑战的，想来想去，我觉得还是先来和大家捋一捋 JDK8 中的一些旧玩意。</p><p>虽然 JDK8 发布距今已经七八年了，但是相信还是有相当多小伙伴用着 JDK8，写着 JDK6 的代码。所以我们有必要回顾一下 JDK8，也算是我们学习 WebFlux 的一些前置知识。</p><p>好啦，开整吧。</p><h2 id="1-Lambda-表达式的四种写法"><a href="#1-Lambda-表达式的四种写法" class="headerlink" title="1.Lambda 表达式的四种写法"></a>1.Lambda 表达式的四种写法</h2><p>JDK8 中引入了 Lambda，这个大家都知道，虽然现在 JDK 都出到 16 了，但是老实说，项目中的 Lambda 表达式似乎还是很少有人用。有的团队技术风格激进，可能会见到很多 Lambda，但是大部分技术团队还是比较保守的。今天为了学习 WebFlux，我们还是先来回顾一下 Lambda 表达式的几种写法。</p><p>先来说说，如果要用 Lambda，必须是只有一个需要强制实现方法的接口，我们可以使用 <code>@FunctionalInterface</code> 注解去标记该接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果该接口中有多个空方法，编译期间就会报错。</p><p>现在我们建议尽量将一个接口设计的小一些，这样也满足单一职责原则。</p><p>不过 JDK8 中引入了 default 方法，就是自带默认实现的那种，自带默认实现的方法可以有多个，这个并不影响 Lambda，并且 <code>@FunctionalInterface</code> 注解也不会去检查默认方法的数量。</p><h3 id="1-1-单个参数的"><a href="#1-1-单个参数的" class="headerlink" title="1.1 单个参数的"></a>1.1 单个参数的</h3><p>如果只是一个参数，那么直接写参数即可，例如如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ICalculator ic = i -&gt; i * i;</span><br><span class="line">        <span class="hljs-keyword">int</span> square = ic.square(<span class="hljs-number">5</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"square = "</span> + square);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数只有一个参数的时候，直接写即可，不需要添加 <code>()</code>。</p><h3 id="1-2-多个参数"><a href="#1-2-多个参数" class="headerlink" title="1.2 多个参数"></a>1.2 多个参数</h3><p>多个参数的话，就需要写上 <code>()</code> 了，以 Spring Security 中登录成功的回调为例（不了解 Spring Security 的小伙伴可在公号后台回复 ss）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    result.put(<span class="hljs-string">"status"</span>, <span class="hljs-number">200</span>);</span><br><span class="line">    result.put(<span class="hljs-string">"msg"</span>, <span class="hljs-string">"使用 logout1 注销成功!"</span>);</span><br><span class="line">    ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();</span><br><span class="line">    String s = om.writeValueAsString(result);</span><br><span class="line">    resp.getWriter().write(s);</span><br><span class="line">&#125;,<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/logout1"</span>,<span class="hljs-string">"GET"</span>))</span><br><span class="line">.defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    result.put(<span class="hljs-string">"status"</span>, <span class="hljs-number">200</span>);</span><br><span class="line">    result.put(<span class="hljs-string">"msg"</span>, <span class="hljs-string">"使用 logout2 注销成功!"</span>);</span><br><span class="line">    ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();</span><br><span class="line">    String s = om.writeValueAsString(result);</span><br><span class="line">    resp.getWriter().write(s);</span><br><span class="line">&#125;,<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/logout2"</span>,<span class="hljs-string">"POST"</span>))</span><br><span class="line">.and()</span><br><span class="line">.csrf().disable();</span><br></pre></td></tr></table></figure><p>这种情况，方法有多个参数，此时使用 Lambda 表达式就需要加上 <code>()</code>。</p><h3 id="1-3-要写参数类型的"><a href="#1-3-要写参数类型的" class="headerlink" title="1.3 要写参数类型的"></a>1.3 要写参数类型的</h3><p>正常来说用 Lambda 时候不需要写上参数类型，但是如果你需要写，就要加上 <code>()</code>，还是上面那个例子，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ICalculator ic = (<span class="hljs-keyword">int</span> i) -&gt; i * i;</span><br><span class="line">        <span class="hljs-keyword">int</span> square = ic.square(<span class="hljs-number">5</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"square = "</span> + square);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-方法体不止一行的"><a href="#1-4-方法体不止一行的" class="headerlink" title="1.4 方法体不止一行的"></a>1.4 方法体不止一行的</h3><p>如果方法体不止一行，需要用上 <code>{}</code>，如果方法体只有一行，则不需要 <code>{}</code>，参考上面 2、3。</p><h2 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2.函数接口"></a>2.函数接口</h2><p>JDK8 中自带了函数式接口，使用起来也非常方便。</p><h3 id="2-1基本应用"><a href="#2-1基本应用" class="headerlink" title="2.1基本应用"></a>2.1基本应用</h3><p>我们先来看一个简单的例子。</p><p>假设我有一个打招呼的接口 SayHello，SayHello 接口中只有一个 sayHello 方法，然后在 User 类中调用该接口对应的方法，最终用法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SayHello</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(SayHello sayHello)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> sayHello.sayHello(<span class="hljs-keyword">this</span>.username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo02</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        String say = user.say((username) -&gt; <span class="hljs-string">"hello "</span> + username);</span><br><span class="line">        System.out.println(<span class="hljs-string">"say = "</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析 main 方法中的调用过程之后，我们发现，在调用时最核心的是如下一行代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(username) -&gt; <span class="hljs-string">"hello "</span> + username</span><br></pre></td></tr></table></figure><p>在这段代码中，我们只关心方法的输入和输出，其他的都不是我所考虑的，为了一个简单的输入输出，我还要额外定义一个接口，这显然不太划算。</p><p>JDK8 中提供了函数接口，可以帮助我们简化上面的接口定义。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(Function&lt;String,String&gt; sayHello)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> sayHello.apply(<span class="hljs-keyword">this</span>.username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo03</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User2 user2 = <span class="hljs-keyword">new</span> User2();</span><br><span class="line">        user2.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        String say = user2.say((username) -&gt; <span class="hljs-string">"hello "</span> + username);</span><br><span class="line">        System.out.println(<span class="hljs-string">"say = "</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用 <code>Function&lt;String,String&gt;</code> 代替我们前面的接口定义，这里有两个泛型，第一个泛型表示接口输入的参数类型，第二个泛型表示接口输出的参数类型，而且大家注意，我们最终 main 方法中的调用方式是不变的。有了 Function 函数之后，以后我们就不需要定义一些简单的接口了。</p><p>而且 Function 函数还支持链式操作，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo03</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User2 user2 = <span class="hljs-keyword">new</span> User2();</span><br><span class="line">        user2.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        Function&lt;String, String&gt; func = (username) -&gt; <span class="hljs-string">"hello "</span> + username;</span><br><span class="line">        String say = user2.say(func.andThen(s -&gt; <span class="hljs-string">"你好 "</span> + s));</span><br><span class="line">        System.out.println(<span class="hljs-string">"say = "</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-其他函数接口"><a href="#2-2-其他函数接口" class="headerlink" title="2.2 其他函数接口"></a>2.2 其他函数接口</h3><table><thead><tr><th style="text-align:left">接口</th><th style="text-align:left">输入参数</th><th style="text-align:left">返回类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">UnaryOperator<t></t></td><td style="text-align:left">T</td><td style="text-align:left">T</td><td style="text-align:left">一元函数，输入输出类型相同</td></tr><tr><td style="text-align:left">Predicate<t></t></td><td style="text-align:left">T</td><td style="text-align:left">boolean</td><td style="text-align:left">断言</td></tr><tr><td style="text-align:left">Consumer<t></t></td><td style="text-align:left">T</td><td style="text-align:left">/</td><td style="text-align:left">消费一个数据，只有输入没有输出</td></tr><tr><td style="text-align:left">Function&lt;T,R&gt;</td><td style="text-align:left">T</td><td style="text-align:left">R</td><td style="text-align:left">输入 T 返回 R，有输入也有输出</td></tr><tr><td style="text-align:left">Supplier<t></t></td><td style="text-align:left">/</td><td style="text-align:left">T</td><td style="text-align:left">提供一个数据，没有输入只有输出</td></tr><tr><td style="text-align:left">BiFunction&lt;T,U,R&gt;</td><td style="text-align:left">(T,U)</td><td style="text-align:left">R</td><td style="text-align:left">两个输入参数</td></tr><tr><td style="text-align:left">BiPredicate&lt;L, R&gt;</td><td style="text-align:left">(L,R)</td><td style="text-align:left">boolean</td><td style="text-align:left">两个输入参数</td></tr><tr><td style="text-align:left">BiConsumer&lt;T, U&gt;</td><td style="text-align:left">(T,U)</td><td style="text-align:left">void</td><td style="text-align:left">两个输入参数</td></tr><tr><td style="text-align:left">BinaryOperator<t></t></td><td style="text-align:left">(T,T)</td><td style="text-align:left">T</td><td style="text-align:left">二元函数，输入输出类型相同</td></tr></tbody></table><p>接下来我们来看看这些函数接口。</p><h4 id="2-2-1-UnaryOperator"><a href="#2-2-1-UnaryOperator" class="headerlink" title="2.2.1 UnaryOperator"></a>2.2.1 UnaryOperator</h4><p>当输入输出类型相同时，可以使用 UnaryOperator 函数接口，例如我们上面的代码，修改之后如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(UnaryOperator&lt;String&gt; sayHello)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> sayHello.apply(<span class="hljs-keyword">this</span>.username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo03</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User2 user2 = <span class="hljs-keyword">new</span> User2();</span><br><span class="line">        user2.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        UnaryOperator&lt;String&gt; func = (username) -&gt; <span class="hljs-string">"helloo "</span> + username;</span><br><span class="line">        String say = user2.say(func);</span><br><span class="line">        System.out.println(<span class="hljs-string">"say = "</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-Predicate"><a href="#2-2-2-Predicate" class="headerlink" title="2.2.2 Predicate"></a>2.2.2 Predicate</h4><p>Predicate 输入一个 T 类型的参数，输出一个 boolean 类型的值。</p><p>举一个简单的例子，例如如下代码，我们定义一个 List 集合中存放着用户姓名，现在要过滤出所有姓张的用户，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo04</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"里斯"</span>, <span class="hljs-string">"张五"</span>);</span><br><span class="line">        List&lt;String&gt; list = names.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">"张"</span>)).collect(Collectors.toList());</span><br><span class="line">        <span class="hljs-keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"s = "</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter 中传入的就是一个 Predicate 函数接口，这个接口接收 String 类型的数据，返回一个 boolean。</p><p><strong>注意</strong></p><p>一些常用类型的函数接口，JDK 中直接提供了相关的类供我们使用，例如 <code>Predicate&lt;Integer&gt;</code> 可以用 <code>IntPredicate</code> 代替；<code>Consumer&lt;Integer&gt;</code> 可以用 <code>IntConsumer</code> 代替。</p><h4 id="2-2-3-Consumer"><a href="#2-2-3-Consumer" class="headerlink" title="2.2.3 Consumer"></a>2.2.3 Consumer</h4><p>看名字就知道，这个是消费数据，只有输入没有输出。</p><p>例如集合的遍历就可以使用 Consumer 函数接口。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo04</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"里斯"</span>, <span class="hljs-string">"张五"</span>);</span><br><span class="line">        names.stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-Supplier"><a href="#2-2-4-Supplier" class="headerlink" title="2.2.4 Supplier"></a>2.2.4 Supplier</h4><p>Supplier 刚好和 Consumer 相反，它只有输出没有输入。有的时候我们的工厂方法没有输入只有输出，这个时候就可以考虑使用 Supplier（如果有输入参数，则可以考虑使用 Function 函数接口）。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Connection&gt; supplier = ()-&gt;&#123;</span><br><span class="line">    Connection con = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        con = DriverManager.getConnection(<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> con;</span><br><span class="line">&#125;;</span><br><span class="line">Connection connection = supplier.get();</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>其实 WebFlux 前置知识还是蛮多的，今天先聊这些吧，我们后面继续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;最近太忙了，发文频率有点不稳定，理解万岁。前面和大家说了要更 WebFlux，学习 WebFlux 之前，我们先来学习一些前置知识。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>挖一个大坑，WebFlux 开搞！</title>
    <link href="http://www.javaboy.org/2021/0525/webflux-guide.html"/>
    <id>http://www.javaboy.org/2021/0525/webflux-guide.html</id>
    <published>2021-05-25T10:04:01.000Z</published>
    <updated>2021-05-25T10:06:48.272Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Spring5 的推出，WebFlux 被置于越来越重要的位置，无论是内在的学习驱动，还是公司的项目要求，很多小伙伴们都开始关注 WebFlux 了，也有很多小伙伴在微信上私我能不能整一套 WebFlux 教程？</p><a id="more"></a><p>整当然是能整，不过最近忙是真的忙，松哥最近开始带团队了，有很多需要和其他部门对接的事情，晚上十一点还在出方案。。。写公号的时间被严重压缩了，但是不管怎么样，该写还是要写，不仅仅是对小伙伴们的承诺，也是对自己的承诺。</p><p>想来想去，这次就整 WebFlux 吧，有小伙伴已经催了快一年了，该搞了。</p><p>今天我们就先来介绍下响应式系统，毕竟不了解响应式系统，那学习 WebFlux 干嘛？</p><h2 id="1-什么是响应式系统"><a href="#1-什么是响应式系统" class="headerlink" title="1.什么是响应式系统"></a>1.什么是响应式系统</h2><p>响应式系统的目标是灵敏度高，系统稳健一直有回复，松耦合和可扩展。<strong>响应式系统是一种架构</strong>，可以应用于任何地方，无论是一个小小的博客网页，还是复杂的网购系统，都可以使用响应式架构。</p><p>一般来说，响应式系统有四个显著的特点：</p><ul><li>即时响应（responsive）</li><li>回弹性（resilience）</li><li>弹性（elastic）</li><li>消息驱动（message driven）</li></ul><p>下面这张图很好的描述了这几者之间的关系：</p><p><img src="http://img.itboyhub.com/2021/02/20210420214856.png" alt></p><p>消息驱动是手段，弹性和回弹性是形式，最终的即时响应就是它的价值。</p><p>接下来我们来逐个介绍这四种特性。</p><h2 id="2-四大特点"><a href="#2-四大特点" class="headerlink" title="2.四大特点"></a>2.四大特点</h2><h3 id="2-1-即时响应（responsive）"><a href="#2-1-即时响应（responsive）" class="headerlink" title="2.1 即时响应（responsive）"></a>2.1 即时响应（responsive）</h3><p>即时响应的特点就是一个字，快！</p><p>现在 4G 的普及，百兆千兆带宽的使用，CPU 计算能力的提高，都在降低用户对于一个系统的耐心，一个网页，5s 没加载完，用户已经觉得体验很差了，30s 还没加载出来，那你可能失去这个用户。</p><p>所以我们需要构建一个健壮的、能够快速响应的即时响应系统，特别是在一些高并发的场景下，响应延迟还能保持在合理范围内，这才是最重要的。</p><p>要实现这一目标，要用到很多具体的技术，例如异步加载、预加载等。另外还涉及到弹性（elastic）与回弹性（resilience）这样一些原则性问题。</p><h3 id="2-2-弹性（elastic）"><a href="#2-2-弹性（elastic）" class="headerlink" title="2.2 弹性（elastic）"></a>2.2 弹性（elastic）</h3><p>弹性其实就是指系统随时可以动态扩展。</p><p>举个例子，一个电商网站，平时活跃用户有限，所需要的服务器数量足够支撑日常服务即可，没有必要多买，毕竟都是要花钱的。一旦遇上大促，系统的流量在短时间内爆发出来，这个时候就需要能够随时随地方便的为系统扩容，这就是系统的弹性。</p><p>松哥在之前的文章中和大家聊过 Nginx 负载均衡，这其实就是一种扩容的手段。现在很多中小公司可能回采用云服务，如果使用云服务，一般都可以非常方便的实现动态扩容。</p><h3 id="2-3-回弹性（resilience）"><a href="#2-3-回弹性（resilience）" class="headerlink" title="2.3 回弹性（resilience）"></a>2.3 回弹性（resilience）</h3><p>回弹性就是指当系统遭遇到失败时，依然能够对外提供服务。松哥在之前和大家分享 Spring Cloud 时，Hystrix 的功能之一就是容错，当一个服务崩掉的时候，不会拖累到其他服务。通过服务的降级、隔离等手段，可以保证回弹性。回弹性还会要求在系统出错的时候，能够自动进行重试。</p><p>其实大家看回弹性这个单词 resilience，不知道有没有想起来在 Spring Cloud 体系中，用来替代 Hystrix 的工具就叫做 resilience4j，所以如果你了解 Hystrix 的功能，大概就知道什么是回弹性。不了解 Spring Cloud 的话，可以看看这个网站：<a href="http://www.itboyhub.com。" target="_blank" rel="noopener">www.itboyhub.com。</a></p><h3 id="2-4-消息驱动（message-driven）"><a href="#2-4-消息驱动（message-driven）" class="headerlink" title="2.4 消息驱动（message driven）"></a>2.4 消息驱动（message driven）</h3><p>消息驱动是具体的实现手段。</p><p>在分布式系统中，我们要解耦、隔离服务、提高可伸缩性，为了达成这一目标，消息驱动是最佳选择。因为只有消息驱动能够同时满足即时响应、弹性以及回弹性这些要求。</p><p>有的小伙伴在学习微服务的时候，可能会看到一个名词，就叫做消息驱动的微服务。</p><p>在松哥的微人事中，有一个邮件发送的功能，就用到了消息驱动，发件人只需要把邮件内容扔到消息中间件中即可，剩余的事情都不用管了，邮件服务器会自动从消息中间件中读取邮件信息然后将邮件发送出去，发送失败的事务、回滚等等操作，都由邮件服务器自行处理，发送方只管把消息扔出去就行了，这就很好的实现了解耦。</p><p>这就是我们常说的响应式系统的四大特点。</p><h2 id="3-身边的响应式系统"><a href="#3-身边的响应式系统" class="headerlink" title="3.身边的响应式系统"></a>3.身边的响应式系统</h2><p>响应式系统其实离我们并不远，不是说用了 WebFlux、用了 Gateway、用了异步 Servlet 就是响应式系统，这其实没有必然联系，上面那些都是实现响应式系统的一个具体方案，具体技术而已。</p><p>举一个很简单的消息驱动微服务的案例，如下图：</p><p><img src="https://zsrimg.ikafan.com/file_images/article/201910/20191015105956901.png?201991511043" alt></p><p>引入了消息中间件 RabbitMQ/Kafka 之后，能够很好的实现 A 服务和 B 服务的解耦，同时利用 RabbitMQ/Kafka 自带的消息消费失败重试的功能也能很好的提高系统的容错性和可靠性。</p><p>松哥之前专门录过提高消息中间件可靠性的视频，感兴趣的小伙伴可以看看：</p><p>提高可靠性：<br><!--视频1--><br>处理幂等性：<br><!--视频2--></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>总之，响应式系统是一个架构层面的东西，它有四个基本特点，它还有很多具体的实现手段，这些具体的实现手段松哥将在未来的文章中和大家逐一进行介绍。好啦，本文作为一个引子，就先和大家聊这么多，关于响应式系统，如果大家有自己的理解或者实践经验，欢迎投稿哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Spring5 的推出，WebFlux 被置于越来越重要的位置，无论是内在的学习驱动，还是公司的项目要求，很多小伙伴们都开始关注 WebFlux 了，也有很多小伙伴在微信上私我能不能整一套 WebFlux 教程？&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>世界有你，了不起！</title>
    <link href="http://www.javaboy.org/2021/0428/2021hdc.html"/>
    <id>http://www.javaboy.org/2021/0428/2021hdc.html</id>
    <published>2021-04-28T11:43:33.000Z</published>
    <updated>2021-04-28T11:44:37.074Z</updated>
    
    <content type="html"><![CDATA[<p>虽然也一把年纪了，但是看到余承东演讲最后这一句，还是有点热血。</p><p><img src="http://img.itboyhub.com//2020/04/vhr/c6131d55af30b6c36b1a148cf2029d8.jpg" alt></p><p>世界有你了不起！</p><a id="more"></a><p>2021 华为开发者大会 4 月 24 - 4 月 26 在深圳大学城举办，四年前我刚来深圳的时候，就住在大学城附近，周末有空了还会去学校里走走，哈工大（深圳）、清北的深圳研究生院都在这里，号称“深圳莱茵河”的大沙河从这里穿过，当时我每天晚上还沿大沙河跑步。大学城北靠西丽水库、南依塘朗山，实在是学习开会的好地方。开会，我最喜欢去的就是这种地方，可以让人很放松，特别是高校里边。</p><p>这届大会主题是#<strong>每一个开发者都了不起</strong>#！这句话是真的好听！</p><p><img src="http://img.itboyhub.com/2021/02/20210427194157.png" alt></p><p>这届大会一共是三天，不过 4 月 24 的活动主要是针对学生，我因为当天从广州赶回深圳，来不及就没去了。25、26 两天则有大量的主题峰会以及训练营，特别是余承东重磅发布了华为云 6 大创新产品及服务，这个就不能错过了。</p><p>25 号一大早 7 点 40 左右就从家里出发，计划 8 点半左右到会场，结果我还是错估了深圳地铁的实力，25 号因为刚好是五一假期补班，赶上早高峰，我到地铁口我就惊呆了，长不见尾的队伍。。。就这样计划稍微受到一点影响，到会场的时候差不多 9 点了。</p><p><img src="http://img.itboyhub.com/2021/02/稿定设计导出-20210427-195803.jpg" alt></p><p>因为这次大会是在大学城举办，不同会场距离较远，因此检票进入后，可以坐接驳的电瓶车去不同的会场。已经过了 9 点了，早上的峰会将在 9 点半开始，于是赶紧上车，go！</p><p>峰会在深圳大学城体育馆举行，这是会场门口：</p><p><img src="http://img.itboyhub.com/2021/02/20210427200523.png" alt></p><p>在华为手机芯片被限制的情况下，现在余承东也在管着华为云（华为云 CEO）和汽车等业务，所以峰会的第一场演讲就是余承东带来的，现场发布了华为云 6 大创新产品及服务，包括：</p><ul><li>华为云 CCE Turbo 云容器集群</li><li>CloudIDE 智能编程助手</li><li>GaussDB（for openGauss）数据库</li><li>可信智能计算服务 TICS</li><li>华为云盘古系列大模型</li><li>多样性计算基础软件</li></ul><p>无论是搞云原生、数据库、人工智能、数据分析还是其他，这些发布的产品或者服务，总有一个能让你提神。</p><p>特别是华为云盘古系列超大规模预训练模型，包括 30 亿参数的全球最大视觉(CV)预训练模型，以及与循环智能、鹏城实验室联合开发的千亿参数、40TB 训练数据的全球最大中文语言(NLP)预训练模型。</p><p>有点后悔的是女朋友没来，女朋友现在在腾讯游戏做大数据分析，现场发布的挺多产品跟她的工作关联性都挺大，不过她那天要上班，没来，我带了另外几个小伙伴一起过来。</p><p><img src="http://img.itboyhub.com/2021/02/20210427202406.png" alt><br><img src="http://img.itboyhub.com/2021/02/20210427202557.png" alt></p><p>我也是第一次近距离听余总演讲，还是挺开心的哈哈。</p><p>余承东演讲完后，接下来还有其他一些大佬上台，有小红书的技术负责人分享他们在华为云上的一些实践心得等等。</p><p><img src="http://img.itboyhub.com/2021/02/20210427202955.png" alt></p><p>早上的峰会时间挺长的，峰会结束后我们又坐电瓶车去了展岛。</p><p>在展岛总算找到组织啦，开发者社区！又见到了很多小伙伴，也认识很多新的小伙伴，太激动了，进去后忘了拍照。。。</p><p><img src="http://img.itboyhub.com/2021/02/20210427203343.png" alt></p><p>今年的开发者社区我们有一个解忧咖啡馆活动，还蛮有意思的，松哥还在现场录了一个 vlog，等弄好了拿出来给小伙伴们过目。</p><p>在展岛我们也看到了华为前段时间刚刚发布的赛力斯汽车（不是自动驾驶那个），近距离体验了一把：</p><p><img src="http://img.itboyhub.com/2021/02/20210427203801.png" alt></p><p><img src="http://img.itboyhub.com/2021/02/稿定设计导出-20210427-204154.jpg" alt></p><p>展岛有很多好玩的打卡活动，我下午去参加训练营和鲲鹏应用实践去了，等我回来的时候，三个小伙伴已经打了一遍卡了。</p><p><img src="http://img.itboyhub.com/2021/02/20210427204536.png" alt></p><p>这些打卡活动都还是挺好玩的，能让我们近距离体验一把华为云的技术，跑一把 ModelArts ，或者 DIY 一下硬件：</p><p><img src="http://img.itboyhub.com/2021/02/稿定设计导出-20210427-210948.jpg" alt></p><p>…</p><p>总之，这次活动还是蛮有意思的。</p><p>老实说，华为在手机芯片被制裁后，手机市场份额下滑厉害，华为云被寄予了厚望，这次大会也是余承东出任华为云 CEO 后的首次公开亮相，余承东回来带领华为云，对内鼓励人心，对外也给人很大期待。毕竟余承东曾经在无线和消费者业务上都有着非常亮眼的成绩。</p><p>不过困难也不小，从 IDC 的报告中我们也可以看出来，仅国内来说，公有云市场目前还是阿里云最强，也期待华为云能够早日走出 others。</p><p><img src="http://img.itboyhub.com/2021/02/20210427211817.png" alt></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然也一把年纪了，但是看到余承东演讲最后这一句，还是有点热血。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.itboyhub.com//2020/04/vhr/c6131d55af30b6c36b1a148cf2029d8.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;世界有你了不起！&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot一键换肤，so easy！</title>
    <link href="http://www.javaboy.org/2021/0423/springmvc-theme.html"/>
    <id>http://www.javaboy.org/2021/0423/springmvc-theme.html</id>
    <published>2021-04-23T12:14:45.000Z</published>
    <updated>2021-04-23T12:15:40.007Z</updated>
    
    <content type="html"><![CDATA[<p>SpringMVC 源码分析系列最后一篇，和大家聊一聊 Theme。</p><a id="more"></a><p>Theme，就是主题，点一下就给网站更换一个主题，相信大家都用过类似功能，这个其实和前面所说的国际化功能很像，代码其实也很像，今天我们就来捋一捋。</p><p>考虑到有的小伙伴可能还没用过 Theme，所以这里松哥先来说下用法，然后我们再进行源码分析。</p><h2 id="1-一键换肤"><a href="#1-一键换肤" class="headerlink" title="1.一键换肤"></a>1.一键换肤</h2><p>来做一个简单的需求，假设我的页面上有三个按钮，点击之后就能一键换肤，像下面这样：</p><p><img src="http://img.itboyhub.com/2021/02/20210409191940.png" alt></p><p>我们来看下这个需求怎么实现。</p><p>首先三个按钮分别对应了三个不同的样式，我们先把这三个不同的样式定义出来，分别如下：</p><p>blue.css：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">body</span>&#123;</span><br><span class="line">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#05e1ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>green.css：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">body</span>&#123;</span><br><span class="line">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#aaff9c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>red.css：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">body</span>&#123;</span><br><span class="line">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0721</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题的定义，往往是一组样式，因此我们一般都是在一个 properties 文件中将同一主题的样式配置在一起，这样方便后期加载。</p><p>所以接下来我们在 resources 目录下新建 theme 目录，然后在 theme 目录中创建三个文件，内容如下：</p><p>blue.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.body=/css/blue.css</span><br></pre></td></tr></table></figure><p>green.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.body=/css/green.css</span><br></pre></td></tr></table></figure><p>red.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.body=/css/red.css</span><br></pre></td></tr></table></figure><p>在不同的 properties 配置文件中引入不同的样式，但是样式定义的 key 都是 index.body，这样方便后期在页面中引入。</p><p>接下来在 SpringMVC 容器中配置三个 Bean，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.theme.ThemeChangeInterceptor"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"paramName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"theme"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"themeSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.ui.context.support.ResourceBundleThemeSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basenamePrefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"theme."</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"themeResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.theme.SessionThemeResolver"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultThemeName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"blue"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>首先配置拦截器 ThemeChangeInterceptor，这个拦截器用来解析主题参数，参数的 key 为 theme，例如请求地址是 <code>/index?theme=blue</code>，该拦截器就会自动设置系统主题为 blue。当然也可以不配置拦截器，如果不配置的话，就可以单独提供一个修改主题的接口，然后手动修改主题，类似下面这样：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line"><span class="hljs-keyword">private</span> ThemeResolver themeResolver;</span><br><span class="line"><span class="hljs-meta">@RequestMapping</span>(path = <span class="hljs-string">"/01/&#123;theme&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">theme1</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"theme"</span>)</span> String themeStr, HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line">    themeResolver.setThemeName(request,response, themeStr);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/01"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>themeStr 就是新的主题名称，将其配置给 themeResolver 即可。</p><ol start="2"><li>接下来配置 ResourceBundleThemeSource，这个 Bean 主要是为了加载主题文件，需要配置一个 basenamePrefix 属性，如果我们的主题文件放在文件夹中，这个 basenamePrefix 的值就是 <code>文件夹名称.</code>。</li><li>接下来配置主题解析器，主题解析器有三种，分别是 CookieThemeResolver、FixedThemeResolver、SessionThemeResolver，这里我们使用的是 SessionThemeResolver，主题信息将被保存在 Session 中，只要 Session 不变，主题就一直有效。这三个主题解析器松哥会在下一小节中和大家仔细分析。</li></ol><p>配置完成后，我们再来提供一个测试页面，如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="hljs-string">"spring"</span> uri=<span class="hljs-string">"http://www.springframework.org/tags"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="hljs-string">"text/html;charset=UTF-8"</span> language=<span class="hljs-string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"&lt;spring:theme code="</span>index.body<span class="hljs-string">" /&gt;"</span> &gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    一键切换主题：&lt;br/&gt;</span><br><span class="line">    &lt;a href="/index?theme=blue"&gt;托帕蓝&lt;/a&gt;</span><br><span class="line">    &lt;a href="/index?theme=red"&gt;多巴胺红&lt;/a&gt;</span><br><span class="line">    &lt;a href="/index?theme=green"&gt;石竹青&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>最关键的是：</p><figure class="highlight jsp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"&lt;spring:theme code="</span>index.body<span class="hljs-string">" /&gt;"</span> &gt;</span><br></pre></td></tr></table></figure><p>css 样式不直接写，而是引用我们在 properties 文件中定义的 index.body，这样将根据当前主题加载不同的 css 文件。</p><p>最后再提供一个处理器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(path = <span class="hljs-string">"/index"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span>  String <span class="hljs-title">getPage</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就很简单了，没啥好说的。</p><p>最后启动项目进行测试，大家就可以看到我们文章一开始给出的图片了，点击不同的按钮就可以实现背景的切换。</p><p>是不是非常 Easy！</p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2.原理分析"></a>2.原理分析</h2><p>主题这块涉及到的东西主要就是主题解析器，主题解析器和我们前面所说的国际化的解析器非常类似，但是比它更简单，我们一起来分析下。</p><p>先来看下 ThemeResolver 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThemeResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">resolveThemeName</span><span class="hljs-params">(HttpServletRequest request)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setThemeName</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中就两个方法：</p><ol><li>resolveThemeName：从当前请求中解析出主题的名字。</li><li>setThemeName：设置当前主题。</li></ol><p>ThemeResolver 主要有三个实现类，继承关系如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210409203413.png" alt></p><p>接下来我们对这几个实现类来逐个分析。</p><h3 id="2-1-CookieThemeResolver"><a href="#2-1-CookieThemeResolver" class="headerlink" title="2.1 CookieThemeResolver"></a>2.1 CookieThemeResolver</h3><p>直接上源码吧：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">resolveThemeName</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String themeName = (String) request.getAttribute(THEME_REQUEST_ATTRIBUTE_NAME);</span><br><span class="line"><span class="hljs-keyword">if</span> (themeName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> themeName;</span><br><span class="line">&#125;</span><br><span class="line">String cookieName = getCookieName();</span><br><span class="line"><span class="hljs-keyword">if</span> (cookieName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Cookie cookie = WebUtils.getCookie(request, cookieName);</span><br><span class="line"><span class="hljs-keyword">if</span> (cookie != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String value = cookie.getValue();</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(value)) &#123;</span><br><span class="line">themeName = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (themeName == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">themeName = getDefaultThemeName();</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, themeName);</span><br><span class="line"><span class="hljs-keyword">return</span> themeName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThemeName</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(themeName)) &#123;</span><br><span class="line">request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, themeName);</span><br><span class="line">addCookie(response, themeName);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, getDefaultThemeName());</span><br><span class="line">removeCookie(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看 resolveThemeName 方法：</p><ol><li>首先会尝试直接从请求中获取主题名称，如果获取到了，就直接返回。</li><li>如果第一步没有获取到主题名称，接下来就尝试从 Cookie 中获取主题名称，Cookie 也是从当前请求中提取，利用 WebUtils 工具进行解析，如果解析到了主题名称，就赋值给 themeName 变量。</li><li>如果前面没有获取到主题名称，就使用默认的主题名称，开发者可以自行配置默认的主题名称，如果不配置，就是 theme。</li><li>将解析出来的 theme 保存到 request 中，以备后续使用。</li></ol><p>再来看 setThemeName 方法：</p><ol><li>如果存在 themeName 就进行设置，同时将 themeName 添加到 Cookie 中。</li><li>如果不存在 themeName，就设置一个默认的主题名，同时从 response 中移除 Cookie。</li></ol><p>可以看到，整个实现思路还是非常简单的。</p><h3 id="2-2-AbstractThemeResolver"><a href="#2-2-AbstractThemeResolver" class="headerlink" title="2.2 AbstractThemeResolver"></a>2.2 AbstractThemeResolver</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractThemeResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThemeResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ORIGINAL_DEFAULT_THEME_NAME = <span class="hljs-string">"theme"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> String defaultThemeName = ORIGINAL_DEFAULT_THEME_NAME;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDefaultThemeName</span><span class="hljs-params">(String defaultThemeName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.defaultThemeName = defaultThemeName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDefaultThemeName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultThemeName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractThemeResolver 主要提供了配置默认主题的能力。</p><h3 id="2-3-FixedThemeResolver"><a href="#2-3-FixedThemeResolver" class="headerlink" title="2.3 FixedThemeResolver"></a>2.3 FixedThemeResolver</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedThemeResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractThemeResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">resolveThemeName</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getDefaultThemeName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThemeName</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Cannot change theme - use a different theme resolution strategy"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThemeResolver 就是使用默认的主题名称，并且不允许修改主题。</p><h3 id="2-4-SessionThemeResolver"><a href="#2-4-SessionThemeResolver" class="headerlink" title="2.4 SessionThemeResolver"></a>2.4 SessionThemeResolver</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionThemeResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractThemeResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String THEME_SESSION_ATTRIBUTE_NAME = SessionThemeResolver.class.getName() + <span class="hljs-string">".THEME"</span>;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">resolveThemeName</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String themeName = (String) WebUtils.getSessionAttribute(request, THEME_SESSION_ATTRIBUTE_NAME);</span><br><span class="line"><span class="hljs-keyword">return</span> (themeName != <span class="hljs-keyword">null</span> ? themeName : getDefaultThemeName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThemeName</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span> </span>&#123;</span><br><span class="line">WebUtils.setSessionAttribute(request, THEME_SESSION_ATTRIBUTE_NAME,</span><br><span class="line">(StringUtils.hasText(themeName) ? themeName : <span class="hljs-keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resolveThemeName：从 session 中取出主题名称并返回，如果 session 中的主题名称为 null，就返回默认的主题名称。</li><li>setThemeName：将主题配置到请求中。</li></ul><p>不想多说，因为很简单。</p><h3 id="2-5-ThemeChangeInterceptor"><a href="#2-5-ThemeChangeInterceptor" class="headerlink" title="2.5 ThemeChangeInterceptor"></a>2.5 ThemeChangeInterceptor</h3><p>最后我们再来看一看 ThemeChangeInterceptor 拦截器，这个拦截器会自动从请求中提取出主题参数，并设置到请求中，核心部分在 preHandle 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">String newTheme = request.getParameter(<span class="hljs-keyword">this</span>.paramName);</span><br><span class="line"><span class="hljs-keyword">if</span> (newTheme != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">ThemeResolver themeResolver = RequestContextUtils.getThemeResolver(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (themeResolver == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No ThemeResolver found: not in a DispatcherServlet request?"</span>);</span><br><span class="line">&#125;</span><br><span class="line">themeResolver.setThemeName(request, response, newTheme);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从请求中提取出 theme 参数，并设置到 themeResolver 中。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，这就是今天和小伙伴们分享的一键换肤！无论是功能性还是源码，都和国际化非常类似，但是比国际化简单很多，不知道小伙伴们有没有 GET 到呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringMVC 源码分析系列最后一篇，和大家聊一聊 Theme。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>这篇文章让你搞懂 SpringMVC 国际化！</title>
    <link href="http://www.javaboy.org/2021/0420/springmvc-i18n.html"/>
    <id>http://www.javaboy.org/2021/0420/springmvc-i18n.html</id>
    <published>2021-04-20T12:54:49.000Z</published>
    <updated>2021-04-20T12:56:05.917Z</updated>
    
    <content type="html"><![CDATA[<p>松哥之前写过 Spring Boot 国际化的问题，不过那一次没讲源码，这次咱们整点源码来深入理解下这个问题。</p><a id="more"></a><p>国际化，也叫 i18n，为啥叫这个名字呢？因为国际化英文是 internationalization ，在 i 和 n 之间有 18 个字母，所以叫 i18n。我们的应用如果做了国际化就可以在不同的语言环境下，方便的进行切换，最常见的就是中文和英文之间的切换，国际化这个功能也是相当的常见。</p><h2 id="1-SpringMVC-国际化配置"><a href="#1-SpringMVC-国际化配置" class="headerlink" title="1.SpringMVC 国际化配置"></a>1.SpringMVC 国际化配置</h2><p>还是先来说说用法，再来说源码，这样大家不容易犯迷糊。我们先说在 SSM 中如何处理国际化问题。</p><p>首先国际化我们可能有两种需求：</p><ul><li>在页面渲染时实现国际化（这个借助于 Spring 标签实现）</li><li>在接口中获取国际化匹配后的消息</li></ul><p>大致上就是上面这两种场景。接下来松哥通过一个简单的用法来和大家演示下具体玩法。</p><p>首先我们在项目的 resources 目录下新建语言文件，language_en_US.properties 和 language_zh-CN.properties，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210401204229.png" alt></p><p>内容分别如下：</p><p>language_en_US.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login.username=Username</span><br><span class="line">login.password=Password</span><br></pre></td></tr></table></figure><p>language_zh-CN.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login.username=用户名</span><br><span class="line">login.password=用户密码</span><br></pre></td></tr></table></figure><p>这两个分别对应英中文环境。配置文件写好之后，还需要在 SpringMVC 容器中提供一个 ResourceBundleMessageSource 实例去加载这两个实例，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.context.support.ResourceBundleMessageSource"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"messageSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basename"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"language"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultEncoding"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"UTF-8"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里配置了文件名 language 和默认的编码格式。</p><p>接下来我们新建一个 login.jsp 文件，如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="hljs-string">"spring"</span> uri=<span class="hljs-string">"http://www.springframework.org/tags"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="hljs-string">"text/html;charset=UTF-8"</span> language=<span class="hljs-string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;spring:message code=<span class="hljs-string">"login.username"</span>/&gt; &lt;input type=<span class="hljs-string">"text"</span>&gt; &lt;br&gt;</span><br><span class="line">&lt;spring:message code=<span class="hljs-string">"login.password"</span>/&gt; &lt;input type=<span class="hljs-string">"text"</span>&gt; &lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在这个文件中，我们通过 <code>spring:message</code> 标签来引用变量，该标签会根据当前的实际情况，选择合适的语言文件。</p><p>接下来我们为 login.jsp 提供一个控制器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        String username = messageSource.getMessage(<span class="hljs-string">"login.username"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">        String password = messageSource.getMessage(<span class="hljs-string">"login.password"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">        System.out.println(<span class="hljs-string">"username = "</span> + username);</span><br><span class="line">        System.out.println(<span class="hljs-string">"password = "</span> + password);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器中直接返回 login 视图即可。</p><p>另外我这还注入了 MessageSource 对象，主要是为了向大家展示如何在处理器中获取国际化后的语言文字。</p><p>配置完成后，启动项目进行测试。</p><p>默认情况下，系统是根据请求头的中 Accept-Language 字段来判断当前的语言环境的，该这个字段由浏览器自动发送，我们这里为了测试方便，可以使用 POSTMAN 进行测试，然后手动设置 Accept_Language 字段。</p><p>首先测试中文环境：</p><p><img src="http://img.itboyhub.com/2021/02/20210401205538.png" alt></p><p>然后测试英文环境：</p><p><img src="http://img.itboyhub.com/2021/02/20210401205612.png" alt></p><p>都没问题，完美！同时观察 IDEA 控制台，也能正确打印出语言文字。</p><p>上面这个是基于 AcceptHeaderLocaleResolver 来解析出当前的区域和语言的。</p><p>有的时候，我们希望语言环境直接通过请求参数来传递，而不是通过请求头来传递，这个需求我们通过 SessionLocaleResolver 或者 CookieLocaleResolver 都可以实现。</p><p>先来看 SessionLocaleResolver。</p><p>首先在 SpringMVC 配置文件中提供 SessionLocaleResolver 的实例，同时配置一个拦截器，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"paramName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"locale"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.SessionLocaleResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"localeResolver"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SessionLocaleResolver 是负责区域解析的，这个没啥好说的。拦截器 LocaleChangeInterceptor 则主要是负责参数解析的，我们在配置拦截器的时候，设置了参数名为 locale（默认即此），也就是说我们将来可以通过 locale 参数来传递当前的环境信息。</p><p>配置完成后，我们还是来访问刚才的 login 控制器，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210401210442.png" alt></p><p>此时我们可以直接通过 locale 参数来控制当前的语言环境，这个 locale 参数就是在前面所配置的 LocaleChangeInterceptor 拦截器中被自动解析的。</p><p>如果你不想配置 LocaleChangeInterceptor 拦截器也是可以的，直接自己手动解析 locale 参数然后设置 locale 也行，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String locale,HttpSession session)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"zh-CN"</span>.equals(locale)) &#123;</span><br><span class="line">            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">"zh"</span>, <span class="hljs-string">"CN"</span>));</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"en-US"</span>.equals(locale)) &#123;</span><br><span class="line">            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">"en"</span>, <span class="hljs-string">"US"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        String username = messageSource.getMessage(<span class="hljs-string">"login.username"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">        String password = messageSource.getMessage(<span class="hljs-string">"login.password"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">        System.out.println(<span class="hljs-string">"username = "</span> + username);</span><br><span class="line">        System.out.println(<span class="hljs-string">"password = "</span> + password);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SessionLocaleResolver 所实现的功能也可以通过 CookieLocaleResolver 来实现，不同的是前者将解析出来的区域信息保存在 session 中，而后者则保存在 Cookie 中。<strong>保存在 session 中，只要 session 没有发生变化，后续就不用再次传递区域语言参数了，保存在 Cookie 中，只要 Cookie 没变，后续也不用再次传递区域语言参数了</strong>。</p><p>使用 CookieLocaleResolver 的方式很简单，直接在 SpringMVC 中提供 CookieLocaleResolver 的实例即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span> id=<span class="hljs-string">"localeResolver"</span>/&gt;</span><br></pre></td></tr></table></figure><p>注意这里也需要使用到 LocaleChangeInterceptor 拦截器，如果不使用该拦截器，则需要自己手动解析并配置语言环境，手动解析并配置的方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login3"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login3</span><span class="hljs-params">(String locale, HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">    CookieLocaleResolver resolver = <span class="hljs-keyword">new</span> CookieLocaleResolver();</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-string">"zh-CN"</span>.equals(locale)) &#123;</span><br><span class="line">        resolver.setLocale(req, resp, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">"zh"</span>, <span class="hljs-string">"CN"</span>));</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"en-US"</span>.equals(locale)) &#123;</span><br><span class="line">        resolver.setLocale(req, resp, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">"en"</span>, <span class="hljs-string">"US"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    String username = messageSource.getMessage(<span class="hljs-string">"login.username"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    String password = messageSource.getMessage(<span class="hljs-string">"login.password"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    System.out.println(<span class="hljs-string">"username = "</span> + username);</span><br><span class="line">    System.out.println(<span class="hljs-string">"password = "</span> + password);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，启动项目进行测试，这次测试的方式跟 SessionLocaleResolver 的测试方式一致，松哥就不再多说了。</p><p>除了前面介绍的这几种 LocaleResolver 之外，还有一个 FixedLocaleResolver，因为比较少见，松哥这里就不做过多介绍了。</p><h2 id="2-Spring-Boot-国际化配置"><a href="#2-Spring-Boot-国际化配置" class="headerlink" title="2.Spring Boot 国际化配置"></a>2.Spring Boot 国际化配置</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><p>Spring Boot 和 Spring 一脉相承，对于国际化的支持，默认是通过 AcceptHeaderLocaleResolver 解析器来完成的，这个解析器，默认是通过请求头的 Accept-Language 字段来判断当前请求所属的环境的，进而给出合适的响应。</p><p>所以在 Spring Boot 中做国际化，这一块我们可以不用配置，直接就开搞。</p><p>首先创建一个普通的 Spring Boot 项目，添加 web 依赖即可。项目创建成功后，默认的国际化配置文件放在 resources 目录下，所以我们直接在该目录下创建四个测试文件，如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-1.png" alt></p><ul><li>我们的 message 文件是直接创建在 resources 目录下的，IDEA 在展示的时候，会多出一个 Resource Bundle，这个大家不用管，千万别手动去创建这个目录。</li><li>messages.properties 这个是默认的配置，其他的则是不同语言环境下的配置，en_US 是英语(美国)，zh_CN 是中文简体，zh_TW 是中文繁体（文末附录里边有一个完整的语言简称表格）。</li></ul><p>四个文件创建好之后，第一个默认的我们可以先空着，另外三个分别填入以下内容：</p><p>messages_zh_CN.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=江南一点雨</span><br></pre></td></tr></table></figure><p>messages_zh_TW.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=江南壹點雨</span><br></pre></td></tr></table></figure><p>messages_en_US.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=javaboy</span><br></pre></td></tr></table></figure><p>配置完成后，我们就可以直接开始使用了。在需要使用值的地方，直接注入 MessageSource 实例即可。</p><blockquote><p>在 Spring 中需要配置的 MessageSource 现在不用配置了，Spring Boot 会通过 <code>org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration</code> 自动帮我们配置一个 MessageSource 实例。</p></blockquote><p>创建一个 HelloController ，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageSource.getMessage(<span class="hljs-string">"user.name"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HelloController 中我们可以直接注入 MessageSource 实例，然后调用该实例中的 getMessage 方法去获取变量的值，第一个参数是要获取变量的 key，第二个参数是如果 value 中有占位符，可以从这里传递参数进去，第三个参数传递一个 Locale 实例即可，这相当于当前的语言环境。</p><p>接下来我们就可以直接去调用这个接口了。</p><p>默认情况下，在接口调用时，通过请求头的 Accept-Language 来配置当前的环境，我这里通过 POSTMAN 来进行测试，结果如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-2.png" alt></p><p>小伙伴们看到，我在请求头中设置了 Accept-Language 为 zh-CN，所以拿到的就是简体中文；如果我设置了 zh-TW，就会拿到繁体中文：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-3.png" alt></p><p>是不是很 Easy？</p><h3 id="2-2-自定义切换"><a href="#2-2-自定义切换" class="headerlink" title="2.2 自定义切换"></a>2.2 自定义切换</h3><p>有的小伙伴觉得切换参数放在请求头里边好像不太方便，那么也可以自定义解析方式。例如参数可以当成普通参数放在地址栏上，通过如下配置可以实现我们的需求。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        LocaleChangeInterceptor interceptor = <span class="hljs-keyword">new</span> LocaleChangeInterceptor();</span><br><span class="line">        interceptor.setParamName(<span class="hljs-string">"lang"</span>);</span><br><span class="line">        registry.addInterceptor(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        SessionLocaleResolver localeResolver = <span class="hljs-keyword">new</span> SessionLocaleResolver();</span><br><span class="line">        localeResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);</span><br><span class="line">        <span class="hljs-keyword">return</span> localeResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段配置中，我们首先提供了一个 SessionLocaleResolver 实例，这个实例会替换掉默认的 AcceptHeaderLocaleResolver，不同于 AcceptHeaderLocaleResolver 通过请求头来判断当前的环境信息，SessionLocaleResolver 将客户端的 Locale 保存到 HttpSession 对象中，并且可以进行修改（这意味着当前环境信息，前端给浏览器发送一次即可记住，只要 session 有效，浏览器就不必再次告诉服务端当前的环境信息）。</p><p>另外我们还配置了一个拦截器，这个拦截器会拦截请求中 key 为 lang 的参数（不配置的话是 locale），这个参数则指定了当前的环境信息。</p><p>好了，配置完成后，启动项目，访问方式如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-4.png?aa=123" alt></p><p>我们通过在请求中添加 lang 来指定当前环境信息。这个指定只需要一次即可，也就是说，在 session 不变的情况下，下次请求可以不必带上 lang 参数，服务端已经知道当前的环境信息了。</p><p>CookieLocaleResolver 也是类似用法，不再赘述。</p><h3 id="2-3-其他自定义"><a href="#2-3-其他自定义" class="headerlink" title="2.3 其他自定义"></a>2.3 其他自定义</h3><p>默认情况下，我们的配置文件放在 resources 目录下，如果大家想自定义，也是可以的，例如定义在 resources/i18n 目录下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-5.png" alt></p><p>但是这种定义方式系统就不知道去哪里加载配置文件了，此时还需要 application.properties 中进行额外配置(注意这是一个相对路径)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.basename=i18n/messages</span><br></pre></td></tr></table></figure><p>另外还有一些编码格式的配置等，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.cache-duration=3600</span><br><span class="line">spring.messages.encoding=UTF-8</span><br><span class="line">spring.messages.fallback-to-system-locale=true</span><br></pre></td></tr></table></figure><p>spring.messages.cache-duration 表示 messages 文件的缓存失效时间，如果不配置则缓存一直有效。</p><p>spring.messages.fallback-to-system-locale 属性则略显神奇，网上竟然看不到一个明确的答案，后来翻了一会源码才看出端倪。</p><p>这个属性的作用在 <code>org.springframework.context.support.AbstractResourceBasedMessageSource#getDefaultLocale</code> 方法中生效：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Locale <span class="hljs-title">getDefaultLocale</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaultLocale != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fallbackToSystemLocale) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Locale.getDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码可以看出，在找不到当前系统对应的资源文件时，如果该属性为 true，则会默认查找当前系统对应的资源文件，否则就返回 null，返回 null 之后，最终又会调用到系统默认的 messages.properties 文件。</p><h2 id="3-LocaleResolver"><a href="#3-LocaleResolver" class="headerlink" title="3.LocaleResolver"></a>3.LocaleResolver</h2><p>国际化这块主要涉及到的组件是 LocaleResolver，这是一个开放的接口，官方默认提供了四个实现。当前该使用什么环境，主要是通过 LocaleResolver 来进行解析的。</p><p><strong>LocaleResolver</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LocaleResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLocale</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里两个方法：</p><ol><li>resolveLocale：根据当前请求解析器出 Locale 对象。</li><li>设置 Locale 对象。</li></ol><p>我们来看看 LocaleResolver 的继承关系：</p><p><img src="http://img.itboyhub.com/2021/02/20210401223028.png" alt></p><p>虽然中间有几个抽象类，不过最终负责实现的其实就四个：</p><ul><li>AcceptHeaderLocaleResolver：根据请求头中的 Accept-Language 字段来确定当前的区域语言等。</li><li>SessionLocaleResolver：根据请求参数来确定区域语言等，确定后会保存在 Session 中，只要 Session 不变，Locale 对象就一直有效。</li><li>CookieLocaleResolver：根据请求参数来确定区域语言等，确定后会保存在 Cookie 中，只要 Session 不变，Locale 对象就一直有效。</li><li>FixedLocaleResolver：配置时直接提供一个 Locale 对象，以后不能修改。</li></ul><p>接下来我们就对这几个类逐一进行分析。</p><h3 id="3-1-AcceptHeaderLocaleResolver"><a href="#3-1-AcceptHeaderLocaleResolver" class="headerlink" title="3.1 AcceptHeaderLocaleResolver"></a>3.1 AcceptHeaderLocaleResolver</h3><p>AcceptHeaderLocaleResolver 直接实现了 LocaleResolver 接口，我们来看它的 resolveLocale 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Locale defaultLocale = getDefaultLocale();</span><br><span class="line"><span class="hljs-keyword">if</span> (defaultLocale != <span class="hljs-keyword">null</span> &amp;&amp; request.getHeader(<span class="hljs-string">"Accept-Language"</span>) == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">Locale requestLocale = request.getLocale();</span><br><span class="line">List&lt;Locale&gt; supportedLocales = getSupportedLocales();</span><br><span class="line"><span class="hljs-keyword">if</span> (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> requestLocale;</span><br><span class="line">&#125;</span><br><span class="line">Locale supportedLocale = findSupportedLocale(request, supportedLocales);</span><br><span class="line"><span class="hljs-keyword">if</span> (supportedLocale != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> supportedLocale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> (defaultLocale != <span class="hljs-keyword">null</span> ? defaultLocale : requestLocale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先去获取默认的 Locale 对象。</li><li>如果存在默认的 Locale 对象，并且请求头中没有设置 <code>Accept-Language</code> 字段，则直接返回默认的 Locale。</li><li>从 request 中取出当前的 Locale 对象，然后查询出支持的 supportedLocales，如果 supportedLocales 或者 supportedLocales 中包含 requestLocale，则直接返回 requestLocale。</li><li>如果前面还是没有匹配成功的，则从 request 中取出 locales 集合，然后再去和支持的 locale 进行比对，选择匹配成功的 locale 返回。</li><li>如果前面都没能返回，则判断 defaultLocale 是否为空，如果不为空，就返回 defaultLocale，否则返回 defaultLocale。</li></ol><p>再来看看它的 setLocale 方法，直接抛出异常，意味着通过请求头处理 Locale 是不允许修改的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocale</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="hljs-string">"Cannot change HTTP accept header - use a different locale resolution strategy"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-SessionLocaleResolver"><a href="#3-2-SessionLocaleResolver" class="headerlink" title="3.2 SessionLocaleResolver"></a>3.2 SessionLocaleResolver</h3><p>SessionLocaleResolver 的实现多了一个抽象类 AbstractLocaleContextResolver，AbstractLocaleContextResolver 中增加了对 TimeZone 的支持，我们先来看下 AbstractLocaleContextResolver：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractLocaleContextResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLocaleResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LocaleContextResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> TimeZone defaultTimeZone;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDefaultTimeZone</span><span class="hljs-params">(@Nullable TimeZone defaultTimeZone)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.defaultTimeZone = defaultTimeZone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> TimeZone <span class="hljs-title">getDefaultTimeZone</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultTimeZone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Locale locale = resolveLocaleContext(request).getLocale();</span><br><span class="line"><span class="hljs-keyword">return</span> (locale != <span class="hljs-keyword">null</span> ? locale : request.getLocale());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocale</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale)</span> </span>&#123;</span><br><span class="line">setLocaleContext(request, response, (locale != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> SimpleLocaleContext(locale) : <span class="hljs-keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，多了一个 TimeZone 属性。从请求中解析出 Locale 还是调用了 resolveLocaleContext 方法，该方法在子类中被实现，另外调用 setLocaleContext 方法设置 Locale，该方法的实现也在子类中。</p><p>我们来看下它的子类 SessionLocaleResolver：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Locale locale = (Locale) WebUtils.getSessionAttribute(request, <span class="hljs-keyword">this</span>.localeAttributeName);</span><br><span class="line"><span class="hljs-keyword">if</span> (locale == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">locale = determineDefaultLocale(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> locale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接从 Session 中获取 Locale，默认的属性名是 <code>SessionLocaleResolver.class.getName() + &quot;.LOCALE&quot;</code>，如果 session 中不存在 Locale 信息，则调用 determineDefaultLocale 方法去加载 Locale，该方法会首先找到 defaultLocale，如果 defaultLocale 不为 null 就直接返回，否则就从 request 中获取 Locale 返回。</p><p>再来看 setLocaleContext 方法，就是将解析出来的 Locale 保存起来。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocaleContext</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable LocaleContext localeContext)</span> </span>&#123;</span><br><span class="line">Locale locale = <span class="hljs-keyword">null</span>;</span><br><span class="line">TimeZone timeZone = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (localeContext != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">locale = localeContext.getLocale();</span><br><span class="line"><span class="hljs-keyword">if</span> (localeContext <span class="hljs-keyword">instanceof</span> TimeZoneAwareLocaleContext) &#123;</span><br><span class="line">timeZone = ((TimeZoneAwareLocaleContext) localeContext).getTimeZone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">WebUtils.setSessionAttribute(request, <span class="hljs-keyword">this</span>.localeAttributeName, locale);</span><br><span class="line">WebUtils.setSessionAttribute(request, <span class="hljs-keyword">this</span>.timeZoneAttributeName, timeZone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存到 Session 中即可。大家可以看到，这种保存方式其实和我们前面演示的自己保存代码基本一致，殊途同归。</p><h3 id="3-3-FixedLocaleResolver"><a href="#3-3-FixedLocaleResolver" class="headerlink" title="3.3 FixedLocaleResolver"></a>3.3 FixedLocaleResolver</h3><p>FixedLocaleResolver 有三个构造方法，无论调用哪一个，都会配置默认的 Locale：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FixedLocaleResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">setDefaultLocale(Locale.getDefault());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FixedLocaleResolver</span><span class="hljs-params">(Locale locale)</span> </span>&#123;</span><br><span class="line">setDefaultLocale(locale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FixedLocaleResolver</span><span class="hljs-params">(Locale locale, TimeZone timeZone)</span> </span>&#123;</span><br><span class="line">setDefaultLocale(locale);</span><br><span class="line">setDefaultTimeZone(timeZone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要么自己传 Locale 进来，要么调用 Locale.getDefault() 方法获取默认的 Locale。</p><p>再来看 resolveLocale 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Locale locale = getDefaultLocale();</span><br><span class="line"><span class="hljs-keyword">if</span> (locale == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">locale = Locale.getDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> locale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应该就不用解释了吧。</p><p>需要注意的是它的 setLocaleContext 方法，直接抛异常出来，也就意味着 Locale 在后期不能被修改。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocaleContext</span><span class="hljs-params">( HttpServletRequest request, @Nullable HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable LocaleContext localeContext)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Cannot change fixed locale - use a different locale resolution strategy"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-CookieLocaleResolver"><a href="#3-4-CookieLocaleResolver" class="headerlink" title="3.4 CookieLocaleResolver"></a>3.4 CookieLocaleResolver</h3><p>CookieLocaleResolver 和 SessionLocaleResolver 比较类似，只不过存储介质变成了 Cookie，其他都差不多，松哥就不再重复介绍了。</p><h2 id="4-附录"><a href="#4-附录" class="headerlink" title="4.附录"></a>4.附录</h2><p>搜刮了一个语言简称表，分享给各位小伙伴：</p><table><thead><tr><th style="text-align:left">语言</th><th style="text-align:left">简称</th></tr></thead><tbody><tr><td style="text-align:left">简体中文(中国)</td><td style="text-align:left">zh_CN</td></tr><tr><td style="text-align:left">繁体中文(中国台湾)</td><td style="text-align:left">zh_TW</td></tr><tr><td style="text-align:left">繁体中文(中国香港)</td><td style="text-align:left">zh_HK</td></tr><tr><td style="text-align:left">英语(中国香港)</td><td style="text-align:left">en_HK</td></tr><tr><td style="text-align:left">英语(美国)</td><td style="text-align:left">en_US</td></tr><tr><td style="text-align:left">英语(英国)</td><td style="text-align:left">en_GB</td></tr><tr><td style="text-align:left">英语(全球)</td><td style="text-align:left">en_WW</td></tr><tr><td style="text-align:left">英语(加拿大)</td><td style="text-align:left">en_CA</td></tr><tr><td style="text-align:left">英语(澳大利亚)</td><td style="text-align:left">en_AU</td></tr><tr><td style="text-align:left">英语(爱尔兰)</td><td style="text-align:left">en_IE</td></tr><tr><td style="text-align:left">英语(芬兰)</td><td style="text-align:left">en_FI</td></tr><tr><td style="text-align:left">芬兰语(芬兰)</td><td style="text-align:left">fi_FI</td></tr><tr><td style="text-align:left">英语(丹麦)</td><td style="text-align:left">en_DK</td></tr><tr><td style="text-align:left">丹麦语(丹麦)</td><td style="text-align:left">da_DK</td></tr><tr><td style="text-align:left">英语(以色列)</td><td style="text-align:left">en_IL</td></tr><tr><td style="text-align:left">希伯来语(以色列)</td><td style="text-align:left">he_IL</td></tr><tr><td style="text-align:left">英语(南非)</td><td style="text-align:left">en_ZA</td></tr><tr><td style="text-align:left">英语(印度)</td><td style="text-align:left">en_IN</td></tr><tr><td style="text-align:left">英语(挪威)</td><td style="text-align:left">en_NO</td></tr><tr><td style="text-align:left">英语(新加坡)</td><td style="text-align:left">en_SG</td></tr><tr><td style="text-align:left">英语(新西兰)</td><td style="text-align:left">en_NZ</td></tr><tr><td style="text-align:left">英语(印度尼西亚)</td><td style="text-align:left">en_ID</td></tr><tr><td style="text-align:left">英语(菲律宾)</td><td style="text-align:left">en_PH</td></tr><tr><td style="text-align:left">英语(泰国)</td><td style="text-align:left">en_TH</td></tr><tr><td style="text-align:left">英语(马来西亚)</td><td style="text-align:left">en_MY</td></tr><tr><td style="text-align:left">英语(阿拉伯)</td><td style="text-align:left">en_XA</td></tr><tr><td style="text-align:left">韩文(韩国)</td><td style="text-align:left">ko_KR</td></tr><tr><td style="text-align:left">日语(日本)</td><td style="text-align:left">ja_JP</td></tr><tr><td style="text-align:left">荷兰语(荷兰)</td><td style="text-align:left">nl_NL</td></tr><tr><td style="text-align:left">荷兰语(比利时)</td><td style="text-align:left">nl_BE</td></tr><tr><td style="text-align:left">葡萄牙语(葡萄牙)</td><td style="text-align:left">pt_PT</td></tr><tr><td style="text-align:left">葡萄牙语(巴西)</td><td style="text-align:left">pt_BR</td></tr><tr><td style="text-align:left">法语(法国)</td><td style="text-align:left">fr_FR</td></tr><tr><td style="text-align:left">法语(卢森堡)</td><td style="text-align:left">fr_LU</td></tr><tr><td style="text-align:left">法语(瑞士)</td><td style="text-align:left">fr_CH</td></tr><tr><td style="text-align:left">法语(比利时)</td><td style="text-align:left">fr_BE</td></tr><tr><td style="text-align:left">法语(加拿大)</td><td style="text-align:left">fr_CA</td></tr><tr><td style="text-align:left">西班牙语(拉丁美洲)</td><td style="text-align:left">es_LA</td></tr><tr><td style="text-align:left">西班牙语(西班牙)</td><td style="text-align:left">es_ES</td></tr><tr><td style="text-align:left">西班牙语(阿根廷)</td><td style="text-align:left">es_AR</td></tr><tr><td style="text-align:left">西班牙语(美国)</td><td style="text-align:left">es_US</td></tr><tr><td style="text-align:left">西班牙语(墨西哥)</td><td style="text-align:left">es_MX</td></tr><tr><td style="text-align:left">西班牙语(哥伦比亚)</td><td style="text-align:left">es_CO</td></tr><tr><td style="text-align:left">西班牙语(波多黎各)</td><td style="text-align:left">es_PR</td></tr><tr><td style="text-align:left">德语(德国)</td><td style="text-align:left">de_DE</td></tr><tr><td style="text-align:left">德语(奥地利)</td><td style="text-align:left">de_AT</td></tr><tr><td style="text-align:left">德语(瑞士)</td><td style="text-align:left">de_CH</td></tr><tr><td style="text-align:left">俄语(俄罗斯)</td><td style="text-align:left">ru_RU</td></tr><tr><td style="text-align:left">意大利语(意大利)</td><td style="text-align:left">it_IT</td></tr><tr><td style="text-align:left">希腊语(希腊)</td><td style="text-align:left">el_GR</td></tr><tr><td style="text-align:left">挪威语(挪威)</td><td style="text-align:left">no_NO</td></tr><tr><td style="text-align:left">匈牙利语(匈牙利)</td><td style="text-align:left">hu_HU</td></tr><tr><td style="text-align:left">土耳其语(土耳其)</td><td style="text-align:left">tr_TR</td></tr><tr><td style="text-align:left">捷克语(捷克共和国)</td><td style="text-align:left">cs_CZ</td></tr><tr><td style="text-align:left">斯洛文尼亚语</td><td style="text-align:left">sl_SL</td></tr><tr><td style="text-align:left">波兰语(波兰)</td><td style="text-align:left">pl_PL</td></tr><tr><td style="text-align:left">瑞典语(瑞典)</td><td style="text-align:left">sv_SE</td></tr><tr><td style="text-align:left">西班牙语(智利)</td><td style="text-align:left">es_CL</td></tr></tbody></table><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天主要和小伙伴们聊了下 SpringMVC 中的国际化问题，以及 LocaleResolver 相关的源码，相信大家对 SpringMVC 的理解应该又更近一步了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥之前写过 Spring Boot 国际化的问题，不过那一次没讲源码，这次咱们整点源码来深入理解下这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
      <category term="I18N" scheme="http://www.javaboy.org/tags/I18N/"/>
    
  </entry>
  
  <entry>
    <title>什么年代了，你还不知道 Servlet3.0 中的文件上传方式？</title>
    <link href="http://www.javaboy.org/2021/0415/servlet3.0-fileupload.html"/>
    <id>http://www.javaboy.org/2021/0415/servlet3.0-fileupload.html</id>
    <published>2021-04-15T09:30:35.000Z</published>
    <updated>2021-04-15T09:31:39.747Z</updated>
    
    <content type="html"><![CDATA[<p>其实文件上传这块松哥之前和大家聊过很多次了，这次因为最近正在进行 SpringMVC 的源码分析，所以又再次把这个话题拉出来“鞭尸”，不过这次松哥想从源码角度来聊聊这个话题。</p><a id="more"></a><p>理解源码的前提是先会用，所以我们还是先来看看用法，然后再来分析源码。</p><h2 id="1-两种文件解析方案"><a href="#1-两种文件解析方案" class="headerlink" title="1.两种文件解析方案"></a>1.两种文件解析方案</h2><p>对于上传文件的请求，SpringMVC 中目前共有两种不同的解析方案：</p><ul><li>StandardServletMultipartResolver</li><li>CommonsMultipartResolver</li></ul><p>StandardServletMultipartResolver 支持 Servlet3.0 中标准的文件上传方案，使用非常简单；CommonsMultipartResolver 则需要结合 Apache Commons fileupload 组件一起使用，这种方式兼容低版本的 Servlet。</p><p><strong>StandardServletMultipartResolver</strong></p><p>先来回顾下 StandardServletMultipartResolver 的用法。</p><p>使用 StandardServletMultipartResolver，可以直接通过 HttpServletRequest 自带的 getPart 方法获取上传文件并保存，这是一种标准的操作方式，这种方式也不用添加任何额外的依赖，只需要确保 Servlet 的版本在 3.0 之上即可。</p><p>首先我们需要为 Servlet 配置 <code>multipart-config</code>，哪个 Servlet 负责处理上传文件，就为哪个 Servlet 配置 <code>multipart-config</code>。在 SpringMVC 中，我们的请求都是通过 DispatcherServlet 进行分发的，所以我们就为 DispatcherServlet 配置 <code>multipart-config</code>。</p><p>配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">serv</span></span></span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">multipart-config</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">max-file-size</span>&gt;</span>1024<span class="hljs-tag">&lt;/<span class="hljs-name">max-file-size</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">max-request-size</span>&gt;</span>10240<span class="hljs-tag">&lt;/<span class="hljs-name">max-request-size</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">multipart-config</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 SpringMVC 的配置文件中提供一个 StandardServletMultipartResolver 实例，注意该实例的 id 必须为 multipartResolver（具体原因参见：<a href="https://mp.weixin.qq.com/s/IeMOfnXhOX5RCf4i5Xsdzw" target="_blank" rel="noopener">SpringMVC 初始化流程分析</a>一文）。</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.multipart.support.StandardServletMultipartResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"multipartResolver"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成后，我们就可以开发一个文件上传接口了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController</span> </span>&#123;</span><br><span class="line">    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"/yyyy/MM/dd/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">        File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">            folder.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        String oldName = file.getOriginalFilename();</span><br><span class="line">        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));</span><br><span class="line">            <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload2</span><span class="hljs-params">(HttpServletRequest req)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        StandardServletMultipartResolver resolver = <span class="hljs-keyword">new</span> StandardServletMultipartResolver();</span><br><span class="line">        MultipartFile file = resolver.resolveMultipart(req).getFile(<span class="hljs-string">"file"</span>);</span><br><span class="line">        String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">        File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">            folder.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        String oldName = file.getOriginalFilename();</span><br><span class="line">        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));</span><br><span class="line">            <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload3"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload3</span><span class="hljs-params">(HttpServletRequest req)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String other_param = req.getParameter(<span class="hljs-string">"other_param"</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"other_param = "</span> + other_param);</span><br><span class="line">        String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">        File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">            folder.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        Part filePart = req.getPart(<span class="hljs-string">"file"</span>);</span><br><span class="line">        String oldName = filePart.getSubmittedFileName();</span><br><span class="line">        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            filePart.write(realPath + newName);</span><br><span class="line">            <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里一共提供了三个文件上传接口，其实最终都是通过 StandardServletMultipartResolver 进行处理的。</p><ol><li>第一个接口是我们在 SpringMVC 框架中常见的一种文件上传处理方式，直接在参数中写上 MultipartFile，这个 MultipartFile 其实就是从当前请求中解析出来的，具体负责参数解析工作的就是 RequestParamMethodArgumentResolver。</li><li>第二个接口其实是一种古老的文件上传实现方案，参数就是普通的 HttpServletRequest，然后在参数里边，我们再手动利用 StandardServletMultipartResolver 实例进行解析（<strong>这种情况可以不用自己 new 一个 StandardServletMultipartResolver 实例，直接将 Spring 容器中的注入进来即可</strong>）。</li><li>第三个接口我们就利用了 Servlet3.0 的 API，调用 getPart 获取文件，然后再调用对象的 write 方法将文件写出去即可。</li></ol><p>大致上一看，感觉办法还挺多，其实仔细看，万变不离其宗，一会我们看完源码，相信小伙伴们还能变化出更多写法。</p><p><strong>CommonsMultipartResolver</strong></p><p>CommonsMultipartResolver 估计很多人都比较熟悉，这个兼容性很好，就是有点过时了。使用 CommonsMultipartResolver 需要我们首先引入 commons-fileupload 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 SpringMVC 的配置文件中提供 CommonsMultipartResolver 实例，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"multipartResolver"</span>&gt;</span>--&gt;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来开发文件上传接口就行了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">    File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String oldName = file.getOriginalFilename();</span><br><span class="line">    String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));</span><br><span class="line">        <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就没啥好说，比较容易。</p><p>文件上传这块松哥之前在视频中也和大家分享过，公号后台回复 ssm 可以查看视频详情。</p><p>用法掌握了，接下来我们来看原理。</p><h2 id="2-StandardServletMultipartResolver"><a href="#2-StandardServletMultipartResolver" class="headerlink" title="2.StandardServletMultipartResolver"></a>2.StandardServletMultipartResolver</h2><p>不废话，直接来看看源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardServletMultipartResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MultipartResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> resolveLazily = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResolveLazily</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> resolveLazily)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.resolveLazily = resolveLazily;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMultipart</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> StringUtils.startsWithIgnoreCase(request.getContentType(), <span class="hljs-string">"multipart/"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> MultipartHttpServletRequest <span class="hljs-title">resolveMultipart</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StandardMultipartHttpServletRequest(request, <span class="hljs-keyword">this</span>.resolveLazily);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanupMultipart</span><span class="hljs-params">(MultipartHttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!(request <span class="hljs-keyword">instanceof</span> AbstractMultipartHttpServletRequest) ||</span><br><span class="line">((AbstractMultipartHttpServletRequest) request).isResolved()) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : request.getParts()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (request.getFile(part.getName()) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">part.delete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里满打满算就四个方法，其中一个还是 set 方法，我们来看另外三个功能性方法：</p><ol><li>isMultipart：这个方法主要是用来判断当前请求是不是文件上传请求，这里的判断思路很简单，就看请求的 content-type 是不是以 <code>multipart/</code> 开头，如果是，则这就是一个文件上传请求，否则就不是文件上传请求。</li><li>resolveMultipart：这个方法负责将当前请求封装一个 StandardMultipartHttpServletRequest 对象然后返回。</li><li>cleanupMultipart：这个方法负责善后，主要完成了缓存的清理工作。</li></ol><p>在这个过程中涉及到 StandardMultipartHttpServletRequest 对象，我们也来稍微说一下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StandardMultipartHttpServletRequest</span><span class="hljs-params">(HttpServletRequest request, <span class="hljs-keyword">boolean</span> lazyParsing)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (!lazyParsing) &#123;</span><br><span class="line">parseRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseRequest</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Collection&lt;Part&gt; parts = request.getParts();</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartParameterNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(parts.size());</span><br><span class="line">MultiValueMap&lt;String, MultipartFile&gt; files = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(parts.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">String headerValue = part.getHeader(HttpHeaders.CONTENT_DISPOSITION);</span><br><span class="line">ContentDisposition disposition = ContentDisposition.parse(headerValue);</span><br><span class="line">String filename = disposition.getFilename();</span><br><span class="line"><span class="hljs-keyword">if</span> (filename != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (filename.startsWith(<span class="hljs-string">"=?"</span>) &amp;&amp; filename.endsWith(<span class="hljs-string">"?="</span>)) &#123;</span><br><span class="line">filename = MimeDelegate.decode(filename);</span><br><span class="line">&#125;</span><br><span class="line">files.add(part.getName(), <span class="hljs-keyword">new</span> StandardMultipartFile(part, filename));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartParameterNames.add(part.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">setMultipartFiles(files);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleParseFailure(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StandardMultipartHttpServletRequest 对象在构建的过程中，会自动进行请求解析，调用 getParts 方法获取所有的项，然后进行判断，将文件和普通参数分别保存下来备用。</p><p>这块的逻辑比较简单。</p><h2 id="3-CommonsMultipartResolver"><a href="#3-CommonsMultipartResolver" class="headerlink" title="3.CommonsMultipartResolver"></a>3.CommonsMultipartResolver</h2><p>再来看 CommonsMultipartResolver。</p><p>先来看它的 isMultipart 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMultipart</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ServletFileUpload.isMultipartContent(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMultipartContent</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!POST_METHOD.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> FileUploadBase.isMultipartContent(<span class="hljs-keyword">new</span> ServletRequestContext(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletFileUpload.isMultipartContent 方法其实就在我们引入的 <code>commons-fileupload</code> 包中。它的判断逻辑分两步：首先检查是不是 POST 请求，然后检查 content-type 是不是以 <code>multipart/</code> 开始。</p><p>再来看它的 resolveMultipart 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> MultipartHttpServletRequest <span class="hljs-title">resolveMultipart</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resolveLazily) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultMultipartHttpServletRequest(request) &#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeMultipart</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">MultipartParsingResult parsingResult = parseRequest(request);</span><br><span class="line">setMultipartFiles(parsingResult.getMultipartFiles());</span><br><span class="line">setMultipartParameters(parsingResult.getMultipartParameters());</span><br><span class="line">setMultipartParameterContentTypes(parsingResult.getMultipartParameterContentTypes());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">MultipartParsingResult parsingResult = parseRequest(request);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultMultipartHttpServletRequest(request, parsingResult.getMultipartFiles(),</span><br><span class="line">parsingResult.getMultipartParameters(), parsingResult.getMultipartParameterContentTypes());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 resolveLazily 属性值，选择两种不同的策略将当前对象重新构建成一个 DefaultMultipartHttpServletRequest 对象。如果 resolveLazily 为 true，则在 initializeMultipart 方法中进行请求解析，否则先解析，再构建 DefaultMultipartHttpServletRequest 对象。</p><p>具体的解析方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> MultipartParsingResult <span class="hljs-title">parseRequest</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line">String encoding = determineEncoding(request);</span><br><span class="line">FileUpload fileUpload = prepareFileUpload(encoding);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">List&lt;FileItem&gt; fileItems = ((ServletFileUpload) fileUpload).parseRequest(request);</span><br><span class="line"><span class="hljs-keyword">return</span> parseFileItems(fileItems, encoding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (FileUploadBase.SizeLimitExceededException ex) &#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> MultipartParsingResult <span class="hljs-title">parseFileItems</span><span class="hljs-params">(List&lt;FileItem&gt; fileItems, String encoding)</span> </span>&#123;</span><br><span class="line">MultiValueMap&lt;String, MultipartFile&gt; multipartFiles = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">Map&lt;String, String[]&gt; multipartParameters = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, String&gt; multipartParameterContentTypes = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (FileItem fileItem : fileItems) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (fileItem.isFormField()) &#123;</span><br><span class="line">String value;</span><br><span class="line">String partEncoding = determineEncoding(fileItem.getContentType(), encoding);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">value = fileItem.getString(partEncoding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (UnsupportedEncodingException ex) &#123;</span><br><span class="line">value = fileItem.getString();</span><br><span class="line">&#125;</span><br><span class="line">String[] curParam = multipartParameters.get(fileItem.getFieldName());</span><br><span class="line"><span class="hljs-keyword">if</span> (curParam == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">multipartParameters.put(fileItem.getFieldName(), <span class="hljs-keyword">new</span> String[] &#123;value&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">String[] newParam = StringUtils.addStringToArray(curParam, value);</span><br><span class="line">multipartParameters.put(fileItem.getFieldName(), newParam);</span><br><span class="line">&#125;</span><br><span class="line">multipartParameterContentTypes.put(fileItem.getFieldName(), fileItem.getContentType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">CommonsMultipartFile file = createMultipartFile(fileItem);</span><br><span class="line">multipartFiles.add(file.getName(), file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MultipartParsingResult(multipartFiles, multipartParameters, multipartParameterContentTypes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的解析就是首先获取到 FileItem 集合，然后调用 parseFileItems 方法进行进一步的解析。在进一步的解析中，会首先判断这是文件还是普通参数，如果是普通参数，则保存到 multipartParameters 中，具体保存过程中还会判断是否为数组，然后再将参数的 ContentType 保存到 multipartParameterContentTypes 中，文件则保存到 multipartFiles 中，最后由三个 Map 构成一个 MultipartParsingResult 对象并返回。</p><p>至此，StandardServletMultipartResolver 和 CommonsMultipartResolver 源码就和大家说完了，可以看到，还是比较容易的。</p><h2 id="4-解析流程"><a href="#4-解析流程" class="headerlink" title="4.解析流程"></a>4.解析流程</h2><p>最后，我们再来梳理一下解析流程。</p><p>以如下接口为例（因为在实际开发中一般都是通过如下方式上传文件）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">    File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String oldName = file.getOriginalFilename();</span><br><span class="line">    String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));</span><br><span class="line">        <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 MultipartFile 对象主要就是在参数解析器中获取的，关于参数解析器，大家可以参考：<a href="https://mp.weixin.qq.com/s/qsS6Dwr6eXx07i5dhn8FEA" target="_blank" rel="noopener">深入分析 SpringMVC 参数解析器</a> 一文，这里涉及到的参数解析器是 RequestParamMethodArgumentResolver。</p><p>在 RequestParamMethodArgumentResolver#resolveName 方法中有如下一行代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mpArg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会进行请求解析，返回 MultipartFile 对象或者 MultipartFile 数组。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">resolveMultipartArgument</span><span class="hljs-params">(String name, MethodParameter parameter, HttpServletRequest request)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MultipartHttpServletRequest multipartRequest =</span><br><span class="line">WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">boolean</span> isMultipart = (multipartRequest != <span class="hljs-keyword">null</span> || isMultipartContent(request));</span><br><span class="line"><span class="hljs-keyword">if</span> (MultipartFile.class == parameter.getNestedParameterType()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequest == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">multipartRequest = <span class="hljs-keyword">new</span> StandardMultipartHttpServletRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> multipartRequest.getFile(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMultipartFileCollection(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequest == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">multipartRequest = <span class="hljs-keyword">new</span> StandardMultipartHttpServletRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line"><span class="hljs-keyword">return</span> (!files.isEmpty() ? files : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMultipartFileArray(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequest == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">multipartRequest = <span class="hljs-keyword">new</span> StandardMultipartHttpServletRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line"><span class="hljs-keyword">return</span> (!files.isEmpty() ? files.toArray(<span class="hljs-keyword">new</span> MultipartFile[<span class="hljs-number">0</span>]) : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Part.class == parameter.getNestedParameterType()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getPart(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPartCollection(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Part&gt; parts = resolvePartList(request, name);</span><br><span class="line"><span class="hljs-keyword">return</span> (!parts.isEmpty() ? parts : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPartArray(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Part&gt; parts = resolvePartList(request, name);</span><br><span class="line"><span class="hljs-keyword">return</span> (!parts.isEmpty() ? parts.toArray(<span class="hljs-keyword">new</span> Part[<span class="hljs-number">0</span>]) : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> UNRESOLVABLE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取 multipartRequest 对象，然后再从中获取文件或者文件数组。如果我们使用 StandardServletMultipartResolver 做文件上传，这里获取到的 multipartRequest 就是 StandardMultipartHttpServletRequest；如果我们使用 CommonsMultipartResolver 做文件上传，这里获取到的 multipartRequest 就是 DefaultMultipartHttpServletRequest。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天就和大家简单分析了下两个文件上传组件的源码，至此，SpringMVC 九大组件我们已经分析了 7 个啦，还剩两个，即将完结，完结后松哥会整理成 pdf 分享给大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实文件上传这块松哥之前和大家聊过很多次了，这次因为最近正在进行 SpringMVC 的源码分析，所以又再次把这个话题拉出来“鞭尸”，不过这次松哥想从源码角度来聊聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 项目总是创建失败，这几个备选方案一定要收藏</title>
    <link href="http://www.javaboy.org/2021/0414/spring-boot-starter.html"/>
    <id>http://www.javaboy.org/2021/0414/spring-boot-starter.html</id>
    <published>2021-04-14T09:08:56.000Z</published>
    <updated>2021-04-14T09:11:28.013Z</updated>
    
    <content type="html"><![CDATA[<p>松哥这两天老遇到一个问题，用 IDEA 创建 Spring Boot 项目总是失败，搞得我很郁闷，一气之下收集了几个可用的 Spring Boot 构建接口，妈妈再也不用担心我 Spring Boot 项目创建失败了！</p><a id="more"></a><h2 id="1-青铜"><a href="#1-青铜" class="headerlink" title="1.青铜"></a>1.青铜</h2><p>创建地址直接用默认的 <a href="https://start.spring.io，这个是最容易失败的了，失败最最主要的原因还是因为这是一个国外的网站，由于众所周知的原因，这些网站访问起来并不太稳定。" target="_blank" rel="noopener">https://start.spring.io，这个是最容易失败的了，失败最最主要的原因还是因为这是一个国外的网站，由于众所周知的原因，这些网站访问起来并不太稳定。</a></p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210413220924.png" alt></p><h2 id="2-白银"><a href="#2-白银" class="headerlink" title="2.白银"></a>2.白银</h2><p>那么国内有没有类似的网站呢？当然有！阿里巴巴就搞了一个：<a href="https://start.aliyun.com，我们在构建项目时可以直接填入" target="_blank" rel="noopener">https://start.aliyun.com，我们在构建项目时可以直接填入</a> <a href="https://start.aliyun.com" target="_blank" rel="noopener">https://start.aliyun.com</a> 即可，像下面这样：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210414083251.png" alt></p><p>但是在选择依赖的时候会有一点问题，如下图：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210414083333.png" alt></p><p>问题主要是两方面的：</p><ol><li>项目版本更新慢，目前 Spring Boot 最新稳定版是 2.4.4，但是这里只能选择到 2.4.1。</li><li>项目构建成功后，没有 parent，而是通过自定义 dependenceManagement 节点来统一处理版本问题，用惯了 parent 的小伙伴可能对此不太习惯，而且这种写法也需要开发者做一些修改。</li></ol><p>所以如果使用 <a href="https://start.aliyun.com" target="_blank" rel="noopener">https://start.aliyun.com</a> 创建项目的话，很多时候并不能一步到位，创建完了还要自己再手动调整下。</p><h2 id="3-黄金"><a href="#3-黄金" class="headerlink" title="3.黄金"></a>3.黄金</h2><p>那就没有跟 <a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a> 一模一样的国内站点吗？有！那就是 Spring Boot 中文社区搭建的 <a href="https://start.springboot.io，这个服务器架设在香港，大陆访问非常稳定，项目创建成功率很高。" target="_blank" rel="noopener">https://start.springboot.io，这个服务器架设在香港，大陆访问非常稳定，项目创建成功率很高。</a></p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210414083726.png" alt></p><p><a href="https://start.springboot.io" target="_blank" rel="noopener">https://start.springboot.io</a> 站点的使用体验就和 <a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a> 一模一样，我目前就主要使用这种方案。</p><h2 id="4-铂金"><a href="#4-铂金" class="headerlink" title="4.铂金"></a>4.铂金</h2><p>有的时候用 IDEA 会创建失败，但是直接打开网页可以创建，创建完成后，将创建好的项目下载下来，然后解压，再用 IDEA 打开。</p><p>这种方式比较麻烦，但是好处是比较可靠，有两个创建的网页可选：</p><ul><li><a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a></li><li><a href="https://start.springboot.io" target="_blank" rel="noopener">https://start.springboot.io</a></li></ul><h2 id="5-钻石"><a href="#5-钻石" class="headerlink" title="5.钻石"></a>5.钻石</h2><p>如果由于种种情况，上面的方案都用不了，那就只能使出撒手锏了。</p><p>Spring Boot 就是一个 Maven 功能而已，所以我们就手动创建 Maven 工程，手动添加依赖，添加项目启动类等等，这个操作也不难。</p><p>这是一个兜底的方案。</p><h2 id="6-王者"><a href="#6-王者" class="headerlink" title="6.王者"></a>6.王者</h2><p>这个留给小伙伴们，看看小伙伴们有没有“王者”方案！评论区见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥这两天老遇到一个问题，用 IDEA 创建 Spring Boot 项目总是失败，搞得我很郁闷，一气之下收集了几个可用的 Spring Boot 构建接口，妈妈再也不用担心我 Spring Boot 项目创建失败了！&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 异常处理体系深入分析</title>
    <link href="http://www.javaboy.org/2021/0414/73d3fb01.html"/>
    <id>http://www.javaboy.org/2021/0414/73d3fb01.html</id>
    <published>2021-04-14T09:08:36.000Z</published>
    <updated>2021-04-14T09:12:27.534Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>SpringMVC 中针对异常问题有一套完整的处理体系，这套体系非常好用，今天松哥就花点时间来和大家聊一聊 SpringMVC 中的异常处理体系，我们把 SpringMVC 中的异常体系从头到尾梳理一下。</p><a id="more"></a><h2 id="1-异常解析器概览"><a href="#1-异常解析器概览" class="headerlink" title="1.异常解析器概览"></a>1.异常解析器概览</h2><p>在 SpringMVC 的异常体系中，处于最顶层的大 Boss 是 HandlerExceptionResolver，这是一个接口，里边只有一个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolveException 方法就用来解析请求处理过程中所产生的异常，并最终返回一个 ModelAndView。</p><p>我们来看下 HandlerExceptionResolver 的实现类：</p><p><img src="http://img.itboyhub.com/2021/02/20210325195747.png" alt></p><p>直接实现 HandlerExceptionResolver 接口的类有三个：</p><ul><li>HandlerExceptionResolverComposite：这个一看又是一个组合，在最近的源码分析中我们已经多次见到 xxxComposite 了，这里就不再赘述。</li><li>DefaultErrorAttributes：这个用来保存异常属性。</li><li><p>AbstractHandlerExceptionResolver：这个的子类比较多：</p><ul><li>SimpleMappingExceptionResolver：通过提前配置好的异常类和 View 之间的对应关系来解析异常。</li><li>AbstractHandlerMethodExceptionResolver：处理使用 <code>@ExceptionHandler</code> 注解自定义的异常类型。</li><li>DefaultHandlerExceptionResolver：按照不同类型来处理异常。</li><li>ResponseStatusExceptionResolver：处理含有 <code>@ResponseStatus</code> 注解的异常。</li></ul></li></ul><p>在 SpringMVC 中，大致的异常解析器就是这些，接下来我们来逐个学习这些异常解析器。</p><h2 id="2-AbstractHandlerExceptionResolver"><a href="#2-AbstractHandlerExceptionResolver" class="headerlink" title="2.AbstractHandlerExceptionResolver"></a>2.AbstractHandlerExceptionResolver</h2><p>AbstractHandlerExceptionResolver 是真正干活的异常解析器的父类，我们就先从他的 resolveException 方法开始看起。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (shouldApplyTo(request, handler)) &#123;</span><br><span class="line">prepareResponse(ex, response);</span><br><span class="line">ModelAndView result = doResolveException(request, response, handler, ex);</span><br><span class="line"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">logException(ex, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 shouldApplyTo 方法判断当前解析器是否可以处理传入的处理器所抛出的异常，如果不支持，则直接返回 null，这个异常将交给下一个 HandlerExceptionResolver 去处理。</li><li>调用 prepareResponse 方法处理 response。</li><li>调用 doResolveException 方法实际处理异常，这是一个模版方法，具体的实现在子类中。</li><li>调用 logException 方法记录异常日志信息。</li></ol><p>记录异常日志没啥好说的，doResolveException 则是一个空的模版方法，所以这里对我们来说主要就是两个方法：shouldApplyTo 和 prepareResponse，我们分别来看。</p><p><strong>shouldApplyTo</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldApplyTo</span><span class="hljs-params">(HttpServletRequest request, @Nullable Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mappedHandlers != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.mappedHandlers.contains(handler)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mappedHandlerClasses != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Class&lt;?&gt; handlerClass : <span class="hljs-keyword">this</span>.mappedHandlerClasses) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (handlerClass.isInstance(handler)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> !hasHandlerMappings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到了两个对象：mappedHandlers 和 mappedHandlerClasses：</p><ul><li>mappedHandlers：存储的是处理器对象（Controller 或者 Controller 中的方法）</li><li>mappedHandlerClasses：存储的是处理器的 Class。</li></ul><p>我们在配置异常解析器的时候可以配置这两个对象，进而实现该异常处理器只为某一个处理器服务，但是一般来说没这种需求，所以大家仅做了解即可。</p><p>如果开发者一开始配置了 mappedHandlers 或者 mappedHandlerClasses，则用这两个和处理器去比较，否则就直接返回 true，表示支持该异常处理。</p><p><strong>prepareResponse</strong></p><p>prepareResponse 方法比较简单，主要是处理一下响应头的缓存字段。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareResponse</span><span class="hljs-params">(Exception ex, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.preventResponseCaching) &#123;</span><br><span class="line">preventCaching(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preventCaching</span><span class="hljs-params">(HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">response.addHeader(HEADER_CACHE_CONTROL, <span class="hljs-string">"no-store"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 AbstractHandlerExceptionResolver 的大致内容，可以看到还是非常 easy 的，接下来我们来看它的实现类。</p><h3 id="2-1-AbstractHandlerMethodExceptionResolver"><a href="#2-1-AbstractHandlerMethodExceptionResolver" class="headerlink" title="2.1 AbstractHandlerMethodExceptionResolver"></a>2.1 AbstractHandlerMethodExceptionResolver</h3><p>AbstractHandlerMethodExceptionResolver 主要是重写了 shouldApplyTo 方法和 doResolveException 方法，一个一个来看。</p><p><strong>shouldApplyTo</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldApplyTo</span><span class="hljs-params">(HttpServletRequest request, @Nullable Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldApplyTo(request, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">handler = handlerMethod.getBean();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldApplyTo(request, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasGlobalExceptionHandlers() &amp;&amp; hasHandlerMappings()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldApplyTo(request, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块感觉没啥好说的，判断逻辑基本上都还是调用父类的 shouldApplyTo 方法去处理。</p><p><strong>doResolveException</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ModelAndView <span class="hljs-title">doResolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">HandlerMethod handlerMethod = (handler <span class="hljs-keyword">instanceof</span> HandlerMethod ? (HandlerMethod) handler : <span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> doResolveHandlerMethodException(request, response, handlerMethod, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> ModelAndView <span class="hljs-title">doResolveHandlerMethodException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex)</span></span>;</span><br></pre></td></tr></table></figure><p>doResolveException 是具体的异常处理方法，但是它里边却没有实质性操作，具体的事情交给 doResolveHandlerMethodException 方法去做了，而该方法是一个抽象方法，具体的实现在子类中。</p><h4 id="2-1-1-ExceptionHandlerExceptionResolver"><a href="#2-1-1-ExceptionHandlerExceptionResolver" class="headerlink" title="2.1.1 ExceptionHandlerExceptionResolver"></a>2.1.1 ExceptionHandlerExceptionResolver</h4><p>AbstractHandlerMethodExceptionResolver 只有一个子类就是 ExceptionHandlerExceptionResolver，来看下它的 doResolveHandlerMethodException 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">doResolveHandlerMethodException</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception)</span> </span>&#123;</span><br><span class="line">ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);</span><br><span class="line"><span class="hljs-keyword">if</span> (exceptionHandlerMethod == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.argumentResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">exceptionHandlerMethod.setHandlerMethodArgumentResolvers(<span class="hljs-keyword">this</span>.argumentResolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returnValueHandlers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(<span class="hljs-keyword">this</span>.returnValueHandlers);</span><br><span class="line">&#125;</span><br><span class="line">ServletWebRequest webRequest = <span class="hljs-keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">ModelAndViewContainer mavContainer = <span class="hljs-keyword">new</span> ModelAndViewContainer();</span><br><span class="line">ArrayList&lt;Throwable&gt; exceptions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Using @ExceptionHandler "</span> + exceptionHandlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Expose causes as provided arguments as well</span></span><br><span class="line">Throwable exToExpose = exception;</span><br><span class="line"><span class="hljs-keyword">while</span> (exToExpose != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">exceptions.add(exToExpose);</span><br><span class="line">Throwable cause = exToExpose.getCause();</span><br><span class="line">exToExpose = (cause != exToExpose ? cause : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">Object[] arguments = <span class="hljs-keyword">new</span> Object[exceptions.size() + <span class="hljs-number">1</span>];</span><br><span class="line">exceptions.toArray(arguments);  <span class="hljs-comment">// efficient arraycopy call in ArrayList</span></span><br><span class="line">arguments[arguments.length - <span class="hljs-number">1</span>] = handlerMethod;</span><br><span class="line">exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable invocationEx) &#123;</span><br><span class="line"><span class="hljs-comment">// Any other than the original exception (or a cause) is unintended here,</span></span><br><span class="line"><span class="hljs-comment">// probably an accident (e.g. failed assertion or the like).</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!exceptions.contains(invocationEx) &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="hljs-string">"Failure in @ExceptionHandler "</span> + exceptionHandlerMethod, invocationEx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Continue with default processing of the original exception...</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">ModelMap model = mavContainer.getModel();</span><br><span class="line">HttpStatus status = mavContainer.getStatus();</span><br><span class="line">ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView(mavContainer.getViewName(), model, status);</span><br><span class="line">mav.setViewName(mavContainer.getViewName());</span><br><span class="line"><span class="hljs-keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">mav.setView((View) mavContainer.getView());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (model <span class="hljs-keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法虽然比较长，但是很好理解：</p><ol><li>首先查找到带有 <code>@ExceptionHandler</code> 注解的方法，封装成一个 ServletInvocableHandlerMethod 对象（关于 ServletInvocableHandlerMethod 对象，松哥在之前的文章中已经介绍过了，具体参见：<a href="https://mp.weixin.qq.com/s/559UL_bcEKo9jNq85qmVMg" target="_blank" rel="noopener">Spring Boot 定义接口的方法是否可以声明为 private？</a>）。</li><li>如果找到了对应的方法，则为 exceptionHandlerMethod 配置参数解析器、视图解析器等，关于这些解析器，参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/4c-uV8f6x5UPvxec6Em79A" target="_blank" rel="noopener">SpringBoot 中如何自定义参数解析器？</a>、<a href="https://mp.weixin.qq.com/s/qsS6Dwr6eXx07i5dhn8FEA" target="_blank" rel="noopener">深入分析 SpringMVC 参数解析器</a>、<a href="https://mp.weixin.qq.com/s/8aMz07rOF5LuclnBaI_p5g" target="_blank" rel="noopener">Spring Boot 中如何统一 API 接口响应格式？</a>。</li><li>接下来定义一个 exceptions 数组，如果发生的异常存在异常链，则将整个异常链存入 exceptions 数组中。</li><li>exceptions 数组再加上 handlerMethod，共同组成方法参数，调用 <code>exceptionHandlerMethod.invokeAndHandle</code> 完成自定义异常方法的执行，执行结果被保存再 mavContainer 中。</li><li>如果请求到此结束，则直接构造一个 ModelAndView 返回。</li><li>否则从 mavContainer 中取出各项信息，构建新的 ModelAndView 返回。同时，如果存在重定向参数，也将之保存下来（关于重定向参数，参见：<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>）。</li></ol><p>这就是 ExceptionHandlerExceptionResolver 的大致工作流程，可以看到，还是非常 easy 的。</p><h3 id="2-2-DefaultHandlerExceptionResolver"><a href="#2-2-DefaultHandlerExceptionResolver" class="headerlink" title="2.2 DefaultHandlerExceptionResolver"></a>2.2 DefaultHandlerExceptionResolver</h3><p>这个看名字就知道是一个默认的异常处理器，用来处理一些常见的异常类型，我们来看一下它的 doResolveException 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">doResolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpRequestMethodNotSupportedException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpRequestMethodNotSupported(</span><br><span class="line">(HttpRequestMethodNotSupportedException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpMediaTypeNotSupportedException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpMediaTypeNotSupported(</span><br><span class="line">(HttpMediaTypeNotSupportedException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpMediaTypeNotAcceptableException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpMediaTypeNotAcceptable(</span><br><span class="line">(HttpMediaTypeNotAcceptableException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> MissingPathVariableException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleMissingPathVariable(</span><br><span class="line">(MissingPathVariableException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> MissingServletRequestParameterException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleMissingServletRequestParameter(</span><br><span class="line">(MissingServletRequestParameterException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> ServletRequestBindingException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleServletRequestBindingException(</span><br><span class="line">(ServletRequestBindingException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> ConversionNotSupportedException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleConversionNotSupported(</span><br><span class="line">(ConversionNotSupportedException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> TypeMismatchException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleTypeMismatch(</span><br><span class="line">(TypeMismatchException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpMessageNotReadableException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpMessageNotReadable(</span><br><span class="line">(HttpMessageNotReadableException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpMessageNotWritableException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpMessageNotWritable(</span><br><span class="line">(HttpMessageNotWritableException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleMethodArgumentNotValidException(</span><br><span class="line">(MethodArgumentNotValidException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> MissingServletRequestPartException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleMissingServletRequestPartException(</span><br><span class="line">(MissingServletRequestPartException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BindException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleBindException((BindException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> NoHandlerFoundException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleNoHandlerFoundException(</span><br><span class="line">(NoHandlerFoundException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> AsyncRequestTimeoutException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleAsyncRequestTimeoutException(</span><br><span class="line">(AsyncRequestTimeoutException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception handlerEx) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里实际上就是根据不同的异常类型，然后调用不同的类去处理该异常。这里相关的处理都比较容易，以 HttpRequestMethodNotSupportedException 为例，异常处理就是对 response 对象做一些配置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">handleHttpRequestMethodNotSupported</span><span class="hljs-params">(HttpRequestMethodNotSupportedException ex,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String[] supportedMethods = ex.getSupportedMethods();</span><br><span class="line"><span class="hljs-keyword">if</span> (supportedMethods != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">response.setHeader(<span class="hljs-string">"Allow"</span>, StringUtils.arrayToDelimitedString(supportedMethods, <span class="hljs-string">", "</span>));</span><br><span class="line">&#125;</span><br><span class="line">response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, ex.getMessage());</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置响应头，然后 sendError，最后返回一个空的 ModelAndView 对象。</p><p>其实这里哥哥异常处理方法都大同小异，松哥就不再赘述啦。</p><h3 id="2-3-ResponseStatusExceptionResolver"><a href="#2-3-ResponseStatusExceptionResolver" class="headerlink" title="2.3 ResponseStatusExceptionResolver"></a>2.3 ResponseStatusExceptionResolver</h3><p>这个用来处理 ResponseStatusException 类型的异常，或者使用了 <code>@ResponseStatus</code> 注解标记的普通异常类。我们来看下它的 doResolveException 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">doResolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> ResponseStatusException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> resolveResponseStatusException((ResponseStatusException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line">ResponseStatus status = AnnotatedElementUtils.findMergedAnnotation(ex.getClass(), ResponseStatus.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (status != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> resolveResponseStatus(status, request, response, handler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ex.getCause() <span class="hljs-keyword">instanceof</span> Exception) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> doResolveException(request, response, handler, (Exception) ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception resolveEx) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先判断异常类型是不是 ResponseStatusException，如果是，则直接调用 resolveResponseStatusException 方法进行异常信息处理，如果不是，则去查找到异常类上的 <code>@ResponseStatus</code> 注解，并从中查找出相关的异常信息，然后调用 resolveResponseStatus 方法进行处理。</p><p>可以看到，ResponseStatusExceptionResolver 处理的异常类型有两种：</p><ul><li>直接继承自 ResponseStatusException 的异常类，这种异常类可以直接从里边提取出来想要的信息。</li><li>通过 <code>@ResponseStatus</code> 注解的普通异常类，这种情况下异常信息从 <code>@ResponseStatus</code> 注解中提取出来。</li></ul><p>这个比较简单，没啥好说的。</p><h3 id="2-4-SimpleMappingExceptionResolver"><a href="#2-4-SimpleMappingExceptionResolver" class="headerlink" title="2.4 SimpleMappingExceptionResolver"></a>2.4 SimpleMappingExceptionResolver</h3><p>SimpleMappingExceptionResolver 则是根据不同的异常显示不同的 error 页面。可能有的小伙伴还没用过 SimpleMappingExceptionResolver，所以松哥这里先简单说一下用法。</p><p>SimpleMappingExceptionResolver 的配置非常简单，直接提供一个 SimpleMappingExceptionResolver 的实例即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">SimpleMappingExceptionResolver <span class="hljs-title">simpleMappingExceptionResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    SimpleMappingExceptionResolver resolver = <span class="hljs-keyword">new</span> SimpleMappingExceptionResolver();</span><br><span class="line">    Properties mappings = <span class="hljs-keyword">new</span> Properties();</span><br><span class="line">    mappings.put(<span class="hljs-string">"java.lang.ArithmeticException"</span>, <span class="hljs-string">"11"</span>);</span><br><span class="line">    mappings.put(<span class="hljs-string">"java.lang.NullPointerException"</span>, <span class="hljs-string">"22"</span>);</span><br><span class="line">    resolver.setExceptionMappings(mappings);</span><br><span class="line">    Properties statusCodes = <span class="hljs-keyword">new</span> Properties();</span><br><span class="line">    statusCodes.put(<span class="hljs-string">"11"</span>, <span class="hljs-string">"500"</span>);</span><br><span class="line">    statusCodes.put(<span class="hljs-string">"22"</span>, <span class="hljs-string">"500"</span>);</span><br><span class="line">    resolver.setStatusCodes(statusCodes);</span><br><span class="line">    <span class="hljs-keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 mappings 中配置异常和 view 之间的对应关系，要写异常类的全路径，后面的 11、22 则表示视图名称；statusCodes 中配置了视图和响应状态码之间的映射关系。配置完成后，如果我们的项目在运行时抛出了 ArithmeticException 异常，则会展示出 11 视图，如果我们的项目在运行时抛出了 NullPointerException 异常，则会展示出 22 视图。</p><p>这是用法，了解了用法之后我们再来看源码，就容易理解了，我们直接来看 doResolveException 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">doResolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">String viewName = determineViewName(ex, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (viewName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Integer statusCode = determineStatusCode(request, viewName);</span><br><span class="line"><span class="hljs-keyword">if</span> (statusCode != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">applyStatusCodeIfPossible(request, response, statusCode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> getModelAndView(viewName, ex, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 determineViewName 方法确定视图的名称。</li><li>接下来调用 determineStatusCode 查看视图是否有对应的 statusCode。</li><li>调用 applyStatusCodeIfPossible 方法将 statusCode 设置到 response 上，这个方法很简单，不多说。</li><li>调用 getModelAndView 方法构造一个 ModelAndView 对象返回，在构造时，同时设置异常参数，异常的信息的 key 默认就是 exception。</li></ol><p>在上面这个过程中，有两个比较长的方法，松哥这里需要和大家额外多说两句。</p><p><strong>determineViewName</strong></p><p>这个就是根据异常类型找到视图名，我们来看下具体的查找方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determineViewName</span><span class="hljs-params">(Exception ex, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String viewName = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.excludedExceptions != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Class&lt;?&gt; excludedEx : <span class="hljs-keyword">this</span>.excludedExceptions) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (excludedEx.equals(ex.getClass())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exceptionMappings != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">viewName = findMatchingViewName(<span class="hljs-keyword">this</span>.exceptionMappings, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (viewName == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.defaultErrorView != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">viewName = <span class="hljs-keyword">this</span>.defaultErrorView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> viewName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果当前异常包含在 excludedExceptions 中，则直接返回 null（意思是当前异常被忽略处理了，直接按照默认方式来）。</li><li>如果 exceptionMappings 不为 null，则直接调用 findMatchingViewName 方法查找异常对应的视图名（exceptionMappings 变量就是前面我们配置的映射关系），具体的查找方式就是遍历我们前面配置的映射表。</li><li>如果没找到对应的 viewName，并且用户配置了 defaultErrorView，则将 defaultErrorView 赋值给 viewName，并将 viewName 返回。</li></ol><p><strong>determineStatusCode</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">determineStatusCode</span><span class="hljs-params">(HttpServletRequest request, String viewName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.statusCodes.containsKey(viewName)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.statusCodes.get(viewName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultStatusCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就比较容易，直接去 statusCodes 中查看是否有视图对应的状态码，如果有则直接返回，如果没有，就返回一个默认的。</p><h2 id="3-HandlerExceptionResolverComposite"><a href="#3-HandlerExceptionResolverComposite" class="headerlink" title="3.HandlerExceptionResolverComposite"></a>3.HandlerExceptionResolverComposite</h2><p>最后，还有一个 HandlerExceptionResolverComposite 需要和大家介绍下，这是一个组合的异常处理器，用来代理哪些真正干活的异常处理器。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (HandlerExceptionResolver handlerExceptionResolver : <span class="hljs-keyword">this</span>.resolvers) &#123;</span><br><span class="line">ModelAndView mav = handlerExceptionResolver.resolveException(request, response, handler, ex);</span><br><span class="line"><span class="hljs-keyword">if</span> (mav != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的 resolveException 方法就比较简单了，这种写法我们已经见到过很多次了，不再赘述。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和大家简单聊一聊 SpringMVC 中的异常处理体系，整体来说并不难，小伙伴们可以仔细品一品。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;SpringMVC 中针对异常问题有一套完整的处理体系，这套体系非常好用，今天松哥就花点时间来和大家聊一聊 SpringMVC 中的异常处理体系，我们把 SpringMVC 中的异常体系从头到尾梳理一下。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>对不起，我加入敌方战队了</title>
    <link href="http://www.javaboy.org/2021/0410/java-lombok.html"/>
    <id>http://www.javaboy.org/2021/0410/java-lombok.html</id>
    <published>2021-04-10T11:14:40.000Z</published>
    <updated>2021-04-10T11:15:37.126Z</updated>
    
    <content type="html"><![CDATA[<p>工作原因，最近我也用上了 Lombok（<strong>本文纯属技术探讨，不持任何立场，请轻喷</strong>）。</p><a id="more"></a><p>用 Lombok 要在 IDEA 上安装插件，忽然发现我的 IDEA 上不知道啥时候已经安装了这个插件了，仔细回忆，想起来是某一次从网上下载了一个开源项目，对方使用了 Lombok，导致我在本地不得不安装一个 Lombok 插件，这种感觉并不太爽，自那以后这个插件就在我的 IDEA 里躺尸了。</p><p>最近没办法，有一个项目一开始就用了 Lombok，我现在接手也不得不用，那么刚好趁此机会，松哥也来和大家聊一聊 Lombok 的使用吧。</p><h2 id="Lombok-简介"><a href="#Lombok-简介" class="headerlink" title="Lombok 简介"></a>Lombok 简介</h2><p>Lombok 是一个 Java 库，能自动插入编辑器并构建工具，简化 Java 开发。通过添加注解的方式，不需要为类编写 getter/setter/equals 等方法，同时可以自动化日志变量。简而言之：Lombok 能以简单的注解形式来简化 Java 代码，提高开发人员的开发效率。</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>由于 Lombok 会自动帮我们生成一些代码，这些代码在 source 阶段是没有的，编译之后才会用，为了避免开发工具如 IDEA 报错，一般在使用 Lombok 的时候还需要安装一个 IDEA 插件。</p><p>安装方式非常简单，直接在 IDEA 市场搜索 Lombok，点击 install 按钮即可，安装完成后，重启 IDEA。</p><p><img src="http://img.itboyhub.com/2021/02/20210407082544.png" alt></p><p>我这个因为安装的比较早，现在已经需要更新了。</p><h2 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h2><p>Lombok 的使用非常简单，在 Spring Boot 创建的时候，就可以添加 Lombok 依赖，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210407082830.png" alt></p><p>创建成功后，项目中多了如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就可以了，接下来我们就可以在项目中使用 Lombok 了。</p><p>Lombok 主要包含如下一些内容：</p><ul><li>val：类似于前端 js 中的 var。</li><li>@NotNull：这个用于方法参数，可以自动校验方法参数是否为空。</li><li>@Cleanup：这个用在局部变量上，在变量使用结束时会自动调用 close 方法释放资源，典型用法就是 IO 流的相关操作中使用该注解。</li><li>@Getter 用在字段或者类上，当用在字段上时会自动生成字段的 getter；当用在类上时，会自动生成该类所有非静态字段的 getter，使用该注解还可以调整 getter 方法的访问级别。</li><li>@Setter：同上。</li><li>@ToString：这个注解用在类上，自动生成类的 toString 方法，可以做一些定制，比如不使用某个字段，不调用 getter 等。</li><li>@EqualsAndHashCode：这个注解用在类上，自动生成类中所有非静态非瞬时字段（添加了 <code>@Transient</code> 注解的字段为瞬时字段）的 equals 方法和 hashCode 方法。</li><li>@NoArgsConstructor：这个注解用在类上，会自动生成一个无参构造函数。</li><li>@AllArgsConstructor：这个注解用在类上，会自动生成一个包含所有参数的构造函数。</li><li>@RequiredArgsConstructor：这个注解也是作用在类上，它会为 final 字段和标记了 @NotNull 的字段生成构造函数。</li><li>@Data：这个注解也是用在类上，使用该注解相当于同时应用了 <code>@Getter</code>、<code>@Setter</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code>、<code>@RequiredArgsConstructor</code>。如果已经定义了一个构造方法，就不会再自动生成构造方法了。</li><li>@Value：这个注解用在类上，和 @Data 类似，但是用于不可变类型。生成的类和所有字段都设置为 final，所有字段都为 private，自动生成 Getter 但是没有 Setter，会生成初始化所有字段的构造函数。相当于同时应用了 <code>final @ToString</code>、 <code>@EqualsAndHashCode</code>、 <code>@AllArgsConstructor</code>、<code>@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)</code> 和 <code>@Getter</code>。</li><li>@CommonsLog：日志注解，相当于定义变量 <code>log = org.apache.commons.logging.LogFactory.getLog(LogExample.class)</code>。</li><li>@JBossLog：日志注解：相当于定义变量 <code>log = org.jboss.logging.Logger.getLogger(LogExample.class)</code>。</li><li>@Log：日志注解，相当于定义变量 <code>log = java.util.logging.Logger.getLogger(LogExample.class.getName())</code>。</li><li>@Log4j：日志注解，相当于定义变量 <code>log = org.apache.log4j.Logger.getLogger(LogExample.class)</code>。</li><li>@Log4j2：日志注解，相当于定义变量 <code>log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class)</code>。</li><li>@Slf4j：日志注解，相当于定义变量 <code>log = org.slf4j.LoggerFactory.getLogger(LogExample.class)</code>。</li><li>@XSlf4j：日志注解，相当于定义变量 <code>log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class)</code>。</li></ul><p>随便举几个例子大家来感受下。</p><p>如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Getter</span></span><br><span class="line"><span class="hljs-meta">@Setter</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210407095045.png" alt></p><p>如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> User)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            User other = (User)o;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!other.canEqual(<span class="hljs-keyword">this</span>)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                Object <span class="hljs-keyword">this</span>$id = <span class="hljs-keyword">this</span>.getId();</span><br><span class="line">                Object other$id = other.getId();</span><br><span class="line">                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>$id == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (other$id != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>$id.equals(other$id)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object <span class="hljs-keyword">this</span>$name = <span class="hljs-keyword">this</span>.getName();</span><br><span class="line">                Object other$name = other.getName();</span><br><span class="line">                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>$name == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (other$name != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>$name.equals(other$name)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canEqual</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object other)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> other <span class="hljs-keyword">instanceof</span> User;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> PRIME = <span class="hljs-keyword">true</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;</span><br><span class="line">        Object $id = <span class="hljs-keyword">this</span>.getId();</span><br><span class="line">        <span class="hljs-keyword">int</span> result = result * <span class="hljs-number">59</span> + ($id == <span class="hljs-keyword">null</span> ? <span class="hljs-number">43</span> : $id.hashCode());</span><br><span class="line">        Object $name = <span class="hljs-keyword">this</span>.getName();</span><br><span class="line">        result = result * <span class="hljs-number">59</span> + ($name == <span class="hljs-keyword">null</span> ? <span class="hljs-number">43</span> : $name.hashCode());</span><br><span class="line">        <span class="hljs-keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"User(id="</span> + <span class="hljs-keyword">this</span>.getId() + <span class="hljs-string">", name="</span> + <span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUtils</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String source, String dest)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File sourceFile = <span class="hljs-keyword">new</span> File(source);</span><br><span class="line">        File destFile = <span class="hljs-keyword">new</span> File(dest);</span><br><span class="line">        <span class="hljs-meta">@Cleanup</span> InputStream in = <span class="hljs-keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line">        <span class="hljs-meta">@Cleanup</span> OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(destFile);</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> r = in.read(b);</span><br><span class="line">            <span class="hljs-keyword">if</span> (r == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;</span><br><span class="line">            out.write(b, <span class="hljs-number">0</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后生成的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUtils</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileUtils</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String source, String dest)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File sourceFile = <span class="hljs-keyword">new</span> File(source);</span><br><span class="line">        File destFile = <span class="hljs-keyword">new</span> File(dest);</span><br><span class="line">        FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(destFile);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">int</span> r = in.read(b);</span><br><span class="line">                    <span class="hljs-keyword">if</span> (r == -<span class="hljs-number">1</span>) &#123;</span><br><span class="line">                        <span class="hljs-keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    out.write(b, <span class="hljs-number">0</span>, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (Collections.singletonList(out).get(<span class="hljs-number">0</span>) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (Collections.singletonList(in).get(<span class="hljs-number">0</span>) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我就不一一举例了，这个东西使用还是非常容易的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Lombok 这个插件还是比较好玩的，注意我用“好玩”来形容它，因为确实好玩，几个注解就可以帮我们生成一大堆代码，N 年前我搞 Android 开发那会，当时 Android 生态里边就有类似的框架，因为当时公司禁止使用该类框架，导致我一直对这种自动生成代码的框架敬而远之。后来搞 Java 了，偶尔也会有小伙伴问我用不用 Lombok，你说不用吧，被说人老古董，你说用吧，被人说是菜鸟，算了，还是沉默吧。</p><p>问一个 Java 程序员用不用 Lombok 就像问一个软件工程师哪种开发语言最好，这绝对是一个足够“燃”的话题。但是退一步想想，语言只是一个工具，利用这样一个工具帮助我们实现心中的一些想法才是最重要的，所以没有必要去争论语言的好坏，存在即合理，去争论语言的好坏格局就小了，更何况 Lombok 只是 Java 语言中一个小小的框架。</p><p>所以，以后大家见到有人用 Lombok，一定要凑上前说一句：牛逼！见到有人喷 Lombok，也要来一句：牛逼！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作原因，最近我也用上了 Lombok（&lt;strong&gt;本文纯属技术探讨，不持任何立场，请轻喷&lt;/strong&gt;）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
      <category term="Lombok" scheme="http://www.javaboy.org/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>其实我不仅会 Spring Security，Shiro 也略懂一二！</title>
    <link href="http://www.javaboy.org/2021/0408/shiro-guide.html"/>
    <id>http://www.javaboy.org/2021/0408/shiro-guide.html</id>
    <published>2021-04-08T07:20:07.000Z</published>
    <updated>2021-04-08T07:25:30.684Z</updated>
    
    <content type="html"><![CDATA[<p>和大家分享一个松哥原创的 Shiro 教程吧，还没写完，先整一部分，剩下的敬请期待。</p><h2 id="1-Shiro简介"><a href="#1-Shiro简介" class="headerlink" title="1.Shiro简介"></a>1.Shiro简介</h2><p>Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架具有直观、易用等特性，同时也能提供健壮的安全性，虽然它的功能不如SpringSecurity那么强大，但是在普通的项目中也够用了。</p><a id="more"></a><h3 id="1-1-由来"><a href="#1-1-由来" class="headerlink" title="1.1 由来"></a>1.1 由来</h3><p>Shiro的前身是JSecurity，2004年，Les Hazlewood和Jeremy Haile创办了Jsecurity。当时他们找不到适用于应用程序级别的合适Java安全框架，同时又对JAAS非常失望。2004年到2008年期间，JSecurity托管在SourceForge上，贡献者包括Peter Ledbrook、Alan Ditzel和Tim Veil。2008年，JSecurity项目贡献给了Apache软件基金会（ASF），并被接纳成为Apache Incubator项目，由导师管理，目标是成为一个顶级Apache项目。期间，Jsecurity曾短暂更名为Ki，随后因商标问题被社区更名为“Shiro”。随后项目持续在Apache Incubator中孵化，并增加了贡献者Kalle Korhonen。2010年7月，Shiro社区发布了1.0版，随后社区创建了其项目管理委员会，并选举Les Hazlewood为主席。2010年9月22日，Shrio成为Apache软件基金会的顶级项目（TLP）。</p><h3 id="1-2-有哪些功能"><a href="#1-2-有哪些功能" class="headerlink" title="1.2 有哪些功能"></a>1.2 有哪些功能</h3><p>Apache Shiro是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。Apache Shiro的首要目标是易于使用和理解。安全有时候是很复杂的，甚至是痛苦的，但它没有必要这样。框架应该尽可能掩盖复杂的地方，露出一个干净而直观的API，来简化开发人员在应用程序安全上所花费的时间。</p><p>以下是你可以用Apache Shiro 所做的事情：</p><ol><li>验证用户来核实他们的身份</li><li>对用户执行访问控制，如：判断用户是否被分配了一个确定的安全角色；判断用户是否被允许做某事</li><li>在任何环境下使用Session API，即使没有Web容器</li><li>在身份验证，访问控制期间或在会话的生命周期，对事件作出反应</li><li>聚集一个或多个用户安全数据的数据源，并作为一个单一的复合用户“视图”</li><li>单点登录（SSO）功能</li><li><p>为没有关联到登录的用户启用”Remember Me”服务</p><p> 等等</p></li></ol><p>Apache Shiro是一个拥有许多功能的综合性的程序安全框架。下面的图表展示了Shiro的重点：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a6a1cb5eb8a807afe4f4b2bd094a97ba.png" alt="p306"></p><p>Shiro中有四大基石——身份验证，授权，会话管理和加密。</p><ol><li>Authentication：有时也简称为“登录”，这是一个证明用户是谁的行为。</li><li>Authorization：访问控制的过程，也就是决定“谁”去访问“什么”。</li><li>Session Management：管理用户特定的会话，即使在非Web 或EJB 应用程序。</li><li>Cryptography：通过使用加密算法保持数据安全同时易于使用。</li></ol><p>除此之外，Shiro也提供了额外的功能来解决在不同环境下所面临的安全问题，尤其是以下这些：</p><ol><li>Web Support：Shiro的web支持的API能够轻松地帮助保护Web应用程序。</li><li>Caching：缓存是Apache Shiro中的第一层公民，来确保安全操作快速而又高效。</li><li>Concurrency：Apache Shiro利用它的并发特性来支持多线程应用程序。</li><li>Testing：测试支持的存在来帮助你编写单元测试和集成测试。</li><li>“Run As”：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。</li><li>“Remember Me”：在会话中记住用户的身份，这样用户只需要在强制登录时候登录。</li></ol><h2 id="2-从一个简单的案例开始身份认证"><a href="#2-从一个简单的案例开始身份认证" class="headerlink" title="2.从一个简单的案例开始身份认证"></a>2.从一个简单的案例开始身份认证</h2><h3 id="2-1-shiro下载"><a href="#2-1-shiro下载" class="headerlink" title="2.1 shiro下载"></a>2.1 shiro下载</h3><p>要学习shiro，我们首先需求去shiro官网下载shiro，官网地址地址<a href="https://shiro.apache.org/，截至本文写作时，shiro的最新稳定版本为1.7.1（Shiro" target="_blank" rel="noopener">https://shiro.apache.org/，截至本文写作时，shiro的最新稳定版本为1.7.1（Shiro</a> 在 2017-2019 曾经停更了两年，我一度以为以为这个项目 gg 了），本文将采用这个版本。当然，shiro我们也可以从github上下载到源码。两个源码下载地址如下：</p><p>1.<a href="http://shiro.apache.org/download.html#latest" target="_blank" rel="noopener">apache shiro</a><br>2.<a href="https://github.com/apache/shiro/archive/master.zip" target="_blank" rel="noopener">github-shiro</a></p><p>上面我主要是和小伙伴们介绍下源码的下载，并没有涉及到jar包的下载，jar包我们到时候直接使用maven即可。</p><h3 id="2-2-创建演示工程"><a href="#2-2-创建演示工程" class="headerlink" title="2.2 创建演示工程"></a>2.2 创建演示工程</h3><p>这里我们先不急着写代码，我们先打开刚刚下载到的源码，源码中有一个samples目录，如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/93c851b022e937eee84972116c10604f.png" alt="p307"></p><p>这个samples目录是官方给我们的一些演示案例，其中有一个quickstart项目，这个项目是一个maven项目，参考这个quickstart，我们来创建一个自己的演示工程。</p><p>1.首先使用maven创建一个JavaSE工程<br>工程创建成功后在pom文件中添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置用户</p><p>参考quickstart项目中的shiro.ini文件，我们来配置一个用户，配置方式如下：首先在resources目录下创建一个shiro.ini文件，文件内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">sang=123,admin</span><br><span class="line">[roles]</span><br><span class="line">admin=*</span><br></pre></td></tr></table></figure><p>以上配置表示我们创建了一个名为sang的用户，该用户的密码是123，该用户的角色是admin，而admin具有操作所有资源的权限。</p><p>3.执行登录</p><p>OK，做完上面几步之后，我们就可以来看看如何实现一次简单的登录操作了。这个登录操作我们依然是参考quickstart项目中的类来实现，首先我们要通过shiro.ini创建一个SecurityManager，再将这个SecurityManager设置为单例模式，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">"classpath:shiro.ini"</span>);</span><br><span class="line">org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();</span><br><span class="line">SecurityUtils.setSecurityManager(securityManager);</span><br></pre></td></tr></table></figure><p>如此之后，我们就配置好了一个基本的Shiro环境，注意此时的用户和角色信息我们配置在shiro.ini这个配置文件中，接下来我们就可以获取一个Subject了，这个Subject就是我们当前的用户对象，获取方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure><p>拿到这个用户对象之后，接下来我们可以获取一个session了，这个session和我们web中的HttpSession的操作基本上是一致的，不同的是，这个session不依赖任何容器，可以随时随地获取，获取和操作方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//获取session</span></span><br><span class="line">Session session = currentUser.getSession();</span><br><span class="line"><span class="hljs-comment">//给session设置属性值</span></span><br><span class="line">session.setAttribute(<span class="hljs-string">"someKey"</span>, <span class="hljs-string">"aValue"</span>);</span><br><span class="line"><span class="hljs-comment">//获取session中的属性值</span></span><br><span class="line">String value = (String) session.getAttribute(<span class="hljs-string">"someKey"</span>);</span><br></pre></td></tr></table></figure><p>说了这么多，我们的用户到现在还没有登录呢，Subject中有一个isAuthenticated方法用来判断当前用户是否已经登录，如果isAuthenticated方法返回一个false，则表示当前用户未登录，那我们就可以执行登陆，登录方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">    UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">"sang"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        currentUser.login(token);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">        log.info(<span class="hljs-string">"There is no user with username of "</span> + token.getPrincipal());</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">        log.info(<span class="hljs-string">"Password for account "</span> + token.getPrincipal() + <span class="hljs-string">" was incorrect!"</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">        log.info(<span class="hljs-string">"The account for username "</span> + token.getPrincipal() + <span class="hljs-string">" is locked.  "</span> +</span><br><span class="line">                <span class="hljs-string">"Please contact your administrator to unlock it."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构造UsernamePasswordToken，两个参数就是我们的用户名和密码，然后调用Subject中的login方法执行登录，当用户名输错，密码输错、或者账户锁定等问题出现时，系统会通过抛异常告知调用者这些问题。</p><p>当登录成功之后，我们可以通过如下方式获取当前登陆用户的用户名：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="hljs-string">"User ["</span> + currentUser.getPrincipal() + <span class="hljs-string">"] logged in successfully."</span>);</span><br></pre></td></tr></table></figure><p>我们也可以通过调用Subject中的hasRole和isPermitted方法来判断当前用户是否具备某种角色或者某种权限，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (currentUser.hasRole(<span class="hljs-string">"admin"</span>)) &#123;</span><br><span class="line">    log.info(<span class="hljs-string">"May the Schwartz be with you!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="hljs-string">"Hello, mere mortal."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">"lightsaber:wield"</span>)) &#123;</span><br><span class="line">    log.info(<span class="hljs-string">"You may use a lightsaber ring.  Use it wisely."</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="hljs-string">"Sorry, lightsaber rings are for schwartz masters only."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以通过logout方法注销本次登录，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentUser.logout();</span><br></pre></td></tr></table></figure><p>OK，至此，我们通过官方案例给小伙伴们简单介绍了Shiro中的登录操作，完整案例大家可以参考官方的demo。</p><h2 id="3-聊一聊Shiro中的Realm"><a href="#3-聊一聊Shiro中的Realm" class="headerlink" title="3. 聊一聊Shiro中的Realm"></a>3. 聊一聊Shiro中的Realm</h2><h3 id="3-1-登录流程是什么样的"><a href="#3-1-登录流程是什么样的" class="headerlink" title="3.1 登录流程是什么样的"></a>3.1 登录流程是什么样的</h3><p>首先我们来看shiro官方文档中这样一张登录流程图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f8b6568be71a8cb15f49f862101dd661.png" alt="p308"></p><p>参照此图，我们的登录一共要经过如下几个步骤：</p><ol><li>应用程序代码调用Subject.login方法，传递创建好的包含终端用户的Principals(身份)和Credentials(凭证)的AuthenticationToken实例(即上文例子中的UsernamePasswordToken)。</li><li>Subject实例，通常是DelegatingSubject（或子类）委托应用程序的SecurityManager通过调用securityManager.login(token)开始真正的验证工作(在DelegatingSubject类的login方法中打断点即可看到)。</li><li>SubjectManager作为一个基本的“保护伞”的组成部分，接收token以及简单地委托给内部的Authenticator实例通过调用authenticator.authenticate(token)。这通常是一个ModularRealmAuthenticator实例，支持在身份验证中协调一个或多个Realm实例。ModularRealmAuthenticator本质上为Apache Shiro 提供了PAM-style 范式（其中在PAM 术语中每个Realm 都是一个’module’）。</li><li>如果应用程序中配置了一个以上的Realm，ModularRealmAuthenticator实例将利用配置好的AuthenticationStrategy来启动Multi-Realm认证尝试。在Realms 被身份验证调用之前，期间和以后，AuthenticationStrategy被调用使其能够对每个Realm的结果作出反应。如果只有一个单一的Realm 被配置，它将被直接调用，因为没有必要为一个单一Realm的应用使用AuthenticationStrategy。</li><li>每个配置的Realm用来帮助看它是否支持提交的AuthenticationToken。如果支持，那么支持Realm的getAuthenticationInfo方法将会伴随着提交的token被调用。</li></ol><p>OK，通过上面的介绍，相信小伙伴们对整个登录流程都有一定的理解了，小伙伴可以通过打断点来验证我们上文所说的五个步骤。那么在上面的五个步骤中，小伙伴们看到了有一个Realm承担了很重要的一部分工作，那么这个Realm到底是个什么东西，接下来我们就来仔细看一看。</p><h3 id="3-2-什么是Realm"><a href="#3-2-什么是Realm" class="headerlink" title="3.2 什么是Realm"></a>3.2 什么是Realm</h3><p>根据Realm文档上的解释，Realms担当Shiro和你的应用程序的安全数据之间的“桥梁”或“连接器”。当它实际上与安全相关的数据如用来执行身份验证（登录）及授权（访问控制）的用户帐户交互时，Shiro从一个或多个为应用程序配置的Realm 中寻找许多这样的东西。在这个意义上说，<strong>Realm 本质上是一个特定安全的DAO</strong>：它封装了数据源的连接详细信息，使Shiro 所需的相关的数据可用。当配置Shiro 时，你必须指定至少一个Realm 用来进行身份验证和/或授权。SecurityManager可能配置多个Realms，但至少有一个是必须的。Shiro 提供了立即可用的Realms 来连接一些安全数据源（即目录），如LDAP，关系数据库（JDBC），文本配置源，像INI 及属性文件，以及更多。你可以插入你自己的Realm 实现来代表自定义的数据源，如果默认地Realm不符合你的需求。</p><p>看了上面这一段解释，可能还有小伙伴云里雾里，那么接下来我们来通过一个简单的案例来看看Realm到底扮演了一个什么样的作用，注意，本文的案例在上文案例的基础上完成。首先自定义一个MyRealm，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Realm</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyRealm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> token <span class="hljs-keyword">instanceof</span> UsernamePasswordToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationInfo <span class="hljs-title">getAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String password = <span class="hljs-keyword">new</span> String(((<span class="hljs-keyword">char</span>[]) token.getCredentials()));</span><br><span class="line">        String username = token.getPrincipal().toString();</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"sang"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(<span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IncorrectCredentialsException(<span class="hljs-string">"密码不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义Realm实现Realm接口，该接口中有三个方法，第一个getName方法用来获取当前Realm的名字，第二个supports方法用来判断这个realm所支持的token，这里我假设值只支持UsernamePasswordToken类型的token，第三个getAuthenticationInfo方法则进行了登陆逻辑判断，从token中取出用户的用户名密码等，进行判断，当然，我这里省略掉了数据库操作，当登录验证出现问题时，抛异常即可，这里抛出的异常，将在执行登录那里捕获到（注意，由于我这里定义的MyRealm是实现了Realm接口，所以这里的用户名和密码都需要我手动判断是否正确，后面的文章我会介绍其他写法）。</p><p>OK，创建好了MyRealm之后还不够，我们还需要做一个简单配置，让MyRealm生效，将shiro.ini文件中的所有东西都注释掉，添加如下两行：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyRealm= org.sang.MyRealm</span><br><span class="line">securityManager.realms=$MyRealm</span><br></pre></td></tr></table></figure><p>第一行表示定义了一个realm，第二行将这个定义好的交给securityManger，这里实际上会调用到RealmSecurityManager类的setRealms方法。OK，做好这些之后，小伙伴们可以在MyRealm类中的一些关键节点打上断点，再次执行main方法，看看整个的登录流程。 </p><h2 id="4-再来聊一聊Shiro中的Realm"><a href="#4-再来聊一聊Shiro中的Realm" class="headerlink" title="4. 再来聊一聊Shiro中的Realm"></a>4. 再来聊一聊Shiro中的Realm</h2><h3 id="4-1-Realm的继承关系"><a href="#4-1-Realm的继承关系" class="headerlink" title="4.1 Realm的继承关系"></a>4.1 Realm的继承关系</h3><p>通过查看类的继承关系，我们发现Realm的子类实际上有很多种，这里我们就来看看有代表性的几种：</p><ol><li>IniRealm </li></ol><p>可能我们并不知道，实际上这个类在我们第二篇文章中就已经用过了。这个类一开始就有如下两行定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String USERS_SECTION_NAME = <span class="hljs-string">"users"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROLES_SECTION_NAME = <span class="hljs-string">"roles"</span>;</span><br></pre></td></tr></table></figure><p>这两行配置表示shiro.ini文件中，[users]下面的表示表用户名密码还有角色，[roles]下面的则是角色和权限的对应关系。</p><ol start="2"><li>PropertiesRealm</li></ol><p>PropertiesRealm则规定了另外一种用户、角色定义方式，如下：</p><p>user.user1=password,role1<br>role.role1=permission1</p><ol start="3"><li>JdbcRealm</li></ol><p>这个顾名思义，就是从数据库中查询用户的角色、权限等信息。打开JdbcRealm类，我们看到源码中有如下几行：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_AUTHENTICATION_QUERY = <span class="hljs-string">"select password from users where username = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SALTED_AUTHENTICATION_QUERY = <span class="hljs-string">"select password, password_salt from users where username = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_USER_ROLES_QUERY = <span class="hljs-string">"select role_name from user_roles where username = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PERMISSIONS_QUERY = <span class="hljs-string">"select permission from roles_permissions where role_name = ?"</span>;</span><br></pre></td></tr></table></figure><p>根据这几行预设的SQL我们就可以大致推断出数据库中表的名称以及字段了，当然，我们也可以自定义SQL。JdbcRealm实际上是AuthenticatingRealm的子类，关于AuthenticatingRealm我们在后面还会详细说到，这里先不展开。接下来我们就来详细说说这个JdbcRealm。</p><h3 id="4-2-JdbcRealm"><a href="#4-2-JdbcRealm" class="headerlink" title="4.2 JdbcRealm"></a>4.2 JdbcRealm</h3><ol><li>准备工作</li></ol><p>使用JdbcRealm，涉及到数据库操作，要用到数据库连接池，这里我使用Druid数据库连接池，因此首先添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数据库创建</li></ol><p>想要使用JdbcRealm，那我首先要创建数据库，根据JdbcRealm中预设的SQL，我定义的数据库表结构如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1387c9ffa9e2e2e731c1ff4ba305fe64.png" alt="p309"></p><p>这里为了大家能够直观的看到表的关系，我使用了外键，实际工作中，视情况而定。然后向表中添加几条测试数据。数据库脚本小伙伴可以在github上下载到（<a href="https://github.com/lenve/shiroSamples/blob/v4/shiroDemo.sql）。" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/blob/v4/shiroDemo.sql）。</a></p><ol start="3"><li>配置文件处理</li></ol><p>然后将shiro.ini中的所有配置注释掉，添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql://localhost:3306/shiroDemo</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123</span><br><span class="line">jdbcRealm.dataSource=$dataSource</span><br><span class="line">jdbcRealm.permissionsLookupEnabled=true</span><br><span class="line">securityManager.realms=$jdbcRealm</span><br></pre></td></tr></table></figure><p>这里的配置文件都很简单，不做过多赘述，小伙伴唯一需要注意的是permissionsLookupEnabled需要设置为true，否则一会JdbcRealm就不会去查询权限用户权限。</p><ol start="4"><li>测试</li></ol><p>OK，做完上面几步就可以测试了，测试方式和第二篇文章中一样，我们可以测试下用户登录，用户角色和用户权限。</p><ol start="5"><li>自定义查询SQL</li></ol><p>小伙伴们看懂了上文，对于自定义查询SQL就没什么问题了。我这里举一个简单的例子，比如我要自定义authenticationQuery对对应的SQL，查看JdbcRealm源码，我们发现authenticationQuery对应的SQL本来是<figure class="highlight plain hljs"><figcaption><span>password from users where username </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>jdbcRealm.authenticationQuery=select password from employee where username = ?<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OK,这个小伙伴下来自己做尝试，我这里就不演示了。</span><br><span class="line"></span><br><span class="line">## 5. Shiro中多Realm的认证策略问题</span><br><span class="line"></span><br><span class="line">### 5.1 多Realm认证策略</span><br><span class="line"></span><br><span class="line">不知道小伙伴们是否还记得这张登录流程图：</span><br><span class="line"></span><br><span class="line">![p308](https://img-blog.csdnimg.cn/img_convert/f8b6568be71a8cb15f49f862101dd661.png)</span><br><span class="line"></span><br><span class="line">从这张图中我们可以清晰看到Realm是可以有多个的，不过到目前为止，我们所有的案例都还是单Realm，那么我们先来看一个简单的多Realm情况。</span><br><span class="line"></span><br><span class="line">前面的文章我们自己创建了一个MyRealm，也用过JdbcRealm，但都是单独使用的，现在我想将两个一起使用，只需要修改shiro.ini配置即可，如下：</span><br><span class="line"></span><br><span class="line">```properties</span><br><span class="line">MyRealm= org.sang.MyRealm</span><br><span class="line"></span><br><span class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql://localhost:3306/shiroDemo</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123</span><br><span class="line">jdbcRealm.dataSource=$dataSource</span><br><span class="line">jdbcRealm.permissionsLookupEnabled=true</span><br><span class="line">securityManager.realms=$jdbcRealm,$MyRealm</span><br></pre></td></tr></table></figure></p><p>但是此时我数据库中用户的信息是sang/123,MyRealm中配置的信息也是sang/123，我把MyRealm中的用户信息修改为<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">    String password = new String(((char[]) token.getCredentials()));</span><br><span class="line">    String username = token.getPrincipal().toString();</span><br><span class="line">    if (!&quot;江南一点雨&quot;.equals(username)) &#123;</span><br><span class="line">        throw new UnknownAccountException(&quot;用户不存在&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!&quot;456&quot;.equals(password)) &#123;</span><br><span class="line">        throw new IncorrectCredentialsException(&quot;密码不正确&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return new SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候我们就配置了两个Realm，还是使用我们一开始的测试代码进行登录测试，这个时候我们发现我既可以使用<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.2 原理追踪</span><br><span class="line"></span><br><span class="line">好了，有了上面的问题后，接下来我们在Subject的login方法上打断点，跟随程序的执行步骤，我们来到了ModularRealmAuthenticator类的doMultiRealmAuthentication方法中，如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</span><br><span class="line">    this.assertRealmsConfigured();</span><br><span class="line">    Collection&lt;Realm&gt; realms = this.getRealms();</span><br><span class="line">    return realms.size() == 1?this.doSingleRealmAuthentication((Realm)realms.iterator().next(), authenticationToken):this.doMultiRealmAuthentication(realms, authenticationToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法中，首先会获取当前一共有多少个realm，如果只有一个则执行doSingleRealmAuthentication方法进行处理，如果有多个realm，则执行doMultiRealmAuthentication方法进行处理。doSingleRealmAuthentication方法部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doSingleRealmAuthentication</span><span class="hljs-params">(Realm realm, AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    AuthenticationInfo info = realm.getAuthenticationInfo(token);</span><br><span class="line">    <span class="hljs-keyword">if</span>(info == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        String msg = <span class="hljs-string">"Realm ["</span> + realm + <span class="hljs-string">"] was unable to find account data for the submitted AuthenticationToken ["</span> + token + <span class="hljs-string">"]."</span>;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(msg);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到这里就明白了，这里调用了realm的getAuthenticationInfo方法，这个方法实际上就是我们自己实现的MyRealm中的getAuthenticationInfo方法。</p><p>那如果有多个Realm呢？我们来看看doMultiRealmAuthentication方法的实现，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doMultiRealmAuthentication</span><span class="hljs-params">(Collection&lt;Realm&gt; realms, AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">    AuthenticationStrategy strategy = <span class="hljs-keyword">this</span>.getAuthenticationStrategy();</span><br><span class="line">    AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token);</span><br><span class="line">    Iterator var5 = realms.iterator();</span><br><span class="line">    <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">        Realm realm = (Realm)var5.next();</span><br><span class="line">        aggregate = strategy.beforeAttempt(realm, token, aggregate);</span><br><span class="line">        <span class="hljs-keyword">if</span>(realm.supports(token)) &#123;</span><br><span class="line">            AuthenticationInfo info = <span class="hljs-keyword">null</span>;</span><br><span class="line">            Throwable t = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                info = realm.getAuthenticationInfo(token);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            aggregate = strategy.afterAttempt(realm, token, info, aggregate, t);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="hljs-string">"Realm [&#123;&#125;] does not support token &#123;&#125;.  Skipping realm."</span>, realm, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    aggregate = strategy.afterAllAttempts(token, aggregate);</span><br><span class="line">    <span class="hljs-keyword">return</span> aggregate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里主要来说下这个方法的实现思路：</p><ol><li><p>首先获取多Realm认证策略</p></li><li><p>构建一个AuthenticationInfo用来存放一会认证成功之后返回的信息</p></li><li><p>遍历Realm，调用每个Realm中的getAuthenticationInfo方法，看是否能够认证成功</p></li><li><p>每次获取到AuthenticationInfo之后，都调用afterAttempt方法进行结果合并</p></li><li><p>遍历完所有的Realm之后，调用afterAllAttempts进行结果合并，这里主要判断下是否一个都没匹配上</p></li></ol><h3 id="5-3-自由配置认证策略"><a href="#5-3-自由配置认证策略" class="headerlink" title="5.3 自由配置认证策略"></a>5.3 自由配置认证策略</h3><p>OK，经过上面的简单解析，小伙伴们对认证策略应该有一个大致的认识了，那么在Shiro中，一共支持三种不同的认证策略，如下：</p><ol><li><p>AllSuccessfulStrategy，这个表示所有的Realm都认证成功才算认证成功</p></li><li><p>AtLeastOneSuccessfulStrategy，这个表示只要有一个Realm认证成功就算认证成功，默认即此策略</p></li><li><p>FirstSuccessfulStrategy，这个表示只要第一个Realm认证成功，就算认证成功</p></li></ol><p>配置方式也很简单，在shiro.ini中进行配置，在上面配置的基础上，增加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator</span><br><span class="line">securityManager.authenticator=$authenticator</span><br><span class="line">allSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy</span><br><span class="line">securityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy</span><br></pre></td></tr></table></figure><p>此时，我们再进行登录测试，则会要求每个Realm都认证通过才算认证通过。</p><h2 id="6-Shiro中密码加密"><a href="#6-Shiro中密码加密" class="headerlink" title="6. Shiro中密码加密"></a>6. Shiro中密码加密</h2><h3 id="6-1-密码为什么要加密"><a href="#6-1-密码为什么要加密" class="headerlink" title="6.1 密码为什么要加密"></a>6.1 密码为什么要加密</h3><p>2011年12月21日，有人在网络上公开了一个包含600万个CSDN用户资料的数据库，数据全部为明文储存，包含用户名、密码以及注册邮箱。事件发生后CSDN在微博、官方网站等渠道发出了声明，解释说此数据库系2009年备份所用，因不明原因泄露，已经向警方报案。后又在官网网站发出了公开道歉信。在接下来的十多天里，金山、网易、京东、当当、新浪等多家公司被卷入到这次事件中。整个事件中最触目惊心的莫过于CSDN把用户密码明文存储，由于很多用户是多个网站共用一个密码，因此一个网站密码泄露就会造成很大的安全隐患。由于有了这么多前车之鉴，我们现在做系统时，密码都要加密处理。</p><p>密码加密我们一般会用到散列函数，又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有如下几种：</p><ol><li>MD5消息摘要算法</li></ol><p>MD5消息摘要算法是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321中被加以规范。将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞，因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。</p><ol start="2"><li>安全散列算法</li></ol><p>安全散列算法（Secure Hash Algorithm）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。SHA家族的算法，由美国国家安全局所设计，并由美国国家标准与技术研究院发布，是美国的政府标准，其分别是：SHA-0：1993年发布，是SHA-1的前身；SHA-1：1995年发布，SHA-1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5的后继者。但SHA-1的安全性在2000年以后已经不被大多数的加密场景所接受。2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1；SHA-2：2001年发布，包括SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法；SHA-3：2015年正式发布，SHA-3并不是要取代SHA-2，因为SHA-2目前并没有出现明显的弱点。由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，NIST感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的SHA-3。</p><h3 id="6-2-Shiro中如何加密"><a href="#6-2-Shiro中如何加密" class="headerlink" title="6.2 Shiro中如何加密"></a>6.2 Shiro中如何加密</h3><p>Shiro中对以上两种散列算法都提供了支持，对于MD5，Shiro中生成消息摘要的方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Md5Hash md5Hash = <span class="hljs-keyword">new</span> Md5Hash(<span class="hljs-string">"123"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1024</span>);</span><br></pre></td></tr></table></figure><p>第一个参数是要生成密码的明文，第二个参数密码的盐值，第三个参数是生成消息摘要的迭代次数。</p><p>Shiro中对于安全散列算法的支持如下(支持多种算法，这里我举一个例子)：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sha512Hash sha512Hash = <span class="hljs-keyword">new</span> Sha512Hash(<span class="hljs-string">"123"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1024</span>);</span><br></pre></td></tr></table></figure><p>这里三个参数含义与上文基本一致，不再赘述。shiro中也提供了通用的算法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleHash md5 = <span class="hljs-keyword">new</span> SimpleHash(<span class="hljs-string">"md5"</span>, <span class="hljs-string">"123"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1024</span>);</span><br><span class="line">SimpleHash sha512 = <span class="hljs-keyword">new</span> SimpleHash(<span class="hljs-string">"sha-512"</span>, <span class="hljs-string">"123"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1024</span>);</span><br></pre></td></tr></table></figure><p>当用户注册时，我们可以通过上面的方式对密码进行加密，将加密后的字符串存入数据库中。我这里为了简单，就不写注册功能了，就把昨天数据库中用户的密码123改成sha512所对应的字符串，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cb5143cfcf5791478e057be9689d2360005b3aac951f947af1e6e71e3661bf95a7d14183dadfb0967bd6338eb4eb2689e9c227761e1640e6a033b8725fabc783</span><br></pre></td></tr></table></figure><p>同时，为了避免其他Realm的干扰，数据库中我只配置一个JdbcRealm。</p><p>此时如果我不做其他修改的话，登录必然会失败，原因很简单：我登录时输入的密码是123，但是数据库中的密码是一个很长的字符串，所以登录肯定不会成功。通过打断点，我们发现最终的密码比对是在SimpleCredentialsMatcher类中的doCredentialsMatch方法中进行密码比对的，比对的方式也很简单，直接使用了对用户输入的密码和数据库中的密码生成byte数组然后进行比较，最终的比较在MessageDigest类的isEqual方法中。部分逻辑如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object tokenCredentials, Object accountCredentials)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="hljs-comment">//获取用户输入密码的byte数组</span></span><br><span class="line">        <span class="hljs-keyword">byte</span>[] tokenBytes = <span class="hljs-keyword">this</span>.toBytes(tokenCredentials);</span><br><span class="line">        <span class="hljs-comment">//获取数据库中密码的byte数组</span></span><br><span class="line">        <span class="hljs-keyword">byte</span>[] accountBytes = <span class="hljs-keyword">this</span>.toBytes(accountCredentials);</span><br><span class="line">        <span class="hljs-keyword">return</span> MessageDigest.isEqual(tokenBytes, accountBytes);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageDigest的isEqual方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] digesta, <span class="hljs-keyword">byte</span>[] digestb)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (digesta == digestb) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (digesta == <span class="hljs-keyword">null</span> || digestb == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (digesta.length != digestb.length) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-comment">// time-constant comparison</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; digesta.length; i++) &#123;</span><br><span class="line">        result |= digesta[i] ^ digestb[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result == <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是很容易理解的比较代码，这里不赘述。我们现在之所以登录失败是因为没有对用户输入的密码进行加密，通过对源代码的分析，我们发现是因为在AuthenticatingRealm类的assertCredentialsMatch方法中获取了一个名为SimpleCredentialsMatcher的密码比对器，这个密码比对器中比对的方法就是简单的比较，因此如果我们能够将这个密码比对器换掉就好了。我们来看一下CredentialsMatcher的继承关系：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/28604409cf95b6f0cca824c7d20fdcc0.png" alt="p310"></p><p>我们发现这个刚好有一个Sha512CredentialsMatcher比对器，这个比对器的doCredentialsMatch方法在它的父类HashedCredentialsMatcher，方法内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doCredentialsMatch</span><span class="hljs-params">(AuthenticationToken token, AuthenticationInfo info)</span> </span>&#123;</span><br><span class="line">    Object tokenHashedCredentials = hashProvidedCredentials(token, info);</span><br><span class="line">    Object accountCredentials = getCredentials(info);</span><br><span class="line">    <span class="hljs-keyword">return</span> equals(tokenHashedCredentials, accountCredentials);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们发现获取tokenHashedCredentials的方式不像以前那样简单粗暴了，而是调用了hashProvidedCredentials方法，而hashProvidedCredentials方法最终会来到下面这个重载方法中：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Hash <span class="hljs-title">hashProvidedCredentials</span><span class="hljs-params">(Object credentials, Object salt, <span class="hljs-keyword">int</span> hashIterations)</span> </span>&#123;</span><br><span class="line">    String hashAlgorithmName = assertHashAlgorithmName();</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleHash(hashAlgorithmName, credentials, salt, hashIterations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码似曾相识，很明显，是系统帮我们对用户输入的密码进行了转换。了解了这些之后，那我只需要将shiro.ini修改成如下样子即可实现登录了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sha512=org.apache.shiro.authc.credential.Sha512CredentialsMatcher</span><br><span class="line"># 迭代次数</span><br><span class="line">sha512.hashIterations=1024</span><br><span class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql://localhost:3306/shiroDemo</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123</span><br><span class="line">jdbcRealm.dataSource=$dataSource</span><br><span class="line">jdbcRealm.permissionsLookupEnabled=true</span><br><span class="line"># 修改JdbcRealm中的credentialsMatcher属性</span><br><span class="line">jdbcRealm.credentialsMatcher=$sha512</span><br><span class="line">securityManager.realms=$jdbcRealm</span><br></pre></td></tr></table></figure><p>如此之后，我们再进行登录测试，就可以登录成功了。</p><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v6.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v6.zip</a></p><h2 id="7-Shiro中密码加盐"><a href="#7-Shiro中密码加盐" class="headerlink" title="7. Shiro中密码加盐"></a>7. Shiro中密码加盐</h2><h3 id="7-1-密码为什么要加盐"><a href="#7-1-密码为什么要加盐" class="headerlink" title="7.1 密码为什么要加盐"></a>7.1 密码为什么要加盐</h3><p>不管是消息摘要算法还是安全散列算法，如果原文一样，生成密文也是一样的，这样的话，如果两个用户的密码原文一样，存到数据库中密文也就一样了，还是不安全，我们需要做进一步处理，常见解决方案就是加盐。盐从那里来呢？我们可以使用用户id（因为一般情况下，用户id是唯一的），也可以使用一个随机字符，我这里采用第一种方案。</p><h3 id="7-2-Shiro中如何实现加盐"><a href="#7-2-Shiro中如何实现加盐" class="headerlink" title="7.2 Shiro中如何实现加盐"></a>7.2 Shiro中如何实现加盐</h3><p>shiro中加盐的方式很简单，在用户注册时生成密码密文时，就要加入盐，如下几种方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Md5Hash md5Hash = <span class="hljs-keyword">new</span> Md5Hash(<span class="hljs-string">"123"</span>, <span class="hljs-string">"sang"</span>, <span class="hljs-number">1024</span>);</span><br><span class="line">Sha512Hash sha512Hash = <span class="hljs-keyword">new</span> Sha512Hash(<span class="hljs-string">"123"</span>, <span class="hljs-string">"sang"</span>, <span class="hljs-number">1024</span>);</span><br><span class="line">SimpleHash md5 = <span class="hljs-keyword">new</span> SimpleHash(<span class="hljs-string">"md5"</span>, <span class="hljs-string">"123"</span>, <span class="hljs-string">"sang"</span>, <span class="hljs-number">1024</span>);</span><br><span class="line">SimpleHash sha512 = <span class="hljs-keyword">new</span> SimpleHash(<span class="hljs-string">"sha-512"</span>, <span class="hljs-string">"123"</span>, <span class="hljs-string">"sang"</span>, <span class="hljs-number">1024</span>)</span><br></pre></td></tr></table></figure><p>然后我们首先将sha512生成的字符串放入数据库中，接下来我要配置一下我的jdbcRealm，因为我要指定我的盐是什么。在这里我的盐就是我的用户名，每个用户的用户名是不一样的，因此这里没法写死，在JdbcRealm中，系统提供了四种不同的SaltStyle，如下：</p><table><thead><tr><th style="text-align:left">SaltStyle</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left">NO_SALT</td><td>默认，密码不加盐</td></tr><tr><td style="text-align:left">CRYPT</td><td>密码是以Unix加密方式储存的</td></tr><tr><td style="text-align:left">COLUMN</td><td>salt是单独的一列储存在数据库中</td></tr><tr><td style="text-align:left">EXTERNAL</td><td>salt没有储存在数据库中，需要通过JdbcRealm.getSaltForUser(String)函数获取</td></tr></tbody></table><p>四种不同的SaltStyle对应了四种不同的密码处理方式，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">switch</span> (saltStyle) &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> NO_SALT:</span><br><span class="line">    password = getPasswordForUser(conn, username)[<span class="hljs-number">0</span>];</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line"><span class="hljs-keyword">case</span> CRYPT:</span><br><span class="line">    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> separate password and hash from getPasswordForUser[0]</span></span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigurationException(<span class="hljs-string">"Not implemented yet"</span>);</span><br><span class="line">    <span class="hljs-comment">//break;</span></span><br><span class="line"><span class="hljs-keyword">case</span> COLUMN:</span><br><span class="line">    String[] queryResults = getPasswordForUser(conn, username);</span><br><span class="line">    password = queryResults[<span class="hljs-number">0</span>];</span><br><span class="line">    salt = queryResults[<span class="hljs-number">1</span>];</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line"><span class="hljs-keyword">case</span> EXTERNAL:</span><br><span class="line">    password = getPasswordForUser(conn, username)[<span class="hljs-number">0</span>];</span><br><span class="line">    salt = getSaltForUser(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在COLUMN这种情况下，SQL查询结果应该包含两列，第一列是密码，第二列是盐，这里默认执行的SQL在JdbcRealm一开头就定义好了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SALTED_AUTHENTICATION_QUERY = <span class="hljs-string">"select password, password_salt from users where username = ?"</span>;</span><br></pre></td></tr></table></figure><p>即系统默认的盐是数据表中的password_salt提供的，但是我这里是username字段提供的，所以这里我一会要自定义这条SQL。自定义方式很简单，修改shiro.ini文件，添加如下两行：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdbcRealm.saltStyle=COLUMN</span><br><span class="line">jdbcRealm.authenticationQuery=select password,username from users where username=?</span><br></pre></td></tr></table></figure><p>首先设置saltStyle为COLUMN，然后重新定义authenticationQuery对应的SQL。注意返回列的顺序很重要，不能随意调整。如此之后，系统就会自动把username字段作为盐了。</p><p>不过，由于ini文件中不支持枚举，saltStyle的值实际上是一个枚举类型，所以我们在测试的时候，需要增加一个枚举转换器在我们的main方法中，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BeanUtilsBean.getInstance().getConvertUtils().register(<span class="hljs-keyword">new</span> AbstractConverter() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">convertToString</span><span class="hljs-params">(Object value)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ((Enum) value).name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">convertToType</span><span class="hljs-params">(Class type, Object value)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Enum.valueOf(type, value.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> Class <span class="hljs-title">getDefaultType</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, JdbcRealm.SaltStyle.class);</span><br></pre></td></tr></table></figure><p>当然，以后当我们将shiro和web项目整合之后，就不需要这个转换器了。</p><p>如此之后，我们就可以再次进行登录测试了，会发现没什么问题了。</p><h3 id="7-3-非JdbcRealm如何配置盐"><a href="#7-3-非JdbcRealm如何配置盐" class="headerlink" title="7.3 非JdbcRealm如何配置盐"></a>7.3 非JdbcRealm如何配置盐</h3><p>OK，刚刚是在JdbcRealm中配置了盐，如果没用JdbcRealm，而是自己定义的普通Realm，要怎么解决配置盐的问题？</p><p>首先要说明一点是，我们前面的文章在自定义Realm时都是通过实现Realm接口实现的，这种方式有一个缺陷，就是密码比对需要我们自己完成，一般在项目中，我们自定义Realm都是通过继承AuthenticatingRealm或者AuthorizingRealm，因为这两个方法中都重写了getAuthenticationInfo方法，而在getAuthenticationInfo方法中，调用doGetAuthenticationInfo方法获取登录用户，获取到之后，会调用assertCredentialsMatch方法进行密码比对，而我们直接实现Realm接口则没有这一步，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AuthenticationInfo <span class="hljs-title">getAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    AuthenticationInfo info = getCachedAuthenticationInfo(token);</span><br><span class="line">    <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">//调用doGetAuthenticationInfo获取info，这个doGetAuthenticationInfo是我们在自定义Realm中自己实现的</span></span><br><span class="line">        info = doGetAuthenticationInfo(token);</span><br><span class="line">        log.debug(<span class="hljs-string">"Looked up AuthenticationInfo [&#123;&#125;] from doGetAuthenticationInfo"</span>, info);</span><br><span class="line">        <span class="hljs-keyword">if</span> (token != <span class="hljs-keyword">null</span> &amp;&amp; info != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            cacheAuthenticationInfoIfPossible(token, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="hljs-string">"Using cached authentication info [&#123;&#125;] to perform credentials matching."</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">//获取到info之后，进行密码比对</span></span><br><span class="line">        assertCredentialsMatch(token, info);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="hljs-string">"No AuthenticationInfo found for submitted AuthenticationToken [&#123;&#125;].  Returning null."</span>, token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于上面所述的原因，这里我先继承AuthenticatingRealm，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthenticatingRealm</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyRealm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> token <span class="hljs-keyword">instanceof</span> UsernamePasswordToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = token.getPrincipal().toString();</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"sang"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(<span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String dbPassword = <span class="hljs-string">"a593ccad1351a26cf6d91d5f0f24234c6a4da5cb63208fae56fda809732dcd519129acd74046a1f9c5992db8903f50ebf3c1091b3aaf67a05c82b7ee470d9e58"</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username, dbPassword, ByteSource.Util.bytes(username), getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个类，我说如下几点：</p><ol><li><p>用户名我这里还是手动判断了下，实际上这个地方要从数据库查询用户信息，如果查不到用户信息，则直接抛UnknownAccountException</p></li><li><p>返回的SimpleAuthenticationInfo中，第二个参数是密码，正常情况下，这个密码是从数据库中查询出来的，我这里直接写死了</p></li><li><p>第三个参数是盐值，这样构造好SimpleAuthenticationInfo之后返回，shiro会去判断用户输入的密码是否正确</p></li></ol><p>上面的核心步骤是第三步，系统去自动比较密码输入是否正确，在比对的过程中，需要首先对用户输入的密码进行加盐加密，既然加盐加密，就会涉及到credentialsMatcher，这里我们要用的credentialsMatcher实际上和在JdbcRealm中用的credentialsMatcher一样，只需要在配置文件中增加如下一行即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyRealm.credentialsMatcher=$sha512</span><br></pre></td></tr></table></figure><p>sha512和我们上文定义的一致，这里就不再重复说了。</p><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v7.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v7.zip</a></p><h2 id="8-Shiro中自定义带角色和权限的Realm"><a href="#8-Shiro中自定义带角色和权限的Realm" class="headerlink" title="8. Shiro中自定义带角色和权限的Realm"></a>8. Shiro中自定义带角色和权限的Realm</h2><p>密码加密加盐小伙伴们应该没有问题了，但是前面几篇文章又给我们带来了一个新的问题：我们前面IniRealm、JdbcRealm以及自定义的MyRealm，其中前两个我们都能实现用户认证以及授权，即既能管理用户登录，又能管理用户角色，而我们自定义的MyRealm，目前还只能实现登录，不能实现授权，本文我们就来看看自定义Realm如何实现授权。</p><h3 id="8-1-问题追踪"><a href="#8-1-问题追踪" class="headerlink" title="8.1 问题追踪"></a>8.1 问题追踪</h3><p>上篇文章我们没有实现自定义Realm的授权操作，但是这个并不影响我们调用hasRole方法去获取用户的权限，我在上文测试代码上的currentUser.hasRole上面打断点，通过层层追踪，我们发现最终来到了ModularRealmAuthorizer类的hasRole方法中，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasRole</span><span class="hljs-params">(PrincipalCollection principals, String roleIdentifier)</span> </span>&#123;</span><br><span class="line">    assertRealmsConfigured();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Realm realm : getRealms()) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!(realm <span class="hljs-keyword">instanceof</span> Authorizer)) <span class="hljs-keyword">continue</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (((Authorizer) realm).hasRole(principals, roleIdentifier)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在这里会遍历所有的realm，如果这个realm是Authorizer的实例，则会进行进一步的授权操作，如果不是Authorizer的实例，则直接跳过，而我们只有一个自定义的MyRealm继承自AuthenticatingRealm，很明显不是Authorizer的实例，所以这里必然返回false，授权失败，所以要解决授权问题，第一步，得先让我们的MyRealm成为Authorizer的实例。</p><h3 id="8-2-解决方案"><a href="#8-2-解决方案" class="headerlink" title="8.2 解决方案"></a>8.2 解决方案</h3><p>如下图是Authorizer的继承关系：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6ba2ff376345402cd6f31fb39f83d6a4.png" alt="p311"></p><p>小伙伴们看到，在Authorizer的实现类中有一个AuthorizingRealm，打开这个类，我们发现它的继承关系如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizingRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthenticatingRealm</span></span></span><br><span class="line"><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Authorizer</span>, <span class="hljs-title">Initializable</span>, <span class="hljs-title">PermissionResolverAware</span>, <span class="hljs-title">RolePermissionResolverAware</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们发现，这个AuthorizingRealm不仅是Authorizer的实现类，同时也是我们上文所用的AuthenticatingRealm的实现类，既然AuthorizingRealm同时是这两个类的实现类，那么我把MyRealm的继承关系由AuthenticatingRealm改为AuthorizingRealm，肯定不会影响我上文的功能，修改之后的MyRealm如下(部分关键代码)：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = token.getPrincipal().toString();</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"sang"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(<span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String dbPassword = <span class="hljs-string">"a593ccad1351a26cf6d91d5f0f24234c6a4da5cb63208fae56fda809732dcd519129acd74046a1f9c5992db8903f50ebf3c1091b3aaf67a05c82b7ee470d9e58"</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username, dbPassword, ByteSource.Util.bytes(username), getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; roles = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"sang"</span>.equals(principals.getPrimaryPrincipal().toString())) &#123;</span><br><span class="line">            roles.add(<span class="hljs-string">"普通用户"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthorizationInfo(roles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了AuthorizingRealm之后，需要我们实现doGetAuthorizationInfo方法。在这个方法中，我们配置用户的权限。这里我为了方便，直接添加了普通用户这个权限，实际上，这里应该根据用户名去数据库里查询权限，查询方式不赘述。</p><p>通过源码追踪，我们发现最终授权会来到AuthorizingRealm类的如下两个方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasRole</span><span class="hljs-params">(PrincipalCollection principal, String roleIdentifier)</span> </span>&#123;</span><br><span class="line">    AuthorizationInfo info = getAuthorizationInfo(principal);</span><br><span class="line">    <span class="hljs-keyword">return</span> hasRole(roleIdentifier, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasRole</span><span class="hljs-params">(String roleIdentifier, AuthorizationInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> info != <span class="hljs-keyword">null</span> &amp;&amp; info.getRoles() != <span class="hljs-keyword">null</span> &amp;&amp; info.getRoles().contains(roleIdentifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法的逻辑很简单，第一个方法中调用的getAuthorizationInfo方法会最终调用到我们自定义的doGetAuthorizationInfo方法，第二个hasRole方法接收的两个参数，第一个是用户申请的角色，第二个是用户具备的角色集，一个简单的contains函数就判断出用户是否具备某个角色了。</p><p>但是这个时候，用户只有角色，没有权限，我们可以对doGetAuthorizationInfo方法做进一步的完善，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; roles = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    Set&lt;String&gt; permiss = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-string">"sang"</span>.equals(principals.getPrimaryPrincipal().toString())) &#123;</span><br><span class="line">        roles.add(<span class="hljs-string">"普通用户"</span>);</span><br><span class="line">        permiss.add(<span class="hljs-string">"book:update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo(roles);</span><br><span class="line">    info.setStringPermissions(permiss);</span><br><span class="line">    <span class="hljs-keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，正常情况下，权限也应当是从数据库中查询得到的，我这里简化下。</p><p>那么这个角色是怎么验证的呢？追踪源码我们来到了AuthorizingRealm类的如下两个方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPermitted</span><span class="hljs-params">(PrincipalCollection principals, Permission permission)</span> </span>&#123;</span><br><span class="line">    AuthorizationInfo info = getAuthorizationInfo(principals);</span><br><span class="line">    <span class="hljs-keyword">return</span> isPermitted(permission, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//visibility changed from private to protected per SHIRO-332</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPermitted</span><span class="hljs-params">(Permission permission, AuthorizationInfo info)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Permission&gt; perms = getPermissions(info);</span><br><span class="line">    <span class="hljs-keyword">if</span> (perms != <span class="hljs-keyword">null</span> &amp;&amp; !perms.isEmpty()) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (Permission perm : perms) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (perm.implies(permission)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个isPermitted方法中调用了getAuthorizationInfo方法，而getAuthorizationInfo方法最终会调用到我们自己定义的doGetAuthorizationInfo方法，即获取到用户的角色权限信息，然后在第二个方法中进行遍历判断，查看是否具备相应的权限，第二个isPermitted方法的第一个参数就是用户要申请的权限。</p><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v8.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v8.zip</a></p><h2 id="9-Shiro整合Spring"><a href="#9-Shiro整合Spring" class="headerlink" title="9. Shiro整合Spring"></a>9. Shiro整合Spring</h2><h3 id="9-1-Spring-amp-SpringMVC环境搭建"><a href="#9-1-Spring-amp-SpringMVC环境搭建" class="headerlink" title="9.1 Spring&amp;SpringMVC环境搭建"></a>9.1 Spring&amp;SpringMVC环境搭建</h3><p>Spring和SpringMVC环境的搭建，整体上来说，还是比较容易的，因为这个不是本文的重点，因此这里我不做详细介绍，小伙伴可以在文末下载源码查看Spring+SpringMVC环境的搭建。同时，由于MyBatis的整合相对要容易很多，这里为了降低项目复杂度，我也就先不引入MyBatis。</p><p>对于项目依赖，除了Spring、SpringMVC、Shiro相关的依赖，还需要加入Shiro和Spring整合的jar，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-整合Shiro"><a href="#9-2-整合Shiro" class="headerlink" title="9.2 整合Shiro"></a>9.2 整合Shiro</h3><p>搭建好Spring+SpringMVC环境之后，整合Shiro我们主要配置两个地方：</p><ol><li>web.xml中配置代理过滤器，如下：</li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>targetFilterLifecycle<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样之后，当DelegatingFilterProxy拦截到所有请求之后，都会委托给shiroFilter来处理，shiroFilter是我们第二步在Spring容器中配置的一个实例。</p><ol start="2"><li>配置Spring容器</li></ol><p>在Spring容器中至少有两个Bean需要我们配置，一个就是第一步中的shiroFilter，还有一个就是SecurityManager，完整配置如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"securityManager"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/login.jsp"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"successUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/success.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"unauthorizedUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/unauthorized.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            /**=authc</span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个非常简单的配置，我们在以后的文章中还会继续完善它，关于这个配置我说如下几点：</p><ol><li><p>首先我们需要配置一个securityManager，到时候我们的realm要配置在这里。</p></li><li><p>还要配置一个名为shiroFilter的bean，这个名字要和web.xml中代理过滤器的名字一致。</p></li><li><p>shiroFilter中，loginUrl表示登录页面地址。</p></li><li><p>successUrl表示登录成功地址。</p></li><li><p>unauthorizedUrl表示授权失败地址。</p></li><li><p>filterChainDefinitions中配置的<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. authc实际上是一个过滤器，这个我们在后文还会再详细说到。</span><br><span class="line"></span><br><span class="line">8. 匹配符遵循Ant风格路径表达式,这里可以配置多个，匹配顺序从上往下匹配到了就不再匹配了。比如下面这个写法：</span><br></pre></td></tr></table></figure></p></li></ol><p>/a/b/*=anon<br>/a/**=authc<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">假设我的路径是/a/b/c那么就会匹配到第一个过滤器anon，而不会匹配到authc，所以这里的顺序很重要。</span><br><span class="line"></span><br><span class="line">OK，这些配置写完后，在webpap目录下创建对应的jsp文件，如下：</span><br><span class="line"></span><br><span class="line">![p312](https://img-blog.csdnimg.cn/img_convert/881d145a378233fac5eb1fc00c6fe8a4.png)</span><br><span class="line"></span><br><span class="line">此时，启动项目去浏览器中访问，无论我们访问什么地址，最后都会回到login.jsp页面，因为所有的页面（即使不存在的地址）都需要认证后才可以访问。</span><br><span class="line"></span><br><span class="line">本小节案例：https://github.com/lenve/shiroSamples/archive/refs/tags/v9.zip</span><br><span class="line"></span><br><span class="line">## 10. Shiro处理登录的三种方式</span><br><span class="line"></span><br><span class="line">### 10.1 准备工作</span><br><span class="line"></span><br><span class="line">很明显，不管是那种登录，都离不开数据库，这里数据库我采用我们前面的数据库，这里不做赘述(文末可以下载数据库脚本)，但是我这里需要首先配置JdbcRealm，在applicationContext.xml中首先配置数据源，如下：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">&lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>有了数据源之后，接下来配置JdbcRealm，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.realm.jdbc.JdbcRealm"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jdbcRealm"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"credentialsMatcher"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.authc.credential.HashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hashAlgorithmName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"sha-512"</span>/&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hashIterations"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1024"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"saltStyle"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"COLUMN"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authenticationQuery"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"select password, username from users where username = ?"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JdbcRealm中这几个属性和我们本系列第七篇文章基本是一致的，首先我们配置了密码比对器为HashedCredentialsMatcher，相应的算法为sha512，密码加密迭代次数为1024次，然后我们配置了密码的盐从数据表的列中来，username列就是我们的盐，这些配置和前文都是一致的，不清楚的小伙伴可以参考我们本系列第七篇文章。</p><h3 id="10-2-自定义登录逻辑"><a href="#10-2-自定义登录逻辑" class="headerlink" title="10.2 自定义登录逻辑"></a>10.2 自定义登录逻辑</h3><p>自定义登录逻辑比较简单，首先我们把login.jsp页面进行简单改造：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登录"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后创建我们的登录处理Controller，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">    UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        currentUser.login(token);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录成功我们就去success页面，登录失败就回到登录页面。做完这两步之后，我们还要修改shiroFilter中的filterChainDefinitions属性，要设置<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">&lt;bean class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot; id=&quot;shiroFilter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;successUrl&quot; value=&quot;/success.jsp&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            /login=anon</span><br><span class="line">            /**=authc</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>做完这些之后，就可以去login.jsp页面测试登录了。</p><p>上面中方式是我们自己写登录逻辑，shiro也给我们提供了两种不用自己写登录逻辑的登录方式，请继续往下看。</p><h3 id="10-3-基于HTTP的认证"><a href="#10-3-基于HTTP的认证" class="headerlink" title="10.3 基于HTTP的认证"></a>10.3 基于HTTP的认证</h3><p>shiro中也提供了基于http协议的认证，当然，这种认证也得有数据库的辅助，数据配置和前文一样，我们只需要修改一个配置即可，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            /**=authcBasic</span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个表示所有的页面都要经过基于http的认证。此时我们打开任意一个页面，认证方式如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/44eacd352b9f3fcfa96cb9a4d7eeb88c.png" alt="p313"></p><h3 id="10-4-表单登录"><a href="#10-4-表单登录" class="headerlink" title="10.4 表单登录"></a>10.4 表单登录</h3><p>表单登录和基于HTTP的登录类似，都是不需要我们自己写登录逻辑的登录，但是出错的逻辑还是要稍微处理下，首先修改shiroFilter：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/login"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"successUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/success.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            /**=authc</span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置登录页面，也配置登录成功后的跳转页面，同时设置所有页面都要登录后才能访问。</p><p>配置登录页面请求，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest req, Model model)</span> </span>&#123;</span><br><span class="line">    String shiroLoginFailure = (String) req.getAttribute(<span class="hljs-string">"shiroLoginFailure"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (UnknownAccountException.class.getName().equals(shiroLoginFailure)) &#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"error"</span>, <span class="hljs-string">"账户不存在!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (IncorrectCredentialsException.class.getName().equals(shiroLoginFailure)) &#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"error"</span>, <span class="hljs-string">"密码不正确!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果登录失败，那么在request中会有一个shiroLoginFailure的属性中保存了登录失败的异常类名，通过判断这个类名，我们就可以知道是什么原因导致了登录失败。</p><p>OK，配置好这两步之后，就可以去登录页面测试了。</p><h3 id="10-5-注销登录"><a href="#10-5-注销登录" class="headerlink" title="10.5 注销登录"></a>10.5 注销登录</h3><p>注销登录比较简单，就一个过滤器，按如下方式配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">        /logout=logout</span><br><span class="line">        /**=authc</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过get请求访问<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本小节有三个案例，下载地址如下：</span><br><span class="line"></span><br><span class="line">- https://github.com/lenve/shiroSamples/archive/refs/tags/v10.1.zip</span><br><span class="line">- https://github.com/lenve/shiroSamples/archive/refs/tags/v10.2.zip</span><br><span class="line">- https://github.com/lenve/shiroSamples/archive/refs/tags/v10.3.zip</span><br><span class="line"></span><br><span class="line">## 11. Shiro中的授权问题</span><br><span class="line"></span><br><span class="line">### 11.1 配置角色</span><br><span class="line"></span><br><span class="line">本文的案例在上文的基础上完成，因此Realm这一块我依然采用JdbcRealm，相关的授权就不必配置了。但是这里的数据库脚本有更新，小伙伴需要下载重新执行（https://github.com/lenve/shiroSamples/blob/v11/shiroDemo.sql）。</span><br><span class="line"></span><br><span class="line">先来介绍下目前数据库中用户的情况，数据库中有两个用户，sang具有admin的角色，同时具有```book:*```和```author:create```两个权限，lisi具有user的角色，同时具有```user:info```和```user:delete```两个权限。修改shiroFilter，如下：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;bean class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot; id=&quot;shiroFilter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;successUrl&quot; value=&quot;/success.jsp&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            /admin.jsp=authc,roles[admin]</span><br><span class="line">            /user.jsp=authc,roles[user]</span><br><span class="line">            /logout=logout</span><br><span class="line">            /**=authc</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>关于这里的配置，我说如下几点：</p><ol><li>unauthorizedUrl表示授权失败时展示的页面 </li><li>filterChainDefinitions中我们配置了admin.jsp页面必须登录后才能访问，同时登录的用户必须具有admin角色，user.jsp也是必须登录后才能访问，同时登录的用户必须具有user角色</li></ol><h3 id="11-2-测试"><a href="#11-2-测试" class="headerlink" title="11.2 测试"></a>11.2 测试</h3><p>测试时我们分别用sang/123和lisi/123进行登录，登录成功后分别访问user.jsp和admin.jsp就能看到效果。</p><h3 id="11-3-配置权限"><a href="#11-3-配置权限" class="headerlink" title="11.3 配置权限"></a>11.3 配置权限</h3><p>上面的方式是配置角色，但是还没有配置权限，要配置权限，首先要在jdbcRealm中添加允许权限信息的查询：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"permissionsLookupEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后配置下shiroFilter：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">        /admin.jsp=authc,roles[admin]</span><br><span class="line">        /user.jsp=authc,roles[user]</span><br><span class="line">        /userinfo.jsp=authc,perms[user:info]</span><br><span class="line">        /bookinfo.jsp=authc,perms[book:info]</span><br><span class="line">        /logout=logout</span><br><span class="line">        /**=authc</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里假设访问userinfo.jsp需要user:info权限，访问bookinfo.jsp需要book:info权限。</p><p>OK，做完这些之后就可以测试了，分别用sang/123和lisi/123进行登录，登录成功后分别访问bookinfo.jsp和userinfo.jsp就可以看到不同效果了。</p><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v11.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v11.zip</a></p><h2 id="12-Shiro中的JSP标签"><a href="#12-Shiro中的JSP标签" class="headerlink" title="12. Shiro中的JSP标签"></a>12. Shiro中的JSP标签</h2><h3 id="12-1-缘起"><a href="#12-1-缘起" class="headerlink" title="12.1 缘起"></a>12.1 缘起</h3><p>上篇文章中，我们在success.jsp中写了很多像下面这种超链接：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录成功！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/logout"</span>&gt;</span>注销<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/admin.jsp"</span>&gt;</span>admin.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/user.jsp"</span>&gt;</span>user.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/bookinfo.jsp"</span>&gt;</span>bookinfo.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/userinfo.jsp"</span>&gt;</span>userinfo.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是对于不同身份的用户，并不是每一个链接都是有效的，点击无效的链接会进入到未授权的页面，这样用户体验并不好，最好能够把不可达的链接自动隐藏起来，同时，我也希望能够方便获取当前登录用户的信息等，考虑到这些需求，我们来聊聊shiro中的jsp标签。</p><h3 id="12-2-标签介绍"><a href="#12-2-标签介绍" class="headerlink" title="12.2 标签介绍"></a>12.2 标签介绍</h3><p>shiro中的标签并不多，主要有如下几种：</p><ol><li>shiro:guest</li></ol><p>shiro:guest标签只有在当前未登录时显示里边的内容，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:guest&gt;</span><br><span class="line">    欢迎【游客】访问!</span><br><span class="line">&lt;/shiro:guest&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>shiro:user</li></ol><p>shiro:user是在用户登录之后显示该标签中的内容，无论是通过正常的登录还是通过Remember Me登录，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:user&gt;</span><br><span class="line">    欢迎【&lt;shiro:principal/&gt;】访问!</span><br><span class="line">&lt;/shiro:user&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>shiro:principal</li></ol><p>shiro:principal用来获取当前登录用户的信息，显示效果如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/636d4969a4043f7047ff43b2f0ffb79f.png" alt="p314"></p><p>4.shiro:authenticated</p><p>和shiro:user相比，shiro:authenticated的范围变小，当用户认证成功且不是通过Remember Me认证成功，这个标签中的内容才会显示出来：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:authenticated&gt;</span><br><span class="line">    用户【&lt;shiro:principal/&gt;】身份认证通过，不是通过Remember Me认证!</span><br><span class="line">&lt;/shiro:authenticated&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>shiro:notAuthenticated</li></ol><p>shiro:notAuthenticated也是在用户未认证的情况下显示内容，和shiro:guest不同的是，对于通过Remember Me方式进行的认证，shiro:guest不会显示内容，而shiro:notAuthenticated会显示内容(因为此时并不是游客，但是又确实未认证)，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:notAuthenticated&gt;</span><br><span class="line">    用户未进行身份认证</span><br><span class="line">&lt;/shiro:notAuthenticated&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>shiro:lacksRole</li></ol><p>当用户不具备某个角色时候，显示内容，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:lacksRole name=&quot;admin&quot;&gt;</span><br><span class="line">    用户不具备admin角色</span><br><span class="line">&lt;/shiro:lacksRole&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>shiro:lacksPermission</li></ol><p>当用户不具备某个权限时显示内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:lacksPermission name=&quot;book:info&quot;&gt;</span><br><span class="line">    用户不具备book:info权限</span><br><span class="line">&lt;/shiro:lacksPermission&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li>shiro:hasRole</li></ol><p>当用户具备某个角色时显示的内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&lt;a href=&quot;/admin.jsp&quot;&gt;admin.jsp&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br></pre></td></tr></table></figure><ol start="9"><li>shiro:hasAnyRoles</li></ol><p>当用户具备多个角色中的某一个时显示的内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasAnyRoles name=&quot;user,aaa&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&lt;a href=&quot;/user.jsp&quot;&gt;user.jsp&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/shiro:hasAnyRoles&gt;</span><br></pre></td></tr></table></figure><ol start="10"><li>shiro:hasPermission</li></ol><p>当用户具备某一个权限时显示的内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasPermission name=&quot;book:info&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&lt;a href=&quot;/bookinfo.jsp&quot;&gt;bookinfo.jsp&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/shiro:hasPermission&gt;</span><br></pre></td></tr></table></figure><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v12.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v12.zip</a></p><h2 id="13-Shiro-中的缓存机制"><a href="#13-Shiro-中的缓存机制" class="headerlink" title="13.Shiro 中的缓存机制"></a>13.Shiro 中的缓存机制</h2><h3 id="13-1-添加依赖"><a href="#13-1-添加依赖" class="headerlink" title="13.1 添加依赖"></a>13.1 添加依赖</h3><p>使用缓存，首先需要添加相关依赖，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="13-2-添加配置文件"><a href="#13-2-添加配置文件" class="headerlink" title="13.2 添加配置文件"></a>13.2 添加配置文件</h3><p>ehcache的配置文件主要参考官方的配置，在resources目录下创建ehcache.xml文件，内容如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"java.io.tmpdir/shiro-spring-sample"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"120"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"120"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"120"</span></span></span><br><span class="line"><span class="hljs-tag">    /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"shiro-activeSessionCache"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">eternal</span>=<span class="hljs-string">"true"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"true"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">"true"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"600"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.apache.shiro.realm.SimpleAccountRealm.authorization"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"100"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"600"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"false"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些都是ehcache缓存中常规的配置，含义我就不一一解释了，文末下载源码有注释。</p><h3 id="13-3-缓存配置"><a href="#13-3-缓存配置" class="headerlink" title="13.3 缓存配置"></a>13.3 缓存配置</h3><p>接下来我们只需要在applicationContext中简单配置下缓存即可，配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cacheManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheManagerConfigFile"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:ehcache.xml"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"securityManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"realm"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jdbcRealm"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"cacheManager"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先配置EhCacheManager类，指定缓存位置，然后在DefaultWebSecurityManager中引入cacheManager即可，如此之后，我们的缓存就应用上了。</p><h3 id="13-4-测试"><a href="#13-4-测试" class="headerlink" title="13.4 测试"></a>13.4 测试</h3><p>由于我这里使用了JdbcRealm，如果使用了自定义Realm那么可以通过打日志看是否使用了缓存，使用了JdbcRealm之后，我们可以通过打断点来查看是否应用了缓存，比如我执行如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subject.checkRole(<span class="hljs-string">"admin"</span>);</span><br><span class="line">subject.checkPermission(<span class="hljs-string">"book:info"</span>);</span><br></pre></td></tr></table></figure><p>通过断点跟踪，发现最终会来到AuthorizingRealm的getAuthorizationInfo方法中，在该方法中，首先会去缓存中检查数据，如果缓存中有数据，则不会执行doGetAuthorizationInfo方法（数据库操作就在doGetAuthorizationInfo方法中进行），如果缓存中没有数据，则会执行doGetAuthorizationInfo方法，并且在执行成功后将数据保存到缓存中（前提是配置了缓存，cache不为null），此时我们通过断点，发现执行了缓存而没有查询数据库中的数据，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">getAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">    AuthorizationInfo info = <span class="hljs-keyword">null</span>;</span><br><span class="line">    Cache&lt;Object, AuthorizationInfo&gt; cache = getAvailableAuthorizationCache();</span><br><span class="line">    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">        info = cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        info = doGetAuthorizationInfo(principals);</span><br><span class="line">        <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span> &amp;&amp; cache != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">            cache.put(key, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，整体来说shiro中的缓存配置还是非常简单的。</p><p>That’s all.</p><p>本小节案例下载地址：<a href="https://github.com/lenve/shiroSamples/archive/v13.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/v13.zip</a></p><p>待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和大家分享一个松哥原创的 Shiro 教程吧，还没写完，先整一部分，剩下的敬请期待。&lt;/p&gt;
&lt;h2 id=&quot;1-Shiro简介&quot;&gt;&lt;a href=&quot;#1-Shiro简介&quot; class=&quot;headerlink&quot; title=&quot;1.Shiro简介&quot;&gt;&lt;/a&gt;1.Shiro简介&lt;/h2&gt;&lt;p&gt;Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架具有直观、易用等特性，同时也能提供健壮的安全性，虽然它的功能不如SpringSecurity那么强大，但是在普通的项目中也够用了。&lt;/p&gt;
    
    </summary>
    
      <category term="Shiro" scheme="http://www.javaboy.org/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://www.javaboy.org/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中这个默认视图名有点意思，看懂直呼内行内行！</title>
    <link href="http://www.javaboy.org/2021/0407/springmvc-default-viewname.html"/>
    <id>http://www.javaboy.org/2021/0407/springmvc-default-viewname.html</id>
    <published>2021-04-07T08:20:37.000Z</published>
    <updated>2021-04-07T08:21:58.081Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在 Spring Boot 项目中，有的时候我们想返回一段 JSON，结果却忘了写 <code>@ResponseBody</code> 注解，像下面这样：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"01"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候当项目跑起来，肯定会报错，具体报什么错，则要看用的什么视图解析器，如果用了 Freemarker，你可能会看到如下错误：</p><p><img src="http://img.itboyhub.com/2021/02/20210325111006.png" alt></p><p>这个错误是说陷入到循环调用中了。</p><p>如果用了 Thymeleaf，你可能会看到如下错误：</p><p><img src="http://img.itboyhub.com/2021/02/20210325111132.png" alt></p><p>这个是说一个名叫 01 的视图不存在。</p><p>我只是少加了一个 <code>@ResponseBody</code> 注解而已，为什么用不同的视图解析器会报不同的错误？并且这些错误实在看不出和 <code>@ResponseBody</code> 注解有什么关联。</p><p>松哥今天就通过源码分析，来和大家把这个问题讲清楚。</p><h2 id="1-方法入口"><a href="#1-方法入口" class="headerlink" title="1.方法入口"></a>1.方法入口</h2><p>前面松哥刚刚和大家分享了 DispatcherServlet 的源码，并且和大家细致分析了 doDispatch 方法的执行步骤，还没看的小伙伴可以先看看：</p><ul><li><a href="https://mp.weixin.qq.com/s/F0QZ-Ukgtn3oC6a4loM9Vg" target="_blank" rel="noopener">SpringMVC 源码分析之 DispatcherServlet</a></li></ul><p>在这篇文章中，有一个小小细节，就是在 doDispatch 方法中，有如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applyDefaultViewName(processedRequest, mv);</span><br></pre></td></tr></table></figure><p>当这段代码执行的时候，接口方法已经通过反射调用完成了，并且将返回值封装成了一个 ModelAndView 对象（如果接口方法用到了 <code>@ResponseBody</code> 注解，则此时拿到的 ModelAndView 对象为 null），但是这个时候的 ModelAndView 对象还没有渲染，此时会调用 applyDefaultViewName 方法去判断返回的 ModelAndView 对象中有没有 view，如果没有，则给出一个默认的视图名。</p><p>这行代码就是切入点，接下来我们就来分析一下 applyDefaultViewName 方法。</p><h2 id="2-applyDefaultViewName"><a href="#2-applyDefaultViewName" class="headerlink" title="2.applyDefaultViewName"></a>2.applyDefaultViewName</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyDefaultViewName</span><span class="hljs-params">(HttpServletRequest request, @Nullable ModelAndView mv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (mv != <span class="hljs-keyword">null</span> &amp;&amp; !mv.hasView()) &#123;</span><br><span class="line">String defaultViewName = getDefaultViewName(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (defaultViewName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mv.setViewName(defaultViewName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里的判断逻辑很简单，首先检查 mv 是否为 null（如果用户添加了 <code>@ResponseBody</code> 注解，mv 就为 null），然后去判断 mv 中是否包含视图，如果不包含视图，则调用 getDefaultViewName 方法去获取默认的视图名，并将获取到的默认视图名交给 mv。</p><h2 id="3-getDefaultViewName"><a href="#3-getDefaultViewName" class="headerlink" title="3.getDefaultViewName"></a>3.getDefaultViewName</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getDefaultViewName</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.viewNameTranslator != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.viewNameTranslator.getViewName(request) : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个新的组件 viewNameTranslator，如果 viewNameTranslator 不为 null，则调用其 getViewName 方法获取默认的视图名。</p><p>viewNameTranslator 其实就是 RequestToViewNameTranslator，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RequestToViewNameTranslator</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getViewName</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口很简单，里边就一个方法 getViewName 方法来返回视图名称。在 SpringMVC 中，RequestToViewNameTranslator 接口只有一个默认的实现类 DefaultRequestToViewNameTranslator，我们来看下实现类中的 getViewName 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getViewName</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String path = ServletRequestPathUtils.getCachedPathValue(request);</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.prefix + transformPath(path) + <span class="hljs-keyword">this</span>.suffix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">transformPath</span><span class="hljs-params">(String lookupPath)</span> </span>&#123;</span><br><span class="line">String path = lookupPath;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stripLeadingSlash &amp;&amp; path.startsWith(SLASH)) &#123;</span><br><span class="line">path = path.substring(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stripTrailingSlash &amp;&amp; path.endsWith(SLASH)) &#123;</span><br><span class="line">path = path.substring(<span class="hljs-number">0</span>, path.length() - <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stripExtension) &#123;</span><br><span class="line">path = StringUtils.stripFilenameExtension(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!SLASH.equals(<span class="hljs-keyword">this</span>.separator)) &#123;</span><br><span class="line">path = StringUtils.replace(path, SLASH, <span class="hljs-keyword">this</span>.separator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getViewName 方法中，首先提取出来当前请求路径，如果请求地址是 <code>http://localhost:8080/01</code>，那么这里提取出来的路径就是 <code>/01</code>，然后通过 transformPath 方法对路径进行处理，再分别加上前后缀后返回，默认的前后缀都是空字符串（如有需要，也可以自行配置）。</p><p>transformPath 则主要干了如下几件事：</p><ol><li>去掉路径开始的 <code>/</code>。</li><li>去掉路径结尾的 <code>/</code>。</li><li>如果请求路径有扩展名，则去掉扩展名，例如请求路径是 <code>/01.txt</code>，经过这一步处理后，就变成了 <code>/01</code>。</li><li>如果 separator 与 SLASH 不同，则替换原来的分隔符（默认是相同的）。</li></ol><p>好了，经过这一波处理后，正常情况下，我们就拿到了一个新的视图名，这个新的视图名就是你的请求路径。</p><p>例如请求路径是 <code>http://localhost:8080/01</code>，那么获取到的默认视图名就是 <code>01</code>。</p><p>现在大家就知道了，在没有写 <code>@ResponseBody</code> 的情况下，SpringMVC 会自动提取出一个默认的视图名，并且根据这个视图名去查找视图。</p><h2 id="4-问题分析"><a href="#4-问题分析" class="headerlink" title="4.问题分析"></a>4.问题分析</h2><p>要搞清楚这个问题，需要大家对视图解析器有一定了解，如果还不了解，可以先看看松哥之前的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/rn-6QyuYIsM_P5b4B1OIrg" target="_blank" rel="noopener">SpringMVC 九大组件之 ViewResolver 深入分析</a></li><li><a href="https://mp.weixin.qq.com/s/jr6vXw48ackqoeF7FR5pcw" target="_blank" rel="noopener">SpringMVC 中如何同时存在多个视图解析器</a></li></ul><p>看完视图解析器的分析之后，接下来的内容就很好理解了。</p><h3 id="4-1-Freemarker"><a href="#4-1-Freemarker" class="headerlink" title="4.1 Freemarker"></a>4.1 Freemarker</h3><p>先来看使用了 Freemarker 后为什么报循环调用的错。</p><p>根据前面两篇文章的分析，现在我们在 Spring Boot 中默认使用的视图解析器是 ContentNegotiatingViewResolver，在这个视图解析器中会首先选出所有候选的 View，由于我们的代码中并不存在一个名为 01 的 Freemarker 视图（如果刚好存在一个名为 01 的 Freemarker 视图就不会报错了，就直接将该视图展示出来了），而 FreeMarkerViewResolver 的父类 UrlBasedViewResolver 中的 loadView 方法在加载视图的时候，会去检查视图是否存在，结果发现视图吧不存在，导致最终返回 null。所以当 01 这个视图不存在时，最终负责处理该视图的并不是 FreeMarkerViewResolver，而是否则兜底的 InternalResourceViewResolver，该视图解析器最终构建出来的视图就是 InternalResourceView。</p><p>InternalResourceView 在最终渲染之前，会有一个预处理，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">prepareForRendering</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String path = getUrl();</span><br><span class="line">Assert.state(path != <span class="hljs-keyword">null</span>, <span class="hljs-string">"'url' not set"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.preventDispatchLoop) &#123;</span><br><span class="line">String uri = request.getRequestURI();</span><br><span class="line"><span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">"/"</span>) ? uri.equals(path) : uri.equals(StringUtils.applyRelativePath(uri, path))) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Circular view path ["</span> + path + <span class="hljs-string">"]: would dispatch back "</span> +</span><br><span class="line"><span class="hljs-string">"to the current handler URL ["</span> + uri + <span class="hljs-string">"] again. Check your ViewResolver setup! "</span> +</span><br><span class="line"><span class="hljs-string">"(Hint: This may be the result of an unspecified view, due to default view name generation.)"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方的 getUrl 参数是在 buildView 方法中设置的（具体参见：<a href="https://mp.weixin.qq.com/s/rn-6QyuYIsM_P5b4B1OIrg" target="_blank" rel="noopener">SpringMVC 九大组件之 ViewResolver 深入分析</a>），它返回的视图的完整路径名，也就是 <code>prefix + viewName + suffix</code>，如果这个路径和当前请求路径一致，就抛出异常，抛出的异常就是我们一开始截图中看到的异常（其实异常中也说了，这个问题可能是由于自动生成 viewName 导致的）。</p><p>这就是为什么当我们使用 Freemarker 依赖时报循环请求的异常。</p><h3 id="4-2-Thymeleaf"><a href="#4-2-Thymeleaf" class="headerlink" title="4.2 Thymeleaf"></a>4.2 Thymeleaf</h3><p>再来看 Thymeleaf，使用 Thymeleaf 时报的异常是模版不存在。</p><p>首先我们找到异常抛出的位置是在 TemplateManager#resolveTemplate 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TemplateResolution <span class="hljs-title">resolveTemplate</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> IEngineConfiguration configuration,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> String ownerTemplate,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> String template,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; templateResolutionAttributes,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> failIfNotExists)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ITemplateResolver templateResolver : configuration.getTemplateResolvers()) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> TemplateResolution templateResolution =</span><br><span class="line">                templateResolver.resolveTemplate(configuration, ownerTemplate, template, templateResolutionAttributes);</span><br><span class="line">        <span class="hljs-keyword">if</span> (templateResolution != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> templateResolution;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!failIfNotExists) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TemplateInputException(</span><br><span class="line">            <span class="hljs-string">"Error resolving template ["</span> + template + <span class="hljs-string">"], "</span> +</span><br><span class="line">            <span class="hljs-string">"template might not exist or might not be accessible by "</span> +</span><br><span class="line">            <span class="hljs-string">"any of the configured Template Resolvers"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法在执行的过程中如果没能提前返回，最终就会抛出异常，抛出的异常也就是我们在控制台所看到的异常。执行到这一步的原因是前面获取到的 templateResolution 为 null，并且 failIfNotExists 参数为 true，failIfNotExists 参数在调用的时候固定传入，这个没啥好说的，问题的核心在于获取到的 templateResolution 是否为 null。</p><p>templateResolution 则是在 AbstractTemplateResolver#resolveTemplate 方法中获取到的，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> TemplateResolution <span class="hljs-title">resolveTemplate</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> IEngineConfiguration configuration,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> String ownerTemplate, <span class="hljs-keyword">final</span> String template,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; templateResolutionAttributes)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!computeResolvable(configuration, ownerTemplate, template, templateResolutionAttributes)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">final</span> ITemplateResource templateResource = computeTemplateResource(configuration, ownerTemplate, template, templateResolutionAttributes);</span><br><span class="line">    <span class="hljs-keyword">if</span> (templateResource == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.checkExistence &amp;&amp; !templateResource.exists()) &#123; <span class="hljs-comment">// will only check if flag set to true</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TemplateResolution(</span><br><span class="line">            templateResource,</span><br><span class="line">            <span class="hljs-keyword">this</span>.checkExistence,</span><br><span class="line">            computeTemplateMode(configuration, ownerTemplate, template, templateResolutionAttributes),</span><br><span class="line">            <span class="hljs-keyword">this</span>.useDecoupledLogic,</span><br><span class="line">            computeValidity(configuration, ownerTemplate, template, templateResolutionAttributes));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在拿到 templateResource 之后，会调用 <code>templateResource.exists()</code> 方法判断资源是否存在，也就是相应的模版文件是否存在，如果不存在就会返回 null，进而导致上一个方法抛出异常。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天主要和小伙伴们分享了一下 SpringMVC 中默认视图名的问题，不知道大家有没有 GET 到呢～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在 Spring Boot 项目中，有的时候我们想返回一段 JSON，结果却忘了写 &lt;code&gt;@ResponseBody&lt;/code&gt; 注解，像下面这样：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 九大组件之 ViewResolver 深入分析</title>
    <link href="http://www.javaboy.org/2021/0402/springmvc-viewresolver.html"/>
    <id>http://www.javaboy.org/2021/0402/springmvc-viewresolver.html</id>
    <published>2021-04-02T06:54:42.000Z</published>
    <updated>2021-04-02T06:56:53.276Z</updated>
    
    <content type="html"><![CDATA[<p>SpringMVC 中的九大组件前面已经和大家分享了好几个了，今天我们来继续视图解析器的分析。</p><a id="more"></a><p>关于视图解析器，松哥其实在之前的文章中有和大家分享过，那一次是为了解决多个视图共存的问题，如果小伙伴们还没看过那篇文章，可以先看看：</p><ul><li><a href="https://mp.weixin.qq.com/s/jr6vXw48ackqoeF7FR5pcw" target="_blank" rel="noopener">SpringMVC 中如何同时存在多个视图解析器</a></li></ul><p>ViewResolver 其实就是我们心心念念的视图解析器，用过 SpringMVC 的小伙伴都知道 SpringMVC 中有一个视图解析器，今天我们就来分析一下这个视图解析器到底是怎么工作的。</p><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p>首先我们来大概看一下 ViewResolver 接口是什么样子的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ViewResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中只有一个方法，可以看到，非常简单，就是通过视图名和 Locale，找到对应的 View 返回即可。</p><p>如图直接继承自 ViewResolver 接口的类有四个，作用如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210323162032.png" alt></p><ul><li>ContentNegotiatingViewResolver：支持 MediaType 和后缀的视图解析器。</li><li>BeanNameViewResolver：这个是直接根据视图名去 Spring 容器中查找相应的 Bean 并返回。</li><li>AbstractCachingViewResolver：具有缓存功能的视图解析器。</li><li>ViewResolverComposite：这是一个组合的视图解析器，届时可以用来代理其他具体干活的视图解析器。</li></ul><p>接下来我们就对这四个视图解析器逐一进行介绍，先从最简单的 BeanNameViewResolver 开始吧。</p><h2 id="2-BeanNameViewResolver"><a href="#2-BeanNameViewResolver" class="headerlink" title="2.BeanNameViewResolver"></a>2.BeanNameViewResolver</h2><p>BeanNameViewResolver 的处理方式非常简单粗暴，直接根据 viewName 去 Spring 容器中查找相应的 Bean 并返回，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">ApplicationContext context = obtainApplicationContext();</span><br><span class="line"><span class="hljs-keyword">if</span> (!context.containsBean(viewName)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!context.isTypeMatch(viewName, View.class)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> context.getBean(viewName, View.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先去判断下有没有相应的 Bean，然后再检查下 Bean 的类型对不对，都没问题，直接查找返回即可。</p><h2 id="3-ContentNegotiatingViewResolver"><a href="#3-ContentNegotiatingViewResolver" class="headerlink" title="3.ContentNegotiatingViewResolver"></a>3.ContentNegotiatingViewResolver</h2><p>ContentNegotiatingViewResolver 其实是目前广泛使用的一个视图解析器，主要是添加了对 MediaType 的支持。ContentNegotiatingViewResolver 这个是 Spring3.0 中引入的的视图解析器，它不负责具体的视图解析，而是根据当前请求的 MIME 类型，从上下文中选择一个合适的视图解析器，并将请求工作委托给它。</p><p>这里我们就先来看看 ContentNegotiatingViewResolver#resolveViewName 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">RequestAttributes attrs = RequestContextHolder.getRequestAttributes();</span><br><span class="line">List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());</span><br><span class="line"><span class="hljs-keyword">if</span> (requestedMediaTypes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);</span><br><span class="line">View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);</span><br><span class="line"><span class="hljs-keyword">if</span> (bestView != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bestView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useNotAcceptableStatusCode) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> NOT_ACCEPTABLE_VIEW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码逻辑也比较简单：</p><ul><li>首先是获取到当前的请求对象，可以直接从 RequestContextHolder 中获取。然后从当前请求对象中提取出 MediaType。</li><li>如果 MediaType 不为 null，则根据 MediaType，找到合适的视图解析器，并将解析出来的 View 返回。</li><li>如果 MediaType 为 null，则为两种情况，如果 useNotAcceptableStatusCode 为 true，则返回 NOT_ACCEPTABLE_VIEW 视图，这个视图其实是一个 406 响应，表示客户端错误，服务器端无法提供与 Accept-Charset 以及 Accept-Language 消息头指定的值相匹配的响应；如果 useNotAcceptableStatusCode 为 false，则返回 null。</li></ul><p>现在问题的核心其实就变成 getCandidateViews 方法和 getBestView 方法了，看名字就知道，前者是获取所有的候选 View，后者则是从这些候选 View 中选择一个最佳的 View，我们一个一个来看。</p><p>先来看 getCandidateViews：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;View&gt; <span class="hljs-title">getCandidateViews</span><span class="hljs-params">(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;View&gt; candidateViews = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">candidateViews.add(view);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (MediaType requestedMediaType : requestedMediaTypes) &#123;</span><br><span class="line">List&lt;String&gt; extensions = <span class="hljs-keyword">this</span>.contentNegotiationManager.resolveFileExtensions(requestedMediaType);</span><br><span class="line"><span class="hljs-keyword">for</span> (String extension : extensions) &#123;</span><br><span class="line">String viewNameWithExtension = viewName + <span class="hljs-string">'.'</span> + extension;</span><br><span class="line">view = viewResolver.resolveViewName(viewNameWithExtension, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">candidateViews.add(view);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.defaultViews)) &#123;</span><br><span class="line">candidateViews.addAll(<span class="hljs-keyword">this</span>.defaultViews);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> candidateViews;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取所有的候选 View 分为两个步骤：</p><ol><li>调用各个 ViewResolver 中的 resolveViewName 方法去加载出对应的 View 对象。</li><li>根据 MediaType 提取出扩展名，再根据扩展名去加载 View 对象，在实际应用中，这一步我们都很少去配置，所以一步基本上是加载不出来 View 对象的，主要靠第一步。</li></ol><p>第一步去加载 View 对象，其实就是根据你的 viewName，再结合 ViewResolver 中配置的 prefix、suffix、templateLocation 等属性，找到对应的 View，方法执行流程依次是 resolveViewName-&gt;createView-&gt;loadView。</p><p>具体执行的方法我就不一一贴出来了，<strong>唯一需要说的一个重点就是最后的 loadView 方法</strong>，我们来看下这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">loadView</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractUrlBasedView view = buildView(viewName);</span><br><span class="line">View result = applyLifecycleMethods(viewName, view);</span><br><span class="line"><span class="hljs-keyword">return</span> (view.checkResource(locale) ? result : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，View 加载出来后，会调用其 checkResource 方法判断 View 是否存在，如果存在就返回 View，不存在就返回 null。</p><p>这是一个非常关键的步骤，但是我们常用的视图对此的处理却不尽相同：</p><ul><li>FreeMarkerView：会老老实实检查。</li><li>ThymeleafView：没有检查这个环节（Thymeleaf 的整个 View 体系不同于 FreeMarkerView 和 JstlView）。</li><li>JstlView：检查结果总是返回 true。</li></ul><p>至此，我们就找到了所有的候选 View，但是大家需要注意，这个候选 View 不一定存在，在有 Thymeleaf 的情况下，返回的候选 View 不一定可用，在 JstlView 中，候选 View 也不一定真的存在。</p><p>接下来调用 getBestView 方法，从所有的候选 View 中找到最佳的 View。getBestView 方法的逻辑比较简单，就是查找看所有 View 的 MediaType，然后和请求的 MediaType 数组进行匹配，第一个匹配上的就是最佳 View，这个过程它不会检查视图是否真的存在，所以就有可能选出来一个压根没有的视图，最终导致 404。</p><p>这就是 ContentNegotiatingViewResolver#resolveViewName 方法的工作过程。</p><p>那么这里还涉及到一个问题，ContentNegotiatingViewResolver 中的 ViewResolver 是从哪里来的？这个有两种来源：默认的和手动配置的。我们来看如下一段初始化代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServletContext</span><span class="hljs-params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">Collection&lt;ViewResolver&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (ViewResolver viewResolver : matchingBeans) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != viewResolver) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewResolvers.add(viewResolver);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.viewResolvers.size(); i++) &#123;</span><br><span class="line">ViewResolver vr = <span class="hljs-keyword">this</span>.viewResolvers.get(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (matchingBeans.contains(vr)) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">String name = vr.getClass().getName() + i;</span><br><span class="line">obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="hljs-keyword">this</span>.viewResolvers);</span><br><span class="line"><span class="hljs-keyword">this</span>.cnmFactoryBean.setServletContext(servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取到 matchingBeans，这个是获取到了 Spring 容器中的所有视图解析器。</li><li>如果 viewResolvers 变量为 null，也就是开发者没有给 ContentNegotiatingViewResolver 配置视图解析器，此时会把查到的 matchingBeans 赋值给 viewResolvers。</li><li>如果开发者为 ContentNegotiatingViewResolver 配置了相关的视图解析器，则去检查这些视图解析器是否存在于 matchingBeans 中，如果不存在，则进行初始化操作。</li></ol><p>这就是 ContentNegotiatingViewResolver 所做的事情。</p><h2 id="4-AbstractCachingViewResolver"><a href="#4-AbstractCachingViewResolver" class="headerlink" title="4.AbstractCachingViewResolver"></a>4.AbstractCachingViewResolver</h2><p>视图这种文件有一个特点，就是一旦开发好了不怎么变，所以将之缓存起来提高加载速度就显得尤为重要了。事实上我们使用的大部分视图解析器都是支持缓存功能，也即 AbstractCachingViewResolver 实际上有很多用武之地。</p><p>我们先来大致了解一下 AbstractCachingViewResolver，然后再来学习它的子类。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isCache()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> createView(viewName, locale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Object cacheKey = getCacheKey(viewName, locale);</span><br><span class="line">View view = <span class="hljs-keyword">this</span>.viewAccessCache.get(cacheKey);</span><br><span class="line"><span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.viewCreationCache) &#123;</span><br><span class="line">view = <span class="hljs-keyword">this</span>.viewCreationCache.get(cacheKey);</span><br><span class="line"><span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">view = createView(viewName, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.cacheUnresolved) &#123;</span><br><span class="line">view = UNRESOLVED_VIEW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.cacheFilter.filter(view, viewName, locale)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.viewAccessCache.put(cacheKey, view);</span><br><span class="line"><span class="hljs-keyword">this</span>.viewCreationCache.put(cacheKey, view);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> (view != UNRESOLVED_VIEW ? view : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先如果没有开启缓存，则直接调用 createView 方法创建视图返回。</li><li>调用 getCacheKey 方法获取缓存的 key。</li><li>去 viewAccessCache 中查找缓存 View，找到了就直接返回。</li><li>去 viewCreationCache 中查找缓存 View，找到了就直接返回，没找到就调用 createView 方法创建新的 View，并将 View 放到两个缓存池中。</li><li>这里有两个缓存池，两个缓存池的区别在于，viewAccessCache 的类型是 ConcurrentHashMap，而 viewCreationCache 的类型是 LinkedHashMap。前者支持并发访问，效率非常高；后者则限制了缓存最大数，效率低于前者。当后者缓存数量达到上限时，会自动删除它里边的元素，在删除自身元素的过程中，也会删除前者 viewAccessCache 中对应的元素。</li></ol><p>那么这里还涉及到一个方法，那就是 createView，我们也来稍微看一下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">createView</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> loadView(viewName, locale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> View <span class="hljs-title">loadView</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>可以看到，createView 中调用了 loadView，而 loadView 则是一个抽象方法，具体的实现要去子类中查看了。</p><p>这就是缓存 View 的查找过程。</p><p>直接继承 AbstractCachingViewResolver 的视图解析器有四种：ResourceBundleViewResolver、XmlViewResolver、UrlBasedViewResolver 以及 ThymeleafViewResolver，其中前两种从 Spring5.3 开始就已经被废弃掉了，因此这里松哥就不做过多介绍，我们主要来看下后两者。</p><h3 id="4-1-UrlBasedViewResolver"><a href="#4-1-UrlBasedViewResolver" class="headerlink" title="4.1 UrlBasedViewResolver"></a>4.1 UrlBasedViewResolver</h3><p>UrlBasedViewResolver 重写了父类的 getCacheKey、createView、loadView 三个方法：</p><p><strong>getCacheKey</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getCacheKey</span><span class="hljs-params">(String viewName, Locale locale)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> viewName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类的 getCacheKey 是 <code>viewName + &#39;_&#39; + locale</code>，现在变成了 viewName。</p><p><strong>createView</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">createView</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!canHandle(viewName, locale)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123;</span><br><span class="line">String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());</span><br><span class="line">RedirectView view = <span class="hljs-keyword">new</span> RedirectView(redirectUrl,</span><br><span class="line">isRedirectContextRelative(), isRedirectHttp10Compatible());</span><br><span class="line">String[] hosts = getRedirectHosts();</span><br><span class="line"><span class="hljs-keyword">if</span> (hosts != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">view.setHosts(hosts);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> applyLifecycleMethods(REDIRECT_URL_PREFIX, view);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (viewName.startsWith(FORWARD_URL_PREFIX)) &#123;</span><br><span class="line">String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());</span><br><span class="line">InternalResourceView view = <span class="hljs-keyword">new</span> InternalResourceView(forwardUrl);</span><br><span class="line"><span class="hljs-keyword">return</span> applyLifecycleMethods(FORWARD_URL_PREFIX, view);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.createView(viewName, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 canHandle 方法判断是否支持这里的逻辑视图。</li><li>接下来判断逻辑视图名前缀是不是 <code>redirect:</code>，如果是，则表示这是一个重定向视图，则构造 RedirectView 进行处理。</li><li>接下来判断逻辑视图名前缀是不是 <code>forward:</code>，如果是，则表示这是一个服务端跳转，则构造 InternalResourceView 进行处理。</li><li>如果前面都不是，则调用父类的 createView 方法去构建视图，这最终会调用到子类的 loadView 方法。</li></ol><p><strong>loadView</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">loadView</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractUrlBasedView view = buildView(viewName);</span><br><span class="line">View result = applyLifecycleMethods(viewName, view);</span><br><span class="line"><span class="hljs-keyword">return</span> (view.checkResource(locale) ? result : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里边就干了三件事：</p><ol><li>调用 buildView 方法构建 View。</li><li>调用 applyLifecycleMethods 方法完成 View 的初始化。</li><li>检车 View 是否存在并返回。</li></ol><p>第三步比较简单，没啥好说的，主要就是检查视图文件是否存在，像我们常用的 Jsp 视图解析器以及 Freemarker 视图解析器都会去检查，但是 Thymeleaf 不会去检查（具体参见：<a href="https://mp.weixin.qq.com/s/jr6vXw48ackqoeF7FR5pcw" target="_blank" rel="noopener">SpringMVC 中如何同时存在多个视图解析器</a>一文）。这里主要是前两步，松哥要和大家着重说一下，这里又涉及到两个方法 buildView 和 applyLifecycleMethods。</p><h4 id="4-1-1-buildView"><a href="#4-1-1-buildView" class="headerlink" title="4.1.1 buildView"></a>4.1.1 buildView</h4><p>这个方法就是用来构建视图的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AbstractUrlBasedView <span class="hljs-title">buildView</span><span class="hljs-params">(String viewName)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">AbstractUrlBasedView view = instantiateView();</span><br><span class="line">view.setUrl(getPrefix() + viewName + getSuffix());</span><br><span class="line">view.setAttributesMap(getAttributesMap());</span><br><span class="line">String contentType = getContentType();</span><br><span class="line"><span class="hljs-keyword">if</span> (contentType != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">view.setContentType(contentType);</span><br><span class="line">&#125;</span><br><span class="line">String requestContextAttribute = getRequestContextAttribute();</span><br><span class="line"><span class="hljs-keyword">if</span> (requestContextAttribute != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">view.setRequestContextAttribute(requestContextAttribute);</span><br><span class="line">&#125;</span><br><span class="line">Boolean exposePathVariables = getExposePathVariables();</span><br><span class="line"><span class="hljs-keyword">if</span> (exposePathVariables != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">view.setExposePathVariables(exposePathVariables);</span><br><span class="line">&#125;</span><br><span class="line">Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes();</span><br><span class="line"><span class="hljs-keyword">if</span> (exposeContextBeansAsAttributes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);</span><br><span class="line">&#125;</span><br><span class="line">String[] exposedContextBeanNames = getExposedContextBeanNames();</span><br><span class="line"><span class="hljs-keyword">if</span> (exposedContextBeanNames != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">view.setExposedContextBeanNames(exposedContextBeanNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 instantiateView 方法，根据我们在配置视图解析器时提供的 viewClass，构建一个 View 对象返回。</li><li>给 view 配置 url，就是前缀+viewName+后缀，其中前缀后缀都是我们在配置视图解析器的时候提供的。</li><li>同理，如果用户在配置视图解析器时提供了 content-type，也将其设置给 View 对象。</li><li>配置 requestContext 的属性名称。</li><li>配置 exposePathVariables，也就是通过 <code>@PathVaribale</code> 注解标记的参数信息。</li><li>配置 exposeContextBeansAsAttributes，表示是否可以在 View 中使用容器中的 Bean，该参数我们可以在配置视图解析器时提供。</li><li>配置 exposedContextBeanNames，表示可以在 View 中使用容器中的哪些 Bean，该参数我们可以在配置视图解析器时提供。</li></ol><p>就这样，视图就构建好了，是不是非常 easy！</p><h4 id="4-1-2-applyLifecycleMethods"><a href="#4-1-2-applyLifecycleMethods" class="headerlink" title="4.1.2 applyLifecycleMethods"></a>4.1.2 applyLifecycleMethods</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> View <span class="hljs-title">applyLifecycleMethods</span><span class="hljs-params">(String viewName, AbstractUrlBasedView view)</span> </span>&#123;</span><br><span class="line">ApplicationContext context = getApplicationContext();</span><br><span class="line"><span class="hljs-keyword">if</span> (context != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object initialized = context.getAutowireCapableBeanFactory().initializeBean(view, viewName);</span><br><span class="line"><span class="hljs-keyword">if</span> (initialized <span class="hljs-keyword">instanceof</span> View) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (View) initialized;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是 Bean 的初始化，没啥好说的。</p><p>UrlBasedViewResolver 的子类还是比较多的，其中有两个比较有代表性的，分别是我们使用 JSP 时所用的 InternalResourceViewResolver 以及当我们使用 Freemarker 时所用的 FreeMarkerViewResolver，由于这两个我们比较常见，因此松哥在这里再和大家介绍一下这两个组件。</p><h3 id="4-2-InternalResourceViewResolver"><a href="#4-2-InternalResourceViewResolver" class="headerlink" title="4.2 InternalResourceViewResolver"></a>4.2 InternalResourceViewResolver</h3><p>当我们使用 JSP 时，可能会用到这个视图解析器。</p><p>InternalResourceViewResolver 主要干了 4 件事：</p><ol><li>通过 requiredViewClass 方法规定了视图。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">protected</span> Class&lt;?&gt; requiredViewClass() &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> InternalResourceView.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在构造方法中调用 requiredViewClass 方法去确定视图，如果项目中引入了 JSTL，则会将视图调整为 JstlView。</li><li>重写了 instantiateView 方法，会根据实际情况初始化不同的 View：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AbstractUrlBasedView <span class="hljs-title">instantiateView</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (getViewClass() == InternalResourceView.class ? <span class="hljs-keyword">new</span> InternalResourceView() :</span><br><span class="line">(getViewClass() == JstlView.class ? <span class="hljs-keyword">new</span> JstlView() : <span class="hljs-keyword">super</span>.instantiateView()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会根据实际情况初始化 InternalResourceView 或者 JstlView，或者调用父类的方法完成 View 的初始化。</p><ol start="4"><li>buildView 方法也重写了，如下：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AbstractUrlBasedView <span class="hljs-title">buildView</span><span class="hljs-params">(String viewName)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">InternalResourceView view = (InternalResourceView) <span class="hljs-keyword">super</span>.buildView(viewName);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.alwaysInclude != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">view.setAlwaysInclude(<span class="hljs-keyword">this</span>.alwaysInclude);</span><br><span class="line">&#125;</span><br><span class="line">view.setPreventDispatchLoop(<span class="hljs-keyword">true</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先调用父类方法构建出 InternalResourceView，然后配置 alwaysInclude，表示是否允许在使用 forward 的情况下也允许使用 include，最后面的 setPreventDispatchLoop 方法则是防止循环调用。</p><h3 id="4-3-FreeMarkerViewResolver"><a href="#4-3-FreeMarkerViewResolver" class="headerlink" title="4.3 FreeMarkerViewResolver"></a>4.3 FreeMarkerViewResolver</h3><p>FreeMarkerViewResolver 和 UrlBasedViewResolver 之间还隔了一个 AbstractTemplateViewResolver，AbstractTemplateViewResolver 比较简单，里边只是多出来了五个属性而已，这五个属性松哥在之前和大家分享 Freemarker 用法的时候都已经说过了（参见：<a href="https://mp.weixin.qq.com/s/1TZfOBMtrTJ7qKHEduLUEw" target="_blank" rel="noopener">Spring Boot + Freemarker 中的弯弯绕！</a>），这里再和大家啰嗦下：</p><ol><li>exposeRequestAttributes：是否将 RequestAttributes 暴露给 View 使用。</li><li>allowRequestOverride：当 RequestAttributes 和 Model 中的数据同名时，是否允许 RequestAttributes 中的参数覆盖 Model 中的同名参数。</li><li>exposeSessionAttributes：是否将 SessionAttributes 暴露给 View 使用。</li><li>allowSessionOverride：当 SessionAttributes 和 Model 中的数据同名时，是否允许 SessionAttributes 中的参数覆盖 Model 中的同名参数。</li><li>exposeSpringMacroHelpers：是否将 RequestContext 暴露出来供 Spring Macro 使用。</li></ol><p>这就是 AbstractTemplateViewResolver 特性，比较简单，再来看 FreeMarkerViewResolver。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerViewResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FreeMarkerViewResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">setViewClass(requiredViewClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FreeMarkerViewResolver</span><span class="hljs-params">(String prefix, String suffix)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>();</span><br><span class="line">setPrefix(prefix);</span><br><span class="line">setSuffix(suffix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">protected</span> Class&lt;?&gt; requiredViewClass() &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> FreeMarkerView.class;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AbstractUrlBasedView <span class="hljs-title">instantiateView</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (getViewClass() == FreeMarkerView.class ? <span class="hljs-keyword">new</span> FreeMarkerView() : <span class="hljs-keyword">super</span>.instantiateView());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeMarkerViewResolver 的源码就很简单了，配置一下前后缀、重写 requiredViewClass 方法提供 FreeMarkerView，重写 instantiateView 方法完成 View 的初始化。</p><p>ThymeleafViewResolver 继承自 AbstractCachingViewResolver，具体的工作流程和前面的差不多，因此这里也就不做过多介绍了。需要注意的是，ThymeleafViewResolver#loadView 方法并不会去检查视图模版是否存在，所以有可能会最终会返回一个不存在的视图（参见：<a href="https://mp.weixin.qq.com/s/jr6vXw48ackqoeF7FR5pcw" target="_blank" rel="noopener">SpringMVC 中如何同时存在多个视图解析器</a>一文）。</p><h2 id="5-ViewResolverComposite"><a href="#5-ViewResolverComposite" class="headerlink" title="5.ViewResolverComposite"></a>5.ViewResolverComposite</h2><p>最后我们再来看下 ViewResolverComposite，ViewResolverComposite 其实我们在前面的源码分析中已经多次见到过这种模式了，通过 ViewResolverComposite 来代理其他的 ViewResolver，不同的是，这里的 ViewResolverComposite 还为其他 ViewResolver 做了一些初始化操作。为对应的 ViewResolver 分别配置了 applicationContext 以及 servletContext。这里的代码比较简单，我就不贴出来了，最后在 ViewResolverComposite#resolveViewName 方法中，遍历其他视图解析器进行处理：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (ViewResolver viewResolver : <span class="hljs-keyword">this</span>.viewResolvers) &#123;</span><br><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line"><span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好啦，今天主要和小伙伴们聊了下 SpringMVC 中视图解析器的工作流程，结合松哥之前的文章<a href="https://mp.weixin.qq.com/s/jr6vXw48ackqoeF7FR5pcw" target="_blank" rel="noopener">SpringMVC 中如何同时存在多个视图解析器</a>，相信大家对于 SpringMVC 中的视图解析器的理解会更进一步。</p><p>好啦，今天就先和大家聊这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringMVC 中的九大组件前面已经和大家分享了好几个了，今天我们来继续视图解析器的分析。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 九大组件之 HandlerAdapter 深入分析</title>
    <link href="http://www.javaboy.org/2021/0401/springmvc-handleradapter.html"/>
    <id>http://www.javaboy.org/2021/0401/springmvc-handleradapter.html</id>
    <published>2021-04-01T06:54:57.000Z</published>
    <updated>2021-04-02T06:56:24.935Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>SpringMVC 九大组件，前面和大家分析了 HandlerMapping，今天我们来看 HandlerAdapter。因为前面已经做了很多铺垫了，所以今天的内容不会太难。</p><a id="more"></a><p>SpringMVC 中通过 HandlerAdapter 来让 Handler 得到执行，为什么拿到 Handler 之后不直接执行呢？那是因为 SpringMVC 中我们定义 Handler 的方式多种多样（虽然日常开发中我们都是使用注解来定义，但是实际上还有其他方式），不同的 Handler 当然对应不同的执行方式，所以这中间就需要一个适配器 HandlerAdapter。</p><h2 id="1-HandlerAdapter-体系"><a href="#1-HandlerAdapter-体系" class="headerlink" title="1.HandlerAdapter 体系"></a>1.HandlerAdapter 体系</h2><p>我们先来看看 HandlerAdapter 大致的继承关系：</p><p><img src="http://img.itboyhub.com/2021/02/20210307212546.png" alt></p><p>可以看到，这里涉及到的子类并不多，而且看名字基本上就知道这个是干啥的。</p><p>这里除了 RequestMappingHandlerAdapter 比较复杂之外，其他几个都是比较容易的，容易是因为这几个调用的方法都是固定的，复杂则是因为调用的方法不固定。我们先来看看这几个容易的。</p><h2 id="2-HandlerAdapter"><a href="#2-HandlerAdapter" class="headerlink" title="2.HandlerAdapter"></a>2.HandlerAdapter</h2><p>HttpRequestHandlerAdapter、SimpleServletHandlerAdapter、HandlerFunctionAdapter、SimpleControllerHandlerAdapter，这四个里边，HandlerFunctionAdapter 用来处理 HandlerFunction 类型的接口，函数式 Web 框架现在呼声很高，但是实际应用的并不多，因此这里我们暂且忽略它，来看另外三个。</p><p><strong>HttpRequestHandlerAdapter</strong></p><p>HttpRequestHandlerAdapter 主要用来处理实现了 HttpRequestHandler 接口的 handler，例如像下面这种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController01</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpRequestHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        response.getWriter().write(<span class="hljs-string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpRequestHandlerAdapter#handle 方法也很简单，直接调用 handleRequest：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (handler <span class="hljs-keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastModified</span><span class="hljs-params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> LastModified) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ((LastModified) handler).getLastModified(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> -<span class="hljs-number">1L</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，supports 方法判断 handler 的类型是否是 HttpRequestHandler，handle 方法则直接调用 handleRequest。</p><p><strong>SimpleControllerHandlerAdapter</strong></p><p>SimpleControllerHandlerAdapter 主要用来处理实现了 Controller 接口的 handler，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleControllerHandlerAdapter 的定义也很简单：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleControllerHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (handler <span class="hljs-keyword">instanceof</span> Controller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastModified</span><span class="hljs-params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> LastModified) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ((LastModified) handler).getLastModified(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> -<span class="hljs-number">1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应该不用再解释了吧。</p><p><strong>SimpleServletHandlerAdapter</strong></p><p>这个用来处理实现了 Servlet 接口的 handler，在实际开发中我们很少用到这种，我就不多说，我们直接来看它的源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleServletHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (handler <span class="hljs-keyword">instanceof</span> Servlet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">((Servlet) handler).service(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastModified</span><span class="hljs-params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，也很简单！handle 方法中直接调用 servlet 的 service 方法。</p><p>可以看到，这三种 HandlerAdapter 简单的原因主要是因为要调用的方法比较简单，直接调用就可以了。而 RequestMappingHandlerAdapter 复杂是因为调用的方法名不固定，所以复杂。</p><h2 id="3-RequestMappingHandlerAdapter"><a href="#3-RequestMappingHandlerAdapter" class="headerlink" title="3.RequestMappingHandlerAdapter"></a>3.RequestMappingHandlerAdapter</h2><p>RequestMappingHandlerAdapter 继承自 AbstractHandlerMethodAdapter，我们先来看看 AbstractHandlerMethodAdapter。</p><h3 id="3-1-AbstractHandlerMethodAdapter"><a href="#3-1-AbstractHandlerMethodAdapter" class="headerlink" title="3.1 AbstractHandlerMethodAdapter"></a>3.1 AbstractHandlerMethodAdapter</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHandlerMethodAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebContentGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerAdapter</span>, <span class="hljs-title">Ordered</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> order = Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractHandlerMethodAdapter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(<span class="hljs-keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> order)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.order = order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsInternal</span><span class="hljs-params">(HandlerMethod handlerMethod)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> ModelAndView <span class="hljs-title">handleInternal</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastModified</span><span class="hljs-params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getLastModifiedInternal(request, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLastModifiedInternal</span><span class="hljs-params">(HttpServletRequest request, HandlerMethod handlerMethod)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractHandlerMethodAdapter 还是比较简单的，前面我们说的三个方法还是没变，只不过三个方法里边分别调用了 supportsInternal、handleInternal 以及 getLastModifiedInternal，而这些 xxxInternal 都将在子类 RequestMappingHandlerAdapter 中被实现。另外 AbstractHandlerMethodAdapter 实现了 Ordered 接口，意味着在配置的时候还可以设置优先级。</p><p>这就是 AbstractHandlerMethodAdapter，比较简单。</p><h3 id="3-2-RequestMappingHandlerAdapter"><a href="#3-2-RequestMappingHandlerAdapter" class="headerlink" title="3.2 RequestMappingHandlerAdapter"></a>3.2 RequestMappingHandlerAdapter</h3><p>RequestMappingHandlerAdapter 承担了大部分的执行工作，通过前面的介绍，我们已经大致知道 RequestMappingHandlerAdapter 中主要实现了三个方法：supportsInternal、handleInternal 以及 getLastModifiedInternal。其中 supportsInternal 总是返回 true，意味着在 RequestMappingHandlerAdapter 中不做任何比较，getLastModifiedInternal 则直接返回 -1，所以对它来说，最重要的其实是 handleInternal 方法。</p><p>整体上来说，RequestMappingHandlerAdapter 要解决三方面的问题：</p><ol><li>处理请求参数。</li><li>调用处理器执行请求。</li><li>处理请求响应。</li></ol><p>三个问题第一个最复杂！大家想想我们平时定义接口时，接口参数是不固定的，有几个参数、参数类型是什么都不确定，有的时候我们还利用 <code>@ControllerAdvice</code> 注解标记了一些全局参数，等等这些都要考虑进来，所以这一步是最复杂的，剩下的两步就比较容易了。对于参数的处理，SpringMVC 中提供了很多参数解析器，在接下来的源码分析中，我们将一步一步见识到这些参数解析器。</p><h4 id="3-2-1-初始化过程"><a href="#3-2-1-初始化过程" class="headerlink" title="3.2.1 初始化过程"></a>3.2.1 初始化过程</h4><p>那么接下来我们就先来看 RequestMappingHandlerAdapter 的初始化过程，由于它实现了 InitializingBean 接口，因此 afterPropertiesSet 方法会被自动调用，在 afterPropertiesSet 方法中，完成了各种参数解析器的初始化：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">initControllerAdviceCache();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.argumentResolvers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line"><span class="hljs-keyword">this</span>.argumentResolvers = <span class="hljs-keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.initBinderArgumentResolvers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line"><span class="hljs-keyword">this</span>.initBinderArgumentResolvers = <span class="hljs-keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returnValueHandlers == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line"><span class="hljs-keyword">this</span>.returnValueHandlers = <span class="hljs-keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initControllerAdviceCache</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (getApplicationContext() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line">List&lt;Object&gt; requestResponseBodyAdviceBeans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line"><span class="hljs-keyword">if</span> (beanType == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Unresolvable type for ControllerAdviceBean: "</span> + adviceBean);</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line"><span class="hljs-keyword">if</span> (!attrMethods.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.modelAttributeAdviceCache.put(adviceBean, attrMethods);</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);</span><br><span class="line"><span class="hljs-keyword">if</span> (!binderMethods.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.initBinderAdviceCache.put(adviceBean, binderMethods);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">requestResponseBodyAdviceBeans.add(adviceBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!requestResponseBodyAdviceBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.requestResponseBodyAdvice.addAll(<span class="hljs-number">0</span>, requestResponseBodyAdviceBeans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先调用 initControllerAdviceCache 方法对包含了 <code>@ControllerAdvice</code> 注解的类进行处理（如果有小伙伴对 <code>@ControllerAdvice</code> 注解的使用还不熟悉，可以在公众号【江南一点雨】后台回复 <strong>666</strong> 或者 <strong>ssm</strong>，有松哥的入门教程，里边都有关于 <code>@ControllerAdvice</code> 的讲解），具体的处理思路如下：</p><ol><li>首先查找到所有标记了 <code>@ControllerAdvice</code> 注解的 Bean，将查找结果保存到 adviceBeans 变量中。</li><li>接下来遍历 adviceBeans，找到对象中包含 <code>@ModelAttribute</code> 注解的方法，将查找的结果保存到 modelAttributeAdviceCache 变量中。</li><li>找到对象中包含 <code>@InitBinder</code> 注解的方法，将查找的结果保存到 initBinderAdviceCache 变量中。</li><li>查找实现了 RequestBodyAdvice 或者 ResponseBodyAdvice 接口的类，并最终将查找结果添加到 requestResponseBodyAdvice 中。实现了 RequestBodyAdvice 或者 ResponseBodyAdvice 接口的类一般需要用 @ControllerAdvice 注解标记，关于这两个接口的详细用法，读者可以参考松哥之前的文章，传送门<a href="https://mp.weixin.qq.com/s/LWuUNHJVnBLK15Msu38Wgw" target="_blank" rel="noopener">如何优雅的实现 Spring Boot 接口参数加密解密？</a>。另外这里还需要注意，找到的 adviceBean 并没有直接放到全局变量中，而是先放在局部变量中，然后才添加到全局的 requestResponseBodyAdvice 中，这种方式可以确保 adviceBean 始终处于集合的最前面。</li></ol><p>这就是 initControllerAdviceCache 方法的处理逻辑，主要是解决了一些全局参数的处理问题。</p><p>我们再回到 afterPropertiesSet 方法中，接下来就是对 argumentResolvers、initBinderArgumentResolvers 以及 returnValueHandlers 的初始化了。</p><p>前两个参数相关的解析器，都是通过 getDefaultXXX 方法获取的，并且把获取的结果添加到 HandlerMethodArgumentResolverComposite 中，这种 xxxComposite，大家一看就知道是一个责任链模式，这个里边管理了诸多的参数解析器，但是它自己不干活，需要工作的时候，它就负责遍历它所管理的参数解析器，让那些参数解析器去处理参数问题。我们先来看看它的 getDefaultXXX 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="hljs-title">getDefaultArgumentResolvers</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">30</span>);</span><br><span class="line"><span class="hljs-comment">// Annotation-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="hljs-keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ServletModelAttributeMethodProcessor(<span class="hljs-keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="hljs-keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters(), <span class="hljs-keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"><span class="hljs-comment">// Type-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="hljs-keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RedirectAttributesMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ModelMethodProcessor());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> MapMethodProcessor());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line"><span class="hljs-keyword">if</span> (KotlinDetector.isKotlinPresent()) &#123;</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ContinuationHandlerMethodArgumentResolver());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Custom arguments</span></span><br><span class="line"><span class="hljs-keyword">if</span> (getCustomArgumentResolvers() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Catch-all</span></span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> PrincipalMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="hljs-keyword">true</span>));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ServletModelAttributeMethodProcessor(<span class="hljs-keyword">true</span>));</span><br><span class="line"><span class="hljs-keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="hljs-title">getDefaultInitBinderArgumentResolvers</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">20</span>);</span><br><span class="line"><span class="hljs-comment">// Annotation-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="hljs-keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"><span class="hljs-comment">// Type-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line"><span class="hljs-comment">// Custom arguments</span></span><br><span class="line"><span class="hljs-keyword">if</span> (getCustomArgumentResolvers() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Catch-all</span></span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> PrincipalMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="hljs-keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="hljs-keyword">true</span>));</span><br><span class="line"><span class="hljs-keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法虽然挺长的，但是内容都比较简单。在 getDefaultArgumentResolvers 方法中，解析器被分为四类：</p><ol><li>通过注解标记的参数对应的解析器。</li><li>通过类型解析的解析器。</li><li>自定义的解析器。</li><li>兜底的解析器（大部分前面搞不定的参数后面的都能搞定，简单数据类型就是在这里处理的）。</li></ol><p>getDefaultInitBinderArgumentResolvers 方法也是类似的，我就不再赘述。</p><p>所谓的解析器实际上就是把参数从对应的介质中提取出来，然后交给方法对应的变量。如果项目有需要，也可以自定义参数解析器，自定义的参数解析器设置到 RequestMappingHandlerAdapter#customArgumentResolvers 属性上，在调用的时候，前两种参数解析器都匹配不上的时候，自定义的参数解析器才会有用，而且这个顺序是固定的无法改变的。</p><p>关于参数解析器本身，如果大家不是特别熟悉的话，可以看看松哥之前的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/4c-uV8f6x5UPvxec6Em79A" target="_blank" rel="noopener">SpringBoot 中如何自定义参数解析器？</a></li><li><a href="https://mp.weixin.qq.com/s/qsS6Dwr6eXx07i5dhn8FEA" target="_blank" rel="noopener">深入分析 SpringMVC 参数解析器</a></li></ul><h4 id="3-2-2-请求执行过程"><a href="#3-2-2-请求执行过程" class="headerlink" title="3.2.2 请求执行过程"></a>3.2.2 请求执行过程</h4><p>根据前面的介绍，请求执行的入口方法实际上就是 handleInternal，所以这里我们就从 handleInternal 方法开始分析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">handleInternal</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ModelAndView mav;</span><br><span class="line">checkRequest(request);</span><br><span class="line"><span class="hljs-comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// No synchronization on session demanded at all...</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">applyCacheSeconds(response, <span class="hljs-keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">prepareResponse(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个 handleInternal 方法看起来平平无奇，没啥特别之处。仔细看起来，它里边就做了三件事：</p><ol><li>checkRequest 方法检查请求。</li><li>invokeHandlerMethod 方法执行处理器方法，这个是核心。</li><li>处理缓存问题。</li></ol><p>那么接下来我们就对这三个问题分别进行分析。</p><h5 id="checkRequest"><a href="#checkRequest" class="headerlink" title="checkRequest"></a>checkRequest</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkRequest</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Check whether we should support the request method.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.supportedMethods != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.supportedMethods.contains(method)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpRequestMethodNotSupportedException(method, <span class="hljs-keyword">this</span>.supportedMethods);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Check whether a session is required.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.requireSession &amp;&amp; request.getSession(<span class="hljs-keyword">false</span>) == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpSessionRequiredException(<span class="hljs-string">"Pre-existing session required but none found"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查就检查了两个东西：</p><ol><li>是否支持请求方法</li></ol><p>当 supportedMethods 不为空的时候，去检查是否支持请求方法。默认情况下，supportedMethods 为 null，所以默认情况下是不检查请求方法的。如果需要检查，可以在注册 RequestMappingHandlerAdapter 的时候进行配置，如果在构造方法中设置 restrictDefaultSupportedMethods 变量为 true，那么默认情况下只支持 GET、POST、以及 HEAD 三种请求，不过这个参数改起来比较麻烦，默认在父类 AbstractHandlerMethodAdapter 类中写死了。</p><ol start="2"><li>是否需要 session</li></ol><p>如果 requireSession 为 true，就检查一下 session 是否存在，默认情况下，requireSession 为 false，所以这里也是不检查的。</p><h5 id="invokeHandlerMethod"><a href="#invokeHandlerMethod" class="headerlink" title="invokeHandlerMethod"></a>invokeHandlerMethod</h5><p>接下来就是 invokeHandlerMethod 方法的调用了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">invokeHandlerMethod</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ServletWebRequest webRequest = <span class="hljs-keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line">ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.argumentResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">invocableMethod.setHandlerMethodArgumentResolvers(<span class="hljs-keyword">this</span>.argumentResolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returnValueHandlers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(<span class="hljs-keyword">this</span>.returnValueHandlers);</span><br><span class="line">&#125;</span><br><span class="line">invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">invocableMethod.setParameterNameDiscoverer(<span class="hljs-keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">ModelAndViewContainer mavContainer = <span class="hljs-keyword">new</span> ModelAndViewContainer();</span><br><span class="line">mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">mavContainer.setIgnoreDefaultModelOnRedirect(<span class="hljs-keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line">AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">asyncWebRequest.setTimeout(<span class="hljs-keyword">this</span>.asyncRequestTimeout);</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.setTaskExecutor(<span class="hljs-keyword">this</span>.taskExecutor);</span><br><span class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">asyncManager.registerCallableInterceptors(<span class="hljs-keyword">this</span>.callableInterceptors);</span><br><span class="line">asyncManager.registerDeferredResultInterceptors(<span class="hljs-keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"><span class="hljs-keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">Object result = asyncManager.getConcurrentResult();</span><br><span class="line">mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="hljs-number">0</span>];</span><br><span class="line">asyncManager.clearConcurrentResult();</span><br><span class="line">LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"Resume with async result ["</span> + formatted + <span class="hljs-string">"]"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">&#125;</span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"><span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">webRequest.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里涉及到的组件比较多，不过大部分组件在前面的文章中松哥都已经和大家介绍过了，因此这里理解起来应该并不难。</p><ol><li>首先获取一个 WebDataBinderFactory 对象，该对象将用来构建 WebDataBinder。</li><li>接下来获取一个 ModelFactory 对象，该对象用来初始化/更新 Model 对象（见：<a href="https://mp.weixin.qq.com/s/RxUlxxSavK9uoM9qfHwv9w" target="_blank" rel="noopener">猜一猜，Model 中的数据放在 session 中还是 request 中？</a>）。</li><li>接下来创建 ServletInvocableHandlerMethod 对象，一会方法的调用，将由它完成（见：<a href="https://mp.weixin.qq.com/s/559UL_bcEKo9jNq85qmVMg" target="_blank" rel="noopener">Spring Boot 定义接口的方法是否可以声明为 private？</a>）。</li><li>接下来给 invocableMethod 把需要的参数都安排上。</li><li>构造一个 ModelAndViewContainer 对象，将来用来存储 Model 和 View。</li><li>把 FlashMap 中的数据先添加进 ModelAndViewContainer 容器中（关于 FlashMap，参见：<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>）。</li><li>接下来初始化 Model，处理 <code>@SessionAttributes</code> 注解和 WebDataBinder 定义的全局数据，同时配置是否在重定向时忽略 defaultModel（具体初始化过程见：<a href="https://mp.weixin.qq.com/s/RxUlxxSavK9uoM9qfHwv9w" target="_blank" rel="noopener">猜一猜，Model 中的数据放在 session 中还是 request 中？</a>）。</li><li>接下来处理异步请求情况，判断是否有异步请求结果。</li><li>调用 invokeAndHandle 方法去真正执行接口方法，具体过程参见<a href="https://mp.weixin.qq.com/s/559UL_bcEKo9jNq85qmVMg" target="_blank" rel="noopener">Spring Boot 定义接口的方法是否可以声明为 private？</a>一文。</li><li>如果是异步请求，则直接返回即可。</li><li>接下来调用 getModelAndView 方法去构造 ModelAndView 并返回，在该方法中，首先会去更新 Model，更新的时候会去处理 <code>SessionAttribute</code> 同时配置 BindingResult；然后会根据 ModelAndViewContainer 去创建一个 ModelAndView 对象；最后，如果 ModelAndViewContainer 中的 Model 是 RedirectAttributes 类型，则将其设置到 FlashMap 中。</li><li>最后设置请求完成。</li></ol><h5 id="处理缓存"><a href="#处理缓存" class="headerlink" title="处理缓存"></a>处理缓存</h5><p>缓存的处理主要是针对响应头的 <code>Cache-Control</code> 字段。</p><p>这块比较简单，松哥就不废话了。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>今天这篇文章主要和小伙伴们聊了 SpringMVC 中的 HandlerAdapter，HandlerAdapter 中涉及到了很多其他的组件，这些组件松哥在之前的文章中已经向大家介绍过了，因此本文其实也可以看成是对前面文章所学习组件的一个梳理。当然这里涉及到的技术细节还是非常多，松哥以后抽空录视频和大家细聊。</p><p>好啦，本文我们就先说这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;SpringMVC 九大组件，前面和大家分析了 HandlerMapping，今天我们来看 HandlerAdapter。因为前面已经做了很多铺垫了，所以今天的内容不会太难。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 定义接口的方法是否可以声明为 private？</title>
    <link href="http://www.javaboy.org/2021/0331/springmvc-handlermethod.html"/>
    <id>http://www.javaboy.org/2021/0331/springmvc-handlermethod.html</id>
    <published>2021-03-31T06:58:00.000Z</published>
    <updated>2021-03-31T07:00:53.760Z</updated>
    
    <content type="html"><![CDATA[<p>我们在 Controller 中定义接口的时候，一般都是像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">    map.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>估计很少有人会把接口方法定义成 private 的吧？那我们不禁要问，如果非要定义成 private 的方法，那能运行起来吗？</p><p>带着这个疑问，我们开始今天的源码解读～</p><p>在我们使用 Spring Boot 的时候，经常会看到 HandlerMethod 这个类型，例如我们在定义拦截器的时候，如果拦截目标是一个方法，则 preHandle 的第三个参数就是 HandlerMethod（以下案例选自松哥之前的视频：<a href="https://mp.weixin.qq.com/s/3gu8tuJduFp--AyDsnH0yg" target="_blank" rel="noopener">手把手教你 Spring Boot 自定义注解</a>）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdempotentInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenService tokenService;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!(handler <span class="hljs-keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//省略...</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在阅读 SpringMVC 源码的时候，也会反复看到这个 HandlerMethod，那么它到底是什么意思？今天我想和小伙伴们捋一捋这个问题，把这个问题搞清楚了，前面的问题大家也就懂了。</p><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p><img src="http://img.itboyhub.com/2021/02/20210319220725.png" alt></p><p>可以看到，HandlerMethod 体系下的类并不多：</p><p><strong>HandlerMethod</strong></p><p>封装 Handler 和具体处理请求的 Method。</p><p><strong>InvocableHandlerMethod</strong></p><p>在 HandlerMethod 的基础上增加了调用的功能。</p><p><strong>ServletInvocableHandlerMethod</strong></p><p>在 InvocableHandlerMethod 的基础上增了对 <code>@ResponseStatus</code> 注解的支持、增加了对返回值的处理。</p><p><strong>ConcurrentResultHandlerMethod</strong></p><p>在 ServletInvocableHandlerMethod 的基础上，增加了对异步结果的处理。</p><p>基本上就是这四个，接下来松哥就来详细说一说这四个组件。</p><h2 id="2-HandlerMethod"><a href="#2-HandlerMethod" class="headerlink" title="2.HandlerMethod"></a>2.HandlerMethod</h2><h3 id="2-1-bridgedMethod"><a href="#2-1-bridgedMethod" class="headerlink" title="2.1 bridgedMethod"></a>2.1 bridgedMethod</h3><p>在正式开始介绍 HandlerMethod 之前，想先和大家聊聊 bridgedMethod，因为在 HandlerMethod 中将会涉及到这个东西，而有的小伙伴可能还没听说过 bridgedMethod，因此松哥在这里做一个简单介绍。</p><p>首先考考大家，下面这段代码编译会报错吗？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Animal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"cat eat "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal = <span class="hljs-keyword">new</span> Cat();</span><br><span class="line">        animal.eat(<span class="hljs-keyword">new</span> Object());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们定义了一个 Animal 接口，里边定义了一个 eat 方法，同时声明了一个泛型。Cat 实现了 Animal 接口，将泛型也定义为了 String。当我调用的时候，声明类型是 Animal，实际类型是 Cat，这个时候调 eat 方法传入了 Object 对象大家猜猜会怎么样？如果调用 eat 方法时传入的是 String 类型那就肯定没问题，但如果不是 String 呢？</p><p>松哥先说结论：编译没问题，运行报错。</p><p>如果小伙伴们在自己电脑上写出上面这段代码，你会发现这样一个问题，开发工具中提示的参数类型竟然是 Object，以松哥的 IDEA 为例，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210320213610.png" alt></p><p>大家看到，在我写代码的时候，开发工具会给我提示，这个参数类型是 Object，有的小伙伴会觉得奇怪，明明是泛型，怎么变成 Object 了？</p><p>我们可以通过反射查看 Cat 类中到底有哪些方法，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method[] methods = Cat.class.getMethods();</span><br><span class="line">        <span class="hljs-keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            String name = method.getName();</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            System.out.println(name+<span class="hljs-string">"("</span>+ Arrays.toString(parameterTypes) +<span class="hljs-string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210320214359.png" alt></p><p>可以看到，在实际运行过程中，竟然有两个 eat 方法，一个的参数为 String 类型，另一个参数为 Object 类型，这是怎么回事呢？</p><p>这个参数类型为 Object 的方法其实是 Java 虚拟机在运行时创建出来的，这个方法就是我们所说的 bridge method。本节的小标题叫做 <code>bridgedMethod</code>，这是 HandlerMethod 源码中的变量名，bridge 结尾多了一个 d，含义变成了被 bridge 的方法，也就是参数为 String 的原方法，大家在接下来的源码中看到了 bridgedMethod 就知道这表示参数类型不变的原方法。</p><h3 id="2-2-HandlerMethod-介绍"><a href="#2-2-HandlerMethod-介绍" class="headerlink" title="2.2 HandlerMethod 介绍"></a>2.2 HandlerMethod 介绍</h3><p>接下来我们来简单看下 HandlerMethod。</p><p>在我们前面分析 HandlerMapping 的时候（参见：<a href></a>），里边有涉及到 HandlerMethod，创建 HandlerMethod 的入口方法是 createWithResolvedBean，因此这里我们就从该方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> HandlerMethod <span class="hljs-title">createWithResolvedBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Object handler = <span class="hljs-keyword">this</span>.bean;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.bean <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String beanName = (String) <span class="hljs-keyword">this</span>.bean;</span><br><span class="line">handler = <span class="hljs-keyword">this</span>.beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HandlerMethod(<span class="hljs-keyword">this</span>, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是确认了一下 handler 的类型，如果 handler 是 String 类型，则根据 beanName 从 Spring 容器中重新查找到 handler 对象，然后构建 HandlerMethod：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HandlerMethod</span><span class="hljs-params">(HandlerMethod handlerMethod, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.bean = handler;</span><br><span class="line"><span class="hljs-keyword">this</span>.beanFactory = handlerMethod.beanFactory;</span><br><span class="line"><span class="hljs-keyword">this</span>.beanType = handlerMethod.beanType;</span><br><span class="line"><span class="hljs-keyword">this</span>.method = handlerMethod.method;</span><br><span class="line"><span class="hljs-keyword">this</span>.bridgedMethod = handlerMethod.bridgedMethod;</span><br><span class="line"><span class="hljs-keyword">this</span>.parameters = handlerMethod.parameters;</span><br><span class="line"><span class="hljs-keyword">this</span>.responseStatus = handlerMethod.responseStatus;</span><br><span class="line"><span class="hljs-keyword">this</span>.responseStatusReason = handlerMethod.responseStatusReason;</span><br><span class="line"><span class="hljs-keyword">this</span>.resolvedFromHandlerMethod = handlerMethod;</span><br><span class="line"><span class="hljs-keyword">this</span>.description = handlerMethod.description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的参数都比较简单，没啥好说的，唯一值得介绍的地方有两个：parameters 和 responseStatus。</p><p><strong>parameters</strong></p><p>parameters 实际上就是方法参数，对应的类型是 MethodParameter，这个类的源码我这里就不贴出来了，主要和大家说一下封装的内容包括：参数的序号（parameterIndex），参数嵌套级别（nestingLevel），参数类型（parameterType），参数的注解（parameterAnnotations），参数名称查找器（parameterNameDiscoverer），参数名称（parameterName）等。</p><p>HandlerMethod 中还提供了两个内部类来封装 MethodParameter，分别是：</p><ul><li>HandlerMethodParameter：这个封装方法调用的参数。</li><li>ReturnValueMethodParameter：这个继承自 HandlerMethodParameter，它封装了方法的返回值，返回值里边的 parameterIndex 是 -1。</li></ul><p>注意，这两者中的 method 都是 bridgedMethod。</p><p><strong>responseStatus</strong></p><p>这个主要是处理方法的 <code>@ResponseStatus</code> 注解，这个注解用来描述方法的响应状态码，使用方式像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/04"</span>)</span><br><span class="line"><span class="hljs-meta">@ResponseBody</span></span><br><span class="line"><span class="hljs-meta">@ResponseStatus</span>(code = HttpStatus.OK)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello4</span><span class="hljs-params">(@SessionAttribute(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中大家可以看到，其实 <code>@ResponseStatus</code> 注解灵活性很差，不实用，当我们定义一个接口的时候，很难预知到该接口的响应状态码是 200。</p><p>在 handlerMethod 中，在调用其构造方法的时候，都会调用 evaluateResponseStatus 方法处理 <code>@ResponseStatus</code> 注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">evaluateResponseStatus</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">ResponseStatus annotation = getMethodAnnotation(ResponseStatus.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (annotation == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">annotation = AnnotatedElementUtils.findMergedAnnotation(getBeanType(), ResponseStatus.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (annotation != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.responseStatus = annotation.code();</span><br><span class="line"><span class="hljs-keyword">this</span>.responseStatusReason = annotation.reason();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这段代码也比较简单，找到注解，把里边的值解析出来，赋值给相应的变量。</p><p>这下小伙伴们应该明白了 HandlerMethod 大概是个怎么回事。</p><h2 id="3-InvocableHandlerMethod"><a href="#3-InvocableHandlerMethod" class="headerlink" title="3.InvocableHandlerMethod"></a>3.InvocableHandlerMethod</h2><p>看名字就知道，InvocableHandlerMethod 可以调用 HandlerMethod 中的具体方法，也就是 bridgedMethod。我们先来看下 InvocableHandlerMethod 中声明的属性：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> HandlerMethodArgumentResolverComposite resolvers = <span class="hljs-keyword">new</span> HandlerMethodArgumentResolverComposite();</span><br><span class="line"><span class="hljs-keyword">private</span> ParameterNameDiscoverer parameterNameDiscoverer = <span class="hljs-keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> WebDataBinderFactory dataBinderFactory;</span><br></pre></td></tr></table></figure><p>主要就是这三个属性：</p><ul><li>resolvers：这个不用说，参数解析器，前面的文章中松哥已经和大家聊过这个问题了。</li><li>parameterNameDiscoverer：这个用来获取参数名称，在 MethodParameter 中会用到。</li><li>dataBinderFactory：这个用来创建 WebDataBinder，在参数解析器中会用到。</li></ul><p>具体的请求调用方法是 invokeForRequest，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invokeForRequest</span><span class="hljs-params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"><span class="hljs-keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Method method = getBridgedMethod();</span><br><span class="line">ReflectionUtils.makeAccessible(method);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (KotlinDetector.isSuspendingFunction(method)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> CoroutinesUtils.invokeSuspendingFunction(method, getBean(), args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> method.invoke(getBean(), args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// 省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 getMethodArgumentValues 方法按顺序获取到所有参数的值，这些参数值组成一个数组，然后调用 doInvoke 方法执行，在 doInvoke 方法中，首先获取到 bridgedMethod，并设置其可见（<strong>意味着我们在 Controller 中定义的接口方法也可以是 private 的</strong>），然后直接通过反射调用即可。当我们没看 SpringMVC 源码的时候，我们就知道接口方法最终肯定是通过反射调用的，现在，经过层层分析之后，终于在这里找到了反射调用代码。</p><p>最后松哥再来说一下负责参数解析的 getMethodArgumentValues 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> Object[] getMethodArgumentValues(NativeWebRequest request, <span class="hljs-meta">@Nullable</span> ModelAndViewContainer mavContainer,</span><br><span class="line">Object... providedArgs) <span class="hljs-keyword">throws</span> Exception &#123;</span><br><span class="line">MethodParameter[] parameters = getMethodParameters();</span><br><span class="line"><span class="hljs-keyword">if</span> (ObjectUtils.isEmpty(parameters)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> EMPTY_ARGS;</span><br><span class="line">&#125;</span><br><span class="line">Object[] args = <span class="hljs-keyword">new</span> Object[parameters.length];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">MethodParameter parameter = parameters[i];</span><br><span class="line">parameter.initParameterNameDiscovery(<span class="hljs-keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line">args[i] = findProvidedArgument(parameter, providedArgs);</span><br><span class="line"><span class="hljs-keyword">if</span> (args[i] != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resolvers.supportsParameter(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(formatArgumentError(parameter, <span class="hljs-string">"No suitable resolver"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">args[i] = <span class="hljs-keyword">this</span>.resolvers.resolveArgument(parameter, mavContainer, request, <span class="hljs-keyword">this</span>.dataBinderFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="hljs-comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 getMethodParameters 方法获取到方法的所有参数。</li><li>创建 args 数组用来保存参数的值。</li><li>接下来一堆初始化配置。</li><li>如果 providedArgs 中提供了参数值，则直接赋值。</li><li>查看是否有参数解析器支持当前参数类型，如果没有，直接抛出异常。</li><li>调用参数解析器对参数进行解析，解析完成后，赋值。</li></ol><p>是不是，很 easy！</p><h2 id="4-ServletInvocableHandlerMethod"><a href="#4-ServletInvocableHandlerMethod" class="headerlink" title="4.ServletInvocableHandlerMethod"></a>4.ServletInvocableHandlerMethod</h2><p>ServletInvocableHandlerMethod 则是在 InvocableHandlerMethod 的基础上，又增加了两个功能：</p><ul><li>对 <code>@ResponseStatus</code> 注解的处理</li><li>对返回值的处理</li></ul><p>Servlet 容器下 Controller 在查找适配器时发起调用的最终就是 ServletInvocableHandlerMethod。</p><p>这里的处理核心方法是 invokeAndHandle，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAndHandle</span><span class="hljs-params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">setResponseStatus(webRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (returnValue == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="hljs-keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">disableContentCachingIfNecessary(webRequest);</span><br><span class="line">mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">mavContainer.setRequestHandled(<span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用父类的 invokeForRequest 方法对请求进行执行，拿到请求结果。</li><li>调用 setResponseStatus 方法处理 <code>@ResponseStatus</code> 注解，具体的处理逻辑是这样：如果没有添加 <code>@ResponseStatus</code> 注解，则什么都不做；如果添加了该注解，并且 reason 属性不为空，则直接输出错误，否则设置响应状态码。这里需要注意一点，如果响应状态码是 200，就不要设置 reason，否则会按照 error 处理。</li><li>接下来就是对返回值的处理了，returnValueHandlers#handleReturnValue 方法松哥在之前的文章中和大家专门介绍过，这里就不再赘述，传送门：<a href="https://mp.weixin.qq.com/s/8aMz07rOF5LuclnBaI_p5g" target="_blank" rel="noopener">Spring Boot 中如何统一 API 接口响应格式？</a>。</li></ol><p>事实上，ServletInvocableHandlerMethod 还有一个子类 ConcurrentResultHandlerMethod，这个支持异步调用结果处理，因为使用场景较少，这里就不做介绍啦。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>现在大家可以回答文章标题提出的问题了吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在 Controller 中定义接口的时候，一般都是像下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@GetMapping&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/01&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Map&amp;lt;String,Object&amp;gt; map)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map.put(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;javaboy&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;forward:/index&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>接口参数 Model 中的数据放在 session 中还是 request 中？</title>
    <link href="http://www.javaboy.org/2021/0330/sessionattribute.html"/>
    <id>http://www.javaboy.org/2021/0330/sessionattribute.html</id>
    <published>2021-03-30T06:58:11.000Z</published>
    <updated>2021-03-31T07:01:29.104Z</updated>
    
    <content type="html"><![CDATA[<p>在 SpringMVC 中，大家都知道有一个特殊的参数 Model，它的使用方式像下面这样：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"01"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个看起来人畜无害的普通参数，里边也会包含你的知识盲区吗？说不定真的包含了，不信你就往下看。</p><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h2><p>仅仅从使用上来说，Model 有两方面的功能：</p><ol><li>携带参数</li><li>返回参数</li></ol><p>先说携带参数：当我们在一个接口中放上 Model 这个参数之后，这个 Model 不一定是空白的，它里边可能已经有了携带的参数，携带的参数可能来自上一次 <code>@SessionAttributes</code> 注解标记过的参数，也可能来自 <code>@ModelAttribute</code> 注解标记过的全局参数。</p><p>在来说返回参数，Model 中的属性，你最终都可以在前端视图中获取到，这个没啥好说的。</p><p>前面提到了 <code>@ModelAttribute</code> 注解，这个如果有小伙伴不清楚，可以看看松哥之前的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/Qd0BAUdUtBuBUBmy1G0Z4w" target="_blank" rel="noopener">@ControllerAdvice 的三种使用场景</a></li></ul><p>或者在公众号后台回复 666 有文字教程，回复 ssm 有视频教程，都有关于 <code>@ModelAttribute</code> 的讲解。</p><p>至于 <code>@SessionAttributes</code>，松哥现在和大家分享一下，毕竟只有先懂怎么用，后面才会懂源码。</p><h2 id="2-SessionAttributes"><a href="#2-SessionAttributes" class="headerlink" title="2.@SessionAttributes"></a>2.<code>@SessionAttributes</code></h2><p><code>@SessionAttributes</code> 作用于处理器类上，这个注解可以把参数存储到 session 中，进而可以实现在多个请求之间传递参数。</p><p><code>@SessionAttributes</code> 的作用类似于 Session 的 Attribute 属性，但不完全一样，一般来说 <code>@SessionAttributes</code> 设置的参数只用于临时的参数传递，而不是长期的保存，参数用完之后可以通过 SessionStatus 将之清除。</p><p>通过 <code>@SessionAttributes</code> 注解设置的参数我们可以在三个地方获取：</p><ol><li>在当前的视图中直接通过 <code>request.getAttribute</code> 或 <code>session.getAttribute</code> 获取。</li></ol><p>例如如下接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"01"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name 属性会被临时保存在 session 中，在前端页面中，我们既可以从 request 域中获取也可以从 session 域中获取，以 Thymeleaf 页面模版为例：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;#request.getAttribute('name')&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;#session.getAttribute('name')&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果没有使用 <code>@SessionAttributes</code> 注解，那就只能从 request 域中获取，而不能从 session 域中获取。</p><ol start="2"><li>在后面的请求中，也可以通过 <code>session.getAttribute</code> 获取。</li></ol><p>参数既然存在 session 中，那就有一个好处，就是无论是服务器端跳转还是客户端跳转，参数都不会丢失。例如如下接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/02"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"01"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论开发者访问 <code>http://localhost:8080/01</code> 还是 <code>http://localhost:8080/02</code>，都能看到页面，并且 name 属性的值也能在页面上渲染出来。</p><p>不知道小伙伴们有没有想起来什么？对了，重定向的参数传递问题，之前松哥和大家分享了 FlashMap（<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>），现在你看到了，这也是一种方案。</p><ol start="3"><li>在后续的请求中，也可以直接从 Model 中获取。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/03"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello3</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        Object name = model.getAttribute(<span class="hljs-string">"name"</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问完 <code>/01</code> 接口之后，再去访问 <code>/03</code> 接口，也可以拿到 Model 中的数据。</p><p>第三种方式还有一个变体，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/04"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello4</span><span class="hljs-params">(@SessionAttribute(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是参数中不使用 Model，而是使用 <code>@SessionAttribute</code> 注解，直接将 session 中的属性绑定到参数上。</p><p>使用了 <code>@SessionAttributes</code> 注解之后，可以调用 <code>SessionStatus.setComplete</code> 方法来清除数据，注意这个方法只是清除 <code>SessionAttribute</code> 里的参数，而不会清除正常 Session 中的参数。</p><p>例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"name"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"name"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/04"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello4</span><span class="hljs-params">(@SessionAttribute(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/05"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello5</span><span class="hljs-params">(SessionStatus sessionStatus)</span> </span>&#123;</span><br><span class="line">        sessionStatus.setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先访问 <code>/01</code> 接口，访问完了就有数据了，这个时候访问 <code>/04</code> 接口，就会打印出数据，继续访问 <code>/05</code> 接口，访问完成后，再去访问 <code>/04</code> 接口，此时就会发现数据没了，因为被清除了。</p><p>现在，大家对 <code>@SessionAttributes</code> 注解的用法应该有了一定的认知了吧。</p><h2 id="3-ModelFactory"><a href="#3-ModelFactory" class="headerlink" title="3.ModelFactory"></a>3.ModelFactory</h2><p>接下来我们就来研究一下 ModelFactory，ModelFactory 是用来维护 Model 的，上面这一切，我们可以从 ModelFactory 中找到端倪。</p><p>整体上来说，ModelFactory 包含两方面的功能：1.初始化 Model；2.将 Model 中相应的参数更新到 SessionAtrributes 中。两方面的功能我们分别来看，先来看初始化问题。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initModel</span><span class="hljs-params">(NativeWebRequest request, ModelAndViewContainer container, HandlerMethod handlerMethod)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Map&lt;String, ?&gt; sessionAttributes = <span class="hljs-keyword">this</span>.sessionAttributesHandler.retrieveAttributes(request);</span><br><span class="line">container.mergeAttributes(sessionAttributes);</span><br><span class="line">invokeModelAttributeMethods(request, container);</span><br><span class="line"><span class="hljs-keyword">for</span> (String name : findSessionAttributeArguments(handlerMethod)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!container.containsAttribute(name)) &#123;</span><br><span class="line">Object value = <span class="hljs-keyword">this</span>.sessionAttributesHandler.retrieveAttribute(request, name);</span><br><span class="line"><span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HttpSessionRequiredException(<span class="hljs-string">"Expected session attribute '"</span> + name + <span class="hljs-string">"'"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">container.addAttribute(name, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 initModel 方法比较逻辑比较简单：</p><ol><li>首先它会从 <code>@SessionAttributes</code> 中取出参数，然后合并进 ModelAndViewContainer 容器中（不懂 ModelAndViewContainer 容器的话，可以参考松哥前面的文章：<a href="https://mp.weixin.qq.com/s/8aMz07rOF5LuclnBaI_p5g" target="_blank" rel="noopener">Spring Boot 中如何统一 API 接口响应格式？</a>）。</li><li>接下来调用含有 <code>@ModelAttribute</code> 注解的方法，并将结果合并进 ModelAndViewContainer 容器中。</li><li>寻找那些既有 <code>@ModelAttribute</code> 注解又有 <code>@SessionAttributes</code> 注解的属性，找到后，如果这些属性不存在于 ModelAndViewContainer 容器中，就从 SessionAttributes 中获取并设置到 ModelAndViewContainer 容器中。</li></ol><p>我们先来看看第一个 retrieveAttributes 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">retrieveAttributes</span><span class="hljs-params">(WebRequest request)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; attributes = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String name : <span class="hljs-keyword">this</span>.knownAttributeNames) &#123;</span><br><span class="line">Object value = <span class="hljs-keyword">this</span>.sessionAttributeStore.retrieveAttribute(request, name);</span><br><span class="line"><span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">attributes.put(name, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个其实没啥好说的，因为逻辑很清晰，knownAttributeNames 就是我们在使用 <code>@SessionAttributes</code> 注解时配置的属性名字，属性名字可以是一个数组。遍历 knownAttributeNames 属性，从 session 中获取相关数据存入 Map 集合中。</p><p>再来看第二个 invokeModelAttributeMethods 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeModelAttributeMethods</span><span class="hljs-params">(NativeWebRequest request, ModelAndViewContainer container)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.modelMethods.isEmpty()) &#123;</span><br><span class="line">InvocableHandlerMethod modelMethod = getNextModelMethod(container).getHandlerMethod();</span><br><span class="line">ModelAttribute ann = modelMethod.getMethodAnnotation(ModelAttribute.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (container.containsAttribute(ann.name())) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!ann.binding()) &#123;</span><br><span class="line">container.setBindingDisabled(ann.name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object returnValue = modelMethod.invokeForRequest(request, container);</span><br><span class="line"><span class="hljs-keyword">if</span> (modelMethod.isVoid()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(ann.value())) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">String returnValueName = getNameForReturnValue(returnValue, modelMethod.getReturnType());</span><br><span class="line"><span class="hljs-keyword">if</span> (!ann.binding()) &#123;</span><br><span class="line">container.setBindingDisabled(returnValueName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!container.containsAttribute(returnValueName)) &#123;</span><br><span class="line">container.addAttribute(returnValueName, returnValue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取含有 <code>@ModelAttribute</code> 注解的方法，然后获取到该注解。</li><li>获取 <code>@ModelAttribute</code> 注解，并提取出它的 name 属性值，然后查看 ModelAndViewContainer 容器中是否已经包含了该属性，如果已经包含了，并且在 <code>@ModelAttribute</code> 注解中设置了不绑定，则将该属性添加到 ModelAndViewContainer 容器中的禁止绑定上面去。</li><li>接下来通过 <code>invokeForRequest</code> 方法去调用含有 <code>@ModelAttribute</code> 注解的方法，并获取返回值。</li><li>如果含有 <code>@ModelAttribute</code> 注解的方法返回值为 void，则该方法到此为止。</li><li>接下来解析出返回值的参数名，有的小伙伴们说，参数名不就是 <code>@ModelAttribute</code> 注解中配置的 name 属性吗？这当然没错！但是有时候用户没有配置 name 属性，那么这个时候就会对应一套默认的 name 生成方案。默认的名字生成方案是这样的：<ul><li>如果返回对象前两个字母都是大写，那就原封不动返回，否则首字母小写后返回。</li><li>如果返回类型是数组或者集合，则在真实类型后加上 List，例如 List<long> 对象 longList。</long></li></ul></li><li>有了 returnValueName 之后，再去判断是否要禁止属性绑定。最后如果 ModelAndViewContainer 容器中不包含该属性，则添加进来。</li></ol><p>这就是 Model 初始化的过程，可以看到，数据最终都被保存进 ModelAndViewContainer 容器中了，至于在该容器中数据被保存到哪个属性，则要看实际情况，可能是 defaultModel 也可能是 redirectModel，具体参见<a href="https://mp.weixin.qq.com/s/8aMz07rOF5LuclnBaI_p5g" target="_blank" rel="noopener">Spring Boot 中如何统一 API 接口响应格式？</a>）。</p><p>最后我们再来看看 ModelFactory 中修改 Model 的过程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateModel</span><span class="hljs-params">(NativeWebRequest request, ModelAndViewContainer container)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ModelMap defaultModel = container.getDefaultModel();</span><br><span class="line"><span class="hljs-keyword">if</span> (container.getSessionStatus().isComplete())&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.sessionAttributesHandler.cleanupAttributes(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.sessionAttributesHandler.storeAttributes(request, defaultModel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!container.isRequestHandled() &amp;&amp; container.getModel() == defaultModel) &#123;</span><br><span class="line">updateBindingResult(request, defaultModel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改的时候会首先判断一下是否已经调用了 <code>sessionStatus.setComplete();</code> 方法，如果调用过了，就执行清除操作，否则就进行正常的更新操作即可，更新的数据就是 ModelAndViewContainer 中的 defaultModel。最后判断是否需要进行页面渲染，如果需要，再给参数分别设置 BindingResult 以备视图使用。</p><p>现在，大家应该已经清楚了 ModelFactory 的功能了。</p><p>一句话，ModelFactory 在初始化的时候，就直接从 SessionAttributes 以及 ModelAttribute 处加载到数据，放到 ModelAndViewContainer 中，更新的时候，则有可能清除 SessionAttributes 中的数据。<strong>这里大家需要把握一点，就是数据最终被存入 ModelAndViewContainer 中了。</strong></p><h2 id="3-相关的参数解析器"><a href="#3-相关的参数解析器" class="headerlink" title="3.相关的参数解析器"></a>3.相关的参数解析器</h2><p>这是 Model 初始化的过程，初始化完成后，参数最终会在参数解析器中被解析，关于参数解析器，大家可以参考如下两篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/4c-uV8f6x5UPvxec6Em79A" target="_blank" rel="noopener">SpringBoot 中如何自定义参数解析器？</a></li><li><a href="https://mp.weixin.qq.com/s/qsS6Dwr6eXx07i5dhn8FEA" target="_blank" rel="noopener">深入分析 SpringMVC 参数解析器</a></li></ul><p>这里涉及到的参数解析器就是 ModelMethodProcessor，我们来看下它里边两个关键的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Model.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mavContainer.getModel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，支持的参数类型就是 Model，参数的值则是直接返回 ModelAndViewContainer 中的 model 对象。</p><p>这里还有一个类似的参数处理器 MapMethodProcessor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp;</span><br><span class="line">parameter.getParameterAnnotations().length == <span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mavContainer.getModel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是处理 Map 类型的参数，最终返回的也是 ModelAndViewContainer 中的 model，你是否发现什么了？对了，在本文第二小节的案例中，你把 Model 参数换成 Map 或者 ModelMap（ModelMap 本质上也是 Map，使用的参数解析器也是 MapMethodProcessor），最终效果是一样的！</p><p>前面我们还使用了 <code>@SessionAttribute</code> 注解，这个注解的 name 属性就绑定了 SessionAttributes 中对应的属性并赋值给变量，它使用的参数解析器是 SessionAttributeMethodArgumentResolver，我们来看下它里边的核心方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionAttributeMethodArgumentResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractNamedValueMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> parameter.hasParameterAnnotation(SessionAttribute.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveName</span><span class="hljs-params">(String name, MethodParameter parameter, NativeWebRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getAttribute(name, RequestAttributes.SCOPE_SESSION);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个参数最终对应的值就是从 session 中取出对应的 name 属性值。</p><p>最后，我们再来梳理一下整个过程：当请求到达后，首先要初始化 Model，初始化 Model 的时候，会根据 <code>@SessionAttributes</code> 注解从 session 中读取相关数据放入 ModelAndViewContainer 中，同时也会加载 <code>@ModelAttribute</code> 注解配置的全局数据到 ModelAndViewContainer 中。最终在参数解析器中，返回 ModelAndViewContainer 中的 model 即可。</p><hr><p>现在大家可以回答文章标题提出的问题了吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 SpringMVC 中，大家都知道有一个特殊的参数 Model，它的使用方式像下面这样：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 九大组件之 HandlerMapping 深入分析</title>
    <link href="http://www.javaboy.org/2021/0326/springmvc-handlermapping.html"/>
    <id>http://www.javaboy.org/2021/0326/springmvc-handlermapping.html</id>
    <published>2021-03-26T06:58:28.000Z</published>
    <updated>2021-03-31T07:03:03.605Z</updated>
    
    <content type="html"><![CDATA[<p>前面跟小伙伴们分享了 SpringMVC 一个大致的初始化流程以及请求的大致处理流程，在请求处理过程中，涉及到九大组件，分别是：</p><ol><li>HandlerMapping</li><li>HandlerAdapter</li><li>HandlerExceptionResolver</li><li>ViewResolver</li><li>RequestToViewNameTranslator</li><li>LocaleResolver</li><li>ThemeResolver</li><li>MultipartResolver</li><li>FlashMapManager</li></ol><a id="more"></a><p>这些组件相信小伙伴们在日常开发中多多少少都有涉及到，如果你对这些组件感到陌生，可以在公众号后台回复 <strong>ssm</strong>，免费获取松哥的入门视频教程。</p><p>那么接下来的几篇文章，松哥想和大家深入分析这九大组件，从用法到源码，挨个分析，今天我们就先来看看这九大组件中的第一个 HandlerMapping。</p><h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a>1.概览</h2><p>HandlerMapping 叫做处理器映射器，它的作用就是根据当前 request 找到对应的 Handler 和 Interceptor，然后封装成一个 HandlerExecutionChain 对象返回，我们来看下 HandlerMapping 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerMapping</span> </span>&#123;</span><br><span class="line">String BEST_MATCHING_HANDLER_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".bestMatchingHandler"</span>;</span><br><span class="line"><span class="hljs-meta">@Deprecated</span></span><br><span class="line">String LOOKUP_PATH = HandlerMapping.class.getName() + <span class="hljs-string">".lookupPath"</span>;</span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".pathWithinHandlerMapping"</span>;</span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".bestMatchingPattern"</span>;</span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + <span class="hljs-string">".introspectTypeLevelMapping"</span>;</span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".uriTemplateVariables"</span>;</span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".matrixVariables"</span>;</span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="hljs-string">".producibleMediaTypes"</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">usesPathPatterns</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">HandlerExecutionChain <span class="hljs-title">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，除了一堆声明的常量外，其实就一个需要实现的方法 getHandler，该方法的返回值就是我们所了解到的 HandlerExecutionChain。</p><p>HandlerMapping 的继承关系如下：</p><p><img src="http://img.itboyhub.com/2021/02/HandlerMapping.png" alt></p><p>这个继承关系虽然看着有点绕，其实仔细观察就两大类：</p><ul><li>AbstractHandlerMethodMapping</li><li>AbstractUrlHandlerMapping</li></ul><p>其他的都是一些辅助接口。</p><p>AbstractHandlerMethodMapping 体系下的都是根据方法名进行匹配的，而 AbstractUrlHandlerMapping 体系下的都是根据 URL 路径进行匹配的，这两者有一个共同的父类 AbstractHandlerMapping，接下来我们就对这三个关键类进行详细分析。</p><h2 id="2-AbstractHandlerMapping"><a href="#2-AbstractHandlerMapping" class="headerlink" title="2.AbstractHandlerMapping"></a>2.AbstractHandlerMapping</h2><p>AbstractHandlerMapping 实现了 HandlerMapping 接口，无论是通过 URL 进行匹配还是通过方法名进行匹配，都是通过继承 AbstractHandlerMapping 来实现的，所以 AbstractHandlerMapping 所做的事情其实就是一些公共的事情，将以一些需要具体处理的事情则交给子类去处理，这其实就是典型的模版方法模式。</p><p>AbstractHandlerMapping 间接继承自 ApplicationObjectSupport，并重写了 initApplicationContext 方法（其实该方法也是一个模版方法），这也是 AbstractHandlerMapping 的初始化入口方法，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">extendInterceptors(<span class="hljs-keyword">this</span>.interceptors);</span><br><span class="line">detectMappedInterceptors(<span class="hljs-keyword">this</span>.adaptedInterceptors);</span><br><span class="line">initInterceptors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个方法都和拦截器有关。</p><p><strong>extendInterceptors</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">extendInterceptors</span><span class="hljs-params">(List&lt;Object&gt; interceptors)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extendInterceptors 是一个模版方法，可以在子类中实现，子类实现了该方法之后，可以对拦截器进行添加、删除或者修改，不过在 SpringMVC 的具体实现中，其实这个方法并没有在子类中进行实现。</p><p><strong>detectMappedInterceptors</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detectMappedInterceptors</span><span class="hljs-params">(List&lt;HandlerInterceptor&gt; mappedInterceptors)</span> </span>&#123;</span><br><span class="line">mappedInterceptors.addAll(BeanFactoryUtils.beansOfTypeIncludingAncestors(</span><br><span class="line">obtainApplicationContext(), MappedInterceptor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>).values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>detectMappedInterceptors 方法会从 SpringMVC 容器以及 Spring 容器中查找所有 MappedInterceptor 类型的 Bean，查找到之后添加到 mappedInterceptors 属性中（其实就是全局的 adaptedInterceptors 属性）。一般来说，我们定义好一个拦截器之后，还要在 XML 文件中配置该拦截器，拦截器以及各种配置信息，最终就会被封装成一个 MappedInterceptor 对象。</p><p><strong>initInterceptors</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInterceptors</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.interceptors.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.interceptors.size(); i++) &#123;</span><br><span class="line">Object interceptor = <span class="hljs-keyword">this</span>.interceptors.get(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (interceptor == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Entry number "</span> + i + <span class="hljs-string">" in interceptors array is null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.adaptedInterceptors.add(adaptInterceptor(interceptor));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initInterceptors 方法主要是进行拦截器的初始化操作，具体内容是将 interceptors 集合中的拦截器添加到 adaptedInterceptors 集合中。</p><p>至此，我们看到，所有拦截器最终都会被存入 adaptedInterceptors 变量中。</p><p>AbstractHandlerMapping 的初始化其实也就是拦截器的初始化过程。</p><blockquote><p>为什么 AbstractHandlerMapping 中对拦截器如此重视呢？其实不是重视，大家想想，AbstractUrlHandlerMapping 和 AbstractHandlerMethodMapping 最大的区别在于查找处理器的区别，一旦处理器找到了，再去找拦截器，但是拦截器都是统一的，并没有什么明显区别，所以拦截器就统一在 AbstractHandlerMapping 中进行处理，而不会去 AbstractUrlHandlerMapping 或者 AbstractHandlerMethodMapping 中处理。</p></blockquote><p>接下来我们再来看看 AbstractHandlerMapping#getHandler 方法，看看处理器是如何获取到的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> HandlerExecutionChain <span class="hljs-title">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object handler = getHandlerInternal(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">handler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Ensure presence of cached lookupPath for interceptors and others</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!ServletRequestPathUtils.hasCachedPath(request)) &#123;</span><br><span class="line">initLookupPath(request);</span><br><span class="line">&#125;</span><br><span class="line">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">CorsConfiguration config = getCorsConfiguration(handler, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (getCorsConfigurationSource() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">CorsConfiguration globalConfig = getCorsConfigurationSource().getCorsConfiguration(request);</span><br><span class="line">config = (globalConfig != <span class="hljs-keyword">null</span> ? globalConfig.combine(config) : config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">config.validateAllowCredentials();</span><br><span class="line">&#125;</span><br><span class="line">executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的执行流程是这样的：</p><ol><li>首先调用 getHandlerInternal 方法去尝试获取处理器，getHandlerInternal 方法也是一个模版方法，该方法将在子类中实现。</li><li>如果没找到相应的处理器，则调用 getDefaultHandler 方法获取默认的处理器，我们在配置 HandlerMapping 的时候可以配置默认的处理器。</li><li>如果找到的处理器是一个字符串，则根据该字符串找去 SpringMVC 容器中找到对应的 Bean。</li><li>确保 lookupPath 存在，一会找对应的拦截器的时候会用到。</li><li>找到 handler 之后，接下来再调用 getHandlerExecutionChain 方法获取 HandlerExecutionChain 对象。</li><li>接下来 if 里边的是进行跨域处理的，获取到跨域的相关配置，然后进行验证&amp;配置，检查是否允许跨域。跨域这块的配置以及校验还是蛮有意思的，松哥以后专门写文章来和小伙伴们细聊。</li></ol><p>接下来我们再来看看第五步的 getHandlerExecutionChain 方法的执行逻辑，正是在这个方法里边把 handler 变成了 HandlerExecutionChain：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title">getHandlerExecutionChain</span><span class="hljs-params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">HandlerExecutionChain chain = (handler <span class="hljs-keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">(HandlerExecutionChain) handler : <span class="hljs-keyword">new</span> HandlerExecutionChain(handler));</span><br><span class="line"><span class="hljs-keyword">for</span> (HandlerInterceptor interceptor : <span class="hljs-keyword">this</span>.adaptedInterceptors) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (interceptor <span class="hljs-keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedInterceptor.matches(request)) &#123;</span><br><span class="line">chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">chain.addInterceptor(interceptor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接根据已有的 handler 创建一个新的 HandlerExecutionChain 对象，然后遍历 adaptedInterceptors 集合，该集合里存放的都是拦截器，如果拦截器的类型是 MappedInterceptor，则调用 matches 方法去匹配一下，看一下是否是拦截当前请求的拦截器，如果是，则调用 chain.addInterceptor 方法加入到 HandlerExecutionChain 对象中；如果就是一个普通拦截器，则直接加入到 HandlerExecutionChain 对象中。</p><p>这就是 AbstractHandlerMapping#getHandler 方法的大致逻辑，可以看到，这里留了一个模版方法 getHandlerInternal 在子类中实现，接下来我们就来看看它的子类。</p><h2 id="3-AbstractUrlHandlerMapping"><a href="#3-AbstractUrlHandlerMapping" class="headerlink" title="3.AbstractUrlHandlerMapping"></a>3.AbstractUrlHandlerMapping</h2><p>AbstractUrlHandlerMapping，看名字就知道，都是按照 URL 地址来进行匹配的，它的原理就是将 URL 地址与对应的 Handler 保存在同一个 Map 中，当调用 getHandlerInternal 方法时，就根据请求的 URL 去 Map 中找到对应的 Handler 返回就行了。</p><p>这里我们就先从他的 getHandlerInternal 方法开始看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getHandlerInternal</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String lookupPath = initLookupPath(request);</span><br><span class="line">Object handler;</span><br><span class="line"><span class="hljs-keyword">if</span> (usesPathPatterns()) &#123;</span><br><span class="line">RequestPath path = ServletRequestPathUtils.getParsedRequestPath(request);</span><br><span class="line">handler = lookupHandler(path, lookupPath, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">handler = lookupHandler(lookupPath, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// We need to care for the default handler directly, since we need to</span></span><br><span class="line"><span class="hljs-comment">// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span></span><br><span class="line">Object rawHandler = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.matchesCharacter(lookupPath, <span class="hljs-string">'/'</span>)) &#123;</span><br><span class="line">rawHandler = getRootHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (rawHandler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">rawHandler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (rawHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (rawHandler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) rawHandler;</span><br><span class="line">rawHandler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">validateHandler(rawHandler, request);</span><br><span class="line">handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先找到 lookupPath，就是请求的路径。这个方法本身松哥就不多说了，之前在<a href>Spring5 里边的新玩法！这种 URL 请求让我涨见识了！</a>一文中有过介绍。</li><li>接下来就是调用 lookupHandler 方法获取 Handler 对象，lookupHandler 有一个重载方法，具体用哪个，主要看所使用的 URL 匹配模式，如果使用了最新的 PathPattern（Spring5 之后的），则使用三个参数的 lookupHandler；如果还是使用之前旧的 AntPathMatcher，则这里使用两个参数的 lookupHandler。</li><li>如果前面没有获取到 handler 实例，则接下来再做各种尝试，去分别查找 RootHandler、DefaultHandler 等，如果找到的 Handler 是一个 String，则去 Spring 容器中查找该 String 对应的 Bean，再调用 validateHandler 方法来校验找到的 handler 和 request 是否匹配，不过这是一个空方法，子类也没有实现，所以可以忽略之。最后再通过 buildPathExposingHandler 方法给找到的 handler 添加一些参数。</li></ol><p>这就是整个 getHandlerInternal 方法的逻辑，实际上并不难，里边主要涉及到 lookupHandler 和 buildPathExposingHandler 两个方法，需要和大家详细介绍下，我们分别来看。</p><p><strong>lookupHandler</strong></p><p>lookupHandler 有两个，我们分别来看。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">lookupHandler</span><span class="hljs-params">(String lookupPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object handler = getDirectMatch(lookupPath, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Pattern match?</span></span><br><span class="line">List&lt;String&gt; matchingPatterns = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String registeredPattern : <span class="hljs-keyword">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (getPathMatcher().match(registeredPattern, lookupPath)) &#123;</span><br><span class="line">matchingPatterns.add(registeredPattern);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!registeredPattern.endsWith(<span class="hljs-string">"/"</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="hljs-string">"/"</span>, lookupPath)) &#123;</span><br><span class="line">matchingPatterns.add(registeredPattern + <span class="hljs-string">"/"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String bestMatch = <span class="hljs-keyword">null</span>;</span><br><span class="line">Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(lookupPath);</span><br><span class="line"><span class="hljs-keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">matchingPatterns.sort(patternComparator);</span><br><span class="line">bestMatch = matchingPatterns.get(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (bestMatch != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">handler = <span class="hljs-keyword">this</span>.handlerMap.get(bestMatch);</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (bestMatch.endsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">handler = <span class="hljs-keyword">this</span>.handlerMap.get(bestMatch.substring(<span class="hljs-number">0</span>, bestMatch.length() - <span class="hljs-number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"Could not find handler for best pattern match ["</span> + bestMatch + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">validateHandler(handler, request);</span><br><span class="line">String pathWithinMapping = getPathMatcher().extractPathWithinPattern(bestMatch, lookupPath);</span><br><span class="line"><span class="hljs-comment">// There might be multiple 'best patterns', let's make sure we have the correct URI template variables</span></span><br><span class="line"><span class="hljs-comment">// for all of them</span></span><br><span class="line">Map&lt;String, String&gt; uriTemplateVariables = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (patternComparator.compare(bestMatch, matchingPattern) == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, lookupPath);</span><br><span class="line">Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// No handler found...</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">getDirectMatch</span><span class="hljs-params">(String urlPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object handler = <span class="hljs-keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line"><span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">validateHandler(handler, request);</span><br><span class="line"><span class="hljs-keyword">return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这里首先调用 getDirectMatch 方法直接去 handlerMap 中找对应的处理器，handlerMap 中就保存了请求 URL 和处理器的映射关系，具体的查找过程就是先去 handlerMap 中找，找到了，如果是 String，则去 Spring 容器中找对应的 Bean，然后调用 validateHandler 方法去验证（实际上没有验证，前面已经说了），最后调用 buildPathExposingHandler 方法添加拦截器。</li><li>如果 getDirectMatch 方法返回值不为 null，则直接将查找到的 handler 返回，方法到此为止。那么什么情况下 getDirectMatch 方法的返回值不为 null 呢？简单来收就是没有使用通配符的情况下，请求地址中没有通配符，一个请求地址对应一个处理器，只有这种情况，getDirectMatch 方法返回值才不为 null，因为 handlerMap 中保存的是代码的定义，比如我们定义代码的时候，某个处理器的访问路径可能带有通配符，但是当我们真正发起请求的时候，请求路径里是没有通配符的，这个时候再去 handlerMap 中就找不对对应的处理器了。如果用到了定义接口时用到了通配符，则需要在下面的代码中继续处理。</li><li>接下来处理通配符的情况。首先定义 matchingPatterns 集合，将当前请求路径和 handlerMap 集合中保存的请求路径规则进行对比，凡是能匹配上的规则都直接存入 matchingPatterns 集合中。具体处理中，还有一个 useTrailingSlashMatch 的可能，有的小伙伴 SpringMVC 用的不熟练，看到这里可能就懵了，这里是这样的，SpringMVC 中，默认是可以匹配结尾 <code>/</code> 的，举个简单例子，如果你定义的接口是 <code>/user</code>，那么请求路径可以是 <code>/user</code> 也可以 <code>/user/</code>，这两种默认都是支持的，所以这里的 useTrailingSlashMatch 分支主要是处理后面这种情况，处理方式很简单，就在 registeredPattern 后面加上 <code>/</code> 然后继续和请求路径进行匹配。</li><li>由于一个请求 URL 可能会和定义的多个接口匹配上，所以 matchingPatterns 变量是一个数组，接下来就要对 matchingPatterns 进行排序，排序完成后，选择排序后的第一项作为最佳选项赋值给 bestMatch 变量。默认的排序规则是 AntPatternComparator，当然开发者也可以自定义。AntPatternComparator 中定义的优先级如下：</li></ol><table><thead><tr><th style="text-align:left">路由配置</th><th style="text-align:left">优先级</th></tr></thead><tbody><tr><td style="text-align:left">不含任何特殊符号的路径，如：配置路由<code>/a/b/c</code></td><td style="text-align:left">第一优先级</td></tr><tr><td style="text-align:left">带有<code>{}</code>的路径，如：<code>/a/{b}/c</code></td><td style="text-align:left">第二优先级</td></tr><tr><td style="text-align:left">带有正则的路径，如：<code>/a/{regex:\d{3}}/c</code></td><td style="text-align:left">第三优先级</td></tr><tr><td style="text-align:left">带有<code>*</code>的路径，如：<code>/a/b/*</code></td><td style="text-align:left">第四优先级</td></tr><tr><td style="text-align:left">带有<code>**</code>的路径，如：<code>/a/b/**</code></td><td style="text-align:left">第五优先级</td></tr><tr><td style="text-align:left">最模糊的匹配：<code>/**</code></td><td style="text-align:left">最低优先级</td></tr></tbody></table><ol start="5"><li>找到 bestMatch 之后，接下来再根据 bestMatch 去 handlerMap 中找到对应的处理器，直接找如果没找到，就去检查 bestMatch 是否以 <code>/</code> 结尾，如果是以 <code>/</code> 结尾，则去掉结尾的 <code>/</code> 再去 handlerMap 中查找，如果还没找到，那就该抛异常出来了。如果找到的 handler 是 String 类型的，则再去 Spring 容器中查找对应的 Bean，接下来再调用 validateHandler 方法进行验证。</li><li>接下来调用 extractPathWithinPattern 方法提取出映射路径，例如定义的接口规则是 <code>myroot/*.html</code>，请求路径是 <code>myroot/myfile.html</code>，那么最终获取到的就是 <code>myfile.html</code>。</li><li>接下来的 for 循环是为了处理存在多个最佳匹配规则的情况，在第四步中，我们对 matchingPatterns 进行排序，排序完成后，选择第一项作为最佳选项赋值给 bestMatch，但是最佳选项可能会有多个，这里就是处理最佳选项有多个的情况。</li><li>最后调用 buildPathExposingHandler 方法注册两个内部拦截器，该方法下文我会给大家详细介绍。</li></ol><p>lookupHandler 还有一个重载方法，不过只要大家把这个方法的执行流程搞清楚了，重载方法其实很好理解，这里松哥就不再赘述了，唯一要说的就是重载方法用了 PathPattern 去匹配 URL 路径，而这个方法用了 AntPathMatcher 去匹配 URL 路径。</p><p><strong>buildPathExposingHandler</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">buildPathExposingHandler</span><span class="hljs-params">(Object rawHandler, String bestMatchingPattern,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">String pathWithinMapping, @Nullable Map&lt;String, String&gt; uriTemplateVariables)</span> </span>&#123;</span><br><span class="line">HandlerExecutionChain chain = <span class="hljs-keyword">new</span> HandlerExecutionChain(rawHandler);</span><br><span class="line">chain.addInterceptor(<span class="hljs-keyword">new</span> PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping));</span><br><span class="line"><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(uriTemplateVariables)) &#123;</span><br><span class="line">chain.addInterceptor(<span class="hljs-keyword">new</span> UriTemplateVariablesHandlerInterceptor(uriTemplateVariables));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buildPathExposingHandler 方法向 HandlerExecutionChain 中添加了两个拦截器 PathExposingHandlerInterceptor 和 UriTemplateVariablesHandlerInterceptor，这两个拦截器在各自的 preHandle 中分别向 request 对象添加了一些属性，具体添加的属性小伙伴们可以自行查看，这个比较简单，我就不多说了。</p><p>在前面的方法中，涉及到一个重要的变量 handlerMap，我们定义的接口和处理器之间的关系都保存在这个变量中，那么这个变量是怎么初始化的呢？这就涉及到 AbstractUrlHandlerMapping 中的另一个方法 registerHandler：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHandler</span><span class="hljs-params">(String[] urlPaths, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String urlPath : urlPaths) &#123;</span><br><span class="line">registerHandler(urlPath, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHandler</span><span class="hljs-params">(String urlPath, Object handler)</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">Object resolvedHandler = handler;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.lazyInitHandlers &amp;&amp; handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">ApplicationContext applicationContext = obtainApplicationContext();</span><br><span class="line"><span class="hljs-keyword">if</span> (applicationContext.isSingleton(handlerName)) &#123;</span><br><span class="line">resolvedHandler = applicationContext.getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Object mappedHandler = <span class="hljs-keyword">this</span>.handlerMap.get(urlPath);</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != resolvedHandler) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"Cannot map "</span> + getHandlerDescription(handler) + <span class="hljs-string">" to URL path ["</span> + urlPath +</span><br><span class="line"><span class="hljs-string">"]: There is already "</span> + getHandlerDescription(mappedHandler) + <span class="hljs-string">" mapped."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (urlPath.equals(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">setRootHandler(resolvedHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (urlPath.equals(<span class="hljs-string">"/*"</span>)) &#123;</span><br><span class="line">setDefaultHandler(resolvedHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line"><span class="hljs-keyword">if</span> (getPatternParser() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.pathPatternHandlerMap.put(getPatternParser().parse(urlPath), resolvedHandler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerHandler(String[],String) 方法有两个参数，第一个就是定义的请求路径，第二个参数则是处理器 Bean 的名字，第一个参数是一个数组，那是因为同一个处理器可以对应多个不同的请求路径。</p><p>在重载方法 registerHandler(String,String) 里边，完成了 handlerMap 的初始化，具体流程如下：</p><ol><li>如果没有设置 lazyInitHandlers，并且 handler 是 String 类型，那么就去 Spring 容器中找到对应的 Bean 赋值给 resolvedHandler。</li><li>根据 urlPath 去 handlerMap 中查看是否已经有对应的处理器了，如果有的话，则抛出异常，一个 URL 地址只能对应一个处理器，这个很好理解。</li><li>接下来根据 URL 路径，将处理器进行配置，最终添加到 handlerMap 变量中。</li></ol><p>这就是 AbstractUrlHandlerMapping 的主要工作，其中 registerHandler 将在它的子类中调用。</p><p>接下来我们来看 AbstractUrlHandlerMapping 的子类。</p><h3 id="3-1-SimpleUrlHandlerMapping"><a href="#3-1-SimpleUrlHandlerMapping" class="headerlink" title="3.1 SimpleUrlHandlerMapping"></a>3.1 SimpleUrlHandlerMapping</h3><p>为了方便处理，SimpleUrlHandlerMapping 中自己定义了一个 urlMap 变量，这样可以在注册之前做一些预处理，例如确保所有的 URL 都是以 <code>/</code> 开始。SimpleUrlHandlerMapping 在定义时重写了父类的 initApplicationContext 方法，并在该方法中调用了 registerHandlers，在 registerHandlers 中又调用了父类的 registerHandler 方法完成了 handlerMap 的初始化操作：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>.initApplicationContext();</span><br><span class="line">registerHandlers(<span class="hljs-keyword">this</span>.urlMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHandlers</span><span class="hljs-params">(Map&lt;String, Object&gt; urlMap)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (urlMap.isEmpty()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"No patterns in "</span> + formatMappingName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">urlMap.forEach((url, handler) -&gt; &#123;</span><br><span class="line"><span class="hljs-comment">// Prepend with slash if not already present.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!url.startsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">url = <span class="hljs-string">"/"</span> + url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Remove whitespace from handler bean name.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;</span><br><span class="line">handler = ((String) handler).trim();</span><br><span class="line">&#125;</span><br><span class="line">registerHandler(url, handler);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码很简单，实在没啥好说的，如果 URL 不是以 <code>/</code> 开头，则手动给它加上 <code>/</code> 即可。有小伙伴们可能要问了，urlMap 的值从哪里来？当然是从我们的配置文件里边来呀，像下面这样：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"urlMap"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"/aaa"</span> <span class="hljs-attr">value-ref</span>=<span class="hljs-string">"/hello"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-AbstractDetectingUrlHandlerMapping"><a href="#3-2-AbstractDetectingUrlHandlerMapping" class="headerlink" title="3.2 AbstractDetectingUrlHandlerMapping"></a>3.2 AbstractDetectingUrlHandlerMapping</h3><p>AbstractDetectingUrlHandlerMapping 也是 AbstractUrlHandlerMapping 的子类，但是它和 SimpleUrlHandlerMapping 有一些不一样的地方。</p><p>不一样的是哪里呢？</p><p>AbstractDetectingUrlHandlerMapping 会自动查找到 SpringMVC 容器以及 Spring 容器中的所有 beanName，然后根据 beanName 解析出对应的 URL 地址，再将解析出的 url 地址和对应的 beanName 注册到父类的 handlerMap 变量中。换句话说，如果你用了 AbstractDetectingUrlHandlerMapping，就不用像 SimpleUrlHandlerMapping 那样去挨个配置 URL 地址和处理器的映射关系了。我们来看下 AbstractDetectingUrlHandlerMapping#initApplicationContext 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ApplicationContextException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>.initApplicationContext();</span><br><span class="line">detectHandlers();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detectHandlers</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">ApplicationContext applicationContext = obtainApplicationContext();</span><br><span class="line">String[] beanNames = (<span class="hljs-keyword">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">applicationContext.getBeanNamesForType(Object.class));</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">registerHandler(urls, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractDetectingUrlHandlerMapping 重写了父类的 initApplicationContext 方法，并在该方法中调用了 detectHandlers 方法，在 detectHandlers 中，首先查找到所有的 beanName，然后调用 determineUrlsForHandler 方法分析出 beanName 对应的 URL，不过这里的 determineUrlsForHandler 方法是一个空方法，具体的实现在它的子类中，AbstractDetectingUrlHandlerMapping 只有一个子类 BeanNameUrlHandlerMapping，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanNameUrlHandlerMapping</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDetectingUrlHandlerMapping</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">List&lt;String&gt; urls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (beanName.startsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">urls.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">String[] aliases = obtainApplicationContext().getAliases(beanName);</span><br><span class="line"><span class="hljs-keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (alias.startsWith(<span class="hljs-string">"/"</span>)) &#123;</span><br><span class="line">urls.add(alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> StringUtils.toStringArray(urls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类很简单，里边就一个 determineUrlsForHandler 方法，这个方法的执行逻辑也很简单，就判断 beanName 是不是以 <code>/</code> 开始，如果是，则将之作为 URL。</p><p>如果我们想要在项目中使用 BeanNameUrlHandlerMapping，配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.init.HelloController"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"/hello"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"handlerMapping"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，Controller 的 name 必须是以 <code>/</code> 开始，否则该 bean 不会被自动作为处理器。</p><p>至此，AbstractUrlHandlerMapping 体系下的东西就和大家分享完了。</p><h2 id="4-AbstractHandlerMethodMapping"><a href="#4-AbstractHandlerMethodMapping" class="headerlink" title="4.AbstractHandlerMethodMapping"></a>4.AbstractHandlerMethodMapping</h2><p>AbstractHandlerMethodMapping 体系下只有三个类，分别是 AbstractHandlerMethodMapping、RequestMappingInfoHandlerMapping 以及 RequestMappingHandlerMapping，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210307171135.png" alt></p><p>在前面第三小节的 AbstractUrlHandlerMapping 体系下，一个 Handler 一般就是一个类，但是在 AbstractHandlerMethodMapping 体系下，一个 Handler 就是一个 Mehtod，这也是我们目前使用 SpringMVC 时最常见的用法，即直接用 @RequestMapping 去标记一个方法，该方法就是一个 Handler。</p><p>接下来我们就一起来看看 AbstractHandlerMethodMapping。</p><h3 id="4-1-初始化流程"><a href="#4-1-初始化流程" class="headerlink" title="4.1 初始化流程"></a>4.1 初始化流程</h3><p>AbstractHandlerMethodMapping 类实现了 InitializingBean 接口，所以 Spring 容器会自动调用其 afterPropertiesSet 方法，在这里将完成初始化操作：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerMethods</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">processCandidateBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">protected</span> String[] getCandidateBeanNames() &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</span><br><span class="line">obtainApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processCandidateBean</span><span class="hljs-params">(String beanName)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; beanType = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (beanType != <span class="hljs-keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">detectHandlerMethods(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，具体的初始化又是在 initHandlerMethods 方法中完成的，在该方法中，首先调用 getCandidateBeanNames 方法获取容器中所有的 beanName，然后调用 processCandidateBean 方法对这些候选的 beanName 进行处理，具体的处理思路就是根据 beanName 找到 beanType，然后调用 isHandler 方法判断该 beanType 是不是一个 Handler，isHandler 是一个空方法，在它的子类 RequestMappingHandlerMapping 中被实现了，该方法主要是检查该 beanType 上有没有 <code>@Controller</code> 或者 <code>@RequestMapping</code> 注解，如果有，说明这就是我们想要的 handler，接下来再调用 detectHandlerMethods 方法保存 URL 和 handler 的映射关系：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detectHandlerMethods</span><span class="hljs-params">(Object handler)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; handlerType = (handler <span class="hljs-keyword">instanceof</span> String ?</span><br><span class="line">obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"><span class="hljs-keyword">if</span> (handlerType != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">userType.getName() + <span class="hljs-string">"]: "</span> + method, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先找到 handler 的类型 handlerType。</li><li>调用 ClassUtils.getUserClass 方法检查是否是 cglib 代理的子对象类型，如果是，则返回父类型，否则将参数直接返回。</li><li>接下来调用 MethodIntrospector.selectMethods 方法获取当前 bean 中所有符合要求的 method。</li><li>遍历 methods，调用 registerHandlerMethod 方法完成注册。</li></ol><p>上面这段代码里又涉及到两个方法：</p><ul><li>getMappingForMethod</li><li>registerHandlerMethod</li></ul><p>我们分别来看：</p><p><strong>getMappingForMethod</strong></p><p>getMappingForMethod 是一个模版方法，具体的实现也是在子类 RequestMappingHandlerMapping 里边：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> RequestMappingInfo <span class="hljs-title">getMappingForMethod</span><span class="hljs-params">(Method method, Class&lt;?&gt; handlerType)</span> </span>&#123;</span><br><span class="line">RequestMappingInfo info = createRequestMappingInfo(method);</span><br><span class="line"><span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);</span><br><span class="line"><span class="hljs-keyword">if</span> (typeInfo != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">info = typeInfo.combine(info);</span><br><span class="line">&#125;</span><br><span class="line">String prefix = getPathPrefix(handlerType);</span><br><span class="line"><span class="hljs-keyword">if</span> (prefix != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">info = RequestMappingInfo.paths(prefix).options(<span class="hljs-keyword">this</span>.config).build().combine(info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据 method 对象，调用 createRequestMappingInfo 方法获取一个 RequestMappingInfo，一个 RequestMappingInfo 包含了一个接口定义的详细信息，例如参数、header、produces、consumes、请求方法等等信息都在这里边。接下来再根据 handlerType 也获取一个 RequestMappingInfo，并调用 combine 方法将两个 RequestMappingInfo 进行合并。接下来调用 getPathPrefix 方法查看 handlerType 上有没有 URL 前缀，如果有，就添加到 info 里边去，最后将 info 返回。</p><p>这里要说一下 handlerType 里边的这个前缀是那里来的，我们可以在 Controller 上使用 <code>@RequestMapping</code> 注解，配置一个路径前缀，这样 Controller 中的所有方法都加上了该路径前缀，但是这种方式需要一个一个的配置，如果想一次性配置所有的 Controller 呢？我们可以使用 Spring5.1 中新引入的方法 addPathPrefix 来配置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.setPatternParser(<span class="hljs-keyword">new</span> PathPatternParser()).addPathPrefix(<span class="hljs-string">"/itboyhub"</span>, HandlerTypePredicate.forAnnotation(RestController.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个配置表示，所有的 <code>@RestController</code> 标记的类都自动加上 <code>itboyhub</code> 前缀。有了这个配置之后，上面的 getPathPrefix 方法获取到的就是 <code>/itboyhub</code> 了。</p><p><strong>registerHandlerMethod</strong></p><p>当找齐了 URL 和 handlerMethod 之后，接下来就是将这些信息保存下来，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerHandlerMethod</span><span class="hljs-params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">validateMethodMapping(handlerMethod, mapping);</span><br><span class="line">Set&lt;String&gt; directPaths = AbstractHandlerMethodMapping.<span class="hljs-keyword">this</span>.getDirectPaths(mapping);</span><br><span class="line"><span class="hljs-keyword">for</span> (String path : directPaths) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.pathLookup.add(path, mapping);</span><br><span class="line">&#125;</span><br><span class="line">String name = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (getNamingStrategy() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">addMappingName(name, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line"><span class="hljs-keyword">if</span> (corsConfig != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">corsConfig.validateAllowCredentials();</span><br><span class="line"><span class="hljs-keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.registry.put(mapping,</span><br><span class="line"><span class="hljs-keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directPaths, name, corsConfig != <span class="hljs-keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 createHandlerMethod 方法创建 HandlerMethod 对象。</li><li>调用 validateMethodMapping 方法对 handlerMethod 进行验证，主要是验证 handlerMethod 是否已经存在。</li><li>从 mappings 中提取出 directPaths，就是不包含通配符的请求路径，然后将请求路径和 mapping 的映射关系保存到 pathLookup 中。</li><li>找到所有 handler 的简称，调用 addMappingName 方法添加到 nameLookup 中。例如我们在 HelloController 中定义了一个名为 hello 的请求接口，那么这里拿到的就是 <code>HC#hello</code>，HC 是 HelloController 中的大写字母。</li><li>初始化跨域配置，并添加到 corsLookup 中。</li><li>将构建好的关系添加到 registry 中。</li></ol><p>多说一句，第四步这个东西有啥用呢？这个其实是 Spring4 中开始增加的功能，算是一个小彩蛋吧，虽然日常开发很少用，但是我这里还是和大家说一下。</p><p>假如你有如下一个接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/javaboy"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/aaa"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello99</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"aaa"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你请求该接口的时候，不想通过路径，想直接通过方法名，行不行呢？当然可以！</p><p>在 jsp 文件中，添加如下超链接：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="hljs-string">"s"</span> uri=<span class="hljs-string">"http://www.springframework.org/tags"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="hljs-string">"text/html;charset=UTF-8"</span> language=<span class="hljs-string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href="$&#123;s:mvcUrl('HC#hello99').build()&#125;"&gt;Go!&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当这个 jsp 页面渲染完成后，href 属性就自动成了 hello99 方法的请求路径了。这个功能的实现，就依赖于前面第四步的内容。</p><p>至此，我们就把 AbstractHandlerMethodMapping 的初始化流程看完了。</p><h3 id="4-2-请求处理"><a href="#4-2-请求处理" class="headerlink" title="4.2 请求处理"></a>4.2 请求处理</h3><p>接下来我们来看下当请求到来后，AbstractHandlerMethodMapping 会如何处理。</p><p>和前面第三小节一样，这里处理请求的入口方法也是 getHandlerInternal，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title">getHandlerInternal</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String lookupPath = initLookupPath(request);</span><br><span class="line"><span class="hljs-keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line"><span class="hljs-keyword">return</span> (handlerMethod != <span class="hljs-keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title">lookupHandlerMethod</span><span class="hljs-params">(String lookupPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;Match&gt; matches = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;T&gt; directPathMatches = <span class="hljs-keyword">this</span>.mappingRegistry.getMappingsByDirectPath(lookupPath);</span><br><span class="line"><span class="hljs-keyword">if</span> (directPathMatches != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">addMatchingMappings(<span class="hljs-keyword">this</span>.mappingRegistry.getRegistrations().keySet(), matches, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">Match bestMatch = matches.get(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (matches.size() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">Comparator&lt;Match&gt; comparator = <span class="hljs-keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">matches.sort(comparator);</span><br><span class="line">bestMatch = matches.get(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Match match : matches) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (match.hasCorsConfig()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Match secondBestMatch = matches.get(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">Method m1 = bestMatch.getHandlerMethod().getMethod();</span><br><span class="line">Method m2 = secondBestMatch.getHandlerMethod().getMethod();</span><br><span class="line">String uri = request.getRequestURI();</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"Ambiguous handler methods mapped for '"</span> + uri + <span class="hljs-string">"': &#123;"</span> + m1 + <span class="hljs-string">", "</span> + m2 + <span class="hljs-string">"&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.getHandlerMethod());</span><br><span class="line">handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line"><span class="hljs-keyword">return</span> bestMatch.getHandlerMethod();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleNoMatch(<span class="hljs-keyword">this</span>.mappingRegistry.getRegistrations().keySet(), lookupPath, request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就比较容易，通过 lookupHandlerMethod 找到对应的 HandlerMethod 返回即可，如果 lookupHandlerMethod 方法返回值不为 null，则通过 createWithResolvedBean 创建 HandlerMethod（主要是确认里边的 Bean 等），具体的创建过程松哥在后面的文章中会专门和大家分享。lookupHandlerMethod 方法也比较容易：</p><ol><li>首先根据 lookupPath 找到匹配条件 directPathMatches，然后将获取到的匹配条件添加到 matches 中（不包含通配符的请求走这里）。</li><li>如果 matches 为空，说明根据 lookupPath 没有找到匹配条件，那么直接将所有匹配条件加入 matches 中（包含通配符的请求走这里）。</li><li>对 matches 进行排序，并选择排序后的第一个为最佳匹配项，如果前两个排序相同，则抛出异常。</li></ol><p>大致的流程就是这样，具体到请求并没有涉及到它的子类。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>SpringMVC 九大组件，今天和小伙伴们把 HandlerMapping 过了一遍，其实只要认真看，这里并没有难点。如果小伙伴们觉得阅读吃力，也可以在公众号后台回复 ssm，查看松哥录制的免费入门教程～</p><p>剩下的八大组件源码解析，小伙伴们敬请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面跟小伙伴们分享了 SpringMVC 一个大致的初始化流程以及请求的大致处理流程，在请求处理过程中，涉及到九大组件，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HandlerMapping&lt;/li&gt;
&lt;li&gt;HandlerAdapter&lt;/li&gt;
&lt;li&gt;HandlerExceptionResolver&lt;/li&gt;
&lt;li&gt;ViewResolver&lt;/li&gt;
&lt;li&gt;RequestToViewNameTranslator&lt;/li&gt;
&lt;li&gt;LocaleResolver&lt;/li&gt;
&lt;li&gt;ThemeResolver&lt;/li&gt;
&lt;li&gt;MultipartResolver&lt;/li&gt;
&lt;li&gt;FlashMapManager&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 源码分析之 DispatcherServlet</title>
    <link href="http://www.javaboy.org/2021/0324/springmvc-dispatcherservlet.html"/>
    <id>http://www.javaboy.org/2021/0324/springmvc-dispatcherservlet.html</id>
    <published>2021-03-24T03:27:25.000Z</published>
    <updated>2021-03-24T03:28:32.423Z</updated>
    
    <content type="html"><![CDATA[<p>前面松哥和大家聊了 DispatcherServlet 的父类 FrameworkServlet，大家从中了解到在 DispatcherServlet 中，方法执行的入口应该是 doService。如果小伙伴们还没看前面的分析，可以先看下，这有助于理解本文，传送门<a href="https://mp.weixin.qq.com/s/uXN93XkXflSefqejWwj1NA" target="_blank" rel="noopener">SpringMVC 源码分析之 FrameworkServlet</a>。</p><a id="more"></a><p>即使你没看过 DispatcherServlet 的源码，估计也听说过：DispatcherServlet 是 SpringMVC 的大脑，它负责整个 SpringMVC 的调度工作，是 SpringMVC 中最最核心的类，SpringMVC 整个顶层架构设计都体现在这里，所以搞明白 DispatcherServlet 的源码，基本上 SpringMVC 的工作原理也就了然于胸了。</p><p>经过<a href="https://mp.weixin.qq.com/s/uXN93XkXflSefqejWwj1NA" target="_blank" rel="noopener">上篇文章</a>的分析，大家已经知道 DispatcherServlet 的入口方法是 doService，所以今天我们就从 doService 方法开始看起，松哥将带领大家，一步一步揭开 DispatcherServlet 的面纱。</p><h2 id="doService"><a href="#doService" class="headerlink" title="doService"></a>doService</h2><p>先来看 doService，把源码先贴上来，然后我们逐步分析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">logRequest(request);</span><br><span class="line"><span class="hljs-comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line"><span class="hljs-comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">attributesSnapshot = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line"><span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">String attrName = (String) attrNames.nextElement();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.localeResolver);</span><br><span class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.themeResolver);</span><br><span class="line">request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">FlashMap inputFlashMap = <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);</span><br><span class="line">&#125;</span><br><span class="line">RequestPath previousRequestPath = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parseRequestPath) &#123;</span><br><span class="line">previousRequestPath = (RequestPath) request.getAttribute(ServletRequestPathUtils.PATH_ATTRIBUTE);</span><br><span class="line">ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">doDispatch(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ServletRequestPathUtils.setParsedRequestPath(previousRequestPath, request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码并不长，我们来稍微分析一下：</p><ol><li>首先判断当前请求是不是 include 请求，如果是 include，则对 request 的 attribute 做一个快照备份，在最后的 finally 中再对备份的属性进行还原。</li><li>接下来对 request 设置一些常见属性，例如应用上下文、国际化的解析器、主题解析器等等，这些东西在初始化的时候已经准备好了，这里只是应用（初始化过程参见<a href="https://mp.weixin.qq.com/s/IeMOfnXhOX5RCf4i5Xsdzw" target="_blank" rel="noopener">SpringMVC 初始化流程分析</a>一文）。</li><li>接下来处理 flashMap，如果存在 flashMap 则进行复原，这一块松哥在之前的文章中和小伙伴们已经分享过了，传送门<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>。</li><li>接下来处理 RequestPath，将请求路径对象化以备后续使用（在后面的请求映射匹配时会用到）。</li><li>调用 doDispatch 方法进行下一步处理。</li><li>还原快照属性、还原 RequestPath。</li></ol><p>所以说这段代码并不难理解，它的核心在于 doDispatch 方法，所以接下来我们就来看看 doDispatch 方法。</p><h2 id="doDispatch"><a href="#doDispatch" class="headerlink" title="doDispatch"></a>doDispatch</h2><p>doDispatch 方法所做的事情就比较多了，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">boolean</span> multipartRequestParsed = <span class="hljs-keyword">false</span>;</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="hljs-keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"><span class="hljs-comment">// Determine handler for the current request.</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"><span class="hljs-comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="hljs-keyword">boolean</span> isGet = <span class="hljs-string">"GET"</span>.equals(method);</span><br><span class="line"><span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="hljs-keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"><span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="hljs-comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较长，涉及到很多组件的处理，这里松哥先和大家把思路梳理畅通，各个组件的详细用法松哥将在以后的文章中和大家仔细分享。</p><p>doDispatch 方法其实主要做了两方面的事情：请求处理以及页面渲染，我们先来看看初始变量的含义：</p><ol><li>processedRequest：这个用来保存实际上所用的 request 对象，在后面的流程中会对当前 request 对象进行检查，如果是文件上传请求，则会对请求重新进行封装，如果不是文件上传请求，则继续使用原来的请求。</li><li>mappedHandler：这是具体处理请求的处理器链，处理器链包含两方面的东西：请求处理器和对应的 Interceptor。</li><li>multipartRequestParsed：表示是否是文件上传请求的标记。</li><li>asyncManager：这是一个异步请求管理器。</li><li>mv：这是最终渲染返回的 ModelAndView 对象。</li><li>dispatchException：表示请求处理过程中所抛出的异常，这个异常不包括渲染过程抛出的异常。</li></ol><p>接下来再来看看具体的处理逻辑：</p><ol><li>首先通过 checkMultipart 检查是不是文件上传请求，如果是，则对当前 request 重新进行包装，如果不是，则直接将参数返回。</li><li>如果 processedRequest 不等于 request，则说明当前请求是文件上传请求（request 在 checkMultipart 方法中被重新封装了），否则说明当前请求不是文件上传请求。</li><li>根据当前请求，调用 getHandler 方法获取请求处理器，如果没找到对应的请求处理器，则调用 noHandlerFound 方法抛出异常或者给出 404。</li><li>接下来再调用 getHandlerAdapter 方法，根据当前的处理器找到处理器适配器。</li><li>然后处理 GET 和 HEAD 请求头的 Last_Modified 字段。当浏览器第一次发起 GET 或者 HEAD 请求时，请求的响应头中包含一个 Last-Modified 字段，这个字段表示该资源最后一次修改时间，以后浏览器再次发送 GET、HEAD 请求时，都会携带上该字段，服务端收到该字段之后，和资源的最后一次修改时间进行对比，如果资源还没有过期，则直接返回 304 告诉浏览器之前的资源还是可以继续用的，如果资源已经过期，则服务端会返回新的资源以及新的 Last-Modified。</li><li>接下来调用拦截器的 preHandle 方法，如果该方法返回 false，则直接 return 掉当前请求（拦截器的用法大家可以参考松哥之前录的免费的 SpringMVC 视频教程，里边有讲，传送门<a href="https://mp.weixin.qq.com/s/KONEIdt_c3Di1zMlXGLxuw" target="_blank" rel="noopener">硬核！松哥又整了一套免费视频，搞起！</a>）。</li><li>接下来执行 <code>ha.handle</code> 去调用真正的请求，获取到返回结果 mv。</li><li>接下来判断当前请求是否需要异步处理，如果需要，则直接 return 掉。</li><li>如果不需要异步处理，则执行 applyDefaultViewName 方法，检查当前 mv 是否没有视图，如果没有（例如方法返回值为 void），则给一个默认的视图名。</li><li>接下来调用 applyPostHandle 方法执行拦截器里边的 postHandle 方法。</li><li>接下来调用 processDispatchResult 方法对执行结果进行处理，包括异常处理、渲染页面以及执行拦截器的 afterCompletion 方法都在这里完成。</li><li>最后在 finally 代码块中判断是否开启了异步处理，如果开启了，则调用相应的拦截器；如果请求是文件上传请求，则再调用 cleanupMultipart 方法清除文件上传过程产生的一些临时文件。</li></ol><p>这是 doDispatch 方法的一个大致执行逻辑，doDispatch 里边的 try-catch 有两层，最里边那一层，抛出来的异常会被赋值给 dispatchException 变量，这些异常最终在 processDispatchResult 方法中被处理掉，外面的异常则是 processDispatchResult 方法在执行的过程中抛出的异常，一般来说主要是页面渲染时候的异常。</p><h2 id="processDispatchResult"><a href="#processDispatchResult" class="headerlink" title="processDispatchResult"></a>processDispatchResult</h2><p>最后我们再来看下 processDispatchResult 方法的执行逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Exception exception)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> errorView = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (exception != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Object handler = (mappedHandler != <span class="hljs-keyword">null</span> ? mappedHandler.getHandler() : <span class="hljs-keyword">null</span>);</span><br><span class="line">mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">errorView = (mv != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Did the handler return a view to render?</span></span><br><span class="line"><span class="hljs-keyword">if</span> (mv != <span class="hljs-keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">render(mv, request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (errorView) &#123;</span><br><span class="line">WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Concurrent handling started during a forward</span></span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Exception (if any) is already handled..</span></span><br><span class="line">mappedHandler.triggerAfterCompletion(request, response, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 processDispatchResult 方法中首先对异常进行了处理，配置好异常对应的 ModelAndView，然后调用 render 方法对页面进行渲染，最后通过 triggerAfterCompletion 方法去触发拦截器的 afterCompletion 方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，我们就把一个请求的大致流程和大家梳理完了，松哥画了一张流程图我们一起来看下：</p><p><img src="http://img.itboyhub.com/2021/02/jkdfajkldfjkl74857829djnfklsk.png" alt></p><p>这下相信大家对 doDispatch 方法比较熟悉了，当然这里还涉及到很多组件，这些组件松哥将在后面的文章中和大家逐一进行分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面松哥和大家聊了 DispatcherServlet 的父类 FrameworkServlet，大家从中了解到在 DispatcherServlet 中，方法执行的入口应该是 doService。如果小伙伴们还没看前面的分析，可以先看下，这有助于理解本文，传送门&lt;a href=&quot;https://mp.weixin.qq.com/s/uXN93XkXflSefqejWwj1NA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringMVC 源码分析之 FrameworkServlet&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 源码分析之 FrameworkServlet</title>
    <link href="http://www.javaboy.org/2021/0323/springmvc-frameworkservlet.html"/>
    <id>http://www.javaboy.org/2021/0323/springmvc-frameworkservlet.html</id>
    <published>2021-03-23T00:37:53.000Z</published>
    <updated>2021-03-23T00:39:00.002Z</updated>
    
    <content type="html"><![CDATA[<p>前面和小伙伴们聊了 SpringMVC 的初始化流程，相信大家对于 SpringMVC 的初始化过程都有一个基本认知了，今天我们就来看看当一个请求到达后，它的执行流程是什么样的？当然这个流程比较长，松哥这里可能会分两篇文章来和大家分享。</p><a id="more"></a><p>很多小伙伴都知道 SpringMVC 的核心是 DispatcherServlet，而 DispatcherServlet 的父类就是 FrameworkServlet，因此我们先来看看 FrameworkServlet，这有助于我们理解 DispatcherServlet。</p><h2 id="1-FrameworkServlet"><a href="#1-FrameworkServlet" class="headerlink" title="1.FrameworkServlet"></a>1.FrameworkServlet</h2><p>FrameworkServlet 继承自 HttpServletBean，而 HttpServletBean 继承自 HttpServlet，HttpServlet 就是 JavaEE 里边的东西了，这里我们不做讨论，从 HttpServletBean 开始就是框架的东西了，但是 HttpServletBean 比较特殊，它的特殊在于它没有进行任何的请求处理，只是参与了一些初始化的操作，这些比较简单，而且我们在上篇文章中也已经分析过了，所以这里我们对 HttpServletBean 不做分析，就直接从它的子类 FrameworkServlet 开始看起。</p><p><img src="http://img.itboyhub.com/2021/02/20210301214050.png" alt></p><p>和所有的 Servlet 一样，FrameworkServlet 对请求的处理也是从 service 方法开始，我们先来看看该方法 FrameworkServlet#service：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="hljs-keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在该方法中，首先获取到当前请求方法，然后对 patch 请求额外关照了下，其他类型的请求统统都是 super.service 进行处理。</p><p>然而在 HttpServlet 中并未对 doGet、doPost 等请求进行实质性处理，所以 FrameworkServlet 中还重写了各种请求对应的方法，如 doDelete、doGet、doOptions、doPost、doPut、doTrace 等，其实就是除了 doHead 之外的其他方法都重写了。</p><p>我们先来看看 doDelete、doGet、doPost 以及 doPut 四个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPut</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDelete</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里又把请求交给 processRequest 去处理了，在 processRequest 方法中则会进一步调用到 doService，对不同类型的请求分类处理。</p><p>doOptions 和 doTrace 则稍微有些差异，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOptions</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dispatchOptionsRequest || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (response.containsHeader(<span class="hljs-string">"Allow"</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">super</span>.doOptions(request, <span class="hljs-keyword">new</span> HttpServletResponseWrapper(response) &#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeader</span><span class="hljs-params">(String name, String value)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-string">"Allow"</span>.equals(name)) &#123;</span><br><span class="line">value = (StringUtils.hasLength(value) ? value + <span class="hljs-string">", "</span> : <span class="hljs-string">""</span>) + HttpMethod.PATCH.name();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">super</span>.setHeader(name, value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTrace</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dispatchTraceRequest) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-string">"message/http"</span>.equals(response.getContentType())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">super</span>.doTrace(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这两个方法的处理多了一层逻辑，就是去选择是在当前方法中处理对应的请求还是交给父类去处理，由于 dispatchOptionsRequest 和 dispatchTraceRequest 变量默认都是 false，因此默认情况下，这两种类型的请求都是交给了父类去处理。</p><h2 id="2-processRequest"><a href="#2-processRequest" class="headerlink" title="2.processRequest"></a>2.processRequest</h2><p>我们再来看 processRequest，这算是 FrameworkServlet 的核心方法了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">Throwable failureCause = <span class="hljs-keyword">null</span>;</span><br><span class="line">LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line">RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="hljs-keyword">new</span> RequestBindingInterceptor());</span><br><span class="line">initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">doService(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">"Request processing failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line"><span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">requestAttributes.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">logResult(request, response, failureCause, asyncManager);</span><br><span class="line">publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法虽然比较长，但是其实它的核心就是最中间的 doService 方法，以 doService 为界，我们可以将该方法的内容分为三部分：</p><ol><li>doService 之前主要是一些准备工作，准备工作主要干了两件事，第一件事就是从 LocaleContextHolder 和 RequestContextHolder 中分别获取它们原来保存的 LocaleContext 和 RequestAttributes 对象存起来，然后分别调用 buildLocaleContext 和 buildRequestAttributes 方法获取到当前请求的 LocaleContext 和 RequestAttributes 对象，再通过 initContextHolders 方法将当前请求的 LocaleContext 和 RequestAttributes 对象分别设置到 LocaleContextHolder 和 RequestContextHolder 对象中；第二件事则是获取到异步管理器并设置拦截器。</li><li>接下来就是 doService 方法，这是一个抽象方法，具体的实现在 DispatcherServlet 中，这个松哥放到 DispatcherServlet 中再和大家分析。</li><li>第三部分就是 finally 中，这个里边干了两件事：第一件事就是将 LocaleContextHolder 和 RequestContextHolder 中对应的对象恢复成原来的样子（参考第一步）；第二件事就是通过 publishRequestHandledEvent 方法发布一个 ServletRequestHandledEvent 类型的消息。</li></ol><p>经过上面的分析，大家发现，processRequest 其实主要做了两件事，第一件事就是对 LocaleContext 和 RequestAttributes 的处理，第二件事就是发布事件。我们对这两件事分别来研究。</p><h3 id="2-1-LocaleContext-和-RequestAttributes"><a href="#2-1-LocaleContext-和-RequestAttributes" class="headerlink" title="2.1 LocaleContext 和 RequestAttributes"></a>2.1 LocaleContext 和 RequestAttributes</h3><p>LocaleContext 和 RequestAttributes 都是接口，不同的是里边存放的对象不同。</p><h4 id="2-1-1-LocaleContext"><a href="#2-1-1-LocaleContext" class="headerlink" title="2.1.1 LocaleContext"></a>2.1.1 LocaleContext</h4><p>LocaleContext 里边存放着 Locale，也就是本地化信息，如果我们需要支持国际化，就会用到 Locale。</p><p>国际化的时候，如果我们需要用到 Locale 对象，第一反应就是从 HttpServletRequest 中获取，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Locale locale = req.getLocale();</span><br></pre></td></tr></table></figure><p>但是大家知道，HttpServletRequest 只存在于 Controller 中，如果我们想要在 Service 层获取 HttpServletRequest，就得从 Controller 中传参数过来，这样就比较麻烦，特别是有的时候 Service 中相关方法都已经定义好了再去修改，就更头大了。</p><p>所以 SpringMVC 中还给我们提供了 LocaleContextHolder，这个工具就是用来保存当前请求的 LocaleContext 的。当大家看到 LocaleContextHolder 时不知道有没有觉得眼熟，松哥在之前的 Spring Security 系列教程中和大家聊过 SecurityContextHolder，这两个的原理基本一致，都是基于 ThreadLocal 来保存变量，进而确保不同线程之间互不干扰，对 ThreadLocal 不熟悉的小伙伴，可以看看松哥的 Spring Security 系列，之前有详细分析过（公号后台回复 ss）。</p><p>有了 LocaleContextHolder 之后，我们就可以在任何地方获取 Locale 了，例如在 Service 中我们可以通过如下方式获取 Locale：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Locale locale = LocaleContextHolder.getLocale();</span><br></pre></td></tr></table></figure><p>上面这个 Locale 对象实际上就是从 LocaleContextHolder 中的 LocaleContext 里边取出来的。</p><blockquote><p>需要注意的是，SpringMVC 中还有一个 LocaleResolver 解析器，所以前面 req.getLocale() 并不总是获取到 Locale 的值，这个松哥在以后的文章中再和小伙伴们细聊。</p></blockquote><h4 id="2-1-2-RequestAttributes"><a href="#2-1-2-RequestAttributes" class="headerlink" title="2.1.2 RequestAttributes"></a>2.1.2 RequestAttributes</h4><p>RequestAttributes 是一个接口，这个接口可以用来 get/set/remove 某一个属性。</p><p>RequestAttributes 有诸多实现类，默认使用的是 ServletRequestAttributes，通过 ServletRequestAttributes，我们可以 getRequest、getResponse 以及 getSession。</p><p>在 ServletRequestAttributes 的具体实现中，会通过 scope 参数判断操作 request 还是操作 session（如果小伙伴们不记得 Spring 中的作用域问题，可以公号后台回复 spring，看看松哥录制的免费的 Spring 入门教程，里边有讲），我们来看一下 ServletRequestAttributes#setAttribute 方法（get/remove 方法执行逻辑类似）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, Object value, <span class="hljs-keyword">int</span> scope)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (scope == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isRequestActive()) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot set request attribute - request is not active anymore!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">this</span>.request.setAttribute(name, value);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        HttpSession session = <span class="hljs-keyword">this</span>.obtainSession();</span><br><span class="line">        <span class="hljs-keyword">this</span>.sessionAttributesToUpdate.remove(name);</span><br><span class="line">        session.setAttribute(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里会先判断 scope，scope 为 0 就操作 request，scope 为 1 就操作 session。如果操作的是 request，则需要首先通过 isRequestActive 方法判断当前 request 是否执行完毕，如果执行完毕，就不可以再对其进行其他操作了（当执行了 finally 代码块中的 requestAttributes.requestCompleted 方法后，isRequestActive 就会返回 false）。</p><p>和 LocaleContext 类似，RequestAttributes 被保存在 RequestContextHolder 中，RequestContextHolder 的原理也和 SecurityContextHolder 类似，这里不再赘述。</p><p>看了上面的讲解，大家应该发现了，在 SpringMVC 中，如果我们需要在 Controller 之外的其他地方使用 request、response 以及 session，其实不用每次都从 Controller 中传递 request、response 以及 session 等对象，我们完全可以直接通过 RequestContextHolder 来获取，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">HttpServletRequest request = servletRequestAttributes.getRequest();</span><br><span class="line">HttpServletResponse response = servletRequestAttributes.getResponse();</span><br></pre></td></tr></table></figure><p>是不是非常 easy！</p><h3 id="2-2-事件发布"><a href="#2-2-事件发布" class="headerlink" title="2.2 事件发布"></a>2.2 事件发布</h3><p>最后就是 processRequest 方法中的事件发布了。</p><p>在 finally 代码块中会调用 publishRequestHandledEvent 方法发送一个 ServletRequestHandledEvent 类型的事件，具体发送代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishRequestHandledEvent</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span> startTime, @Nullable Throwable failureCause)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.publishEvents &amp;&amp; <span class="hljs-keyword">this</span>.webApplicationContext != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Whether or not we succeeded, publish an event.</span></span><br><span class="line"><span class="hljs-keyword">long</span> processingTime = System.currentTimeMillis() - startTime;</span><br><span class="line"><span class="hljs-keyword">this</span>.webApplicationContext.publishEvent(</span><br><span class="line"><span class="hljs-keyword">new</span> ServletRequestHandledEvent(<span class="hljs-keyword">this</span>,</span><br><span class="line">request.getRequestURI(), request.getRemoteAddr(),</span><br><span class="line">request.getMethod(), getServletConfig().getServletName(),</span><br><span class="line">WebUtils.getSessionId(request), getUsernameForRequest(request),</span><br><span class="line">processingTime, failureCause, response.getStatus()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，事件的发送需要 publishEvents 为 true，而该变量默认就是 true。如果需要修改该变量的值，可以在 web.xml 中配置 DispatcherServlet 时，通过 init-param 节点顺便配置一下该变量的值。正常情况下，这个事件总是会被发送出去，如果项目有需要，我们可以监听该事件，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletRequestHandleListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ServletRequestHandledEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ServletRequestHandledEvent servletRequestHandledEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"请求执行完毕-"</span>+servletRequestHandledEvent.getRequestUrl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个请求执行完毕时，该事件就会被触发。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>这篇文章主要和小伙伴们分享了 SpringMVC 中 DispatcherServlet 的父类 FrameworkServlet，FrameworkServlet 的功能其实比较简单，主要就是在 service 方法中增加了对 PATCH 的处理，然后其他类型的请求都被归类到 processRequest 方法中进行统一处理，processRequest 方法则又分了三部分，首先是对 LocaleContext 和 RequestAttributes 的处理，然后执行 doService，最后在 finally 代码块中对 LocaleContext 和 RequestAttributes 属性进行复原，同时发布一个请求结束的事件。</p><p>doService 是重头戏，松哥将在下篇文章中和大家分享。好啦，今天就先和小伙伴们聊这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和小伙伴们聊了 SpringMVC 的初始化流程，相信大家对于 SpringMVC 的初始化过程都有一个基本认知了，今天我们就来看看当一个请求到达后，它的执行流程是什么样的？当然这个流程比较长，松哥这里可能会分两篇文章来和大家分享。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中如何统一 API 接口响应格式？</title>
    <link href="http://www.javaboy.org/2021/0319/spring-boot-handler-method-return-value-handler.html"/>
    <id>http://www.javaboy.org/2021/0319/spring-boot-handler-method-return-value-handler.html</id>
    <published>2021-03-19T05:56:09.000Z</published>
    <updated>2021-03-22T05:58:54.797Z</updated>
    
    <content type="html"><![CDATA[<p>今天又要给大家介绍一个 Spring Boot 中的组件–HandlerMethodReturnValueHandler。</p><a id="more"></a><p>在前面的文章中（<a href="https://mp.weixin.qq.com/s/LWuUNHJVnBLK15Msu38Wgw" target="_blank" rel="noopener">如何优雅的实现 Spring Boot 接口参数加密解密？</a>），松哥已经和大家介绍过如何对请求/响应数据进行预处理/二次处理，当时我们使用了 ResponseBodyAdvice 和 RequestBodyAdvice。其中 ResponseBodyAdvice 可以实现对响应数据的二次处理，可以在这里对响应数据进行加密/包装等等操作。不过这不是唯一的方案，今天松哥要和大家介绍一种更加灵活的方案–HandlerMethodReturnValueHandler，我们一起来看看下。</p><h2 id="1-HandlerMethodReturnValueHandler"><a href="#1-HandlerMethodReturnValueHandler" class="headerlink" title="1.HandlerMethodReturnValueHandler"></a>1.HandlerMethodReturnValueHandler</h2><p>HandlerMethodReturnValueHandler 的作用是对处理器的处理结果再进行一次二次加工，这个接口里边有两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsReturnType：这个处理器是否支持相应的返回值类型。</li><li>handleReturnValue：对方法返回值进行处理。</li></ul><p>HandlerMethodReturnValueHandler 有很多默认的实现类，我们来看下：</p><p><img src="http://img.itboyhub.com/2021/02/20210317092534.png" alt></p><p>接下来我们来把这些实现类的作用捋一捋：</p><p><strong>ViewNameMethodReturnValueHandler</strong></p><p>这个处理器用来处理返回值为 void 和 String 的情况。如果返回值为 void，则不做任何处理。如果返回值为 String，则将 String 设置给 mavContainer 的 viewName 属性，同时判断这个 String 是不是重定向的 String，如果是，则设置 mavContainer 的 redirectModelScenario 属性为 true，这是处理器返回重定向视图的标志。</p><p><strong>ViewMethodReturnValueHandler</strong></p><p>这个处理器用来处理返回值为 View 的情况。如果返回值为 View，则将 View 设置给 mavContainer 的 view 属性，同时判断这个 View 是不是重定向的 View，如果是，则设置 mavContainer 的 redirectModelScenario 属性为 true，这是处理器返回重定向视图的标志。</p><p><strong>MapMethodProcessor</strong></p><p>这个处理器用来处理返回值类型为 Map 的情况，具体的处理方案就是将 map 添加到 mavContainer 的 model 属性中。</p><p><strong>StreamingResponseBodyReturnValueHandler</strong></p><p>这个用来处理 StreamingResponseBody 或者 <code>ResponseEntity&lt;StreamingResponseBody&gt;</code> 类型的返回值。</p><p><strong>DeferredResultMethodReturnValueHandler</strong></p><p>这个用来处理 DeferredResult、ListenableFuture 以及 CompletionStage 类型的返回值，用于异步请求。</p><p><strong>CallableMethodReturnValueHandler</strong></p><p>处理 Callable 类型的返回值，也是用于异步请求。</p><p><strong>HttpHeadersReturnValueHandler</strong></p><p>这个用来处理 HttpHeaders 类型的返回值，具体处理方式就是将 mavContainer 中的 requestHandled 属性设置为 true，该属性是请求是否已经处理完成的标志（如果处理完了，就到此为止，后面不会再去找视图了），然后将 HttpHeaders 添加到响应头中。</p><p><strong>ModelMethodProcessor</strong></p><p>这个用来处理返回值类型为 Model 的情况，具体的处理方式就是将 Model 添加到 mavContainer 的 model 上。</p><p><strong>ModelAttributeMethodProcessor</strong></p><p>这个用来处理添加了 <code>@ModelAttribute</code> 注解的返回值类型，如果 annotaionNotRequired 属性为 true，也可以用来处理其他非通用类型的返回值。</p><p><strong>ServletModelAttributeMethodProcessor</strong></p><p>同上，该类只是修改了参数解析方式。</p><p><strong>ResponseBodyEmitterReturnValueHandler</strong></p><p>这个用来处理返回值类型为 <code>ResponseBodyEmitter</code> 的情况。</p><p><strong>ModelAndViewMethodReturnValueHandler</strong></p><p>这个用来处理返回值类型为 <code>ModelAndView</code> 的情况，将返回值中的 Model 和 View 分别设置到 mavContainer 的相应属性上去。</p><p><strong>ModelAndViewResolverMethodReturnValueHandler</strong></p><p>这个的 supportsReturnType 方法返回 true，即可以处理所有类型的返回值，这个一般放在最后兜底。</p><p><strong>AbstractMessageConverterMethodProcessor</strong></p><p>这是一个抽象类，当返回值需要通过 HttpMessageConverter 进行转化的时候会用到它的子类。这个抽象类主要是定义了一些工具方法。</p><p><strong>RequestResponseBodyMethodProcessor</strong></p><p>这个用来处理添加了 <code>@ResponseBody</code> 注解的返回值类型。</p><p><strong>HttpEntityMethodProcessor</strong></p><p>这个用来处理返回值类型是 HttpEntity 并且不是 RequestEntity 的情况。</p><p><strong>AsyncHandlerMethodReturnValueHandler</strong></p><p>这是一个空接口，暂未发现典型使用场景。</p><p><strong>AsyncTaskMethodReturnValueHandler</strong></p><p>这个用来处理返回值类型为 WebAsyncTask 的情况。</p><p><strong>HandlerMethodReturnValueHandlerComposite</strong></p><p>看 Composite 就知道，这是一个组合处理器，没啥好说的。</p><p>这个就是系统默认定义的 HandlerMethodReturnValueHandler。</p><p>那么在上面的介绍中，大家看到反复涉及到一个组件 mavContainer，这个我也要和大家介绍一下。</p><h2 id="2-ModelAndViewContainer"><a href="#2-ModelAndViewContainer" class="headerlink" title="2.ModelAndViewContainer"></a>2.ModelAndViewContainer</h2><p>ModelAndViewContainer 就是一个数据穿梭巴士，在整个请求的过程中承担着数据传送的工作，从它的名字上我们可以看出来它里边保存着 Model 和 View 两种类型的数据，但是实际上可不止两种，我们来看下 ModelAndViewContainer 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelAndViewContainer</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> ignoreDefaultModelOnRedirect = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> Object view;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ModelMap defaultModel = <span class="hljs-keyword">new</span> BindingAwareModelMap();</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> ModelMap redirectModel;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> redirectModelScenario = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> HttpStatus status;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; noBinding = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; bindingDisabled = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SessionStatus sessionStatus = <span class="hljs-keyword">new</span> SimpleSessionStatus();</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> requestHandled = <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这几个属性理解了，基本上也就整明白 ModelAndViewContainer 的作用了：</p><ul><li>defaultModel：默认使用的 Model。当我们在接口参数重使用 Model、ModelMap 或者 Map 时，最终使用的实现类都是 BindingAwareModelMap，对应的也都是 defaultModel。</li><li>redirectModel：重定向时候的 Model，如果我们在接口参数中使用了 RedirectAttributes 类型的参数，那么最终会传入 redirectModel。</li></ul><p>可以看到，一共有两个 Model，两个 Model 到底用哪个呢？这个在 getModel 方法中根据条件返回合适的 Model：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelMap <span class="hljs-title">getModel</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (useDefaultModel()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultModel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.redirectModel == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.redirectModel = <span class="hljs-keyword">new</span> ModelMap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.redirectModel;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">useDefaultModel</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (!<span class="hljs-keyword">this</span>.redirectModelScenario || (<span class="hljs-keyword">this</span>.redirectModel == <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.ignoreDefaultModelOnRedirect));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 redirectModelScenario 表示处理器是否返回 redirect 视图；ignoreDefaultModelOnRedirect 表示是否在重定向时忽略 defaultModel，所以这块的逻辑是这样：</p><ol><li>如果 redirectModelScenario 为 true，即处理器返回的是一个重定向视图，那么使用 redirectModel。如果 redirectModelScenario 为 false，即处理器返回的不是一个重定向视图，那么使用 defaultModel。</li><li>如果 redirectModel 为 null，并且 ignoreDefaultModelOnRedirect 为 false，则使用 redirectModel，否则使用 defaultModel。</li></ol><p>接下来还剩下如下一些参数：</p><ul><li>view：返回的视图。</li><li>status：HTTP 状态码。</li><li>noBinding：是否对 @ModelAttribute(binding=true/false) 声明的数据模型的相应属性进行绑定。</li><li>bindingDisabled：不需要进行数据绑定的属性。</li><li>sessionStatus：SessionAttribute 使用完成的标识。</li><li>requestHandled：请求处理完成的标识（例如添加了 <code>@ResponseBody</code> 注解的接口，这个属性为 true，请求就不会再去找视图了）。</li></ul><blockquote><p>这个 ModelAndViewContainer 小伙伴们权且做一个了解，松哥在后面的源码分析中，还会和大家再次聊到这个组件。</p></blockquote><p>接下来我们也来自定义一个 HandlerMethodReturnValueHandler，来感受一下 HandlerMethodReturnValueHandler 的基本用法。</p><h2 id="3-API-接口数据包装"><a href="#3-API-接口数据包装" class="headerlink" title="3.API 接口数据包装"></a>3.API 接口数据包装</h2><p>假设我有这样一个需求：我想在原始的返回数据外面再包裹一层，举个简单例子，本来接口是下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setAddress(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的数据格式是下面这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="hljs-attr">"username"</span>:<span class="hljs-string">"javaboy"</span>,<span class="hljs-attr">"address"</span>:<span class="hljs-string">"www.javaboy.org"</span>&#125;</span><br></pre></td></tr></table></figure><p>现在我希望返回的数据格式变成下面这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="hljs-attr">"status"</span>:<span class="hljs-string">"ok"</span>,<span class="hljs-attr">"data"</span>:&#123;<span class="hljs-attr">"username"</span>:<span class="hljs-string">"javaboy"</span>,<span class="hljs-attr">"address"</span>:<span class="hljs-string">"www.javaboy.org"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>就这样一个简单需求，我们一起来看下怎么实现。</p><h3 id="3-1-RequestResponseBodyMethodProcessor"><a href="#3-1-RequestResponseBodyMethodProcessor" class="headerlink" title="3.1 RequestResponseBodyMethodProcessor"></a>3.1 RequestResponseBodyMethodProcessor</h3><p>在开始定义之前，先给大家介绍一下 RequestResponseBodyMethodProcessor，这是 HandlerMethodReturnValueHandler 的实现类之一，这个主要用来处理返回 JSON 的情况。</p><p>我们来稍微看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||</span><br><span class="line">returnType.hasMethodAnnotation(ResponseBody.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);</span><br><span class="line">ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line">writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>supportsReturnType：从这个方法中可以看到，这里支持有 <code>@ResponseBody</code> 注解的接口。</li><li>handleReturnValue：这是具体的处理逻辑，首先 mavContainer 中设置 requestHandled 属性为 true，表示这里处理完成后就完了，以后不用再去找视图了，然后分别获取 inputMessage 和 outputMessage，调用 writeWithMessageConverters 方法进行输出，writeWithMessageConverters 方法是在父类中定义的方法，这个方法比较长，核心逻辑就是调用确定输出数据、确定 MediaType，然后通过 HttpMessageConverter 将 JSON 数据写出去即可。</li></ul><p>有了上面的知识储备之后，接下来我们就可以自己实现了。</p><h3 id="3-2-具体实现"><a href="#3-2-具体实现" class="headerlink" title="3.2 具体实现"></a>3.2 具体实现</h3><p>首先自定义一个 HandlerMethodReturnValueHandler：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlerMethodReturnValueHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> HandlerMethodReturnValueHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHandlerMethodReturnValueHandler</span><span class="hljs-params">(HandlerMethodReturnValueHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> handler.supportsReturnType(returnType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="hljs-string">"status"</span>, <span class="hljs-string">"ok"</span>);</span><br><span class="line">        map.put(<span class="hljs-string">"data"</span>, returnValue);</span><br><span class="line">        handler.handleReturnValue(map, returnType, mavContainer, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们要做的功能其实是在 RequestResponseBodyMethodProcessor 基础之上实现的，因为支持 <code>@ResponseBody</code>，输出 JSON 那些东西都不变，我们只是在输出之前修改一下数据而已。所以我这里直接定义了一个属性 HandlerMethodReturnValueHandler，这个属性的实例就是 RequestResponseBodyMethodProcessor，supportsReturnType 方法就按照 RequestResponseBodyMethodProcessor 的要求来，在 handleReturnValue 方法中，我们先对返回值进行一个预处理，然后调用 RequestResponseBodyMethodProcessor#handleReturnValue 方法继续输出 JSON 即可。</p><p>接下来就是配置 MyHandlerMethodReturnValueHandler 使之生效了。由于 SpringMVC 中 HandlerAdapter 在加载的时候已经配置了 HandlerMethodReturnValueHandler（这块松哥以后会和大家分析相关源码），所以我们可以通过如下方式对已经配置好的 RequestMappingHandlerAdapter 进行修改，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReturnValueConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RequestMappingHandlerAdapter requestMappingHandlerAdapter;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; originHandlers = requestMappingHandlerAdapter.getReturnValueHandlers();</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; newHandlers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(originHandlers.size());</span><br><span class="line">        <span class="hljs-keyword">for</span> (HandlerMethodReturnValueHandler originHandler : originHandlers) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (originHandler <span class="hljs-keyword">instanceof</span> RequestResponseBodyMethodProcessor) &#123;</span><br><span class="line">                newHandlers.add(<span class="hljs-keyword">new</span> MyHandlerMethodReturnValueHandler(originHandler));</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                newHandlers.add(originHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        requestMappingHandlerAdapter.setReturnValueHandlers(newHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 ReturnValueConfig 实现 InitializingBean 接口，afterPropertiesSet 方法会被自动调用，在该方法中，我们将 RequestMappingHandlerAdapter 中已经配置好的 HandlerMethodReturnValueHandler 拎出来挨个检查，如果类型是 RequestResponseBodyMethodProcessor，则重新构建，用我们自定义的 MyHandlerMethodReturnValueHandler 代替它，最后给 requestMappingHandlerAdapter 重新设置 HandlerMethodReturnValueHandler 即可。</p><p>最后再提供一个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setAddress(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-comment">//省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，就可以启动项目啦。</p><p>项目启动成功后，访问 <code>/user</code> 接口，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210317203148.png" alt></p><p>完美。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>其实统一 API 接口响应格式办法很多，可以参考松哥之前分享的 <a href="https://mp.weixin.qq.com/s/LWuUNHJVnBLK15Msu38Wgw" target="_blank" rel="noopener">如何优雅的实现 Spring Boot 接口参数加密解密？</a>，也可以使用本文中的方案，甚至也可以自定义过滤器实现。</p><p>本文的内容稍微有点多，不知道大家有没有发现松哥最近发了很多 SpringMVC 源码相关的东西，没错，本文其实是松哥 SpringMVC 源码解析的一部分，为了源码解析不那么枯燥，所以强行加了一个案例进来，祝小伙伴们学习愉快～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天又要给大家介绍一个 Spring Boot 中的组件–HandlerMethodReturnValueHandler。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
</feed>
