<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="http://www.javaboy.org/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2024-12-18T13:00:37.604Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这款老牌 MySQL 客户端可以免费用了！</title>
    <link href="http://www.javaboy.org/2024/0627/mysql-navicat.html"/>
    <id>http://www.javaboy.org/2024/0627/mysql-navicat.html</id>
    <published>2024-06-27T12:28:13.000Z</published>
    <updated>2024-12-18T13:00:37.604Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.itboyhub.com/2024/mp/20240627173641.png"></p><p>小伙伴们平时用哪个 MySQL 客户端？</p><span id="more"></span><p>松哥之前接触过的数据库客户端工具主要是 SQLYog、DataGrip、Navicat 以及 Sequel Pro。</p><p>从使用体验上来说：</p><ul><li><p><strong>SQLYog</strong>：最主要就是简洁高效的界面和丰富的功能，特别适合 MySQL 数据库的管理和开发。它提供了直观的图形界面，支持快速网络维护远端数据库，一般我在 Win 上用的就是这个。</p></li><li><p><strong>DataGrip</strong> 作为 JetBrains 家族的一员，DataGrip 以其智能代码补全、强大的导航功能和全面的数据库支持著称，为用户提供流畅的 SQL 编写体验。它的用户界面友好且高度可定制，适合需要处理多种数据库类型的高级开发者，对于 IDEA 重度用户来说，用 DataGrip 也不错，我认识一些小伙伴特别喜欢 DataGrip。</p></li><li><p><strong>Navicat</strong>：提供了跨平台的数据库管理解决方案，拥有丰富的图形界面和一系列高级功能，如数据同步、结构同步、备份恢复等。Navicat 的界面设计现代化，操作直观，适合各类技术水平的用户。</p></li><li><p><strong>Sequel Pro</strong>：专为 MacOS 设计，界面简洁明快，这是一个开源的工具，当然它的功能也比较简陋。</p></li></ul><p>这些工具除了最后一个是开源的，其他都要付费使用。松哥自己在这些工具里边比较偏爱 Navicat，因为它的功能最牛。但是因为这个是收费的，而且价格不菲，关键是数据库又是比较重要的设施，一般又不太愿意用破解的客户端工具，所以有时候我宁愿选择一些开源的工具比如在 Mac 上我常用的是 Sequel Pro 这个工具，这个工具虽然能用，但是功能就少了很多了，不是特别方便。</p><p>不过最近看到了一则好消息：</p><p><img src="http://img.itboyhub.com/2024/mp/20240627174303.png"></p><p>就是 Navicat 推出了 Navicat Premium Lite，从名字就可以看出来这是 Navicat 的精简版，虽然精简，但是也拥有基本数据库操作所需的核心功能。允许你从单个应用程序同时连接到各种数据库平台，包括 MySQL、Redis、PostgreSQL、SQL Server、Oracle、MariaDB、SQLite 和 MongoDB。Navicat Premium Lite 提供简化的数据库管理体验，使其成为用户的实用选择。</p><p>也就是 Navicat Premium Lite 虽然没有 Navicat Premium 功能那么丰富，但是对我们日常开发来说也够用了。官方通过一个列表详细介绍了 Lite 版本和 Premium 版本的差别。</p><p><img src="http://img.itboyhub.com/2024/mp/20240627175017.png"></p><p>在常规功能上基本上是没有差别的。差别主要是在数据模型、BI、数据导入导出格式上有一些差别，具体小伙伴们可以通过如下链接来查看：</p><p><a href="https://www.navicat.com.cn/products/navicat-premium-feature-matrix">https://www.navicat.com.cn/products/navicat-premium-feature-matrix</a></p><p>松哥已经安装体验上了：</p><p><img src="http://img.itboyhub.com/2024/mp/20240627180138.png"></p><p>感兴趣的小伙伴快去下载体验吧～</p><p><a href="https://www.navicat.com.cn/download/navicat-premium-lite">https://www.navicat.com.cn/download/navicat-premium-lite</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://img.itboyhub.com/2024/mp/20240627173641.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;小伙伴们平时用哪个 MySQL 客户端？&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>管理员如何踢掉登录用户？</title>
    <link href="http://www.javaboy.org/2024/0617/spring-security-logout.html"/>
    <id>http://www.javaboy.org/2024/0617/spring-security-logout.html</id>
    <published>2024-06-17T12:27:45.000Z</published>
    <updated>2024-12-18T13:00:41.935Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Spring Security 学习小组有小伙伴提的一个问题：</p><span id="more"></span><p><img src="http://img.itboyhub.com/2024/04/20240617103103.png"></p><p>感觉这个问题还有点意思，拿出来和各位小伙伴一起分享下。</p><h1 id="一-问题分析"><a href="#一-问题分析" class="headerlink" title="一 问题分析"></a>一 问题分析</h1><p>首先大家注意限制条件：<strong>常规 Session 方案</strong>。</p><p>如果不是这几个字，这个问题根本就不是问题，如果是 JWT+Redis 这种方案，这个问题很好解决，自己随随便便几段逻辑处理就行了。问题是<strong>常规 Session 方案</strong>，也就是 Spring Security 默认的方案，Spring Security 默认情况下，登录用户信息保存在 HttpSession 中，HttpSession 不同用户又是不一样的 HttpSession，相当于你在一个 HttpSession 对象中要使另外一个 HttpSession 对象失效，这是这个小伙伴困惑的地方。</p><h1 id="二-解决思路"><a href="#二-解决思路" class="headerlink" title="二 解决思路"></a>二 解决思路</h1><p>Spring Security 中提供了一个会话并发管理的功能，就是可以设置同一个用户并发登录的数量，比如 javaboy 的并发登录数量为 1，那么 javaboy 就只能在一台设备上登录，在在其他设备登录就会被拒绝，或者其他设备登录会自动踢掉当前登录。</p><p>这一功能实现的原理是 Spring Security 中用了一个会话注册器 SessionRegistry 去统一管理登录用户的会话，当用户登录成功之后，讲用户信息保存在一个类型为 <code>ConcurrentMap&lt;Object, Set&lt;String&gt;&gt; principals</code> 的 Map 中，这里的 key 就是登录的用户对象，value 就是登录用户的 sessionId，当然如果想获取到登录用户会话更为详细的信息，还有一个类型为 <code>Map&lt;String, SessionInformation&gt; sessionIds</code> 的 Map，这个 Map 的 key 则是 sessionId。通过对这两个 Map 中的数据进行管理，就能实现对用户并发登录的控制。</p><p>相同的道理，我这里也想借鉴已有的功能，在这个功能的基础上，实现管理员踢出已登录用户，这样就会方便很多。</p><p>管理员踢出用户的时候，只需要遍历 principals 集合，根据用户名找出来这个用户登录的 sessionId，然后再根据 sessionId 去 sessionIds 里找到会话对应的 SessionInformation，然后令这些会话失效即可。</p><h1 id="三-参考代码"><a href="#三-参考代码" class="headerlink" title="三 参考代码"></a>三 参考代码</h1><p>首先需要我们自己提供 SessionRegistry 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    SessionRegistry <span class="title function_">sessionRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SessionRegistryImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    UserDetailsService <span class="title function_">us</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="string">&quot;zhangsan&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;ADMIN&quot;</span>).build());</span><br><span class="line">        manager.createUser(User.withUsername(<span class="string">&quot;lisi&quot;</span>).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).roles(<span class="string">&quot;ADMIN&quot;</span>).build());</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.authorizeHttpRequests(a -&gt; a.anyRequest().authenticated())</span><br><span class="line">                .formLogin(Customizer.withDefaults())</span><br><span class="line">                .csrf(c -&gt; c.disable())</span><br><span class="line">                .sessionManagement(s -&gt; s.maximumSessions(Integer.MAX_VALUE).sessionRegistry(sessionRegistry()));</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    HttpSessionEventPublisher <span class="title function_">sessionEventPublisher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpSessionEventPublisher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置 SecurityFilterChain 的时候，传入自己配置的 sessionRegistry。</p><p>这里有一个需要注意的点，就是要开启会话并发管理，只有开启了会话并发管理，第二小节我们说的那些思路才是有效的，否则这些思路不会生效。那么怎么开启会话并发管理呢？设置会话的最大并发数即可，如果你本身并不想限制，那么这个并发数可以设置为 <code>Integer.MAX_VALUE</code>。</p><p>这里涉及到的其他内容我就不多说了，都是课程中讲的关于会话并发管理的内容。</p><p>最后，踢出用户的逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogoutService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SessionRegistry sessionRegistry;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; principals = sessionRegistry.getAllPrincipals();</span><br><span class="line">        <span class="keyword">for</span> (Object principal : principals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (principal <span class="keyword">instanceof</span> User u) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> u.getUsername();</span><br><span class="line">                <span class="keyword">if</span> (name.equals(username)) &#123;</span><br><span class="line">                    List&lt;SessionInformation&gt; allSessions = sessionRegistry.getAllSessions(u, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">for</span> (SessionInformation session : allSessions) &#123;</span><br><span class="line">                        session.expireNow();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 username 就是管理员要踢出去的用户名。</p><p><code>sessionRegistry.getAllPrincipals();</code> 是获取到所有的登录用户信息，然后遍历，根据用户名找到要踢出去的用户，然后调用 <code>sessionRegistry.getAllSessions</code> 方法获取该用户的所有会话信息，遍历这些会话，挨个调用其 expireNow() 方法，使之失效。</p><p>这样，当用户被踢下线的感觉就像是会话并发控制的时候，被其他客户端挤下线的感觉。</p><p>当然，也可以给用户一个明确提示，类似下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.sessionManagement(s -&gt; s.maximumSessions(Integer.MAX_VALUE).sessionRegistry(sessionRegistry()).expiredSessionStrategy(event -&gt; &#123;</span><br><span class="line">    <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> event.getResponse();</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">    response.getWriter()</span><br><span class="line">            .print(<span class="string">&quot;你被管理员踢下线了&quot;</span>);</span><br><span class="line">    response.flushBuffer();</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>OK，大功告成。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是 Spring Security 学习小组有小伙伴提的一个问题：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>面试为什么老爱问 Redis？</title>
    <link href="http://www.javaboy.org/2024/0616/redis-video.html"/>
    <id>http://www.javaboy.org/2024/0616/redis-video.html</id>
    <published>2024-06-16T12:27:34.000Z</published>
    <updated>2024-12-18T13:00:07.110Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 在 Java 面试中应该算是出镜率比较高的知识点了。为什么 Java 面试中 Redis 出镜率这么高呢？</p><span id="more"></span><p>松哥想了想，可能主要有下面一些原因。</p><h1 id="一-考察候选人性能优化意识"><a href="#一-考察候选人性能优化意识" class="headerlink" title="一 考察候选人性能优化意识"></a>一 考察候选人性能优化意识</h1><p>Redis 的高效性是其一大优势，但正确配置和使用是关键。面试官可能询问如何通过调整配置参数、合理设计数据模型、选择正确的数据淘汰策略等方法来优化 Redis 性能。这不仅能提高系统的响应速度，还能有效利用资源，展现候选人的性能优化思维和实践经验。</p><p>很多小伙伴在写简历的时候，为了突出项目的亮点难点，一般都会扯上 Redis，这个思路是对的，因为一旦扯上了 Redis，你能够在面试官面前秀一把的空间就很大（当然前提是你对 Redis 足够了解）。</p><h1 id="二-评估候选人问题解决能力"><a href="#二-评估候选人问题解决能力" class="headerlink" title="二 评估候选人问题解决能力"></a>二 评估候选人问题解决能力</h1><p>通过提出关于 Redis 故障恢复、性能瓶颈分析、数据丢失预防等实际问题，面试官可以考察候选人在面对复杂问题时的分析能力和解决方案设计能力。例如，如何在保证数据一致性的前提下实现 Redis 的高可用性，就是一个考验综合能力的问题。</p><h1 id="三-检验实际工作经验"><a href="#三-检验实际工作经验" class="headerlink" title="三 检验实际工作经验"></a>三 检验实际工作经验</h1><p>询问候选人关于 Redis 部署、监控、调优的实际操作经验，可以评估他们是否真正参与过生产环境下的 Redis 管理，挤出简历中的水分。比如，如何设置合理的键过期策略以避免内存溢出，或者如何配置哨兵以自动处理主节点故障，这些都是实操中常见的挑战。</p><h1 id="四-考察候选人的技术广度与深度"><a href="#四-考察候选人的技术广度与深度" class="headerlink" title="四 考察候选人的技术广度与深度"></a>四 考察候选人的技术广度与深度</h1><ul><li><strong>技术广度</strong>：了解候选人是否熟悉数据库领域不仅仅是关系型数据库（如 MySQL），还包括 NoSQL 数据库如 Redis，这反映了他们对不同数据存储解决方案的全面认识。</li><li><strong>技术深度</strong>：深入探讨 Redis 的数据结构（如字符串、哈希、列表、集合、有序集合）及其适用场景，可以帮助面试官评估候选人是否能根据具体需求选择最合适的 Redis 功能。</li></ul><h1 id="五-技术趋势的跟随"><a href="#五-技术趋势的跟随" class="headerlink" title="五 技术趋势的跟随"></a>五 技术趋势的跟随</h1><p>随着 Redis 版本的迭代，新特性的引入（如多线程 I&#x2F;O、模块系统等）为开发者提供了更多可能性。面试中讨论这些新特性，可以看出候选人是否保持对技术发展的关注，以及他们对新技术接纳和学习的态度。</p><p>其实就是 Redis 可玩性非常强，能解决的问题多种多样，擅长的领域也多种多样，想问，就能问很多相关的问题。</p><p>松哥最近抽空剪了一套 Redis 视频，是我五月份刚刚录的，先来给大伙看看目录：</p><p><img src="http://img.itboyhub.com/2024/04/%E9%95%BF%E5%9B%BE_2_redis_content.png"></p><p>视频总共是 166 集大约 22.7 个小时左右。从 Redis 的基本用法到高级用法，Redis 实现各种分布式锁以及相关的原理、Redis 限流、持久化、事务、集群、常见使用场景等等都有非常详细的介绍，最后还整理了 28 道常见面试题供小伙伴们学习。视频教程有完整的代码案例和笔记，并且有微信答疑群～</p><p>当然，视频课程是付费的，¥499，老用户有 ¥30 优惠哦，老用户可以私我领取优惠券。</p><p>下单的小伙伴记得私我加 Redis 答疑群哦（备注 Redis）～</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis 在 Java 面试中应该算是出镜率比较高的知识点了。为什么 Java 面试中 Redis 出镜率这么高呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java 猿的 Python 奇遇</title>
    <link href="http://www.javaboy.org/2024/0613/java-python.html"/>
    <id>http://www.javaboy.org/2024/0613/java-python.html</id>
    <published>2024-06-13T12:27:21.000Z</published>
    <updated>2024-12-18T13:02:19.019Z</updated>
    
    <content type="html"><![CDATA[<p>最近手头上有两个小需求，手动处理太麻烦了，想写段代码快速处理下，用 Java 处理，需要一些第三方 jar，但是因为比较冷门，这些 jar 早在 2008 年左右就停更了。</p><span id="more"></span><p>在查找资料的过程中，发现 Python 这块相关的内容比较多，于是找了段 Python 脚本，自己又修修补补搞了下，嘿，成了！</p><p>想起来一两年前网络上铺天盖地的 Python 办公自动化培训，当时不理解，现在总算理解了，Python 在办公自动化这块确实比较强，不愧于瑞士军刀的称号。</p><p>我们自己平时工作的时候多多少少都会遇到一些比较繁琐的文档要处理，我之前遇到了基本上都是自己用 Java 处理，Java 虽然并不擅长处理文档这个事情，但是因为咱是 Java 猿，用 Java 处理起来顺手，而且也不需要查找资料，代码啪啪啪狂敲，很快就能搞定。</p><p>这次踢到石头上了主要是因为需求太冷门了，Java 也有点吃不消，当然，也是因为时间仓促，如果时间充足，我自己慢慢在那重新码个工具出来也不是不行。但是话说回来，每种语言都有自己擅长的领域，Java 的看家本领是企业级应用开发以及相对完善的生态。所以我也就没必要用蛮力了，选择最佳解决方案，趁机再理解一波 Python，也不是个坏事。</p><p>这件事让我又一次感受到了作为软件工程师，不能够拘泥于语言，拉这个语言踩那个语言有点过于幼稚。术业有专攻，每种语言有自己擅长的领域和不擅长的领域，选择合适的语言做合适的事情，技术毕竟是为人服务的，我们用 Java 开发系统是为了简化别人的工作，现在用 Python 也是简化我们自己的工作。</p><p>发了个朋友圈，有小伙伴说松哥要不要整个 Python 课？哈哈，感觉没必要了～你把 Java 搞通了，有一门自己比较擅长的语言之后，其他的开发语言上手相对会容易很多。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近手头上有两个小需求，手动处理太麻烦了，想写段代码快速处理下，用 Java 处理，需要一些第三方 jar，但是因为比较冷门，这些 jar 早在 2008 年左右就停更了。&lt;/p&gt;</summary>
    
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>事务中存在多线程，怎么处理？</title>
    <link href="http://www.javaboy.org/2024/0612/spring-transaction.html"/>
    <id>http://www.javaboy.org/2024/0612/spring-transaction.html</id>
    <published>2024-06-12T12:26:49.000Z</published>
    <updated>2024-12-18T13:02:22.736Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring 框架中，<code>@Transactional</code> 注解作为一种声明式事务管理的关键机制，其背后的工作原理远比简单的 <code>AOP</code>（面向切面编程）和 <code>ThreadLocal</code> 存储更为细腻。该注解的实现核心在于 <code>Spring</code> 的 <code>TransactionInterceptor</code>（事务拦截器）以及它如何与 <code>Spring</code> 的代理机制、<code>TransactionManager</code>（事务管理器）协同工作，来确保事务的开启、提交或回滚等操作得以正确执行。</p><span id="more"></span><h1 id="一-注解解析与代理生成"><a href="#一-注解解析与代理生成" class="headerlink" title="一 注解解析与代理生成"></a>一 注解解析与代理生成</h1><p>当 Spring 容器初始化时，会通过 AnnotationTransactionAttributeSource 扫描并识别出所有标有 @Transactional 的方法。这些方法在被调用前，Spring 会根据配置（如基于接口或类的代理）为它们创建动态代理对象。如果是基于接口的代理，则使用 JDK Dynamic Proxy；如果是基于类的，则采用 CGLIB。这个代理对象会在目标方法调用前后插入事务处理逻辑。</p><h2 id="1-1-Spring-Bean的后处理器"><a href="#1-1-Spring-Bean的后处理器" class="headerlink" title="1.1 Spring Bean的后处理器"></a>1.1 Spring Bean的后处理器</h2><p>一切始于 Spring 容器的 Bean 创建和初始化过程。Spring 通过一系列的 BeanPostProcessor 接口实现类来增强 Bean 的功能，其中与事务管理密切相关的便是 <code>AbstractAutoProxyCreator</code>的子类，如 <code>AnnotationAwareAspectJAutoProxyCreator</code>。这个类负责扫描并创建代理对象，以便于在运行时织入诸如事务管理这样的切面逻辑。</p><h2 id="1-2-识别-Transactional-注解"><a href="#1-2-识别-Transactional-注解" class="headerlink" title="1.2 识别 @Transactional 注解"></a>1.2 识别 @Transactional 注解</h2><ul><li><strong>ClassPathScanningCandidateComponentProvider</strong>：Spring 首先会使用此类扫描指定包路径下带有特定注解（如<code>@Transactional</code>）的类或方法。</li><li><strong>AnnotationTransactionAttributeSource</strong>：一旦找到带有 <code>@Transactional</code> 注解的类或方法，Spring 会使用 <code>AnnotationTransactionAttributeSource</code> 来解析这些注解，将其转换为事务属性（TransactionAttribute），比如事务的隔离级别、传播行为、超时时间等。</li></ul><h2 id="1-3-创建代理对象"><a href="#1-3-创建代理对象" class="headerlink" title="1.3 创建代理对象"></a>1.3 创建代理对象</h2><ul><li>对于基于接口的代理，Spring 使用 JDK 的动态代理技术，通过<code>JdkDynamicAopProxy</code>创建代理对象。该代理会检查调用链，并在调用目标方法前插入事务管理的前置逻辑，调用后插入后置逻辑（如提交或回滚事务）。</li><li>对于没有实现接口的类，Spring 则利用 CGLIB 库生成目标类的子类作为代理，通过<code>CglibAopProxy</code> 来完成。CGLIB 代理同样能够在目标方法调用的前后插入事务管理代码。</li></ul><h2 id="1-4-TransactionInterceptor"><a href="#1-4-TransactionInterceptor" class="headerlink" title="1.4 TransactionInterceptor"></a>1.4 TransactionInterceptor</h2><ul><li>在代理对象中，事务管理的具体逻辑是由 <code>TransactionInterceptor</code>（事务拦截器）来执行的。它实现了 <code>MethodInterceptor</code> 接口，因此当代理对象的方法被调用时，会进入<code>invoke(MethodInvocation invocation)</code> 方法。在这个方法内，<code>TransactionInterceptor</code> 根据解析出的事务属性来决定是否开启事务、使用何种传播行为，并最终调用目标方法。</li></ul><p>总结下就是，Spring 通过 Bean 的后置处理器在容器初始化阶段自动检测带有 <code>@Transactional</code> 注解的类和方法，并通过动态代理机制为这些组件创建代理对象。代理对象在方法调用时，通过 <code>TransactionInterceptor</code> 这一核心组件，根据注解配置的事务属性来管理事务生命周期，确保事务逻辑的无缝集成。</p><h1 id="二-事务拦截与执行"><a href="#二-事务拦截与执行" class="headerlink" title="二 事务拦截与执行"></a>二 事务拦截与执行</h1><h2 id="2-1-TransactionInterceptor-的作用"><a href="#2-1-TransactionInterceptor-的作用" class="headerlink" title="2.1 TransactionInterceptor 的作用"></a>2.1 TransactionInterceptor 的作用</h2><p><code>TransactionInterceptor</code> 实现了 Spring 的 <code>MethodInterceptor</code> 接口，这意味着它能够拦截方法调用，并在调用前后执行额外的逻辑，即事务管理逻辑。其核心职责包括：</p><ul><li><strong>识别是否需要事务</strong>: 根据目标方法上的 <code>@Transactional</code> 注解（如果有的话）及其属性（如传播行为、隔离级别、超时时间等），决定是否需要启动一个新的事务或加入到现有的事务中。需要注意的是，事务上下文（包括连接信息等）被存储在由 Spring 管理的一个特定的 TransactionSynchronizationManager 中，TransactionSynchronizationManager 内部使用了 ThreadLocal。</li><li><strong>事务管理</strong>: 在方法调用之前开启事务，调用之后根据方法执行结果提交或回滚事务。这包括异常处理逻辑，即在遇到未被捕获的异常时，确保事务被正确回滚。</li></ul><h2 id="2-2-拦截与执行流程"><a href="#2-2-拦截与执行流程" class="headerlink" title="2.2 拦截与执行流程"></a>2.2 拦截与执行流程</h2><ol><li><p><strong>方法调用前</strong>:</p><ul><li><strong>事务属性解析</strong>: <code>TransactionInterceptor</code> 首先通过<code>TransactionAttributeSource</code>（通常是<code>AnnotationTransactionAttributeSource</code>）获取目标方法的事务属性。</li><li><strong>事务开始</strong>: 根据解析出的事务属性，决定是否创建新的事务或者加入到当前事务中。如果需要新事务，它会通过事务管理器（如 <code>PlatformTransactionManager</code> 的实现类）来开始事务。</li></ul></li><li><p><strong>方法执行</strong>:</p><ul><li>在事务上下文中执行实际的目标方法。此时，如果目标方法内部抛出了异常，这个异常会被暂存以供后续处理。</li></ul></li><li><p><strong>方法调用后</strong>:</p><ul><li><strong>异常处理</strong>: 如果方法执行过程中抛出了异常，<code>TransactionInterceptor</code> 会捕获到这个异常，并根据异常类型及事务属性决定是否需要回滚事务。通常，非检查型异常（继承自 <code>RuntimeException</code> 的异常）会导致事务回滚，而检查型异常则不会，除非事务属性特别指定了回滚规则。</li><li><strong>事务提交或回滚</strong>: 如果方法正常结束，或者按事务属性应该提交事务的情况下，事务管理器会提交事务。相反，如果需要回滚，则执行回滚操作。</li></ul></li><li><p><strong>资源清理</strong>: 在事务结束后，确保所有资源被正确释放，比如关闭数据库连接等。</p></li></ol><h2 id="2-3-动态代理的作用"><a href="#2-3-动态代理的作用" class="headerlink" title="2.3 动态代理的作用"></a>2.3 动态代理的作用</h2><p>整个过程中，动态代理扮演着关键角色。无论是 JDK 动态代理还是 CGLIB 代理，它们都是在调用真正业务方法之前插入事务拦截逻辑的桥梁。当客户端代码调用代理对象上的方法时，实际上是调用了由 <code>TransactionInterceptor</code> 所控制的代理逻辑，从而透明地在业务逻辑执行前后管理事务。</p><p>通过这种方式，开发者无需在每个需要事务管理的方法中手动编写开启、提交或回滚事务的代码，极大地简化了开发复杂度，提高了代码的可维护性和可读性。</p><h1 id="三-多线程环境下的挑战"><a href="#三-多线程环境下的挑战" class="headerlink" title="三 多线程环境下的挑战"></a>三 多线程环境下的挑战</h1><p>当 @Transactional 标记的方法内部启动新的线程时，问题就显现了。前面提到，事务拦截使用了 TransactionInterceptor，而 TransactionInterceptor 内部用到了  TransactionSynchronizationManager，TransactionSynchronizationManager 使用 ThreadLocal 来存储事务相关的资源信息，如数据库连接、JMS 会话等。这意味着每个线程都有其独立的事务上下文，确保了事务信息在线程间的隔离。</p><p>换句话说，Spring 管理的事务上下文是基于调用线程的，新线程并没有继承原线程的 TransactionSynchronizationManager 中的事务上下文。因此，新线程执行的数据库操作实际上是在无事务管理的环境下进行的，这就导致事务失效。</p><p>那如果非要用多线程怎么办呢？这个时候可以使用编程式事务，首先设置一个全局变量 Boolean，默认是可以提交的 true，在子线程，通过编程式事务的方式去开启事务，然后插入数据，插入完成后，事务先不提交，同时通知主线程，我准备好了，进入等待状态。如果子线程出现异常，那就通知主线程，我这边发生异常，然后自己回滚。</p><p>最后主线程收集各个子线程的状态，如果有一个线程出现问题，那么全局变量就设置为不可提交false，然后唤醒所有子线程，进行回滚。</p><p>这里涉及到线程同步可以利用闭锁去实现；当主线程通知各个子线程提交事务的时候，子线程可能在提交的时候出错了，最终导致数据不一致，那么这种时候可能就需要引入重试机制，有了重试机制后，又要去保证幂等性等等。</p><p>这一套方案下来大伙有没有觉得眼熟，是不是就是分布式事务的处理思路了？</p><p>所以说，非要在事务中开启多线程也没问题，但是不建议这么做。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Spring 框架中，&lt;code&gt;@Transactional&lt;/code&gt; 注解作为一种声明式事务管理的关键机制，其背后的工作原理远比简单的 &lt;code&gt;AOP&lt;/code&gt;（面向切面编程）和 &lt;code&gt;ThreadLocal&lt;/code&gt; 存储更为细腻。该注解的实现核心在于 &lt;code&gt;Spring&lt;/code&gt; 的 &lt;code&gt;TransactionInterceptor&lt;/code&gt;（事务拦截器）以及它如何与 &lt;code&gt;Spring&lt;/code&gt; 的代理机制、&lt;code&gt;TransactionManager&lt;/code&gt;（事务管理器）协同工作，来确保事务的开启、提交或回滚等操作得以正确执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>杏儿熟了</title>
    <link href="http://www.javaboy.org/2024/0611/fruit.html"/>
    <id>http://www.javaboy.org/2024/0611/fruit.html</id>
    <published>2024-06-11T12:26:32.000Z</published>
    <updated>2024-12-18T13:02:16.855Z</updated>
    
    <content type="html"><![CDATA[<p>又到了杏子成熟的季节了，老爸从老家寄了杏子到深圳，好多年不吃，偶尔吃一次，感觉味道还挺不错的。</p><span id="more"></span><p><img src="http://img.itboyhub.com/2024/04/20240611083424.png"></p><p>杏子在老家有很多不同的品种，味道也会有差异，这种个头比较大，里边核是甜的我们叫做大银杏或者银杏。不过，出门在外，一提“大银杏”，大伙可能立刻想到的是那种古老、庄严、国家一级保护野生植物的银杏树，而不是我手里这个果子，所以还是说杏子吧。</p><p>小时候学过一篇和杏子有关的课文，不知道小伙伴们还记得否：</p><p><img src="http://img.itboyhub.com/2024/04/20240611085224.png"></p><p>小时候杏子还没熟，酸溜溜的时候，就迫不及待地开始尝鲜，一直吃到果期结束。杏子成熟的季节，平时就挂在杏树上。导致从小就把杏子吃腻了，后来离开家出去上学，也就很少吃了，虽然很少吃也但是不怎么想念，每年 6 月份在超市里看到，也总是诧异于它在大城市的价格，至于味蕾则毫无波澜。</p><p>老家几种产量比较大的果子果期都比较短，也不适合长途运输，比较有代表性的就是杏子和柿子。</p><p>杏子果期很短，大概就一周左右时间，熟了不摘就掉地上了，妥妥的”速食主义者”，农民把果树辛苦维护一年，赚不了几个钱。</p><p>柿子老家也有大量种植，但是柿子成熟的时候，在当地很便宜，便宜到摘下来拿去卖都不划算，所以有的人就宁愿柿子烂在树上，或者柿子硬的时候，就提前摘下来，利用一些土办法去除涩味，然后拿去卖。等到柿子真正成熟的时候再拿去卖就卖不上价钱了。</p><p>在城市里我们吃到的柿子大部分是硬的时候摘下来然后放软的，这种柿子不仅价格贵，而且味道和树上长软的柿子不可同日而语。树上长软的柿子红彤彤的，吃的时候，从尖尖撕一个小口子，用嘴巴一吸，果肉进到嘴里，手上就只剩薄薄一层皮了。</p><p>物离乡贵人离乡贱，亘古不变的道理呀～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;又到了杏子成熟的季节了，老爸从老家寄了杏子到深圳，好多年不吃，偶尔吃一次，感觉味道还挺不错的。&lt;/p&gt;</summary>
    
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>又一个小伙伴在深圳上车安家～</title>
    <link href="http://www.javaboy.org/2024/0609/buy-house.html"/>
    <id>http://www.javaboy.org/2024/0609/buy-house.html</id>
    <published>2024-06-09T12:25:58.000Z</published>
    <updated>2024-12-18T13:02:14.030Z</updated>
    
    <content type="html"><![CDATA[<p>又有同学在深圳买房上车了，招呼在深圳的大学同学聚餐，现在这个时间点买房的我愿称之为爱国勇士！</p><span id="more"></span><p>他主要是小孩马上到了上学的年纪，考虑到孩子上学，所以今年四月份开始在深圳看房，很快就在罗湖锁定了一套二手房，没怎么犹豫就成交了。</p><p>我之前没太了解过，原来在罗湖总价 200+ 就能上车一套二手住宅，户型小一些，但是对于一个三口之家显然也够用了。我们去玩，他这个房龄也不算老，有超大窗户，采光特别好。并且因为罗湖是比较成熟的城区，各项配套设施都非常完善。我们吃完饭出去走走，小区门口就有一个小山包，基本上五分钟左右就能到公园，公园里小孩哥在钓鱼 PK，好不热闹。</p><p><img src="http://img.itboyhub.com/2024/04/20240608222651.png"></p><p>周边有学校医院一应俱全，老城区超大的榕树真的非常有 feel，它的枝叶茂盛，犹如一把巨大的绿伞，为过往的行人提供了一片凉爽的树荫。阳光透过密密麻麻的树叶，洒下斑驳的光影，随着微风轻轻摇曳，为这炎热的夏日带来了一丝清凉。走在这样的人行道上，时间彷佛慢了，人们的心情也变得轻松愉悦了许多，甚至忘了深圳是一座打工之城了。</p><p>我们都是 2015 年大学毕业之后出来工作，我先去了广州，兜兜转转在 2017 年初来到深圳。而小伙伴则自始至终坚守在深圳，这座充满活力的城市。他在一家游戏公司担任研发工作，干了快十年，与公司共同成长，共同经历风雨。2019 年公司上市，他分得一些期权。</p><p>工作这些年，我发现自己对那些能在一家公司扎根如老树般不动的程序员们，简直是佩服得五体投地。因为据我观察，公司一线的销售人员其实流动很大，但是销售部门的领导基本上不怎么动，那些领导不怎么跳槽，大部分程序员的离职率一般介于这两者之间。</p><p>话说回来，能在一家公司坚持这么久，这不仅仅是性格使然，更可能是公司文化的魅力所在。毕竟，一个好的工作环境，就像是一块肥沃的土壤，能让程序员们种出一片属于自己的数字森林。</p><p>从我 2017 年初来深圳到现在，身边的小伙伴就像一群在城市森林中探险的精灵，他们有的选择踏上归途，回到老家的省会城市，去追寻那份熟悉和安宁。长沙、武汉、长春、西安……这些城市成了他们的新乐园。</p><p>也有一些同学反复横跳的，回老家又来深圳，又回老家又来深圳，这种我也挺羡慕的，潇洒。他们的生活就像是在玩一场”城市跳棋”，今年在深圳的高楼大厦间穿梭，明年可能就在老家的小巷里悠闲散步。其实从深圳回老家容易，但是回去了再来深圳需要勇气，也需要实力，所以对于这种反复横跳的同学我也是非常佩服。</p><p>当然，还有一些同学，他们在深圳这片热土上默默搬砖，攒钱买房。</p><p>前几年网上有一个说法特别流行，仿佛成了大城市生活的座右铭：”<strong>如果你不努力在大城市站稳脚，将来你的孩子要像你一样，重走一遍来大城市的路。</strong>“ 那会儿互联网行业和房地产业火得跟打了鸡血似的，这句话被很多人奉为圭臬。</p><p>可时间这玩意儿，它不等人，转眼就到了 2024 年。世界变了，变得连你我都认不出来了。现在再看到那句话，大家的反应可能就跟看老照片一样：”嗯，这照片挺有年代感的。” 然后心里默默地想：”我孩子为啥非得来大城市？难道是为了体验挤地铁的快感，还是为了品尝那吃不完的隆江猪脚饭？”</p><p>甚至，有些人已经提前进入了”躺平”模式，心里想着：”我都躺平了，还要啥自行车……哦不对，是孩子？”。既然如此，那似乎也没有在大城市继续搬砖的必要了。</p><p>说到底，经济趋缓，我们的心思也发生了很大的变化，当下辛苦点，将来生活也不见得会越来越好，那么不如选择活在当下，没必要把自己搞的那么辛苦。</p><p>其实，”萝卜青菜，各有所爱。” 有的人爱大城市的繁华，有的人爱小城市的宁静，还有的人……爱躺着。所以，不管选择回老家还是留深圳，只要自己觉得开心、舒适，那就是最好的选择。毕竟，生活不就是图个乐呵嘛！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;又有同学在深圳买房上车了，招呼在深圳的大学同学聚餐，现在这个时间点买房的我愿称之为爱国勇士！&lt;/p&gt;</summary>
    
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>第一次看演唱会</title>
    <link href="http://www.javaboy.org/2024/0607/video.html"/>
    <id>http://www.javaboy.org/2024/0607/video.html</id>
    <published>2024-06-07T12:25:48.000Z</published>
    <updated>2024-12-18T13:02:10.714Z</updated>
    
    <content type="html"><![CDATA[<p>朋友给了三张演唱会门票，长么大第一次有机会去现场听歌。</p><span id="more"></span><p><img src="http://img.itboyhub.com/2024/04/20240607101241.png"></p><p>上周有朋友说有三张演唱会门票，地点离我比较近，看我有空去不。虽然算不上吴克群粉丝，但是长这么大还没去看过演唱会，经常在网上刷到一些演唱会或者音乐节流出来的视频，感觉氛围都很不错，我也想体验一下，看演唱会在我眼里还是比较奢侈的事，既然有这个机会也刚好有空，管他是谁的演唱会，去看看。</p><p>对吴克群一直不怎么了解，印象中他比较有名的歌就是将军令、为你写诗，去了现场才知道还有一首大舌头也挺有名，之前我一直不知道那首歌叫大舌头，也不知道是谁唱的，好吧，路人无疑了。</p><p><img src="http://img.itboyhub.com/2024/04/20240607100545.png"></p><p>演唱会两个半小时，唱的歌都是吴克群自己作词作曲的歌，这倒是令我挺诧异的，没想到竟然是一个创作型歌手，虽然唱歌也是个专业度高的事情，但是能自己写词作曲，瞬间让人觉得这人还挺有才华的，有点路转粉了。</p><p>我那个位置比较靠前，按理前面的应该是铁粉，可是我那两排感觉挺安静的，不知道是不是跟我一样都是赠票来的。倒是其他地方有热情的粉丝特别激动，但是感觉好像不允许有激动的粉丝，因为每次粉丝一激动，保安立马就拿着激光灯跑过去，旁边站着一个保安队长，盯着每一个人，警惕着每一个可能“冒尖”的观众。虽然我不是狂热粉丝，也不会有出格举动，但是一直被人这样盯着观看表演还是不太舒服。也可能是我们互联网行业呆久了，比较在乎用户体验，1280 的票价也不是小数，应该让用户有一个比较好的体验。</p><p>演唱会现场的音响效果特别给力，音乐一响起来，低音炮的震动，让你的心跳跟着节奏一起”咚咚咚”，这种感觉特别震撼，也很有氛围感。</p><p>现场查了下吴克群百科上的信息，感觉他创作的黄金时代刚好跟我的中学时代吻合（2005.9-2008.6），不过那个时间段，叫得出名的歌手太多了，即使自己不是某位歌手的粉丝，身边的同学天天哼唱我们也会知道很多歌，所以吴克群就这样被忽略了。</p><p>第一次看演唱会，整体感觉不错，唯一的不足就是不是我喜欢的歌手～回了查了下李宗盛、许巍、伍佰的演唱会，都要抢票，算了，还是 App 听歌吧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;朋友给了三张演唱会门票，长么大第一次有机会去现场听歌。&lt;/p&gt;</summary>
    
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主键自增注意事项</title>
    <link href="http://www.javaboy.org/2024/0606/mysql-id-autoincrement.html"/>
    <id>http://www.javaboy.org/2024/0606/mysql-id-autoincrement.html</id>
    <published>2024-06-06T12:25:36.000Z</published>
    <updated>2024-12-18T12:59:59.963Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇文章中，松哥和小伙伴们分享了 MySQL 的聚簇索引，也顺便和小伙伴们分析了为什么在 MySQL 中主键不应该使用随机字符串。但是主键不用随机字符串用什么？主键自增？主键自增就是最佳方案吗？有没有其他坑？今天我们就来讨论下这个话题。</p><span id="more"></span><h2 id="1-为什么不用-UUID"><a href="#1-为什么不用-UUID" class="headerlink" title="1. 为什么不用 UUID"></a>1. 为什么不用 UUID</h2><p>经过上篇文章的介绍，我们知道在 MySQL 中，主键索引就是聚簇索引，MySQL 表中的数据是根据主键值聚集在一起的，聚簇索引是一棵 B+Tree，这棵树中的数据是有序的。</p><p>所以，如果我们使用 UUID 字符串作为主键，那么就会导致每次数据插入的时候，都需要在 B+Tree 中寻找到适合它自己的位置，找到之后就<strong>有可能</strong>要挪动后面的节点（就像在数组中插入一条记录），挪动后面的节点，就有可能涉及到页分裂，插入效率就会降低。</p><p>另一方面，在非聚簇索引中，叶子结点保存的是主键值，主键如果是一个很长的 UUID 字符串，就会占据较大的存储空间（相对 int 而言），那么同一个叶子结点能够保存的主键值数量就会减少，进而可能会导致树变高，树变高，意味着查询的时候 IO 次数增加，查询效率降低。</p><p>基于上面的分析，我们在 MySQL 中尽量不使用 UUID 作为主键，不用 UUID，可能会有小伙伴想到，那我使用主键自增行不行？</p><p>对于上面提到的两个使用 UUID 作为主键的问题，使用主键自增显然都可以解决。主键自增，每次只需要往树的末尾添加就行了，基本上不会涉及到页分裂问题；主键自增意味着主键是数字，占用的存储空间相对来说就比较小，对非聚簇索引的影响也会小一些。</p><p>那么主键自增就是最佳方案吗？主键自增有没有一些需要注意的问题？</p><h2 id="2-主键自增的问题"><a href="#2-主键自增的问题" class="headerlink" title="2. 主键自增的问题"></a>2. 主键自增的问题</h2><p><strong>以下内容，有一个共同的大前提，就是我们的表设置了主键自增。</strong></p><p>一般来说，主键自增是没有什么问题的。但是，如果在高并发环境下，就会有问题了。</p><p>首先最容易想到的就是在高并发插入的时候产生的尾部热点问题，并发插入时，大家都需要去查询这个值然后计算出自己的主键值，那么主键的上界就会成为热点数据，并发插入时这里会产生锁竞争。</p><p>为了解决这个问题，我们就需要选择适合自己的 <code>innodb_autoinc_lock_mode</code>。</p><h3 id="2-1-数据插入的三种形式"><a href="#2-1-数据插入的三种形式" class="headerlink" title="2.1 数据插入的三种形式"></a>2.1 数据插入的三种形式</h3><p>首先，我们在向数据表中插入数据的时候，一般来说有三种不同的形式，分别如下：</p><ol><li><code>insert into user(name) values(&#39;javaboy&#39;)</code> 或者 <code>replace into user(name) values(&#39;javaboy&#39;)</code> ，这种没有嵌套子查询并且<strong>能够确定具体插入多少行</strong>的插入叫做 <code>simple insert</code>，不过需要注意的是 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 不算是 <code>simple insert</code>。</li><li><code>load data</code> 或者 <code>insert into user select ... from ....</code>，这种都是批量插入，叫做 <code>bulk insert</code>，这种批量插入有一个特点就是插入多少条数据在一开始是未知的。</li><li><code>insert into user(id,name) values(null,&#39;javaboy&#39;),(null,&#39;江南一点雨&#39;)</code>，这种也是批量插入，但是跟第二种又不太一样，这种里边包含了一些自动生成的值（本案例中的主键自增），并且能够确定一共插入多少行，这种称之为 <code>mixed insert</code>，对于前面第一点提到的 <code>INSERT ... ON DUPLICATE KEY UPDATE</code> 也算是一种 <code>mixed insert</code>。</li></ol><p>将数据插入分为这三类，主要是因为在主键自增的时候，锁的处理方案不同，我们继续往下看。</p><h3 id="2-2-innodb-autoinc-lock-mode"><a href="#2-2-innodb-autoinc-lock-mode" class="headerlink" title="2.2 innodb_autoinc_lock_mode"></a>2.2 innodb_autoinc_lock_mode</h3><p>我们可以通过控制 innodb_autoinc_lock_mode 变量的值，来控制在主键自增的时候，MySQL 锁的处理思路。</p><p>innodb_autoinc_lock_mode 变量一共有三个不同的取值：</p><ul><li>0: 这个表示 traditional，在这种模式下，我们上面提到的三种不同的插入 SQL，对于自增锁的处理方案是一致的，都是在插入 SQL 语句开始的时候，获取到一个表级的 AUTO-INC 锁，然后当插入 SQL 执行完毕之后，再释放掉这把锁，这样做的好处是可以确保在批量插入的时候，自增主键是连续的。</li><li>1: 这个表示 consecutive，在这种模式下，对 <code>simple insert</code>（能够确定具体插入行数的，对应上面 1、3 两种情况）做了一些优化，由于 <code>simple insert</code> 插入多少行这个很好计算，于是可以一次性生成几个连续的值用在对应的插入 SQL 语句上，这样就可以提前释放掉 AUTO-INC 锁，可以减少锁等待，提高并发插入效率。</li><li>2: 这个表示 interleaved，这种情况下不存在 AUTO-INC 锁，来一个处理一个，批量插入的时候，就有可能出现主键虽然自增，但是不连续的问题。</li></ul><p>从上面的介绍中小伙伴们可以看到，实际上第三种，也就是 innodb_autoinc_lock_mode 取值为 2 的情况下，并发效率是最强的，那么我们是不是就应该设置 innodb_autoinc_lock_mode&#x3D;2 呢？</p><p>这得看情况。</p><p>松哥之前写过一篇文章和小伙伴们介绍 MySQL binlog 日志文件的三种格式：</p><ul><li>row：binlog 中记录的是具体的值而不是原始的 SQL，举一个简单例子，假设表中有一个字段是 UUID，用户执行的 SQL 是 <code>insert into user(username,uuid) values(&#39;javaboy&#39;,uuid())</code>，那么最终记录到 binlog 中的 SQL 是 <code>insert into user(username,uuid) values(&#39;javaboy&#39;,‘0212cfa0-de06-11ed-a026-0242ac110004’)</code>。</li><li>statement：binlog 中记录的就是原始的 SQL 了，以 row 中的为例，最终 binlog 中记录的就是 <code>insert into user(username,uuid) values(&#39;javaboy&#39;,uuid())</code>。</li><li>mixed：在这种模式下，MySQL 会根据具体的 SQL 语句来决定日志的形式，也就是在 statement 和 row 之间选择一种。</li></ul><p>对于这三种不同的模式，很明显，在主从复制的时候，statement 模式可能会导致主从数据不一致，所以现在 MySQL 默认的 binlog 格式都是 row。</p><p>回到我们的问题：</p><ul><li>如果 binlog 格式是 row，那么我们就可以设置 innodb_autoinc_lock_mode 的值为 2，这样就能尽最大程度保证数据并发插入的能力，同时不会发生主从数据不一致的问题。</li><li>如果 binlog 格式是 statement，那么我们最好设置 innodb_autoinc_lock_mode 的值为 1，这样对于 <code>simple insert</code> 的并发插入能力进行了提高，批量插入还是先获取 AUTO-INC 锁，等插入成功之后再释放，这样也能避免主从数据不一致，保证数据复制的安全性。</li><li>以上两点主要是针对 InnoDB 存储引擎，如果是 MyISAM 存储引擎，都是先获取 AUTO-INC 锁，插入完成再释放，相当于 innodb_autoinc_lock_mode 变量的取值对 MyISAM 不生效。</li></ul><h3 id="2-3-实践"><a href="#2-3-实践" class="headerlink" title="2.3 实践"></a>2.3 实践</h3><p>接下来我们来通过一个简单的 SQL 来和小伙伴们演示一下 innodb_autoinc_lock_mode 不同取值对应不同结果的情况。</p><p>首先，我们可以通过如下 SQL 查看当前 innodb_autoinc_lock_mode 的取值：</p><p><img src="http://img.itboyhub.com/2022/08/20230419005230.png"></p><p>可以看到，我使用的 8.0.32 这个版本目前默认值是 2。</p><p>我先把它改成 0，修改方式就是在 <code>/etc/my.cnf</code> 文件中添加一行 <code>innodb_autoinc_lock_mode=0</code>：</p><p><img src="http://img.itboyhub.com/2022/08/20230419005739.png"></p><p>改完之后再重启查看，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230419010011.png"></p><p>可以看到，现在就已经改过来了。</p><p>现在假设我有如下表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">CHARACTER SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">100</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>这个自增是从 100 开始计的，现在假设我有如下插入 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> <span class="keyword">user</span>(id,username) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;javaboy&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;江南一点雨&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;www.javaboy.org&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure><p>插入完成之后，我们来看查询结果：</p><p><img src="http://img.itboyhub.com/2022/08/20230419010756.png"></p><p>按照我们前文的介绍，这个情况应该是可以解释的通的，我这里不再赘述。</p><p>接下来，我把 innodb_autoinc_lock_mode 取值改为 1，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230419011034.png"></p><p>还是上面相同的 SQL，我们再执行一遍。执行完成之后结果也和上文相同。</p><p>但是！！！<strong>当上面的 SQL 执行完毕之后，如果我们还想再插入数据，并且新插入的 ID 不指定值，则我们发现自动生成的 ID 值为 104。</strong>这就是因为我们设置了 innodb_autoinc_lock_mode&#x3D;1，此时，执行 <code>simple insert</code> 插入的时候，系统一看我要插入 4 条记录，就直接给我提前拿了 4 个 ID 出来，分别是 100、101、102 以及 103，结果该 SQL 实际上只用了两个 ID，剩下两个没用，但是下次插入还是从 104 开始了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，这就是关于主键自增的一个小小知识点，小伙伴们一定要根据实际情况来为 innodb_autoinc_lock_mode 属性取一个合适的值。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上篇文章中，松哥和小伙伴们分享了 MySQL 的聚簇索引，也顺便和小伙伴们分析了为什么在 MySQL 中主键不应该使用随机字符串。但是主键不用随机字符串用什么？主键自增？主键自增就是最佳方案吗？有没有其他坑？今天我们就来讨论下这个话题。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>最新版Spring Security+OAuth2 视频教程</title>
    <link href="http://www.javaboy.org/2024/0605/spring-security-oauth2.html"/>
    <id>http://www.javaboy.org/2024/0605/spring-security-oauth2.html</id>
    <published>2024-06-05T12:25:12.000Z</published>
    <updated>2024-12-18T13:01:46.915Z</updated>
    
    <content type="html"><![CDATA[<p>松哥在 2021 年出版了一本关于 Spring Security 的书，就是下面这本：</p><span id="more"></span><p><img src="http://img.itboyhub.com/2021/02/20210309142654.png"></p><p>这本书是基于当时 Spring Security 的最新版本 Spring Security5.2 写的。从这本书的写作到现在，差不多过去了四年了，这期间 Spring Security 的变化非常大。特别是进入到 Spring Security6 的时代，很多之前的 API 废弃了。</p><p>虽然 Spring Security 变化很大，但是整体上还是越变越容易了，也越变越合理了。不过还是有很多小伙伴对 Spring Security 的用法不熟悉，因此松哥最近<strong>基于目前最新版的 Spring Security6.2.3</strong> 录制了一套视频教程，从用法到源码，和小伙伴们一起剖析 Spring Security+OAuth2。</p><p>不废话，先来看目录：</p><p><img src="http://img.itboyhub.com/2024/04/20240430095150.png"></p><p>基本上把 Spring Security 的方方面面以及 OAuth2 都讲到了。最重要的是，贴合了很多小伙伴们日常常见的开发场景，比如短信验证码登录、JWT+Redis 登录、微信 OAuth2 登录等等都有讲到。</p><p>这套视频是基于目前最新版的 Spring Security6 录制的，Spring Security6 在 API 层面的变化还是蛮大的，引入了大量的 Lambda 表达式去简化配置，很多旧版的写法在 Spring Security6 中被废弃，并在将来在 Spring Security7 中会移除相关的 API，所以说最近的 Spring Security 更新还是蛮激进的。</p><p>另一方面就是这套视频包含了全新的基于目前最新版 Spring Security 录制的 OAuth2 教程，松哥在 2020 年的时候出过图文版的 OAuth2 教程，但是，现在新版的 OAuth2 也有很多变化，不仅仅是 API 层面的变化，授权模式也发生了一些变化，传统的密码模式、简化模式现在都不再推荐，转而引入了 PKCE 模式，并且利用 OIDC 简化用户信息获取。同时，在 2020 年还处于萌芽状态的 Spring Security OAuth2 Server 这个项目，目前也趋于成熟，也可以直接使用了，这些松哥都在视频中和大家做了详细介绍。在 OAuth2 环节我也和大家分享了如何使用微信的 OAuth2 登录。</p><p>总之这一套教程，让大家彻底理解系统的安全管理。</p><p>之前有小伙伴说我直接自己写过滤器，既灵活还简单。我并不反对这种做法，但是有一个前提就是你很牛，你自己写的过滤器有考虑到计时攻击，有考虑到 XSS 攻击，有考虑到点击劫持，有考虑跨站请求伪造。。。等等太多了。当然，这些问题如果你都没有考虑到，那么 Spring Security 都有帮你考虑到并提供解决方案！</p><p>理解了 Spring Security，再去看市面上其他的安全管理框架，都会豁然开朗。</p><p>不同于松哥之前其他教程的交付方式，这套教程<strong>使用微信群答疑</strong>并且<strong>不再使用一机一码绑定设备播放</strong>，小伙伴们可以在任意设备上登录自己的账号就可以学习了，很便捷。</p><p>下面是两个试看视频：</p><p>这套视频是付费的，<strong>¥499</strong>，有需要的小伙伴加微信备注 <strong>499</strong>。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p><p>最后我再稍微介绍下自己，虽然很多小伙伴已经了解我了：</p><ol><li>技术畅销书作者，出版过两本技术图书，《Spring Boot+Vue全栈开发实战》（清华大学出版社，2019）和《深入浅出 Spring Security》（清华大学出版社，2021）。</li><li>华为云最具价值专家、华为云杰出 MVP、华为开发者社区之星。</li><li>腾讯技术创作营特邀评委、腾讯云金牌讲师。</li><li>GitHub 26k star 项目作者。</li><li>多年一线 coding 经验，有丰富的项目经验和授课经验。</li></ol><p><img src="http://img.itboyhub.com/2022/08/%E7%A8%BF%E5%AE%9A%E8%AE%BE%E8%AE%A1%E5%AF%BC%E5%87%BA-20240215-213838.jpg"></p><p>一个写过 Spring Security 相关图书的人来教你 Spring Security，绝对够专业。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;松哥在 2021 年出版了一本关于 Spring Security 的书，就是下面这本：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>什么时候需要用到 @EnableWebSecurity 注解？</title>
    <link href="http://www.javaboy.org/2024/0603/spring-security-enablewebsecurity.html"/>
    <id>http://www.javaboy.org/2024/0603/spring-security-enablewebsecurity.html</id>
    <published>2024-06-03T12:25:00.000Z</published>
    <updated>2024-12-18T13:01:43.848Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴在学习 Spring Security 的遇到一个问题：</p><span id="more"></span><p><img src="http://img.itboyhub.com/2024/04/20240530131118.png"></p><p>箭头所指的位置报红，也就是 Spring 容器中没有找到一个类型为 HttpSecurity 的 Bean。</p><p>小伙伴说如果他在配置类上加 @EnableWebSecurity 注解，就不报错；不加该注解则会报错。那么到底该不该加 @EnableWebSecurity 注解呢？今天就来和大伙聊一聊这个话题。</p><h1 id="一-EnableWebSecurity"><a href="#一-EnableWebSecurity" class="headerlink" title="一 @EnableWebSecurity"></a>一 @EnableWebSecurity</h1><p>首先我们来说下 @EnableWebSecurity 这个注解。从名字上就能看出来，这个注解就是启动 Spring Security 的，我们来看下这个注解的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123; WebSecurityConfiguration.class, SpringWebMvcImportSelector.class, OAuth2ImportSelector.class,</span></span><br><span class="line"><span class="meta">HttpSecurityConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableGlobalAuthentication</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebSecurity &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controls debugging support for Spring Security. Default is false.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> if true, enables debug support with Spring Security</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">debug</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这个注解的核心能力有两方面：</p><ol><li>导入了四个配置类。</li><li>启用了 @EnableGlobalAuthentication 注解。</li></ol><p>我们先来看这四个配置类。</p><h2 id="1-1-WebSecurityConfiguration"><a href="#1-1-WebSecurityConfiguration" class="headerlink" title="1.1 WebSecurityConfiguration"></a>1.1 WebSecurityConfiguration</h2><p><code>WebSecurityConfiguration</code> 是 Spring Security 框架中的一个核心配置类，它的主要作用是自动配置 Web 安全相关的组件和服务，以确保应用程序的 Web 层安全。</p><p><code>WebSecurityConfiguration</code> 主要有如下一些作用：</p><ol><li><strong>初始化 WebSecurity</strong>：它创建并配置了 <code>WebSecurity</code> 对象，这是一个高级抽象，负责配置安全过滤器链（<code>FilterChainProxy</code>），该过滤器链处理所有进入的 HTTP 请求，执行认证、授权、安全头设置、CSRF 保护等安全操作。</li><li><strong>自动配置 SecurityFilterChain</strong>：通过 <code>WebSecurity</code>，<code>WebSecurityConfiguration</code> 会设置一系列的安全过滤器，这些过滤器形成了 SecurityFilterChain，负责处理所有 Web 请求的安全性。</li><li><strong>配置默认安全行为</strong>：它提供了默认的安全配置，如允许未认证访问静态资源、设置默认的登录表单和登出逻辑、异常处理等，这些都是大多数 Web 应用的基础安全需求。</li><li><strong>支持自定义配置</strong>：尽管提供了默认配置，<code>WebSecurityConfiguration</code> 也允许开发者通过扩展 <code>WebSecurityConfigurerAdapter</code>（Spring Security5.7及以后版本已被弃用）或直接实现相关接口来自定义安全策略，以满足特定应用的需求。开发者可以覆盖默认的认证、授权规则、安全过滤器等配置。</li></ol><p>从这里大家可以看到，<code>WebSecurityConfiguration</code> 是 Spring Security 自动配置的核心，它简化了安全配置过程，同时保持了高度的可定制性，是构建安全 Web 应用不可或缺的一部分。</p><h2 id="1-2-SpringWebMvcImportSelector"><a href="#1-2-SpringWebMvcImportSelector" class="headerlink" title="1.2 SpringWebMvcImportSelector"></a>1.2 SpringWebMvcImportSelector</h2><p>SpringWebMvcImportSelector 主要是判断当前是不是 Web 环境，如果是，则返回 WebMvcSecurityConfiguration 对象进行配置，WebMvcSecurityConfiguration 在最新版 Spring Security 中已经废弃了。</p><h2 id="1-3-OAuth2ImportSelector"><a href="#1-3-OAuth2ImportSelector" class="headerlink" title="1.3 OAuth2ImportSelector"></a>1.3 OAuth2ImportSelector</h2><p>OAuth2ImportSelector 主要是检查当前项目有没有使用 OAuth2 Client，如果使用了，则返回和 OAuth2 Client 相关的配置类完成自动配置。</p><h2 id="1-4-HttpSecurityConfiguration"><a href="#1-4-HttpSecurityConfiguration" class="headerlink" title="1.4 HttpSecurityConfiguration"></a>1.4 HttpSecurityConfiguration</h2><p>HttpSecurityConfiguration 是提供了默认的 HttpSecurity 对象，关于 HttpSecurity 对象松哥在前面的文章中已经详细介绍过了。<a href="https://mp.weixin.qq.com/s/hGOhqla5xhqJWaIhIBwcYQ">HttpSecurity 是如何组装过滤器链的</a>。</p><h2 id="1-5-EnableGlobalAuthentication"><a href="#1-5-EnableGlobalAuthentication" class="headerlink" title="1.5 @EnableGlobalAuthentication"></a>1.5 @EnableGlobalAuthentication</h2><p>这个注解主要是为了导入 AuthenticationConfiguration 配置，AuthenticationConfiguration 配置中主要是配置了一些全局的认证器，因为 Spring Security 中的认证器有全局和局部之分（感兴趣的小伙伴可以了解下松哥的<a href="https://mp.weixin.qq.com/s/a7CvhHcnRuJQ-gEDFQNhsQ">Spring Security6+OAuth2 视频精讲</a>）。</p><p>从上面的代码中我们可以看到，@EnableWebSecurity 注解存在的意义，主要是就是开启了 Spring Security 的一些默认配置，相当于是一件启用 Spring Security。</p><h1 id="二-加还是不加？"><a href="#二-加还是不加？" class="headerlink" title="二 加还是不加？"></a>二 加还是不加？</h1><p>一键启用 Spring Security，在没有 Spring Boot 的年代，这确实是个好玩意！</p><p>但是！！！</p><p>现在我们都是使用 Spring Boot，相信各位小伙伴使用 Spring Security 的场景基本上也都是在 Spring Boot 项目中，而 Spring Boot 中关于 Spring Security 提供了自动化配置类 SecurityAutoConfiguration，当我们分析 SecurityAutoConfiguration 的源码时候，发现其实它里边最终也是调用了 @EnableWebSecurity。</p><p>所以，在 Spring Boot 项目中使用 Spring Security 的话，一般是不需要自己手动添加 @EnableWebSecurity 注解的，默认的自动化配置类已经帮我们启用了该注解。</p><h1 id="三-问题答案"><a href="#三-问题答案" class="headerlink" title="三 问题答案"></a>三 问题答案</h1><p>回到一开始的问题。小伙伴遇到这种问题，一般是两种可能：</p><ol><li>IDEA 检测问题，IDEA 提示不能全信，对于这样的报错问题，如果确认自己代码没问题，那就大胆去运行，可能是 IDEA 误报。</li><li>当前配置类没有被 Spring 容器扫描到，即当前配置类不在 Spring 容器中，但是却尝试注入 Spring 容器中的 Bean，于是就有了错误提示。当添加了 @EnableWebSecurity 注解之后，IDEA 检测到有 HttpSecurity 对象导入了，就不报错了，但是问题在根源其实在于当前类没有被注入到 Spring 容器中。</li></ol><p>后来证明是第二种原因。</p><p><img src="http://img.itboyhub.com/2024/04/20240531154300.png"></p><p>欢迎各位小伙伴一起来精进 Spring Security～<a href="https://mp.weixin.qq.com/s/5AdPmMR3RYHWuHA3gU2KrA">Spring Security+OAuth2 视频目录</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有小伙伴在学习 Spring Security 的遇到一个问题：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中如何控制 Bean 的加载顺序？</title>
    <link href="http://www.javaboy.org/2024/0529/spring-bean-order.html"/>
    <id>http://www.javaboy.org/2024/0529/spring-bean-order.html</id>
    <published>2024-05-29T12:24:36.000Z</published>
    <updated>2024-12-18T13:02:26.673Z</updated>
    
    <content type="html"><![CDATA[<p>如果你脱口而出说添加 @Order 注解或者是实现 Ordered 接口，那么恭喜，你掉坑了。</p><span id="more"></span><h1 id="一-Order-注解和-Ordered-接口"><a href="#一-Order-注解和-Ordered-接口" class="headerlink" title="一 @Order 注解和 Ordered 接口"></a>一 @Order 注解和 Ordered 接口</h1><p>在 Spring 框架中，<code>@Order</code> 是一个非常实用的元注解，它位于 <code>spring-core</code> 包下，主要用于控制某些特定上下文中组件的执行顺序或排序，但它并不直接控制 Bean 的初始化顺序。</p><h2 id="1-1-用途"><a href="#1-1-用途" class="headerlink" title="1.1 用途"></a>1.1 用途</h2><p>@Order 注解或者是 Ordered 接口，常见的用途主要是两种：</p><ul><li><p><strong>定义执行顺序</strong>：当多个组件（如拦截器、过滤器、监听器等）需要按照特定的顺序执行时，<code>@Order</code> 注解可以用来指定这些组件的执行优先级。数值越小，优先级越高，相应的组件会更早被执行或被放置在集合的前面（<code>@Order</code> 注解接受一个整数值，这个值可以是负数、零或正数。Spring 框架提供了 <code>Ordered.HIGHEST_PRECEDENCE</code>（默认最低优先级）和 <code>Ordered.LOWEST_PRECEDENCE</code>（默认最高优先级）常量，分别对应于  Integer.MIN_VALUE和 Integer.MAX_VALUE，可以方便地设定优先级。）。</p></li><li><p><strong>集合排序</strong>：当相同类型的组件被自动装配到一个集合中时，<code>@Order</code> 注解会影响它们在这个集合中的排列顺序。</p></li></ul><h2 id="1-2-使用场景"><a href="#1-2-使用场景" class="headerlink" title="1.2 使用场景"></a>1.2 使用场景</h2><p>经典使用场景。</p><h3 id="拦截器排序"><a href="#拦截器排序" class="headerlink" title="拦截器排序"></a>拦截器排序</h3><p>在 Spring MVC 中，可以使用 <code>@Order</code> 来控制拦截器的执行顺序。</p><h3 id="Spring-Security-Filters（过滤器）"><a href="#Spring-Security-Filters（过滤器）" class="headerlink" title="Spring Security Filters（过滤器）"></a>Spring Security Filters（过滤器）</h3><p>在 Spring Security 中，过滤器链的顺序通过 <code>@Order</code> 来定义，确保正确的安全处理流程。这个在松哥最近的教程中和大家详细介绍过了。</p><p><img src="http://img.itboyhub.com/2024/04/20240527115851.png"></p><h3 id="Event-Listeners（事件监听器）"><a href="#Event-Listeners（事件监听器）" class="headerlink" title="Event Listeners（事件监听器）"></a>Event Listeners（事件监听器）</h3><p>当有多个监听同一事件的监听器时，可以通过 <code>@Order</code> 来控制它们的触发顺序。</p><h3 id="Bean-的集合注入"><a href="#Bean-的集合注入" class="headerlink" title="Bean 的集合注入"></a>Bean 的集合注入</h3><p>当一个 Bean 依赖于一个特定类型的 Bean 集合时，带有 <code>@Order</code> 注解的 Bean 将按照指定顺序被注入。</p><p><strong>可以看到，@Order 注解的使用场景中，主要是相同类型的 Bean 存在多个时，这多个 Bean 的执行顺序可以通过 @Order 注解或者实现 Ordered 接口来确定。</strong></p><p>但是！！！</p><p><strong>@Order 注解不控制初始化和加载</strong>：<code>@Order</code> 注解不直接影响 Bean 的创建和初始化过程，这些由 Spring IoC 容器基于依赖关系和配置来决定。Spring IoC 容器根据依赖关系图来决定 Bean 的初始化顺序，而不是依据 <code>@Order</code> 注解。依赖关系决定了哪些 Bean 需要在其他 Bean 初始化之前被创建。</p><h1 id="二-如何设置-Bean-的加载顺序？"><a href="#二-如何设置-Bean-的加载顺序？" class="headerlink" title="二 如何设置 Bean 的加载顺序？"></a>二 如何设置 Bean 的加载顺序？</h1><p>有两种方式来设置 Bean 的加载顺序。</p><h2 id="2-1-DependsOn"><a href="#2-1-DependsOn" class="headerlink" title="2.1 @DependsOn"></a>2.1 @DependsOn</h2><p><code>@DependsOn</code> 是 Spring 框架提供的一个注解，用于指示 Spring 容器在初始化一个 Bean 之前，必须先初始化其依赖的其他 Bean。这个注解可以帮助解决 Bean 间的依赖关系，确保依赖的 Bean 已经准备就绪。</p><p><code>@DependsOn</code> 可以放在任何一个 Spring 管理的 Bean 定义上，包括但不限于配置类、服务类、数据访问对象等。其语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DependsOn(&#123;&quot;beanName1&quot;, &quot;beanName2&quot;, ...&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyBean</code> 类声明了它依赖于名为 <code>beanName1</code> 和 <code>beanName2</code> 的 Bean。这意味着，当 Spring 容器创建 <code>MyBean</code> 的实例时，它会首先确保 <code>beanName1</code> 和 <code>beanName2</code> 已经被正确初始化。</p><p>相关的源码在 AbstractBeanFactory#doGetBean 方法中：</p><p><img src="http://img.itboyhub.com/2024/04/20240527123326.png"></p><p>在创建的 Bean 的时候，先检查该 Bean 是否依赖了其他 Bean，如果依赖了，则先把其他 Bean 创建出来，然后再继续创建当前 Bean，这样就确保了 Bean 的加载顺序。</p><blockquote><p>如果小伙伴们对这块的完整流程感兴趣，可以看松哥录制的 <a href="https://mp.weixin.qq.com/s/9-DQdfN8GQ2cvGwy-T3DwA">Spring源码分析</a>。</p></blockquote><h2 id="2-2-BeanFactoryPostProcessor"><a href="#2-2-BeanFactoryPostProcessor" class="headerlink" title="2.2 BeanFactoryPostProcessor"></a>2.2 BeanFactoryPostProcessor</h2><p>第二种方式就是利用 BeanFactoryPostProcessor，BeanFactoryPostProcessor 的执行时机比较早，从下面这张流程图中可以看到，BeanFactoryPostProcessor 在正常的 Bean 初始化之前就执行了。</p><p><img src="http://img.itboyhub.com/2024/04/2024-05-27-124118.png"></p><p>那么对于想要提前初始化的 Bean，我们可以在 BeanFactoryPostProcessor 中手动调用，类似下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">//想要提前初始化的 Bean 在这里执行</span></span><br><span class="line">        beanFactory.getBean(<span class="string">&quot;serviceB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三 小结"></a>三 小结</h1><p>多个相同类型的 Bean 该如何确保其执行顺序？这个靠 @Order 注解或者 Ordered 接口来解决。但是这两者并不能解决 Bean 的加载顺序。Bean 的加载顺序有两种方式可以调整：</p><ol><li>通过 @DependsOn 注解加载。</li><li>手动在 BeanFactoryPostProcessor#postProcessBeanFactory 方法中提前调用 getBean 方法去初始化 Bean。</li></ol><p>如果小伙伴们想要彻底掌握 Spring 源码，那么不妨看看松哥录制的 Spring 源码视频教程。</p><p>这套视频教程基于目前最新的 Spring6 录制，一共有 204 集约 40 个小时，从 Spring 基本用法讲起，一直讲到源码分析。</p><p>以下是完整视频目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="number">01.</span>基础用法</span><br><span class="line">│   ├── <span class="number">01.</span>IoC基础</span><br><span class="line">│   │   ├── <span class="number">01.</span>Spring框架介绍-核心容器.mp4</span><br><span class="line">│   │   ├── <span class="number">02.</span>Spring框架介绍-数据访问和通信.mp4</span><br><span class="line">│   │   ├── <span class="number">03.</span>Spring框架介绍-Web模块.mp4</span><br><span class="line">│   │   ├── <span class="number">04.</span>Spring框架介绍-AOP和测试.mp4</span><br><span class="line">│   │   ├── <span class="number">05.</span>什么是IoC.mp4</span><br><span class="line">│   │   ├── <span class="number">06.</span>自定义一个简单的IoC.mp4</span><br><span class="line">│   │   ├── <span class="number">07.</span>向Spring容器注册Bean.mp4</span><br><span class="line">│   │   ├── <span class="number">08.</span>从Spring容器获取Bean.mp4</span><br><span class="line">│   │   ├── <span class="number">09.</span>id属性和name属性.mp4</span><br><span class="line">│   │   ├── <span class="number">10.</span>基本属性注入.mp4</span><br><span class="line">│   │   ├── <span class="number">11.</span>复杂属性注入.mp4</span><br><span class="line">│   │   ├── <span class="number">12.</span>构造器注入.mp4</span><br><span class="line">│   │   ├── <span class="number">13.</span>p名称空间注入.mp4</span><br><span class="line">│   │   ├── <span class="number">14.</span>属性自动注入.mp4</span><br><span class="line">│   │   ├── <span class="number">15.</span>配置文件加载.mp4</span><br><span class="line">│   │   ├── <span class="number">16.</span>Java代码配置IoC.mp4</span><br><span class="line">│   │   ├── <span class="number">17.</span>BeanName自动生成原理.mp4</span><br><span class="line">│   │   ├── <span class="number">18.</span>id和name属性处理原理.mp4</span><br><span class="line">│   │   ├── <span class="number">19.</span>Bean 的作用域.mp4</span><br><span class="line">│   │   ├── <span class="number">20.</span>singleton 和 prototype 的区别.mp4</span><br><span class="line">│   │   ├── <span class="number">21.</span>条件注解详解.mp4</span><br><span class="line">│   │   ├── <span class="number">22.</span>多环境切换.mp4</span><br><span class="line">│   │   ├── <span class="number">23.</span>Profile原理分析.mp4</span><br><span class="line">│   │   ├── <span class="number">24.</span>自定义Profile.mp4</span><br><span class="line">│   │   ├── <span class="number">25.</span>Bean的依赖关系.mp4</span><br><span class="line">│   │   ├── <span class="number">26.</span>FactoryBean用法.mp4</span><br><span class="line">│   │   ├── <span class="number">27.</span>抽取Bean的公共属性.mp4</span><br><span class="line">│   │   ├── <span class="number">28.</span>父子容器问题.mp4</span><br><span class="line">│   │   ├── <span class="number">29.</span><span class="meta">@Configuration</span>注解的作用.mp4</span><br><span class="line">│   │   ├── <span class="number">30.</span>Bean自动扫描.mp4</span><br><span class="line">│   │   └── <span class="number">31.</span>属性值注入.mp4</span><br><span class="line">│   ├── <span class="number">02.</span>AOP基础</span><br><span class="line">│   │   ├── <span class="number">01.</span>静态代理.mp4</span><br><span class="line">│   │   ├── <span class="number">02.</span>编译时增强和运行时增强.mp4</span><br><span class="line">│   │   ├── <span class="number">03.</span>编译时增强.mp4</span><br><span class="line">│   │   ├── <span class="number">04.</span>运行时增强-JDK.mp4</span><br><span class="line">│   │   ├── <span class="number">05.</span>运行时增强-CGLIB.mp4</span><br><span class="line">│   │   ├── <span class="number">06.</span>什么是Spring AOP.mp4</span><br><span class="line">│   │   ├── <span class="number">07.</span>SpringAOP和AspectJAOP.mp4</span><br><span class="line">│   │   ├── <span class="number">08.</span>Spring AOP核心概念.mp4</span><br><span class="line">│   │   ├── <span class="number">09.</span>Spring AOP入门用法.mp4</span><br><span class="line">│   │   ├── <span class="number">10.</span>五种通知.mp4</span><br><span class="line">│   │   ├── <span class="number">11.</span>Java代码配置AOP.mp4</span><br><span class="line">│   │   ├── <span class="number">12.</span>SpringAOP底层代理.mp4</span><br><span class="line">│   │   └── <span class="number">13.</span>通过注解定义AOP拦截规则.mp4</span><br><span class="line">│   ├── <span class="number">03.</span>JdbcTemplate</span><br><span class="line">│   │   ├── <span class="number">01.</span>JdbcTemplate基本操作.mp4</span><br><span class="line">│   │   ├── <span class="number">02.</span>增删改查.mp4</span><br><span class="line">│   │   └── <span class="number">03.</span>通过变量名传递参数.mp4</span><br><span class="line">│   └── <span class="number">04.</span>事务</span><br><span class="line">│       ├── <span class="number">01.</span>事务简介.mp4</span><br><span class="line">│       ├── <span class="number">02.</span>编程式事务.mp4</span><br><span class="line">│       ├── <span class="number">03.</span>XML配置声明式事务.mp4</span><br><span class="line">│       ├── <span class="number">04.</span>Java配置声明式事务.mp4</span><br><span class="line">│       ├── <span class="number">05.</span>Java+XML配置声明式事务.mp4</span><br><span class="line">│       ├── <span class="number">06.</span>自定义事务注解.mp4</span><br><span class="line">│       ├── <span class="number">07.</span>事务属性-隔离级别.mp4</span><br><span class="line">│       ├── <span class="number">08.</span>事务属性-传播性.mp4</span><br><span class="line">│       ├── <span class="number">09.</span>事务属性-传播性<span class="number">2.</span>mp4</span><br><span class="line">│       ├── <span class="number">10.</span>事务属性-回滚规则.mp4</span><br><span class="line">│       ├── <span class="number">11.</span>事务属性-只读事务.mp4</span><br><span class="line">│       ├── <span class="number">12.</span>事务属性-超时时间.mp4</span><br><span class="line">│       └── <span class="number">13.</span>事务失效的场景.mp4</span><br><span class="line">└── <span class="number">02.</span>进阶用法</span><br><span class="line">    ├── <span class="number">001.</span>通过name属性定义别名.mp4</span><br><span class="line">    ├── <span class="number">002.</span>通过alias标签定义别名.mp4</span><br><span class="line">    ├── <span class="number">003.</span>别名处理接口AliasRegistry.mp4</span><br><span class="line">    ├── <span class="number">004.</span>aliasMap变量.mp4</span><br><span class="line">    ├── <span class="number">005.</span>allowAliasOverriding.mp4</span><br><span class="line">    ├── <span class="number">006.</span>hasAlias.mp4</span><br><span class="line">    ├── <span class="number">007.</span>removeAlias和isAlias.mp4</span><br><span class="line">    ├── <span class="number">008.</span>getAliases.mp4</span><br><span class="line">    ├── <span class="number">009.</span>checkForAliasCircle.mp4</span><br><span class="line">    ├── <span class="number">010.</span>canonicalName.mp4</span><br><span class="line">    ├── <span class="number">011.</span>registerAlias.mp4</span><br><span class="line">    ├── <span class="number">012.</span>resolveAliases.mp4</span><br><span class="line">    ├── <span class="number">013.</span>name属性解析原理.mp4</span><br><span class="line">    ├── <span class="number">014.</span>alias标签解析.mp4</span><br><span class="line">    ├── <span class="number">015.</span>DefaultListableBeanFactory.mp4</span><br><span class="line">    ├── <span class="number">016.</span>StaticListableBeanFactory.mp4</span><br><span class="line">    ├── <span class="number">017.</span>SimpleJndiBeanFactory.mp4</span><br><span class="line">    ├── <span class="number">018.</span>ApplicationContext.mp4</span><br><span class="line">    ├── <span class="number">019.</span>FactoryBean&amp;SmartFactoryBean.mp4</span><br><span class="line">    ├── <span class="number">020.</span>FactoryBean处理思路.mp4</span><br><span class="line">    ├── <span class="number">021.</span>Bean提前加载流程分析.mp4</span><br><span class="line">    ├── <span class="number">022.</span>isFactoryBean方法分析.mp4</span><br><span class="line">    ├── <span class="number">023.</span>getBean中&amp;的处理逻辑.mp4</span><br><span class="line">    ├── <span class="number">024.</span>BeanDefinition简介.mp4</span><br><span class="line">    ├── <span class="number">025.</span>RootBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">026.</span>ChildBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">027.</span>GenericBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">028.</span>AnnotatedGenericBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">029.</span>ScannedGenericBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">030.</span>ConfigurationClassBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">031.</span>CreateFromClassBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">032.</span>ClassDerivedBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">033.</span>加载XML配置的两种方式.mp4</span><br><span class="line">    ├── <span class="number">034.</span>BeanDefinitionReader.mp4</span><br><span class="line">    ├── <span class="number">035.</span>PropertiesBeanDefinitionReader.mp4</span><br><span class="line">    ├── <span class="number">036.</span>XmlBeanDefinitionReader.mp4</span><br><span class="line">    ├── <span class="number">037.</span>配置类解析为BeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">038.</span><span class="meta">@Scope</span>注解高级用法.mp4</span><br><span class="line">    ├── <span class="number">039.</span>编程式AOP.mp4</span><br><span class="line">    ├── <span class="number">040.</span>编程式AOP之target方法分析.mp4</span><br><span class="line">    ├── <span class="number">041.</span>TargetSource体系结构.mp4</span><br><span class="line">    ├── <span class="number">042.</span>SimpleBeanTargetSource.mp4</span><br><span class="line">    ├── <span class="number">043.</span>自定义TargetSource.mp4</span><br><span class="line">    ├── <span class="number">044.</span>引介增强.mp4</span><br><span class="line">    ├── <span class="number">045.</span>启动类上的<span class="meta">@Scope</span>注解代理原理.mp4</span><br><span class="line">    ├── <span class="number">046.</span>常规类上的<span class="meta">@Scope</span>注解.mp4</span><br><span class="line">    ├── <span class="number">047.</span>Java配置中的<span class="meta">@Scope</span>代理.mp4</span><br><span class="line">    ├── <span class="number">048.</span>导入配置类上的<span class="meta">@Scope</span>注解.mp4</span><br><span class="line">    ├── <span class="number">049.</span><span class="meta">@Configuration</span>注解存在的意义是什么.mp4</span><br><span class="line">    ├── <span class="number">050.</span><span class="meta">@Configuration</span>-Vs-<span class="meta">@Component</span>.mp4</span><br><span class="line">    ├── <span class="number">051.</span><span class="meta">@Configuration</span>原理分析.mp4</span><br><span class="line">    ├── <span class="number">052.</span><span class="meta">@Configuration</span>的两种模式Full和Lite.mp4</span><br><span class="line">    ├── <span class="number">053.</span>详细演示Full和Lite模式.mp4</span><br><span class="line">    ├── <span class="number">054.</span>Full模式和Lite模式特点总结.mp4</span><br><span class="line">    ├── <span class="number">055.</span><span class="meta">@Configuration</span>注解解析源码分析.mp4</span><br><span class="line">    ├── <span class="number">056.</span><span class="meta">@Configuration</span>注解解析源码分析-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">057.</span>条件注解高级用法.mp4</span><br><span class="line">    ├── <span class="number">058.</span>条件注解高级用法补充.mp4</span><br><span class="line">    ├── <span class="number">059.</span>条件注解原理分析.mp4</span><br><span class="line">    ├── <span class="number">060.</span>beanName自动生成场景.mp4</span><br><span class="line">    ├── <span class="number">061.</span>beanName生成器分析.mp4</span><br><span class="line">    ├── <span class="number">062.</span>AnnotationBeanNameGenerator.mp4</span><br><span class="line">    ├── <span class="number">063.</span>BeanFactoryPostProcessor和BeanPostProcessor.mp4</span><br><span class="line">    ├── <span class="number">064.</span>BeanFactoryPostProcessor案例.mp4</span><br><span class="line">    ├── <span class="number">065.</span>BeanFactoryPostProcessor典型应用场景.mp4</span><br><span class="line">    ├── <span class="number">066.</span>Properties加载原理分析.mp4</span><br><span class="line">    ├── <span class="number">067.</span>BeanDefinitionRegistryPostProcessor.mp4</span><br><span class="line">    ├── <span class="number">068.</span>BeanFactoryPostProcessor作用时机分析.mp4</span><br><span class="line">    ├── <span class="number">069.</span>BeanPostProcessor接口分析.mp4</span><br><span class="line">    ├── <span class="number">070.</span>BeanPostProcessor实践.mp4</span><br><span class="line">    ├── <span class="number">071.</span>BeanPostProcessor实现AOP.mp4</span><br><span class="line">    ├── <span class="number">072.</span>MergedBeanDefinitionPostProcessor.mp4</span><br><span class="line">    ├── <span class="number">073.</span>BeanPostProcessor原理分析.mp4</span><br><span class="line">    ├── <span class="number">074.</span>合并BeanDefinition原理分析.mp4</span><br><span class="line">    ├── <span class="number">075.</span>合并BeanDefinition源码分析.mp4</span><br><span class="line">    ├── <span class="number">076.</span>父子容器原理分析.mp4</span><br><span class="line">    ├── <span class="number">077.</span>事件基本用法.mp4</span><br><span class="line">    ├── <span class="number">078.</span>事件是阻塞还是非阻塞.mp4</span><br><span class="line">    ├── <span class="number">079.</span>手动注册事件监听器.mp4</span><br><span class="line">    ├── <span class="number">080.</span>事件三大组件.mp4</span><br><span class="line">    ├── <span class="number">081.</span>Java类定义的事件监听器.mp4</span><br><span class="line">    ├── <span class="number">082.</span>Java类定义的事件监听器-补充.mp4</span><br><span class="line">    ├── <span class="number">083.</span>通过Java注解定义的事件监听器.mp4</span><br><span class="line">    ├── <span class="number">084.</span>ApplicationEventPublisher.mp4</span><br><span class="line">    ├── <span class="number">085.</span>ApplicationEventMulticaster.mp4</span><br><span class="line">    ├── <span class="number">086.</span>Spring事件补充.mp4</span><br><span class="line">    ├── <span class="number">087.</span>Java国际化.mp4</span><br><span class="line">    ├── <span class="number">088.</span>Spring国际化.mp4</span><br><span class="line">    ├── <span class="number">089.</span>MessageSource层级关系.mp4</span><br><span class="line">    ├── <span class="number">090.</span>getMessage方法原理分析.mp4</span><br><span class="line">    ├── <span class="number">091.</span>解析无参的key.mp4</span><br><span class="line">    ├── <span class="number">092.</span>解析有参key.mp4</span><br><span class="line">    ├── <span class="number">093.</span>Lifecycle基本用法.mp4</span><br><span class="line">    ├── <span class="number">094.</span>SmartLifecycle基本用法.mp4</span><br><span class="line">    ├── <span class="number">095.</span>Lifecycle中start方法执行原理.mp4</span><br><span class="line">    ├── <span class="number">096.</span>Lifecycle中stop方法执行原理.mp4</span><br><span class="line">    ├── <span class="number">097.</span>编程式AOP.mp4</span><br><span class="line">    ├── <span class="number">098.</span>动态代理对象创建流程.mp4</span><br><span class="line">    ├── <span class="number">099.</span>JDK和CGLIB动态代理分析.mp4</span><br><span class="line">    ├── <span class="number">100.</span>Advisor详解.mp4</span><br><span class="line">    ├── <span class="number">101.</span>自定义切面对象Advisor.mp4</span><br><span class="line">    ├── <span class="number">102.</span>重载方法拦截规则.mp4</span><br><span class="line">    ├── <span class="number">103.</span>拦截所有方法.mp4</span><br><span class="line">    ├── <span class="number">104.</span>默认配置的Pointcut对象.mp4</span><br><span class="line">    ├── <span class="number">105.</span>Pointcut经典写法.mp4</span><br><span class="line">    ├── <span class="number">106.</span>Pointcut分类.mp4</span><br><span class="line">    ├── <span class="number">107.</span>StaticMethodMatcherPointcut.mp4</span><br><span class="line">    ├── <span class="number">108.</span>StaticMethodMatcherPointcut-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">109.</span>DynamicMethodMatcherPointcut.mp4</span><br><span class="line">    ├── <span class="number">110.</span>AnnotationMatchingPointcut.mp4</span><br><span class="line">    ├── <span class="number">111.</span>ControlFlowPointcut.mp4</span><br><span class="line">    ├── <span class="number">112.</span>ComposablePointcut.mp4</span><br><span class="line">    ├── <span class="number">113.</span>提前返回Bean的机会.mp4</span><br><span class="line">    ├── <span class="number">114.</span>提前AOP的机会.mp4</span><br><span class="line">    ├── <span class="number">115.</span>理解两个关键变量.mp4</span><br><span class="line">    ├── <span class="number">116.</span>特殊的beanName.mp4</span><br><span class="line">    ├── <span class="number">117.</span>自定义TargetSourceCreator.mp4</span><br><span class="line">    ├── <span class="number">118.</span>提前AOP实践.mp4</span><br><span class="line">    ├── <span class="number">119.</span>AOP创建的契机.mp4</span><br><span class="line">    ├── <span class="number">120.</span>AOP对象生成整体思路.mp4</span><br><span class="line">    ├── <span class="number">121.</span>AOP对象创建详细流程分析.mp4</span><br><span class="line">    ├── <span class="number">122.</span>Bean的获取思路.mp4</span><br><span class="line">    ├── <span class="number">123.</span>getBean方法整体思路分析.mp4</span><br><span class="line">    ├── <span class="number">124.</span>从三级缓存中加载Bean.mp4</span><br><span class="line">    ├── <span class="number">125.</span>从parent中加载Bean.mp4</span><br><span class="line">    ├── <span class="number">126.</span>检查<span class="meta">@DependOn</span>注解.mp4</span><br><span class="line">    ├── <span class="number">127.</span>不同Scope获取Bean实例.mp4</span><br><span class="line">    ├── <span class="number">128.</span>生成的Bean类型检查.mp4</span><br><span class="line">    ├── <span class="number">129.</span>createBean方法分析.mp4</span><br><span class="line">    ├── <span class="number">130.</span>doCreateBean-<span class="number">1.</span>mp4</span><br><span class="line">    ├── <span class="number">131.</span>循环依赖-二级缓存.mp4</span><br><span class="line">    ├── <span class="number">132.</span>循环依赖-三级缓存.mp4</span><br><span class="line">    ├── <span class="number">133.</span>循环依赖-三级缓存-补充.mp4</span><br><span class="line">    ├── <span class="number">134.</span>循环依赖源码分析-<span class="number">1.</span>mp4</span><br><span class="line">    ├── <span class="number">135.</span>循环依赖源码分析-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">136.</span>循环依赖源码分析-<span class="number">3.</span>mp4</span><br><span class="line">    ├── <span class="number">137.</span>Bean的生命周期-<span class="number">1.</span>mp4</span><br><span class="line">    ├── <span class="number">138.</span>Bean的生命周期-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">139.</span>Bean的生命周期-<span class="number">3.</span>mp4</span><br><span class="line">    ├── <span class="number">140.</span>Bean的实例化-<span class="number">1.</span>mp4</span><br><span class="line">    ├── <span class="number">141.</span>Bean的实例化-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">142.</span>Bean的属性注入.mp4</span><br><span class="line">    ├── <span class="number">143.</span>getBean方法.mp4</span><br><span class="line">    └── <span class="number">144.</span>小结.mp4</span><br></pre></td></tr></table></figure><p><strong>好啦，5 折 ¥199 抄底就在今天啦！</strong>扫码加微信，<strong>备注 spring</strong>，发红包 199 上车吧～</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你脱口而出说添加 @Order 注解或者是实现 Ordered 接口，那么恭喜，你掉坑了。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>HttpSecurity 是如何组装过滤器链的</title>
    <link href="http://www.javaboy.org/2024/0525/spring-security-http-security.html"/>
    <id>http://www.javaboy.org/2024/0525/spring-security-http-security.html</id>
    <published>2024-05-25T12:24:12.000Z</published>
    <updated>2024-12-18T13:01:40.801Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴们问到这个问题，简单写篇文章和大伙聊一下。</p><span id="more"></span><h1 id="一-SecurityFilterChain"><a href="#一-SecurityFilterChain" class="headerlink" title="一 SecurityFilterChain"></a>一 SecurityFilterChain</h1><p>首先大伙都知道，Spring Security 里边的一堆功能都是通过 Filter 来实现的，无论是认证、RememberMe Login、会话管理、CSRF 处理等等，各种功能都是通过 Filter 来实现的。</p><p>所以，我们配置 Spring Security，说白了其实就是配置这些 Filter。</p><p>以前旧版继承自 WebSecurityConfigurerAdapter 类，然后重写 configure 方法，利用 HttpSecurity 去配置过滤器链，这种写法其实不太好理解，特别对于新手来说，可能半天整不明白到底配置了啥。</p><p>现在新版写法我觉得更加合理，因为直接就是让开发者自己去配置过滤器链，类似下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样开发者更容易理解，自己是在配置配置 SecurityFilter 过滤器链，因为就是要配置这样一个 Bean。</p><p>SecurityFilterChain 是一个接口，这个接口只有一个实现类 DefaultSecurityFilterChain。</p><p>DefaultSecurityFilterChain 中有一个 requestMatcher，通过 requestMatcher 可以识别出来哪些请求需要拦截，拦截下来之后，经由该类的另外一个属性 filters 进行处理，这个 filters 中保存了我们配置的所有 Filter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DefaultSecurityFilterChain</span> <span class="keyword">implements</span> <span class="title class_">SecurityFilterChain</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestMatcher requestMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Filter&gt; filters;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在配置 SecurityFilterChain 这个 Bean 的时候，我们甚至可以按照如下方式来写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityFilterChain</span>(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">&quot;/**&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置就表示拦截所有请求，但是拦截下来之后，这些请求所经过的过滤器为空，即拦截所有请求但是不做任何处理。</p><p>我们也可以为 DefaultSecurityFilterChain 对象去配置过滤器链，大家看到，它的构造器可以传入 Filter：</p><p><img src="http://img.itboyhub.com/2024/04/20240524230107.png"></p><p>但是，Spring Security 过滤器数量有 30+，我们平日开发使用的也在 15 个左右，这样一个一个去配置太麻烦了，每个过滤器并非 new 出来就能用了，还要配置各种属性，所以我们一般不会自己一个一个去配置这些过滤器。</p><h1 id="二-SecurityConfigurer"><a href="#二-SecurityConfigurer" class="headerlink" title="二 SecurityConfigurer"></a>二 SecurityConfigurer</h1><p>为了简化 Spring Security 中各个组件的配置，官方推出了 SecurityConfigurer，SecurityConfigurer 在 Spring Security 中扮演着非常重要的角色，其主要作用可以归纳为以下几点：</p><ol><li>配置过滤器：在 Spring Security 中，过滤器链中的每一个过滤器都是通过 xxxConfigurer 来进行配置的，而这些 xxxConfigurer 实际上都是 SecurityConfigurer 的实现。这意味着 SecurityConfigurer 负责配置和管理安全过滤器链中的各个组件。</li><li>初始化和配置安全构建器：SecurityConfigurer 接口中定义了两个主要方法：init 和 configure。init 方法用于初始化安全构建器（SecurityBuilder），而 configure 方法则用于配置这个构建器。这两个方法共同确保了安全组件的正确设置和初始化。</li><li>提供扩展点：SecurityConfigurer 的三个主要实现类（SecurityConfigurerAdapter、GlobalAuthenticationConfigurerAdapter、WebSecurityConfigurer）为开发者提供了扩展 Spring Security 功能的点。特别是，大部分的 xxxConfigurer 都是 SecurityConfigurerAdapter 的子类，这使得开发者能够轻松地定制和扩展安全配置。</li><li>构建安全上下文：通过配置和组合不同的 SecurityConfigurer 实现，可以构建一个完整的安全上下文，包括身份验证、授权、加密等各个方面，从而确保应用程序的安全性。</li></ol><p>换句话说，Spring Security 中的各种 Filter，其实都有各自对应的 xxxConfigurer，通过这些 xxxConfigurer 完成了对 Filter 的配置。</p><p>举几个简答的例子，如：</p><ul><li>CorsConfigurer 负责配置 CorsFilter</li><li>RememberMeConfigurer 负责配置 RememberMeAuthenticationFilter</li><li>FormLoginConfigurer 负责配置 UsernamePasswordAuthenticationFilter</li></ul><p>以上是前置知识。</p><h1 id="三-SecurityBuilder"><a href="#三-SecurityBuilder" class="headerlink" title="三 SecurityBuilder"></a>三 SecurityBuilder</h1><p><code>SecurityBuilder</code> 是 Spring Security 框架中的一个核心接口，它体现了建造者设计模式，用于构建和配置安全组件。这个接口并不直接与安全功能如认证或授权的具体实现绑定，而是提供了一种灵活的方式来组织和装配这些功能组件，特别是在构建安全上下文和过滤器链过程中。</p><h3 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h3><ol><li><strong>灵活性与模块化</strong>：通过 <code>SecurityBuilder</code>，开发者可以以模块化的方式添加、移除或替换安全配置中的各个部分，而不需要了解整个安全架构的细节。这促进了代码的复用性和可维护性。</li><li><strong>层次结构</strong>：在 Spring Security 中，<code>SecurityBuilder</code>及其子类形成了一个层次结构，允许配置像嵌套娃娃一样层层深入，每一个层级都可以贡献自己的配置逻辑，最终形成一个完整的安全配置。</li><li><strong>安全上下文构建</strong>：在认证过程中，<code>SecurityBuilder</code> 用于构造 <code>SecurityContext</code>，该上下文中包含了当前认证主体（通常是用户）的详细信息，以及主体所关联的权限和角色。</li><li><strong>过滤器链构建</strong>：在 Web 应用中，<code>SecurityBuilder</code> 还用于构建 <code>FilterChainProxy</code>，这是一个关键组件，负责组织和执行一系列的过滤器，这些过滤器负责处理 HTTP 请求的安全性，比如检查用户是否已经登录、是否有权限访问某个资源等。</li></ol><p>简而言之，在 SecurityBuilder 的子类 AbstractConfiguredSecurityBuilder 中，有一个名为 configurers 的集合，这个集合中保存的就是我们前面所说的各种 xxxConfigure 对象。</p><p>AbstractConfiguredSecurityBuilder 收集到所有的 xxxConfigure 之后，将来会调用每个 xxxConfigure 的 configure 方法完成过滤器的构建。</p><p>另外很重要的一点，HttpSecurity 也是一个 SecurityBuilder。因此，HttpSecurity 其实就是帮我们收集各种各样的 xxxConfigure，并存入到 configurers 集合中，以备将来构建过滤器使用。</p><h1 id="四-HttpSecurity"><a href="#四-HttpSecurity" class="headerlink" title="四 HttpSecurity"></a>四 HttpSecurity</h1><p>根据前面的介绍，我们知道，无论我们怎么配置，最终拿到手的一定是一个 DefaultSecurityFilterChain 对象，因为这是 SecurityFilterChain 的唯一实现类。</p><p>所以，HttpSecurity 其实就是在帮我们配置 DefaultSecurityFilterChain，我们看到 HttpSecurity 里边就有两个非常关键的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;OrderedFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="type">RequestMatcher</span> <span class="variable">requestMatcher</span> <span class="operator">=</span> AnyRequestMatcher.INSTANCE;</span><br></pre></td></tr></table></figure><p>这两个恰恰就是构建 DefaultSecurityFilterChain 所需的关键参数。</p><p>事实确实如此，我们看到，在 HttpSecurity#performBuild 方法中，就是利用这两个参数构建出来了 DefaultSecurityFilterChain：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> DefaultSecurityFilterChain <span class="title function_">performBuild</span><span class="params">()</span> &#123;</span><br><span class="line">ExpressionUrlAuthorizationConfigurer&lt;?&gt; expressionConfigurer = getConfigurer(</span><br><span class="line">ExpressionUrlAuthorizationConfigurer.class);</span><br><span class="line">AuthorizeHttpRequestsConfigurer&lt;?&gt; httpConfigurer = getConfigurer(AuthorizeHttpRequestsConfigurer.class);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">oneConfigurerPresent</span> <span class="operator">=</span> expressionConfigurer == <span class="literal">null</span> ^ httpConfigurer == <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">this</span>.filters.sort(OrderComparator.INSTANCE);</span><br><span class="line">List&lt;Filter&gt; sortedFilters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.filters.size());</span><br><span class="line"><span class="keyword">for</span> (Filter filter : <span class="built_in">this</span>.filters) &#123;</span><br><span class="line">sortedFilters.add(((OrderedFilter) filter).filter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityFilterChain</span>(<span class="built_in">this</span>.requestMatcher, sortedFilters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先对 filters 进行排序，然后据此创建出来 DefaultSecurityFilterChain 对象。</p><p>那么问题来了，filters 中的过滤器从何而来呢？</p><p>前面我们提到，HttpSecurity 本质上也是一个 SecurityBuilder，我们平时在 HttpSecurity 配置的各种东西，本质上其实就是一个 xxxConfigure，这些 xxxConfigure 被 HttpSecurity 收集起来，最后会遍历收集起来的 xxxConfigure，调用其 configure 方法，最终获取过滤器，并将获取到的过滤器存入到 filters 集合中。</p><p>这里松哥以我们最为常见的登录配置为例来和大家捋一捋这个流程。</p><p>新版的登录配置我们一般按照如下方式来配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.formLogin(f -&gt; f.permitAll());</span><br></pre></td></tr></table></figure><p>这个方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> HttpSecurity <span class="title function_">formLogin</span><span class="params">(Customizer&lt;FormLoginConfigurer&lt;HttpSecurity&gt;&gt; formLoginCustomizer)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">formLoginCustomizer.customize(getOrApply(<span class="keyword">new</span> <span class="title class_">FormLoginConfigurer</span>&lt;&gt;()));</span><br><span class="line"><span class="keyword">return</span> HttpSecurity.<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码可以看到，我们配置里边写的 lambda，其实就是在配置 FormLoginConfigurer 对象。</p><p>getOrApply 方法主要主要有两方面的作用：</p><ol><li>确保这个 Bean 不会重复配置。</li><li>如果该 Bean 是第一次配置，那么将该对象添加到 SecurityBuilder 中（其实就是 HttpSecurity 对象自身），这个 SecurityBuilder 里边保存了所有配置好的 xxxConfigure 对象，将来在过滤器链构建的时候，会去遍历这些 xxxConfigure 对象并调用其 configure 方法，完成过滤器的构建。</li></ol><p>在 FormLoginConfigurer#init 方法中，完成了和登录相关过滤器的配置，如：</p><ul><li>登录请求处理过滤器（构造方法中完成的）</li><li>注销过滤器的配置</li><li>登录失败端点配置</li><li>登录页面的配置</li></ul><p>这里涉及到的属性都会在对应的 xxxConfigurer 中完成配置。</p><p>当过滤器链开始构建的时候，会调用到所有 xxxConfigurer 的 configure 方法，在这个方法中，最终完成相关过滤器的创建，并将之添加到 HttpSecurity 的 filters 属性这个集合中。</p><p>FormLoginConfigurer 的 configure 方法在其父类中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(B http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">PortMapper</span> <span class="variable">portMapper</span> <span class="operator">=</span> http.getSharedObject(PortMapper.class);</span><br><span class="line"><span class="keyword">if</span> (portMapper != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.authenticationEntryPoint.setPortMapper(portMapper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">RequestCache</span> <span class="variable">requestCache</span> <span class="operator">=</span> http.getSharedObject(RequestCache.class);</span><br><span class="line"><span class="keyword">if</span> (requestCache != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.defaultSuccessHandler.setRequestCache(requestCache);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.authFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager.class));</span><br><span class="line"><span class="built_in">this</span>.authFilter.setAuthenticationSuccessHandler(<span class="built_in">this</span>.successHandler);</span><br><span class="line"><span class="built_in">this</span>.authFilter.setAuthenticationFailureHandler(<span class="built_in">this</span>.failureHandler);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.authenticationDetailsSource != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.authFilter.setAuthenticationDetailsSource(<span class="built_in">this</span>.authenticationDetailsSource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SessionAuthenticationStrategy</span> <span class="variable">sessionAuthenticationStrategy</span> <span class="operator">=</span> http</span><br><span class="line">.getSharedObject(SessionAuthenticationStrategy.class);</span><br><span class="line"><span class="keyword">if</span> (sessionAuthenticationStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.authFilter.setSessionAuthenticationStrategy(sessionAuthenticationStrategy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">RememberMeServices</span> <span class="variable">rememberMeServices</span> <span class="operator">=</span> http.getSharedObject(RememberMeServices.class);</span><br><span class="line"><span class="keyword">if</span> (rememberMeServices != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.authFilter.setRememberMeServices(rememberMeServices);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SecurityContextConfigurer</span> <span class="variable">securityContextConfigurer</span> <span class="operator">=</span> http.getConfigurer(SecurityContextConfigurer.class);</span><br><span class="line"><span class="keyword">if</span> (securityContextConfigurer != <span class="literal">null</span> &amp;&amp; securityContextConfigurer.isRequireExplicitSave()) &#123;</span><br><span class="line"><span class="type">SecurityContextRepository</span> <span class="variable">securityContextRepository</span> <span class="operator">=</span> securityContextConfigurer</span><br><span class="line">.getSecurityContextRepository();</span><br><span class="line"><span class="built_in">this</span>.authFilter.setSecurityContextRepository(securityContextRepository);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.authFilter.setSecurityContextHolderStrategy(getSecurityContextHolderStrategy());</span><br><span class="line"><span class="type">F</span> <span class="variable">filter</span> <span class="operator">=</span> postProcess(<span class="built_in">this</span>.authFilter);</span><br><span class="line">http.addFilter(filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在最后这一句 <code>http.addFilter(filter);</code>，这句代码将配置好的过滤器放到了 HttpSecurity 的 filters 集合中。</p><p>其他的也都类似，例如配置 CorsFilter 的 CorsConfigurer#configure 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(H http)</span> &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> http.getSharedObject(ApplicationContext.class);</span><br><span class="line"><span class="type">CorsFilter</span> <span class="variable">corsFilter</span> <span class="operator">=</span> getCorsFilter(context);</span><br><span class="line">http.addFilter(corsFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些被添加到 HttpSecurity 的 filters 属性上的 Filter，最终就成为了创建 DefaultSecurityFilterChain 的原材料。</p><p>类似的道理，我们也可以分析出 disable 方法的原理，例如我们要关闭 csrf，一般配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.csrf(c -&gt; c.disable());</span><br></pre></td></tr></table></figure><p>那么很明显，这段代码其实就是调用了 CsrfConfigurer 的 disable 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">disable</span><span class="params">()</span> &#123;</span><br><span class="line">getBuilder().removeConfigurer(getClass());</span><br><span class="line"><span class="keyword">return</span> getBuilder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法直接从 SecurityBuilder 的 configurers 集合中移除了 CsrfConfigurer，所以导致最终调用各个 xxxConfigure 的 configure 方法的时候，没有 CsrfConfigurer#configure 了，就导致 csrf 过滤器没有配置上，进而 CSRF filter 失效。</p><p>如果小伙伴们想要彻底学会 Spring Security，那么不妨看看我最近刚刚录完的 Spring Security+OAuth2 教程：</p><p><img src="http://img.itboyhub.com/2024/04/20240430095150.png"></p><p>这套教程基本上把 Spring Security 的方方面面以及 OAuth2 都讲到了。最重要的是，贴合了很多小伙伴们日常常见的开发场景，比如短信验证码登录、JWT+Redis 登录、微信 OAuth2 登录等等都有讲到。</p><p>视频是基于目前最新版的 Spring Security6 录制的，Spring Security6 在 API 层面的变化还是蛮大的，引入了大量的 Lambda 表达式去简化配置，很多旧版的写法在 Spring Security6 中被废弃，并在将来在 Spring Security7 中会移除相关的 API，所以说最近的 Spring Security 更新还是蛮激进的。</p><p>另一方面就是这套视频包含了全新的基于目前最新版 Spring Security 录制的 OAuth2 教程，松哥在 2020 年的时候出过图文版的 OAuth2 教程，但是，现在新版的 OAuth2 也有很多变化，不仅仅是 API 层面的变化，授权模式也发生了一些变化，传统的密码模式、简化模式现在都不再推荐，转而引入了 PKCE 模式，并且利用 OIDC 简化用户信息获取。同时，在 2020 年还处于萌芽状态的 Spring Security OAuth2 Server 这个项目，目前也趋于成熟，也可以直接使用了，这些松哥都在视频中和大家做了详细介绍。在 OAuth2 环节我也和大家分享了如何使用微信的 OAuth2 登录。</p><p>总之这一套教程，让大家彻底理解系统的安全管理。</p><p>之前有小伙伴说我直接自己写过滤器，既灵活还简单。我并不反对这种做法，但是有一个前提就是你很牛，你自己写的过滤器有考虑到计时攻击，有考虑到 XSS 攻击，有考虑到点击劫持，有考虑跨站请求伪造。。。等等太多了。当然，这些问题如果你都没有考虑到，那么 Spring Security 都有帮你考虑到并提供解决方案！</p><p>理解了 Spring Security，再去看市面上其他的安全管理框架，都会豁然开朗。</p><p>不同于松哥之前其他教程的交付方式，这套教程<strong>使用微信群答疑</strong>并且<strong>不再使用一机一码绑定设备播放</strong>，小伙伴们可以在任意设备上登录自己的账号就可以学习了，很便捷。</p><p>下面是两个试看视频：</p><p>这套视频是付费的，<strong>¥499</strong>，有需要的小伙伴加微信备注 <strong>499</strong>。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p><p>松哥在 2021 年出版了《深入浅出 Spring Security》（清华大学出版社，2021），所以这套视频教程绝对够专业。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有小伙伴们问到这个问题，简单写篇文章和大伙聊一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>JWT 签名用对称加密还是非对称加密？</title>
    <link href="http://www.javaboy.org/2024/0523/spring-security-jwt.html"/>
    <id>http://www.javaboy.org/2024/0523/spring-security-jwt.html</id>
    <published>2024-05-23T12:24:01.000Z</published>
    <updated>2024-12-18T13:01:36.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概念梳理"><a href="#一-概念梳理" class="headerlink" title="一 概念梳理"></a>一 概念梳理</h1><p>对称加密和非对称加密是两种基本的加密方法，它们在现代密码学中扮演着核心角色，用于保护数据的安全和隐私。</p><span id="more"></span><h2 id="1-1-对称加密（Symmetric-Encryption）"><a href="#1-1-对称加密（Symmetric-Encryption）" class="headerlink" title="1.1 对称加密（Symmetric Encryption）"></a>1.1 对称加密（Symmetric Encryption）</h2><p>对称加密是指加密和解密使用同一个密钥的过程。这意味着发送方和接收方都必须知道并使用这个共享的密钥来对信息进行加密和解密。这种方法的优点在于加密和解密速度快，效率高，适合处理大量数据。但是，安全分发密钥成为一个挑战，因为如果密钥在传输过程中被截获，那么加密的信息就可能被破解。常用的对称加密算法有 DES（Data Encryption Standard）、3DES（Triple DES）、AES（Advanced Encryption Standard）等。</p><h2 id="1-2-非对称加密（Asymmetric-Encryption）"><a href="#1-2-非对称加密（Asymmetric-Encryption）" class="headerlink" title="1.2 非对称加密（Asymmetric Encryption）"></a>1.2 非对称加密（Asymmetric Encryption）</h2><p>非对称加密则使用一对密钥，分别是公钥（Public Key）和私钥（Private Key）。公钥可以公开给任何人，用于加密信息；而私钥必须保密，仅由信息的接收者持有，用于解密信息。这种机制解决了密钥分发的问题，因为即使公钥被广泛传播，只要私钥保持安全，信息仍然是安全的。非对称加密的计算复杂度较高，速度相对较慢，因此通常用于加密小量的数据，或者用来安全地交换对称加密的密钥。常见的非对称加密算法有 RSA、DSA（Digital Signature Algorithm）、ECC（Elliptic Curve Cryptography）等。</p><p>对称加密适用于数据的快速加密和解密，但需要安全的密钥管理机制；而非对称加密提供了更好的安全性，尤其在密钥交换方面，尽管其加密和解密过程比对称加密更耗时。在实际应用中，这两种加密方式常常结合使用，例如在 HTTPS 的处理中。</p><h1 id="二-JWT"><a href="#二-JWT" class="headerlink" title="二 JWT"></a>二 JWT</h1><h2 id="2-1-JWT-简介"><a href="#2-1-JWT-简介" class="headerlink" title="2.1 JWT 简介"></a>2.1 JWT 简介</h2><p>JSON Web Token（JWT）是一种轻量级、自包含的安全标准，用于在各方之间安全地传输信息。它以 JSON 对象的形式存在，包含三个部分：Header（头部）、Payload（载荷）和Signature（签名）。JWT 被广泛应用于认证、授权和信息交换场景，如单点登录（SSO）、API 安全认证等。</p><p>JWT 的优势在于：</p><ul><li>无状态性：服务器无需存储会话信息，降低了服务器负担。</li><li>自包含：所有必要信息直接包含在 JWT 中，便于跨域传输。</li><li>安全性：通过签名机制确保数据的完整性和防篡改。</li></ul><h2 id="2-2-JWT-如何防篡改"><a href="#2-2-JWT-如何防篡改" class="headerlink" title="2.2 JWT 如何防篡改"></a>2.2 JWT 如何防篡改</h2><p>JWT 通过其内置的签名机制来防止数据被篡改，确保消息的完整性和真实性。JWT 的结构分为三部分：Header、Payload 和 Signature。签名部分正是 JWT 防止篡改的关键所在，其生成和验证流程如下：</p><h3 id="签名生成过程"><a href="#签名生成过程" class="headerlink" title="签名生成过程"></a>签名生成过程</h3><ol><li><p><strong>Header 和 Payload 编码</strong>：首先，JWT 的 Header 和 Payload 分别被 Base64Url 编码，形成两段字符串。Header 包含了关于 JWT 的元数据，如签名算法类型；Payload 则包含了实际要传输的数据，如用户标识、过期时间等。</p></li><li><p><strong>签名数据准备</strong>：将编码后的 Header 和 Payload 通过 <code>.</code> 连接起来形成一个字符串，这个字符串与用于签名的密钥（可以是对称密钥或私钥，依据所选签名算法而定）一起作为签名的输入。</p></li><li><p><strong>签名计算</strong>：根据 Header 中声明的签名算法（如 HMAC SHA256、RSA、ECDSA 等），使用密钥对上述拼接的字符串进行加密计算，产生一个签名字符串。</p></li><li><p><strong>组合 JWT</strong>：最后，将 Base64Url 编码的 Header、Payload 和新产生的 Signature 通过 <code>.</code> 连接，形成完整的 JWT 字符串。</p></li></ol><h3 id="防篡改验证过程"><a href="#防篡改验证过程" class="headerlink" title="防篡改验证过程"></a>防篡改验证过程</h3><ol><li><p><strong>接收 JWT</strong>：接收方首先解析 JWT，将其分割成 Header、Payload 和 Signature 三部分。</p></li><li><p><strong>签名验证</strong>：再次对 Header 和 Payload 进行 Base64Url 解码，并使用声明的签名算法和相应的密钥（如果是对称加密，则与签名时使用的密钥相同；如果是非对称加密，则使用与私钥配对的公钥）对这两部分数据进行计算，生成一个新的签名字符串。</p></li><li><p><strong>比较签名</strong>：将新生成的签名与 JWT 中携带的原始 Signature 进行对比。如果两者完全一致，则说明在传输过程中 JWT 没有被篡改，其内容是完整且真实的；若不一致，则表明 JWT 可能被篡改或不是由预期的发送方发出。</p></li></ol><h1 id="三-选择那种签名方案"><a href="#三-选择那种签名方案" class="headerlink" title="三 选择那种签名方案"></a>三 选择那种签名方案</h1><p>根据上面的介绍，在签名的时候存在两类不同的签名方式：对称加密和非对称加密。</p><p>选择使用共享密钥（HMAC）还是公私钥对（如RSA、ECDSA）来签名 JWT 取决于具体的应用场景和安全需求。</p><h2 id="3-1-共享密钥（HMAC）"><a href="#3-1-共享密钥（HMAC）" class="headerlink" title="3.1 共享密钥（HMAC）"></a>3.1 共享密钥（HMAC）</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>实现简单：相较于公私钥对，使用共享密钥进行签名和验证的实现更为直接和快速。</li><li>计算效率高：HMAC 算法的计算速度通常比 RSA 等非对称加密算法快，适合对性能有较高要求的场景。</li><li>密钥管理相对简单：只需保护好一个密钥即可，减少了密钥管理的复杂度。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>密钥分发风险：所有需要验证 JWT 的服务都需要访问这个共享密钥，增加了密钥泄露的风险。</li><li>不支持非对称操作：无法实现 JWT 的签发者和服务验证者之间的分离，因为双方都需要知道相同的密钥。</li></ul><h2 id="3-2-公私钥对"><a href="#3-2-公私钥对" class="headerlink" title="3.2 公私钥对"></a>3.2 公私钥对</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>增强安全性：私钥保持在签发者一方，公钥可以公开，即使 JWT 在传输过程中被截取，没有私钥也无法伪造 JWT，提高了安全性。</li><li>分离权限：可以实现签发和验证的职责分离，例如，认证服务器使用私钥签发 JWT，而各个服务使用公钥验证，无需共享私密信息。</li><li>更灵活的架构设计：适用于分布式系统，特别是当有多个服务需要验证 JWT，但不应知道用于签名的私钥时。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>实现复杂度：公私钥的管理和使用相比 HMAC 更复杂，尤其是在密钥的生成、存储和更新方面。</li><li>性能开销：非对称加密算法的计算成本高于对称加密，可能影响到大规模系统中的性能。</li></ul><h1 id="四-小结"><a href="#四-小结" class="headerlink" title="四 小结"></a>四 小结</h1><p>如果你的应用场景对性能要求较高，且信任环境较为封闭，可以考虑使用共享密钥。</p><p>若你需要更高的安全性，或者在分布式系统中需要明确分离 JWT 的签发和验证权限，公私钥对会是更好的选择，尽管它在实现和性能上可能带来一些挑战。</p><p>如果小伙伴们想要彻底掌握 Spring Security+OAuth2，那么可以看看松哥最近录制的这套全新的视频教程：</p><p><img src="http://img.itboyhub.com/2024/04/20240430095150.png"></p><p>基本上把 Spring Security 的方方面面以及 OAuth2 都讲到了。最重要的是，贴合了很多小伙伴们日常常见的开发场景，比如短信验证码登录、JWT+Redis 登录、微信 OAuth2 登录等等都有讲到。</p><p>这套视频是基于目前最新版的 Spring Security6 录制的，Spring Security6 在 API 层面的变化还是蛮大的，引入了大量的 Lambda 表达式去简化配置，很多旧版的写法在 Spring Security6 中被废弃，并在将来在 Spring Security7 中会移除相关的 API，所以说最近的 Spring Security 更新还是蛮激进的。</p><p>另一方面就是这套视频包含了全新的基于目前最新版 Spring Security 录制的 OAuth2 教程，松哥在 2020 年的时候出过图文版的 OAuth2 教程，但是，现在新版的 OAuth2 也有很多变化，不仅仅是 API 层面的变化，授权模式也发生了一些变化，传统的密码模式、简化模式现在都不再推荐，转而引入了 PKCE 模式，并且利用 OIDC 简化用户信息获取。同时，在 2020 年还处于萌芽状态的 Spring Security OAuth2 Server 这个项目，目前也趋于成熟，也可以直接使用了，这些松哥都在视频中和大家做了详细介绍。在 OAuth2 环节我也和大家分享了如何使用微信的 OAuth2 登录。</p><p>总之这一套教程，让大家彻底理解系统的安全管理。</p><p>之前有小伙伴说我直接自己写过滤器，既灵活还简单。我并不反对这种做法，但是有一个前提就是你很牛，你自己写的过滤器有考虑到计时攻击，有考虑到 XSS 攻击，有考虑到点击劫持，有考虑跨站请求伪造。。。等等太多了。当然，这些问题如果你都没有考虑到，那么 Spring Security 都有帮你考虑到并提供解决方案！</p><p>理解了 Spring Security，再去看市面上其他的安全管理框架，都会豁然开朗。</p><p>不同于松哥之前其他教程的交付方式，这套教程<strong>使用微信群答疑</strong>并且<strong>不再使用一机一码绑定设备播放</strong>，小伙伴们可以在任意设备上登录自己的账号就可以学习了，很便捷。</p><p>下面是两个试看视频：</p><p>这套视频是付费的，<strong>¥499</strong>，有需要的小伙伴加微信备注 <strong>499</strong>。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p><p>松哥在 2021 年出版了《深入浅出 Spring Security》（清华大学出版社，2021），所以这套视频教程绝对够专业。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一-概念梳理&quot;&gt;&lt;a href=&quot;#一-概念梳理&quot; class=&quot;headerlink&quot; title=&quot;一 概念梳理&quot;&gt;&lt;/a&gt;一 概念梳理&lt;/h1&gt;&lt;p&gt;对称加密和非对称加密是两种基本的加密方法，它们在现代密码学中扮演着核心角色，用于保护数据的安全和隐私。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 如何防止点击劫持</title>
    <link href="http://www.javaboy.org/2024/0522/spring-security-clickjacking.html"/>
    <id>http://www.javaboy.org/2024/0522/spring-security-clickjacking.html</id>
    <published>2024-05-22T12:23:50.000Z</published>
    <updated>2024-12-18T13:01:33.031Z</updated>
    
    <content type="html"><![CDATA[<p>在当今复杂的网络环境中，安全成为了每一个应用程序不可或缺的一部分。点击劫持（Clickjacking）作为一种隐蔽的网络攻击手段，对用户的信息安全构成了严重威胁。本文将深入探讨点击劫持的基本概念、其工作原理，并详细介绍在 Spring Security 框架中如何有效防御这一安全威胁。</p><span id="more"></span><h1 id="一-点击劫持简介"><a href="#一-点击劫持简介" class="headerlink" title="一 点击劫持简介"></a>一 点击劫持简介</h1><p>点击劫持是一种界面欺骗技术，攻击者通过隐藏真实的网页元素，诱使用户在不知情的情况下点击页面上的特定区域。这种点击可能触发恶意操作，如信息泄露、资金转账或权限授予等。攻击者利用 HTML 的 <code>iframe</code>、<code>透明层</code>等技术，将恶意界面叠加在合法网站之上，使得用户看似在与正常界面交互，实则执行了攻击者预设的操作。</p><h1 id="二-工作原理"><a href="#二-工作原理" class="headerlink" title="二 工作原理"></a>二 工作原理</h1><ol><li><strong>界面覆盖</strong>：攻击者创建一个透明层或与目标网站设计相似的界面，通过 CSS 设置使其完全覆盖在目标网页之上。</li><li><strong>诱导点击</strong>：在透明层或伪装界面上设置按钮或链接，引导用户点击。这些元素通常与目标网站的内容相融合，难以察觉。</li><li><strong>恶意操作</strong>：用户的点击实际上激活了隐藏在背后的恶意功能，如提交表单、执行脚本或导航到恶意网站。</li></ol><h1 id="三-Spring-Security-防御策略"><a href="#三-Spring-Security-防御策略" class="headerlink" title="三 Spring Security 防御策略"></a>三 Spring Security 防御策略</h1><p>Spring Security 作为 Java 应用中最受欢迎的安全框架之一，提供了多种安全特性来防御包括点击劫持在内的多种安全威胁。主要通过实施 Content Security Policy（CSP）和使用 X-Frame-Options 头部来防止点击劫持。</p><h2 id="3-1-X-Frame-Options"><a href="#3-1-X-Frame-Options" class="headerlink" title="3.1 X-Frame-Options"></a>3.1 X-Frame-Options</h2><p>这是最早被广泛采用的防御点击劫持的策略。Spring Security允许开发者通过配置轻松启用此头部：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.headers().frameOptions().sameOrigin(); <span class="comment">// 或 deny()</span></span><br></pre></td></tr></table></figure><ul><li><code>sameOrigin</code> 策略表示页面只能在同源的 <code>iframe</code> 中加载，有效阻止了跨域的点击劫持攻击。</li><li><code>deny</code> 则完全禁止页面在任何 <code>iframe</code> 中显示，是最严格的策略，但可能会限制一些合法的嵌套框架使用场景。</li></ul><h2 id="3-2-Content-Security-Policy-CSP"><a href="#3-2-Content-Security-Policy-CSP" class="headerlink" title="3.2 Content Security Policy (CSP)"></a>3.2 Content Security Policy (CSP)</h2><p>随着 Web 安全标准的发展，Content Security Policy 成为了一种更全面的安全策略，不仅能够防御点击劫持，还能对抗跨站脚本(XSS)等多种攻击。Spring Security 支持配置 CSP 以细化资源加载规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.headers().contentSecurityPolicy(<span class="string">&quot;default-src &#x27;self&#x27;; frame-ancestors &#x27;none&#x27;;&quot;</span>);</span><br></pre></td></tr></table></figure><p>这段配置指示浏览器只从自身源加载默认资源，并且不允许任何祖先框架，从而有效防止页面被嵌入到其他页面中进行点击劫持。</p><h1 id="四-结语"><a href="#四-结语" class="headerlink" title="四 结语"></a>四 结语</h1><p>点击劫持是一种需要高度重视的网络安全风险，它利用用户界面的漏洞，悄无声息地窃取用户数据或执行恶意操作。通过 Spring Security 提供的 X-Frame-Options 和 Content Security Policy 等机制，开发者可以有效地提升应用程序的安全性，保护用户免受点击劫持的侵害。然而，安全是一个持续的过程，开发者应定期审查并更新安全策略，以应对不断演变的威胁。</p><p>如果小伙伴们想要彻底掌握 Spring Security+OAuth2，那么可以看看松哥最近录制的这套全新的视频教程：</p><p><img src="http://img.itboyhub.com/2024/04/20240430095150.png"></p><p>基本上把 Spring Security 的方方面面以及 OAuth2 都讲到了。最重要的是，贴合了很多小伙伴们日常常见的开发场景，比如短信验证码登录、JWT+Redis 登录、微信 OAuth2 登录等等都有讲到。</p><p>这套视频是基于目前最新版的 Spring Security6 录制的，Spring Security6 在 API 层面的变化还是蛮大的，引入了大量的 Lambda 表达式去简化配置，很多旧版的写法在 Spring Security6 中被废弃，并在将来在 Spring Security7 中会移除相关的 API，所以说最近的 Spring Security 更新还是蛮激进的。</p><p>另一方面就是这套视频包含了全新的基于目前最新版 Spring Security 录制的 OAuth2 教程，松哥在 2020 年的时候出过图文版的 OAuth2 教程，但是，现在新版的 OAuth2 也有很多变化，不仅仅是 API 层面的变化，授权模式也发生了一些变化，传统的密码模式、简化模式现在都不再推荐，转而引入了 PKCE 模式，并且利用 OIDC 简化用户信息获取。同时，在 2020 年还处于萌芽状态的 Spring Security OAuth2 Server 这个项目，目前也趋于成熟，也可以直接使用了，这些松哥都在视频中和大家做了详细介绍。在 OAuth2 环节我也和大家分享了如何使用微信的 OAuth2 登录。</p><p>总之这一套教程，让大家彻底理解系统的安全管理。</p><p>之前有小伙伴说我直接自己写过滤器，既灵活还简单。我并不反对这种做法，但是有一个前提就是你很牛，你自己写的过滤器有考虑到计时攻击，有考虑到 XSS 攻击，有考虑到点击劫持，有考虑跨站请求伪造。。。等等太多了。当然，这些问题如果你都没有考虑到，那么 Spring Security 都有帮你考虑到并提供解决方案！</p><p>理解了 Spring Security，再去看市面上其他的安全管理框架，都会豁然开朗。</p><p>不同于松哥之前其他教程的交付方式，这套教程<strong>使用微信群答疑</strong>并且<strong>不再使用一机一码绑定设备播放</strong>，小伙伴们可以在任意设备上登录自己的账号就可以学习了，很便捷。</p><p>下面是两个试看视频：</p><p>这套视频是付费的，<strong>¥499</strong>，有需要的小伙伴加微信备注 <strong>499</strong>。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p><p>松哥在 2021 年出版了《深入浅出 Spring Security》（清华大学出版社，2021），所以这套视频教程绝对够专业。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在当今复杂的网络环境中，安全成为了每一个应用程序不可或缺的一部分。点击劫持（Clickjacking）作为一种隐蔽的网络攻击手段，对用户的信息安全构成了严重威胁。本文将深入探讨点击劫持的基本概念、其工作原理，并详细介绍在 Spring Security 框架中如何有效防御这一安全威胁。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>微服务中的鉴权该怎么做？</title>
    <link href="http://www.javaboy.org/2024/0520/micro-service-permission.html"/>
    <id>http://www.javaboy.org/2024/0520/micro-service-permission.html</id>
    <published>2024-05-20T12:23:37.000Z</published>
    <updated>2024-12-18T13:02:02.579Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚好有小伙伴在微信上问到这个问题，松哥就来和大家聊一聊，本文主要和小伙伴们聊一聊思路，不写代码，小伙伴们可以结合松哥之前的文章，应该能够自己写出来本文的代码。当然，思路也只是我自己的一点实践经验，不一定是最完美的方案，欢迎小伙伴们在留言中一起探讨。</p><span id="more"></span><h2 id="1-认证与授权"><a href="#1-认证与授权" class="headerlink" title="1. 认证与授权"></a>1. 认证与授权</h2><p>首先小伙伴们知道，无论我们学习 Shiro 还是 Spring Security，里边的功能无论有哪些，核心都是两个：</p><ol><li>认证</li><li>授权</li></ol><p>所以，我们在微服务中处理鉴权问题，也可以从这两个方面来考虑。</p><h3 id="1-1-认证"><a href="#1-1-认证" class="headerlink" title="1.1 认证"></a>1.1 认证</h3><p>认证，说白了就是登录。传统的 Web 登录是 Cookie+Session 的方案，这种方案依赖于服务器本地内存，在微服务中，由于服务众多，这种方案显然不再合适。</p><blockquote><p>可能会有小伙伴说用 Redis+SpringSession 做 Session 共享，这是个办法，但是不是最佳方案，因为这种方案的性能以及可扩展性都比较差。</p></blockquote><p>所以，微服务中的认证，还是建议使用令牌的方式，可以选择 JWT 令牌，这也是目前使用较多的一种方案。但是熟悉 JWT 的小伙伴都知道，纯粹的无状态登录无法实现注销，这就很头大，所以在实际应用中，单纯的使用 JWT 是不行的，一般还是要结合 Redis 一起，将生成的 JWT 字符串在 Redis 上也保存一份，并设置过期时间，判断用户是否登录时，需要先去 Redis 上查看 JWT 字符串是否存在，存在的话再对 JWT 字符串做解析操作，如果能成功解析，就没问题，如果不能成功解析，就说明令牌不合法。</p><p>这样有状态登录+无状态登录混在一起的方式，虽然看起来有点不伦不类，但是就当下来说，这个折衷的办法算是一个可行的方案了。</p><blockquote><p>其实，上面的方案，说白了，跟传统的 Cookie+Session 没什么两样，思路几乎都是完全 copy 的：传统的 Session 用 Redis 代替了；传统穿梭于服务端和浏览器之间的 jsessionId 被 JWT 字符串代替了；传统的 jsessionId 通过 Cookie 来传输，现在的 JWT 则通过开发者手动设置后通过请求头来传输；传统的 Session 可以自动续签，现在用 JWT 就是手动续签，每次请求到达服务端的时候，就去看下 Redis 上令牌的过期时间，快过期了，就重新设置一下，其他都一模一样。</p></blockquote><p>这是认证方案的选择。</p><h3 id="1-2-授权"><a href="#1-2-授权" class="headerlink" title="1.2 授权"></a>1.2 授权</h3><p>微服务中授权，也可以使用 Shiro 或者 Spring Security 框架来做，省事一些。考虑到微服务技术栈都是 Spring 家族的产品，所以在权限框架这块也是建议大家首选 Spring Security（如果有小伙伴对 Spring Security 还不熟悉的话，可以在微信公众号后台回复 ss，有教程）。</p><p>当然，如果觉得 Spring Security 比较复杂想自己搞的话，也是可以的。自己搞的话，也是可以借助于 Spring Security 的思路的，松哥最近的一个项目就是这样：</p><blockquote><p>请求到达微服务之后，先找到当前用户的各种信息，包括当前用户所拥有的角色和权限等信息，然后存入到和当前线程绑定的 ThreadLocal 对象中。另一方面自定义权限注解和角色注解，在切面中对这些注解进行解析，检查当前用户是否具备所需要的角色&#x2F;权限等。</p></blockquote><p>当然，如果你使用了 Spring Security 的话，上面这个就不需要自定义注解了，直接使用 Spring Security 中自带的即可，还可以体验 Spring Security 中更多的丰富的安全功能。</p><h2 id="2-认证服务"><a href="#2-认证服务" class="headerlink" title="2. 认证服务"></a>2. 认证服务</h2><p>那么认证和授权在哪里做？</p><p>先来说认证，认证我们可以简单分为两个步骤：</p><ol><li>登录</li><li>校验</li></ol><h3 id="2-1-登录"><a href="#2-1-登录" class="headerlink" title="2.1 登录"></a>2.1 登录</h3><p>一般来说，登录我们可以单独做一个认证服务。<strong>当登录请求到达网关之后，我们将之转发到认证服务上</strong>，完成认证操作。</p><p>在认证服务上，我们就去检查用户名&#x2F;密码是否 OK，用户状态是否都 OK，都没问题的话，生成 JWT 字符串，同时再把数据存入到 Redis 上，然后把 JWT 字符串返回。</p><blockquote><p>如果系统有注册功能的话，注册功能也是放在这个微服务上来完成。</p></blockquote><h3 id="2-2-校验"><a href="#2-2-校验" class="headerlink" title="2.2 校验"></a>2.2 校验</h3><p>校验是指每一个请求到达的时候，校验用户是否已经登录。</p><p>这个当然可以和 2.1 放到一起去做，但是松哥不建议。问题在于，假如是一个创建订单的请求，这个请求原本是要经过网关转发到订单服务上的，但是，此时就得先在网关上调用 2.1 小节的服务进行登录校验，没问题再转发到订单服务上，这样做很明显很费事，也不合理。</p><p>一个比较好的办法是直接在网关上去校验请求的令牌是否合法，这个校验本身也比较容易，校验令牌是否合法，我们只需要看 Redis 上是否存在这个令牌，并且这个 JWT 令牌能够被顺利解析就行，这个操作完全可以在网关上做。</p><p>以 Gateway 网关为例，我们可以自定义全局过滤器，在全局过滤器中校验每一个请求的令牌，校验通过了，再进行请求的转发，否则就不转发。</p><p>校验通过之后，在转发到具体的微服务之后，我们可以将解析出来的用户 id 以及用户名等信息放到请求头中，然后再转发，这样到达各个具体的微服务之后，就知道这个请求是谁发来的，这人都有哪些角色&#x2F;权限，方便做下一步的权限校验。</p><blockquote><p>松哥的做法是定义了一个公共模块，所有的微服务都依赖这个公共模块，这个公共模块中定义了一个拦截器，会拦截下来每一个请求，从请求头中取出用户 ID，然后从 Redis 中拿到具体的用户信息，存入到 ThreadLocal 中，这样在后续的方法调用中，如果需要判断用户是否具备某一个权限，就可以通过 ThreadLocal 去获取了。</p></blockquote><p>大致上就是这样一个流程。</p><h2 id="3-授权服务"><a href="#3-授权服务" class="headerlink" title="3. 授权服务"></a>3. 授权服务</h2><p>授权没法放到网关上做，还是得在各个微服务上去完成。</p><p>微服务上的授权我们又可以将之大致上分为两类：</p><ol><li>前端发送来的请求（外部请求）。</li><li>别的微服务发送来的请求（内部请求）。</li></ol><h3 id="3-1-外部请求"><a href="#3-1-外部请求" class="headerlink" title="3.1 外部请求"></a>3.1 外部请求</h3><p>对于外部请求来说，就按正常的权限校验对待就行了，自定义注解亦或者使用 Spring Security 等框架都是可以的，如果是自定义注解的话，就结合 AOP 一起，定义切面自己去处理权限注解，当然，这些功能基本上每一个微服务都是需要的，所以可以将之抽取成为一个公共的模块，在不同的微服务中依赖即可。</p><h3 id="3-2-内部请求"><a href="#3-2-内部请求" class="headerlink" title="3.2 内部请求"></a>3.2 内部请求</h3><p>对于内部的请求来说，正常是不需要鉴权的，内部请求可以直接处理。问题是如果使用了 OpenFeign，数据都是通过接口暴露出去的，不鉴权的话，又会担心从外部来的请求调用这个接口，对于这个问题，我们也可以自定义注解+AOP，然后在内部请求调用的时候，额外加一个头字段加以区分。</p><p>当然，内部请求到达微服务的时候，也是需要进行认证的，就行请求从网关转发到每一个具体的微服务上时需要认证一样，不过很明显，我们没必要每次使用 OpenFeign 调用别的服务的时候，都去传一堆认证信息，我们可以通过实现 <code>feign.RequestInterceptor</code> 接口来定义一个 OpenFeign 的请求拦截器，在拦截器中，统一为 OpenFeign 请求设置请求头信息。</p><p>好啦，关于微服务中的鉴权，我们目前是这么做的，欢迎小伙伴们留言一起探讨。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近刚好有小伙伴在微信上问到这个问题，松哥就来和大家聊一聊，本文主要和小伙伴们聊一聊思路，不写代码，小伙伴们可以结合松哥之前的文章，应该能够自己写出来本文的代码。当然，思路也只是我自己的一点实践经验，不一定是最完美的方案，欢迎小伙伴们在留言中一起探讨。&lt;/p&gt;</summary>
    
    
    
    <category term="微服务" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 注册过滤器注意事项</title>
    <link href="http://www.javaboy.org/2024/0519/spring-security-registry-filter.html"/>
    <id>http://www.javaboy.org/2024/0519/spring-security-registry-filter.html</id>
    <published>2024-05-19T12:23:25.000Z</published>
    <updated>2024-12-18T13:01:29.969Z</updated>
    
    <content type="html"><![CDATA[<p>前两天和小伙伴聊了 Spring Security+JWT 实现无状态登录，然后有小伙伴反馈了一个问题，感觉这是一个我们平时写代码容易忽略的问题，写一篇文章和小伙伴们聊一聊。</p><span id="more"></span><h1 id="一-问题复原"><a href="#一-问题复原" class="headerlink" title="一 问题复原"></a>一 问题复原</h1><p>先来说问题吧，在 Spring Security+JWT 登录中，整体上的思路就是用户登录成功之后返回 JWT 字符串，然后以后用户每次请求都携带上 JWT 字符串，服务端进行校验，校验通过之后，请求继续执行。</p><p>按照上面的思路，我们的项目中需要有一个 JwtFilter 用来从请求中提取请求传来的 Jwt 字符串进行校验，类似下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> req.getRequestURI();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;/login&quot;</span>.equals(requestURI)) &#123;</span><br><span class="line">            <span class="comment">//登录请求，无需校验令牌，请求继续执行</span></span><br><span class="line">            filterChain.doFilter(xxx,xxx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//令牌校验</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有一个小伙伴反馈，在项目中使用了 WebSecurityCustomizer 给 Swagger 相关的请求都放行了，结果这些被放行的请求都被 JwtFilter 拦截了，这是咋回事呢？</p><p>首先小伙伴们要知道，使用 WebSecurityCustomizer 放行的请求，都不再经过 SecurityFilter 了，所以按理不该再被 JwtFilter 拦截了，因为 JwtFilter 是隶属于 SecurityFilter 这个过滤器链中的，并非原生的跟 Servlet 平级的那种 Filter。</p><p><img src="http://img.itboyhub.com/2024/04/_WebSecurityCustomizer_202405182319.png"></p><p>但是为什么又拦截了呢？</p><p>松哥看了下代码，发现问题出在 @Component 这个注解上。</p><h1 id="二-原理分析"><a href="#二-原理分析" class="headerlink" title="二 原理分析"></a>二 原理分析</h1><p>在 Spring Boot 项目启动的时候，有一个环节就是把 Spring 容器中所有类型为 Filter 的 Bean 找出来，并且自动添加到容器的过滤器链条中（注意不是添加到 Spring Security 过滤器链中）。</p><p>这段代码的逻辑位于 ServletContextInitializerBeans#addAdaptableBeans 方法中，在该方法中，会调用 addAsRegistrationBean 方法完成以上事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T, B <span class="keyword">extends</span> <span class="title class_">T</span>&gt; <span class="keyword">void</span> <span class="title function_">addAsRegistrationBean</span><span class="params">(ListableBeanFactory beanFactory, Class&lt;T&gt; type,</span></span><br><span class="line"><span class="params">Class&lt;B&gt; beanType, RegistrationBeanAdapter&lt;T&gt; adapter)</span> &#123;</span><br><span class="line">List&lt;Map.Entry&lt;String, B&gt;&gt; entries = getOrderedBeansOfType(beanFactory, beanType, <span class="built_in">this</span>.seen);</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, B&gt; entry : entries) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"><span class="type">B</span> <span class="variable">bean</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.seen.add(bean)) &#123;</span><br><span class="line"><span class="comment">// One that we haven&#x27;t already seen</span></span><br><span class="line"><span class="type">RegistrationBean</span> <span class="variable">registration</span> <span class="operator">=</span> adapter.createRegistrationBean(beanName, bean, entries.size());</span><br><span class="line"><span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> getOrder(bean);</span><br><span class="line">registration.setOrder(order);</span><br><span class="line"><span class="built_in">this</span>.initializers.add(type, registration);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里传入的参数 type 和 beanType 都是 Filter，从 Spring 容器中找到 Filter 类型的 Bean 存入到 initializers 集合中。不过注意，添加到集合中的实际上是封装之后的 registration 对象，这个对象通过 <code>adapter.createRegistrationBean</code> 方法创建出来，在该方法中，由于我们没有为当前过滤器设置拦截的请求地址，所以默认拦截所有请求，拦截规则是 <code>/*</code>。</p><p>最后在 ServletWebServerApplicationContext#selfInitialize 方法中遍历上一步找到的过滤器，并逐个进行配置，相关代码如下：</p><p>DynamicRegistrationBean#register：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String description, ServletContext servletContext)</span> &#123;</span><br><span class="line">    <span class="comment">//注册过滤器</span></span><br><span class="line"><span class="type">D</span> <span class="variable">registration</span> <span class="operator">=</span> addRegistration(description, servletContext);</span><br><span class="line"><span class="comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractFilterRegistrationBean#addRegistration：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Dynamic <span class="title function_">addRegistration</span><span class="params">(String description, ServletContext servletContext)</span> &#123;</span><br><span class="line"><span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> getFilter();</span><br><span class="line"><span class="keyword">return</span> servletContext.addFilter(getOrDeduceName(filter), filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这最终就是大家熟知的添加过滤器的代码了。</p><h1 id="三-解决方案"><a href="#三-解决方案" class="headerlink" title="三 解决方案"></a>三 解决方案</h1><p>找到问题的原因，那么问题就好解决了。</p><p>问题的产生，主要是因为 Spring 自动查找容器中所有 Filter 类型的 Bean，并进行配置，那么我们的解决方案就是不要把这个 Bean 注册到 Spring 容器中，即不要添加 @Component 注解，而是直接自己 new 出来就行了，在配置过滤器链的时候，像下面这样配置即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterAfter(<span class="keyword">new</span> <span class="title class_">JwtFilter</span>(redisTemplate), SecurityContextHolderFilter.class);</span><br></pre></td></tr></table></figure><p>经过上面这样配置之后，JwtFilter 就不存在于原生过滤器链中了，只是单纯的存在于 SecurityFilter 中。</p><p>理解了 Spring Security 原理，那么日常开发中各种奇奇怪怪的情况，我们就都能轻车熟路的解决了。</p><p>如果小伙伴们想要彻底掌握 Spring Security+OAuth2，那么可以看看松哥最近录制的这套全新的视频教程：</p><p><img src="http://img.itboyhub.com/2024/04/20240430095150.png"></p><p>基本上把 Spring Security 的方方面面以及 OAuth2 都讲到了。最重要的是，贴合了很多小伙伴们日常常见的开发场景，比如短信验证码登录、JWT+Redis 登录、微信 OAuth2 登录等等都有讲到。</p><p>这套视频是基于目前最新版的 Spring Security6 录制的，Spring Security6 在 API 层面的变化还是蛮大的，引入了大量的 Lambda 表达式去简化配置，很多旧版的写法在 Spring Security6 中被废弃，并在将来在 Spring Security7 中会移除相关的 API，所以说最近的 Spring Security 更新还是蛮激进的。</p><p>另一方面就是这套视频包含了全新的基于目前最新版 Spring Security 录制的 OAuth2 教程，松哥在 2020 年的时候出过图文版的 OAuth2 教程，但是，现在新版的 OAuth2 也有很多变化，不仅仅是 API 层面的变化，授权模式也发生了一些变化，传统的密码模式、简化模式现在都不再推荐，转而引入了 PKCE 模式，并且利用 OIDC 简化用户信息获取。同时，在 2020 年还处于萌芽状态的 Spring Security OAuth2 Server 这个项目，目前也趋于成熟，也可以直接使用了，这些松哥都在视频中和大家做了详细介绍。在 OAuth2 环节我也和大家分享了如何使用微信的 OAuth2 登录。</p><p>总之这一套教程，让大家彻底理解系统的安全管理。</p><p>之前有小伙伴说我直接自己写过滤器，既灵活还简单。我并不反对这种做法，但是有一个前提就是你很牛，你自己写的过滤器有考虑到计时攻击，有考虑到 XSS 攻击，有考虑到点击劫持，有考虑跨站请求伪造。。。等等太多了。当然，这些问题如果你都没有考虑到，那么 Spring Security 都有帮你考虑到并提供解决方案！</p><p>理解了 Spring Security，再去看市面上其他的安全管理框架，都会豁然开朗。</p><p>不同于松哥之前其他教程的交付方式，这套教程<strong>使用微信群答疑</strong>并且<strong>不再使用一机一码绑定设备播放</strong>，小伙伴们可以在任意设备上登录自己的账号就可以学习了，很便捷。</p><p>下面是两个试看视频：</p><p>这套视频是付费的，<strong>¥499</strong>，有需要的小伙伴加微信备注 <strong>499</strong>。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p><p>最后我再稍微介绍下自己，虽然很多小伙伴已经了解我了：</p><ol><li>技术畅销书作者，出版过两本技术图书，《Spring Boot+Vue全栈开发实战》（清华大学出版社，2019）和《深入浅出 Spring Security》（清华大学出版社，2021）。</li><li>华为云最具价值专家、华为云杰出 MVP、华为开发者社区之星。</li><li>腾讯技术创作营特邀评委、腾讯云金牌讲师。</li><li>GitHub 26k star 项目作者。</li><li>多年一线 coding 经验，有丰富的项目经验和授课经验。</li></ol><p><img src="http://img.itboyhub.com/2022/08/%E7%A8%BF%E5%AE%9A%E8%AE%BE%E8%AE%A1%E5%AF%BC%E5%87%BA-20240215-213838.jpg"></p><p>一个写过 Spring Security 相关图书的人来教你 Spring Security，绝对够专业。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前两天和小伙伴聊了 Spring Security+JWT 实现无状态登录，然后有小伙伴反馈了一个问题，感觉这是一个我们平时写代码容易忽略的问题，写一篇文章和小伙伴们聊一聊。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 如何防止暴力破解？</title>
    <link href="http://www.javaboy.org/2024/0516/spring-security-prevent-attack.html"/>
    <id>http://www.javaboy.org/2024/0516/spring-security-prevent-attack.html</id>
    <published>2024-05-16T12:23:08.000Z</published>
    <updated>2024-12-18T13:01:26.593Z</updated>
    
    <content type="html"><![CDATA[<p>在构建安全的 Web 应用时，防御暴力破解攻击是一个关键的考虑因素。Spring Security 提供了一套灵活的机制来帮助我们实现这一目标。本文将介绍如何使用 Spring Security 来记录失败的登录尝试，并在尝试次数超过一定阈值时封锁攻击者的 IP 地址。</p><span id="more"></span><blockquote><p>亦可基于本文的思路实现封锁攻击者的账号。</p></blockquote><h1 id="一-封装登录计数器"><a href="#一-封装登录计数器" class="headerlink" title="一 封装登录计数器"></a>一 封装登录计数器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginAttemptService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ATTEMPT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loginFailed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">attempts</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        attempts = (Integer) redisTemplate.opsForValue().get(getClientIP());</span><br><span class="line">        <span class="keyword">if</span> (attempts == <span class="literal">null</span>) &#123;</span><br><span class="line">            attempts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        attempts++;</span><br><span class="line">        redisTemplate.opsForValue().set(getClientIP(), attempts);</span><br><span class="line">        redisTemplate.expire(getClientIP(), <span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBlocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">attempts</span> <span class="operator">=</span> (Integer) redisTemplate.opsForValue().get(getClientIP());</span><br><span class="line">        <span class="keyword">return</span> attempts != <span class="literal">null</span> &amp;&amp; attempts &gt;= MAX_ATTEMPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getClientIP</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">xfHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (xfHeader != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> xfHeader.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> request.getRemoteAddr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loginSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.delete(getClientIP());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里核心方法就三个：</p><ol><li>loginFailed：登录失败的时候调用该方法，以当前登录 IP 为 key，在 Redis 上保存登录失败的次数，并设置过期时间为 1 天。</li><li>isBlocked：判断当前登录 IP 是否已经达到最大重试次数，达到了就要禁用该 IP 地址了（禁止时间为 1 天）。</li><li>loginSuccess：登录成功后，清除该 IP 地址登录失败的记录。</li></ol><h1 id="二-监听器"><a href="#二-监听器" class="headerlink" title="二 监听器"></a>二 监听器</h1><p>前面 LoginAttemptService 中的方法，我们分别在登录成功和登录失败的监听器中进行调用。</p><p>首先，我们将创建一个 <code>AuthenticationFailureListener</code>，用于监听认证失败事件，并记录相关 IP 地址的失败尝试次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationFailureListener</span> <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ApplicationListener</span>&lt;AuthenticationFailureBadCredentialsEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginAttemptService loginAttemptService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(AuthenticationFailureBadCredentialsEvent e)</span> &#123;</span><br><span class="line">        loginAttemptService.loginFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来再创建一个登录成功的监听器，用来清除当前 IP 登录失败的次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationSuccessListener</span> <span class="keyword">implements</span></span><br><span class="line">        <span class="title class_">ApplicationListener</span>&lt;AuthenticationSuccessEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginAttemptService loginAttemptService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(AuthenticationSuccessEvent event)</span> &#123;</span><br><span class="line">        loginAttemptService.loginSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 在登录成功或者失败的时候都会自动发布相关事件，我们这里只需要定义监听器就可以获取到事件，相关源码在 ProviderManager#authenticate 方法中，如下：</p><p><img src="http://img.itboyhub.com/2024/04/20240515152855.png"></p><h1 id="三-修改登录逻辑"><a href="#三-修改登录逻辑" class="headerlink" title="三 修改登录逻辑"></a>三 修改登录逻辑</h1><p>在自定义的 <code>UserDetailsService</code> 实现中，我们需要在加载用户详情之前检查请求的 IP 地址是否已被封锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LoginAttemptService loginAttemptService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (loginAttemptService.isBlocked()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;blocked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> User.builder().username(username).password(<span class="string">&quot;&#123;noop&#125;123&quot;</span>).authorities(<span class="string">&quot;admin&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-自定义认证失败处理器"><a href="#四-自定义认证失败处理器" class="headerlink" title="四 自定义认证失败处理器"></a>四 自定义认证失败处理器</h1><p>最后，我们将修改 <code>CustomAuthenticationFailureHandler</code>，以自定义错误消息并通知用户其 IP 已被封锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomAuthenticationFailureHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleUrlAuthenticationFailureHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageSource messages;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginAttemptService loginAttemptService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// ... 错误处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-结论"><a href="#五-结论" class="headerlink" title="五 结论"></a>五 结论</h1><p>通过上述步骤，我们已经在 Spring Security 中实现了一个基本的暴力破解防御机制。不过在实际开发中，我们还可以采用更复杂的策略，如结合验证码、多因素认证等。</p><p>如果小伙伴们想要深入全面的学习 Spring Security，可以看看我最近录的最新版的 Spring Security+OAuth2 视频教程，这是视频目录：</p><p><img src="http://img.itboyhub.com/2024/04/20240430095150.png"></p><p>这套视频教程基本上把 Spring Security 的方方面面以及 OAuth2 都讲到了。最重要的是，贴合了很多小伙伴们日常常见的开发场景，比如短信验证码登录，微信 OAuth2 登录等等都有讲到。</p><p>这套视频是基于目前最新版的 Spring Security6 录制的，Spring Security6 在 API 层面的变化还是蛮大的，引入了大量的 Lambda 表达式去简化配置，很多旧版的写法在 Spring Security6 中被废弃，并在将来在 Spring Security7 中会移除相关的 API，所以说最近的 Spring Security 更新还是蛮激进的。</p><p>另一方面就是这套视频包含了全新的基于目前最新版 Spring Security 录制的 OAuth2 教程，松哥在 2020 年的时候出过图文版的 OAuth2 教程，但是，现在新版的 OAuth2 也有很多变化，不仅仅是 API 层面的变化，授权模式也发生了一些变化，传统的密码模式、简化模式现在都不再支持，转而引入了 PKCE 模式，并且利用 OIDC 简化用户信息获取。同时，在 2020 年还处于萌芽状态的 Spring Security OAuth2 Server 这个项目，目前也趋于成熟，也可以直接使用了，这些松哥都在视频中和大家做了详细介绍。在 OAuth2 环节我也和大家分享了如何使用微信的 OAuth2 登录。</p><p>总之这一套教程，让大家彻底理解系统的安全管理。</p><p>之前有小伙伴说我直接自己写过滤器，既灵活还简单。我并不反对这种做法，但是有一个前提就是你很牛，你自己写的过滤器有考虑到计时攻击，有考虑到 XSS 攻击，有考虑到点击劫持，有考虑跨站请求伪造。。。等等太多了。当然，这些问题如果你都没有考虑到，那么 Spring Security 都有帮你考虑到并提供解决方案！</p><p>理解了 Spring Security，再去看市面上其他的安全管理框架，都会豁然开朗。</p><p>这套教程目前给小伙伴们提供了两个试看视频：</p><p>这套视频是付费的，¥499，有需要的小伙伴加微信备注 <strong>499</strong> 上车。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在构建安全的 Web 应用时，防御暴力破解攻击是一个关键的考虑因素。Spring Security 提供了一套灵活的机制来帮助我们实现这一目标。本文将介绍如何使用 Spring Security 来记录失败的登录尝试，并在尝试次数超过一定阈值时封锁攻击者的 IP 地址。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 如何防止 XSS 攻击</title>
    <link href="http://www.javaboy.org/2024/0515/spring-security-xss.html"/>
    <id>http://www.javaboy.org/2024/0515/spring-security-xss.html</id>
    <published>2024-05-15T12:22:46.000Z</published>
    <updated>2024-12-18T13:01:17.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-引言"><a href="#一-引言" class="headerlink" title="一 引言"></a>一 引言</h1><p>在构建基于 Spring 的 Web 应用时，安全性是一个不可忽视的重要议题。跨站脚本攻击（XSS）是网络应用安全中最为常见的攻击类型之一。在本文中，我们将探讨如何利用 Spring Security 的特性来有效预防 XSS 攻击。</p><span id="more"></span><h1 id="二-理解-XSS-攻击"><a href="#二-理解-XSS-攻击" class="headerlink" title="二 理解 XSS 攻击"></a>二 理解 XSS 攻击</h1><h2 id="2-1-XSS-攻击的定义"><a href="#2-1-XSS-攻击的定义" class="headerlink" title="2.1 XSS 攻击的定义"></a>2.1 XSS 攻击的定义</h2><p>XSS 攻击，即跨站脚本攻击（Cross-Site Scripting），是一种常见的网络攻击手段，攻击者通过在用户浏览的网页中注入恶意脚本，从而控制用户的浏览器进行非法操作。根据存储方式，XSS 攻击可分为两类：</p><ul><li><strong>反射型XSS（Reflected XSS）</strong>：用户提交的不可信数据被 Web 应用即时响应回显，增加了不可信内容到页面中，浏览器会执行这些代码。</li><li><strong>存储型XSS（Stored XSS）</strong>：攻击者的输入被 Web 服务器存储，随后任何访问者都可能执行该恶意代码。</li></ul><p>举个栗子：</p><p>假设一个在线商城网站允许用户在产品页面留下评论。攻击者张三发现了这个功能可以被用于 XSS 攻击，他决定利用这个漏洞。</p><ol><li>反射型XSS攻击案例：张三在评论框中输入以下内容作为他的“评论”：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&#x27;XSS Attack!&#x27;</span>);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当其他用户查看这个评论时，由于网站没有对用户输入进行适当的过滤和转义，页面会执行这段脚本，弹出一个警告框。</p><ol start="2"><li>存储型 XSS 攻击案例：如果网站将张三的评论存储在数据库中，并且在未来对所有查看该产品的用户都显示这条评论，那么这就成了一个存储型 XSS 攻击。这意味着任何访问该页面的用户都会受到 XSS 攻击的影响。</li></ol><h2 id="2-2-防御策略"><a href="#2-2-防御策略" class="headerlink" title="2.2 防御策略"></a>2.2 防御策略</h2><p>防御 XSS 攻击的核心策略是对用户输入进行净化。在 Spring Web 应用中，用户的输入即 HTTP 请求，我们需要检查并清除可能被服务器或浏览器执行的内容。</p><p>一般来说我们可以采取以下措施：</p><ol><li>输入验证： 对所有用户输入进行验证，确保只接受预期的数据格式。</li><li>输出编码： 当将用户输入作为页面内容输出时，必须进行适当的编码处理，以防止脚本执行。</li><li>使用安全框架： 利用 Spring Security 等安全框架提供的工具和配置，增强应用的安全性。</li></ol><h1 id="三-增强-XSS-防护"><a href="#三-增强-XSS-防护" class="headerlink" title="三 增强 XSS 防护"></a>三 增强 XSS 防护</h1><p>Spring Security 默认提供了多种安全相关的 HTTP 头，其中包括 <code>X-XSS-Protection</code> 头。这个头指示浏览器阻止看似 XSS 的尝试。为了激活这个特性，我们需要在 Spring Security 的配置类中配置 XSS 支持。</p><p>此外，内容安全策略（CSP）提供了另一层安全防护，帮助减轻 XSS 和数据注入攻击的风险。通过配置应用返回 <code>Content-Security-Policy</code> 头，我们可以启用 CSP：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConf</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.headers(headers -&gt;</span><br><span class="line">            headers.xssProtection(xss -&gt;</span><br><span class="line">                xss.headerValue(XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK)</span><br><span class="line">            ).contentSecurityPolicy(CSP -&gt; CSP.policyDirectives(<span class="string">&quot;script-src &#x27;self&#x27;&quot;</span>))</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-结语"><a href="#四-结语" class="headerlink" title="四 结语"></a>四 结语</h1><p>通过本文，我们学习了如何利用 Spring Security 中的 <code>xssProtection</code> 特性来预防 XSS 攻击。在 Spring Security 中，类似的防护机制非常多，在我最近的 Spring Security6 视频教程的<strong>第九章</strong>中，我和大家详细介绍了可能存在的网络攻击以及 Spring Security 的应对之法，这些自带的防护机制可以让我们的系统足够安全。</p><p><img src="http://img.itboyhub.com/2024/04/20240430095150.png"></p><p>这套视频教程基本上把 Spring Security 的方方面面以及 OAuth2 都讲到了。最重要的是，贴合了很多小伙伴们日常常见的开发场景，比如短信验证码登录，微信 OAuth2 登录等等都有讲到。</p><p>这套视频是基于目前最新版的 Spring Security6 录制的，Spring Security6 在 API 层面的变化还是蛮大的，引入了大量的 Lambda 表达式去简化配置，很多旧版的写法在 Spring Security6 中被废弃，并在将来在 Spring Security7 中会移除相关的 API，所以说最近的 Spring Security 更新还是蛮激进的。</p><p>另一方面就是这套视频包含了全新的基于目前最新版 Spring Security 录制的 OAuth2 教程，松哥在 2020 年的时候出过图文版的 OAuth2 教程，但是，现在新版的 OAuth2 也有很多变化，不仅仅是 API 层面的变化，授权模式也发生了一些变化，传统的密码模式、简化模式现在都不再支持，转而引入了 PKCE 模式，并且利用 OIDC 简化用户信息获取。同时，在 2020 年还处于萌芽状态的 Spring Security OAuth2 Server 这个项目，目前也趋于成熟，也可以直接使用了，这些松哥都在视频中和大家做了详细介绍。在 OAuth2 环节我也和大家分享了如何使用微信的 OAuth2 登录。</p><p>总之这一套教程，让大家彻底理解系统的安全管理。</p><p>之前有小伙伴说我直接自己写过滤器，既灵活还简单。我并不反对这种做法，但是有一个前提就是你很牛，你自己写的过滤器有考虑到计时攻击，有考虑到 XSS 攻击，有考虑到点击劫持，有考虑跨站请求伪造。。。等等太多了。当然，这些问题如果你都没有考虑到，那么 Spring Security 都有帮你考虑到并提供解决方案！</p><p>理解了 Spring Security，再去看市面上其他的安全管理框架，都会豁然开朗。</p><p>这套教程目前给小伙伴们提供了两个试看视频：</p><p>这套视频是付费的，¥499，有需要的小伙伴加微信备注 <strong>499</strong> 上车。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一-引言&quot;&gt;&lt;a href=&quot;#一-引言&quot; class=&quot;headerlink&quot; title=&quot;一 引言&quot;&gt;&lt;/a&gt;一 引言&lt;/h1&gt;&lt;p&gt;在构建基于 Spring 的 Web 应用时，安全性是一个不可忽视的重要议题。跨站脚本攻击（XSS）是网络应用安全中最为常见的攻击类型之一。在本文中，我们将探讨如何利用 Spring Security 的特性来有效预防 XSS 攻击。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>如何查看 Spring Security 过滤器链？</title>
    <link href="http://www.javaboy.org/2024/0514/spring-security-filter-chain.html"/>
    <id>http://www.javaboy.org/2024/0514/spring-security-filter-chain.html</id>
    <published>2024-05-14T12:22:56.000Z</published>
    <updated>2024-12-18T13:01:23.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-引言"><a href="#一-引言" class="headerlink" title="一 引言"></a>一 引言</h1><p>Spring Security 作为一个强大的安全框架，其核心是基于一系列的 Filter。这些过滤器按照一定的顺序执行，形成了一个过滤器链，每个过滤器负责处理特定的安全任务。在本文中，我们将探讨如何发现和理解 Spring Security 中注册的过滤器。</p><span id="more"></span><h1 id="二-启用安全调试"><a href="#二-启用安全调试" class="headerlink" title="二 启用安全调试"></a>二 启用安全调试</h1><p>要查看 Spring Security 的过滤器链，首先可以通过启用安全调试来实现。这将为每个请求记录详细的安全信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity(debug = true)</span></span><br></pre></td></tr></table></figure><p>启用调试后，服务器接收到请求时会记录所有相关信息，包括完整的安全过滤器链。</p><p><img src="http://img.itboyhub.com/2024/04/20240513120820.png"></p><p>不过这是一个敏感操作，只可以在开发环境下开启，生产环境就不要开启了。</p><h1 id="三-日志记录"><a href="#三-日志记录" class="headerlink" title="三 日志记录"></a>三 日志记录</h1><p>另一种查看注册的 Spring Security 过滤器的方法是通过日志记录。可以通过在 <code>application.properties</code> 中设置日志级别来实现：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.org.springframework.security.web.FilterChainProxy</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure><p>这样，每次请求处理时，控制台都会输出每个过滤器的详细信息。方便我们观察与排查错误：</p><p><img src="http://img.itboyhub.com/2024/04/20240513120944.png"></p><h1 id="四-代码获取过滤器"><a href="#四-代码获取过滤器" class="headerlink" title="四 代码获取过滤器"></a>四 代码获取过滤器</h1><p>除了手动查看日志，我们还可以通过编写代码来程序化地获取注册的过滤器。</p><p>首先，需要注入 <code>springSecurityFilterChain</code> 这个Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;springSecurityFilterChain&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Filter springSecurityFilterChain;</span><br></pre></td></tr></table></figure><p>然后，将该对象转换为 <code>FilterChainProxy</code> 类型，并调用<code>getFilterChains()</code> 方法来获取所有过滤器链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listFilters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FilterChainProxy</span> <span class="variable">filterChainProxy</span> <span class="operator">=</span> (FilterChainProxy) springSecurityFilterChain;</span><br><span class="line">    List&lt;SecurityFilterChain&gt; chains = filterChainProxy.getFilterChains();</span><br><span class="line">    chains.stream()</span><br><span class="line">          .flatMap(chain -&gt; chain.getFilters().stream())</span><br><span class="line">          .forEach(filter -&gt; System.out.println(filter.getClass().getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，将输出所有注册的过滤器的类名。</p><h1 id="五-重要过滤器"><a href="#五-重要过滤器" class="headerlink" title="五 重要过滤器"></a>五 重要过滤器</h1><p>在 Spring Security 中，有几个过滤器扮演着特别重要的角色：</p><ul><li><strong>UsernamePasswordAuthenticationFilter</strong>：处理用户登录认证。</li><li><strong>AnonymousAuthenticationFilter</strong>：在没有认证对象的情况下创建匿名认证，既匿名用户也是用户的一种。</li><li><strong>AuthorizationFilter</strong>：当访问被拒绝时抛出异常（旧版是 FilterSecurityInterceptor）。</li><li><strong>ExceptionTranslationFilter</strong>：捕获 Spring Security 的异常。</li></ul><h1 id="六-结论"><a href="#六-结论" class="headerlink" title="六 结论"></a>六 结论</h1><p>通过本文，我们学习了如何通过不同的方法来发现 Spring Security 中注册的过滤器，包括启用安全调试、日志记录以及程序化获取。这些方法可以帮助开发者更好地理解和配置 Spring Security 的过滤器链。</p><p>如果小伙伴们想要深入全面的学习 Spring Security，可以看看我最近录的最新版的 Spring Security+OAuth2 视频教程，这是视频目录：</p><p><img src="http://img.itboyhub.com/2024/04/20240430095150.png"></p><p>这套视频教程基本上把 Spring Security 的方方面面以及 OAuth2 都讲到了。最重要的是，贴合了很多小伙伴们日常常见的开发场景，比如短信验证码登录，微信 OAuth2 登录等等都有讲到。</p><p>这套视频是基于目前最新版的 Spring Security6 录制的，Spring Security6 在 API 层面的变化还是蛮大的，引入了大量的 Lambda 表达式去简化配置，很多旧版的写法在 Spring Security6 中被废弃，并在将来在 Spring Security7 中会移除相关的 API，所以说最近的 Spring Security 更新还是蛮激进的。</p><p>另一方面就是这套视频包含了全新的基于目前最新版 Spring Security 录制的 OAuth2 教程，松哥在 2020 年的时候出过图文版的 OAuth2 教程，但是，现在新版的 OAuth2 也有很多变化，不仅仅是 API 层面的变化，授权模式也发生了一些变化，传统的密码模式、简化模式现在都不再支持，转而引入了 PKCE 模式，并且利用 OIDC 简化用户信息获取。同时，在 2020 年还处于萌芽状态的 Spring Security OAuth2 Server 这个项目，目前也趋于成熟，也可以直接使用了，这些松哥都在视频中和大家做了详细介绍。在 OAuth2 环节我也和大家分享了如何使用微信的 OAuth2 登录。</p><p>总之这一套教程，让大家彻底理解系统的安全管理。</p><p>之前有小伙伴说我直接自己写过滤器，既灵活还简单。我并不反对这种做法，但是有一个前提就是你很牛，你自己写的过滤器有考虑到计时攻击，有考虑到 XSS 攻击，有考虑到点击劫持，有考虑跨站请求伪造。。。等等太多了。当然，这些问题如果你都没有考虑到，那么 Spring Security 都有帮你考虑到并提供解决方案！</p><p>理解了 Spring Security，再去看市面上其他的安全管理框架，都会豁然开朗。</p><p>这套教程目前给小伙伴们提供了两个试看视频：</p><p>这套视频是付费的，¥499，有需要的小伙伴加微信备注 <strong>499</strong> 上车。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一-引言&quot;&gt;&lt;a href=&quot;#一-引言&quot; class=&quot;headerlink&quot; title=&quot;一 引言&quot;&gt;&lt;/a&gt;一 引言&lt;/h1&gt;&lt;p&gt;Spring Security 作为一个强大的安全框架，其核心是基于一系列的 Filter。这些过滤器按照一定的顺序执行，形成了一个过滤器链，每个过滤器负责处理特定的安全任务。在本文中，我们将探讨如何发现和理解 Spring Security 中注册的过滤器。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
    <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
</feed>
