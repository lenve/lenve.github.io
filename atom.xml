<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-06-08T01:39:59.236Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot+CAS 默认登录页面太丑了，怎么办？</title>
    <link href="http://www.javaboy.org/2020/0608/cas-login-page.html"/>
    <id>http://www.javaboy.org/2020/0608/cas-login-page.html</id>
    <published>2020-06-08T01:38:14.000Z</published>
    <updated>2020-06-08T01:39:59.236Z</updated>
    
    <content type="html"><![CDATA[<p>松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><a id="more"></a><p>最近的又一头扎进 Spring Security+CAS 上面了，CAS 单点登录已经连续写了四篇了，小伙伴们一定按顺序阅读哦，这样后面的文章才好理解。</p><p><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">上篇文章</a>和大家分享了 CAS Server 接入数据库的问题，今天我们来看下如何在 CAS Server 上自定义登录页面，因为正常来说，我们是不会直接用官方给出的登录页面的。</p><p>本文是 Spring Security 系列第 26 篇，阅读前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li></ol><h2 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h2><p>CAS Server 对于自定义登录页面其实提供了很好的支持，可以从多个角度来实现，松哥分别来和大家介绍。</p><p>CAS Server 上提供的登录页面，早期是用 jsp 写的，我们用的 5.3.2 版本里是用 Thymeleaf 写的，所以现在自定义登录页面也是用 Thymeleaf 来写。</p><p>想要自定义登录页面，我们有两种不同的方式：</p><ol><li>直接修改源码，位置在 overlays/org.apereo.cas.cas-server-webapp-tomcat-5.3.14/WEB-INF/classes/templates/casLoginView.html，直接就在它的源码基础上改，这个可以实现需求，但是一般不推荐。</li><li>把自定义的登录页面当成 theme 来开发，然后在配置文件中配置 theme，这种方式就很灵活，而且既可以配置全局主题，也可以配置局部主题。全局主题就是所有的登录页面都使用自定义的登录页面，局部主题则是可以根据不同的 CAS Client 来配置，不同的 CAS Client 将看到不同的登录页面。</li></ol><p>松哥在这里主要和大家介绍第二种方式。</p><h2 id="2-自定义登录页面"><a href="#2-自定义登录页面" class="headerlink" title="2.自定义登录页面"></a>2.自定义登录页面</h2><p>首先我们需要提前准备好自己的登录页面，松哥这里还是使用我本系列前面用过的登录页面：</p><p><img src="http://img.itboyhub.com/2020/05/20200528161117.png" alt></p><p>这个大家可以在文末下载页面模版，也可以自己找一个喜欢的登录页面模版，是在找不到，随便写个表单也行，只要实现了自定义的效果即可。</p><p>自定义的登录页面准备好之后，接下来，我们创建一个新的目录 src/main/resources/static/themes/mylogin，将自定义页面涉及到的静态资源文件拷贝进去，这里的 themes 目录下专门放置各种自定义登录页面的静态资源，mylogin 相当于是我当前使用的主题名称：</p><p><img src="http://img.itboyhub.com/2020/05/20200528161516.png" alt></p><p>接下来创建 src/main/resources/mylogin.properties 文件，将登录页面中的一些 js、css 引用配置进去，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylogin.css.style=/themes/mylogin/css/style.css</span><br><span class="line">mylogin.css.fa=/themes/mylogin/css/font-awesome-4.7.0/css/font-awesome.min.css</span><br><span class="line">mylogin.js.jq=/themes/mylogin/js/jquery.min.js</span><br><span class="line">mylogin.js.index=/themes/mylogin/js/index.js</span><br></pre></td></tr></table></figure><p>我的自定义登录页面里边就这四个引用，如果你有更多的引用，就在这里多配置即可，这里的 key 可以自定义，value 就是静态资源的位置。</p><p>接下来，创建 src/main/resources/templates/mylogin/casLoginView.html 文件，casLoginView.html 就是你的登录页面，注意文件名不能写错。Thymeleaf 模版默认是在 templates 目录下，所以我们要在 resources 目录下新建 templates 目录，templates 目录下再新建 mylogin 目录。</p><p>casLoginView.html 页面内容如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>江南一点雨<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;$&#123;#themes.code('mylogin.css.fa')&#125;&#125;"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@&#123;$&#123;#themes.code('mylogin.css.style')&#125;&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"materialContainer"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>统一认证中心<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">"$&#123;credential&#125;"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"login"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"username"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"username"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"password"</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"password"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"execution"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;flowExecutionKey&#125;"</span>/&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"_eventId"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"submit"</span>/&gt;</span></span><br><span class="line">                        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"geolocation"</span>/&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button login"</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">                    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pass-forgot"</span>&gt;</span>忘记密码？<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"overbox"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"material-button alt-2"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"shape"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>江南一点雨-注册<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"regname"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"regname"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"regname"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"regpass"</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"regpass"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"regpass"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"reregpass"</span>&gt;</span>确认密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"reregpass"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"reregpass"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;$&#123;#themes.code('mylogin.js.jq')&#125;&#125;"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@&#123;$&#123;#themes.code('mylogin.js.index')&#125;&#125;"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就是一个普通的登录页面，我只是把 js 和 css 的引用修改了下而已，所以这里也就不做过多介绍。</p><p>OK，如此之后，我们的登录页面就算定义好了，接下来就是登录页面的引用了。</p><p>登录页面引用，我们有两种方式：</p><p>第一种是全剧配置，直接在 application.properties 中添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas.theme.defaultThemeName=mylogin</span><br></pre></td></tr></table></figure><p>mylogin 就是我们在前面反复出现的目录，相当于是我的主题名。这个配置完成后，以后不管是直接在 CAS Server 上登录，还是从 CAS Client 跳转到 CAS Server 上登录，看到的都是自定义登录页面。</p><p>第二种方式则是局部配置，局部配置针对某一个 CAS Client 的配置，所以我们可以在 src/main/resources/services/client1-99.json 文件中（复习前面文章就知道该文件怎么来的）添加 theme 配置：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"@class"</span>: <span class="hljs-string">"org.apereo.cas.services.RegexRegisteredService"</span>,</span><br><span class="line">  <span class="hljs-attr">"serviceId"</span>: <span class="hljs-string">"^(https|http)://.*"</span>,</span><br><span class="line">  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"client1"</span>,</span><br><span class="line">  <span class="hljs-attr">"id"</span>: <span class="hljs-number">99</span>,</span><br><span class="line">  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"应用1 的定义信息"</span>,</span><br><span class="line">  <span class="hljs-attr">"evaluationOrder"</span>: <span class="hljs-number">1</span>,</span><br><span class="line">  <span class="hljs-attr">"theme"</span>: <span class="hljs-string">"mylogin"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，以后如果是通过<strong>该</strong> CAS Client 跳转到 CAS Server 上登录，则会看到自定义登录页面，如果通过其他 CAS Client 或者直接就在 CAS Server 上登录，则看到的还是默认登录页面，当然我们也可以给其他 CAS Client 再去定义它自己的登录页面。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好了，这就是松哥和大家介绍的 CAS 单点登录自定义登录页面的问题，感兴趣的小伙伴可以试试～</p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&amp;gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot+Vue+微人事视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="CAS" scheme="http://www.javaboy.org/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>我为什么要出一套免费视频教程</title>
    <link href="http://www.javaboy.org/2020/0607/ssm-video.html"/>
    <id>http://www.javaboy.org/2020/0607/ssm-video.html</id>
    <published>2020-06-07T01:37:50.000Z</published>
    <updated>2020-06-08T01:40:28.374Z</updated>
    
    <content type="html"><![CDATA[<p>是的，你没看错，松哥要推出一套<strong>免费视频</strong>教程了。</p><a id="more"></a><p>新出的免费视频估计有的小伙伴可能已经看上了，有的小伙伴可能还不知道，因此今天我就在这里和大家聊一下。</p><p>做免费视频的想法由来已久，但是迟迟没有下定决心，主要有以下两方面的原因：</p><ol><li>工作比较忙，每天还要写原创技术文章，剩下的时间非常有限，而视频的录制需要前期准备、录制、后期剪辑等等，还是一个很耗时的事情。</li><li>网络上批小将太多，免费视频没有门槛，会招致更多的批小将，因此一直比较犹豫。</li></ol><p>由于这两方面的原因，做免费视频的事被我从过年一直拖到现在。中途也曾一度录过一两集，但是因为实在忙不过来后期基本上都烂尾了。所以最近作出这个决定我下了很大决心，今天把话撂在这，也算是给自己一点压力，免费视频争取不要烂尾。</p><h3 id="1-我为什么要录免费视频"><a href="#1-我为什么要录免费视频" class="headerlink" title="1.我为什么要录免费视频"></a>1.我为什么要录免费视频</h3><p>松哥从大二开始自学 Java，大学毕业后顺利入坑，自学之路还是蛮艰辛的。所以我深知大家在自学时面临的两个问题：</p><ol><li>学习顺序</li><li>学习资料</li></ol><p>首先是不知道学什么，这个我之前已经总结了 Java 升级路线图（<a href="https://mp.weixin.qq.com/s/rBRFL2UcDKWB-bHp324mCw" target="_blank" rel="noopener">Java 打怪升级路线图</a>），大家可以参考。</p><p>第二个就是学习资料的问题，虽然现在网上的资料多如牛毛，但是很多时候我们缺的不是一个资料，<strong>我们缺的是一个从头到尾连贯的、系统的资料</strong>，经常是这个人讲的看了一点，那个人讲的看了一点，想头到尾看一个人讲，发现几乎没有这样的资源。</p><p>如果是一个人来讲，知识是连贯的，什么东西讲过，什么东西没讲过，他心里有数，这样大家的学习的时候就不会觉得突兀，比如突然蹦出来一个你从来没听说过的知识点，一个人讲的话，就不会发生这种事情。</p><p>而我从去年七月份开始录制视频以来，被小伙伴们一顿夸，夸的我有点膨胀，所以一直想自己搞一套成体系的课程。松哥之前在网上搜集了超 2TB 的 Java 学习资源（公众号后台回复 2TB 可以获取），但是这些都是别人录制的，现在我也想自己录制一套连贯的、成体系的课程，因为我有信心能够做的更好。</p><h3 id="2-免费视频都录啥"><a href="#2-免费视频都录啥" class="headerlink" title="2.免费视频都录啥"></a>2.免费视频都录啥</h3><p>考虑到松哥之前已经有付费视频了（<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">松哥自制四套视频教程已经杀青，视频常见问题梳理</a>），所以这次的免费视频内容不会和付费视频内容有交叉，也不会重叠，也就是说，免费视频和<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">付费视频</a>内容上不会冲突，这点请大家放心。</p><p>我目前的计划是这样：</p><ol><li>针对刚刚入门的小伙伴出一套<strong>入门级</strong>的 SSM 课程，这套视频会相当简单，只要你有 Java Web 基础就能学。</li><li>出一个入门级的项目（非前后端分离），大概率是以我 GitHub 上的 CoolMeeting(<a href="https://github.com/lenve/CoolMeeting" target="_blank" rel="noopener">https://github.com/lenve/CoolMeeting</a>) 为例来讲解。</li><li>前两个讲完之后，接下来会出一个进阶的课程，进阶课程主要是讲解 Spring 的源码，这块我已经研究了很长时间了，是时候和大家见面了。</li><li>前三个讲完之后。。。再说吧，现在还没想好，一步一步来。</li></ol><p>这就是目前暂定的视频录制计划。<strong>前期的视频主要面向初学者，源码解读会面向有开发经验的小伙伴。</strong></p><p>那么目前已经更新了哪些视频呢？Spring 【基础篇】刚刚制作完毕！给大家看一下目录：</p><p><img src="http://img.itboyhub.com/2020/06/20200606211611.png" alt></p><p>免费视频我会上传到年轻人的学习圣地 B 站上，大家在 B 站搜索<strong>江南一点雨</strong>就可以看到，或者扫描下面的二维码找到松哥：</p><p><img src="http://img.itboyhub.com/2020/06/20200606212723.png" alt></p><p>松哥毕竟是一个人利用业余时间做这件事，没有团队，宣传力度也不能跟一些公司比，但是这些不足并不会影响视频的内容，我还是会认认真真做一套对初学者有用的课程。小伙伴们如果身边有人想学习 Java ，不妨推荐一下松哥的视频给他们，我一定不会让大家失望！</p><p>大家看了免费的视频，如果觉得松哥的讲课风格还能接受，也可以考虑一下付费视频哦：<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">松哥自制四套视频教程已经杀青，视频常见问题梳理</a>。松哥上周末为最近连载的 Spring Security 系列也录制了一套视频，放在 Spring Boot 第十章安全管理里边，感兴趣的小伙伴不要错过呀。</p><p>点击文末的阅读原文，开启 coding 之路吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是的，你没看错，松哥要推出一套&lt;strong&gt;免费视频&lt;/strong&gt;教程了。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
      <category term="视频" scheme="http://www.javaboy.org/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+CAS 单点登录，如何对接数据库？</title>
    <link href="http://www.javaboy.org/2020/0605/springsecurity-cas-mysql.html"/>
    <id>http://www.javaboy.org/2020/0605/springsecurity-cas-mysql.html</id>
    <published>2020-06-05T14:47:22.000Z</published>
    <updated>2020-06-05T15:08:59.876Z</updated>
    
    <content type="html"><![CDATA[<p>松哥给最近连载的 Spring Security 系列也录制了视频教程，感兴趣的小伙伴请戳这里-&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a>（Spring Boot 第十章就是 Spring Security）。</p><a id="more"></a><p>在前面的两篇文章中，松哥和大家分享了 CAS Server 的搭建以及如何使用 Spring Security 搭建 CAS Client。</p><p>但是前面的案例有一个问题，就是登录用户是在 CAS Server 配置文件中写死的，没有对接数据库，实际项目中，这里肯定要对接数据库，所以今天，松哥就来和大家聊一聊 CAS Server 如何对接数据库。</p><p>松哥最近和 Spring Security 杠上了，这是 Spring Security 系列的第 25 篇：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li></ol><h2 id="1-整体思路"><a href="#1-整体思路" class="headerlink" title="1.整体思路"></a>1.整体思路</h2><p>先来看整体思路。</p><p>我们用 CAS Server 做单点登录，CAS Server 主要是负责认证的，也就是它主要解决登录问题。登录成功之后，还有一个权限处理的问题，权限的问题则交由各个 CAS Client 自行处理，并不在 CAS Server 中完成。</p><p>在上篇文章中，松哥有教过大家定义 UserDetailsService，不知道大家是否还记得如下代码（忘记了可以参考上篇文章：<a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a>）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Primary</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(s, <span class="hljs-string">"123"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>,</span><br><span class="line">                AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_user"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是在什么时候执行呢？</p><p>如果我们没有使用 CAS 这一套的话，这段代码当然是在用户登录的时候执行，用户登录时，从数据库中查询用户的信息，然后做校验（参考本系列前面文章就懂）。</p><p>如果我们使用 CAS 这一套，用户登录的校验将在 CAS Server 上执行，CAS Client 就不用做校验工作了，但是为什么我们还需要定义 UserDetailsService 呢？这是为了当用户在 CAS Server 上登录成功之后，拿着用户名回到 CAS Client，然后我们再去数据库中根据用户名获取用户的详细信息，包括用户的角色等，进而在后面的鉴权中用上角色。</p><p>好了，这是我们一个大致的思路，接下来我们来看具体实现。</p><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><p>接下来的配置在 <a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a> 一文的基础上完成，所以还没看前面文章的小伙伴建议先看一下哦。</p><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><p>首先我们先在数据库中准备一下用户表、角色表以及用户角色关联表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`t_role`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`name_zh`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`t_user`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`account_non_expired`</span> <span class="hljs-built_in">bit</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`account_non_locked`</span> <span class="hljs-built_in">bit</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`credentials_non_expired`</span> <span class="hljs-built_in">bit</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`enabled`</span> <span class="hljs-built_in">bit</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`password`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`t_user_roles`</span> (</span><br><span class="line">  <span class="hljs-string">`t_user_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`roles_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`FKj47yp3hhtsoajht9793tbdrp4`</span> (<span class="hljs-string">`roles_id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`FK7l00c7jb4804xlpmk1k26texy`</span> (<span class="hljs-string">`t_user_id`</span>),</span><br><span class="line">  <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-string">`FK7l00c7jb4804xlpmk1k26texy`</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`t_user_id`</span>) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">`t_user`</span> (<span class="hljs-string">`id`</span>),</span><br><span class="line">  <span class="hljs-keyword">CONSTRAINT</span> <span class="hljs-string">`FKj47yp3hhtsoajht9793tbdrp4`</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`roles_id`</span>) <span class="hljs-keyword">REFERENCES</span> <span class="hljs-string">`t_role`</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`t_role`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`name_zh`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-string">'ROLE_admin'</span>,<span class="hljs-string">'管理员'</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">'ROLE_user'</span>,<span class="hljs-string">'普通用户'</span>);</span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`t_user`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`account_non_expired`</span>, <span class="hljs-string">`account_non_locked`</span>, <span class="hljs-string">`credentials_non_expired`</span>, <span class="hljs-string">`enabled`</span>, <span class="hljs-string">`password`</span>, <span class="hljs-string">`username`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,<span class="hljs-string">'123'</span>,<span class="hljs-string">'javaboy'</span>),(<span class="hljs-number">2</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,b<span class="hljs-string">'1'</span>,<span class="hljs-string">'123'</span>,<span class="hljs-string">'江南一点雨'</span>);</span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`t_user_roles`</span> (<span class="hljs-string">`t_user_id`</span>, <span class="hljs-string">`roles_id`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-CAS-Server"><a href="#2-2-CAS-Server" class="headerlink" title="2.2 CAS Server"></a>2.2 CAS Server</h3><p>然后我们要在 CAS Server 的 pom.xml 文件中添加两个依赖：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cas-server-support-jdbc-drivers&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apereo.cas&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cas-server-support-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;cas.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注意这里不用添加数据库驱动，系统会自动解决。</p><p>添加完成之后，再在 src/main/resources/application.properties 文件中添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cas.authn.jdbc.query[0].url=jdbc:mysql://127.0.0.1:3306/withjpa?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;useSSL=false</span><br><span class="line">cas.authn.jdbc.query[0].user=root</span><br><span class="line">cas.authn.jdbc.query[0].password=123</span><br><span class="line">cas.authn.jdbc.query[0].sql=select * from t_user where username=?</span><br><span class="line">cas.authn.jdbc.query[0].fieldPassword=password</span><br><span class="line">cas.authn.jdbc.query[0].driverClass=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><ul><li>前三行配置是数据库基本连接配置，这个无需我多说。</li><li>第四行表示配置用户查询 sql，根据用户名查询出用户的所有信息。</li><li>第五行表示数据库中密码的字段名字是什么。</li><li>第六行是数据库驱动。</li></ul><p>OK，配置完成后，接下来我们就来重启 CAS Server：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh run</span><br></pre></td></tr></table></figure><p>启动成功后，浏览器输入 <a href="https://cas.javaboy.org:8443/cas/login" target="_blank" rel="noopener">https://cas.javaboy.org:8443/cas/login</a> 就可以进入登录页面了（注意是 https 哦）：</p><p><img src="http://img.itboyhub.com/2020/05/20200523220157.png" alt></p><p>此时登录用户名就是 javaboy，密码是 123。</p><h3 id="2-3-CAS-Client"><a href="#2-3-CAS-Client" class="headerlink" title="2.3 CAS Client"></a>2.3 CAS Client</h3><p>接下来我们再来看看 CAS Client 要做哪些完善。</p><p>接下来的配置在 <a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a> 一文的基础上完成，所以还没看前面文章的小伙伴建议先看一下哦。</p><p>同时，为了案例简洁，我这里使用 JPA 来操作数据库，要是大家不熟悉这块的操作，可以参考本系列之前的文章：<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a>。</p><p>CAS Client 中的对接主要是实现 UserDetailsService 接口。这里要用到数据库查询，所以我们首先添加数据库相关依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 application.properties 中配置数据库连接信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="hljs-number">123</span></span><br><span class="line">spring.datasource.url=jdbc:mysql:<span class="hljs-comment">///withjpa?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line">spring.jpa.database=mysql</span><br><span class="line">spring.jpa.database-platform=mysql</span><br><span class="line">spring.jpa.hibernate.ddl-auto=update</span><br><span class="line">spring.jpa.show-sql=<span class="hljs-keyword">true</span></span><br><span class="line">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect</span><br></pre></td></tr></table></figure><p>都是常规配置，我们就不再重复解释了。</p><p>接下来我们创建两个实体类，分别表示用户角色了用户类：</p><p>用户角色：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Entity</span>(name = <span class="hljs-string">"t_role"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> String nameZh;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实体类用来描述用户角色信息，有角色 id、角色名称（英文、中文），@Entity 表示这是一个实体类，项目启动后，将会根据实体类的属性在数据库中自动创建一个角色表。</p><p>用户实体类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Entity</span>(name = <span class="hljs-string">"t_user"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> accountNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> accountNonLocked;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> credentialsNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enabled;</span><br><span class="line">    <span class="hljs-meta">@ManyToMany</span>(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST)</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (Role role : getRoles()) &#123;</span><br><span class="line">            authorities.add(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(role.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> accountNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> accountNonLocked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> credentialsNonExpired;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> enabled;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//省略其他 get/set 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户实体类主要需要实现  UserDetails 接口，并实现接口中的方法。</p><p>这里的字段基本都好理解，几个特殊的我来稍微说一下：</p><ol><li>accountNonExpired、accountNonLocked、credentialsNonExpired、enabled 这四个属性分别用来描述用户的状态，表示账户是否没有过期、账户是否没有被锁定、密码是否没有过期、以及账户是否可用。</li><li>roles 属性表示用户的角色，User 和 Role 是多对多关系，用一个 @ManyToMany 注解来描述。</li><li>getAuthorities 方法返回用户的角色信息，我们在这个方法中把自己的 Role 稍微转化一下即可。</li></ol><p>数据模型准备好之后，我们再来定义一个 UserDao：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">findUserByUsername</span><span class="hljs-params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的东西很简单，我们只需要继承 JpaRepository 然后提供一个根据 username 查询 user 的方法即可。如果小伙伴们不熟悉 Spring Data Jpa 的操作，可以在公众号后台回复 springboot 获取松哥手敲的 Spring Boot 教程，里边有 jpa 相关操作，也可以看看松哥录制的视频教程：<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue 系列视频教程</a>。</p><p>在接下来定义 UserService ，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Primary</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        User user = userDao.findUserByUsername(username);</span><br><span class="line">        <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UsernameNotFoundException(<span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自己定义的 UserDetailsServiceImpl 需要实现 UserDetailsService 接口，实现该接口，就要实现接口中的方法，也就是 loadUserByUsername。</p><p>OK ，如此之后，我们的 CAS Client 现在就开发完成了，接下来启动 CAS Client，启动成功后，浏览器输入 <code>http://client1.cas.javaboy.org:8080/user/hello</code> 访问 hello 接口，此时会自动跳转到 CAS Server 上登录，登录的用户名密码就是我们存储在数据库中的用户名密码。登录成功之后，经过两个重定向，会重新回到 hello 接口。</p><p>hello 接口访问成功之后，再去访问 <code>/user/hello</code> 接口，就会发现权限配置也生效了。</p><p>这里比较简单，我就不给大家截图了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，今天主要和小伙伴们分享了一下 Spring Security + CAS 单点登录中，如何使用本地数据库。一个核心的思路是，认证由 CAS Server 来做，权限相关的操作，则还是由 Spring Security 来完成。</p><p>好了 ，本文就说到这里，本文相关案例我已经上传到 GitHub ，大家可以自行下载:<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>好啦，小伙伴们如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥给最近连载的 Spring Security 系列也录制了视频教程，感兴趣的小伙伴请戳这里-&amp;gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot+Vue+微人事视频教程&lt;/a&gt;（Spring Boot 第十章就是 Spring Security）。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="CAS" scheme="http://www.javaboy.org/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 实现单点登录的第三种方案！</title>
    <link href="http://www.javaboy.org/2020/0604/springsecurity-cas.html"/>
    <id>http://www.javaboy.org/2020/0604/springsecurity-cas.html</id>
    <published>2020-06-04T14:47:12.000Z</published>
    <updated>2020-06-05T15:08:50.033Z</updated>
    
    <content type="html"><![CDATA[<p>松哥周末抽空给 Spring Security 系列也录制了一套视频，目录如下：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/05/springboot/20200531234416.png" alt></p><p>感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><p>来看今天的文章。</p><p>前面松哥发过两篇文章，也是两种方案，讲到单点登录问题：</p><ul><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">OAuth2+JWT 方案</a></li><li><a href="https://mp.weixin.qq.com/s/EyAMTbKPqNNnEtZACIsMVw" target="_blank" rel="noopener">@EnableOAuth2Sso 注解方案</a></li></ul><p>今天再来和大家介绍第三种方案，使用 Spring Security 开发 CAS 单点登录系统客户端。</p><p><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">上篇文章</a>讲了 CAS 单点登录以及 CAS Server 的搭建问题，CAS Server 搭建好了，接下来我们要搭建具体的应用，本文我们就来看看 Spring Security+CAS 如何实现单点登录。</p><p>本文在<a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">上篇文章</a>的基础上继续完成，如果小伙伴们的 CAS Server 还没搭建成功，可以参考<a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">上篇文章</a>。</p><p>本文是 Spring Security 系列第 24 篇，阅读本系列前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">聊一聊 Spring Boot 中的 CAS 单点登录</a></li></ol><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>准备工作主要做两件事。</p><h3 id="1-1-服务记录"><a href="#1-1-服务记录" class="headerlink" title="1.1 服务记录"></a>1.1 服务记录</h3><p>某一个 Client 需要接入 CAS Server 进行验证，则该 Client 必须提前在 CAS Server 上配置其信息。</p><p>这个信息既可以动态添加，也可以通过 JSON 来配置，后面松哥会教搭建如何动态添加，这里方便起见，我们还是通过 JSON 来进行配置。</p><p>具体配置方式如下，在 CAS Server 中创建如下目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src/main/resources/services</span><br></pre></td></tr></table></figure><p>在该目录下创建一个名为 client1-99.json 的文件，client1 表示要接入的 client 的名字，99 表示要接入的 client 的 id，json 文件内容如下（这个配置可以参考官方给出的模版：overlays/org.apereo.cas.cas-server-webapp-tomcat-5.3.14/WEB-INF/classes/services/Apereo-10000002.json）：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="hljs-attr">"@class"</span>: <span class="hljs-string">"org.apereo.cas.services.RegexRegisteredService"</span>,</span><br><span class="line">  <span class="hljs-attr">"serviceId"</span>: <span class="hljs-string">"^(https|http)://.*"</span>,</span><br><span class="line">  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"client1"</span>,</span><br><span class="line">  <span class="hljs-attr">"id"</span>: <span class="hljs-number">99</span>,</span><br><span class="line">  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"应用1 的定义信息"</span>,</span><br><span class="line">  <span class="hljs-attr">"evaluationOrder"</span>: <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段 JSON 配置含义如下：</p><ol><li>@calss 指定注册服务类，这个是固定的org.apereo.cas.services.RegexRegisteredService。</li><li>serviceId 则通过正则表达式用来匹配具体的请求。</li><li>name 是接入的 client 的名称。</li><li>id 是接入的 client 的 id。</li><li>description 是接入的 client 的描述信息。</li><li>evaluationOrder 则指定了执行的优先级。</li></ol><p>接下来再在 src/main/resources/application.properties 文件中配置刚刚 json 的信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cas.serviceRegistry.json.location=classpath:/services</span><br><span class="line">cas.serviceRegistry.initFromJson=true</span><br></pre></td></tr></table></figure><p>这里有两行配置：</p><ol><li>指定配置 JSON 文件的位置。</li><li>开启 JSON 识别。</li></ol><p>OK，配置完成后，重启 CAS Server。</p><p>CAS Server 启动成功后，我们在控制台看到如下日志，表示 JSON 配置已经加载成功了：</p><p><img src="http://img.itboyhub.com/2020/05/20200524112747.png" alt></p><h3 id="1-2-JDK-证书"><a href="#1-2-JDK-证书" class="headerlink" title="1.2 JDK 证书"></a>1.2 JDK 证书</h3><p>第二个要提前准备的东西就是 JDK 证书。</p><p>在实际开发中，这一步可以忽略，但是因为我们现在用的自己生成的 SSL 证书，所以我们要将自己生成的证书导入到 JDK 中，否则在使用 Spring Security 接入 CAS 单点登录时，会抛出如下错误：</p><p><img src="http://img.itboyhub.com/2020/05/20200526162719.png" alt></p><p>将 SSL 证书导入 JDK 中的命令其实也很简单，两个步骤，第一个导出 <code>.cer</code> 文件，第二步，导入 JDK，命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -trustcacerts -alias casserver -file ./cas.cer -keystore ./keystore</span><br><span class="line">sudo keytool -import -trustcacerts -alias casserver -file ./cas.cer -keystore /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home/lib/security/cacerts</span><br></pre></td></tr></table></figure><p>注意，在执行 export 导出命令时，需要输入密钥口令，这个口令就是自己一开始创建 SSL 证书时设置的。在执行 import 导入命令时，也需要输入口令，这个口令是 changeit，注意，不是自己一开始设置的。</p><p>密钥库的位置在 JDK 目录下的 <code>/lib/security/cacerts</code>，小伙伴们根据自己实际情况来修改（在 JDK9 之前，位置在 <code>jre/lib/security/cacerts</code>）。</p><p>我们在本地测试一定要导入证书到 JDK 证书库中，否则后面的测试会出现上图中的错误，证书导入 JDK 证书库之后，要确保之后的开发中，使用的是本地的 JDK。</p><p><strong>注意，JDK 证书导入之后，CASServer 需要重启一下。</strong></p><h3 id="1-3-修改-hosts"><a href="#1-3-修改-hosts" class="headerlink" title="1.3 修改 hosts"></a>1.3 修改 hosts</h3><p>另外，我们还需要修改电脑 hosts 文件，因为前面关于 CAS Server，关于 SSL 证书的配置都涉及到域名，所以后面的访问我们将通过域名的形式访问，hosts 文件中添加如下两条记录：</p><p><img src="http://img.itboyhub.com/2020/05/20200526192403.png" alt></p><p>第一个是 CAS Server 的请求域名，第二个是 CAS Client 的请求域名。</p><h2 id="2-开发-Client"><a href="#2-开发-Client" class="headerlink" title="2.开发 Client"></a>2.开发 Client</h2><p>在使用 Spring Security 开发 CAS Client 之前，有一个基本问题需要先和小伙伴们捋清楚：用户登录是在 CAS Server 上登录，所以 Spring Security 中虽然依旧存在用户的概念，但是对于用户的处理逻辑会和前面的有所不同。</p><p>好了，接下来我们来看下具体步骤。</p><p>首先我们来创建一个普通的 Spring Boot 项目，加入 Web 依赖 和 Spring Security 依赖，如下：</p><p><img src="http://img.itboyhub.com/2020/05/20200526192109.png" alt></p><p>项目创建成功后，我们再来手动加入 cas 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-cas<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，在 application.properties 中配置 CAS Server 和 CAS Client 的请求地址信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cas.server.prefix=https://cas.javaboy.org:8443/cas</span><br><span class="line">cas.server.login=$&#123;cas.server.prefix&#125;/login</span><br><span class="line">cas.server.logout=$&#123;cas.server.prefix&#125;/logout</span><br><span class="line"></span><br><span class="line">cas.client.prefix=http://client1.cas.javaboy.org:8080</span><br><span class="line">cas.client.login=$&#123;cas.client.prefix&#125;/login/cas</span><br><span class="line">cas.client.logoutRelative=/logout/cas</span><br><span class="line">cas.client.logout=$&#123;cas.client.prefix&#125;$&#123;cas.client.logoutRelative&#125;</span><br></pre></td></tr></table></figure><p>这些配置都是自定义配置，所以配置的 key 可以自己随意定义。至于配置的含义都好理解，分别配置了 CAS Server 和 CAS Client 的登录和注销地址。</p><p>配置好之后，我们需要将这些配置注入到实体类中使用，这里就用到了类型安全的属性绑定（参见：<a href="https://mp.weixin.qq.com/s/vd6MR-UXi-OK2Z-uR15BTQ" target="_blank" rel="noopener">Spring Boot2 系列教程(四)理解配置文件 application.properties ！</a>）。</p><p>这里我创建两个类分别用来接收 CAS Server 和 CAS Client 的配置文件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"cas.server"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASServerProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String prefix;</span><br><span class="line">    <span class="hljs-keyword">private</span> String login;</span><br><span class="line">    <span class="hljs-keyword">private</span> String logout;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"cas.client"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASClientProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String prefix;</span><br><span class="line">    <span class="hljs-keyword">private</span> String login;</span><br><span class="line">    <span class="hljs-keyword">private</span> String logoutRelative;</span><br><span class="line">    <span class="hljs-keyword">private</span> String logout;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外记得在启动类上面添加 <code>@ConfigurationPropertiesScan</code> 注解来扫描这两个配置类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span></span><br><span class="line"><span class="hljs-meta">@ConfigurationPropertiesScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client1Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Client1Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里配置完成后，我们一会将在配置文件中来使用。</p><p>接下来创建 CAS 的配置文件，略长：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CasSecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    CASClientProperties casClientProperties;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    CASServerProperties casServerProperties;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserDetailsService userDetailService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">ServiceProperties <span class="hljs-title">serviceProperties</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        ServiceProperties serviceProperties = <span class="hljs-keyword">new</span> ServiceProperties();</span><br><span class="line">        serviceProperties.setService(casClientProperties.getLogin());</span><br><span class="line">        <span class="hljs-keyword">return</span> serviceProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-meta">@Primary</span></span><br><span class="line">    <span class="hljs-function">AuthenticationEntryPoint <span class="hljs-title">authenticationEntryPoint</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        CasAuthenticationEntryPoint entryPoint = <span class="hljs-keyword">new</span> CasAuthenticationEntryPoint();</span><br><span class="line">        entryPoint.setLoginUrl(casServerProperties.getLogin());</span><br><span class="line">        entryPoint.setServiceProperties(serviceProperties());</span><br><span class="line">        <span class="hljs-keyword">return</span> entryPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TicketValidator <span class="hljs-title">ticketValidator</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cas20ProxyTicketValidator(casServerProperties.getPrefix());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">CasAuthenticationProvider <span class="hljs-title">casAuthenticationProvider</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        CasAuthenticationProvider provider = <span class="hljs-keyword">new</span> CasAuthenticationProvider();</span><br><span class="line">        provider.setServiceProperties(serviceProperties());</span><br><span class="line">        provider.setTicketValidator(ticketValidator());</span><br><span class="line">        provider.setUserDetailsService(userDetailService);</span><br><span class="line">        provider.setKey(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">CasAuthenticationFilter <span class="hljs-title">casAuthenticationFilter</span><span class="hljs-params">(AuthenticationProvider authenticationProvider)</span> </span>&#123;</span><br><span class="line">        CasAuthenticationFilter filter = <span class="hljs-keyword">new</span> CasAuthenticationFilter();</span><br><span class="line">        filter.setServiceProperties(serviceProperties());</span><br><span class="line">        filter.setAuthenticationManager(<span class="hljs-keyword">new</span> ProviderManager(authenticationProvider));</span><br><span class="line">        <span class="hljs-keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SingleSignOutFilter <span class="hljs-title">singleSignOutFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        SingleSignOutFilter sign = <span class="hljs-keyword">new</span> SingleSignOutFilter();</span><br><span class="line">        sign.setIgnoreInitConfiguration(<span class="hljs-keyword">true</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> sign;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">LogoutFilter <span class="hljs-title">logoutFilter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        LogoutFilter filter = <span class="hljs-keyword">new</span> LogoutFilter(casServerProperties.getLogout(), <span class="hljs-keyword">new</span> SecurityContextLogoutHandler());</span><br><span class="line">        filter.setFilterProcessesUrl(casClientProperties.getLogoutRelative());</span><br><span class="line">        <span class="hljs-keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件略长，但是并不难，我来和大家挨个解释：</p><ol><li>首先一进来注入三个对象，这三个中，有两个是我们前面写的配置类的实例，另外一个则是 UserDetailsService，关于 UserDetailsService，我想我也不必多做解释，大家参考本系列前面的文章就知道 UserDetailsService 的作用（<a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a>），一会我会给出 UserDetailsService 的实现。</li><li>接下来配置 ServiceProperties，ServiceProperties 中主要配置一下 Client 的登录地址即可，这个地址就是在 CAS Server 上登录成功后，重定向的地址。</li><li>CasAuthenticationEntryPoint 则是 CAS 验证的入口，这里首先设置 CAS Server 的登录地址，同时将前面的 ServiceProperties 设置进去，这样当它登录成功后，就知道往哪里跳转了。</li><li>TicketValidator 这是配置 ticket 校验地址，CAS Client 拿到 ticket 要去 CAS Server 上校验，默认校验地址是：<a href="https://cas.javaboy.org:8443/cas/proxyValidate?ticket=xxx" target="_blank" rel="noopener">https://cas.javaboy.org:8443/cas/proxyValidate?ticket=xxx</a></li><li>CasAuthenticationProvider 主要用来处理 CAS 验证逻辑，关于 AuthenticationProvider 松哥在前面的文章中和大家分享过（<a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a>），当时就说，想要自定义认证逻辑，如短信登录等，都可以通过扩展 AuthenticationProvider 来实现，这里的 CAS 登录当然也不例外，这里虽然设置了一个 userDetailService，但是目的不是为了从数据库中查询数据做校验，因为登录是在 CAS Server 中进行的，这个的作用，我在后面会做介绍。</li><li>CasAuthenticationFilter 则是 CAS 认证的过滤器，过滤器将请求拦截下来之后，交由 CasAuthenticationProvider 来做具体处理。</li><li>SingleSignOutFilter 表示接受 CAS Server 发出的注销请求，所有的注销请求都将从 CAS Client 转发到 CAS Server，CAS Server 处理完后，会通知所有的 CAS Client 注销登录。</li><li>LogoutFilter 则是配置将注销请求转发到 CAS Server。</li></ol><p>接下来我再来给大家看下我定义的 UserDetailsService：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Primary</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDetailsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(s, <span class="hljs-string">"123"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>,</span><br><span class="line">                AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_user"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是单点登录，也就是用户是在 CAS Server 上登录的，这里的 UserDetailsService 意义在哪里呢？</p><p>用户虽然在 CAS Server 上登录，但是，登录成功之后，CAS Client 还是要获取用户的基本信息、角色等，以便做进一步的权限控制，所以，这里的 loadUserByUsername 方法中的参数，实际上就是你从 CAS Server 上登录成功后获取到的用户名，拿着这个用户名，去数据库中查询用户的相关信心并返回，方便 CAS Client 在后续的鉴权中做进一步的使用，这里我为了方便，就没有去数据库中查询了，而是直接创建了一个 User 对象返回。</p><p>接下来，我们再来看看 Spring Security 的配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationProvider authenticationProvider;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    SingleSignOutFilter singleSignOutFilter;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    LogoutFilter logoutFilter;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    CasAuthenticationFilter casAuthenticationFilter;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.authenticationProvider(authenticationProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().antMatchers(<span class="hljs-string">"/user/**"</span>)</span><br><span class="line">                .hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/login/cas"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">                .and()</span><br><span class="line">                .addFilter(casAuthenticationFilter)</span><br><span class="line">                .addFilterBefore(singleSignOutFilter, CasAuthenticationFilter.class)</span><br><span class="line">                .addFilterBefore(logoutFilter, LogoutFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的配置就简单很多了：</p><ol><li>首先配置 authenticationProvider，这个 authenticationProvider 实际上就是一开始配置的 CasAuthenticationProvider。</li><li>接下来配置 <code>/user/**</code> 格式的路径需要有 user 角色才能访问，登录路径 <code>/login/cas</code> 可以直接访问，剩余接口都是登录成功之后才能访问。</li><li>最后把 authenticationEntryPoint 配置进来，再把自定义的过滤器加进来，这些都比较容易我就不多说了。</li></ol><p>最后，再提供两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK ，如此之后，我们的 CAS Client 现在就开发完成了，接下来启动 CAS Client，启动成功后，浏览器输入 <code>http://client1.cas.javaboy.org:8080/user/hello</code> 访问 hello 接口，此时会自动跳转到 CAS Server 上登录，登录成功之后，经过两个重定向，会重新回到 hello 接口。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>OK，这就是松哥和大家介绍的 Spring Security + CAS 单点登录，当然，这个案例中还有很多需要完善的地方，松哥会在后面的文章中继续和大家分享完善的方案。</p><p>好了 ，本文就说到这里，本文相关案例我已经上传到 GitHub ，大家可以自行下载:<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>好啦，小伙伴们如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥周末抽空给 Spring Security 系列也录制了一套视频，目录如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="CAS" scheme="http://www.javaboy.org/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>来一个简单的，微服务项目中如何管理依赖版本号？</title>
    <link href="http://www.javaboy.org/2020/0602/springcloud-maven-version.html"/>
    <id>http://www.javaboy.org/2020/0602/springcloud-maven-version.html</id>
    <published>2020-06-02T14:47:59.000Z</published>
    <updated>2020-06-05T15:09:08.685Z</updated>
    
    <content type="html"><![CDATA[<p>松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><a id="more"></a><p>本文是微服务项目代码组织形式三部曲中的第三篇，也是最后一篇，通过这三篇文章，相信大家对于如果组织微服务中的代码已经有了一个基本认知，前面两篇分别是：</p><ol><li><a href="https://mp.weixin.qq.com/s/RpkkbAeUZADdiUDx244eJw" target="_blank" rel="noopener">微服务项目搭建，到底要不要聚合工程？</a></li><li><a href="https://mp.weixin.qq.com/s/GWMBhxXPwYyaQy5RvYD71g" target="_blank" rel="noopener">在微服务项目中，Maven 真的适合管理公共代码库吗？</a></li></ol><p>第三篇相对来说要简单一些，本来没打算写，但是上周有个小伙伴问了我一个 Maven 问题，然后我就发现有的小伙伴对聚合工程的认知还是不到位，因此才有了这篇文章，想和大家再聊聊聚合工程的问题。</p><h2 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1.微服务架构"></a>1.微服务架构</h2><p>理论上的微服务架构和实际应用的微服务，往往会有一些差异。</p><p>理论上，在微服务架构中，各个独立的微服务可以是各种语言，像我们使用的 Eureka 注册中心，就是支持多种语言的，这样可以充分发挥各种语言的优势。如果是这样，就没有必要从项目整体上进行版本管理了，也管不了。</p><p>但是在实际操作中，考虑到团队的技术栈，现有的技术生态等因素，大部分情况下，我们可能并不会在项目中掺杂其他语言进来，比如就是用 Java 开发，相信大部分小伙伴都是这么做的。</p><p>既然统一都使用 Java 语言开发，那一个需求就随之浮出水面，就是项目依赖统一管理。</p><p><strong>这个问题其实不是绝对的。</strong></p><p>大型的微服务项目分属不同的团队开发，每个团队维护好自己的项目，然后通过 RPC 或者 HTTP 的方式互相之间进行交互，这种情况下，版本号也可以交由各个团队自行维护，这样版本升级的时候，就不必一起升级，可以各个团队独自完成，逐个升级。</p><p>但是这种方式又可能会带来另外一个问题，就是依赖版本的碎片化，在经过 N 多次迭代之后，可能会存在两个项目所依赖的微服务版本差异非常大。</p><p>因此，在实际操作中，有的团队会倾向于将项目版本统一管理。</p><p>统一管理也很简单，就是搞一个 parent 就行了，但是有的小伙伴容易将这种 parent 和聚合工程搞混，因此松哥这里还是和大家稍微聊一下怎么统一管理项目版本号。</p><h2 id="2-统一管理版本号"><a href="#2-统一管理版本号" class="headerlink" title="2.统一管理版本号"></a>2.统一管理版本号</h2><h3 id="2-1-聚合工程"><a href="#2-1-聚合工程" class="headerlink" title="2.1 聚合工程"></a>2.1 聚合工程</h3><p>先来说一说聚合工程，这里我就不重新写代码了，以微人事（<a href="https://github.com/lenve/vhr）为例来和大家分享。" target="_blank" rel="noopener">https://github.com/lenve/vhr）为例来和大家分享。</a></p><p>微人事项目的服务端就是一个聚合工程。</p><p><img src="http://img.itboyhub.com/2020/05/20200526111146.png" alt></p><p>我们可以来看下 vhrserver 的 pom.xml 文件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhrserver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-mapper<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-model<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个聚合工程中，vhr-model 用来放实体类，vhr-mapper 用来放 Dao 层，vhr-server 用来放 Service 层，vhr-web 则是一个 Spring Boot 工程。</p><p>在聚合工程中，vhr-web 作为聚合工程的一部分，是无法独立打包的，因为它依赖 vhr-service，vhr-service 依赖 vhr-mapper ，而 vhr-mapper 则依赖 vhr-model。我们需要从 vhrserver 处打包，这样它会自动解决 module 之间的依赖问题。</p><p>单独给 vhr-web 打包会报如下错误：</p><p><img src="http://img.itboyhub.com/2020/05/20200526111842.png" alt></p><p>从 vhrserver 处统一打包，结果如下：</p><p><img src="http://img.itboyhub.com/2020/05/20200526112419.png" alt></p><p>可以看到，我们需要直接打包聚合工程，内部的依赖问题会自动解决。</p><p>有人可能会问，既然前面报 <code>Could not find artifact org.javaboy:vhr-service:pom:1.0-SNAPSHOT</code> 错误，那我先把 vhr-service install 到本地仓库，再去打包 vhr-web 行不行？</p><p>这个是不行的，因为这是聚合工程，不能这样做，只能从聚合工程处打包。</p><h3 id="2-2-统一管理版本号"><a href="#2-2-统一管理版本号" class="headerlink" title="2.2 统一管理版本号"></a>2.2 统一管理版本号</h3><p>上面说的聚合工程虽然也能实现版本号的统一管理，但是我们不能在微服务中采用这种方式。</p><p>你想一个微服务系统，包含了很多子系统，例如商品管理、交易管理、物流管理等等，要是想给商品管理打包，你还得从聚合工程处打包，打完之后，其他微服务模块也生成了各自的包，这样效率太低了。</p><p>但是我们还想实现版本号的统一管理，该怎么办呢？创建父子工程即可。这种项目结构和聚合工程很像，但是不一样，很多小伙伴会搞混，所以这里我来给大家稍微演示一下。</p><p>首先我们定义一个普通的 Maven 工程作为父工程，我把 pom.xml 文件拎出来给大家参考下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy.vmall<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vmall<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-comment">&lt;!--省略--&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="hljs-comment">&lt;!--省略--&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>大家可以看到，这个父工程本身也有一个 parent ，就是 Spring Boot 中的 parent。</p><p>这里的 packaging 依然是 pom，然后我们定义了 dependencyManagement，将一些不包含在 spring-boot-starter-parent 中的依赖版本进行统一管理。但是大家注意，这里没有 modules 节点，这是一个很大的不同。</p><p>接下来，我们创建其他微服务项目，在创建的过程中，可以采用平铺的方式，例如下面这样：</p><p><img src="http://img.itboyhub.com/2020/05/20200526130345.png" alt></p><p>也可以做成有层次结构的父子形式，像下面这样：</p><p><img src="http://img.itboyhub.com/2020/05/20200526130526.png" alt></p><p>两种方式都可以。</p><p>然后在各个微服务项目中，重新修改 parent 即可：</p><p><img src="http://img.itboyhub.com/2020/05/20200526130659.png" alt></p><p>如此之后，我们就可以对各个微服务中的依赖版本进行统一管理了。</p><p>这种项目结构和聚合工程并不一样，这种项目打包，是可以独立打包的。</p><p>首先我们先将父工程 install 到本地仓库：</p><p><img src="http://img.itboyhub.com/2020/05/20200526130922.png" alt></p><p>然后再去 install vmall-common 模块，最后给 vmall-app-manager 进行打包，注意，现在的 vmall-app-manager 可以独立打包，不需要从总的 parent 处进行统一打包。微服务项目中如果需要对项目版本进行统一管理，可以采用这种方式。</p><p>小伙伴们可以仔细品一品这种方式和聚合工程的差异。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，今天的内容比较简单，再结合前面已经发过的两篇文章，相信大家对于如何组织微服务项目的代码已经有一定的思路了。</p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&amp;gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot+Vue+微人事视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Maven" scheme="http://www.javaboy.org/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手教你入门 Spring Boot + CAS 单点登录</title>
    <link href="http://www.javaboy.org/2020/0601/springsecurity-casserver.html"/>
    <id>http://www.javaboy.org/2020/0601/springsecurity-casserver.html</id>
    <published>2020-06-01T14:47:02.000Z</published>
    <updated>2020-06-05T15:08:54.845Z</updated>
    
    <content type="html"><![CDATA[<p>松哥周末抽空给 Spring Security 系列也录制了一套视频，目录如下：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/05/springboot/20200531234416.png" alt></p><p>感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><p>我们来看今天的 CAS 单点登录。</p><p>在微服务以及分布式系统中，单点登录变得越来越普遍，松哥之前也有两篇文章和大家介绍过单点登录的方案：</p><ul><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">OAuth2+JWT 方案</a></li><li><a href="https://mp.weixin.qq.com/s/EyAMTbKPqNNnEtZACIsMVw" target="_blank" rel="noopener">@EnableOAuth2Sso 注解方案</a></li></ul><p>这两种方案中，JWT 存在一个注销登录的问题，要费点功夫解决。@EnableOAuth2Sso 注解这种方案不存在注销登录的问题，但是又不像 JWT 那么灵活。</p><p><strong>没有银弹！</strong></p><p>在实际项目中，我们只能根据自己的实际需求，看一看哪一种方案更适合自己，然后在此基础上进行改造！</p><p>现在我们在 Spring Cloud Security 中使用 OAuth2+JWT 或者使用 @EnableOAuth2Sso 注解比以前要方便很多了，松哥也是最近才把项目切换到 Spring Cloud Security 技术栈上面来，在这之前，单点登录用的更多的是 CAS 单点登录。相信有不少小伙伴在公司里可能也还是使用了 CAS 单点登录这种方案，今天松哥就来花点时间，和大家聊聊 CAS+Spring Security 实现单点登录，这种方案到底该怎么玩。</p><p>可能会连续几篇文章来介绍 CAS 单点登录，本文先来说说理论和登录流程。另外，由于 CAS 和 Spring Cloud OAuth2 在某些方面具有一定的相似性，所以强烈建议大家先看一看松哥的 OAuth2 系列教程，再来阅读本文就会轻松很多（公众号后台回复 OAuth2 有相关教程）。</p><p>本文是 Spring Security 系列第 23 篇，阅读本系列前面的文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li></ol><h2 id="1-什么是-CAS"><a href="#1-什么是-CAS" class="headerlink" title="1.什么是 CAS"></a>1.什么是 CAS</h2><p>CAS 全称叫做中央认证服务，英文是 Central Authentication Service。</p><p>这是由耶鲁大学发起的一个开源项目，目的是帮助 Web 应用系统构建一种可靠的单点登录解决方案，从目前企业实际项目来看，CAS 还是非常受欢迎的一种单点登录解决方案。</p><h3 id="1-1-CAS-架构"><a href="#1-1-CAS-架构" class="headerlink" title="1.1 CAS 架构"></a>1.1 CAS 架构</h3><p>CAS 分为两部分：</p><ul><li>一个是 CAS Server，这是单点验证服务，作用类似于我们<a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">OAuth2+JWT 方案</a>中的授权服务器，用来校验用户名/密码等，一般来说都是独立部署。</li><li>另一个则是 CAS Client，相当于就是一个一个的（微）服务。</li></ul><p>我们来看 CAS 的官方给出的一个架构图：</p><p><img src="http://img.itboyhub.com/2020/05/20200521204320.png" alt></p><p>可以看到，用户访问的是 CAS Clients，CAS Clients 和 CAS Server 之间的通信支持多种协议，CAS Server 处理具体的认证事宜，CAS Server 对数据源的支持也非常多样化。</p><p>CAS Client 支持的平台有：</p><ul><li>Apache httpd Server (mod_auth_cas module)</li><li>Java (Java CAS Client)</li><li>.NET (.NET CAS Client)</li><li>PHP (phpCAS)</li><li>Perl (PerlCAS)</li><li>Python (pycas)</li><li>Ruby (rubycas-client)</li></ul><p>CAS 支持的通信协议有：</p><ul><li>CAS (versions 1, 2, and 3)</li><li>SAML 1.1 and 2</li><li>OpenID Connect</li><li>OpenID</li><li>OAuth 2.0</li><li>WS Federation</li></ul><p>从图中也可以看出 CAS 支持多种不同的认证机制，具体有：</p><ul><li>JAAS</li><li>LDAP</li><li>RDBMS</li><li>SPNEGO</li><li>…</li></ul><h3 id="1-2-三个概念"><a href="#1-2-三个概念" class="headerlink" title="1.2 三个概念"></a>1.2 三个概念</h3><p>在 CAS 的整个登录过程中，有三个重要的概念，这里我先来和大家捋一捋。</p><ol><li>TGT：TGT 全称叫做 Ticket Granting Ticket，这个相当于我们平时所见到的 HttpSession 的作用，用户登录成功后，用户的基本信息，如用户名、登录有效期等信息，都将存储在此。</li><li>TGC：TGC 全称叫做 Ticket Granting Cookie，TGC 以 Cookie 的形式保存在浏览器中，根据 TGC 可以帮助用户找到对应的 TGT，所以这个 TGC 有点类似与会话 ID。</li><li>ST：ST 全称是 Service Ticket，这是 CAS Sever 通过 TGT 给用户发放的一张票据，用户在访问其他服务时，发现没有 Cookie 或者 ST ，那么就会 302 到 CAS Server 获取 ST，然后会携带着 ST 302 回来，CAS Client 则通过 ST 去 CAS Server 上获取用户的登录状态。</li></ol><h2 id="2-CAS-登录流程"><a href="#2-CAS-登录流程" class="headerlink" title="2.CAS 登录流程"></a>2.CAS 登录流程</h2><p>接下来我们通过一张官方给出的流程图来看下 CAS 登录过程是什么样子的！</p><p><img src="http://img.itboyhub.com/2020/05/20200522112134.png" alt></p><p>这张图其实画的比较清楚了，我再用文字和大家解释下：</p><p>术语：应用1、应用2 分别表示被保护的应用。</p><ol><li>用户通过浏览器访问应用1，应用1 发现用户没有登录，于是返回 302，并且携带上一个 service 参数，让用户去 CAS Server 上登录。</li><li>浏览器自动重定向到 CAS Server 上，CAS Server 获取用户 Cookie 中携带的 TGC，去校验用户是否已经登录，如果已经登录，则完成身份校验（此时 CAS Server 可以根据用户的 TGC 找到 TGT，进而获取用户的信息）；如果未登录，则重定向到 CAS Server 的登录页面，用户输入用户名/密码，CAS Server 会生成 TGT，并且根据 TGT 签发一个 ST，再将 TGC 放在用户的 Cookie 中，完成身份校验。</li><li>CAS Server 完成身份校验之后，会将 ST 拼接在 service 中，返回 302，浏览器将首先将 TGC 存在 Cookie 中，然后根据 302 的指示，携带上 ST 重定向到应用1。</li><li>应用1 收到浏览器传来的 ST 之后，拿去 CAS Server 上校验，去判断用户的登录状态，如果用户登录合法，CAS Server 就会返回用户信息给 应用1。</li><li>浏览器再去访问应用2，应用2 发现用户未登录，重定向到 CAS Server。</li><li>CAS Server 发现此时用户实际上已经登录了，于是又重定向回应用2，同时携带上 ST。</li><li>应用2 拿着 ST 去 CAS Server 上校验，获取用户的登录信息。</li></ol><p>在整个登录过程中，浏览器分别和 CAS Server、应用1、应用2 建立了会话，其中，和 CAS Server 建立的会话称之为全局会话，和应用1、应用2 建立的会话称之为局部会话；一旦局部会话成功建立，以后用户再去访问应用1、应用2 就不会经过 CAS Server 了。</p><h2 id="3-CAS-Server-搭建"><a href="#3-CAS-Server-搭建" class="headerlink" title="3.CAS Server 搭建"></a>3.CAS Server 搭建</h2><p>说了这么多，来点实际的。</p><p>由于整个 CAS 单点登录做起来还比较麻烦，我们一步一步来，今天我先来教大家把 CAS Server 搭建起来。</p><h3 id="3-1-版本选择"><a href="#3-1-版本选择" class="headerlink" title="3.1 版本选择"></a>3.1 版本选择</h3><p>目前最新的 CAS Server 是 6.x，这个是基于 gradle 来构建的，考虑到很多小伙伴可能不熟悉 gradle 操作，因此这里我选择 5.3 的版本，该版本基于大家熟悉的 maven 来构建。</p><p>官方为我们提供了构建 CAS Server 的模版，地址是：<a href="https://github.com/apereo/cas-overlay-template。" target="_blank" rel="noopener">https://github.com/apereo/cas-overlay-template。</a></p><p>我们在分支中选择 5.3 版本下载：</p><p><img src="http://img.itboyhub.com/2020/05/20200523213534.png" alt></p><p>或者直接 clone 下来，然后切换到 5.3 这个分支也可以。这个应该就不用我教大家了吧，相信小伙伴们都能自己搞定。</p><h3 id="3-2-HTTPS-证书"><a href="#3-2-HTTPS-证书" class="headerlink" title="3.2 HTTPS 证书"></a>3.2 HTTPS 证书</h3><p>CAS Server 从版本 4 开始，要使用 HTTPS 通信，所以我们得提前准备 HTTPS 证书。公司里的项目的话，需要购买 HTTPS 证书，自己玩的话也可以从云服务厂商那里申请到免费的 HTTPS 证书。</p><p>现在我们在本地测试，直接利用 JDK 自带的 keytool 工具，自己生成一个 HTTPS 证书即可。</p><p>生成命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias casserver -keyalg RSA -keystore ./keystore</span><br></pre></td></tr></table></figure><ul><li>-alias 表示生成的证书别名</li><li>-keyalg 表示生成证书使用的算法</li><li>-keystore 表示生成证书的存放位置</li></ul><p>证书在执行的时候，需要给一个密钥库口令，这个大家随意给出即可，但是给出了多少要自己记着。另外，在 <code>What is your first and last name?</code> 选项中，<strong>需要填入 CAS Server 的域名，这点切记</strong>：</p><p><img src="http://img.itboyhub.com/2020/05/20200523214858.png" alt></p><p>如此之后，我们的 HTTPS 证书就有了，虽然这个证书不被各大厂商认可，但是自己做练习够用了。</p><h3 id="3-3-配置并启动"><a href="#3-3-配置并启动" class="headerlink" title="3.3 配置并启动"></a>3.3 配置并启动</h3><p>接下来进行配置。</p><p>我们在下载的 cas-overlay-template 项目中，新建 src/main/resources 目录，并将 overlays/org.apereo.cas.cas-server-webapp-tomcat-5.3.14/WEB-INF/classes/application.properties 文件和刚刚生成的 keystore 文件拷贝进来：</p><p><img src="http://img.itboyhub.com/2020/05/20200523215321.png" alt></p><p>然后修改 application.properties ，主要配置一下 keystore 的位置和密钥，如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.ssl.key-store=classpath:keystore</span><br><span class="line">server.ssl.key-store-password=111111</span><br><span class="line">server.ssl.key-password=111111</span><br></pre></td></tr></table></figure><p>配置完成后，在项目根目录下执行如下命令启动项目：</p><p>./build.sh bootrun</p><p>根据个人网速，第一次启动可能会非常漫长，耐心等待即可。</p><p>启动过程中，也可能会报错，但是不用管，如果看到 ready 图标，就表示启动成功了：</p><p><img src="http://img.itboyhub.com/2020/05/20200523215730.png" alt></p><h3 id="3-4-测试"><a href="#3-4-测试" class="headerlink" title="3.4 测试"></a>3.4 测试</h3><p>启动成功后，浏览器输入 <a href="https://cas.javaboy.org:8443/cas/login" target="_blank" rel="noopener">https://cas.javaboy.org:8443/cas/login</a> 就可以进入登录页面了（注意是 https 哦）：</p><p><img src="http://img.itboyhub.com/2020/05/20200523220157.png" alt></p><p>默认的用户名是 casuser，密码是 Mellon，输入用户名密码就可以登录了。</p><p><img src="http://img.itboyhub.com/2020/05/20200523220520.png" alt></p><p>默认的用户名/密码也可以在 application.properties 文件中修改，该文件的最后一行：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cas.authn.accept.users=casuser::Mellon</span><br></pre></td></tr></table></figure><p>修改完后，重启项目即可生效。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>今天主要和小伙伴聊一下 CAS 的基本概念，然后我们顺手搭建一个 CAS Server 出来，感兴趣的小伙伴可以动手试一试哦～，下篇文章我们来看如何用 Spring Boot 开发 CAS 客户端～</p><p>好啦，如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥周末抽空给 Spring Security 系列也录制了一套视频，目录如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="CAS" scheme="http://www.javaboy.org/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 两种资源放行策略，千万别用错了！</title>
    <link href="http://www.javaboy.org/2020/0528/springsecurity-ignoring.html"/>
    <id>http://www.javaboy.org/2020/0528/springsecurity-ignoring.html</id>
    <published>2020-05-28T14:46:51.000Z</published>
    <updated>2020-06-05T15:09:56.149Z</updated>
    
    <content type="html"><![CDATA[<p>松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><a id="more"></a><p>来看今天的正文。</p><p>事情的起因是这样，有小伙伴在微信上问了松哥一个问题：</p><p><img src="http://img.itboyhub.com/2020/05/20200527212040.png" alt></p><p>就是他使用 Spring Security 做用户登录，等成功后，结果无法获取到登录用户信息，松哥之前写过相关的文章（<a href="https://mp.weixin.qq.com/s/qUDZdTPc4-2UtmHtFI4v-g" target="_blank" rel="noopener">奇怪，Spring Security 登录成功后总是获取不到登录用户信息？</a>），但是他似乎没有看懂。考虑到这是一个非常常见的问题，因此我想今天换个角度再来和大伙聊一聊这个话题。</p><p>Spring Security 中，到底该怎么样给资源额外放行？</p><h2 id="1-两种思路"><a href="#1-两种思路" class="headerlink" title="1.两种思路"></a>1.两种思路</h2><p>在 Spring Security 中，有一个资源，如果你希望用户不用登录就能访问，那么一般来说，你有两种配置策略：</p><p>第一种就是在 configure(WebSecurity web) 方法中配置放行，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"/js/**"</span>, <span class="hljs-string">"/index.html"</span>, <span class="hljs-string">"/img/**"</span>, <span class="hljs-string">"/fonts/**"</span>, <span class="hljs-string">"/favicon.ico"</span>, <span class="hljs-string">"/verifyCode"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式是在 configure(HttpSecurity http) 方法中进行配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/hello"</span>).permitAll()</span><br><span class="line">        .anyRequest().authenticated()</span><br></pre></td></tr></table></figure><p>两种方式最大的区别在于，第一种方式是不走 Spring Security 过滤器链，而第二种方式走 Spring Security 过滤器链，在过滤器链中，给请求放行。</p><p>在我们使用 Spring Security 的时候，有的资源可以使用第一种方式额外放行，不需要验证，例如前端页面的静态资源，就可以按照第一种方式配置放行。</p><p>有的资源放行，则必须使用第二种方式，例如登录接口。大家知道，登录接口也是必须要暴露出来的，不需要登录就能访问到的，但是我们却不能将登录接口用第一种方式暴露出来，登录请求必须要走 Spring Security 过滤器链，因为在这个过程中，还有其他事情要做。</p><p>接下来我以登录接口为例，来和小伙伴们分析一下走 Spring Security 过滤器链有什么不同。</p><h2 id="2-登录请求分析"><a href="#2-登录请求分析" class="headerlink" title="2.登录请求分析"></a>2.登录请求分析</h2><p>首先大家知道，当我们使用 Spring Security，用户登录成功之后，有两种方式获取用户登录信息：</p><ol><li><code>SecurityContextHolder.getContext().getAuthentication()</code></li><li>在 Controller 的方法中，加入 Authentication 参数</li></ol><p>这两种办法，都可以获取到当前登录用户信息。具体的操作办法，大家可以看看松哥之前发布的教程：<a href="https://mp.weixin.qq.com/s/jQZx4i4-vqjpBjpoJKJF4A" target="_blank" rel="noopener">Spring Security 如何动态更新已登录用户信息？</a>。</p><p>这两种方式获取到的数据都是来自 SecurityContextHolder，SecurityContextHolder 中的数据，本质上是保存在 <code>ThreadLocal</code> 中，<code>ThreadLocal</code> 的特点是存在它里边的数据，哪个线程存的，哪个线程才能访问到。</p><p>这样就带来一个问题，当用户登录成功之后，将用户用户数据存在 SecurityContextHolder 中（thread1），当下一个请求来的时候（thread2），想从 SecurityContextHolder 中获取用户登录信息，却发现获取不到！为啥？因为它俩不是同一个 Thread。</p><p>但实际上，正常情况下，我们使用 Spring Security 登录成功后，以后每次都能够获取到登录用户信息，这又是怎么回事呢？</p><p>这我们就要引入 Spring Security 中的 <code>SecurityContextPersistenceFilter</code> 了。</p><p>小伙伴们都知道，无论是 Spring Security 还是 Shiro，它的一系列功能其实都是由过滤器来完成的，在 Spring Security 中，松哥前面跟大家聊了 <code>UsernamePasswordAuthenticationFilter</code> 过滤器，在这个过滤器之前，还有一个过滤器就是 <code>SecurityContextPersistenceFilter</code>，请求在到达 <code>UsernamePasswordAuthenticationFilter</code> 之前都会先经过 <code>SecurityContextPersistenceFilter</code>。</p><p>我们来看下它的源码(部分)：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityContextPersistenceFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">HttpRequestResponseHolder holder = <span class="hljs-keyword">new</span> HttpRequestResponseHolder(request,</span><br><span class="line">response);</span><br><span class="line">SecurityContext contextBeforeChainExecution = repo.loadContext(holder);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">SecurityContextHolder.setContext(contextBeforeChainExecution);</span><br><span class="line">chain.doFilter(holder.getRequest(), holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">SecurityContext contextAfterChainExecution = SecurityContextHolder</span><br><span class="line">.getContext();</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line">repo.saveContext(contextAfterChainExecution, holder.getRequest(),</span><br><span class="line">holder.getResponse());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本的方法很长，我这里列出来了比较关键的几个部分：</p><ol><li>SecurityContextPersistenceFilter 继承自 GenericFilterBean，而 GenericFilterBean 则是 Filter 的实现，所以 SecurityContextPersistenceFilter 作为一个过滤器，它里边最重要的方法就是 doFilter 了。</li><li>在 doFilter 方法中，它首先会从 repo 中读取一个 SecurityContext 出来，这里的 repo 实际上就是 HttpSessionSecurityContextRepository，读取 SecurityContext 的操作会进入到 readSecurityContextFromSession 方法中，在这里我们看到了读取的核心方法 <code>Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);</code>，这里的 springSecurityContextKey 对象的值就是 SPRING_SECURITY_CONTEXT，读取出来的对象最终会被转为一个 SecurityContext 对象。</li><li>SecurityContext 是一个接口，它有一个唯一的实现类 SecurityContextImpl，这个实现类其实就是用户信息在 session 中保存的 value。</li><li>在拿到 SecurityContext 之后，通过 SecurityContextHolder.setContext 方法将这个 SecurityContext 设置到 ThreadLocal 中去，这样，在当前请求中，Spring Security 的后续操作，我们都可以直接从 SecurityContextHolder 中获取到用户信息了。</li><li>接下来，通过 chain.doFilter 让请求继续向下走（这个时候就会进入到 <code>UsernamePasswordAuthenticationFilter</code> 过滤器中了）。</li><li>在过滤器链走完之后，数据响应给前端之后，finally 中还有一步收尾操作，这一步很关键。这里从 SecurityContextHolder 中获取到 SecurityContext，获取到之后，会把 SecurityContextHolder 清空，然后调用 repo.saveContext 方法将获取到的 SecurityContext 存入 session 中。</li></ol><p>至此，整个流程就很明了了。</p><p>每一个请求到达服务端的时候，首先从 session 中找出来 SecurityContext ，然后设置到 SecurityContextHolder 中去，方便后续使用，当这个请求离开的时候，SecurityContextHolder 会被清空，SecurityContext 会被放回 session 中，方便下一个请求来的时候获取。</p><p>登录请求来的时候，还没有登录用户数据，但是登录请求走的时候，会将用户登录数据存入 session 中，下个请求到来的时候，就可以直接取出来用了。</p><p>看了上面的分析，我们可以至少得出两点结论：</p><ol><li>如果我们暴露登录接口的时候，使用了前面提到的第一种方式，没有走 Spring Security，过滤器链，则在登录成功后，就不会将登录用户信息存入 session 中，进而导致后来的请求都无法获取到登录用户信息（后来的请求在系统眼里也都是未认证的请求）</li><li>如果你的登录请求正常，走了 Spring Security 过滤器链，但是后来的 A 请求没走过滤器链（采用前面提到的第一种方式放行），那么 A 请求中，也是无法通过 SecurityContextHolder 获取到登录用户信息的，因为它一开始没经过 SecurityContextPersistenceFilter 过滤器链。</li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>总之，前端静态资源放行时，可以直接不走 Spring Security 过滤器链，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="hljs-string">"/css/**"</span>,<span class="hljs-string">"/js/**"</span>,<span class="hljs-string">"/index.html"</span>,<span class="hljs-string">"/img/**"</span>,<span class="hljs-string">"/fonts/**"</span>,<span class="hljs-string">"/favicon.ico"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端的接口要额外放行，就需要仔细考虑场景了，不过一般来说，不建议使用上面这种方式，建议下面这种方式，原因前面已经说过了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/hello"</span>).permitAll()</span><br><span class="line">        .anyRequest().authenticated()</span><br></pre></td></tr></table></figure><p>好了，这就是和小伙伴们分享的两种资源放行策略，大家千万别搞错了哦～</p><p>有收获的话，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥原创的四套视频教程已经全部杀青，感兴趣的小伙伴戳这里–&amp;gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot+Vue+微人事视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>在微服务项目中，Maven 真的适合管理公共代码库吗？</title>
    <link href="http://www.javaboy.org/2020/0526/springcloud-maven.html"/>
    <id>http://www.javaboy.org/2020/0526/springcloud-maven.html</id>
    <published>2020-05-26T14:47:48.000Z</published>
    <updated>2020-06-05T15:09:04.277Z</updated>
    
    <content type="html"><![CDATA[<p>今天我还是想和大家继续聊一聊微服务中代码的组织形式。</p><a id="more"></a><p>昨天聊了微服务项目中要不要使用聚合工程的问题（<a href="https://mp.weixin.qq.com/s/RpkkbAeUZADdiUDx244eJw" target="_blank" rel="noopener">微服务项目搭建，到底要不要聚合工程？</a>），感觉小伙伴们对这个话题还挺感兴趣，因此今天我们就再来说说微服务中公共代码库的组织形式。</p><h2 id="1-公共代码库"><a href="#1-公共代码库" class="headerlink" title="1.公共代码库"></a>1.公共代码库</h2><p>任何项目，我们都不可避免的会有一个公共代码库，这个公共代码库中可能存放了一些工具类或者实体类，供其他项目使用。</p><p>常规的做法就是把公共代码库上传到公司私服，然后每个人各自在项目中添加依赖即可，这种方式，相信很多小伙伴们都玩过。</p><p>但是不知道大家有没有想过，这种方式其实有一个弊端，就是它不适用于快速迭代的项目。</p><p>在一个快速迭代的项目中，common 的变化非常频繁，这就意味着开发者得不停的将 common 打包上传，其他人不停的修改所引用的 common 版本号。</p><p>在传统的单体应用中，团队人可能不会太多，common 变化也不怎么频繁，所以用 Maven 管理公共代码块的劣势并不明显。</p><p>而现在流行的微服务架构适合大军团作战，人多微服务数量也多，在微服务项目中，动辄几十个上百个微服务。为了解决微服务之间调用时的序列化问题，我们可能将实体类都抽到一个公共的 common 中，每个微服务都可以根据自己的需求修改 common，即使每个微服务每天修改一次 common，反映到 common 身上，也是日日夜夜不停的变化，而其他的微服务就得不停的修改版本号以便日日夜夜追随这种变化。</p><p>在这样的情况下，显然不适合使用 Maven 继续管理 common，因为这意味着你得不停的打包，所有的微服务得不停的修改引用的 common 版本号。</p><blockquote><p>为了防止有人抬杠，松哥得补充一句，上面所说的这种情况在快速迭代的微服务项目中比较常见，特别是团队越大，微服务数量越多，Maven 管理公共代码块的劣势越明显。而传统的单体应用中，你可能并不容易感受到问题所在。</p></blockquote><p><strong>从松哥上面的描述中大家可以看出，Maven 实际上更侧重于包的依赖管理，虽然它能够做到在不同项目中同步公共代码，但没法双向同步（所谓双向同步，就是各个微服务中 common 的更新自动同步到 common 库，common 库的更新也能自动同步到各个微服务），Maven 更适用于公共代码库比较稳定的情形。</strong></p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><p>如果公共代码库总是在不停的变化，而 Maven 又并不是特别方便，那么我们还有没有其他解决方案呢？</p><p>方案肯定是有的，不然松哥也不会撸这篇文章了。</p><p>这里给大家介绍一个我们团队目前在使用的方案—Git Subtree。</p><h3 id="2-1-Git-Subtree"><a href="#2-1-Git-Subtree" class="headerlink" title="2.1 Git Subtree"></a>2.1 Git Subtree</h3><p>Git Subtree 是 Git 官方给出的一个管理子项目的解决方案，在 Git Subtree 之前，官方给出的方案是 Git Submodule，但是从 Git1.5.2 开始，Git 新增并推荐使用这个功能来管理子项目，只要大家本地安装的 Git 版本大于等于 1.5.2，都可以直接使用 Git Subtree。</p><p>Git Subtree 虽然不具备依赖管理的功能，但是在处理快速代替的公共代码库时，却显得非常得心应手，而且它能够做到双向同步！</p><h3 id="2-2-具体应用"><a href="#2-2-具体应用" class="headerlink" title="2.2 具体应用"></a>2.2 具体应用</h3><p>说了这么多，这个 Git Subtree 到底要怎么用？这里松哥来给大家稍微介绍下。</p><p>首先，假设我现在有一个项目叫做 vmall，vmall 是一个微服务项目，里边包含了很多微服务，同时也包含了一个在快速迭代的公共代码块 vmall-common（注意，vmall 和 vmall-common 分属两个不同的仓库）。</p><p>vmall-common 我已经提交在 GitHub 上了，地址是 <a href="https://github.com/lenve/vmall-common。" target="_blank" rel="noopener">https://github.com/lenve/vmall-common。</a></p><p>现在我想在 vmall 项目中引用 vmall-common，怎么做呢？在 vmall 仓库中执行如下代码即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree add --prefix=vmall-common https://github.com/lenve/vmall-common.git master --squash</span><br></pre></td></tr></table></figure><p>最后的 <code>--squash</code> 参数表示不拉取历史信息，而只生成一条 commit 信息，这是一个可选参数，可以不加。这行命令执行完成后，在 vmall 项目中，就可以看到 vmall-common 了，而且 vmall-common 将作为一个普通的文件夹存在，该怎么样还是怎么样。</p><p><img src="http://img.itboyhub.com/2020/05/20200525225956.png" alt></p><p>这个时候我们就可以正常开发了。</p><p>假如说，我们在开发的过程中，修改了 vmall-common，这个时候，在 vmall 仓库中，我们可以通过如下命令将 vmall-common 提交到它自己的仓库中去（先将 vmall 中的变化提交到远程仓库，再执行如下代码）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree push --prefix=vmall-common https://github.com/lenve/vmall-common.git master</span><br></pre></td></tr></table></figure><blockquote><p>如果是在 vmall-common 自己的仓库中提交这种变化，那就是普通的 Git 提交命令，这个就不需要我多说了。</p></blockquote><p>当 vmall-common 中的代码发生变化了，其他微服务通过如下指令可以更新代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree pull --prefix=vmall-common https:<span class="hljs-comment">//github.com/lenve/vmall-common.git master --squash</span></span><br></pre></td></tr></table></figure><p>这三个指令基本上就能应付日常的大部分操作了，不过每次都要输入一个长长的地址很不方便，我们可以给地址取一个别名：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add -f vmall-common https://github.com/lenve/vmall-common.git</span><br></pre></td></tr></table></figure><p>这样，最上面介绍的三个命令就可以简化了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git subtree add --prefix=vmall-common vmall-common master --squash</span><br><span class="line">git subtree pull --prefix=vmall-common vmall-common master --squash</span><br><span class="line">git subtree push --prefix=vmall-common vmall-common master</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>今天还是和小伙伴们聊了下代码微服务中代码的组织问题。</p><p>一言以蔽之，Maven 适合管理比较稳定的公共代码库，Git Subtree 适合处理快速变化的公共代码库，并且支持双向同步！关于 Git Subtree 的一些使用细节问题，比如 <code>--squash</code> 参数要不要加，什么时候加，松哥以后抽时间再来和大家细说。</p><p>好啦，感兴趣的小伙伴可以下来试试～如果大家觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我还是想和大家继续聊一聊微服务中代码的组织形式。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Maven" scheme="http://www.javaboy.org/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>微服务项目搭建，到底要不要聚合工程？</title>
    <link href="http://www.javaboy.org/2020/0525/springcloud-maven-pom.html"/>
    <id>http://www.javaboy.org/2020/0525/springcloud-maven-pom.html</id>
    <published>2020-05-25T14:47:38.000Z</published>
    <updated>2020-06-05T15:09:12.883Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个入门问题，做微服务项目，首先就是要搭建 Project，代码采用什么样的形式来组织，这是我们面临的第一个问题。</p><a id="more"></a><blockquote><p>要扯清楚这个问题，首先对 Maven 的使用不能含糊，小伙伴们可以在公众号后台回复 ssm，获取松哥手敲的 Maven 教程。</p></blockquote><p>在传统的项目中，我们经常需要搭建聚合工程，这样可以方便的对项目进行分模块管理，降低维护难度。</p><p>微服务项目中，我们是否还需要继续这种开发方式呢？今天松哥结合自己在项目中的经验和大家简单聊一下，微服务项目中代码的组织形式。</p><h2 id="1-开发模式"><a href="#1-开发模式" class="headerlink" title="1.开发模式"></a>1.开发模式</h2><p>要搞清楚代码如何组织，首先大家要明白微服务架构到底是什么样子！</p><p>在微服务架构中，一个完整的项目被拆分成很多独立的微服务，例如一个电商项目，可能分为商品管理、商家管理、用户管理、交易管理、SEO 管理、App 管理、财务管理、系统管理等很多微服务。</p><p>这些微服务都是一个个独立的项目，由不同的团队负责开发维护。</p><p>不同的团队独立开发、独立维护、独立测试（看情况）、独立上线，这样可以有效提高项目的开发效率。</p><p>结合项目的实际情况，不同的团队甚至可以选择不同的技术栈，比如商品管理模块用 Java、交易管理可能用 Go、门户网站可能用 PHP 等等，从微服务架构上来说，这些都是支持的，这也是微服务的优势之一，即同一系统不必拘泥于同一种语言，当然在具体实践中，还需要结合团队的技术栈以及语言的特性来选择。</p><p>其实看到这里，你大概就明白了，聚合工程在这里还能不能用了！</p><h2 id="2-要不要聚合工程"><a href="#2-要不要聚合工程" class="headerlink" title="2.要不要聚合工程"></a>2.要不要聚合工程</h2><p>首先从整体上来说，也就是整个项目层面，我们不再需要聚合工程了。聚合工程可以让项目统一打包，解决项目中的依赖问题，还可以对依赖的版本进行统一管理，但是这些特性对微服务项目来说，其实并不重要。</p><p>假如商品管理模块用 Java、交易管理用 Go、门户网站用 PHP，那么这三个独立的微服务肯定是没有必要做成一个聚合工程的，你也没法聚合。当然这是一种比较极端的情况，即使不同微服务模块都是使用 Java 语言开发，那也没有必要聚合，因为不同的微服务实际上都是一个个独立运行的项目，由不同的团队开发维护，微服务的一大优势就是各个团队对独立开发，互不影响，如果搞个聚合工程，又把各个团队绑定在一起了。</p><p>但是不同的微服务之间，不可避免的要使用一些公共类库，这些可以统一打包上传到公司 Maven 私服上，然后不同的团队自行依赖即可，<strong>或者通过 <code>git subtree</code> 的方式来使用</strong>。</p><p>这是从大的层面来说。具体到每一个微服务，聚合工程的优势还在，该用还是要用，例如在商品管理模块，聚合工程还是可以继续使用的。</p><h2 id="3-为什么会有疑问"><a href="#3-为什么会有疑问" class="headerlink" title="3.为什么会有疑问"></a>3.为什么会有疑问</h2><p>微服务中用不用聚合工程这个问题，本来是个很小的问题，但是为什么很多小伙伴会有疑问呢？</p><p>我说一下我了解到几种情况。</p><p>一种情况就是公司的微服务是在旧项目的基础上改造的，仓促上马，改来改去，面目全非，已经顾不上架构这些东西了，功能能实现就行了，这种时候甚至在大的层面就使用了聚合工程，结果不同团队开发起来，还是牵一发而动全身，如果有小伙伴也开发过这种项目，可能就会对聚合工程的使用产生疑问。松哥有一个朋友在广州做某央企的项目，就是这种情况。</p><p>另一种情况可能是因为公司人少，微服务项目开发为了方便，也就从整体上做成了聚合工程，这样在项目人少并且工程量不大的情况下，修改起来非常方便。</p><p>总之，这个问题实际上也不能一概而论，结合项目的实际情况，选择适合自己的方案才是最好的，松哥近期也会搞一个这方面的架构给大家参考，小伙伴们敬请留意公众号的消息～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个入门问题，做微服务项目，首先就是要搭建 Project，代码采用什么样的形式来组织，这是我们面临的第一个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Maven" scheme="http://www.javaboy.org/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 要怎么学？为什么一定要成体系的学习？</title>
    <link href="http://www.javaboy.org/2020/0522/springsecurity-study.html"/>
    <id>http://www.javaboy.org/2020/0522/springsecurity-study.html</id>
    <published>2020-05-22T14:46:42.000Z</published>
    <updated>2020-06-05T15:08:39.568Z</updated>
    
    <content type="html"><![CDATA[<p>最近松哥在连载 Spring Security 系列，到目前为主，前前后后已经写了二十多篇了，从 Spring Security 入门开始，一步一步深入，直到现在。</p><a id="more"></a><p>当然这个系列还没有完结，目前还在继续连载中，欢迎小伙伴们保持关注。</p><p>有小伙伴看松哥的文章都是系列为主，不由得好奇，到底该如何成体系的学习一个框架？看书？还是看视频？还是看博客？</p><p>今天松哥结合自己的一些经验，和小伙伴们聊一聊这个话题。</p><h2 id="1-系统性学习"><a href="#1-系统性学习" class="headerlink" title="1.系统性学习"></a>1.系统性学习</h2><h3 id="1-1-为什么要系统性学习"><a href="#1-1-为什么要系统性学习" class="headerlink" title="1.1 为什么要系统性学习"></a>1.1 为什么要系统性学习</h3><p>为什么一定要系统性学习？不管你是不是做 IT，其实都有系统性学习的必要。</p><p>系统性的学习一个知识点，可以让我们在遇到问题时考虑的更加全面，这也是一个成熟的工程师应该具备的特征；碎片化的学习则很容易让我们得出一些片面的、甚至错误的结论。</p><p>然而，系统性学习需要耗费巨大的时间和精力，有的人可能会觉得不值得，就放弃了系统性学习，转而信仰<strong>复制粘贴改一下</strong>七字真言，一头扎进 CURD 的苦海。</p><p>工作之余和小伙伴们聊天，我也发现很多人都明白天天 CURD 的危害，想提高，但是不知道该从哪里入手？松哥告诉你，就从系统性学习入手。</p><h3 id="1-2-系统性学习如何切入"><a href="#1-2-系统性学习如何切入" class="headerlink" title="1.2 系统性学习如何切入"></a>1.2 系统性学习如何切入</h3><p>很多小伙伴不清楚系统性学习该从哪里入手？我给大家举一个简单的例子：</p><p>公司想要结合 RabbitMQ 搭建一个邮件服务器，可是你从来没用过 RabbitMQ，那怎么办？工作中的事情都是比较急的，所以一般可能这样做：</p><ul><li>网上搜一个教程，照着从头到尾搞一遍，成功了，工作搞定！不成功，就再搜搜一个教程搞，现在网上教程这么多，总有一款适合你。</li></ul><p>当借助网上的教程把工作中的问题搞定了，从此 RabbitMQ 就扔在一边了，再也不管了，以后出了问题，再继续搜索。</p><p>相信这可能是大部分小伙伴的日常。如果你想系统性学习，这就是一个很好的切入点，请继续看：</p><p>如果在搞定工作之后，利用业余时间买一本 RabbitMQ 相关的书，或者翻一遍它的官方文档，再去认真的啃一遍它里边消息队列、消息发送和确认、故障恢复、故障转移、REST API 操作 RabbitMQ、监控、性能提升等等各个方面，把它从头到尾的认真啃一遍，那么下次当你再遇到 RabbitMQ 相关的需求时，写代码就信手拈来了，因为你已经熟知 RabbitMQ 有哪些特性、可以实现哪些功能，不用再去一遍遍百度搜索。</p><p>其实我们日常工作中，有很多可以系统性学习的切入点。当你 Coding 的时候遇到问题了，百度搜一下，<strong>复制粘贴改一下</strong>就完事了，也不去深究到底是什么原因，这时候其实就错过了一个系统性学习的机会。其实这个时候可以想一想为什么是这样，如果从当前问题这个点深挖下去，就会有惊喜。</p><p>有的小伙伴表示平时工作太忙了，没时间系统性学习，这个问题其实我很难给你什么好的建议，我只能说，时间挤一挤总会有的。我属于那种对自己比较狠的，所以我基本上不会有这个问题，工作再忙我都有时间学习，但是我这种方式可能并不是适合所有人。</p><h2 id="2-如何入手一个新的框架"><a href="#2-如何入手一个新的框架" class="headerlink" title="2.如何入手一个新的框架"></a>2.如何入手一个新的框架</h2><p>总体上来说，有这样几种方式可以选择：</p><ul><li>看视频/网课</li><li>看书/看官网</li><li>网上看博客</li></ul><p>三种方式有的人不知道通过哪种方式学习效果好，或者应该选择哪种方式，松哥在这里给大家稍微分析一下。</p><p><strong>视频教程</strong></p><ul><li>优势：可以快速上手，短时间内了解到该技术的具体应用。</li><li>劣势：看视频比较费时间，所以大家看到各大视频网站一般都有倍速播放的功能。</li></ul><p><strong>看书</strong></p><ul><li>优势：书中的知识是成体系的，可以帮助读者构建关于一个知识点的完整知识体系；同时，看书也能更加深刻的理解某一个知识点。</li><li>劣势：书一般会有一点滞后性，毕竟知识点出来后，从写书到出版社出版发行，是需要时间的；另一方面就是对于新手而言，直接选择看书不一定看得懂。</li></ul><p><strong>看官网</strong></p><ul><li>优势：官网具备和书相同的优势，并且更加具备实时性。</li><li>劣势：大部分情况下，我们学习的技术官网可能都是英文的，所以这对读者的英文水平有一定的要求；另一方面就是官网的介绍虽然完整，但是却比较浅显，缺乏一些实际使用经验，从这个角度来看，图书融入了作者关于技术的使用经验，可能更胜一筹。</li></ul><p><strong>看博客</strong></p><ul><li>优势：博客能够触及到最新技术，而且获取极为方便，大部分的技术点网上都充斥着大量的博客。</li><li>劣势：大部分博客呈现碎片化知识，比较零散，不利于建立完整的知识体系。</li></ul><p>了解了每种方式的优劣势之后，我们再来看学习步骤：</p><ol><li>看视频快速入手，虽然略微花点时间，但是却是最有效的入门方式（如果你开发经验很丰富的话，或者直接撸书就能懂的话，可以跳过这一步）。</li><li>看书/看官网深入学习，充分发掘书系统性的特点。</li><li>看博客了解该技术的最新动态。</li></ol><p>通过这样的方式，我们就能系统性的学习某一个知识点，进而逐步建立起自己的知识体系。</p><h2 id="3-什么时候看源码比较合适"><a href="#3-什么时候看源码比较合适" class="headerlink" title="3.什么时候看源码比较合适"></a>3.什么时候看源码比较合适</h2><p>还有一个大家比较关心的问题，就是源码该怎么看？什么时候看比较合适？</p><p>这块我也来稍微说一下经验。</p><p>首先不建议一上来就尝试通读源码，这有点费时间。</p><p>源码阅读，建议采取“农村包围城市”的方式，即“点动成线,线动成面”，学习的时候，先学某一个技术点的应用，然后，结合具体的应用去分析相关的源码，这样源码阅读起来要容易很多。这块大家可以参考我最近在连载的 Spring Security 系列，基本就是按照这样的方式来的，每次讲完一个知识点，我会顺便带着大家看一下源码，这个时候源码看起来就不枯燥，很有意思。</p><p>当我们将一个一个知识点的源码攻克之后，最后再回过头从整体上看源码，你就会发现原来如此简单！</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>系统性学习是一个漫长艰辛的过程，对自己来说也是一场修炼，松哥写了很多系列教程（参考<a href="https://mp.weixin.qq.com/s/h59gk0euA6O3Blf8Kpup3Q" target="_blank" rel="noopener">不知不觉松哥已经撸了 8 个原创电子书了，今天打包下载！</a>），不仅仅帮助大家掌握技术，对我自己来说，也是一个知识梳理与提炼的过程，我很享受这种一个系列完结后的轻松与惬意，所以每一个系列尽量避免烂尾。</p><p>说到系统性学习，如果大家想系统性学习 Spring Boot+Vue+微人事+Spring Cloud+Redis，那么不妨看看松哥录制的视频教程<a href="https://mp.weixin.qq.com/s/h59gk0euA6O3Blf8Kpup3Q" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><p>好啦，今天周五就和小伙伴们随便聊一聊，下周我们来继续学习 Spring Security+CAS，小伙伴们敬请期待哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近松哥在连载 Spring Security 系列，到目前为主，前前后后已经写了二十多篇了，从 Spring Security 入门开始，一步一步深入，直到现在。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中密码加密的两种姿势！</title>
    <link href="http://www.javaboy.org/2020/0521/springsecurity-passwordencoder.html"/>
    <id>http://www.javaboy.org/2020/0521/springsecurity-passwordencoder.html</id>
    <published>2020-05-21T14:46:30.000Z</published>
    <updated>2020-06-05T15:09:52.098Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>先说一句：密码是无法解密的。大家也不要再问松哥微人事项目中的密码怎么解密了！</p><a id="more"></a><p>密码无法解密，还是为了确保系统安全。今天松哥就来和大家聊一聊，密码要如何处理，才能在最大程度上确保我们的系统安全。</p><p>本文是 Spring Security 系列的第 20 篇，阅读本系列前面的文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li></ol><h2 id="1-为什么要加密"><a href="#1-为什么要加密" class="headerlink" title="1.为什么要加密"></a>1.为什么要加密</h2><p>2011 年 12 月 21 日，有人在网络上公开了一个包含 600 万个 CSDN 用户资料的数据库，数据全部为明文储存，包含用户名、密码以及注册邮箱。事件发生后 CSDN 在微博、官方网站等渠道发出了声明，解释说此数据库系 2009 年备份所用，因不明原因泄露，已经向警方报案，后又在官网发出了公开道歉信。在接下来的十多天里，金山、网易、京东、当当、新浪等多家公司被卷入到这次事件中。整个事件中最触目惊心的莫过于 CSDN 把用户密码明文存储，由于很多用户是多个网站共用一个密码，因此一个网站密码泄露就会造成很大的安全隐患。由于有了这么多前车之鉴，我们现在做系统时，密码都要加密处理。</p><p>这次泄密，也留下了一些有趣的事情，特别是对于广大程序员设置密码这一项。人们从 CSDN 泄密的文件中，发现了一些好玩的密码，例如如下这些：</p><ul><li><code>ppnn13%dkstFeb.1st</code> 这段密码的中文解析是：娉娉袅袅十三余，豆蔻梢头二月初。</li><li><code>csbt34.ydhl12s</code> 这段密码的中文解析是：池上碧苔三四点，叶底黄鹂一两声</li><li>…</li></ul><p>等等不一而足，你会发现很多程序员的人文素养还是非常高的，让人啧啧称奇。</p><h2 id="2-加密方案"><a href="#2-加密方案" class="headerlink" title="2.加密方案"></a>2.加密方案</h2><p>密码加密我们一般会用到散列函数，又称散列算法、哈希函数，这是一种从任何数据中创建数字“指纹”的方法。</p><p>散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，重新创建一个散列值。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。</p><p>我们常用的散列函数有 MD5 消息摘要算法、安全散列算法（Secure Hash Algorithm）。</p><p>但是仅仅使用散列函数还不够，单纯的只使用散列函数，如果两个用户密码明文相同，生成的密文也会相同，这样就增加的密码泄漏的风险。</p><p>为了增加密码的安全性，一般在密码加密过程中还需要加盐，所谓的盐可以是一个随机数也可以是用户名，加盐之后，即使密码明文相同的用户生成的密码密文也不相同，这可以极大的提高密码的安全性。</p><p>传统的加盐方式需要在数据库中有专门的字段来记录盐值，这个字段可能是用户名字段（因为用户名唯一），也可能是一个专门记录盐值的字段，这样的配置比较繁琐。</p><p>Spring Security 提供了多种密码加密方案，官方推荐使用 BCryptPasswordEncoder，BCryptPasswordEncoder 使用 BCrypt 强哈希函数，开发者在使用时可以选择提供 strength 和 SecureRandom 实例。strength 越大，密钥的迭代次数越多，密钥迭代次数为 2^strength。strength 取值在 4~31 之间，默认为 10。</p><p>不同于 Shiro 中需要自己处理密码加盐，在 Spring Security 中，BCryptPasswordEncoder 就自带了盐，处理起来非常方便。</p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3.实践"></a>3.实践</h2><h3 id="3-1-codec-加密"><a href="#3-1-codec-加密" class="headerlink" title="3.1 codec 加密"></a>3.1 codec 加密</h3><p>commons-codec 是一个 Apache 上的开源项目，用它可以方便的实现密码加密。松哥在 <code>V 部落</code> 项目中就是采用的这种方案（<a href="https://github.com/lenve/VBlog）。在" target="_blank" rel="noopener">https://github.com/lenve/VBlog）。在</a> Spring Security 还未推出 BCryptPasswordEncoder 的时候，commons-codec 还是一个比较常见的解决方案。</p><p>所以，这里我先来给大家介绍下 commons-codec 的用法。</p><p>首先我们需要引入 commons-codec 的依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-codec<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-codec<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后自定义一个 PasswordEncoder：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPasswordEncoder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> DigestUtils.md5DigestAsHex(rawPassword.toString().getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> encodedPassword.equals(DigestUtils.md5DigestAsHex(rawPassword.toString().getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Security 中，PasswordEncoder 专门用来处理密码的加密与比对工作，我们自定义 MyPasswordEncoder 并实现 PasswordEncoder 接口，还需要实现该接口中的两个方法：</p><ol><li>encode 方法表示对密码进行加密，参数 rawPassword 就是你传入的明文密码，返回的则是加密之后的密文，这里的加密方案采用了 MD5。</li><li>matches 方法表示对密码进行比对，参数 rawPassword 相当于是用户登录时传入的密码，encodedPassword 则相当于是加密后的密码（从数据库中查询而来）。</li></ol><p>最后记得将 MyPasswordEncoder 通过 @Component 注解标记为 Spring 容器中的一个组件。</p><p>这样用户在登录时，就会自动调用 matches 方法进行密码比对。</p><p>当然，使用了 MyPasswordEncoder 之后，在用户注册时，就需要将密码加密之后存入数据库中，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reg</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-comment">//插入用户,插入之前先对密码进行加密</span></span><br><span class="line">    user.setPassword(passwordEncoder.encode(user.getPassword()));</span><br><span class="line">    result = userMapper.reg(user);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实很简单，就是调用 encode 方法对密码进行加密。完整代码大家可以参考 V 部落（<a href="https://github.com/lenve/VBlog），我这里就不赘述了。" target="_blank" rel="noopener">https://github.com/lenve/VBlog），我这里就不赘述了。</a></p><h3 id="3-2-BCryptPasswordEncoder-加密"><a href="#3-2-BCryptPasswordEncoder-加密" class="headerlink" title="3.2 BCryptPasswordEncoder 加密"></a>3.2 BCryptPasswordEncoder 加密</h3><p>但是自己定义 PasswordEncoder 还是有些麻烦，特别是处理密码加盐问题的时候。</p><p>所以在 Spring Security 中提供了 BCryptPasswordEncoder，使得密码加密加盐变得非常容易。只需要提供 BCryptPasswordEncoder 这个 Bean 的实例即可，微人事就是采用了这种方案（<a href="https://github.com/lenve/vhr），如下：" target="_blank" rel="noopener">https://github.com/lenve/vhr），如下：</a></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder(<span class="hljs-number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 BCryptPasswordEncoder 时传入的参数 10 就是 strength，即密钥的迭代次数（也可以不配置，默认为 10）。同时，配置的内存用户的密码也不再是 123 了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auth.inMemoryAuthentication()</span><br><span class="line">.withUser(<span class="hljs-string">"admin"</span>)</span><br><span class="line">.password(<span class="hljs-string">"$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq"</span>)</span><br><span class="line">.roles(<span class="hljs-string">"ADMIN"</span>, <span class="hljs-string">"USER"</span>)</span><br><span class="line">.and()</span><br><span class="line">.withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">.password(<span class="hljs-string">"$2a$10$eUHbAOMq4bpxTvOVz33LIehLe3fu6NwqC9tdOcxJXEhyZ4simqXTC"</span>)</span><br><span class="line">.roles(<span class="hljs-string">"USER"</span>);</span><br></pre></td></tr></table></figure><p>这里的密码就是使用 BCryptPasswordEncoder 加密后的密码，虽然 admin 和 sang 加密后的密码不一样，但是明文都是 123。配置完成后，使用 admin/123 或者 sang/123 就可以实现登录。</p><p>本案例使用了配置在内存中的用户，一般情况下，用户信息是存储在数据库中的，因此需要在用户注册时对密码进行加密处理，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reg</span><span class="hljs-params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        BCryptPasswordEncoder encoder = <span class="hljs-keyword">new</span> BCryptPasswordEncoder(<span class="hljs-number">10</span>);</span><br><span class="line">        String encodePasswod = encoder.encode(password);</span><br><span class="line">        <span class="hljs-keyword">return</span> saveToDb(username, encodePasswod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户将密码从前端传来之后，通过调用 BCryptPasswordEncoder 实例中的 encode 方法对密码进行加密处理，加密完成后将密文存入数据库。</p><h2 id="4-源码浅析"><a href="#4-源码浅析" class="headerlink" title="4.源码浅析"></a>4.源码浅析</h2><p>最后我们再来稍微看一下 PasswordEncoder。</p><p>PasswordEncoder 是一个接口，里边只有三个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">upgradeEncoding</span><span class="hljs-params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>encode 方法用来对密码进行加密。</li><li>matches 方法用来对密码进行比对。</li><li>upgradeEncoding 表示是否需要对密码进行再次加密以使得密码更加安全，默认为 false。</li></ul><p>Spring Security 为 PasswordEncoder 提供了很多实现：</p><p><img src="http://img.itboyhub.com/2020/05/PasswordEncoder.png" alt></p><p>但是老实说，自从有了 BCryptPasswordEncoder，我们很少关注其他实现类了。</p><p>PasswordEncoder 中的 encode 方法，是我们在用户注册的时候手动调用。</p><p>matches 方法，则是由系统调用，默认是在 DaoAuthenticationProvider#additionalAuthenticationChecks 方法中调用的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additionalAuthenticationChecks</span><span class="hljs-params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authentication.getCredentials() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Authentication failed: no credentials provided"</span>);</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"><span class="hljs-keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Authentication failed: password does not match stored value"</span>);</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，密码比对就是通过 passwordEncoder.matches 方法来进行的。</p><p>关于 DaoAuthenticationProvider 的调用流程，大家可以参考 <a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a>一文。</p><p>好了，今天就和小伙伴们简单聊一聊 Spring Security 加密问题，小伙伴们要是有收获记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;先说一句：密码是无法解密的。大家也不要再问松哥微人事项目中的密码怎么解密了！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>要学就学透彻！Spring Security 中 CSRF 防御源码解析</title>
    <link href="http://www.javaboy.org/2020/0520/springsecurity-csrf-sourcecode.html"/>
    <id>http://www.javaboy.org/2020/0520/springsecurity-csrf-sourcecode.html</id>
    <published>2020-05-20T14:46:17.000Z</published>
    <updated>2020-06-05T15:09:41.948Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">上篇文章</a>松哥和大家聊了什么是 CSRF 攻击，以及 CSRF 攻击要如何防御。主要和大家聊了 Spring Security 中处理该问题的几种办法。</p><a id="more"></a><p>今天松哥来和大家简单的看一下 Spring Security 中，CSRF 防御源码。</p><p>本文是本系列第 19 篇，阅读本系列前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li></ol><p>本文主要从两个方面来和大家讲解：</p><ol><li>返回给前端的 <code>_csrf</code> 参数是如何生成的。</li><li>前端传来的 <code>_csrf</code> 参数是如何校验的。</li></ol><h2 id="1-随机字符串生成"><a href="#1-随机字符串生成" class="headerlink" title="1.随机字符串生成"></a>1.随机字符串生成</h2><p>我们先来看一下 Spring Security 中的 csrf 参数是如何生成的。</p><p>首先，Spring Security 中提供了一个保存 csrf 参数的规范，就是 CsrfToken：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CsrfToken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getHeaderName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getParameterName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getToken</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里三个方法都好理解，前两个是获取 <code>_csrf</code> 参数的 key，第三个是获取 <code>_csrf</code> 参数的 value。</p><p>CsrfToken 有两个实现类，如下：</p><p><img src="http://img.itboyhub.com/2020/05/CsrfToken-2.png" alt></p><p>默认情况下使用的是 DefaultCsrfToken，我们来稍微看下 DefaultCsrfToken：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultCsrfToken</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CsrfToken</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String token;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String parameterName;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String headerName;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultCsrfToken</span><span class="hljs-params">(String headerName, String parameterName, String token)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.headerName = headerName;</span><br><span class="line"><span class="hljs-keyword">this</span>.parameterName = parameterName;</span><br><span class="line"><span class="hljs-keyword">this</span>.token = token;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getHeaderName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.headerName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getParameterName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.parameterName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getToken</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.token;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段实现很简单，几乎没有添加额外的方法，就是接口方法的实现。</p><p>CsrfToken 相当于就是 <code>_csrf</code> 参数的载体。那么参数是如何生成和保存的呢？这涉及到另外一个类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CsrfTokenRepository</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">CsrfToken <span class="hljs-title">generateToken</span><span class="hljs-params">(HttpServletRequest request)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveToken</span><span class="hljs-params">(CsrfToken token, HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span></span>;</span><br><span class="line"><span class="hljs-function">CsrfToken <span class="hljs-title">loadToken</span><span class="hljs-params">(HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里三个方法：</p><ol><li>generateToken 方法就是 CsrfToken 的生成过程。</li><li>saveToken 方法就是保存 CsrfToken。</li><li>loadToken 则是如何加载 CsrfToken。</li></ol><p>CsrfTokenRepository 有四个实现类，在<a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">上篇文章</a>中，我们用到了其中两个：HttpSessionCsrfTokenRepository 和 CookieCsrfTokenRepository，其中 HttpSessionCsrfTokenRepository 是默认的方案。</p><p><img src="http://img.itboyhub.com/2020/05/CsrfTokenRepository-3.png" alt></p><p>我们先来看下 HttpSessionCsrfTokenRepository 的实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpSessionCsrfTokenRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CsrfTokenRepository</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_CSRF_PARAMETER_NAME = <span class="hljs-string">"_csrf"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_CSRF_HEADER_NAME = <span class="hljs-string">"X-CSRF-TOKEN"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_CSRF_TOKEN_ATTR_NAME = HttpSessionCsrfTokenRepository.class</span><br><span class="line">.getName().concat(<span class="hljs-string">".CSRF_TOKEN"</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> String parameterName = DEFAULT_CSRF_PARAMETER_NAME;</span><br><span class="line"><span class="hljs-keyword">private</span> String headerName = DEFAULT_CSRF_HEADER_NAME;</span><br><span class="line"><span class="hljs-keyword">private</span> String sessionAttributeName = DEFAULT_CSRF_TOKEN_ATTR_NAME;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveToken</span><span class="hljs-params">(CsrfToken token, HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">session.removeAttribute(<span class="hljs-keyword">this</span>.sessionAttributeName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(<span class="hljs-keyword">this</span>.sessionAttributeName, token);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> CsrfToken <span class="hljs-title">loadToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (session == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> (CsrfToken) session.getAttribute(<span class="hljs-keyword">this</span>.sessionAttributeName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> CsrfToken <span class="hljs-title">generateToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultCsrfToken(<span class="hljs-keyword">this</span>.headerName, <span class="hljs-keyword">this</span>.parameterName,</span><br><span class="line">createNewToken());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">createNewToken</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码其实也很好理解：</p><ol><li>saveToken 方法将 CsrfToken 保存在 HttpSession 中，将来再从 HttpSession 中取出和前端传来的参数做笔记。</li><li>loadToken 方法当然就是从 HttpSession 中读取 CsrfToken 出来。</li><li>generateToken 是生成 CsrfToken 的过程，可以看到，生成的默认载体就是 DefaultCsrfToken，而 CsrfToken 的值则通过 createNewToken 方法生成，是一个 UUID 字符串。</li><li>在构造 DefaultCsrfToken 是还有两个参数 headerName 和 parameterName，这两个参数是前端保存参数的 key。</li></ol><p>这是默认的方案，适用于前后端不分的开发，具体用法可以参考<a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">上篇文章</a>。</p><p>如果想在前后端分离开发中使用，那就需要 CsrfTokenRepository 的另一个实现类 CookieCsrfTokenRepository ，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CookieCsrfTokenRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CsrfTokenRepository</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_CSRF_COOKIE_NAME = <span class="hljs-string">"XSRF-TOKEN"</span>;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_CSRF_PARAMETER_NAME = <span class="hljs-string">"_csrf"</span>;</span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_CSRF_HEADER_NAME = <span class="hljs-string">"X-XSRF-TOKEN"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> String parameterName = DEFAULT_CSRF_PARAMETER_NAME;</span><br><span class="line"><span class="hljs-keyword">private</span> String headerName = DEFAULT_CSRF_HEADER_NAME;</span><br><span class="line"><span class="hljs-keyword">private</span> String cookieName = DEFAULT_CSRF_COOKIE_NAME;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> cookieHttpOnly = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> String cookiePath;</span><br><span class="line"><span class="hljs-keyword">private</span> String cookieDomain;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CookieCsrfTokenRepository</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> CsrfToken <span class="hljs-title">generateToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultCsrfToken(<span class="hljs-keyword">this</span>.headerName, <span class="hljs-keyword">this</span>.parameterName,</span><br><span class="line">createNewToken());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveToken</span><span class="hljs-params">(CsrfToken token, HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String tokenValue = token == <span class="hljs-keyword">null</span> ? <span class="hljs-string">""</span> : token.getToken();</span><br><span class="line">Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-keyword">this</span>.cookieName, tokenValue);</span><br><span class="line">cookie.setSecure(request.isSecure());</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cookiePath != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.cookiePath.isEmpty()) &#123;</span><br><span class="line">cookie.setPath(<span class="hljs-keyword">this</span>.cookiePath);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">cookie.setPath(<span class="hljs-keyword">this</span>.getRequestContext(request));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">cookie.setMaxAge(<span class="hljs-number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">cookie.setMaxAge(-<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cookie.setHttpOnly(cookieHttpOnly);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cookieDomain != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.cookieDomain.isEmpty()) &#123;</span><br><span class="line">cookie.setDomain(<span class="hljs-keyword">this</span>.cookieDomain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> CsrfToken <span class="hljs-title">loadToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Cookie cookie = WebUtils.getCookie(request, <span class="hljs-keyword">this</span>.cookieName);</span><br><span class="line"><span class="hljs-keyword">if</span> (cookie == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String token = cookie.getValue();</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(token)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultCsrfToken(<span class="hljs-keyword">this</span>.headerName, <span class="hljs-keyword">this</span>.parameterName, token);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CookieCsrfTokenRepository <span class="hljs-title">withHttpOnlyFalse</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">CookieCsrfTokenRepository result = <span class="hljs-keyword">new</span> CookieCsrfTokenRepository();</span><br><span class="line">result.setCookieHttpOnly(<span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">createNewToken</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 HttpSessionCsrfTokenRepository 相比，这里 <code>_csrf</code> 数据保存的时候，都保存到 cookie 中去了，当然读取的时候，也是从 cookie 中读取，其他地方则和 HttpSessionCsrfTokenRepository 是一样的。</p><p>OK，这就是我们整个 <code>_csrf</code> 参数生成的过程。</p><p>总结一下，就是生成一个 CsrfToken，这个 Token，本质上就是一个 UUID 字符串，然后将这个 Token 保存到 HttpSession 中，或者保存到 Cookie 中，待请求到来时，从 HttpSession 或者 Cookie 中取出来做校验。</p><h2 id="2-参数校验"><a href="#2-参数校验" class="headerlink" title="2.参数校验"></a>2.参数校验</h2><p>那接下来就是校验了。</p><p>校验主要是通过 CsrfFilter 过滤器来进行，我们来看下核心的 doFilterInternal 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.setAttribute(HttpServletResponse.class.getName(), response);</span><br><span class="line">CsrfToken csrfToken = <span class="hljs-keyword">this</span>.tokenRepository.loadToken(request);</span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> missingToken = csrfToken == <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (missingToken) &#123;</span><br><span class="line">csrfToken = <span class="hljs-keyword">this</span>.tokenRepository.generateToken(request);</span><br><span class="line"><span class="hljs-keyword">this</span>.tokenRepository.saveToken(csrfToken, request, response);</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(CsrfToken.class.getName(), csrfToken);</span><br><span class="line">request.setAttribute(csrfToken.getParameterName(), csrfToken);</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.requireCsrfProtectionMatcher.matches(request)) &#123;</span><br><span class="line">filterChain.doFilter(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String actualToken = request.getHeader(csrfToken.getHeaderName());</span><br><span class="line"><span class="hljs-keyword">if</span> (actualToken == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">actualToken = request.getParameter(csrfToken.getParameterName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!csrfToken.getToken().equals(actualToken)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">"Invalid CSRF token found for "</span></span><br><span class="line">+ UrlUtils.buildFullRequestUrl(request));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (missingToken) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.accessDeniedHandler.handle(request, response,</span><br><span class="line"><span class="hljs-keyword">new</span> MissingCsrfTokenException(actualToken));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.accessDeniedHandler.handle(request, response,</span><br><span class="line"><span class="hljs-keyword">new</span> InvalidCsrfTokenException(csrfToken, actualToken));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法我来稍微解释下：</p><ol><li>首先调用 tokenRepository.loadToken 方法读取 CsrfToken 出来，这个 tokenRepository 就是你配置的 CsrfTokenRepository 实例，CsrfToken 存在 HttpSession 中，这里就从 HttpSession 中读取，CsrfToken 存在 Cookie 中，这里就从 Cookie 中读取。</li><li>如果调用 tokenRepository.loadToken 方法没有加载到 CsrfToken，那说明这个请求可能是第一次发起，则调用 tokenRepository.generateToken 方法生成 CsrfToken ，并调用 tokenRepository.saveToken 方法保存 CsrfToken。</li><li>大家注意，这里还调用 request.setAttribute 方法存了一些值进去，这就是默认情况下，我们通过 jsp 或者 thymeleaf 标签渲染 <code>_csrf</code> 的数据来源。</li><li>requireCsrfProtectionMatcher.matches 方法则使用用来判断哪些请求方法需要做校验，默认情况下，”GET”, “HEAD”, “TRACE”, “OPTIONS” 方法是不需要校验的。</li><li>接下来获取请求中传递来的 CSRF 参数，先从请求头中获取，获取不到再从请求参数中获取。</li><li>获取到请求传来的 csrf 参数之后，再和一开始加载到的 csrfToken 做比较，如果不同的话，就抛出异常。</li></ol><p>如此之后，就完成了整个校验工作了。</p><h2 id="3-LazyCsrfTokenRepository"><a href="#3-LazyCsrfTokenRepository" class="headerlink" title="3.LazyCsrfTokenRepository"></a>3.LazyCsrfTokenRepository</h2><p>前面我们说了 CsrfTokenRepository 有四个实现类，除了我们介绍的两个之外，还有一个 LazyCsrfTokenRepository，这里松哥也和大家做一个简单介绍。</p><p>在前面的 CsrfFilter 中大家发现，对于常见的 GET 请求实际上是不需要 CSRF 攻击校验的，但是，每当 GET 请求到来时，下面这段代码都会执行：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (missingToken) &#123;</span><br><span class="line">csrfToken = <span class="hljs-keyword">this</span>.tokenRepository.generateToken(request);</span><br><span class="line"><span class="hljs-keyword">this</span>.tokenRepository.saveToken(csrfToken, request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成 CsrfToken 并保存，但实际上却没什么用，因为 GET 请求不需要 CSRF 攻击校验。</p><p>所以，Spring Security 官方又推出了 LazyCsrfTokenRepository。</p><p>LazyCsrfTokenRepository 实际上不能算是一个真正的 CsrfTokenRepository，它是一个代理，可以用来增强 HttpSessionCsrfTokenRepository 或者 CookieCsrfTokenRepository 的功能：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyCsrfTokenRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CsrfTokenRepository</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> CsrfToken <span class="hljs-title">generateToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> wrap(request, <span class="hljs-keyword">this</span>.delegate.generateToken(request));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveToken</span><span class="hljs-params">(CsrfToken token, HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.delegate.saveToken(token, request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> CsrfToken <span class="hljs-title">loadToken</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.delegate.loadToken(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> CsrfToken <span class="hljs-title">wrap</span><span class="hljs-params">(HttpServletRequest request, CsrfToken token)</span> </span>&#123;</span><br><span class="line">HttpServletResponse response = getResponse(request);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SaveOnAccessCsrfToken(<span class="hljs-keyword">this</span>.delegate, request, response, token);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SaveOnAccessCsrfToken</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CsrfToken</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> CsrfTokenRepository tokenRepository;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HttpServletRequest request;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HttpServletResponse response;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CsrfToken delegate;</span><br><span class="line"></span><br><span class="line">SaveOnAccessCsrfToken(CsrfTokenRepository tokenRepository,</span><br><span class="line">HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">CsrfToken delegate) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.tokenRepository = tokenRepository;</span><br><span class="line"><span class="hljs-keyword">this</span>.request = request;</span><br><span class="line"><span class="hljs-keyword">this</span>.response = response;</span><br><span class="line"><span class="hljs-keyword">this</span>.delegate = delegate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getToken</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">saveTokenIfNecessary();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.delegate.getToken();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveTokenIfNecessary</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tokenRepository == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tokenRepository != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.tokenRepository.saveToken(<span class="hljs-keyword">this</span>.delegate, <span class="hljs-keyword">this</span>.request,</span><br><span class="line"><span class="hljs-keyword">this</span>.response);</span><br><span class="line"><span class="hljs-keyword">this</span>.tokenRepository = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">this</span>.request = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">this</span>.response = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我说三点：</p><ol><li>generateToken 方法，该方法用来生成 CsrfToken，默认 CsrfToken 的载体是 DefaultCsrfToken，现在换成了 SaveOnAccessCsrfToken。</li><li>SaveOnAccessCsrfToken 和 DefaultCsrfToken 并没有太大区别，主要是 getToken 方法有区别，在 SaveOnAccessCsrfToken 中，当开发者调用 getToken 想要去获取 csrfToken 时，才会去对 csrfToken 做保存操作（调用 HttpSessionCsrfTokenRepository 或者 CookieCsrfTokenRepository 的 saveToken 方法）。</li><li>LazyCsrfTokenRepository 自己的 saveToken 则做了修改，相当于放弃了 saveToken 的功能，调用该方法并不会做保存操作。</li></ol><p>使用了 LazyCsrfTokenRepository 之后，只有在使用 csrfToken 时才会去存储它，这样就可以节省存储空间了。</p><p>LazyCsrfTokenRepository 的配置方式也很简单，在我们使用 Spring Security 时，如果对 csrf 不做任何配置，默认其实就是 LazyCsrfTokenRepository+HttpSessionCsrfTokenRepository 组合。</p><p>当然我们也可以自己配置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">            .successHandler((req,resp,authentication)-&gt;&#123;</span><br><span class="line">                resp.getWriter().write(<span class="hljs-string">"success"</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().csrfTokenRepository(<span class="hljs-keyword">new</span> LazyCsrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>今天主要和小伙伴聊了一下 Spring Security 中 csrf 防御的原理。</p><p>整体来说，就是两个思路：</p><ol><li>生成 csrfToken 保存在 HttpSession 或者 Cookie 中。</li><li>请求到来时，从请求中提取出来 csrfToken，和保存的 csrfToken 做比较，进而判断出当前请求是否合法。</li></ol><p>好啦，不知道小伙伴们有没有 GET 到呢？如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;松哥和大家聊了什么是 CSRF 攻击，以及 CSRF 攻击要如何防御。主要和大家聊了 Spring Security 中处理该问题的几种办法。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</title>
    <link href="http://www.javaboy.org/2020/0519/springsecurity-csrf.html"/>
    <id>http://www.javaboy.org/2020/0519/springsecurity-csrf.html</id>
    <published>2020-05-19T14:46:00.000Z</published>
    <updated>2020-06-05T15:09:36.781Z</updated>
    
    <content type="html"><![CDATA[<p>CSRF 就是跨域请求伪造，英文全称是 Cross Site Request Forgery。</p><a id="more"></a><p>这是一种非常常见的 Web 攻击方式，其实是很好防御的，但是由于经常被很多开发者忽略，进而导致很多网站实际上都存在 CSRF 攻击的安全隐患。</p><p>今天松哥就来和大家聊一聊什么是 CSRF 攻击以及 CSRF 攻击该如何防御。</p><p>本文是本系列第 18 篇，阅读本系列前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li></ol><h2 id="1-CSRF原理"><a href="#1-CSRF原理" class="headerlink" title="1.CSRF原理"></a>1.CSRF原理</h2><p>想要防御 CSRF 攻击，那我们得先搞清楚什么是 CSRF 攻击，松哥通过下面一张图，来和大家梳理 CSRF 攻击流程：</p><p><img src="http://img.itboyhub.com/2020/05/csrf-1.png" alt></p><p>其实这个流程很简单：</p><ol><li>假设用户打开了招商银行网上银行网站，并且登录。</li><li>登录成功后，网上银行会返回 Cookie 给前端，浏览器将 Cookie 保存下来。</li><li>用户在没有登出网上银行的情况下，在浏览器里边打开了一个新的选项卡，然后又去访问了一个危险网站。</li><li>这个危险网站上有一个超链接，超链接的地址指向了招商银行网上银行。</li><li>用户点击了这个超链接，由于这个超链接会自动携带上浏览器中保存的 Cookie，所以用户不知不觉中就访问了网上银行，进而可能给自己造成了损失。</li></ol><p>CSRF 的流程大致就是这样，接下来松哥用一个简单的例子和小伙伴们展示一下 CSRF 到底是怎么回事。</p><h2 id="2-CSRF实践"><a href="#2-CSRF实践" class="headerlink" title="2.CSRF实践"></a>2.CSRF实践</h2><p>接下来，我创建一个名为 csrf-1 的 Spring Boot 项目，这个项目相当于我们上面所说的网上银行网站，创建项目时引入 Web 和 Spring Security 依赖，如下：</p><p><img src="http://img.itboyhub.com/2020/05/20200516201607.png" alt></p><p>创建成功后，方便起见，我们直接将 Spring Security 用户名/密码 配置在 application.properties 文件中：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=123</span><br></pre></td></tr></table></figure><p>然后我们提供两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/transfer"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transferMoney</span><span class="hljs-params">(String name, Integer money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">        System.out.println(<span class="hljs-string">"money = "</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设 <code>/transfer</code> 是一个转账接口（这里是假设，主要是给大家演示 CSRF 攻击，真实的转账接口比这复杂）。</p><p>最后我们还需要配置一下 Spring Security，因为 Spring Security 中默认是可以自动防御 CSRF 攻击的，所以我们要把这个关闭掉：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，我们启动 csrf-1 项目。</p><p>接下来，我们再创建一个 csrf-2 项目，这个项目相当于是一个危险网站，为了方便，这里创建时我们只需要引入 web 依赖即可。</p><p>项目创建成功后，首先修改项目端口：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><p>然后我们在 resources/static 目录下创建一个 hello.html ，内容如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"http://localhost:8080/transfer"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"javaboy"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10000"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"money"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"点击查看美女图片"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有一个超链接，超链接的文本是<strong>点击查看美女图片</strong>，当你点击了超链接之后，会自动请求 <code>http://localhost:8080/transfer</code> 接口，同时隐藏域还携带了两个参数。</p><p>配置完成后，就可以启动 csrf-2 项目了。</p><p>接下来，用户首先访问 csrf-1 项目中的接口，在访问的时候需要登录，用户就执行了登录操作，访问完整后，用户并没有执行登出操作，然后用户访问 csrf-2 中的页面，看到了超链接，好奇这美女到底长啥样，一点击，结果钱就被人转走了。</p><h2 id="3-CSRF防御"><a href="#3-CSRF防御" class="headerlink" title="3.CSRF防御"></a>3.CSRF防御</h2><p>先来说说防御思路。</p><p>CSRF 防御，一个核心思路就是在前端请求中，添加一个随机数。</p><p>因为在 CSRF 攻击中，黑客网站其实是不知道用户的 Cookie 具体是什么的，他是让用户自己发送请求到网上银行这个网站的，因为这个过程会自动携带上 Cookie 中的信息。</p><p>所以我们的防御思路是这样：用户在访问网上银行时，除了携带 Cookie 中的信息之外，还需要携带一个随机数，如果用户没有携带这个随机数，则网上银行网站会拒绝该请求。黑客网站诱导用户点击超链接时，会自动携带上 Cookie 中的信息，但是却不会自动携带随机数，这样就成功的避免掉 CSRF 攻击了。</p><p>Spring Security 中对此提供了很好的支持，我们一起来看下。</p><h3 id="3-1-默认方案"><a href="#3-1-默认方案" class="headerlink" title="3.1 默认方案"></a>3.1 默认方案</h3><p>Spring Security 中默认实际上就提供了 csrf 防御，但是需要开发者做的事情比较多。</p><p>首先我们来创建一个新的 Spring Boot 工程，创建时引入 Spring Security、Thymeleaf 和 web 依赖。</p><p><img src="http://img.itboyhub.com/2020/05/20200516213825.png" alt></p><p>项目创建成功后，我们还是在 application.properties 中配置用户名/密码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=123</span><br></pre></td></tr></table></figure><p>接下来，我们提供一个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个测试接口是一个 POST 请求，因为默认情况下，GET、HEAD、TRACE 以及 OPTIONS 是不需要验证 CSRF 攻击的。</p><p>然后，我们在 resources/templates 目录下，新建一个 thymeleaf 模版，如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/hello"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"$&#123;_csrf.token&#125;"</span> <span class="hljs-attr">th:name</span>=<span class="hljs-string">"$&#123;_csrf.parameterName&#125;"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"hello"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，在发送 POST 请求的时候，还额外携带了一个隐藏域，隐藏域的 key 是 <code>${_csrf.parameterName}</code>，value 则是 <code>${_csrf.token}</code>。</p><p>这两个值服务端会自动带过来，我们只需要在前端渲染出来即可。</p><p>接下来给前端 hello.html 页面添加一个控制器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完成后，启动项目，我们访问 hello 页面，在访问时候，需要先登录，登录成功之后，我们可以看到登录请求中也多了一个参数，如下：</p><p><img src="http://img.itboyhub.com/2020/05/20200516210028.png" alt></p><p>可以看到，这里也多了 <code>_csrf</code> 参数。</p><p>这里我们用了 Spring Security 的默认登录页面，如果大家使用自定义登录页面，可以参考上面 hello.html 的写法，通过一个隐藏域传递 <code>_csrf</code> 参数。</p><p>访问到 hello 页面之后，再去点击按钮，就可以访问到 hello 接口了。</p><blockquote><p>小伙伴们可以自行尝试在 hello.html 页面中，去掉 <code>_csrf</code> 参数，看看访问 hello 接口的效果。</p></blockquote><p>这是 Spring Security 中默认的方案，通过 Model 将相关的数据带到前端来。</p><p>如果你的项目是前后端不分项目，这种方案就可以了，如果你的项目是前后端分离项目，这种方案很明显不够用。</p><h3 id="3-2-前后端分离方案"><a href="#3-2-前后端分离方案" class="headerlink" title="3.2 前后端分离方案"></a>3.2 前后端分离方案</h3><p>如果是前后端分离项目，Spring Security 也提供了解决方案。</p><p>这次不是将 <code>_csrf</code> 放在 Model 中返回前端了，而是放在 Cookie 中返回前端，配置方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有小伙伴可能会说放在 Cookie 中不是又被黑客网站盗用了吗？其实不会的，大家注意如下两个问题：</p><ol><li>黑客网站根本不知道你的 Cookie 里边存的啥，他也不需要知道，因为 CSRF 攻击是浏览器自动携带上 Cookie 中的数据的。</li><li>我们将服务端生成的随机数放在 Cookie 中，前端需要从 Cookie 中自己提取出来 <code>_csrf</code> 参数，然后拼接成参数传递给后端，单纯的将 Cookie 中的数据传到服务端是没用的。</li></ol><p>理解透了上面两点，你就会发现 <code>_csrf</code> 放在 Cookie 中是没有问题的，但是大家注意，配置的时候我们通过 withHttpOnlyFalse 方法获取了 CookieCsrfTokenRepository 的实例，该方法会设置 Cookie 中的 HttpOnly 属性为 false，也就是允许前端通过 js 操作 Cookie（否则你就没有办法获取到 <code>_csrf</code>）。</p><p>配置完成后，重启项目，此时我们就发现返回的 Cookie 中多了一项：</p><p><img src="http://img.itboyhub.com/2020/05/20200516234139.png" alt></p><p>接下来，我们通过自定义登录页面，来看看前端要如何操作。</p><p>首先我们在 resources/static 目录下新建一个 html 页面叫做 login.html：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/jquery.min.js"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/jquery.cookie.js"</span>&gt;</span><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"username"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"password"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登录"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loginBtn"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="hljs-undefined"></span></span><br><span class="line"><span class="hljs-javascript">    $(<span class="hljs-string">"#loginBtn"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="line"><span class="hljs-javascript">        <span class="hljs-keyword">let</span> _csrf = $.cookie(<span class="hljs-string">'XSRF-TOKEN'</span>);</span></span><br><span class="line"><span class="hljs-javascript">        $.post(<span class="hljs-string">'/login.html'</span>,&#123;<span class="hljs-attr">username</span>:$(<span class="hljs-string">"#username"</span>).val(),<span class="hljs-attr">password</span>:$(<span class="hljs-string">"#password"</span>).val(),<span class="hljs-attr">_csrf</span>:_csrf&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="hljs-undefined">            alert(data);</span></span><br><span class="line"><span class="hljs-undefined">        &#125;)</span></span><br><span class="line"><span class="hljs-undefined">    &#125;)</span></span><br><span class="line"><span class="hljs-undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这段 html 我给大家解释下：</p><ol><li>首先引入 jquery 和 jquery.cookie ，方便我们一会操作 Cookie。</li><li>定义三个 input，前两个是用户名和密码，第三个是登录按钮。</li><li>点击登录按钮之后，我们先从 Cookie 中提取出 XSRF-TOKEN，这也就是我们要上传的 csrf 参数。</li><li>通过一个 POST 请求执行登录操作，注意携带上 <code>_csrf</code> 参数。</li></ol><p>服务端我们也稍作修改，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="hljs-string">"/js/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">                .successHandler((req,resp,authentication)-&gt;&#123;</span><br><span class="line">                    resp.getWriter().write(<span class="hljs-string">"success"</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一方面这里给 js 文件放行。</p><p>另一方面配置一下登录页面，以及登录成功的回调，这里简单期间，登录成功的回调我就给一个字符串就可以了。大家感兴趣的话，可以查看<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319828555819286528&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">本系列</a>前面文章，有登录成功后回调的详细解释。</p><p>OK，所有事情做完之后，我们访问 login.html 页面，输入用户名密码进行登录，结果如下：</p><p><img src="http://img.itboyhub.com/2020/05/20200517000551.png" alt></p><p>可以看到，我们的 <code>_csrf</code> 配置已经生效了。</p><blockquote><p>小伙伴们可以自行尝试从登录参数中去掉 <code>_csrf</code>，然后再看看效果。</p></blockquote><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好了，今天主要和小伙伴们介绍了 csrf 攻击以及如何防御的问题。大家看到，csrf 攻击主要是借助了浏览器默认发送 Cookie 的这一机制，所以如果你的前端是 App、小程序之类的应用，不涉及浏览器应用的话，其实可以忽略这个问题，如果你的前端包含浏览器应用的话，这个问题就要认真考虑了。</p><p>好了 ，本文就说到这里，本文相关案例我已经上传到 GitHub ，大家可以自行下载:<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>好啦，不知道小伙伴们有没有 GET 到呢？如果有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSRF 就是跨域请求伪造，英文全称是 Cross Site Request Forgery。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>集群化部署，Spring Security 要如何处理 session 共享？</title>
    <link href="http://www.javaboy.org/2020/0518/springsecurity-spring-session.html"/>
    <id>http://www.javaboy.org/2020/0518/springsecurity-spring-session.html</id>
    <published>2020-05-18T14:45:46.000Z</published>
    <updated>2020-06-05T15:09:32.226Z</updated>
    
    <content type="html"><![CDATA[<p>前面和大家聊了 Spring Security 如何像 QQ 一样，自动踢掉已登录用户（<a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a>），但是前面我们是基于单体应用的，如果我们的项目是集群化部署，这个问题该如何解决呢？</p><a id="more"></a><p>今天我们就来看看集群化部署，Spring Security 要如何处理 session 并发。</p><p>本文是 Spring Security 系列第 17 篇，阅读前面的文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li></ol><h2 id="1-集群会话方案"><a href="#1-集群会话方案" class="headerlink" title="1.集群会话方案"></a>1.集群会话方案</h2><p>在传统的单服务架构中，一般来说，只有一个服务器，那么不存在 Session 共享问题，但是在分布式/集群项目中，Session 共享则是一个必须面对的问题，先看一个简单的架构图：</p><p><img src="http://img.itboyhub.com/2020/05/14-1.png" alt></p><p>在这样的架构中，会出现一些单服务中不存在的问题，例如客户端发起一个请求，这个请求到达 Nginx 上之后，被 Nginx 转发到 Tomcat A 上，然后在 Tomcat A 上往 session 中保存了一份数据，下次又来一个请求，这个请求被转发到 Tomcat B  上，此时再去 Session 中获取数据，发现没有之前的数据。</p><h3 id="1-1-session-共享"><a href="#1-1-session-共享" class="headerlink" title="1.1 session 共享"></a>1.1 session 共享</h3><p>对于这一类问题的解决，目前比较主流的方案就是将各个服务之间需要共享的数据，保存到一个公共的地方（主流方案就是 Redis）：</p><p><img src="http://img.itboyhub.com/2020/05/14-2.png" alt></p><p>当所有 Tomcat 需要往 Session 中写数据时，都往 Redis 中写，当所有 Tomcat 需要读数据时，都从 Redis 中读。这样，不同的服务就可以使用相同的 Session 数据了。</p><p>这样的方案，可以由开发者手动实现，即手动往 Redis 中存储数据，手动从 Redis 中读取数据，相当于使用一些 Redis 客户端工具来实现这样的功能，毫无疑问，手动实现工作量还是蛮大的。</p><p>一个简化的方案就是使用 Spring Session 来实现这一功能，Spring Session 就是使用 Spring 中的代理过滤器，将所有的 Session 操作拦截下来，自动的将数据 同步到 Redis 中，或者自动的从 Redis 中读取数据。</p><p>对于开发者来说，所有关于 Session 同步的操作都是透明的，开发者使用 Spring Session，一旦配置完成后，具体的用法就像使用一个普通的 Session 一样。</p><h3 id="1-2-session-拷贝"><a href="#1-2-session-拷贝" class="headerlink" title="1.2 session 拷贝"></a>1.2 session 拷贝</h3><p>session 拷贝就是不利用 redis，直接在各个 Tomcat 之间进行 session 数据拷贝，但是这种方式效率有点低，Tomcat A、B、C 中任意一个的 session 发生了变化，都需要拷贝到其他 Tomcat 上，如果集群中的服务器数量特别多的话，这种方式不仅效率低，还会有很严重的延迟。</p><p>所以这种方案一般作为了解即可。</p><h3 id="1-3-粘滞会话"><a href="#1-3-粘滞会话" class="headerlink" title="1.3 粘滞会话"></a>1.3 粘滞会话</h3><p>所谓的粘滞会话就是将相同 IP 发送来的请求，通过 Nginx 路由到同一个 Tomcat 上去，这样就不用进行 session 共享与同步了。这是一个办法，但是在一些极端情况下，可能会导致负载失衡（因为大部分情况下，都是很多人用同一个公网 IP）。</p><p><strong>所以，Session 共享就成为了这个问题目前主流的解决方案了。</strong></p><h2 id="2-Session共享"><a href="#2-Session共享" class="headerlink" title="2.Session共享"></a>2.Session共享</h2><h3 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1 创建工程"></a>2.1 创建工程</h3><p>首先 创建一个 Spring Boot 工程，引入 Web、Spring Session、Spring Security 以及 Redis:</p><p><img src="http://img.itboyhub.com/2020/05/20200514092541.png" alt></p><p>创建成功之后，pom.xml 文件如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.redis.password=123</span><br><span class="line">spring.redis.port=6379</span><br><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line"></span><br><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=123</span><br><span class="line"></span><br><span class="line">server.port=8080</span><br></pre></td></tr></table></figure><p>配置一下 Redis 的基本信息；Spring Security 为了简化，我就将用户名密码直接配置在 application.properties 中了，最后再配置一下项目端口号。</p><h3 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h3><p>配置完成后 ，就可以使用 Spring Session 了，其实就是使用普通的 HttpSession ，其他的 Session 同步到 Redis 等操作，框架已经自动帮你完成了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    Integer port;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/set"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        session.setAttribute(<span class="hljs-string">"user"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> String.valueOf(port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/get"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> session.getAttribute(<span class="hljs-string">"user"</span>) + <span class="hljs-string">":"</span> + port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到一会 Spring Boot 将以集群的方式启动 ，为了获取每一个请求到底是哪一个 Spring  Boot 提供的服务，需要在每次请求时返回当前服务的端口号，因此这里我注入了 server.port 。</p><p>接下来 ，项目打包：</p><p><img src="http://img.itboyhub.com/2020/05/14-4.png" alt></p><p>打包之后，启动项目的两个实例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar session-4-0.0.1-SNAPSHOT.jar --server.port=8080</span><br><span class="line">java -jar session-4-0.0.1-SNAPSHOT.jar --server.port=8081</span><br></pre></td></tr></table></figure><p>然后先访问 <code>localhost:8080/set</code> 向 <code>8080</code> 这个服务的 <code>Session</code> 中保存一个变量，第一次访问时会自动跳转到登录页面，输入用户名密码进行登录即可。访问成功后，数据就已经自动同步到 <code>Redis</code>  中 了 ：</p><p><img src="http://img.itboyhub.com/2020/05/20200514104238.png" alt></p><p>然后，再调用 <code>localhost:8081/get</code> 接口，就可以获取到 <code>8080</code> 服务的 <code>session</code> 中的数据：</p><p><img src="http://img.itboyhub.com/2020/05/14-6.png" alt></p><p>此时关于 session 共享的配置就已经全部完成了，session 共享的效果我们已经看到了。</p><h3 id="2-4-Security-配置"><a href="#2-4-Security-配置" class="headerlink" title="2.4 Security 配置"></a>2.4 Security 配置</h3><p>Session 共享已经实现了，但是我们发现新的问题，在<a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a>一文中我们配置的 session 并发管理失效了。</p><p>也就是说，如果我添加了如下配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests().anyRequest()</span><br><span class="line">            ...</span><br><span class="line">            .sessionManagement()</span><br><span class="line">            .maximumSessions(<span class="hljs-number">1</span>)</span><br><span class="line">            .maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个配置不起作用，用户依然可以在多个浏览器上同时登录。</p><p>这是怎么回事呢？</p><p>首先建议大家回忆一下<a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a>一文。</p><p>在该文中，我们提到，会话注册表的维护默认是由 SessionRegistryImpl 来维护的，而 SessionRegistryImpl 的维护就是基于内存的维护。现在我们虽然启用了 Spring Session+Redis 做 Session 共享，但是 SessionRegistryImpl 依然是基于内存来维护的，所以我们要修改 SessionRegistryImpl 的实现逻辑。</p><p>修改方式也很简单，实际上 Spring Session 为我们提供了对应的实现类 SpringSessionBackedSessionRegistry，具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    FindByIndexNameSessionRepository sessionRepository;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest()</span><br><span class="line">                ...</span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .maximumSessions(<span class="hljs-number">1</span>)</span><br><span class="line">                .maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>)</span><br><span class="line">                .sessionRegistry(sessionRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">SpringSessionBackedSessionRegistry <span class="hljs-title">sessionRegistry</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringSessionBackedSessionRegistry(sessionRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里只需要提供一个 SpringSessionBackedSessionRegistry 的实例，并且将其配置到 sessionManagement 中去即可。以后，session 并发数据的维护将由 SpringSessionBackedSessionRegistry 来完成，而不是 SessionRegistryImpl，<strong>如此，我们关于 session 并发的配置就生效了，在集群环境下，用户也只可以在一台设备上登录。</strong></p><p>为了让我们的案例看起更完美一些，接下来我们来引入 Nginx ，实现服务实例自动切换。</p><h2 id="3-引入-Nginx"><a href="#3-引入-Nginx" class="headerlink" title="3.引入 Nginx"></a>3.引入 Nginx</h2><p>很简单，进入  Nginx 的安装目录的 conf 目录下（默认是在 <code>/usr/local/nginx/conf</code>），编辑 nginx.conf 文件:</p><p><img src="http://img.itboyhub.com/2020/05/14-7.png" alt></p><p>在这段配置中：</p><ol><li>upstream 表示配置上游服务器</li><li>javaboy.org 表示服务器集群的名字，这个可以随意取名字</li><li>upstream 里边配置的是一个个的单独服务</li><li>weight 表示服务的权重，意味者将有多少比例的请求从 Nginx 上转发到该服务上</li><li>location 中的 proxy_pass 表示请求转发的地址，<code>/</code> 表示拦截到所有的请求，转发转发到刚刚配置好的服务集群中</li><li>proxy_redirect 表示设置当发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址，我们需要将之修改使之成为 Nginx 的地址）。</li></ol><p>配置完成后，将本地的 Spring Boot 打包好的 jar 上传到 Linux ，然后在 Linux 上分别启动两个 Spring Boot 实例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar session-4-0.0.1-SNAPSHOT.jar --server.port=8080 &amp;</span><br><span class="line">nohup java -jar session-4-0.0.1-SNAPSHOT.jar --server.port=8081 &amp;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li>nohup 表示当终端关闭时，Spring Boot 不要停止运行</li><li>&amp; 表示让 Spring Boot 在后台启动</li></ul><p>配置完成后，重启 Nginx：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>Nginx 启动成功后，我们首先手动清除 Redis 上的数据，然后访问 <code>192.168.66.128/set</code> 表示向 <code>session</code> 中保存数据，这个请求首先会到达 <code>Nginx</code> 上，再由 <code>Nginx</code> 转发给某一个 <code>Spring Boot</code> 实例：</p><p><img src="http://img.itboyhub.com/2020/05/14-8.png" alt></p><p>如上，表示端口为 <code>8081</code> 的 <code>Spring Boot</code> 处理了这个 <code>/set</code> 请求，再访问 <code>/get</code> 请求：</p><p><img src="http://img.itboyhub.com/2020/05/14-9.png" alt></p><p>可以看到，<code>/get</code> 请求是被端口为 8080 的服务所处理的。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>本文主要向大家介绍了 Spring Session 的使用，另外也涉及到一些 Nginx 的使用 ，虽然本文较长，但是实际上 Spring Session 的配置没啥，涉及到的配置也都很简单。</p><p>如果大家没有在 SSM 架构中用过 Spring Session ，可能不太好理解我们在 Spring Boot 中使用 Spring Session 有多么方便，因为在 SSM 架构中，Spring Session 的使用要配置三个地方 ，一个是 web.xml 配置代理过滤器，然后在 Spring 容器中配置 Redis，最后再配置 Spring Session，步骤还是有些繁琐的，而 Spring Boot 中直接帮我们省去了这些繁琐的步骤！</p><p>好了 ，本文就说到这里，本文相关案例我已经上传到 GitHub ，大家可以自行下载:<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和大家聊了 Spring Security 如何像 QQ 一样，自动踢掉已登录用户（&lt;a href=&quot;https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？&lt;/a&gt;），但是前面我们是基于单体应用的，如果我们的项目是集群化部署，这个问题该如何解决呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>不知不觉松哥已经撸了 8 个原创电子书了，今天打包下载！</title>
    <link href="http://www.javaboy.org/2020/0515/book-video.html"/>
    <id>http://www.javaboy.org/2020/0515/book-video.html</id>
    <published>2020-05-15T14:50:14.000Z</published>
    <updated>2020-06-05T15:09:46.902Z</updated>
    
    <content type="html"><![CDATA[<p>写博客，就是不停的写，不停的做电子书，到目前为止，松哥出的电子书已经有至少 8 个了：</p><a id="more"></a><ul><li>Spring 电子书</li><li>SpringMVC 电子书</li><li>MyBatis 电子书</li><li>Maven 电子书</li><li>Redis 电子书</li><li>Docker 电子书</li><li>Spring Boot 电子书</li></ul><p>这些电子文档，大家在松哥公众号后台回复 <code>ssm</code> 都可以免费下载。</p><p>不过，从今天开始，电子书家族喜迎新成员 Spring Cloud OAuth2。</p><p>不知不觉 Spring Cloud OAuth2 系列写了 9 篇了，基本上涉及到了 OAuth2 使用的各个细节。从基本的入门到四种授权模式的具体案例，松哥都做了详细介绍，并且为每一篇文章都提供了配套案例。</p><p><img src="http://img.itboyhub.com/2020/05/20200511211933.png" alt></p><p>9 篇文章也是按照循序渐进的思路，逐步呈现给大家的，系列文章做成了一个 PDF 文档，足足有 68 页：</p><p><img src="http://img.itboyhub.com/2020/05/20200511212148.png" alt></p><p><strong>老实说，像这种成体系的，结合最新案例的 Spring Cloud OAuth2 教程，现在确实不多，值得一看。</strong></p><p>这个教程目前基本上告一段落了，还剩一个 Spring Cloud OAuth2 在微服务中的应用，这个松哥将来放在 Spring Cloud 主题中再来和大家介绍，请小伙伴们留意公众号的消息哦。</p><p><strong>小伙伴们在公众号后台回复 OAuth2 可以获取上面的 PDF 文档下载链接。松哥自己做的 PDF 文档都有加密，不过这个加密并不影响大家正常阅读。</strong></p><p>下一步要出的电子书，应该就是 Spring Security 了，小伙伴们敬请期待！</p><p>另外，五一期间松哥抽空为 OAuth2 系列教程录制了和文章对应的视频教程，</p><p><img src="http://img.itboyhub.com/2020/05/20200511213404.png" alt></p><p><strong>视频教程是付费的</strong>，因为这是我牺牲了休息时间和陪家人时间而录制的。OAuth2 教程将作为松哥 Spring Boot 系列视频第十章 Spring Boot 安全管理的一部分。</p><p>说到这里，我也顺便说下，松哥自制的四套视频教程 Spring Boot+微人事+Spring Cloud+Redis 目前已经杀青，四套视频已经全部更新完毕，四套视频总大小在 50G 左右，总时长在 90 小时左右（其中 Spring Boot 约 22 小时，Vue+微人事约 32 小时，Spring Cloud 约 22 小时，Redis 约 14 小时）。</p><p>由于视频的目录比较长，我就不在这里列出来了，小伙伴们可以在公众号后台回复 <code>视频目录</code> 就可以查看整套视频的完整目录。</p><p>为了这套视频松哥牺牲了太多休息时间和陪女票的时间，我一般都是下班后回到家就开始录视频，女票只能安安静静呆在一边，不发出一点声音，就这样积少成多，一步一步积攒成约 90 个小时的视频教程。</p><p>之前有小伙伴问松哥哪来那么多时间写文章录视频？还能从哪里来？熬夜呗。</p><p><img src="http://img.itboyhub.com//2020/03/video-1.jpg" alt></p><p>刚开始录制的时候，松哥经验也不是很丰富，我的 Windows 电脑用了 8 年了，录制出来的视频有 呲呲呲呲 的电流声，于是我又去学习了 Adobe Premiere Pro ，把录制的视频用 pr 统一处理了一遍，把噪音降低到最小：</p><p><img src="http://img.itboyhub.com//2020/03/video-2.jpg" alt></p><p>刚开始因为没经验，我对这个问题也束手无策，只能通过软件解决，后来经过小伙伴提醒，松哥花大价钱入手了一个专业的麦，从此彻底解决了视频音质问题。</p><p><img src="http://img.itboyhub.com//2020/03/video-3.jpg" alt></p><p>当然，对于视频教程而言，比这些更重要的是视频的质量，讲的思路是否清晰，小伙伴是否能听懂这才是关键。</p><p>其实录视频和写博客有着异曲同工之妙，只是一个知识点的不同展示形式而已。如果你觉得松哥平时的博客写的还不错，能看懂，那么视频基本上也能看懂。这不是我自卖自夸，有小伙伴的评价为证，随便列举一例：</p><p><img src="http://img.itboyhub.com//2020/03/video-10.png" alt></p><p>但是要提醒大家的是，学习松哥这套视频教程<strong>需要有 ssm 基础和 js 基础</strong>，如果你对 ssm 尚不熟悉，可以先看看松哥的自己手敲 5 万 余字的 ssm 入门教程，在<strong>公众号后台回复 ssm</strong> 可以获取下载链接。</p><p>按照惯例，接下来我要秀一波小伙伴们对视频的评价：</p><p><img src="http://img.itboyhub.com/2020/05/20200514-193629.jpg" alt><br><img src="http://img.itboyhub.com//2020/03/video-5.png" alt><br><img src="http://img.itboyhub.com//2020/03/video-6.jpg" alt><br><img src="http://img.itboyhub.com//2020/03/video-7.jpg" alt><br><img src="http://img.itboyhub.com//2020/03/video-8.jpg" alt></p><p>秀完之后，接下来再把视频常见问题和大家捋一捋：</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码一人一码。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：以后录的视频都可以看吗？</strong></p><p>这次松哥一共计划出四套视频课程，并且四套视频已经全部录完，大家在公众号后台回复 <code>视频目录</code> 可以查看已经录完的视频详细目录。也就是 199 一共可以看这四套视频。</p><p><strong>Q4：视频可以试看吗？</strong></p><p>其实我平时在公号发的视频，大家都可以当作试看的，反正的录视频风格是不变的。小伙伴们也可以在公众号后台回复 <code>vhr试看</code> 获取试看合集。</p><p><strong>Q5：可以砍价吗？</strong></p><p>不可以。</p><p><strong>Q6：知识星球是怎么回事？</strong></p><p>知识星球主要是用来更新视频下载地址的地方，大家在这套视频教程时遇到问题时，都可以在星球上提问。</p><p><strong>Q7：付费视频和免费视频有什么区别？</strong></p><p>免费视频是我在网上搜集别人录制的视频，大家在公众号后台回复 <code>2TB</code> 可以获取，付费视频是我自己录制的，录完之后都有二次剪辑，去噪，花费了很大功夫，因此是付费的。</p><p><strong>Q8：看视频有问题可以问吗？</strong></p><p>参考 Q6。</p><p><strong>Q9：这套视频适合哪些人看？</strong></p><p>学习这套视频，后端需要有 SSM 基础，前端需要有 js 基础（可以不懂 Vue，第十六章视频会讲）。要是不懂 SSM，可以先看松哥之前手敲 5 万余字的 SSM 教程，公众号后台回复 ssm 可以获取下载链接。</p><p><strong>Q10：可以单独买某一套视频吗？</strong></p><p>不可以。</p><p>有以下两个原因：</p><ol><li>Spring Boot 视频和 vhr 项目是有衔接的，比如 Spring Security 的知识点，我在 Spring Boot 第十章就讲了，到了做 vhr 项目的时候，我就直接讲应用了，不会再去纠结 Spring Security 使用细节的问题。</li><li>单独购买，我要给视频单独加密、单独上传，无形中加大了工作量。</li></ol><p>因此不支持单独购买。</p><p><strong>Q11：视频中的技术版本是什么</strong></p><ul><li>Spring Boot 录制基于 2.1.6-2.1.8 之间（因为录制的过程中 Spring Boot 版本在变，而我一直使用最新版本录制）。</li><li>微人事基于 SpringBoot2.1.8。</li><li>Spring Cloud 基于目前最新稳定版 H 版。</li><li>Redis 基于 Redis5。</li></ul><p><strong>视频是松哥业余做的，没有助理客服之类的，在微信上回复你消息的就是我本人，所以有的时候消息回复有些慢，请大家理解。</strong></p><p>好了，加松哥微信(<strong>a_java_boy</strong>)，发红包 199，和众多小伙伴一起撸 Spring Boot + Vue +Spring Cloud 以及微人事项目吧。</p><p><img src="http://img.itboyhub.com//2020/03/a_java_boy.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写博客，就是不停的写，不停的做电子书，到目前为止，松哥出的电子书已经有至少 8 个了：&lt;/p&gt;
    
    </summary>
    
      <category term="学习资源" scheme="http://www.javaboy.org/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="vhr" scheme="http://www.javaboy.org/tags/vhr/"/>
    
  </entry>
  
  <entry>
    <title>什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</title>
    <link href="http://www.javaboy.org/2020/0514/springsecurity-sfa.html"/>
    <id>http://www.javaboy.org/2020/0514/springsecurity-sfa.html</id>
    <published>2020-05-14T14:44:02.000Z</published>
    <updated>2020-06-05T15:09:27.188Z</updated>
    
    <content type="html"><![CDATA[<p>前两天和大家聊了 Spring Security 中的 session 并发问题，和小伙伴们聊了如何像 QQ 一样，用户在一台设备上登录成功之后，就会自动踢掉另一台设备上的登录。</p><a id="more"></a><p>当然，Spring Security 中，关于 session 的功能不仅仅是这些，之前和大家说<strong>我们学习 Spring Security，也是学习各种各样的网络攻击与防御策略</strong>，今天松哥就来和大家聊一个简单的：什么是会话固定攻击以及 Spring Security 中如何防止会话固定攻击。</p><p>本文是 Spring Security 系列的第 16 篇，阅读本系列前面的文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li></ol><h2 id="1-HttpSession"><a href="#1-HttpSession" class="headerlink" title="1.HttpSession"></a>1.HttpSession</h2><p>看前面文章的评论，我发现有的小伙伴对 HttpSession 还不太熟悉，所以在讲会话固定攻击之前，先来和大家说一说 HttpSession。</p><p>HttpSession 是一个服务端的概念，服务端生成的 HttpSession 都会有一个对应的 sessionid，这个 sessionid 会通过 cookie 传递给前端，前端以后发送请求的时候，就带上这个 sessionid 参数，服务端看到这个 sessionid 就会把这个前端请求和服务端的某一个 HttpSession 对应起来，形成“会话”的感觉。</p><p>浏览器关闭并不会导致服务端的 HttpSession 失效，想让服务端的 HttpSession 失效，要么手动调用 HttpSession#invalidate 方法；要么等到 session 自动过期；要么重启服务端。</p><p>但是为什么有的人会感觉浏览器关闭之后 session 就失效了呢？这是因为浏览器关闭之后，保存在浏览器里边的 sessionid 就丢了（默认情况下），所以当浏览器再次访问服务端的时候，服务端会给浏览器重新分配一个 sessionid ，这个 sessionid 和之前的 HttpSession 对应不上，所以用户就会感觉 session 失效。</p><p>注意前面我用了一个<strong>默认情况下</strong>，也就是说，我们可以通过手动配置，让浏览器重启之后 sessionid 不丢失，但是这样会带来安全隐患，所以一般不建议。</p><p>以 Spring Boot 为例，服务端生成 sessionid 之后，返回给前端的响应头是这样的：</p><p><img src="http://img.itboyhub.com/2020/05/20200513110652.png" alt></p><p>在服务端的响应头中有一个 Set-Cookie 字段，该字段指示浏览器更新 sessionid，同时大家注意还有一个 HttpOnly 属性，这个表示通过 JS 脚本无法读取到 Cookie 信息，这样能有效的防止 XSS 攻击。</p><p>下一次浏览器再去发送请求的时候，就会自觉的携带上这个 jsessionid 了：</p><p><img src="http://img.itboyhub.com/2020/05/20200513111352.png" alt></p><p>大家先对 HttpSession 有一个大致的了解，接下来我们再来看会话固定攻击。</p><h2 id="2-会话固定攻击"><a href="#2-会话固定攻击" class="headerlink" title="2.会话固定攻击"></a>2.会话固定攻击</h2><p>什么是会话固定攻击？英文叫做 session fixation attack。</p><p>正常来说，只要你不关闭浏览器，并且服务端的 HttpSession 也没有过期，那么维系服务端和浏览器的 sessionid 是不会发生变化的，而会话固定攻击，则是利用这一机制，借助受害者用相同的会话 ID 获取认证和授权，然后利用该会话 ID 劫持受害者的会话以成功冒充受害者，造成会话固定攻击。</p><p>一般来说，会话固定攻击的流程是这样，以淘宝为例：</p><ol><li>攻击者自己可以正常访问淘宝网站，在访问的过程中，淘宝网站给攻击者分配了一个 sessionid。</li><li>攻击者利用自己拿到的 sessionid 构造一个淘宝网站的链接，并把该链接发送给受害者。</li><li>受害者使用该链接登录淘宝网站（该链接中含有 sessionid），登录成功后，一个合法的会话就成功建立。</li><li>攻击者利用手里的 sessionid 冒充受害者。</li></ol><p>在这个过程中，如果淘宝网站支持 URL 重写，那么攻击还会变得更加容易。</p><p>什么是 URL 重写？就是用户如果在浏览器中禁用了 cookie，那么 sessionid 自然也用不了了，所以有的服务端就支持把 sessionid 放在请求地址中：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.taobao.com;jsessionid=xxxxxx</span><br></pre></td></tr></table></figure><p>如果服务端支持这种 URL 重写，那么对于攻击者来说，按照上面的攻击流程，构造一个这种地址简直太简单不过了。</p><p>不过这种请求地址大家在 Spring Security 中应该很少见到（原因请见下文），但是在 Shiro 中可能多多少少有见过。</p><h2 id="3-如何防御"><a href="#3-如何防御" class="headerlink" title="3.如何防御"></a>3.如何防御</h2><p>这个问题的根源在 sessionid 不变，如果用户在未登录时拿到的是一个 sessionid，登录之后服务端给用户重新换一个 sessionid，就可以防止会话固定攻击了。</p><p>如果你使用了 Spring Security ，其实是不用担心这个问题的，因为 Spring Security 中默认已经做了防御工作了。</p><p>Spring Security 中的防御主要体现在三个方面：</p><p><strong>首先</strong>就是<a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">上篇文章讲的 StrictHttpFirewall</a>，请求地址中有 <code>;</code> 请求会被直接拒绝。</p><p><strong>另一方面</strong>就是响应的 Set-Cookie 字段中有 HttpOnly 属性，这种方式避免了通过 XSS 攻击来获取 Cookie 中的会话信息进而达成会话固定攻击。</p><p><strong>第三点</strong>则是让 sessionid 变一下。既然问题是由于 sessionid 不变导致的，那我就让 sessionid 变一下。</p><p>具体配置如下：</p><p><img src="http://img.itboyhub.com/2020/05/20200513120930.png" alt></p><p>可以看到，在这里，我们有四个选项：</p><ol><li>migrateSession 表示在登录成功之后，创建一个新的会话，然后讲旧的 session 中的信息复制到新的 session 中，<strong>默认即此</strong>。</li><li>none 表示不做任何事情，继续使用旧的 session。</li><li>changeSessionId 表示 session 不变，但是会修改 sessionid，这实际上用到了 Servlet 容器提供的防御会话固定攻击。</li><li>newSession 表示登录后创建一个新的 session。</li></ol><p>默认的 migrateSession ，在用户匿名访问的时候是一个 sessionid，当用户成功登录之后，又是另外一个 sessionid，这样就可以有效避免会话固定攻击。</p><p>这三种方案，可以让我们有效避免会话固定攻击！</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>说了这么多，大家发现，如果你使用了 Spring Security，其实你什么都不用做，Spring Security 已经帮我们做好了会话固定攻击的防御工作，Spring Security 之强大，可见一斑。是不是非常 nice！</p><p>好啦，今天就和大家聊这样一个简单的话题，如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天和大家聊了 Spring Security 中的 session 并发问题，和小伙伴们聊了如何像 QQ 一样，用户在一台设备上登录成功之后，就会自动踢掉另一台设备上的登录。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>怎么样写好一篇技术文章？经验贴速来围观！</title>
    <link href="http://www.javaboy.org/2020/0513/article.html"/>
    <id>http://www.javaboy.org/2020/0513/article.html</id>
    <published>2020-05-13T14:43:48.000Z</published>
    <updated>2020-06-05T15:08:44.315Z</updated>
    
    <content type="html"><![CDATA[<p>不论是在星球上，还是在公众号上，松哥都曾多次鼓励小伙伴们写博客：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA" target="_blank" rel="noopener">如果你没写过博客，现在就是你写博客的最佳时机</a></li></ul><p>为什么鼓励大家呢？因为我自己就是写博客的受益者。</p><p>作为一个非科班程序员，博客让我能够快速获得同事的认可；博客也让我在毕业一年的时候薪水翻了三倍，博客也让我认识了各位小伙伴。</p><p>好处真是太多了，但一定要先动笔，才能慢慢感受到这些好处。</p><p>今天和大家聊一聊博客的一些写作经验，这些仅仅是松哥个人经验，小伙伴们可以作为一个参考。</p><h2 id="1-思路清晰"><a href="#1-思路清晰" class="headerlink" title="1.思路清晰"></a>1.思路清晰</h2><p>思路清晰是最最重要的一点，无论是看松哥博客还是看视频，<strong>思路清晰</strong> 我一直觉得是最高评价了。</p><p>技术博客不像写散文，语言优美不是必须，最关键的是要把问题讲清楚。对博客作者来说，这个东西你会了，这是一个技能，你能够明明白白的把它讲出来，并且让不会的人学会，这又是另外一个技能。</p><p>那么什么样的文章就算思路清晰呢？网上博客那么多，大家在平时学习的时候，应该也看过不少博客，有的文章一看就懂，觉得收获了很多，技能都 GET 到了，这就算是思路清晰的。</p><p>对于小伙伴们来说，要写一篇思路清晰的文章，其实也不难，就是把你整个写代码的过程记录下来，按照顺序从头到尾一步一步记录下来，尽量不要有任何跳跃。在这个过程中，最关键的其实就是要有耐心。</p><p>有的小伙伴刚开始写博客，感觉一步一步记录、截图啥的都太麻烦了，写一会就烦了，于是可能会跳过一些简单的步骤，对于有经验的读者来说，这些跳跃不影响他们阅读文章，对于没经验的读者来说，这些跳跃可能就会让他们卡在这里看不下去了。</p><p>所以你在写的时候，先想想你这篇文章的目标用户是谁？进而决定文章的详细程度。松哥之前写的 Spring Boot 系列教程每篇文章基本都是从 0 开始，而最近连载的 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319828555819286528&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Spring Security</a> 系列刚开始也是从 0 开始，后面基本上就有一些跳跃，但是这些跳跃实际上并不影响文章阅读，因为有前面的文章做铺垫。</p><h2 id="2-短小精悍"><a href="#2-短小精悍" class="headerlink" title="2.短小精悍"></a>2.短小精悍</h2><p>经常看松哥文章的小伙伴应该能够发现，我一般一篇文章只讲一个知识点，如果这个知识点涉及到的东西比较多，我可能会拆分成几篇文章来写，而不是写一篇超级长的所谓“干货”。</p><p>其实我以前也写过那种很长很长的“干货”，记得 2016 年在 CSDN 上发过一篇多线程的文章，很长，长到网页一打开浏览器就卡住的程度，我码了一个礼拜码出来的。这种文章一般转发率、收藏率都很高，但是阅读完成率却很低，阅读完成率低的原因也很好理解，读起来太累了。而且这种方式不容易写清楚一个知识点。</p><p>所以我尽量一篇文章讲一个知识点，配上完整的案例，不求多，只求大家看完一篇文章能 GET 一个技能，而且小伙伴们读起来也轻松。积累个几十篇文章后，做成一个系列，分享给小伙伴们，我觉得这种方式也挺香。</p><h2 id="3-案例设计"><a href="#3-案例设计" class="headerlink" title="3.案例设计"></a>3.案例设计</h2><p>每篇文章最好都有案例，而案例是需要设计的。</p><p>如果是涉及到知识点的文章，最好都有配套的案例，因为对于初学者而言，如果你文章写了很多字，但是却没有代码，他们可能还是看的一头雾水，把代码亮出来，一下就懂了，所以最好能够提供完整的案例。</p><p>这个案例代码不是随便撸一个，一般来说最好要提前设计案例，要去琢磨，什么样的案例，能够清楚的展示这个知识点。</p><p>我说一个案例设计的重要原则，就是尽量不要有无关的代码。</p><p>比如我要给大家演示 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319828555819286528&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Spring Security</a> 中的登录功能，那么案例中就是登录，不会有授权、不会有记住我、不会有 session 并发管理等等，为什么要这样呢？因为对于刚刚接触 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319828555819286528&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Spring Security</a> 的小伙伴而言，他可能照着你的案例写，你写了这么多配置，他照着写，写完了他也无法确定到底哪些配置是和登录相关的，哪些配置是和登录无关的，所以即使代码写完了还是比较懵。案例中的每一行代码都是必须的，也更容易让读者理解配置的含义。</p><p>所以最好每篇文章一个案例，每个案例不要有无关的代码。以松哥最近连载的 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319828555819286528&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Spring Security</a> 系列为例，讲登录就单纯讲登录，讲授权就单纯讲授权，讲自动登录就单纯讲自动登录，当你把这些文章都看完后，自然而然的就能够融会贯通，将所有的配置集成到一个项目中。</p><p><strong>有时候一些无关的代码可以让案例看起来更加完整，但是，在初次介绍一个技术点的时候，还是不建议有无关代码。</strong></p><h2 id="4-做成系列"><a href="#4-做成系列" class="headerlink" title="4.做成系列"></a>4.做成系列</h2><p>最后再来说说做成系列这个问题。</p><p>写博客，可能是工作中遇到问题的记录，也可能是单纯的介绍知识点，松哥的文章基本上都是以后者为主。</p><p>以前写 Android 的时候，还没形成写系列的习惯，但是也会围绕某一个主题来写；后来做 Java 之后，基本上都是系列了，Git 系列、Spring Cloud 系列、MongoDB 系列、Spring Boot 系列、前后端分离系列、OAuth2 系列、<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319828555819286528&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Spring Security</a> 系列、Docker 系列、MySQL 系列等等，我发现自己还是写了蛮多系列的。</p><p>为什么要写系列？</p><p>写博客不仅仅是教小伙伴们学习技术，也是博主自己梳理技术的一个过程，从这个角度来说，写系列文章有两个好处：</p><ol><li>将自己的知识整理成体系，这对于自己技术上的提升是非常大的，你会发现你在工作中遇到的各种奇奇怪怪的 BUG 或者奇奇怪怪的需求，可能在该技术体系中都有对应的解决方案，而你如果没有成体系的去学习过该技术，那么遇到问题后可能就是东一榔头西一棒，面向搜索引擎编程，搞了半天最终还是没搞定。</li><li>对读者来说，成体系的学习也比碎片化学习要好很多，所以写成系列也会有更多的小伙伴愿意看你的文章。</li></ol><p>但是系列文章可能也会遇到一些问题，比如读者看久了可能会有一些疲劳，系列文章到了后面阅读量就会变低，松哥最近在连载的 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319828555819286528&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Spring Security</a> 系列中，就有好几篇文章阅读量非常低，那是我情绪最低落的时候。但是这种时候我还是会坚持把这个系列写完，否则我就没有办法做成 PDF 文档分享给大家，如鲠在喉，非常难受。</p><p>每一个系列完结的时候，即是对自己的交代，也是对读者的交代。每一个系列完结的时候，就像以前考试结束的感觉，浑身上下非常轻松。</p><p>今天就和小伙伴们分享一点松哥写博客的经验，还是那句话：<a href="https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA" target="_blank" rel="noopener">如果你没写过博客，现在就是你写博客的最佳时机</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不论是在星球上，还是在公众号上，松哥都曾多次鼓励小伙伴们写博客：&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 自带防火墙！你都不知道自己的系统有多安全！</title>
    <link href="http://www.javaboy.org/2020/0512/springsecurity-stricthttpfirewall.html"/>
    <id>http://www.javaboy.org/2020/0512/springsecurity-stricthttpfirewall.html</id>
    <published>2020-05-12T14:43:27.000Z</published>
    <updated>2020-06-05T15:09:22.857Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>之前有小伙伴表示，看 Spring Security 这么麻烦，不如自己写一个 Filter 拦截请求，简单实用。</p><a id="more"></a><p>自己写当然也可以实现，但是大部分情况下，大家都不是专业的 Web 安全工程师，所以考虑问题也不过就是认证和授权，这两个问题处理好了，似乎系统就很安全了。</p><p>其实不是这样的！</p><p>各种各样的 Web 攻击每天都在发生，什么固定会话攻击、csrf 攻击等等，如果不了解这些攻击，那么做出来的系统肯定也不能防御这些攻击。</p><p>使用 Spring Security 的好处就是，即使不了解这些攻击，也不用担心这些攻击，因为 Spring Security 已经帮你做好防御工作了。</p><p>我们常说相比于 Shiro，Spring Security 更加重量级，重量级有重量级的好处，比如功能全，安全管理更加完备。用了 Spring Security，你都不知道自己的系统有多安全！</p><p>今天我就来和大家聊一聊 Spring Security 中自带的防火墙机制。</p><p>本文是 Spring Security 系列的第 15 篇，阅读本系列前面的文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li></ol><p>好了，不废话了，我们来看文章。</p><h2 id="1-HttpFirewall"><a href="#1-HttpFirewall" class="headerlink" title="1.HttpFirewall"></a>1.HttpFirewall</h2><p>在 Spring Security 中提供了一个 HttpFirewall，看名字就知道这是一个请求防火墙，它可以自动处理掉一些非法请求。</p><p>HttpFirewall 目前一共有两个实现类：</p><p><img src="http://img.itboyhub.com/2020/05/HttpFirewall.png" alt></p><p>一个是严格模式的防火墙设置，还有一个默认防火墙设置。</p><p>DefaultHttpFirewall 的限制相对于  StrictHttpFirewall 要宽松一些，当然也意味着安全性不如 StrictHttpFirewall。</p><p>Spring Security 中默认使用的是 StrictHttpFirewall。</p><h2 id="2-防护措施"><a href="#2-防护措施" class="headerlink" title="2.防护措施"></a>2.防护措施</h2><p>那么 StrictHttpFirewall 都是从哪些方面来保护我们的应用呢？我们来挨个看下。</p><h3 id="2-1-只允许白名单中的方法"><a href="#2-1-只允许白名单中的方法" class="headerlink" title="2.1 只允许白名单中的方法"></a>2.1 只允许白名单中的方法</h3><p>首先，对于请求的方法，只允许白名单中的方法，也就是说，不是所有的 HTTP 请求方法都可以执行。</p><p>这点我们可以从 StrictHttpFirewall 的源码中看出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrictHttpFirewall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpFirewall</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> Set&lt;String&gt; allowedHttpMethods = createDefaultAllowedHttpMethods();</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Set&lt;String&gt; <span class="hljs-title">createDefaultAllowedHttpMethods</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; result = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">result.add(HttpMethod.DELETE.name());</span><br><span class="line">result.add(HttpMethod.GET.name());</span><br><span class="line">result.add(HttpMethod.HEAD.name());</span><br><span class="line">result.add(HttpMethod.OPTIONS.name());</span><br><span class="line">result.add(HttpMethod.PATCH.name());</span><br><span class="line">result.add(HttpMethod.POST.name());</span><br><span class="line">result.add(HttpMethod.PUT.name());</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectForbiddenHttpMethod</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.allowedHttpMethods == ALLOW_ANY_HTTP_METHOD) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowedHttpMethods.contains(request.getMethod())) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RequestRejectedException(<span class="hljs-string">"The request was rejected because the HTTP method \""</span> +</span><br><span class="line">request.getMethod() +</span><br><span class="line"><span class="hljs-string">"\" was not included within the whitelist "</span> +</span><br><span class="line"><span class="hljs-keyword">this</span>.allowedHttpMethods);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中我们看出来，你的 HTTP 请求方法必须是 DELETE、GET、HEAD、OPTIONS、PATCH、POST 以及 PUT 中的一个，请求才能发送成功，否则的话，就会抛出 RequestRejectedException 异常。</p><p>那如果你想发送其他 HTTP 请求方法，例如 TRACE ，该怎么办呢？我们只需要自己重新提供一个 StrictHttpFirewall 实例即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">HttpFirewall <span class="hljs-title">httpFirewall</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    StrictHttpFirewall firewall = <span class="hljs-keyword">new</span> StrictHttpFirewall();</span><br><span class="line">    firewall.setUnsafeAllowAnyHttpMethod(<span class="hljs-keyword">true</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，setUnsafeAllowAnyHttpMethod 方法表示不做 HTTP 请求方法校验，也就是什么方法都可以过。或者也可以通过 setAllowedHttpMethods 方法来重新定义可以通过的方法。</p><h3 id="2-2-请求地址不能有分号"><a href="#2-2-请求地址不能有分号" class="headerlink" title="2.2 请求地址不能有分号"></a>2.2 请求地址不能有分号</h3><p>不知掉大家有没有试过，如果你使用了 Spring Security，请求地址是不能有 <code>;</code> 的，如果请求地址有 <code>;</code> ，就会自动跳转到如下页面：</p><p><img src="http://img.itboyhub.com/2020/05/20200511152104.png" alt></p><p>可以看到，页面的提示中已经说了，因为你的请求地址中包含 <code>;</code>，所以请求失败。</p><p>什么时候请求地址中会包含 <code>;</code> 呢？不知道小伙伴们在使用 Shiro 的时候，有没有注意到，如果你禁用了 Cookie，那么 jsessionid 就会出现在地址栏里，像下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/hello;jsessionid=xx</span><br></pre></td></tr></table></figure><p>这种传递 jsessionid 的方式实际上是非常不安全的（松哥后面的文章会和大家细聊这个问题），所以在 Spring Security 中，这种传参方式默认就禁用了。</p><p>当然，如果你希望地址栏能够被允许出现 <code>;</code> ，那么可以按照如下方式设置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">HttpFirewall <span class="hljs-title">httpFirewall</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    StrictHttpFirewall firewall = <span class="hljs-keyword">new</span> StrictHttpFirewall();</span><br><span class="line">    firewall.setAllowSemicolon(<span class="hljs-keyword">true</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置完成之后，再去访问相同的接口，可以看到，此时虽然还是报错，但是错误是 404 了，而不是一开始那个不允许 <code>;</code> 的错了。</p><p><img src="http://img.itboyhub.com/2020/05/20200511153022.png" alt></p><p><strong>注意，在 URL 地址中，<code>;</code> 编码之后是 <code>%3b</code> 或者 <code>%3B</code>，所以地址中同样不能出现 <code>%3b</code> 或者 <code>%3B</code></strong></p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>有的小伙伴可能不知道或者没用过，Spring3.2 开始，带来了一种全新的传参方式 @MatrixVariable。</p><p>@MatrixVariable 是 Spring3.2 中带来的功能，这种方式拓展了请求参数的传递格式，使得参数之间可以用 <code>;</code> 隔开，这种传参方式真是哪壶不开提哪壶。因为 Spring Security 默认就是禁止这种传参方式，所以一般情况下，如果你需要使用 @MatrixVariable 来标记参数，就得在 Spring Security 中额外放行。</p><p>接下来我通过一个简单的例子来和大家演示一下 @MatrixVariable 的用法。</p><p>我们新建一个 <code>/hello</code> 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/hello/&#123;id&#125;"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(@PathVariable Integer id,@MatrixVariable String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"id = "</span> + id);</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外我们还需要配置一下 SpringMVC，使 <code>;</code> 不要被自动移除了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePathMatch</span><span class="hljs-params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        UrlPathHelper urlPathHelper = <span class="hljs-keyword">new</span> UrlPathHelper();</span><br><span class="line">        urlPathHelper.setRemoveSemicolonContent(<span class="hljs-keyword">false</span>);</span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动项目(注意，Spring Security 中也已经配置了允许 URL 中存在 <code>;</code>)，浏览器发送如下请求：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/hello/123;name=javaboy</span><br></pre></td></tr></table></figure><p>控制台打印信息如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id = 123</span><br><span class="line">name = javaboy</span><br></pre></td></tr></table></figure><p>可以看到，@MatrixVariable 注解已经生效了。</p><h3 id="2-3-必须是标准化-URL"><a href="#2-3-必须是标准化-URL" class="headerlink" title="2.3 必须是标准化 URL"></a>2.3 必须是标准化 URL</h3><p>请求地址必须是标准化 URL。</p><p>什么是标准化 URL？标准化 URL 主要从四个方面来判断，我们来看下源码：</p><p>StrictHttpFirewall#isNormalized：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNormalized</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isNormalized(request.getRequestURI())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isNormalized(request.getContextPath())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isNormalized(request.getServletPath())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isNormalized(request.getPathInfo())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getRequestURI 就是获取请求协议之外的字符；getContextPath 是获取上下文路径，相当于是 project 的名字；getServletPath 这个就是请求的 servlet 路径，getPathInfo 则是除过 contextPath 和 servletPath 之后剩余的部分。</p><p>这四种路径中，都不能包含如下字符串：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;./&quot;, &quot;/../&quot; or &quot;/.&quot;</span><br></pre></td></tr></table></figure><h3 id="2-4-必须是可打印的-ASCII-字符"><a href="#2-4-必须是可打印的-ASCII-字符" class="headerlink" title="2.4 必须是可打印的 ASCII 字符"></a>2.4 必须是可打印的 ASCII 字符</h3><p>如果请求地址中包含不可打印的 ASCII 字符，请求则会被拒绝，我们可以从源码中看出端倪：</p><p>StrictHttpFirewall#containsOnlyPrintableAsciiCharacters</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsOnlyPrintableAsciiCharacters</span><span class="hljs-params">(String uri)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> length = uri.length();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line"><span class="hljs-keyword">char</span> c = uri.charAt(i);</span><br><span class="line"><span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">'\u0020'</span> || c &gt; <span class="hljs-string">'\u007e'</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-双斜杠不被允许"><a href="#2-5-双斜杠不被允许" class="headerlink" title="2.5 双斜杠不被允许"></a>2.5 双斜杠不被允许</h3><p>如果请求地址中出现双斜杠，这个请求也将被拒绝。双斜杠 <code>//</code> 使用 URL 地址编码之后，是 %2F%2F，其中 F 大小写无所谓，所以请求地址中也能不出现 “%2f%2f”, “%2f%2F”, “%2F%2f”, “%2F%2F”。</p><p>如果你希望请求地址中可以出现 <code>//</code> ，可以按照如下方式配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">HttpFirewall <span class="hljs-title">httpFirewall</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    StrictHttpFirewall firewall = <span class="hljs-keyword">new</span> StrictHttpFirewall();</span><br><span class="line">    firewall.setAllowUrlEncodedDoubleSlash(<span class="hljs-keyword">true</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-不被允许"><a href="#2-6-不被允许" class="headerlink" title="2.6 % 不被允许"></a>2.6 % 不被允许</h3><p>如果请求地址中出现 %，这个请求也将被拒绝。URL 编码后的 % 是 %25，所以 %25 也不能出现在 URL 地址中。</p><p>如果希望请求地址中可以出现 %，可以按照如下方式修改：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">HttpFirewall <span class="hljs-title">httpFirewall</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    StrictHttpFirewall firewall = <span class="hljs-keyword">new</span> StrictHttpFirewall();</span><br><span class="line">    firewall.setAllowUrlEncodedPercent(<span class="hljs-keyword">true</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-正反斜杠不被允许"><a href="#2-7-正反斜杠不被允许" class="headerlink" title="2.7 正反斜杠不被允许"></a>2.7 正反斜杠不被允许</h3><p>如果请求地址中包含斜杠编码后的字符 %2F 或者 %2f ，则请求将被拒绝。</p><p>如果请求地址中包含反斜杠 \ 或者反斜杠编码后的字符 %5C 或者 %5c ，则请求将被拒绝。</p><p>如果希望去掉如上两条限制，可以按照如下方式来配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">HttpFirewall <span class="hljs-title">httpFirewall</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    StrictHttpFirewall firewall = <span class="hljs-keyword">new</span> StrictHttpFirewall();</span><br><span class="line">    firewall.setAllowBackSlash(<span class="hljs-keyword">true</span>);</span><br><span class="line">    firewall.setAllowUrlEncodedSlash(<span class="hljs-keyword">true</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-不被允许"><a href="#2-8-不被允许" class="headerlink" title="2.8 . 不被允许"></a>2.8 <code>.</code> 不被允许</h3><p>如果请求地址中存在 <code>.</code> 编码之后的字符 <code>%2e</code>、<code>%2E</code>，则请求将被拒绝。</p><p>如需支持，按照如下方式进行配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">HttpFirewall <span class="hljs-title">httpFirewall</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    StrictHttpFirewall firewall = <span class="hljs-keyword">new</span> StrictHttpFirewall();</span><br><span class="line">    firewall.setAllowUrlEncodedPeriod(<span class="hljs-keyword">true</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> firewall;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-小结"><a href="#2-9-小结" class="headerlink" title="2.9 小结"></a>2.9 小结</h3><p>需要强调一点，上面所说的这些限制，都是针对请求的 requestURI 进行的限制，而不是针对请求参数。例如你的请求格式是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/hello?param=aa%2ebb</span><br></pre></td></tr></table></figure><p>那么 2.7 小节说的限制和你没关系。</p><p>这个大家从 StrictHttpFirewall 源码中很容易看到：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrictHttpFirewall</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpFirewall</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> FirewalledRequest <span class="hljs-title">getFirewalledRequest</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> RequestRejectedException </span>&#123;</span><br><span class="line">rejectForbiddenHttpMethod(request);</span><br><span class="line">rejectedBlacklistedUrls(request);</span><br><span class="line">rejectedUntrustedHosts(request);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (!isNormalized(request)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RequestRejectedException(<span class="hljs-string">"The request was rejected because the URL was not normalized."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String requestUri = request.getRequestURI();</span><br><span class="line"><span class="hljs-keyword">if</span> (!containsOnlyPrintableAsciiCharacters(requestUri)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RequestRejectedException(<span class="hljs-string">"The requestURI was rejected because it can only contain printable ASCII characters."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FirewalledRequest(request) &#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedBlacklistedUrls</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String forbidden : <span class="hljs-keyword">this</span>.encodedUrlBlacklist) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (encodedUrlContains(request, forbidden)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RequestRejectedException(<span class="hljs-string">"The request was rejected because the URL contained a potentially malicious String \""</span> + forbidden + <span class="hljs-string">"\""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (String forbidden : <span class="hljs-keyword">this</span>.decodedUrlBlacklist) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (decodedUrlContains(request, forbidden)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RequestRejectedException(<span class="hljs-string">"The request was rejected because the URL contained a potentially malicious String \""</span> + forbidden + <span class="hljs-string">"\""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">encodedUrlContains</span><span class="hljs-params">(HttpServletRequest request, String value)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (valueContains(request.getContextPath(), value)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> valueContains(request.getRequestURI(), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">decodedUrlContains</span><span class="hljs-params">(HttpServletRequest request, String value)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (valueContains(request.getServletPath(), value)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (valueContains(request.getPathInfo(), value)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">valueContains</span><span class="hljs-params">(String value, String contains)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span> &amp;&amp; value.contains(contains);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rejectedBlacklistedUrls 方法就是校验 URL 的，该方法逻辑很简单，我就不再赘述了。</p><p><strong>注意：虽然我们可以手动修改 Spring Security 中的这些限制，但是松哥不建议大家做任何修改，每一条限制都有它的原由，每放开一个限制，就会带来未知的安全风险。后面松哥在和大家分享 Web 中的安全攻击时，也会再次提到这些限制的作用，请小伙伴们保持关注哦。</strong></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>没想到吧？Spring Security 竟然为你做了这么多事情！正好应了那句鸡汤：</p><blockquote><p>你所谓的岁月静好,不过是有人在替你负重前行。</p></blockquote><p>好了，不知道大家有没有 GET 到呢？如果有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;之前有小伙伴表示，看 Spring Security 这么麻烦，不如自己写一个 Filter 拦截请求，简单实用。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+Vue 文件上传，如何携带令牌信息？</title>
    <link href="http://www.javaboy.org/2020/0511/springsecurity-vue-token.html"/>
    <id>http://www.javaboy.org/2020/0511/springsecurity-vue-token.html</id>
    <published>2020-05-11T14:42:23.000Z</published>
    <updated>2020-06-05T15:09:17.808Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>关于文件上传这块，松哥之前也写了好几篇文章了，甚至还有视频：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/tIFyi2EiQRhdaOZi7bMoGw" target="_blank" rel="noopener">Spring Boot+Vue+FastDFS 实现前后端分离文件上传</a></li></ul><p>但是，之前和小伙伴们提到的方案，是基于 session 来做认证的，所以并不需要考虑携带令牌的问题，但是在前后端分离开发中，我们可能采用 JWT 或者是 OAuth2+JWT 的方式来做认证，如果是这样的话，那我们就要手动传递令牌了。</p><p>今天就来和大家说说手动传递令牌的事。</p><h2 id="1-传统方案"><a href="#1-传统方案" class="headerlink" title="1.传统方案"></a>1.传统方案</h2><p>我们先来看看，基于 session 认证，文件上传要怎么做。</p><p>在 Vue.js 中，如果网络请求使用 axios ，并且使用了 ElementUI 库，那么一般来说，文件上传有两种不同的实现方案：</p><ol><li>通过 Ajax 实现文件上传</li><li>通过 ElementUI 里边的 Upload 组件实现文件上传</li></ol><p>两种方案，各有优缺点，我们分别来看。</p><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><p>首先我们需要一点点准备工作，就是在后端提供一个文件上传接口，这是一个普通的 Spring Boot 项目，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"/yyyy/MM/dd/"</span>);</span><br><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/import"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">importData</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/upload"</span>) + format;</span><br><span class="line">    File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String oldName = file.getOriginalFilename();</span><br><span class="line">    String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">    file.transferTo(<span class="hljs-keyword">new</span> File(folder,newName));</span><br><span class="line">    String url = req.getScheme() + <span class="hljs-string">"://"</span> + req.getServerName() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/upload"</span> + format + newName;</span><br><span class="line">    System.out.println(url);</span><br><span class="line">    <span class="hljs-keyword">return</span> RespBean.ok(<span class="hljs-string">"上传成功!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的文件上传比较简单，上传的文件按照日期进行归类，使用 UUID 给文件重命名。</p><p><strong>这里为了简化代码，我省略掉了异常捕获，上传结果直接返回成功，后端代码大伙可根据自己的实际情况自行修改。</strong></p><blockquote><p>这是为了方便，我直接将文件存储到本地，小伙伴们也可以结合 FastDFS 将文件上传做的更加专业一些，可以参考松哥这篇文章：<a href="https://mp.weixin.qq.com/s/tIFyi2EiQRhdaOZi7bMoGw" target="_blank" rel="noopener">Spring Boot+Vue+FastDFS 实现前后端分离文件上传</a>。</p></blockquote><h3 id="1-2-Ajax-上传"><a href="#1-2-Ajax-上传" class="headerlink" title="1.2 Ajax 上传"></a>1.2 Ajax 上传</h3><p>在 Vue 中，通过 Ajax 实现文件上传，方案和传统 Ajax 实现文件上传基本上是一致的，唯一不同的是查找元素的方式。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"myfile"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"importData"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"success"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"mini"</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">"el-icon-upload2"</span>&gt;</span>导入数据<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，首先提供一个文件导入 input 组件，再来一个导入按钮，在导入按钮的事件中来完成导入的逻辑。</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">importData() &#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> myfile = <span class="hljs-keyword">this</span>.$refs.myfile;</span><br><span class="line">  <span class="hljs-keyword">let</span> files = myfile.files;</span><br><span class="line">  <span class="hljs-keyword">let</span> file = files[<span class="hljs-number">0</span>];</span><br><span class="line">  <span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> FormData();</span><br><span class="line">  formData.append(<span class="hljs-string">"file"</span>, file);</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadFileRequest(<span class="hljs-string">"/system/basic/jl/import"</span>,formData).then(<span class="hljs-function"><span class="hljs-params">resp</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (resp) &#123;</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(resp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这段上传核心逻辑，解释如下：</p><ol><li>首先利用 Vue 中的 $refs 查找到存放文件的元素。</li><li>type 为 file 的 input 元素内部有一个 files 数组，里边存放了所有选择的 file，由于文件上传时，文件可以多选，因此这里拿到的 files 对象是一个数组。</li><li>从 files 对象中，获取自己要上传的文件，由于这里是单选，所以其实就是数组中的第一项。</li><li>构造一个 FormData ，用来存放上传的数据,FormData 不可以像 Java 中的 StringBuffer 使用链式配置。</li><li>构造好 FromData 后，就可以直接上传数据了，FormData 就是要上传的数据。</li><li>文件上传注意两点，1. 请求方法为 post，2. 设置 <code>Content-Type</code> 为  <code>multipart/form-data</code> 。</li></ol><p>这种文件上传方式，实际上就是传统的 Ajax 上传文件，和大家常见的 jQuery 中写法不同的是，这里元素查找的方式不一样（实际上元素查找也可以按照JavaScript 中原本的写法来实现），其他写法一模一样。这种方式是一个通用的方式，和使用哪一种前端框架无关。最后再和大家来看下封装的上传方法：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> uploadFileRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> axios(&#123;</span><br><span class="line">    method: <span class="hljs-string">'post'</span>,</span><br><span class="line">    url: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">    data: params,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'multipart/form-data'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这几步的配置后，前端就算上传完成了，可以进行文件上传了。</p><h3 id="1-3-使用-el-upload-组件"><a href="#1-3-使用-el-upload-组件" class="headerlink" title="1.3 使用 el-upload 组件"></a>1.3 使用 el-upload 组件</h3><p>如果使用 el-upload ，则需要引入 ElementUI，所以一般建议，如果使用了 ElementUI 做 UI 控件的话，则可以考虑使用 el-upload 组件来实现文件上传，如果没有使用 ElementUI 的话，则不建议使用 el-upload 组件，至于其他的 UI 控件，各自都有自己的文件上传组件，具体使用可以参考各自文档。</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">el-upload</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">style</span>=<span class="hljs-string">"display: inline"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:show-file-list</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:on-success</span>=<span class="hljs-string">"onSuccess"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:on-error</span>=<span class="hljs-string">"onError"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:before-upload</span>=<span class="hljs-string">"beforeUpload"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">action</span>=<span class="hljs-string">"/system/basic/jl/import"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"mini"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"success"</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">"!enabledUploadBtn"</span> <span class="hljs-attr">:icon</span>=<span class="hljs-string">"uploadBtnIcon"</span>&gt;</span>&#123;&#123;btnText&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>show-file-list 表示是否展示上传文件列表，默认为true，这里设置为不展示。</li><li>before-upload 表示上传之前的回调，可以在该方法中，做一些准备工作，例如展示一个进度条给用户 。</li><li>on-success 和 on-error 分别表示上传成功和失败时候的回调，可以在这两个方法中，给用户一个相应的提示，如果有进度条，还需要在这两个方法中关闭进度条。</li><li>action 指文件上传地址。</li><li>上传按钮的点击状态和图标都设置为变量 ，在文件上传过程中，修改上传按钮的点击状态为不可点击，同时修改图标为一个正在加载的图标 loading。</li><li>上传的文本也设为变量，默认上传 button 的文本是 <code>数据导入</code> ，当开始上传后，将找个 button 上的文本修改为 <code>正在导入</code>。</li></ol><p>相应的回调如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onSuccess(response, file, fileList) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.enabledUploadBtn = <span class="hljs-literal">true</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadBtnIcon = <span class="hljs-string">'el-icon-upload2'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.btnText = <span class="hljs-string">'数据导入'</span>;</span><br><span class="line">&#125;,</span><br><span class="line">onError(err, file, fileList) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.enabledUploadBtn = <span class="hljs-literal">true</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadBtnIcon = <span class="hljs-string">'el-icon-upload2'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.btnText = <span class="hljs-string">'数据导入'</span>;</span><br><span class="line">&#125;,</span><br><span class="line">beforeUpload(file) &#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>.enabledUploadBtn = <span class="hljs-literal">false</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.uploadBtnIcon = <span class="hljs-string">'el-icon-loading'</span>;</span><br><span class="line">  <span class="hljs-keyword">this</span>.btnText = <span class="hljs-string">'正在导入'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在文件开始上传时，修改上传按钮为不可点击，同时修改上传按钮的图标和文本。</li><li>文件上传成功或者失败时，修改上传按钮的状态为可以点击，同时恢复上传按钮的图标和文本。</li></ol><p>上传效果图如下：</p><p><img src="http://img.itboyhub.com/2020/04/springboot-vue-upload-2-1.png" alt></p><p>使用 el-upload 做文件上传，松哥之前也录过一个视频，小伙伴们可以参考(本视频节选自松哥自制的 <a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot+Vue+微人事系列视频教程</a>)：</p><!--视频位置--><h3 id="1-4-两种方式比较"><a href="#1-4-两种方式比较" class="headerlink" title="1.4 两种方式比较"></a>1.4 两种方式比较</h3><p>两种上传方式各有优缺点：</p><ol><li>第一种方式最大的优势是通用，一招鲜吃遍天，到哪里都能用，但是对于上传过程的监控，进度条的展示等等逻辑都需要自己来实现。</li><li>第二种方式不够通用，因为它是 ElementUI 中的组件，得引入 ElementUI 才能使用，不过这种方式很明显有需多比较方便的回调，可以实现非常方便的处理常见的各种上传问题。</li><li>常规的上传需求第二种方式可以满足，但是如果要对上传的方法进行定制，则还是建议使用第一种上传方案。</li></ol><h2 id="2-手动传递令牌"><a href="#2-手动传递令牌" class="headerlink" title="2.手动传递令牌"></a>2.手动传递令牌</h2><p>对于上面不同的文件上传方式，手动上传令牌也有不同的方案，松哥来和大家挨个介绍。我这里服务端认证是 OAuth2+JWT 的方式，所以接下来令牌传递主要是按照 OAuth2 的格式来传递令牌，其实都是修改请求头，只要这种方式会了，其他方式也就会了。</p><p><strong>关于 OAuth2，如果小伙伴们还不熟悉，可以看看松哥之前写的系列教程：<a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319833457266163712&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">OAuth2系列</a></strong></p><h3 id="2-1-Ajax-传递令牌"><a href="#2-1-Ajax-传递令牌" class="headerlink" title="2.1 Ajax 传递令牌"></a>2.1 Ajax 传递令牌</h3><p>Ajax 传递令牌实际上是非常容易的，我们只需要稍微修改请求头即可。我给大家举一个简单例子。</p><p>如果你用的 axios 来做网络请求，那么按照如下方式添加请求头即可（或者在请求拦截器中统一添加）：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> uploadFileRequest = <span class="hljs-function">(<span class="hljs-params">url, params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> axios(&#123;</span><br><span class="line">    method: <span class="hljs-string">'post'</span>,</span><br><span class="line">    url: <span class="hljs-string">`<span class="hljs-subst">$&#123;base&#125;</span><span class="hljs-subst">$&#123;url&#125;</span>`</span>,</span><br><span class="line">    data: params,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'multipart/form-data'</span>,</span><br><span class="line">      <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">'Bearer '</span> + token</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你用了 jQuery 的话，那么按照如下方式添加请求头即可：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="hljs-string">"#btnClick"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">var</span> formData = <span class="hljs-keyword">new</span> FormData();</span><br><span class="line">        formData.append(<span class="hljs-string">"file"</span>, $(<span class="hljs-string">"#userface"</span>)[<span class="hljs-number">0</span>].files[<span class="hljs-number">0</span>]);</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="hljs-string">'/fileupload'</span>,</span><br><span class="line">            type: <span class="hljs-string">'post'</span>,</span><br><span class="line">            headers: &#123;</span><br><span class="line">                <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">'Bearer '</span> + token</span><br><span class="line">            &#125;,</span><br><span class="line">            data: formData,</span><br><span class="line">            processData: <span class="hljs-literal">false</span>,</span><br><span class="line">            contentType: <span class="hljs-literal">false</span>,</span><br><span class="line">            success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;</span><br><span class="line">                alert(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>无非就是修改请求头，只要是自己发送请求的，请求头都是可以自由定制的，无论你用 jQuery 还是 axios 还是原生的 XMLHttpRequest。</p></blockquote><h3 id="2-2-el-upload-处理令牌"><a href="#2-2-el-upload-处理令牌" class="headerlink" title="2.2 el-upload 处理令牌"></a>2.2 el-upload 处理令牌</h3><p>如果使用了 el-upload，我们就得在人家框架里边玩了，得符合框架要求，这虽然多了一些掣肘，但是也不是不能实现，松哥这里和大家介绍两种方案。</p><h4 id="2-2-1-方案一"><a href="#2-2-1-方案一" class="headerlink" title="2.2.1 方案一"></a>2.2.1 方案一</h4><p>方案一是我目前采用的方案，因为 el-upload 支持定制请求头，这就好办了：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">el-upload</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">ref</span>=<span class="hljs-string">"upload"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">"upload-container"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:data</span>=<span class="hljs-string">"category"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:multiple</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:limit</span>=<span class="hljs-string">"1"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:headers</span>=<span class="hljs-string">"myHeaders"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:auto-upload</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:on-success</span>=<span class="hljs-string">"onSuccess"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:on-error</span>=<span class="hljs-string">"onError"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">:file-list</span>=<span class="hljs-string">"fileList"</span></span></span><br><span class="line"><span class="hljs-tag">  <span class="hljs-attr">action</span>=<span class="hljs-string">"/appmanager/app/categories/"</span></span></span><br><span class="line"><span class="hljs-tag">&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"mini"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span>&gt;</span>选择图标<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，:headers=”myHeaders” 就是我定制的请求头，然后在 data 中定义该变量即可：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="line">    myHeaders: &#123; <span class="hljs-attr">Authorization</span>: <span class="hljs-string">'Bearer '</span> + getToken() &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="2-2-2-方案二"><a href="#2-2-2-方案二" class="headerlink" title="2.2.2 方案二"></a>2.2.2 方案二</h4><p>方案二则是利用 el-upload 的 before-upload 钩子函数，开发者可以在这个钩子函数中自己手动上传，上传完成之后，返回一个 false，这时 el-upload 就会停止它自己的上传逻辑。这种方式我看到有别的小伙伴在用，所以给大家一个简单的案例参考下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-upload action=<span class="hljs-string">"http://www.javaboy.org"</span> :before-upload=<span class="hljs-string">"beforeUpload"</span>&gt;<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">el-upload</span>&gt;</span></span></span><br><span class="line"><span class="hljs-xml">beforeUpload (file) &#123;</span></span><br><span class="line"><span class="hljs-xml">    //参考上面的 ajax 或者 axios 上传文件</span></span><br><span class="line"><span class="hljs-xml">    return false</span></span><br><span class="line"><span class="hljs-xml">&#125;</span></span><br></pre></td></tr></table></figure><p>这里有几个细节大家需要注意下：</p><ol><li>el-upload 的 action 属性随意给一个值，使之不报错，因为真正的上传地址我们将在 beforeUpload 方法中给出。</li><li>beforeUpload 方法的上传逻辑跟我们第一小节介绍的一致，我就不重复写了，注意上传的文件对象是 <code>file.raw</code>。</li><li>beforeUpload 方法最终返回 false，终止 el-upload 自己的上传逻辑。</li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好了，和小伙伴们介绍了几种文件上传时候的令牌传递方式，不知道大家有没有 GET 到呢？有问题欢迎留言讨论，如果学到了，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;关于文件上传这块，松哥之前也写了好几篇文章了，甚至还有视频：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>推荐三个 Vue 后台管理模版，配合 Spring Boot 使用真香！</title>
    <link href="http://www.javaboy.org/2020/0509/vue-template.html"/>
    <id>http://www.javaboy.org/2020/0509/vue-template.html</id>
    <published>2020-05-09T12:36:11.000Z</published>
    <updated>2020-05-10T12:59:39.853Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为因为项目的原因，一直在寻找一款合适的前端模版，之前的 Vue 前端页面都是自己写的，写多了就烦了，因为功能都差不多，写来写去就没意思了。</p><p>所以在新项目中想看看市面上的 Vue 后台管理模版，找个现成的，改一改基本就 OK 了，团队也省事一些。</p><a id="more"></a><p>老实说，Vue 的生态还是相当丰富的，经典的、新生的后台管理框架都有，我这里和大家分享我们这次重点比较的三个。</p><h2 id="vue-element-admin"><a href="#vue-element-admin" class="headerlink" title="vue-element-admin"></a>vue-element-admin</h2><ul><li>GitHub 地址：<a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">https://github.com/PanJiaChen/vue-element-admin</a></li><li>演示地址：<a href="https://panjiachen.github.io/vue-element-admin" target="_blank" rel="noopener">https://panjiachen.github.io/vue-element-admin</a></li></ul><p>这个项目名气还是挺大的，在我刚开始做 vhr 的时候，就有了解过这个项目，那个时候这个项目才刚刚开发没多久，star 都没几个，现在已然混成一方霸主了。</p><p>vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui 实现。它使用了最新的前端技术栈，内置了 i18n 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。</p><p>可以说，这个项目的功能还是比较全的，它里边将一些常见的功能模块如权限管理等都做好了，有的时候，你甚至会觉得这个项目有些臃肿。</p><p>我们来看一张效果图：</p><p><img src="http://img.itboyhub.com/2020/04/20200508161409.png" alt></p><p>这个开源项目也是我们这里最终选定的方案，选定它有几方面的原因：</p><ol><li>这个项目的开发时间较早，目前相对来说可能 BUG 较少，比较稳定。</li><li>该项目目前依然非常活跃，作者还在不断的完善。</li><li>功能齐全，和其他项目相比，功能上基本没有劣势。</li><li>相对于其他 UI 框架，ElementUI 使用更多一些，这对于一个商用项目还是非常重要的。</li></ol><p>当然，使用开源项目肯定不可能完全契合自己的需求的，这种就要在开发中，再去慢慢克服了。</p><h2 id="ant-design-vue-pro"><a href="#ant-design-vue-pro" class="headerlink" title="ant-design-vue-pro"></a>ant-design-vue-pro</h2><ul><li>GitHub 地址：<a href="https://github.com/vueComponent/ant-design-vue-pro" target="_blank" rel="noopener">https://github.com/vueComponent/ant-design-vue-pro</a></li><li>演示地址：<a href="https://preview.pro.loacg.com" target="_blank" rel="noopener">https://preview.pro.loacg.com</a></li></ul><p>这个也是我们当时重点比较的项目之一。</p><p>Ant Design Pro 是一个企业级中后台前端/设计解决方案，秉承 Ant Design 的设计价值观，致力于在设计规范和基础组件的基础上，继续向上构建，提炼出典型模板/业务组件/配套设计资源，进一步提升企业级中后台产品设计研发过程中的『用户』和『设计者』的体验。随着『设计者』的不断反馈，持续迭代，逐步沉淀和总结出更多设计模式和相应的代码实现。</p><p>我们来看个效果图：</p><p><img src="http://img.itboyhub.com/2020/04/20200508162634.png" alt></p><p>这个项目也很优秀，但是最终却“落榜”了，主要是考虑到以下几个原因：</p><ol><li>这个项目看起来没有 vue-element-admin 那么“臃肿”，当然也意味着它的功能比较少。</li><li>ant design 本身发展时间挺久了，但是一直都是跟 React 玩，去年才开始支持 Vue，这也是这个 Ant Design Pro 看起来比较简单的原因。</li><li>这个项目权限部分的代码，和 vue-element-admin 具有高度相似性，如出一辙，所以还不如直接上 vue-element-admin。</li></ol><blockquote><p>话说回来，无论用哪个开源项目，想让项目契合自己的实际应用场景，都是需要大刀阔斧的修改的，开源项目拿来直接就能用的很少，从这个角度讲，其实用哪个都无所谓，反正自己都还要改不少东西。但是由于只能选择一个，我们还是选择了更懂 Vue 的 vue-element-admin。</p></blockquote><h2 id="iview-admin"><a href="#iview-admin" class="headerlink" title="iview-admin"></a>iview-admin</h2><ul><li>GitHub 地址：<a href="https://github.com/iview/iview-admin" target="_blank" rel="noopener">https://github.com/iview/iview-admin</a></li><li>演示地址：<a href="https://admin.iviewui.com" target="_blank" rel="noopener">https://admin.iviewui.com</a></li></ul><p>iView-admin 是 iView 生态中的成员之一，是一套采用前后端分离开发模式，基于 Vue 的后台管理系统前端解决方案。iView-admin2.0 脱离 1.x 版本进行重构，换用 Webpack4.0 + Vue-cli3.0 作为基本开发环境。内置了开发后台管理系统常用的逻辑功能，和开箱即用的业务组件，旨在让开发者能够以最小的成本开发后台管理系统，降低开发量。</p><p>看惯了 ElementUI ，偶尔看一看 iview 或者 ant design，感觉还蛮清新的。</p><p>来看一看它的效果图：<br><img src="http://img.itboyhub.com/2020/04/20200508174653.png" alt></p><blockquote><p>老实说，这些框架同质化太严重了，除了 UI 不一样，其他的基本上没啥区别，所以我们最终还是选择了更加经典的 vue-element-admin。</p></blockquote><p>我们主要是在这三款中进行比较的，所以这里主要和大家介绍这三个，小伙伴们要是用过其他好用的，欢迎留言区提出来哦～</p><h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><p>最后我再啰嗦一句，这种前端框架要如何学习的问题。</p><p>如果你是一个前端新手，刷过 Vue 官网但是还没做过 SPA 应用（甚至没听说过 SPA 应用），那么这三个框架对你来说还是蛮有挑战的，上手并不容易，我也不是特别建议使用这个来入门。</p><p>原因很简单，这三个前端框架都算是比较专业的前端框架，里边集成了很多东西，如果你是新手的话，很容易就搞懵了。</p><p>最好自己先做过一些 SPA 应用，对前端的整体流程有一个基本把握，再去学习这些框架，相对而言就会容易很多。说到这里，如果大家感兴趣，不妨看看松哥的：<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">微人事项目视频教程</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为因为项目的原因，一直在寻找一款合适的前端模版，之前的 Vue 前端页面都是自己写的，写多了就烦了，因为功能都差不多，写来写去就没意思了。&lt;/p&gt;
&lt;p&gt;所以在新项目中想看看市面上的 Vue 后台管理模版，找个现成的，改一改基本就 OK 了，团队也省事一些。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
</feed>
