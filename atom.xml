<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2023-09-12T09:39:46.021Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring 中三种 BeanName 生成器！</title>
    <link href="http://www.javaboy.org/2023/0912/spring-beanname-generator.html"/>
    <id>http://www.javaboy.org/2023/0912/spring-beanname-generator.html</id>
    <published>2023-09-12T09:21:04.000Z</published>
    <updated>2023-09-12T09:39:46.021Z</updated>
    
    <content type="html"><![CDATA[<p>无论我们是通过 XML 文件，还是 Java 代码，亦或是包扫描的方式去注册 Bean，都可以不设置 BeanName，而 Spring 均会为之提供默认的 beanName，今天我们就来看看 Spring 中三种处理不同情况的 beanName 生成器。</p><a id="more"></a><h2 id="1-BeanNameGenerator"><a href="#1-BeanNameGenerator" class="headerlink" title="1. BeanNameGenerator"></a>1. BeanNameGenerator</h2><p>Spring 中提供了一个名为 BeanNameGenerator 的接口，这个接口就只有一个需要实现的方法就是 generateBeanName，从名字就能看出来，这就是专门用来生成 beanName 的方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanNameGenerator</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有两个参数：</p><ul><li>definition：这个是要生成的 Bean 定义。</li><li>registry：这个是将来 BeanDefinition 的注册器。</li></ul><p>BeanNameGenerator 有三个不同的实现类，对应不同的处理场景：</p><p><img src="http://img.itboyhub.com/2022/08/BeanNameGenerator202309071905.png" alt></p><ul><li>AnnotationBeanNameGenerator：这个专门用来处理包扫描的时候扫到的 Bean，对于这些 Bean，其 name 属性该如何处理，由这个类来解决，当然，小伙伴们都知道，通过 @Component/@Service/@Repository/@Controller 这些注解定义的 Bean，默认情况下，beanName 就是类名首字母小写。</li><li>FullyQualifiedAnnotationBeanNameGenerator：这个继承自 AnnotationBeanNameGenerator，并重写了 AnnotationBeanNameGenerator#buildDefaultBeanName 方法，这个是使用类的全路径来作为 Bean 的默认名称。</li><li>DefaultBeanNameGenerator：这个是专门用来解决 XML 文件中定义的 Bean 如果没有设置 beanName，那么就通过 DefaultBeanNameGenerator 来为其生成 beanName。</li></ul><p>看了上面三个场景之后，可能有小伙伴发现一个 BUG，那么 @Bean 注解定义的 Bean，其 beanName 属性是在哪里处理的呢？这个其实比较特殊，是当场处理的，没用到 BeanNameGenerator，松哥后面单独说。</p><p>接下来我们详细看下上面这三个实现类。</p><h2 id="2-AnnotationBeanNameGenerator"><a href="#2-AnnotationBeanNameGenerator" class="headerlink" title="2. AnnotationBeanNameGenerator"></a>2. AnnotationBeanNameGenerator</h2><p>咱们直接来看最关键的 generateBeanName 方法吧：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (definition <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="hljs-comment">// Explicit bean name found.</span></span><br><span class="line"><span class="hljs-keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line"><span class="hljs-keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先判断 definition 是否为 AnnotatedBeanDefinition 类型，根据我们前面文章对 BeanDefinition 的介绍（<a href="https://mp.weixin.qq.com/s/G5_wqgjbpVp0qmscIkFaTg" target="_blank" rel="noopener">七种 BeanDefinition，各显其能！</a>），大家知道，AnnotatedBeanDefinition 的实现类主要是针对三种情况：@Bean 注解定义的 Bean、@Service/@Controller/@Component/@Repository 等注解标记的 Bean 以及系统的启动配置类，如果是这三种情况，那么就去调用 determineBeanNameFromAnnotation 方法，这个方法会尝试从注解中提取出来 beanName，如果不是上面三种情况，那么就调用 buildDefaultBeanName 方法去生成 beanName。</p><p>那我们先来看 determineBeanNameFromAnnotation 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determineBeanNameFromAnnotation</span><span class="hljs-params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">String beanName = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (String type : types) &#123;</span><br><span class="line">AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line"><span class="hljs-keyword">if</span> (attributes != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Set&lt;String&gt; metaTypes = <span class="hljs-keyword">this</span>.metaAnnotationTypesCache.computeIfAbsent(type, key -&gt; &#123;</span><br><span class="line">Set&lt;String&gt; result = amd.getMetaAnnotationTypes(key);</span><br><span class="line"><span class="hljs-keyword">return</span> (result.isEmpty() ? Collections.emptySet() : result);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-keyword">if</span> (isStereotypeWithNameValue(type, metaTypes, attributes)) &#123;</span><br><span class="line">Object value = attributes.get(<span class="hljs-string">"value"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> String strVal) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (beanName != <span class="hljs-keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Stereotype annotations suggest inconsistent "</span> +</span><br><span class="line"><span class="hljs-string">"component names: '"</span> + beanName + <span class="hljs-string">"' versus '"</span> + strVal + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">beanName = strVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先会去获取类上的注解信息，拿到 amd 之后，获取到所有的注解类型，然后进行遍历。</p><p>遍历的时候，首先获取到注解上的所有属性 attributes，当 attributes 不为空的时候，继续去读取当前注解的元注解，并将读取到的结果存入到 metaAnnotationTypesCache 集合中。这个是干嘛呢？大家知道，Spring 中用来标记 Bean 的注解大部分衍生自 @Component，甚至我们也可以自定义注解，那么如果自定义注解了，这个地方就没法判断了，因为每个人自定义出来的注解都不一样。所以，万变不离其宗，这里就去找各个注解的元注解。例如如果我们在类上添加的是 @Configuration，那么 @Configuration 的元注解有两个，分别是 @Component 和 @Indexed。</p><p>接下来的 isStereotypeWithNameValue 方法就是判断 type 是不是 @Component 或者 Jakarta 中自带的 @ManagedBean、@Named，亦或者 metaTypes 里是否包含 @Component。如果确定是 @Component 衍生出来的注解，亦或者是 @ManagedBean、@Named 注解标记的 Bean，那么就将其 value 属性读取出来，作为 beanName，如果包含多个有效注解，且各自配置的 beanName 不一致，就会抛出异常。</p><p>例如下面这种情况：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(<span class="hljs-string">"j"</span>)</span><br><span class="line"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"a"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个 beanName 不一致，运行时就会出错。</p><p>同时，经过上面的分析，小伙伴也看到了，我们其实可以通过自定义注解为 Bean 设置名称，例如我有如下注解：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyBeanName &#123;</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解衍生自 @Component，那么它的用法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@MyBeanName</span>(<span class="hljs-string">"f"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 f 就是当前类生成的 beanName。</p><p>以上是从注解中去提取 beanName，但是注解中可能没有提供 beanName，那么就得调用 buildDefaultBeanName 方法去自动生成了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> buildDefaultBeanName(definition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">String beanClassName = definition.getBeanClassName();</span><br><span class="line">Assert.state(beanClassName != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No bean class name set"</span>);</span><br><span class="line">String shortClassName = ClassUtils.getShortName(beanClassName);</span><br><span class="line"><span class="hljs-keyword">return</span> StringUtils.uncapitalizeAsProperty(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就很好懂了，先拿到 bean 的完整类名，然后提取出来 shortName，也就是去除包名之后的名字，然后首字母小写之后返回。</p><p>这就是 @Component 注解体系下的 beanName 生成流程。</p><h2 id="3-FullyQualifiedAnnotationBeanNameGenerator"><a href="#3-FullyQualifiedAnnotationBeanNameGenerator" class="headerlink" title="3. FullyQualifiedAnnotationBeanNameGenerator"></a>3. FullyQualifiedAnnotationBeanNameGenerator</h2><p>FullyQualifiedAnnotationBeanNameGenerator 类只是重写了 AnnotationBeanNameGenerator 的 buildDefaultBeanName 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildDefaultBeanName</span><span class="hljs-params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">String beanClassName = definition.getBeanClassName();</span><br><span class="line">Assert.state(beanClassName != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No bean class name set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> beanClassName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写后的方法就是获取类的完整路径返回。</p><p>FullyQualifiedAnnotationBeanNameGenerator 默认情况下并不会直接使用，需要自己手动配置，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(nameGenerator = FullyQualifiedAnnotationBeanNameGenerator.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，生成的 Bean 的默认名称就是类的全路径了。</p><h2 id="4-DefaultBeanNameGenerator"><a href="#4-DefaultBeanNameGenerator" class="headerlink" title="4. DefaultBeanNameGenerator"></a>4. DefaultBeanNameGenerator</h2><p>这个是专门用来处理 XML 中默认的 beanName 的。这个在最近录制的 Spring 源码视频中已经详细介绍过了，这里就不再啰嗦了，感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>。</p><h2 id="5-Bean-处理特殊情况"><a href="#5-Bean-处理特殊情况" class="headerlink" title="5. @Bean 处理特殊情况"></a>5. @Bean 处理特殊情况</h2><p>如果类是被 @Bean 注解标记的，那么处理情况就特殊一些，直接现场处理，方法在 <code>org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod</code> 位置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForBeanMethod</span><span class="hljs-params">(BeanMethod beanMethod)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Consider name and any aliases</span></span><br><span class="line">List&lt;String&gt; names = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(bean.getStringArray(<span class="hljs-string">"name"</span>)));</span><br><span class="line">String beanName = (!names.isEmpty() ? names.remove(<span class="hljs-number">0</span>) : methodName);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Register aliases even when overridden</span></span><br><span class="line"><span class="hljs-keyword">for</span> (String alias : names) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到，如果一开始配置了 name 属性，那么就把 names 集合中的第一个值拿出来作为 beanName，集合中的其他值则当作别名来处理，如果没有配置 name 属性值，那么就使用方法名作为 beanName。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>好啦，这就是松哥和大家讲的 Spring 中默认的 beanName 生成策略，感兴趣的小伙伴可以试试哦</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论我们是通过 XML 文件，还是 Java 代码，亦或是包扫描的方式去注册 Bean，都可以不设置 BeanName，而 Spring 均会为之提供默认的 beanName，今天我们就来看看 Spring 中三种处理不同情况的 beanName 生成器。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 条件注解没生效？咋回事</title>
    <link href="http://www.javaboy.org/2023/0911/spring-condition.html"/>
    <id>http://www.javaboy.org/2023/0911/spring-condition.html</id>
    <published>2023-09-11T09:20:52.000Z</published>
    <updated>2023-09-12T09:40:46.652Z</updated>
    
    <content type="html"><![CDATA[<p>条件注解相信各位小伙伴都用过，Spring 中的多环境配置 profile 底层就是通过条件注解来实现的，松哥在之前的 Spring 视频中也有和大家详细介绍过条件注解的使用，感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>。</p><a id="more"></a><p>从 Spring4.0 开始，Spring 提供了一个更加细粒度的条件注解： ConfigurationCondition。从名字上就可以看出来这个是搭配 @Configuration 注解一起使用的，ConfigurationCondition 提供了一种更加细粒度的条件匹配，可以在配置或者 Bean 注册的时候去评估条件注解是否满足。</p><p>也就是说，当一个类上存在条件注解的时候，我们可以有两个评估条件注解是否满足的时机：</p><ol><li>在配置的时候去评估。</li><li>在 Bean 注册的时候评估。</li></ol><p>在配置的时候评估，可能会导致当前类都不会被加载，在 Bean 注册的时候再去评估，意味着当前类就会被加载。</p><h2 id="1-ConfigurationCondition"><a href="#1-ConfigurationCondition" class="headerlink" title="1. ConfigurationCondition"></a>1. ConfigurationCondition</h2><p>我们先来看下这个类的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ConfigurationCondition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Condition</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">ConfigurationPhase <span class="hljs-title">getConfigurationPhase</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-keyword">enum</span> ConfigurationPhase &#123;</span><br><span class="line">PARSE_CONFIGURATION,</span><br><span class="line">REGISTER_BEAN</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到，这里其实就是定义了两个枚举值，然后提供了一个方法返回枚举值。</p><ul><li>PARSE_CONFIGURATION：这个表示 Condition 条件应该在解析 @Configuration 类时进行评估，如果评估不通过，则不会将 @Configuration 添加到容器中。</li><li>REGISTER_BEAN：这个表示添加常规 Bean 的时候去评估 Condition 条件（常规 Bean 就是指非配置类，例如添加搭配 @Bean 注解使用的条件注解），这个条件不会阻止注册 @Configuration 类到容器中。</li></ul><p>其实道理很好懂，就是加载配置类的时候就根据条件注解判断要不要加载配置类，还是等到注册 Bean 的时候再去看条件注解是否满足条件。</p><h2 id="2-案例分析"><a href="#2-案例分析" class="headerlink" title="2. 案例分析"></a>2. 案例分析</h2><p>松哥通过一个简单案例来和小伙伴们演示一下。</p><p>假设我现在有如下条件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConfigurationCondition</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurationPhase <span class="hljs-title">getConfigurationPhase</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ConfigurationPhase.PARSE_CONFIGURATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> context.getBeanFactory().containsBean(<span class="hljs-string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个条件我没有直接实现 Condition 接口，而是实现类 ConfigurationCondition 接口，在这个接口中，getConfigurationPhase 方法返回了 PARSE_CONFIGURATION，表示在加载配置类的时候就去评估条件是否满足，matches 方法则是去判断容器中是否存在一个名为 a 的 Bean。</p><p>现在我有两个配置类，分别是 A 和 B，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(MyCondition.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A 配置类正常加载，B 配置类有一个加载条件，就是得 A 存在，B 才会加载。</p><p>现在，在容器中加载 B 和 A 两个配置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.register(B.class,A.class);</span><br><span class="line">ctx.refresh();</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    System.out.println(beanDefinitionName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家注意，加载的时候，我先加载了 B，后加载了 A，这点很重要，加载 B 的时候，由于此时容器中还不存在一个名为 a 的 Bean，而我们的评估时机是在处理配置类的时候，因此就会导致 B 配置类不会被加载，最终打印出来的 BeanName 就没有 b。</p><p>但是，如果我们将 MyCondition 中，条件注解的评估时机改为 <code>ConfigurationPhase.REGISTER_BEAN</code>，那么就表示在系统启动的时候，并不会去评估条件注解是否满足，而是会将 @Configuration 配置类进行解析，此时启动系统，就会发现最终打印出来的 beanName 里既有 a 又有 b。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>接下来我们再来从源码的角度来分析一下上述行为。</p><p>在 Spring 中，提供了一个专门的内部类 ConditionEvaluator 来处理要不要跳过条件注解，该类中有一个名为 shouldSkip 的方法，用来处理此事：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> shouldSkip(metadata, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (metadata == <span class="hljs-keyword">null</span> || !metadata.isAnnotated(Conditional.class.getName())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (phase == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (metadata <span class="hljs-keyword">instanceof</span> AnnotationMetadata annotationMetadata &amp;&amp;</span><br><span class="line">ConfigurationClassUtils.isConfigurationCandidate(annotationMetadata)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Condition&gt; conditions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String[] conditionClasses : getConditionClasses(metadata)) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String conditionClass : conditionClasses) &#123;</span><br><span class="line">Condition condition = getCondition(conditionClass, <span class="hljs-keyword">this</span>.context.getClassLoader());</span><br><span class="line">conditions.add(condition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAwareOrderComparator.sort(conditions);</span><br><span class="line"><span class="hljs-keyword">for</span> (Condition condition : conditions) &#123;</span><br><span class="line">ConfigurationPhase requiredPhase = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (condition <span class="hljs-keyword">instanceof</span> ConfigurationCondition configurationCondition) &#123;</span><br><span class="line">requiredPhase = configurationCondition.getConfigurationPhase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> ((requiredPhase == <span class="hljs-keyword">null</span> || requiredPhase == phase) &amp;&amp; !condition.matches(<span class="hljs-keyword">this</span>.context, metadata)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个方法不用多说，我们来看第二个重载方法，重载方法多了一个参数 ConfigurationPhase，这个就表示配置的阶段，也就是条件注解生效的阶段。</p><p>首先会去判断当前注解是否是一个条件注解，如果不是条件注意，那么就不能跳过，要继续后面的解析（继续后面的解析时 Bean 将会被注册），如果是条件注解，则继续后面的判断。继续判断，如果没有传递 phase 进来，说明没有指定应该在哪个阶段去评估条件注解，那么这个时候就去判断，如果当前注解是一个配置类上的注解，那么就设置 phase 为 PARSE_CONFIGURATION，然后继续调用 shouldSkip 方法，否则就设置 phase 为 REGISTER_BEAN 然后继续调用 shouldSkip 方法。</p><blockquote><p>那么什么样的情况会被认为是一个配置类上的注解呢？如果当前类上添加的注解时 @Component、@ComponentScan、@Import、@ImportResource 以及这四种注解衍生出来的注解，亦或者当前类中有 @Bean 注解标记的方法，那么当前类就是一个配置类，就会设置 phase 为 PARSE_CONFIGURATION。</p></blockquote><p>第二次进入 shouldSkip 方法的时候，就已经有明确的 phase 了。这次进来后，把所有的条件注解的条件收集起来，存入到 conditions 集合中，然后再对该集合进行排序。然后遍历该集合。遍历的时候就去判断这个条件注解是不是 ConfigurationCondition 类型的，如果是，则提取出来其中的 phase 为 requiredPhase，这个就表示这个条件注意希望自己被处理的阶段，接下来去判断，如果 requiredPhase 为空，说明条件并未指定自己的执行时间，那么就执行 matches 方法进行条件评估；如果 requiredPhase 不为空，并且和传入的 phase 相等，那么也是当前评估。其实这个判断核心逻辑就是以参数传入进来的 phase 为准，要么条件没有设置评估时机，要么设置了，但是得和参数传进来的 phase 一致，只有满足这两个条件，才会当场进行评估。</p><p>这就是系统条件注解的评估逻辑。</p><p>对于配置类来说，是在 <code>AnnotatedBeanDefinitionReader#doRegisterBean</code> 方法中调用评估逻辑的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doRegisterBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass, @Nullable String name,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable BeanDefinitionCustomizer[] customizers)</span> </span>&#123;</span><br><span class="line">AnnotatedGenericBeanDefinition abd = <span class="hljs-keyword">new</span> AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候并未明确指定 phase，所以会在进入到 shouldSkip 方法后，自行分析是哪个阶段评估条件注解。</p><p>对于 @Bean 注解标记的类来说，是在 <code>ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod</code> 方法中调用评估逻辑的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitionsForBeanMethod</span><span class="hljs-params">(BeanMethod beanMethod)</span> </span>&#123;</span><br><span class="line">ConfigurationClass configClass = beanMethod.getConfigurationClass();</span><br><span class="line">MethodMetadata metadata = beanMethod.getMetadata();</span><br><span class="line">String methodName = metadata.getMethodName();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN)) &#123;</span><br><span class="line">configClass.skippedBeanMethods.add(methodName);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个调用的时候，就传入了 phase 了，直接指定了是在 Bean 初始化的时候评估。</p><p>好啦，这就是条件注解条件评估时机的两种情况。在 Spring Boot 中定义的条件注解里，有不少都用到了 ConfigurationCondition，而不是传统的 Condition，感兴趣的小伙伴可以自行查看哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;条件注解相信各位小伙伴都用过，Spring 中的多环境配置 profile 底层就是通过条件注解来实现的，松哥在之前的 Spring 视频中也有和大家详细介绍过条件注解的使用，感兴趣的小伙伴戳这里：&lt;a href=&quot;https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring源码应该怎么学？&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>七种 BeanDefinition，各显其能！</title>
    <link href="http://www.javaboy.org/2023/0906/spring-7-beandefinition.html"/>
    <id>http://www.javaboy.org/2023/0906/spring-7-beandefinition.html</id>
    <published>2023-09-06T09:20:39.000Z</published>
    <updated>2023-09-12T09:40:42.194Z</updated>
    
    <content type="html"><![CDATA[<p>聚沙成塔！不知不觉 Spring 源码已经连续更了两个月啦，视频也录制了不少了，对 Spring 源码分析感兴趣的小伙伴戳这里哦<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>～</p><a id="more"></a><p>今天我们继续来看 Spring 源码中一个非常重要的概念：BeanDefinition。</p><h2 id="1-BeanDefinition"><a href="#1-BeanDefinition" class="headerlink" title="1.BeanDefinition"></a>1.BeanDefinition</h2><p>在 Spring 容器中，我们广泛使用的是一个一个的 Bean，BeanDefinition 从名字上就可以看出是关于 Bean 的定义。</p><p>事实上就是这样，我们在 XML 文件中配置的 Bean 的各种属性，亦或者用注解定义出来的 Bean 的各种属性，在真正生成 Bean 直接，我们需要先对这些设置的属性进行解析，解析的结果需要有一个对象来承载，很明显，这个对象就是 BeanDefinition。</p><p>无论是通过 XML 中定义的 Bean 属性还是通过 Java 代码定义的 Bean 属性，都会先加载到 BeanDefinition 上，然后通过 BeanDefinition 来生成一个 Bean，从这个角度来说，BeanDefinition 和 Bean 的关系有点类似于类和对象的关系，BeanDefinition 是模板，Bean 是模板具体化之后的产物。</p><p>要理解 BeanDefinition，我们从 BeanDefinition 的继承关系开始看起。</p><p><img src="http://img.itboyhub.com/2020/BeanDefinition.png" alt></p><p>BeanDefinition 是一个接口，继承自 BeanMetadataElement 和 AttributeAccessor 接口。</p><ul><li>BeanMetadataElement：该接口只有一个方法 getSource，该方法返回 Bean 的来源。</li><li>AttributeAccessor：该接口主要规范了问任意对象元数据的方法。</li></ul><p>我们来看下 AttributeAccessor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AttributeAccessor</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, @Nullable Object value)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">removeAttribute</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAttribute</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">String[] attributeNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了元数据的访问接口，具体的实现则是 AttributeAccessorSupport，这些数据采用 LinkedHashMap 进行存储。</p><p>这是 BeanDefinition 所继承的两个接口。接下来我们来看下 BeanDefinition 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeAccessor</span>, <span class="hljs-title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"><span class="hljs-keyword">int</span> ROLE_APPLICATION = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ROLE_SUPPORT = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ROLE_INFRASTRUCTURE = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParentName</span><span class="hljs-params">(@Nullable String parentName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getParentName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBeanClassName</span><span class="hljs-params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getBeanClassName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setScope</span><span class="hljs-params">(@Nullable String scope)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getScope</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLazyInit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isLazyInit</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDependsOn</span><span class="hljs-params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">String[] getDependsOn();</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAutowireCandidate</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAutowireCandidate</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPrimary</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> primary)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrimary</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFactoryBeanName</span><span class="hljs-params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getFactoryBeanName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFactoryMethodName</span><span class="hljs-params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getFactoryMethodName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">ConstructorArgumentValues <span class="hljs-title">getConstructorArgumentValues</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasConstructorArgumentValues</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function">MutablePropertyValues <span class="hljs-title">getPropertyValues</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPropertyValues</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInitMethodName</span><span class="hljs-params">(@Nullable String initMethodName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getInitMethodName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDestroyMethodName</span><span class="hljs-params">(@Nullable String destroyMethodName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getDestroyMethodName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setRole</span><span class="hljs-params">(<span class="hljs-keyword">int</span> role)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRole</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDescription</span><span class="hljs-params">(@Nullable String description)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">ResolvableType <span class="hljs-title">getResolvableType</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAbstract</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getResourceDescription</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">BeanDefinition <span class="hljs-title">getOriginatingBeanDefinition</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinition 中的方法虽然多，但是结合我们平时在 XML/Java 中的配置，这些方法其实都很好理解：</p><ol><li>首先一开始定义了两个变量用来描述 Bean 是不是单例的，后面的 setScope/getScope 方法可以用来修改/获取 scope 属性。</li><li>ROLE_xxx 用来描述一个 Bean 的角色，ROLE_APPLICATION 表示这个 Bean 是用户自己定义的 Bean；ROLE_SUPPORT 表示这个 Bean 是某些复杂配置的支撑部分；ROLE_INFRASTRUCTURE 表示这是一个 Spring 内部的 Bean，通过 setRole/getRole 可以修改。</li><li>setParentName/getParentName 用来配置 parent 的名称，这块可能有的小伙伴使用较少，这个对应着 XML 中的 <code>&lt;bean parent=&quot;&quot;&gt;</code> 配置，在之前的视频中松哥已经和大家讲过了 Spring 中 parent 的使用了。</li><li>setBeanClassName/getBeanClassName 这个就是配置 Bean 的 Class 全路径，对应 XML 中的 <code>&lt;bean class=&quot;&quot;&gt;</code> 配置。</li><li>setLazyInit/isLazyInit 配置/获取 Bean 是否懒加载，这个对应了 XML 中的 <code>&lt;bean lazy-init=&quot;&quot;&gt;</code> 配置。</li><li>setDependsOn/getDependsOn 配置/获取 Bean 的依赖对象，这个对应了 XML 中的 <code>&lt;bean depends-on=&quot;&quot;&gt;</code> 配置。</li><li>setAutowireCandidate/isAutowireCandidate 配置/获取 Bean 是否是自动装配，对应了 XML 中的 <code>&lt;bean autowire-candidate=&quot;&quot;&gt;</code> 配置。</li><li>setPrimary/isPrimary 配置/获取当前 Bean 是否为首选的 Bean，对应了 XML 中的 <code>&lt;bean primary=&quot;&quot;&gt;</code> 配置。</li><li>setFactoryBeanName/getFactoryBeanName 配置/获取 FactoryBean 的名字，对应了 XML 中的 <code>&lt;bean factory-bean=&quot;&quot;&gt;</code> 配置，factory-bean 松哥在之前的视频中讲过，小伙伴们可以参考这里:<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a>。</li><li>setFactoryMethodName/getFactoryMethodName 和上一条成对出现的，对应了 XML 中的 <code>&lt;bean factory-method=&quot;&quot;&gt;</code> 配置，不再赘述。</li><li>getConstructorArgumentValues 返回该 Bean 构造方法的参数值。</li><li>hasConstructorArgumentValues 判断上一条是否是空对象。</li><li>getPropertyValues 这个是获取普通属性的集合。</li><li>hasPropertyValues 判断上一条是否为空对象。</li><li>setInitMethodName/setDestroyMethodName 配置 Bean 的初始化方法、销毁方法。</li><li>setDescription/getDescription 配置/返回 Bean 的描述。</li><li>isSingleton Bean 是否为单例。</li><li>isPrototype Bean 是否为原型。</li><li>isAbstract Bean 是否抽象。</li><li>getResourceDescription 返回定义 Bean 的资源描述。</li><li>getOriginatingBeanDefinition 如果当前 BeanDefinition 是一个代理对象，那么该方法可以用来返回原始的 BeanDefinition 。</li></ol><p>这个就是 BeanDefinition 的定义以及它里边方法的含义。</p><h2 id="2-BeanDefinition-实现类"><a href="#2-BeanDefinition-实现类" class="headerlink" title="2.BeanDefinition 实现类"></a>2.BeanDefinition 实现类</h2><p>上面只是 BeanDefinition 接口的定义，BeanDefinition 还拥有诸多实现类，我们也来大致了解下。</p><p>先来看一张继承关系图：</p><p><img src="http://img.itboyhub.com/2022/08/BeanDefinition202309051544.png" alt></p><p>这么多实现类看着有点眼花缭乱，不过搞清楚了每一个接口和类的作用，再看就很容易了。</p><h3 id="2-1-AbstractBeanDefinition"><a href="#2-1-AbstractBeanDefinition" class="headerlink" title="2.1 AbstractBeanDefinition"></a>2.1 AbstractBeanDefinition</h3><p>AbstractBeanDefinition 是一个抽象类，它根据 BeanDefinition 中定义的接口提供了相应的属性，并实现了 BeanDefinition 中定义的一部分方法。BeanDefinition 中原本只是定义了一系列的 get/set 方法，并没有提供对应的属性，在 AbstractBeanDefinition 中将所有的属性定义出来了。</p><p>后面其他的实现类也基本上都是在 AbstractBeanDefinition 的基础上完成的。</p><h3 id="2-2-RootBeanDefinition"><a href="#2-2-RootBeanDefinition" class="headerlink" title="2.2 RootBeanDefinition"></a>2.2 RootBeanDefinition</h3><p>这是一个比较常用的实现类，对应了一般的元素标签。</p><h3 id="2-3-ChildBeanDefinition"><a href="#2-3-ChildBeanDefinition" class="headerlink" title="2.3 ChildBeanDefinition"></a>2.3 ChildBeanDefinition</h3><p>可以让子 BeanDefinition 定义拥有从父 BeanDefinition 那里继承配置的能力，如果子 Bean 从父 Bean 获取配置，可以参考松哥之前的这篇文章：<a href="https://mp.weixin.qq.com/s/C8EnAU4A-6bvgm5jr3AK4w" target="_blank" rel="noopener">Spring BeanDefinition 也分父子？</a>。</p><h3 id="2-4-GenericBeanDefinition"><a href="#2-4-GenericBeanDefinition" class="headerlink" title="2.4 GenericBeanDefinition"></a>2.4 GenericBeanDefinition</h3><p>GenericBeanDefinition 是从 Spring2.5 以后新加入的 BeanDefinition 实现类。GenericBeanDefinition 可以动态设置父 Bean，同时兼具 RootBeanDefinition 和 ChildBeanDefinition 的功能，因此，自从有了 GenericBeanDefinition 之后，RootBeanDefinition 和 ChildBeanDefinition 现在相对就用的少了。</p><h3 id="2-5-AnnotatedBeanDefinition"><a href="#2-5-AnnotatedBeanDefinition" class="headerlink" title="2.5 AnnotatedBeanDefinition"></a>2.5 AnnotatedBeanDefinition</h3><p>这个表示注解类型 BeanDefinition，用于表示通过注解配置的 Bean 定义。通过 AnnotatedBeanDefinition，我们可以获取到被注解的 Bean 的相关信息，包括注解类型、属性值、方法等。这个接口提供了一种方便的方式来处理通过注解方式配置的 Bean，并且可以在运行时动态地获取和操作这些注解信息，当然，这是一个接口，它有三个实现类，分别是 AnnotatedGenericBeanDefinition、ScannedGenericBeanDefinition 以及 ConfigurationClassBeanDefinition。</p><h3 id="2-6-AnnotatedGenericBeanDefinition"><a href="#2-6-AnnotatedGenericBeanDefinition" class="headerlink" title="2.6 AnnotatedGenericBeanDefinition"></a>2.6 AnnotatedGenericBeanDefinition</h3><p>作为系统配置类的类会解析为 AnnotatedGenericBeanDefinition。</p><h3 id="2-7-ScannedGenericBeanDefinition"><a href="#2-7-ScannedGenericBeanDefinition" class="headerlink" title="2.7 ScannedGenericBeanDefinition"></a>2.7 ScannedGenericBeanDefinition</h3><p>这个是通过包扫描自动注册的 Bean，就会被解析为 ScannedGenericBeanDefinition。</p><h3 id="2-8-ConfigurationClassBeanDefinition"><a href="#2-8-ConfigurationClassBeanDefinition" class="headerlink" title="2.8 ConfigurationClassBeanDefinition"></a>2.8 ConfigurationClassBeanDefinition</h3><p>这是一个私有的内部类。我们通过 @Bean 注解定义的 Bean，最终会被解析为 ConfigurationClassBeanDefinition。</p><h3 id="2-9-ClassDerivedBeanDefinition"><a href="#2-9-ClassDerivedBeanDefinition" class="headerlink" title="2.9 ClassDerivedBeanDefinition"></a>2.9 ClassDerivedBeanDefinition</h3><p>ClassDerivedBeanDefinition 的作用是扩展并描述一个类派生的Bean的元数据。它是 AnnotatedBeanDefinition 接口的一个实现类，在 Spring 框架中用于表示通过类派生方式配置的Bean定义。</p><h3 id="2-10-CreateFromClassBeanDefinition"><a href="#2-10-CreateFromClassBeanDefinition" class="headerlink" title="2.10 CreateFromClassBeanDefinition"></a>2.10 CreateFromClassBeanDefinition</h3><p>这个是按照类型创建 Bean 的时候会用到。</p><p>差不多就这么多了，大部分我们日常开发中其实都用不上，接下来松哥通过几个具体的案例来和小伙伴们演示这些 BeanDefinition 的具体用法。后面的文章，我们再来分析这些 BeanDefinition 在 Spring 源码中是如何应用的。</p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3.实践"></a>3.实践</h2><p>接下来我通过几个具体的案例来和小伙伴们演示各种不同的 BeanDefinition 的用法，今天我主要和小伙伴们演示我们纯手动使用 BeanDefinition，然后分析一下我们平时的配置本质上使用的 BeanDefinition 是哪一个，今天我们先不去源码分析，单纯的就看看效果。</p><h3 id="3-1-GenericBeanDefinition"><a href="#3-1-GenericBeanDefinition" class="headerlink" title="3.1 GenericBeanDefinition"></a>3.1 GenericBeanDefinition</h3><p>先来看 GenericBeanDefinition，这个功能相对比较全，兼具 RootBeanDefinition 和 ChildBeanDefinition 的能力。</p><p>先来看一个简单用法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">GenericBeanDefinition bd = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">bd.setBeanClass(User.class);</span><br><span class="line">MutablePropertyValues pValues = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pValues.add(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">bd.setPropertyValues(pValues);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"user"</span>, bd);</span><br><span class="line">User user = beanFactory.getBean(<span class="hljs-string">"user"</span>, User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>小伙伴们看到，我们这里向 Spring 容器注册了一个 GenericBeanDefinition 类型的 BeanDefinition，GenericBeanDefinition 中包含了具体的 class 以及 Bean 的各个属性值。</p><p>如果我们在 Bean 定义的时候，想要使用继承特性，也可以使用 GenericBeanDefinition：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">GenericBeanDefinition parentBD = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">GenericBeanDefinition childBD = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">parentBD.setBeanClass(Animal.class);</span><br><span class="line">MutablePropertyValues pValues = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pValues.add(<span class="hljs-string">"name"</span>, <span class="hljs-string">"小黄"</span>);</span><br><span class="line">parentBD.setPropertyValues(pValues);</span><br><span class="line">childBD.setBeanClass(Dog.class);</span><br><span class="line">childBD.setParentName(<span class="hljs-string">"animal"</span>);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"animal"</span>, parentBD);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"dog"</span>, childBD);</span><br><span class="line">Dog dog = beanFactory.getBean(<span class="hljs-string">"dog"</span>, Dog.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"dog = "</span> + dog);</span><br></pre></td></tr></table></figure><p>这次我直接定义了两个 GenericBeanDefinition，一个作为 parent，另外一个作为 child，为 child 设置 parentName，则 child 可以继承 parent 中的属性。上面的案例中，最终打印出来 dog 的 name 属性就是 <strong>小黄</strong>，这块小伙伴们可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/C8EnAU4A-6bvgm5jr3AK4w" target="_blank" rel="noopener">Spring BeanDefinition 也分父子？</a>。</p><p>我们平时通过 XML 文件定义的 Bean，最终解析后就是 GenericBeanDefinition。</p><p>例如下面这样：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.demo.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载 XML 文件，创建容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans.xml"</span>);</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    BeanDefinition bd = ctx.getBeanFactory().getBeanDefinition(beanDefinitionName);</span><br><span class="line">    System.out.println(beanDefinitionName + <span class="hljs-string">"&gt;&gt;&gt;"</span> + bd.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230905161741.png" alt></p><p>这个也好理解，毕竟我们在 XML 中配置的时候，可能存在 parent，也可能不存在，用 GenericBeanDefinition 就能够应对各种情况。</p><h3 id="3-2-RootBeanDefinition-ChildBeanDefinition"><a href="#3-2-RootBeanDefinition-ChildBeanDefinition" class="headerlink" title="3.2 RootBeanDefinition/ChildBeanDefinition"></a>3.2 RootBeanDefinition/ChildBeanDefinition</h3><p>这两个常规的功能其实都有，但是 RootBeanDefinition 一般可以用来做 parent，不能用作 child，即给 RootBeanDefinition 不能配置 parentName 属性。强行设置会抛出如下异常：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParentName</span><span class="hljs-params">(@Nullable String parentName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (parentName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Root bean cannot be changed into a child bean with parent reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChildBeanDefinition 则既可以做 parent 也可以做 child，但是 ChildBeanDefinition 在使用的使用必须指定 parent，即使 ChildBeanDefinition 作为 parent，也必须指定 parent，所以 ChildBeanDefinition 在使用的过程中有一点点局限性，因此目前被 GenericBeanDefinition 代替了。</p><p>来看一个简单的案例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">RootBeanDefinition parentBD = <span class="hljs-keyword">new</span> RootBeanDefinition();</span><br><span class="line">parentBD.setBeanClass(Animal.class);</span><br><span class="line">MutablePropertyValues pValues = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pValues.add(<span class="hljs-string">"name"</span>, <span class="hljs-string">"小黄"</span>);</span><br><span class="line">parentBD.setPropertyValues(pValues);</span><br><span class="line">ChildBeanDefinition childBD = <span class="hljs-keyword">new</span> ChildBeanDefinition(<span class="hljs-string">"animal"</span>);</span><br><span class="line">childBD.setBeanClass(Dog.class);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"animal"</span>, parentBD);</span><br><span class="line">beanFactory.registerBeanDefinition(<span class="hljs-string">"dog"</span>, childBD);</span><br><span class="line">Dog dog = beanFactory.getBean(<span class="hljs-string">"dog"</span>, Dog.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"dog = "</span> + dog);</span><br></pre></td></tr></table></figure><h3 id="3-3-AnnotatedGenericBeanDefinition"><a href="#3-3-AnnotatedGenericBeanDefinition" class="headerlink" title="3.3 AnnotatedGenericBeanDefinition"></a>3.3 AnnotatedGenericBeanDefinition</h3><p>对于使用 @Configuration 注解标记的类，最终解析出来的 BeanDefinition 就是 AnnotatedGenericBeanDefinition。例如我有一个配置类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载配置类并启动容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    BeanDefinition beanDefinition = ctx.getBeanFactory().getBeanDefinition(beanDefinitionName);</span><br><span class="line">    System.out.println(beanDefinitionName + <span class="hljs-string">" &gt;&gt;&gt; "</span> + beanDefinition.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230905201527.png" alt></p><h3 id="3-4-ScannedGenericBeanDefinition"><a href="#3-4-ScannedGenericBeanDefinition" class="headerlink" title="3.4 ScannedGenericBeanDefinition"></a>3.4 ScannedGenericBeanDefinition</h3><p>这个是那些通过包扫描注册到 Spring 容器中的 Bean，在一开始定义出来的 BeanDefinition 就是 ScannedGenericBeanDefinition。</p><p>例如我有如下 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后配置包扫描：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    BeanDefinition beanDefinition = ctx.getBeanFactory().getBeanDefinition(beanDefinitionName);</span><br><span class="line">    System.out.println(beanDefinitionName + <span class="hljs-string">" &gt;&gt;&gt; "</span> + beanDefinition.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230905202035.png" alt></p><h3 id="3-5-ConfigurationClassBeanDefinition"><a href="#3-5-ConfigurationClassBeanDefinition" class="headerlink" title="3.5 ConfigurationClassBeanDefinition"></a>3.5 ConfigurationClassBeanDefinition</h3><p>当我们通过 @Bean 注解去定义 Bean 的时候，那么被 @Bean 注解标记的类就会被解析为 ConfigurationClassBeanDefinition。</p><p>例如下面这个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看解析后的 BeanDefinition 如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230905202930.png" alt></p><h3 id="3-6-CreateFromClassBeanDefinition"><a href="#3-6-CreateFromClassBeanDefinition" class="headerlink" title="3.6 CreateFromClassBeanDefinition"></a>3.6 CreateFromClassBeanDefinition</h3><p>这个其实用的少，但是咱么既然讲到 Spring，松哥也说两句。</p><p>这个是当我们想要创建一个对象，我们希望这个对象能够自动走一遍 Spring 中的各种后置处理器的时候，那么可以调用 createBean 方法，该方法内部使用了 CreateFromClassBeanDefinition。</p><p>例如如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = ctx.getBeanFactory();</span><br><span class="line">User user = beanFactory.createBean(User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>使用这种方式去创建一个 Bean，这个 Bean 会走一遍 Spring 中 Bean 的后置处理器，其中，createBean 方法的内部就使用了 CreateFromClassBeanDefinition。</p><h3 id="3-7-ClassDerivedBeanDefinition"><a href="#3-7-ClassDerivedBeanDefinition" class="headerlink" title="3.7 ClassDerivedBeanDefinition"></a>3.7 ClassDerivedBeanDefinition</h3><p>ClassDerivedBeanDefinition 和 CreateFromClassBeanDefinition 其实比较像，差别在于二者处理构造方法的方式不同。</p><p>而且 ClassDerivedBeanDefinition 是一个相当冷门的 BeanDefinition，在 GenericApplicationContext 的实现类中，可以使用 GenericXmlApplicationContext、StaticApplicationContext 或者 GenericGroovyApplicationContext，只有这三个类中 registerBean 方法用到了 ClassDerivedBeanDefinition，我们常见的 AnnotationConfigApplicationContext 由于方法重写的缘故并未使用 ClassDerivedBeanDefinition。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StaticApplicationContext ctx = <span class="hljs-keyword">new</span> StaticApplicationContext();</span><br><span class="line">ctx.registerBean(User.class,()-&gt;&#123;</span><br><span class="line">    User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> user;</span><br><span class="line">&#125;);</span><br><span class="line">User user = ctx.getBean(User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">    BeanDefinition bd = ctx.getBeanDefinition(beanDefinitionName);</span><br><span class="line">    System.out.println(beanDefinitionName + <span class="hljs-string">"&gt;&gt;&gt;"</span> + bd.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以调用 registerBean 方法向 Spring 容器中注入一个 Bean，该方法第二个参数是一个 Bean 的生产者，如果不指定生产者，那么这个方法最终就是通过第一个参数反射创建 Bean，registerBean 方法的内部就是使用了 ClassDerivedBeanDefinition。</p><p>好啦，BeanDefinition 一共就是这七种，接下来我会通过几篇文章和大家重点介绍 GenericBeanDefinition、AnnotatedGenericBeanDefinition、ScannedGenericBeanDefinition 以及 ConfigurationClassBeanDefinition 这四种最为常见的 BeanDefinition。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聚沙成塔！不知不觉 Spring 源码已经连续更了两个月啦，视频也录制了不少了，对 Spring 源码分析感兴趣的小伙伴戳这里哦&lt;a href=&quot;https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring源码应该怎么学？&lt;/a&gt;～&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean 别名处理原理分析</title>
    <link href="http://www.javaboy.org/2023/0905/spring-alias.html"/>
    <id>http://www.javaboy.org/2023/0905/spring-alias.html</id>
    <published>2023-09-05T09:20:24.000Z</published>
    <updated>2023-09-12T09:40:38.935Z</updated>
    
    <content type="html"><![CDATA[<p>今天来和小伙伴们聊一聊 Spring 中关于 Bean 别名的处理逻辑。</p><a id="more"></a><h2 id="1-Alias"><a href="#1-Alias" class="headerlink" title="1. Alias"></a>1. Alias</h2><p>别名，顾名思义就是给一个 Bean 去两个甚至多个名字。整体上来说，在 Spring 中，有两种不同的别名定义方式：</p><ol><li>定义 Bean 的 name 属性，name 属性在真正的处理过程中，实际上就是按照别名来处理的。</li><li>通过 alias 标签定义专门的别名，通过 alias 定义出来的别名和 name 属性定义的别名最终都是合并在一起处理的，所以<strong>这两种定义别名的方式最终是殊途同归</strong>。</li></ol><p>那么定义的别名是保存在哪里呢？</p><p>大家知道，Bean 解析出来之后被保存在容器中，别名其实也是一样的，容器中存在一个 aliasMap 专门用来保存 Bean 的别名，保存的格式是 alias-&gt;name，例如有一个 Bean 的名字是 user，别名是 userAlias，那么保存在 aliasMap 中就是 userAlias-&gt;user。</p><p>举个简单例子：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.demo.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user4,user5,user6"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"user2"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user2"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"user3"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在上面这段定义中，user2、user3、user4、user5、user6 都是别名。</p><h2 id="2-AliasRegistry"><a href="#2-AliasRegistry" class="headerlink" title="2. AliasRegistry"></a>2. AliasRegistry</h2><h3 id="2-1-AliasRegistry"><a href="#2-1-AliasRegistry" class="headerlink" title="2.1 AliasRegistry"></a>2.1 AliasRegistry</h3><p>Spring 中为别名的处理提供了 AliasRegistry 接口，这个接口中提供了别名处理的主要方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AliasRegistry</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(String name, String alias)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeAlias</span><span class="hljs-params">(String alias)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlias</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>registerAlias：这个方法用来添加别名，核心逻辑就是向 aliasMap 中添加数据。</li><li>removeAlias：这个方法用来从 aliasMap 中移除一个别名。</li><li>isAlias：判断给定的 name 是否是一个别名。</li><li>getAliases：根据给定的名字去获取所有的别名。</li></ul><p>方法就这四个，看一下这个接口的实现类有哪些。</p><p><img src="http://img.itboyhub.com/2022/08/AliasRegistry202308261044.png" alt></p><p>大家看到，AliasRegistry 的实现类其实还是蛮多的，但是大部分都是容器，真正实现了 AliasRegistry 中四个方法的只有 SimpleAliasRegistry，其他的容器大部分其实都是为了具备别名管理的能力，继承了 SimpleAliasRegistry。</p><p>所以真正给我们整活的其实是 SimpleAliasRegistry。</p><h3 id="2-2-SimpleAliasRegistry"><a href="#2-2-SimpleAliasRegistry" class="headerlink" title="2.2 SimpleAliasRegistry"></a>2.2 SimpleAliasRegistry</h3><p>SimpleAliasRegistry 类中的内容比较多，为了讲解方便，我就挨个贴属性和方法出来，贴出来后和大家分享。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; aliasMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);</span><br></pre></td></tr></table></figure><p>首先，SimpleAliasRegistry 中定义了一个 aliasMap，这个就是用来保存别名的，这是一个 Map 集合，接下来所有的操作都是围绕这个集合展开。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAlias</span><span class="hljs-params">(String alias)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.aliasMap) &#123;</span><br><span class="line">String name = <span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line"><span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No alias '"</span> + alias + <span class="hljs-string">"' registered"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来移除别名，移除的思路很简单，就是从 aliasMap 中移除数据即可，如果 remove 方法返回值为 null 那就说明要移除的别名不存在，那么直接抛出异常。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAlias</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.aliasMap.containsKey(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是判断是否包含某一个别名，这个判断简单。有一个跟它容易产生歧义的方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAlias</span><span class="hljs-params">(String name, String alias)</span> </span>&#123;</span><br><span class="line">String registeredName = <span class="hljs-keyword">this</span>.aliasMap.get(alias);</span><br><span class="line"><span class="hljs-keyword">return</span> ObjectUtils.nullSafeEquals(registeredName, name) ||</span><br><span class="line">(registeredName != <span class="hljs-keyword">null</span> &amp;&amp; hasAlias(name, registeredName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是判断给定的 name 和 alias 之间是否具备关联关系。判断的逻辑就是先去 aliasMap 中，根据 alias 查出来这个 alias 所对应的真实 beanName，即 registeredName，然后判断 registeredName 和 name 是否相等，如果相等就直接返回，如果不相等就继续递归调用，为什么要递归呢？因为 aliasMap 中存在的别名可能是这样的：</p><ul><li>a-&gt;b</li><li>b-&gt;c</li><li>c-&gt;d</li></ul><p>即 a 是 b 的别名，b 是 c 的别名，c 是 d 的别名，现在如果想要判断 a 和 d 之间的关系，那么根据 a 查出来的 b 显然不等于 d，所以要继续递归，再根据 b 查 c，根据 c 查到 d，这样就能确定 a 和 d 是否有关系了。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> String[] getAliases(String name) &#123;</span><br><span class="line">List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.aliasMap) &#123;</span><br><span class="line">retrieveAliases(name, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> StringUtils.toStringArray(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">retrieveAliases</span><span class="hljs-params">(String name, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.forEach((alias, registeredName) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">result.add(alias);</span><br><span class="line">retrieveAliases(alias, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getAliases 方法是根据传入的 name 找到其对应的别名，但是由于别名可能存在多个，所以调用 retrieveAliases 方法递归去查找所有的别名，将找到的别名都存入到一个集合中，最终将集合转为数组返回。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForAliasCircle</span><span class="hljs-params">(String name, String alias)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (hasAlias(alias, name)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot register alias '"</span> + alias +</span><br><span class="line"><span class="hljs-string">"' for name '"</span> + name + <span class="hljs-string">"': Circular reference - '"</span> +</span><br><span class="line">name + <span class="hljs-string">"' is a direct or indirect alias for '"</span> + alias + <span class="hljs-string">"' already"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来检查别名是否存在死结，即 a 是 b 的别名，b 是 a 的别名这种情况。检查的方式很简单，就是调用 hasAlias 方法，但是将传入的两个参数颠倒过来就可以了。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resolveAliases</span><span class="hljs-params">(StringValueResolver valueResolver)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.aliasMap) &#123;</span><br><span class="line">Map&lt;String, String&gt; aliasCopy = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-keyword">this</span>.aliasMap);</span><br><span class="line">aliasCopy.forEach((alias, registeredName) -&gt; &#123;</span><br><span class="line">String resolvedAlias = valueResolver.resolveStringValue(alias);</span><br><span class="line">String resolvedName = valueResolver.resolveStringValue(registeredName);</span><br><span class="line"><span class="hljs-keyword">if</span> (resolvedAlias == <span class="hljs-keyword">null</span> || resolvedName == <span class="hljs-keyword">null</span> || resolvedAlias.equals(resolvedName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!resolvedAlias.equals(alias)) &#123;</span><br><span class="line">String existingName = <span class="hljs-keyword">this</span>.aliasMap.get(resolvedAlias);</span><br><span class="line"><span class="hljs-keyword">if</span> (existingName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (existingName.equals(resolvedName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"Cannot register resolved alias '"</span> + resolvedAlias + <span class="hljs-string">"' (original: '"</span> + alias +</span><br><span class="line"><span class="hljs-string">"') for name '"</span> + resolvedName + <span class="hljs-string">"': It is already registered for name '"</span> +</span><br><span class="line">registeredName + <span class="hljs-string">"'."</span>);</span><br><span class="line">&#125;</span><br><span class="line">checkForAliasCircle(resolvedName, resolvedAlias);</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.put(resolvedAlias, resolvedName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!registeredName.equals(resolvedName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.put(alias, resolvedName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是处理别名是占位符的情况，例如当引入了一个 <code>.properties</code> 文件之后，那么在配置别名的时候就可以引用 <code>.properties</code> 中的变量，那么上面这个方法就是用来解析变量的。</p><p>例如下面这种情况，我有一个 alias.properties，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=user</span><br><span class="line">alias=javaboy</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中使用这个 properties 文件，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:alias.properties"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"$&#123;name&#125;"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"$&#123;alias&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>对于这种情况，一开始存入到 aliasMap 中的就是占位符了，resolveAliases 方法就是要将这些占位符解析为具体的字符串。</p><p>大家看到，首先这里将 aliasMap 复制一份，生成一个 aliasCopy，然后进行遍历。在遍历时，根据 valueResolver 将引用使用的占位符解析为真正的字符，如果解析出来的。如果解析出来的 name 和别名是相同的，那么显然是有问题的，就需要把这个别名移除掉。</p><p>继续判断，如果解析出来的别名和原本的别名不相等（说明别名使用了占位符），那么就去检查一下这个别名对应的 name，如果这个 name 已经存在，且等于占位符解析出来的 name，说明这个别名已经被定义过了，即重复定义，那么就把别名移除掉即可。如果这个别名指向的 name 和占位符解析出来的 name 不相等，说明试图让一个别名指向两个 bean，那么就直接抛出异常了。</p><p>如果解析出来的别名还没有指向 name 属性的话，那么就正常处理，检查是否存在死结、移除带占位符的别名，存入解析之后的别名。</p><p>最后，如果原本的名称和解析之后的属性名称不相等，那么就直接保存这个别名即可。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(String name, String alias)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.aliasMap) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (alias.equals(name)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.remove(alias);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">String registeredName = <span class="hljs-keyword">this</span>.aliasMap.get(alias);</span><br><span class="line"><span class="hljs-keyword">if</span> (registeredName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot define alias '"</span> + alias + <span class="hljs-string">"' for name '"</span> +</span><br><span class="line">name + <span class="hljs-string">"': It is already registered for name '"</span> + registeredName + <span class="hljs-string">"'."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">checkForAliasCircle(name, alias);</span><br><span class="line"><span class="hljs-keyword">this</span>.aliasMap.put(alias, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是使用最多的别名注册了，传入的参数分别是 bean 的 name 和 alias，如果 alias 跟 name 相等，二话不说直接移除，这个 alias 有问题。</p><p>否则就去查询这个 alias，检查这个 alias 是否已经有对应的 name 了，如果有，且等于传入的 name，那么直接返回就行了，不用注册，因为已经注册过了；如果有且不等于传入的 name，那么就抛出异常，因为一个 alias 不能指向两个 name。最后就是检查和保存了。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">canonicalName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">String canonicalName = name;</span><br><span class="line">String resolvedName;</span><br><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line">resolvedName = <span class="hljs-keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line"><span class="hljs-keyword">if</span> (resolvedName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">canonicalName = resolvedName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">while</span> (resolvedName != <span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用来解析出来别名里边顶格的名字，例如有一个 bean 有很多别名，a-&gt;b,b-&gt;c,c-&gt;d，那么这个方法的目的就是传入 a、b、c 中任意一个，返回 d 即可。因为 Spring 容器在处理的时候，并不用管这么多别名问题，容器只需要专注一个名字即可，因为最后一个别名实际上就是指向真实的 beanId 了，所以最终拿到的 bean 名称其实相当于 bean 的 ID 了。</p><p>别名的处理主要就是这些方法。</p><h2 id="3-原理分析"><a href="#3-原理分析" class="headerlink" title="3. 原理分析"></a>3. 原理分析</h2><p>前面我们说了，别名的来源主要是两个地方：name 属性和 alias 标签，我们分别来看。</p><h3 id="3-1-name-处理"><a href="#3-1-name-处理" class="headerlink" title="3.1 name 处理"></a>3.1 name 处理</h3><p>对于 name 属性的处理，有两个地方，一个是在 bean 定义解析的时候，将 name 属性解析为 alias，具体在 BeanDefinitionParserDelegate#parseBeanDefinitionElement 方法中（这个方法在之前跟大家讲 bean 的默认名称生成策略的时候，见过）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionHolder <span class="hljs-title">parseBeanDefinitionElement</span><span class="hljs-params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//省略其他</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就从 XML 节点中提取出来 name 属性，然后切分为一个数组，并将之存入到 aliases 属性中。接下来在后续的 BeanDefinitionReaderUtils#registerBeanDefinition 方法中，再把 aliases 中的值注册一下，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="hljs-keyword">if</span> (aliases != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 XML 中的 name 属性是如何变为别名的。</p><h3 id="3-2-别名标签处理"><a href="#3-2-别名标签处理" class="headerlink" title="3.2 别名标签处理"></a>3.2 别名标签处理</h3><p>别名的另一个来源是别名标签，在 Spring 解析 XML 标签的时候，有针对别名标签的专门处理，具体位置是在 DefaultBeanDefinitionDocumentReader#parseDefaultElement 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">importBeanDefinitionResource(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">processAliasRegistration(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line"><span class="hljs-comment">// recurse</span></span><br><span class="line">doRegisterBeanDefinitions(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会去判断标签的类型，如果是别名，就调用 processAliasRegistration 方法进行处理：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processAliasRegistration</span><span class="hljs-params">(Element ele)</span> </span>&#123;</span><br><span class="line">String name = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">String alias = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line"><span class="hljs-keyword">boolean</span> valid = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasText(name)) &#123;</span><br><span class="line">getReaderContext().error(<span class="hljs-string">"Name must not be empty"</span>, ele);</span><br><span class="line">valid = <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasText(alias)) &#123;</span><br><span class="line">getReaderContext().error(<span class="hljs-string">"Alias must not be empty"</span>, ele);</span><br><span class="line">valid = <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (valid) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">getReaderContext().getRegistry().registerAlias(name, alias);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="hljs-string">"Failed to register alias '"</span> + alias +</span><br><span class="line"><span class="hljs-string">"' for bean with name '"</span> + name + <span class="hljs-string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里也是从 XML 文件中的别名标签上，提取出来 name 和 alias 属性值，最后调用 registerAlias 方法进行注册。</p><p>好啦，这就是 Spring 中关于别名的处理流程啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来和小伙伴们聊一聊 Spring 中关于 Bean 别名的处理逻辑。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一段让人抓心挠肝的源码</title>
    <link href="http://www.javaboy.org/2023/0904/instanceof-optimize.html"/>
    <id>http://www.javaboy.org/2023/0904/instanceof-optimize.html</id>
    <published>2023-09-04T09:20:11.000Z</published>
    <updated>2023-09-12T09:40:36.003Z</updated>
    
    <content type="html"><![CDATA[<p>加了松哥微信的小伙伴可能注意到松哥前两天发的一个朋友圈了，就是我在录制 Spring 源码的时候，发现了这样一段代码：</p><a id="more"></a><p>为了大家阅读方便，我这里只贴出来一些关键的部分：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getObjectForBeanInstance</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//省略</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean&lt;?&gt; factoryBean)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line"><span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line">object = getObjectFromFactoryBean(factoryBean, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码里有一个比较好玩的地方就是使用了 JDK16 中引入的增强类型推断，以前我们用 instanceof 的时候可能是这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> B)&#123;</span><br><span class="line">  B b = (B)a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样比较麻烦，所以从 JDK16 开始，支持一种新的写法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> B b)&#123;</span><br><span class="line">  <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码跟上面的代码的作用是一模一样的。</p><p>最上面的 Spring 源码其实就是用了这个最新的写法。</p><p>但是！！！</p><p>我今天想和各位小伙伴聊的其实还不是这个问题，而是在上面的 Spring 源码中，factoryBean 变量是在 if 分支中定义的，按理说，它的作用域就存在于 if 分支中，但是各位小伙伴注意，factoryBean 变量却可以在下面的 if 中使用，这是咋回事呢？</p><p>大家看下下面这个截图，这个是 Spring 框架在 2022.01.26 的提交日志，就是这一次提交修改了上面这个 getObjectForBeanInstance 方法：</p><p><img src="http://img.itboyhub.com/2022/08/20230902192108.png" alt></p><p>从这段变更中，我们其实可以看到，在之前的 Spring 源码中，是有专门的一行 <code>FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</code> 去做类型转换的，然后在接下来的方法中去使用该变量，但是现在没有这样一句了，很明显，现在是在 if 中做 instanceof 判断时顺手定义的 factoryBean 变量，在下面的 if 分支中使用了，这和我们理解的 Java 中变量的作用域似乎不太一样。</p><p>这是咋回事呢？</p><p>前两天我发个朋友圈之后，有小伙伴说这是语法糖，这显然不是，因为如果是语法糖，这很容易造成歧义，变量的作用域岂不是全乱了？</p><p>也有小伙伴说这是新特性，这个很聪明，不认识的写法统一都是新特性。但是新在哪里？什么样的情况下可以在 if 之外使用 if 判断条件里声明的变量？什么样的情况下不可以？</p><p><strong>今天这个问题松哥就不说教了，欢迎各位小伙伴评论区说出你的答案！</strong></p><p><strong>松哥会从评论区选出来 3 位小伙伴，各送一本《Spring Boot+Spring Cloud+Vue+Element 项目实战·徐丽健著》。</strong></p><p>松哥最近在录的 Spring 源码视频，不是枯燥的源码分析，我会从每一个组件的用法入手，跟各位小伙伴分析它怎么用，为什么这样用，它的原理是什么，从浅到深，一步一步推理。在这个过程中也会小伙伴们聊一聊 Spring6 中引入的一些 JDK 新语法，源码阅读技巧分析技巧等，感兴趣的小伙伴戳<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">这里</a>查看详情上车吧～<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w" target="_blank" rel="noopener">Spring源码应该怎么学？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加了松哥微信的小伙伴可能注意到松哥前两天发的一个朋友圈了，就是我在录制 Spring 源码的时候，发现了这样一段代码：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
      <category term="JDK16" scheme="http://www.javaboy.org/tags/JDK16/"/>
    
  </entry>
  
  <entry>
    <title>FactoryBean 和它的兄弟SmartFactoryBean！</title>
    <link href="http://www.javaboy.org/2023/0831/spring-factorybean-smartfactorybean.html"/>
    <id>http://www.javaboy.org/2023/0831/spring-factorybean-smartfactorybean.html</id>
    <published>2023-08-31T09:19:58.000Z</published>
    <updated>2023-09-12T09:40:32.896Z</updated>
    
    <content type="html"><![CDATA[<p>之前松哥写过一篇文章，跟小伙伴们介绍了我们在面试中非常常见的一道面试题：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/r3rnVhU8vr58Cw__UWOVLA" target="_blank" rel="noopener">Spring 中 BeanFactory 和 FactoryBean 有何区别？</a></li></ul><p>在这篇文章中，松哥也和各位小伙伴演示了了 FactoryBean 的一些具体用法，但是关于 FactoryBean 的一些具体实践，这篇文章中没有讲，那么今天我就来和大家聊一聊这个话题，顺便再来说说 FactoryBean 的兄弟 SmartFactoryBean。</p><h2 id="1-使用差别"><a href="#1-使用差别" class="headerlink" title="1. 使用差别"></a>1. 使用差别</h2><p>FactoryBean 的用法我就不再重复了，这里来看下 SmartFactoryBean。</p><p>FactoryBean 有很多实现类，但是继承自 FactoryBean 的接口却只有 SmartFactoryBean 一个。</p><p>SmartFactoryBean 接口的定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SmartFactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEagerInit</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，SmartFactoryBean 就是在 FactoryBean 的基础之上多了两个方法：</p><ul><li>isPrototype：这个方法就是返回当前 Bean 是否是多实例。初看这个方法，有的小伙伴可能会感觉到诧异，因为在 FactoryBean 中实际上有一个跟它功能类似的方法叫做 isSingleton，isSingleton 的意思就是说这个 Bean 是否是单例的，那么为什么现在还多了一个 isPrototype 方法呢？在前面的视频中松哥和大家讲过，Spring 中 Bean 的 scope 一共有六种，singleton 和 prototype 只是其中的两种，所以，isSingleton 为 true 就表示是单例，但是为 false 并不能表示就是 prototype，同理，isPrototype 为 true 就表示是多实例，但是 isPrototype 为 false 并不能表示就是 singleton，因此，这两个方法是不冲突的。</li><li>isEagerInit：这个方法就好理解了，方法名表示是否要提前初始化 Bean。当我们使用 FactoryBean 的时候，默认情况下，Spring 在初始化 Bean 的时候，初始化的是工厂 Bean，例如我们有一个 UserFactoryBean，那么默认情况下，Spring 容器初始化的是 UserFactoryBean，而 UserFactoryBean 中 getObject 方法真正要返回的 User 则在第一次使用的时候，才会被初始化，不知不觉中，目标 Bean 的初始化就被延迟了。如果不使用 SmartFactoryBean 的话，那我们得通过 Bean 的提前注入等方式去实现 Bean 的提前初始化，如果使用 SmartFactoryBean 的话，那么就可以通过配置 isEagerInit 方法返回 true 来实现目标 Bean 提前初始化了。</li></ul><p>关于第二个方法 isEagerInit，我举个例子给大家演示一下。</p><p>假设我有一个 User 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"User-init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又有一个 UserFactoryBean，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserFactoryBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"UserFactoryBean-init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后扫描这个 Bean 并且启动容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当我只初始化容器，不从容器中获取任何 Bean，控制台就会只打印 <code>UserFactoryBean-init</code>。</p><p>这就说明只有 UserFactoryBean 被 Spring 容器初始化了，我们的 User 对象其实还没被初始化，User 对象要在第一次使用的时候，才会被初始化。</p><p>如果我们的 UserFactoryBean 实现的是 SmartFactoryBean 接口，那么就可以按照如下方式进行配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartFactoryBean</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserFactoryBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"UserFactoryBean-init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEagerInit</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们启动容器，但是却不获取任何 Bean，那么大家就会发现，<code>User-init</code> 也打印出来了，目标 Bean 也被初始化了。</p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h2><p>接下来我们就从源码的角度来和大家简单梳理一下。</p><p>大家知道，容器的初始化是从 refresh 方法开始的，refresh 在初始化的过程中会调用到 finishBeanFactoryInitialization，而在 finishBeanFactoryInitialization 方法中则会调用到 beanFactory.preInstantiateSingletons() 方法，这个方法的作用就是去初始化那些不是延迟加载的 Bean。</p><p>所以，问题的核心就在 beanFactory.preInstantiateSingletons() 方法中，一起来看下。</p><p>DefaultListableBeanFactory#preInstantiateSingletons：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> SmartFactoryBean&lt;?&gt; smartFactoryBean &amp;&amp; smartFactoryBean.isEagerInit()) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton smartSingleton) &#123;</span><br><span class="line">StartupStep smartInitialize = <span class="hljs-keyword">this</span>.getApplicationStartup().start(<span class="hljs-string">"spring.beans.smart-initialize"</span>)</span><br><span class="line">.tag(<span class="hljs-string">"beanName"</span>, beanName);</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">smartInitialize.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的逻辑还是比较好理解。</p><p>首先 beanNames 中保存的就是所有 bean 名称，然后进行遍历。</p><p>遍历的时候根据 beanName 获取到 RootBeanDefinition，然后查看类是否不是抽象类、是否是单例以及是否不延迟初始化，如果满足条件，那么就开始初始化。</p><p>初始化的时候，首先判断当前 beanName 是否是一个 FactoryBean，大家注意，如果是 FactoryBean，则调用 getBean 方法去获取 Bean，但是调用的时候，在 beanName 的前面加上了 FACTORY_BEAN_PREFIX，这个其实就是 <code>&amp;</code>，在前面的视频中松哥和大家讲过，加上 <code>&amp;</code> 之后，这里获取到的就不是目标 Bean，而是这个 FactoryBean。这就是为什么在第一小节中和大家说，使用 FactoryBean 会导致目标 Bean 延迟加载，原因就在这里，因为初始化的时候给 beanName 加上了 <code>&amp;</code> 前缀，所以初始化的就不是目标 Bean 了。</p><p>接下来还有一个判断，如果初始化出来的 Bean 是一个 SmartFactoryBean 对象，并且 isEagerInit 方法还返回 true，那么就再次调用 getBean 方法进行 Bean 的初始化，此时 Bean 的初始化传入的 beanName 就没有添加前缀了，那么初始化的就是目标 Bean 了，这也和我们第一小节中讲的结论相符。</p><p>初始化的时候，如果判断当前 bean 不是一个 FactoryBean，那么就直接调用 getBean 方法进行 Bean 的初始化。</p><p>最后还有一段逻辑，就是根据 beanName 获取到实例名称，如果这个实例是一个 SmartInitializingSingleton 类型的，那么就调用一下它的 afterSingletonsInstantiated 方法。</p><p>那么上面这段源码还涉及到两个地方，分别是 isFactoryBean 和 getBean。</p><h3 id="2-1-isFactoryBean"><a href="#2-1-isFactoryBean" class="headerlink" title="2.1 isFactoryBean"></a>2.1 isFactoryBean</h3><p>这个方法就是根据 beanName 判断是否是一个 FactoryBean，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFactoryBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">String beanName = transformedBeanName(name);</span><br><span class="line">Object beanInstance = getSingleton(beanName, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (beanInstance != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// No singleton instance found -&gt; check bean definition.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() <span class="hljs-keyword">instanceof</span> ConfigurableBeanFactory cbf) &#123;</span><br><span class="line"><span class="hljs-comment">// No bean definition found in this factory -&gt; delegate to parent.</span></span><br><span class="line"><span class="hljs-keyword">return</span> cbf.isFactoryBean(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> isFactoryBean(beanName, getMergedLocalBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFactoryBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">Boolean result = mbd.isFactoryBean;</span><br><span class="line"><span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; beanType = predictBeanType(beanName, mbd, FactoryBean.class);</span><br><span class="line">result = (beanType != <span class="hljs-keyword">null</span> &amp;&amp; FactoryBean.class.isAssignableFrom(beanType));</span><br><span class="line">mbd.isFactoryBean = result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个里边，首先调用 transformedBeanName 方法对 beanName 进行一个预处理：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">transformedBeanName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> canonicalName(BeanFactoryUtils.transformedBeanName(name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">transformedBeanName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> transformedBeanNameCache.computeIfAbsent(name, beanName -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line">beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">while</span> (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));</span><br><span class="line"><span class="hljs-keyword">return</span> beanName;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">canonicalName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">String canonicalName = name;</span><br><span class="line"><span class="hljs-comment">// Handle aliasing...</span></span><br><span class="line">String resolvedName;</span><br><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line">resolvedName = <span class="hljs-keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line"><span class="hljs-keyword">if</span> (resolvedName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">canonicalName = resolvedName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">while</span> (resolvedName != <span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到，在静态的 transformedBeanName 方法中，首先判断 beanName 是否是以 <code>&amp;</code> 开头，如果不是，则直接返回 beanName 即可。否则就通过一个 do{}while() 将 beanName 中的 <code>&amp;</code> 都给删除掉，防止出现类似 <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;user</code> 这种 beanName。</p><p>然后调用 canonicalName 方法获取到规范的 beanName，因为 bean 可能存在别名，如果使用的是别名，则将之在 canonicalName 方法中解析为规范的 beanName。</p><p>有了 beanName 之后，接下来调用 getSingleton 方法去一级缓存中查询这个 Bean 是否已经完成初始化了，如果已经完成，那么直接判断该 beanInstance 是否为 FactoryBean 即可，默认情况下，显然不会走这条线。</p><p>接下来继续判断当前 beanFactory 中是否存在该 beanName 的定义，如果不存在，且当前 beanFactory 是 ConfigurableBeanFactory，那么就去父容器中检查这个 beanName 对应的 bean 是否是 isFactoryBean。</p><p>最后实在不行，就调用另外一个重载的 isFactoryBean 方法去判断，这个重载的方法逻辑就比较简单了，从 BeanDefinition 中获取到 Bean 的类型，然后判断是否是 FactoryBean 即可。</p><p>这就是判断一个 beanName 对应的 Bean 是否为 FactoryBean 的所有逻辑。</p><h3 id="2-2-getBean"><a href="#2-2-getBean" class="headerlink" title="2.2 getBean"></a>2.2 getBean</h3><p>另一方面就是 getBean 方法了，这个方法的执行可以分为两步。</p><p>再来回顾下 preInstantiateSingletons 方法中的如下逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> SmartFactoryBean&lt;?&gt; smartFactoryBean &amp;&amp; smartFactoryBean.isEagerInit()) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，无论是否提前初始化目标 Bean，都需要先初始化 FactoryBean，也就是自动加上 <code>&amp;</code> 前缀然后去调用 getBean 方法，FactoryBean 的初始化就和普通 Bean 的初始化流程一样，我这里就不重复了。</p><p>然后，如果是要提前初始化 Bean，则还会再调用一次 getBean 方法，这次调用不加 <code>&amp;</code> 前缀，所以这次调用最终就会触发到 FactoryBean 的 getObject 方法。</p><p>getBean 的调用最终会来到 AbstractBeanFactory#doGetBean 方法中，我们来简单看下这个方法的逻辑，这个方法比较长，我这里列出来跟我们相关的一部分：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">String beanName = transformedBeanName(name);</span><br><span class="line">Object beanInstance;</span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里首先会调用 transformedBeanName 方法对 bean 名称进行处理，处理之后的 bean 名称就不带 <code>&amp;</code> 了（2.1 小节已经介绍过），然后根据 bean 名称去单例池中获取 Bean 实例，如果是第一次来，也就是初始化 UserFactoryBean 的那一次，那次显然单例池中是没有东西的，那么那么就会进入到 Bean 的创建流程中，并在创建完成后，将 Bean 实例存入到单例池中（实际上存的是 UserFactoryBean 的实例）。</p><p>如果是第二次进来，由于上一次已经完成了 UserFactoryBean 的初始化了，第二次进来单例池中显然是有东西的，而且这个东西就是 UserFactoryBean 的实例，所以第二次进来之后，会进入到接下来的 if 分支中（第一次不会进入到该分支），在这个分支中，最终触发 getObject 方法的调用。</p><blockquote><p>大家注意，getObjectForBeanInstance 方法传入了两个 bean 名称参数，第一个 name 是没有去除 <code>&amp;</code> 的 beanName（可能包含 <code>&amp;</code> 前缀），第二个参数则是经过处理的 beanName，即去除了 <code>&amp;</code> 的 beanName。</p></blockquote><p>来看下 getObjectForBeanInstance 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getObjectForBeanInstance</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (beanInstance <span class="hljs-keyword">instanceof</span> NullBean) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mbd.isFactoryBean = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!(beanInstance <span class="hljs-keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">Object object = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mbd.isFactoryBean = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">boolean</span> synthetic = (mbd != <span class="hljs-keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体上来看，这里有四个 if 分支，我们分别来看。</p><p>第一个 if 分支主要是判断想要获取的 Bean 到底是不是一个 FactoryBean？BeanFactoryUtils.isFactoryDereference(name) 其实就是判断当前这个 name 是否以 <code>&amp;</code> 开始，如果是以 <code>&amp;</code> 开始，那就说明想要获取的就是 FactoryBean 实例，此时就检查 beanInstance 是否为 NullBean，是否为 FactoryBean，如果都检测没问题，那么就把 bean 直接返回即可。如果我们是想要从 Spring 容器中获取一个 FactoryBean 的实例，那么很明显就是走的这条线。</p><p>第二个 if 是检查 beanInstance 如果不是 FactoryBean 的实例，说明可能就是一个普通 Bean，那么就不需要额外处理，直接返回即可。</p><p>第三个 if 是标记 FactoryBean 的，这个没啥好说的。</p><p>第四个 if 分支则是将 beanInstance 转为 FactoryBean，然后合并一下 BeanDefinition，进而判断一下这个 Bean 是否是在内部使用（synthetic），最后调用 getObjectFromFactoryBean 方法去获取 Bean 对象，注意第三个参数是 <code>!synthetic</code>，这个参数表示这个类是否要使用 BeanPostProcessor 对其进行处理，只要这个 Bean 不是内部使用（synthetic=false），那么就会给其应用上 BeanPostProcessor。</p><p>继续来看 getObjectFromFactoryBean 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getObjectFromFactoryBean</span><span class="hljs-params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="hljs-keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">Object object = <span class="hljs-keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">Object alreadyThere = <span class="hljs-keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (alreadyThere != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">object = alreadyThere;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先调用 factory.isSingleton() 方法去判断这个 Bean 是否是单例模式，该方法就是我们第一小节和大家分析的方法。</p><p>如果是单例模式，则去单例池 factoryBeanObjectCache 中获取到 Bean 并返回即可，当然，单例池中可能并不存在这个 Bean，那么就调用 doGetObjectFromFactoryBean 方法进行加载，加载成功之后，再给其应用上 BeanPostProcessor，最后还要将加载的结果存入到单例池 factoryBeanObjectCache 中，方便下一次使用。</p><p>如果不是单例模式，那么就不去单例池中查找，直接调用 doGetObjectFromFactoryBean 方法去获取 Bean 实例即可，获取到之后，也根据 shouldPostProcess 参数为之应用 BeanPostProcessor。</p><p>所有的线索都指向了 doGetObjectFromFactoryBean，我们再来看这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">doGetObjectFromFactoryBean</span><span class="hljs-params">(FactoryBean&lt;?&gt; factory, String beanName)</span> <span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">Object object;</span><br><span class="line"><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">AccessControlContext acc = getAccessControlContext();</span><br><span class="line">object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">object = factory.getObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">object = <span class="hljs-keyword">new</span> NullBean();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了一些权限的判断（防止对代码块没有执行权限），当然无论是否有权限，最终都会调用到 factory.getObject() 方法，终于到终点啦~</p><p>拿到 object 之后，再做一个简单判断，如果 object 为 null，那么就创建一个 NullBean 并返回即可。</p><p>好啦，这就是 FactoryBean 的完整创建流程啦~</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，今天就和小伙伴们分享了 FactoryBean 和它的兄弟 SmartFactoryBean，其实无论是目标 Bean 还是 FactoryBean，一开始的处理流程都是相似的，分歧产生在 AbstractBeanFactory#doGetBean 方法中，从这个方法中是否获取到 beanInstance 实例开始，一个向东一个向西~</p><p>小伙伴们不妨 debug 走一遍流程哦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前松哥写过一篇文章，跟小伙伴们介绍了我们在面试中非常常见的一道面试题：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一道经典面试题：@Configuration 和 @Component 有何区别？</title>
    <link href="http://www.javaboy.org/2023/0829/spring-configuration-vs-component.html"/>
    <id>http://www.javaboy.org/2023/0829/spring-configuration-vs-component.html</id>
    <published>2023-08-29T09:19:45.000Z</published>
    <updated>2023-09-12T09:40:29.684Z</updated>
    
    <content type="html"><![CDATA[<p>关于 @Configuration 注解有一个特别经典的面试题：</p><a id="more"></a><ul><li>@Configuration 和 @Component 有什么区别？</li></ul><p>无论小伙伴们之前是否背过相关的面试题，今天这篇文章学完之后相信大家对这个问题都会有更深一层的理解，废话不多少，咱们开始分析。</p><h2 id="1-情景展现"><a href="#1-情景展现" class="headerlink" title="1. 情景展现"></a>1. 情景展现</h2><p>@Configuration 和 @Component 到底有何区别呢？我先通过如下一个案例，在不分析源码的情况下，小伙伴们先来直观感受一下这两个之间的区别。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig01</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig02</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，分别向 Spring 容器中注入两个 Bean，JavaConfig01 和 JavaConfig02，其中，JavaConfig01 上添加的是 @Configuration 注解而 JavaConfig02 上添加的则是 @Component 注解。</p><p>现在，在 XML 文件中配置包扫描：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> </span></span><br><span class="line"><span class="hljs-tag"><span class="hljs-attr">base-package</span>=<span class="hljs-string">"org.javaboy.demo.p6"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>最后，加载 XML 配置文件，初始化容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans_demo.xml"</span>);</span><br><span class="line">        JavaConfig01 config01 = ctx.getBean(JavaConfig01.class);</span><br><span class="line">        JavaConfig02 config02 = ctx.getBean(JavaConfig02.class);</span><br><span class="line">        System.out.println(<span class="hljs-string">"config01.getClass() = "</span> + config01.getClass());</span><br><span class="line">        System.out.println(<span class="hljs-string">"config02.getClass() = "</span> + config02.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印出来结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230819211920.png" alt></p><p>从上面这段代码中，我们可以得出来两个结论：</p><ol><li>@Configuration 注解也是 Spring 组件注解的一种，通过普通的 Bean 扫描也可以扫描到 @Configuration。</li><li>@Configuration 注解注册到 Spring 中的 Bean 是一个 CGLIB 代理的 Bean，而不是原始 Bean，这一点和 @Component 不一样，@Component 注册到 Spring 容器中的还是原始 Bean。</li></ol><p>一个问题来了，@Configuration 标记的类为什么注册到 Spring 容器之后就变成了代理对象了呢？闭着眼睛大家也能猜到，肯定是为了通过代理来增强其功能，那么究竟增强什么功能呢？接下来我们通过源码分析来和小伙伴们梳理一下这里的条条框框。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>要理解这个问题，首先得结合我们前面的文章<a href="https://mp.weixin.qq.com/s/DrOp6wPYbUhfJFyhSmyo4g" target="_blank" rel="noopener">@Configuration 注解的 Full 模式和 Lite 模式！</a>，在该文中，松哥提到了 @Configuration 模式分为了 Full 模式和 Lite 模式，所以，对于 @Configuration 注解的处理，在加载的时候，就需要首先区分出来是 Full 模式还是 Lite 模式。</p><p>负责 @Configuration 注解的是 ConfigurationClassPostProcessor，这个处理器是一个 BeanFactoryPostProcessor，BeanFactoryPostProcessor 的作用就是在 Bean 定义的时候，通过修改 BeanDefinition 来重新定义 Bean 的行为，这个松哥之前有过专门的文章介绍，不熟悉的小伙伴可以先看看这里：</p><ul><li><a href="https://mp.weixin.qq.com/s/r3rnVhU8vr58Cw__UWOVLA" target="_blank" rel="noopener">Spring 中 BeanFactory 和 FactoryBean 有何区别？</a></li></ul><p>同时，ConfigurationClassPostProcessor 也是 BeanDefinitionRegistryPostProcessor 的实例，BeanDefinitionRegistryPostProcessor 是干嘛的呢？</p><p>BeanDefinitionRegistryPostProcessor 是 Spring 框架中的一个接口，它的作用是在应用程序上下文启动时，对 BeanDefinitionRegistry 进行后置处理。具体来说，BeanDefinitionRegistryPostProcessor 可以用于修改或扩展应用程序上下文中的 BeanDefinition，即在 Bean 实例化之前对 BeanDefinition 进行修改。它可以添加、删除或修改 BeanDefinition 的属性，甚至可以动态地注册新的 BeanDefinition。通过实现 BeanDefinitionRegistryPostProcessor 接口，我们可以在 Spring 容器启动过程中干预 Bean 的定义，以满足特定的需求。这使得我们可以在应用程序上下文加载之前对 Bean 进行一些自定义的操作，例如动态注册 Bean 或者修改 Bean 的属性。<strong>需要注意的是，BeanDefinitionRegistryPostProcessor 在 BeanFactoryPostProcessor 之前被调用，因此它可以影响到 BeanFactoryPostProcessor 的行为。</strong></p><p>BeanFactoryPostProcessor 中的方法是 postProcessBeanFactory，而 BeanDefinitionRegistryPostProcessor 中的方法是 postProcessBeanDefinitionRegistry，根据前面的介绍，postProcessBeanDefinitionRegistry 方法将在 postProcessBeanFactory 方法之前执行。</p><p>所以，我们就从 postProcessBeanDefinitionRegistry 方法开始看起吧～</p><h3 id="2-1-postProcessBeanDefinitionRegistry"><a href="#2-1-postProcessBeanDefinitionRegistry" class="headerlink" title="2.1 postProcessBeanDefinitionRegistry"></a>2.1 postProcessBeanDefinitionRegistry</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方面前面的代码主要是为了确保该方法执行一次，我们就不多说了。关键在于最后的 processConfigBeanDefinitions 方法，这个方法就是用来决策配置类是 Full 模式还是 Lite 模式的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Bean definition has already been processed as a configuration class: "</span> + beanDef);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我省略了其他代码，大家看，这个方法中，会首先根据 beanName 取出来 BeanDefinition，然后判断 BeanDefinition 中是否包含 <code>ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE</code> 属性，这个属性上记录了当前配置类是 Full 模式还是 Lite 模式，不同模式将来的处理方案肯定也是不同的。如果是第一次处理，显然 BeanDefinition 中并不包含该属性，因此就会进入到 ConfigurationClassUtils.checkConfigurationClassCandidate 方法中，正是在该方法中，判断当前配置类是 Full 模式还是 Lite 模式，并进行标记，checkConfigurationClassCandidate 方法的逻辑也挺长的，我这里挑出来跟我们感兴趣的部分：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkConfigurationClassCandidate</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//省略。。。</span></span><br><span class="line">Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line"><span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="hljs-string">"proxyBeanMethods"</span>))) &#123;</span><br><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config != <span class="hljs-keyword">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Full 模式情况很简单，就是如果配置类上存在 @Configuration 注解，并且该注解的 proxyBeanMethods 属性值不为 false，那么就是 Full 模式，这个跟松哥在 <a href="https://mp.weixin.qq.com/s/DrOp6wPYbUhfJFyhSmyo4g" target="_blank" rel="noopener">@Configuration 注解的 Full 模式和 Lite 模式！</a>一文中的介绍是一致的。</p><p>Lite 模式就情况多一些，首先 <code>config!=null</code> 就是说现在也存在 @Configuration 注解，但是 proxyBeanMethods 属性值此时为 false，那么就是 Lite 模式（proxyBeanMethods 属性值为 true 的话就进入到 if 分支中了）。</p><p>另外就是在 isConfigurationCandidate 方法中有一些判断逻辑去锁定是否为 Lite 模式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConfigurationCandidate</span><span class="hljs-params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Do not consider an interface or an annotation...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (metadata.isInterface()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Any of the typical annotations found?</span></span><br><span class="line"><span class="hljs-keyword">for</span> (String indicator : candidateIndicators) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (metadata.isAnnotated(indicator)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Finally, let's look for @Bean methods...</span></span><br><span class="line"><span class="hljs-keyword">return</span> hasBeanMethods(metadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的判断逻辑是这样：</p><ol><li>首先注解要是标记的是接口，那就不能算是 Lite 模式。</li><li>遍历 candidateIndicators，判断当前类上是否包含这个 Set 集合中的注解，这个 Set 集合中的注解有四个，分别是 @Component、@ComponentScan、@Import、@ImportResource 四个，也就是，如果类上标记的是这四个注解的话，那么也按照 Lite 模式处理。</li><li>判断当前类中是否有 @Bean 标记的方法，如果有则按照 Lite 模式处理，否则就不是 Lite 模式。</li></ol><p>如果小伙伴们看过松哥之前的 <a href="https://mp.weixin.qq.com/s/DrOp6wPYbUhfJFyhSmyo4g" target="_blank" rel="noopener">@Configuration 注解的 Full 模式和 Lite 模式！</a>一文，那么上面这些代码应该都很好理解，跟松哥在该文章中的介绍都是一致的。</p><p>好了，经过上面的处理，现在就已经标 BeanDefinition 中标记了这个配置类到底是 Full 模式还是 Lite 模式了。</p><h3 id="2-2-postProcessBeanFactory"><a href="#2-2-postProcessBeanFactory" class="headerlink" title="2.2 postProcessBeanFactory"></a>2.2 postProcessBeanFactory</h3><p>接下来我们就来看 postProcessBeanFactory 方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Prepare the Configuration classes for servicing bean requests at runtime</span></span><br><span class="line"><span class="hljs-comment"> * by replacing them with CGLIB-enhanced subclasses.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"postProcessBeanFactory already called on this post-processor against "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="hljs-comment">// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span></span><br><span class="line"><span class="hljs-comment">// Simply call processConfigurationClasses lazily at this point then.</span></span><br><span class="line">processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">enhanceConfigurationClasses(beanFactory);</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先大家看一下这个方法的注释，注释说的很明确了，将 Configuration 类通过 CGLIB 进行增强，以便在运行时较好的处理 Bean 请求。</p><p>这个方法中还会再次确认一下 postProcessBeanDefinitionRegistry 方法已经处理过了，如果没有处理的话，则会在该方法中调用 processConfigBeanDefinitions 去确认 Bean 使用的是哪种模式。</p><p>该方法的关键在于 enhanceConfigurationClasses，这个就是用来通过动态代理增强配置类的，当然这个方法也是比较长的，我这里列出来一些关键的逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enhanceConfigurationClasses</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">StartupStep enhanceConfigClasses = <span class="hljs-keyword">this</span>.applicationStartup.start(<span class="hljs-string">"spring.context.config-classes.enhance"</span>);</span><br><span class="line">Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">Object configClassAttr = beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE);</span><br><span class="line"><span class="hljs-keyword">if</span> ((configClassAttr != <span class="hljs-keyword">null</span> || methodMetadata != <span class="hljs-keyword">null</span>) &amp;&amp;</span><br><span class="line">(beanDef <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition abd) &amp;&amp; !abd.hasBeanClass()) &#123;</span><br><span class="line"><span class="hljs-comment">// Configuration class (full or lite) or a configuration-derived @Bean method</span></span><br><span class="line"><span class="hljs-comment">// -&gt; eagerly resolve bean class at this point, unless it's a 'lite' configuration</span></span><br><span class="line"><span class="hljs-comment">// or component class without @Bean methods.</span></span><br><span class="line"><span class="hljs-keyword">boolean</span> liteConfigurationCandidateWithoutBeanMethods =</span><br><span class="line">(ConfigurationClassUtils.CONFIGURATION_CLASS_LITE.equals(configClassAttr) &amp;&amp;</span><br><span class="line">annotationMetadata != <span class="hljs-keyword">null</span> &amp;&amp; !ConfigurationClassUtils.hasBeanMethods(annotationMetadata));</span><br><span class="line"><span class="hljs-keyword">if</span> (!liteConfigurationCandidateWithoutBeanMethods) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">abd.resolveBeanClass(<span class="hljs-keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) &#123;</span><br><span class="line">configBeanDefs.put(beanName, abd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConfigurationClassEnhancer enhancer = <span class="hljs-keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line"><span class="hljs-comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line"><span class="hljs-comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">Class&lt;?&gt; configClass = beanDef.getBeanClass();</span><br><span class="line">Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="hljs-keyword">this</span>.beanClassLoader);</span><br><span class="line"><span class="hljs-keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">beanDef.setBeanClass(enhancedClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhanceConfigClasses.tag(<span class="hljs-string">"classCount"</span>, () -&gt; String.valueOf(configBeanDefs.keySet().size())).end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的逻辑，我整体上将之分为两部分：</p><p>第一部分就是先找到 Full 模式的配置类的名称，存入到 configBeanDefs 集合中。</p><p>具体寻找的逻辑就是根据配置类的模式去寻找，如果配置类是 Full 模式，就将之存入到 configBeanDefs 中。如果配置类是 Lite 模式，且里边没有 @Bean 标记的方法，那就说明这可能并不是一个配置类，就是一个普通 Bean，那么就在这里加载类就行了。</p><p>第二步则是遍历 configBeanDefs 集合，增强配置类。</p><p>这个如果大家了解 CGLIB 动态代理的话，这个就很好懂了，关于 CGLIB 动态代理松哥这里不啰嗦，最近更新的 Spring 源码视频中都有详细讲到。那么这里主要是通过 enhancer.enhance 方法来生成代理类的，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (EnhancedConfiguration.class.isAssignableFrom(configClass)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> configClass;</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line"><span class="hljs-keyword">return</span> enhancedClass;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Enhancer <span class="hljs-title">newEnhancer</span><span class="hljs-params">(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();</span><br><span class="line">enhancer.setSuperclass(configSuperClass);</span><br><span class="line">enhancer.setInterfaces(<span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">enhancer.setUseFactory(<span class="hljs-keyword">false</span>);</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setAttemptLoad(<span class="hljs-keyword">true</span>);</span><br><span class="line">enhancer.setStrategy(<span class="hljs-keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line"><span class="hljs-keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，增强类中的 setCallbackFilter 是 CALLBACK_FILTER，这个里边包含了几个方法拦截器，跟我们相关的是 BeanMethodInterceptor，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span>, <span class="hljs-title">ConditionalCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">MethodProxy cglibMethodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);</span><br><span class="line">String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);</span><br><span class="line"><span class="hljs-comment">// Determine whether this bean is a scoped-proxy</span></span><br><span class="line"><span class="hljs-keyword">if</span> (BeanAnnotationHelper.isScopedProxy(beanMethod)) &#123;</span><br><span class="line">String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123;</span><br><span class="line">beanName = scopedBeanName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// To handle the case of an inter-bean method reference, we must explicitly check the</span></span><br><span class="line"><span class="hljs-comment">// container for already cached instances.</span></span><br><span class="line"><span class="hljs-comment">// First, check to see if the requested bean is a FactoryBean. If so, create a subclass</span></span><br><span class="line"><span class="hljs-comment">// proxy that intercepts calls to getObject() and returns any cached bean instance.</span></span><br><span class="line"><span class="hljs-comment">// This ensures that the semantics of calling a FactoryBean from within @Bean methods</span></span><br><span class="line"><span class="hljs-comment">// is the same as that of referring to a FactoryBean within XML. See SPR-6602.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp;</span><br><span class="line">factoryContainsBean(beanFactory, beanName)) &#123;</span><br><span class="line">Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (factoryBean <span class="hljs-keyword">instanceof</span> ScopedProxyFactoryBean) &#123;</span><br><span class="line"><span class="hljs-comment">// Scoped proxy factory beans are a special case and should not be further proxied</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// It is a candidate FactoryBean - go ahead with enhancement</span></span><br><span class="line"><span class="hljs-keyword">return</span> enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写过 CGLIB 动态代理的小伙伴都知道这里 intercept 方法的含义，这就是真正的拦截方法了，也就是说，如果我们的配置类是 Full 模式的话，那么将来调用 @Bean 注解标记的方法的时候，调用的其实是这里的 intercept 方法。</p><p>上面方法，首先会判断当前代理是否为作用域代理，我们这里当然不是。</p><p>接下来判断请求的 Bean 是否是一个 FactoryBean，如果是，则需要去代理其 getObject 方法，当执行到 getObject 方法的时候，就去 Spring 容器中查找需要的 Bean，当然，我们这里也不属于这种情况。</p><p>接下来判断当前正在执行的方法，是否为容器中正在调用的工厂方法。</p><p>例如我有如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setDog(dog());</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Dog <span class="hljs-title">dog</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如果是直接调用 dog() 方法，则 isCurrentlyInvokedFactoryMethod 返回 true，如果是在 user() 方法中调用的 dog() 方法，则 isCurrentlyInvokedFactoryMethod 返回 false。</p><p>当 isCurrentlyInvokedFactoryMethod 返回 true 的时候，就执行 invokeSuper 方法，也就是真正的触发 dog() 方法的执行。</p><p>当 isCurrentlyInvokedFactoryMethod 返回 false 的时候，则执行下面的 resolveBeanReference 方法，这个方法会先去 Spring 容器中查找相应的 Bean，如果 Spring 容器中不存在该 Bean，则会触发 Bean 的创建流程。</p><p>现在，小伙伴们应该明白了为什么 Full 模式下，调用 @Bean 注解标记的方法并不会导致 Bean 的重复创建了吧～</p><p>好啦，本文结合上文 <a href="https://mp.weixin.qq.com/s/DrOp6wPYbUhfJFyhSmyo4g" target="_blank" rel="noopener">@Configuration 注解的 Full 模式和 Lite 模式！</a> 一起食用效果更佳哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 @Configuration 注解有一个特别经典的面试题：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>@Configuration 注解的 Full 模式和 Lite 模式！</title>
    <link href="http://www.javaboy.org/2023/0828/spring-configuration-full-lite.html"/>
    <id>http://www.javaboy.org/2023/0828/spring-configuration-full-lite.html</id>
    <published>2023-08-28T09:19:32.000Z</published>
    <updated>2023-09-12T09:40:26.473Z</updated>
    
    <content type="html"><![CDATA[<p>@Configuration 注解相信各位小伙伴经常会用到，但是大家知道吗，这个注解有两种不同的模式，一种叫做 Full 模式，另外一种则叫做 Lite 模式。</p><a id="more"></a><p><strong>准确来说，Full 模式和 Lite 模式其实 Spring 容器在处理 Bean 时的两种不同行为。</strong></p><p>这两种不同的模式在使用时候的表现完全不同，今天松哥就来和各位小伙伴捋一捋这两种模式。</p><h2 id="1-概念梳理"><a href="#1-概念梳理" class="headerlink" title="1. 概念梳理"></a>1. 概念梳理</h2><p>首先我们先来看一下 Spring 官方文档中对 Full 模式和 Lite 模式的一个介绍：</p><p><img src="http://img.itboyhub.com/2022/08/20230819113746.png" alt></p><p>截图来自：<a href="https://docs.spring.io/spring-framework/reference/core/beans/java/basic-concepts.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/reference/core/beans/java/basic-concepts.html</a></p><p>这个文档主要讲了这样几件事情：</p><ol><li>我们可以通过在一个方法上添加 @Bean 注解，进而将该方法的返回值暴露给 Spring 容器，在这种场景下，@Bean 注解实际上就是一种通用的工厂方法机制。</li><li>当一个添加了 @Bean 注解的方法位于一个没有添加 @Configuration 注解的类里边时，那么这个添加了 @Bean 注解的方法在处理时就会按照 Lite 模式来处理。</li><li>当一个 Bean 被声明在添加了 @Component 注解的类中，那么会按照 Lite 模式来处理。</li><li>当一个 Bean 被声明在一个普通的类中时（plain old class），按照 Lite 模式来处理（这一点感觉和第二点差不多）。</li><li>在 Lite 模式下，@Bean 注解标记的方法最终不会被 CGLIB 进行代理，就是一个普通的工厂方法，因此，在 @Bean 标记的方法中，不能调用其他 @Bean 注解标记的方法，如果有需要，可以通过方法参数注入自己所需要的 Bean。</li><li>由于 Lite 模式下并不会使用 CGLIB，因此 @Bean 标记的方法可以是 final 类型的。</li><li>在大多数场景下，我们在一个 @Configuration 注解标记的类中，使用 @Bean 注解向 Spring 容器注册一个 Bean，都是 Full 模式。</li></ol><p>官网文档的介绍还是有些抽象，接下来松哥通过具体的案例来和大家演示 Full 模式和 Lite 模式的差别。</p><h2 id="2-Full-模式"><a href="#2-Full-模式" class="headerlink" title="2. Full 模式"></a>2. Full 模式</h2><p>先看 Full 模式，中文也可以称之为 <code>完整</code> 模式，我们平时使用时，在一个配置类上添加 @Configuration 注解，且不添加任何额外属性，这就是 Full 模式了。</p><p>Full 模式最大的特点是会给配置类通过 CGLIB 生成一个代理，所有被 @Bean 注解标记的方法将来都是通过代理方法进行调用。</p><p>假设我有如下配置类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们去 Spring 容器获取这个配置类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">        JavaConfig config = ctx.getBean(JavaConfig.class);</span><br><span class="line">        System.out.println(<span class="hljs-string">"config.getClass() = "</span> + config.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230819124226.png" alt></p><p>大家看到，最终从 Spring 容器中拿到的 JavaConfig 实例并不是原始的 JavaConfig 对象，而是一个被代理的 JavaConfig 对象。</p><p>为什么要代理呢？肯定是为了实现某些功能。</p><p>大家看下面这个案例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setDog(dog());</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Dog <span class="hljs-title">dog</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Full 模式下，在 user() 方法中调用 dog() 方法的时候，调用的是一个代理对象的 dog 方法，在这个代理对象的 dog 方法中，会首先去检查 Spring 容器中是否存在 Dog 对象，如果存在，则直接使用 Spring 容器中的 dog 对象，就不会真正去执行 dog 方法而获取到一个新的 dog 对象了，如果 Spring 容器中不存在 dog 对象，才会创建新的 dog 对象出来。</p><p><strong>一言以蔽之，在 Full 模式下，user 中的 dog 对象和 dog 方法注册到 Spring 容器的 dog 对象是同一个。</strong></p><p>在 Full 模式下，由于要给当前类生成代理，然后去代理 @Bean 注解标记的方法，因此，这些 @Bean 注解标记的方法不能是 final 或者 private 类型的，因为 final 或者 private 类型的方法无法被重写，也就没法生成代理对象，如果添加了 final 或者 private 修饰符，那么会抛出如下异常：</p><p><img src="http://img.itboyhub.com/2022/08/20230819125408.png" alt></p><h2 id="3-Lite-模式"><a href="#3-Lite-模式" class="headerlink" title="3. Lite 模式"></a>3. Lite 模式</h2><p>再来看 Lite 模式，这种模式可以认为是一种精简模式。</p><p>怎么开启呢？我们可以去除配置类上的 @Configuration 注解，或者去除之后添加 @Component 注解，又或者使用 @ComponentScan、@ImportResource、@Import 等注解标记类，那么最终都是 Lite 模式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setDog(dog());</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Dog <span class="hljs-title">dog</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就是 Lite 模式，现在我们去 Spring 容器中获取这个配置类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(JavaConfig.class);</span><br><span class="line">        JavaConfig config = ctx.getBean(JavaConfig.class);</span><br><span class="line">        System.out.println(<span class="hljs-string">"config.getClass() = "</span> + config.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230819130451.png" alt></p><p>大家看到，我们从 Spring 容器中拿到的就是原始的对象，而不是一个被代理过的对象。因此：</p><ol><li>由于 @Bean 注解标记的方法没有被代理，因此，该方法可以是 final 也可以是 private，运行时都不会报错。</li><li>由于 @Bean 方法没有被代理，因此在 user 方法中调用 dog 方法的时候，就直接调用了，这就导致 user 中的 dog 和最终 dog 方法注册到 Spring 容器中的 dog 不是同一个。</li></ol><p>针对第二点，如果想要确保 user 中的 dog 和 Spring 容器中的 dog 是同一个，那么可以通过参数将所需要的对象注入进来，类似下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> User <span class="hljs-title">user</span><span class="hljs-params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setDog(dog);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Dog <span class="hljs-title">dog</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Spring 容器调用 user 方法初始化 User 对象时，发现该方法还有参数，因此会去容器中查找这个参数，找到了直接使用。</p><p>另外，我们也可以在类上添加 @Configuration 注解，但是通过修改属性值来启用 Lite 模式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> User <span class="hljs-title">user</span><span class="hljs-params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setDog(dog);</span><br><span class="line">        <span class="hljs-keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Dog <span class="hljs-title">dog</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了 <code>proxyBeanMethods</code> 属性为 false，那么也就是 Lite 模式了，其实我们从属性名称上也能看出来端倪：是否代理 @Bean 注解标记的方法。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>总结一下：</p><ol><li>Lite 模式下，配置类中的方法就是普通方法，可以是 final 类型，也可以是 private。</li><li>Lite 模式下，不需要通过 CGLIB 生成动态代理类，所以启动速度会快一些。</li><li>Lite 模式下，一个 @Bean 方法调用另外一个 @Bean 方法，会导致同一个 Bean 被初始化两次。</li><li>Full 模式下，会给配置类生成一个动态代理类，配置类中的所有方法都将被动态代理，因此配置类中的方法不能是 final 或者 private 的。</li><li>Full 模式下，一个 @Bean 方法调用另外一个 @Bean 方法，动态代理方法会先去容器中检查是否存在该 Bean，如果存在，则直接使用容器中的 Bean，否则才会去创建新的对象。</li></ol><p><strong>日常开发中，我们使用较多的是 Full 模式。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@Configuration 注解相信各位小伙伴经常会用到，但是大家知道吗，这个注解有两种不同的模式，一种叫做 Full 模式，另外一种则叫做 Lite 模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>似懂非懂的 AspectJ</title>
    <link href="http://www.javaboy.org/2023/0825/spring-aspectj.html"/>
    <id>http://www.javaboy.org/2023/0825/spring-aspectj.html</id>
    <published>2023-08-25T09:19:18.000Z</published>
    <updated>2023-09-12T09:41:21.300Z</updated>
    
    <content type="html"><![CDATA[<p>今天想和小伙伴们聊一下我们在使用 Spring AOP 时，一个非常常见的概念 AspectJ。</p><a id="more"></a><h2 id="1-关于代理"><a href="#1-关于代理" class="headerlink" title="1. 关于代理"></a>1. 关于代理</h2><p>小伙伴们知道，Java 23 种设计模式中有一种模式叫做代理模式，这种代理我们可以将之称为静态代理，Spring AOP 我们常说是一种动态代理，那么这两种代理的区别在哪里呢？</p><h3 id="1-1-静态代理"><a href="#1-1-静态代理" class="headerlink" title="1.1 静态代理"></a>1.1 静态代理</h3><p>这种代理在我们日常生活中其实非常常见，例如房屋中介就相当于是一个代理，当房东需要出租房子的时候，需要发布广告、寻找客户、清理房间。。。由于比较麻烦，因此房东可以将租房子这件事情委托给中间代理去做。这就是一个静态代理。</p><p>我通过一个简单的代码来演示一下，首先我们有一个租房的接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>房东实现了该接口，表示想要出租房屋：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Landlord</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span></span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"房屋出租"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中介作为中间代理，也实现了该接口，同时代理了房东，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseAgent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Landlord landlord;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HouseAgent</span><span class="hljs-params">(Landlord landlord)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.landlord = landlord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HouseAgent</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rent</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        publishAd();</span><br><span class="line">        landlord.rent();</span><br><span class="line">        agencyFee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishAd</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"发布招租广告"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">agencyFee</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"收取中介费"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，中介的 rent 方法中，除了调用房东的 rent 方法之外，还调用了 publishAd 和 agencyFee 两个方法。</p><p>接下来客户租房，只需要和代理打交道就可以了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Landlord landlord = <span class="hljs-keyword">new</span> Landlord();</span><br><span class="line">        HouseAgent houseAgent = <span class="hljs-keyword">new</span> HouseAgent(landlord);</span><br><span class="line">        houseAgent.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的代理模式。无论大家是否有接触过 Java 23 种设计模式，上面这段代码应该都很好理解。</p><p>这是静态代理。</p><h3 id="1-2-动态代理"><a href="#1-2-动态代理" class="headerlink" title="1.2 动态代理"></a>1.2 动态代理</h3><p>动态代理讲究在不改变原类原方法的情况下，增强目标方法的功能，例如，大家平时使用的 Spring 事务功能，在不改变目标方法的情况下，就可以通过动态代理为方法添加事务处理能力。再比如松哥在 TienChin 项目中所讲的日志处理、接口幂等性处理、多数据源处理等，都是动态代理能力的体现：</p><p><img src="http://img.itboyhub.com/2022/08/20230814192352.png" alt></p><p>从实现原理上，我们又可以将动态代理划分为两大类：</p><ul><li>编译时增强。</li><li>运行时增强。</li></ul><h4 id="1-2-1-编译时增强"><a href="#1-2-1-编译时增强" class="headerlink" title="1.2.1 编译时增强"></a>1.2.1 编译时增强</h4><p>编译时增强，这种有点类似于 Lombok 的感觉，就是在编译阶段就直接生成了代理类，将来运行的时候，就直接运行这个编译生成的代理类，AspectJ 就是这样一种编译时增强的工具。</p><p>AspectJ 全称是 Eclipse AspectJ， 其官网地址是： <code>http://www.eclipse.org/aspectj</code>，截止到本文写作时，目前最新版本为：1.9.7。</p><p>从官网我们可以看到 AspectJ 的定位：</p><ol><li>基于 Java 语言的面向切面编程语言。</li><li>兼容 Java。</li><li>易学易用。</li></ol><p>使用 AspectJ 时需要使用专门的编译器 ajc。</p><h4 id="1-2-2-运行时增强"><a href="#1-2-2-运行时增强" class="headerlink" title="1.2.2 运行时增强"></a>1.2.2 运行时增强</h4><p>运行时增强则是指借助于 JDK 动态代理或者 CGLIB 动态代理等，在内存中临时生成 AOP 动态代理类，我们在 Spring AOP 中常说的动态代理，一般是指这种运行时增强。</p><p>我们平日开发写的 Spring AOP，基本上都是属于这一类。</p><h2 id="2-AspectJ-和-Spring-AOP"><a href="#2-AspectJ-和-Spring-AOP" class="headerlink" title="2. AspectJ 和 Spring AOP"></a>2. AspectJ 和 Spring AOP</h2><p>经过前面的介绍，相信大家已经明白了 AspectJ 其实也是 AOP 的一种实现，只不过它是编译时增强。</p><p>接下来，松哥再通过三个具体的案例，来和小伙伴们演示编译时增强和运行时增强。</p><h3 id="2-1-AspectJ"><a href="#2-1-AspectJ" class="headerlink" title="2.1 AspectJ"></a>2.1 AspectJ</h3><p>首先，在 IDEA 中想要运行 AspectJ，需要先安装 AspectJ 插件，就是下面这个：</p><p><img src="http://img.itboyhub.com/2022/08/20230814220355.png" alt></p><p>安装好之后，我们需要在 IDEA 中配置一下，使用 ajc 编译器代替 javac（这个是针对当前项目的设置，所以可以放心修改）：</p><p><img src="http://img.itboyhub.com/2022/08/20230814220912.png" alt></p><p>有如下几个需要修改的点：</p><ol><li>首先修改编译器为 ajc。</li><li>将使用的 Java 版本改为 8，这个一共有两个地方需要修改。</li><li>设置 aspectjtools.jar 的位置，这个 jar 包需要自己提前准备好，可以从 Maven 官网下载，然后在这里配置 jar 的路径，配置完成之后，点击 test 按钮进行测试，测试成功就会弹出来图中的弹框。</li></ol><p>对于第 3 步所需要的 jar，也可以在项目的 Maven 中添加如下依赖，自动下载，下载到本地仓库之后，再删除掉 pom.xml 中的配置即可：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.7.M3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，开发环境就准备好了。</p><p>接下来，假设我有一个银行转帐的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transferMoney</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"转账操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想给这个方法添加事务，那么我就新建一个 Aspect，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> aspect TxAspect &#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">()</span>:<span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">void</span> MoneyService.transferMoney()</span>)</span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"开启事务"</span>);</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            proceed();</span><br><span class="line">            System.out.println(<span class="hljs-string">"提交事务事务"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"回滚事务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 AspectJ 的语法，跟 Java 有点像，但是不太一样。需要注意的是，这个 TxAspect 不是一个 Java 类，它的后缀是 <code>.aj</code>。</p><p>proceed 表示继续执行目标方法，前后逻辑比较简单，我就不多说了。</p><p>最后，我们去运行转账服务：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MoneyService moneyService = <span class="hljs-keyword">new</span> MoneyService();</span><br><span class="line">        moneyService.transferMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230814222244.png" alt></p><p>这就是一个静态代理。</p><p>为什么这么说呢？我们通过 IDEA 来查看一下 TxAspect 编译之后的结果：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Aspect</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxAspect</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            ajc$postClinit();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Throwable var1) &#123;</span><br><span class="line">            ajc$initFailureCause = var1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TxAspect</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Around</span>(</span><br><span class="line">        value = <span class="hljs-string">"call(void MoneyService.transferMoney())"</span>,</span><br><span class="line">        argNames = <span class="hljs-string">"ajc$aroundClosure"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> ajc$around$org_javaboy_demo_p2_TxAspect$<span class="hljs-number">1</span>$<span class="hljs-number">3</span>b99afea(AroundClosure ajc$aroundClosure) &#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"开启事务"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            ajc$around$org_javaboy_demo_p2_TxAspect$<span class="hljs-number">1</span>$<span class="hljs-number">3</span>b99afeaproceed(ajc$aroundClosure);</span><br><span class="line">            System.out.println(<span class="hljs-string">"提交事务事务"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception var2) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"回滚事务"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TxAspect <span class="hljs-title">aspectOf</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (ajc$perSingletonInstance == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoAspectBoundException(<span class="hljs-string">"org_javaboy_demo_p2_TxAspect"</span>, ajc$initFailureCause);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> ajc$perSingletonInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAspect</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ajc$perSingletonInstance != <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一下编译之后的启动类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MoneyService moneyService = <span class="hljs-keyword">new</span> MoneyService();</span><br><span class="line">        transferMoney_aroundBody1$advice(moneyService, TxAspect.aspectOf(), (AroundClosure)<span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，都是修改后的内容了。</p><p>所以说 AspectJ 的作用就有点类似于 Lombok，直接在编译时期将我们的代码改了，这就是编译时增强。</p><h3 id="2-2-Spring-AOP"><a href="#2-2-Spring-AOP" class="headerlink" title="2.2 Spring AOP"></a>2.2 Spring AOP</h3><p>Spring AOP 在开发的时候，其实也使用了 AspectJ 中的注解，像我们平时使用的 @Aspect、@Around、@Pointcut 等，都是 AspectJ 里边提供的，但是 Spring AOP 并未借鉴 AspectJ 的编译时增强，Spring AOP 没有使用 AspectJ 的编译器和织入器，Spring AOP 还是使用了运行时增强。</p><p>运行时增强可以利用 JDK 动态代理或者 CGLIB 动态代理来实现。我分别来演示。</p><h4 id="2-2-1-JDK-动态代理"><a href="#2-2-1-JDK-动态代理" class="headerlink" title="2.2.1 JDK 动态代理"></a>2.2.1 JDK 动态代理</h4><p>JDK 动态代理有一个要求，就是被代理的对象需要有接口，没有接口不行，CGLIB 动态代理则无此要求。</p><p>假设我现在有一个计算器接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口有一个实现类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICalculator</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a + <span class="hljs-string">"+"</span> + b + <span class="hljs-string">"="</span> + (a + b));</span><br><span class="line">        <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我想通过动态代理实现统计该接口的执行时间功能，JDK 动态代理如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CalculatorImpl calculator = <span class="hljs-keyword">new</span> CalculatorImpl();</span><br><span class="line">        ICalculator proxyInstance = (ICalculator) Proxy.newProxyInstance(Demo02.class.getClassLoader(), <span class="hljs-keyword">new</span> Class[]&#123;ICalculator.class&#125;, <span class="hljs-keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">                Object invoke = method.invoke(calculator, args);</span><br><span class="line">                <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">                System.out.println(method.getName() + <span class="hljs-string">" 方法执行耗时 "</span> + (endTime - startTime) + <span class="hljs-string">" 毫秒"</span>);</span><br><span class="line">                <span class="hljs-keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxyInstance.add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要任何额外依赖，都是 JDK 自带的能力：</p><ol><li>Proxy.newProxyInstance 方法表示要生成一个动态代理对象。</li><li>newProxyInstance 方法有三个参数，第一个是一个类加载器，第二个参数是一个被代理的对象所实现的接口，第三个则是具体的代理逻辑。</li><li>在 InvocationHandler 中，有一个 invoke 方法，该方法有三个参数，分别表示当前代理对象，被拦截下来的方法以及方法的参数，我们在该方法中可以统计被拦截方法的执行时间，通过方式执行被拦截下来的目标方法。</li><li>最终，第一步的方法返回了一个代理对象，执行该代理对象，就有代理的效果了。</li></ol><p>上面这个案例就是一个 JDK 动态代理。这是一种运行时增强，在编译阶段并未修改我们的代码。</p><h4 id="2-2-2-CGLIB-动态代理"><a href="#2-2-2-CGLIB-动态代理" class="headerlink" title="2.2.2 CGLIB 动态代理"></a>2.2.2 CGLIB 动态代理</h4><p>从 SpringBoot2 开始，AOP 默认使用的动态代理就是 CGLIB 动态代理了，相比于 JDK 动态代理，CGLIB 动态代理支持代理一个类。</p><p>使用 CGLIB 动态代理，需要首先添加依赖，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设我有一个计算器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a + <span class="hljs-string">"+"</span> + b + <span class="hljs-string">"="</span> + (a + b));</span><br><span class="line">        <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家注意，这个计算器就是一个实现类，没有接口。</p><p>现在，我想统计这个计算器方法的执行时间，首先，我添加一个方法执行的拦截器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculatorInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(method.getName() + <span class="hljs-string">" 方法执行耗时 "</span> + (endTime - startTime) + <span class="hljs-string">" 毫秒"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当把代理方法拦截下来之后，额外要做的事情就在 intercept 方法中完成。通过执行 <code>methodProxy.invokeSuper</code> 可以调用到代理方法。</p><p>最后，配置 CGLIB，为方法配置增强：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Calculator.class);</span><br><span class="line">        enhancer.setCallback(<span class="hljs-keyword">new</span> CalculatorInterceptor());</span><br><span class="line">        Calculator calculator = (Calculator) enhancer.create();</span><br><span class="line">        calculator.add(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就是创建了字节增强器，为生成的代理对象配置 superClass，然后设置拦截下来之后的回调函数就行了，最后通过 create 方法获取到一个代理对象。</p><p>这就是 CGLIB 动态代理。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>经过上面的介绍，现在大家应该搞明白了静态代理、编译时增强的动态代理和运行时增强的动态代理了吧～</p><p>那么我们在项目中到底该如何选择呢？</p><p>先来说 AspectJ 的几个优势吧。</p><ol><li>Spring AOP 由于要生成动态代理类，因此，对于一些 static 或者 final 修饰的方法，是无法代理的，因为这些方法是无法被重写的，final 修饰的类也无法被继承。但是，AspectJ 由于不需要动态生成代理类，一切都是编译时完成的，因此，这个问题在 AspectJ 中天然的就被解决了。</li><li>Spring AOP 有一个局限性，就是只能用到被 Spring 容器管理的 Bean 上，其他的类则无法使用，AspectJ 则无此限制（话说回来，Java 项目 Spring 基本上都是标配了，所以这点其实到也不重要）。</li><li>Spring AOP 只能在运行时增强，而 AspectJ 则支持编译时增强，编译后增强以及运行时增强。</li><li>Spring AOP 支持方法的增强，然而 AspectJ 支持方法、属性、构造器、静态对象、final 类/方法等的增强。</li><li>AspectJ 由于是编译时增强，因此运行效率也要高于 Spring AOP。</li><li>。。。</li></ol><p>虽然 AspectJ 有这么多优势，但是 Spring AOP 却有另外一个制胜法宝，那就是<strong>简单易用</strong>！</p><p>所以，我们日常开发中，还是 Spring AOP 使用更多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天想和小伙伴们聊一下我们在使用 Spring AOP 时，一个非常常见的概念 AspectJ。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>当注入的 Bean 存在冲突时，到底有多少种解决方案？松哥总结了 5 种！</title>
    <link href="http://www.javaboy.org/2023/0824/spring-bean-inject-conflict.html"/>
    <id>http://www.javaboy.org/2023/0824/spring-bean-inject-conflict.html</id>
    <published>2023-08-24T09:19:05.000Z</published>
    <updated>2023-09-12T09:41:15.950Z</updated>
    
    <content type="html"><![CDATA[<p>当我们从 Spring 容器中“拉”取一个 Bean 回来的时候，可以按照名字去拉取，也可以按照类型去拉取，按照 BeanName 拉取的话，一般来说只要 BeanName 书写没有问题，都是没问题的。但是如果是按照类型去拉取，则可能会因为 Bean 存在多个实例从而导致失败。</p><a id="more"></a><p>在前面的文章中，松哥和小伙伴们分享了 @Primary、@Qualifier 注解在处理该问题时的一些具体的方案，但是都是零散的，今天咱们来把这些方案总结一下，顺便再来看看是否还存在其他方案？</p><h2 id="1-问题呈现"><a href="#1-问题呈现" class="headerlink" title="1. 问题呈现"></a>1. 问题呈现</h2><p>假设我有 A、B 两个类，在 A 中注入 B，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 B，则在配置类中存在多个实例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"b1"</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"b2"</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的项目启动之后，必然会抛出如下异常：</p><p><img src="http://img.itboyhub.com/2022/08/20230726195132.png" alt></p><p>今天我们就来总结下这个问题的解决方案。</p><h2 id="2-解决方案分析"><a href="#2-解决方案分析" class="headerlink" title="2. 解决方案分析"></a>2. 解决方案分析</h2><h3 id="2-1-Resource"><a href="#2-1-Resource" class="headerlink" title="2.1 @Resource"></a>2.1 @Resource</h3><p>使用 @Resource 注解，这个应该是大家最容易想到的方案之一，不过使用 @Resource 注解需要额外添加依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加了依赖之后，现在就可以直接使用 @Resource 注解了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Resource</span>(name = <span class="hljs-string">"b1"</span>)</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Qualifier-指定-name"><a href="#2-2-Qualifier-指定-name" class="headerlink" title="2.2 @Qualifier 指定 name"></a>2.2 @Qualifier 指定 name</h3><p>另一种方案就是搭配 @Qualifier 注解，通过该注解指定 Bean 的名称：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"b1"</span>)</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这种方案的源码分析松哥在之前的文章中和大家聊过了：<a href="https://mp.weixin.qq.com/s/gY7tetEEBe4A9ElHanr2qg" target="_blank" rel="noopener">Spring 中 @Qualifier 注解还能这么用？</a>。</p><h3 id="2-3-Qualifier-不指定-name"><a href="#2-3-Qualifier-不指定-name" class="headerlink" title="2.3 @Qualifier 不指定 name"></a>2.3 @Qualifier 不指定 name</h3><p>这种方案也是搭配 @Qualifier，但是并不指定 BeanName，而是在 B 注册和 A 中注入 B 的时候，分别标记一个 @Qualifier 注解：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-meta">@Qualifier</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-meta">@Qualifier</span></span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这种方案的源码分析松哥在之前的文章中和大家聊过了：<a href="https://mp.weixin.qq.com/s/gY7tetEEBe4A9ElHanr2qg" target="_blank" rel="noopener">Spring 中 @Qualifier 注解还能这么用？</a>。</p><h3 id="2-4-不作为候选-Bean"><a href="#2-4-不作为候选-Bean" class="headerlink" title="2.4 不作为候选 Bean"></a>2.4 不作为候选 Bean</h3><p>另外还有一种方案，就是在注册 Bean 的时候，告诉 Spring 容器，这个 Bean 在通过 type 进行注入的时候，不作为候选 Bean。</p><p>小伙伴们知道，在第一小节中报的错，原因就是因为根据 type 去查找相应的 Bean 的时候，找到了多个候选 Bean，所以才会报错，所以我们注册一个 Bean 的时候，可以设置该 Bean 不是候选 Bean，这个设置并不影响通过 name 注入一个 Bean。</p><p>具体配置如下：</p><p>Java 代码配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span>(autowireCandidate = <span class="hljs-keyword">false</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autowireCandidate 属性就表示这个 Bean 不是一个候选 Bean。</p><p>XML 配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.p2.B"</span> <span class="hljs-attr">autowire-candidate</span>=<span class="hljs-string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>autowire-candidate 属性表示当前 Bean 是否作为一个候选 Bean。</p><h3 id="2-5-Primary"><a href="#2-5-Primary" class="headerlink" title="2.5 @Primary"></a>2.5 @Primary</h3><p>差点把我们最常用的方案忘了。@Primary 表示当通过 type 注入的时候，如果当前 Bean 存在多个实例，则优先使用带有 @Primary 注解的 Bean。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-meta">@Primary</span></span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这种方案的源码分析松哥在之前的文章中和大家聊过了：<a href="https://mp.weixin.qq.com/s/Fm_Z8G5mU7gc92MhtL269w" target="_blank" rel="noopener">Spring 中 @Primary 注解的原理是什么？</a>。</p><p>好啦，这就是松哥总结出来的 5 种方案，实际上，基于这五种，还能衍生出来一些方案，这就需要小伙伴们自行探索啦～</p><p>最后大家思考这样一问题：对于第一小节提出来的问题，如果同时使用 2.2 和 2.5 小节的方案，那么哪一个会生效呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们从 Spring 容器中“拉”取一个 Bean 回来的时候，可以按照名字去拉取，也可以按照类型去拉取，按照 BeanName 拉取的话，一般来说只要 BeanName 书写没有问题，都是没问题的。但是如果是按照类型去拉取，则可能会因为 Bean 存在多个实例从而导致失败。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码应该怎么学？</title>
    <link href="http://www.javaboy.org/2023/0823/spring-how-to-study.html"/>
    <id>http://www.javaboy.org/2023/0823/spring-how-to-study.html</id>
    <published>2023-08-23T09:18:52.000Z</published>
    <updated>2023-09-12T09:41:09.843Z</updated>
    
    <content type="html"><![CDATA[<p>很多小伙伴知道松哥最近在录 Spring 源码视频，也有小伙伴说能不能授之以渔，我也仔细想过这个问题，今天来和大家聊一聊这个话题。</p><a id="more"></a><p>关注松哥时间久的小伙伴可能还记得我在 2020 年的时候其实写过 Spring 源码解析的文章，但是最终却无疾而终，烂尾了。为什么当时没有坚持把一个系列写完呢？</p><p><img src="http://img.itboyhub.com/2022/08/20230822194325.png" alt="这是当年写的文章，前后一共十篇左右，都发在公众号上了"></p><p>现在总结起来，当时这个系列没有坚持写完的原因就是方式不对！当时我想的是，就从配置文件/配置类的加载开始，一步一步梳理 Spring 容器的初始化流程，最后打通任督二脉融会贯通。然而在开始写之后，却发现了很多问题。整个 Spring 容器初始化的过程中，涉及到的小细节非常多，任何一个小细节拉出来，都能写好几篇文章去讲，为了让大家把各个细节理解到位，我需要不停的从主线切换出来，去做支线任务，然而支线任务可能也会分出来支线任务，这样到最后，摊子越铺越大，刚好当时正在写《深入浅出 Spring Security》一书，到了交稿的前夕，也比较忙，Spring 源码的内容就搁置了，一搁就是三年。</p><p>今年当我想重新拾起 Spring 源码这个系列的时候，我决定换一个思路。</p><p>Spring 经过接近二十年的发展，里边的实现细节现在非常多，很多小伙伴掌握的都是工作中特别常见的用法，而这些，估计仅有 Spring 所有功能的 1/3，这就导致大家在阅读 Spring 源码的时候经常会感觉比较懵，因为不知道 Spring 还能这么用，就不理解为什么源码这么写。</p><p>所以这一次我决定就从 Spring 的用法开始，先就某一个具体的使用细节，和大家分析其源码，这样，在不断的功能细节分析过程中，大家对 Spring 源码也会逐渐熟悉，最后，再来个提纲挈领的分析，把所有内容串起来。</p><p>就比如前段时间我写的关于循环依赖的文章：</p><p>首先我先从非代码的层面介绍什么是循环依赖，以及循环依赖的解决思路：</p><ul><li><a href="https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA" target="_blank" rel="noopener">如何通过三级缓存解决 Spring 循环依赖</a></li></ul><p>然后，我再指出这种循环依赖解决思路可能存在的不足：</p><ul><li><a href="https://mp.weixin.qq.com/s/Un8pyET2XDXpDY4FnRbwXw" target="_blank" rel="noopener">Spring 能解决所有循环依赖吗？</a></li></ul><p>再给出为什么 @Lazy 注解就能破解死循环：</p><ul><li><a href="https://mp.weixin.qq.com/s/GjI4xPGXscCGQtcalwnJKQ" target="_blank" rel="noopener">@Lazy 注解为啥就能破解死循环？</a></li></ul><p>最后，所有道理都明白了，所有细节的源码都搞清楚了之后，再来一个整体的源码分析：</p><ul><li><a href="https://mp.weixin.qq.com/s/YIokfCvLKLhcsEpO734Qtg" target="_blank" rel="noopener">透过源码，捋清楚循环依赖到底是如何解决的！</a></li></ul><p>这样一套流程下来，循序渐进，相信大家对于循环依赖的理解就相当到位了。当然，这并不是说就结束了，上面这些内容又是将来 IoC 容器中 Bean 初始化的前置知识。</p><p>通过这种先从用法入手，从一个小的知识点开始源码分析，再逐步扩大分析范围，直到最终把整个知识点的源码捋清楚，这种方式相比于三年前的源码分析方式，效果应该要好很多。我的这种讲解的方式，也得到了小伙伴们的认可，这也给了我自信，就按照这样的方式坚持下去。</p><p><img src="http://img.itboyhub.com/2022/08/20230822-210534.jpg" alt></p><p>如果小伙伴们想要自己去探索 Spring 源码，我也建议采用这种方式来～</p><p>最后再来和大家说一说我最近在录的 Spring 源码视频。</p><p>为什么要做这个视频，因为我觉得 Spring 源码对于大家非常重要，从初级程序员进阶到高级，Spring 源码算是一个必备技能，不是说懂 Spring 源码你就是高级开发了，但是如果连 Spring 源码都不清楚，你是否有底气告诉别人自己是一个高级开发？所以把 Spring 理解到位，是大家打怪升级的必经之路。</p><p>学习 Spring 源码，不仅仅是学习 Spring，也是学习优秀框架的设计思想，例如我们天天背 23 种设计模式，但是到了工作中很多人不知道该如何使用，那么不妨来看看 Spring 源码，看看 Spring 源码是如何使用设计模式的。</p><p>视频目前已经处于更新中了，现在已经更了 53 集约 12 个小时了。</p><p>这次的视频我提供了语雀笔记，所有的视频都有对应的笔记，小伙伴们在学习的过程中，如果有不懂的地方或者理解不到位的地方，可以直接在语雀文档下评论，我都会回复大家，典型问题我会重新录视频讲解，这样大家最终拿到手的不仅仅是一套视频，还有一套资料翔实的文档。</p><p><img src="http://img.itboyhub.com/2022/08/20230822-211003.jpg" alt></p><p>由于现在视频刚刚开始更新，所以现在上车还是比较实惠的，5 折 199 上车！买过 vhr 和 TienChin 的小伙伴应该都知道，后面随着录制内容越来越多，购买人数变多，优惠力度也会降低。</p><p>每一次做课程我都会认认真真去对待，如果没有想好怎么做，我是不会贸然推出来相应的课程的，因为来自小伙伴们的信任太珍贵了。最近有个小伙伴去年问我有无 Spring 高级课程，当时还没有，而且当时我也没想到今年会出 Spring 源码课程，小伙伴说会等，我是真没想到他真的等了一年，还好今年总算把课程出了，没让小伙伴失望！</p><p><img src="http://img.itboyhub.com/2022/08/20230822211347.png" alt></p><p>说这么多是想告诉大家，松哥的课程还是值得的，不然也不会有这么多小伙伴选择二次上车啦：</p><p><img src="http://img.itboyhub.com/2022/08/20230822-212524.jpg" alt></p><p>好啦，最后再统一回答大家几个关于视频的问题。</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码一人一码。至于小伙伴们推荐的阿里网盘等，由于空间、分享文件类型等限制，并无法用在加密视频分发中。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：视频可以试看吗？</strong></p><p>其实我最近在公号发的视频，大家都可以当作试看视频。</p><p><strong>Q4：可以砍价吗？</strong></p><p>不可以，这个价格已经很便宜了，没法砍了（悄悄告诉大家，从 vhr 到 tienchin，暂时没有人砍价成功过），另外就是松哥是没有客服运营这些的，你加的微信就是我，咱都是纯粹的技术人，老实说我并不懂砍价，但是我会用沉默代表拒绝。</p><p><strong>Q5：视频多久更新完毕？</strong></p><p>我会争取在一个月之内更完第一部分，两个月之内更完第二部分。</p><p><strong>Q6：这套视频适合哪些人看？</strong></p><p>学习这套视频，有 Spring 基础更佳，没有也可以。对于有 Spring 基础的小伙伴来说，我会保证你学到一些之前从未了解到的 Spring 玩法，对于没有 Spring 基础的小伙伴来说，这套视频从 0 开始的，那一样也适合你。</p><p><strong>Q7：看视频有问题可以问吗？</strong></p><p>购买视频后我会统一拉一个微信群，视频有问题可以在群里交流。</p><p><strong>Q8：这套视频我能学到啥？</strong></p><p>从 Spring 基础用法到源码理解统统搞定。如果你还没接触过 Spring，这套视频从基础用法到源码分析，可以让大家一步到位掌握 Spring；如果已经有一些 Spring 使用经验了，那么这套视频可以帮你进一步提升，掌握 Spring 原理。不过需要提醒大家的是，这套视频不包括 SpringMVC 相关的内容。</p><hr><p><strong>好啦，5 折 199 抄底就在今天啦！</strong></p><p>P.s.：可能有小伙伴加了松哥多个微信，其实没有必要重复添加，任意一个都能找到我。当然，如果你还没有松哥微信，扫码加微信，<strong>备注 spring</strong>，发红包 199 上车吧（买过 vhr 或者 tienchin 的小伙伴可在此基础上再优惠 ¥30 哦）～</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多小伙伴知道松哥最近在录 Spring 源码视频，也有小伙伴说能不能授之以渔，我也仔细想过这个问题，今天来和大家聊一聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中 @Primary 注解的原理是什么？</title>
    <link href="http://www.javaboy.org/2023/0821/spring-primary.html"/>
    <id>http://www.javaboy.org/2023/0821/spring-primary.html</id>
    <published>2023-08-21T09:18:39.000Z</published>
    <updated>2023-09-12T09:40:52.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题分析"><a href="#1-问题分析" class="headerlink" title="1. 问题分析"></a>1. 问题分析</h2><p>当我们使用 Spring 的时候，有时候会遇到下面这种情况。</p><a id="more"></a><p>假设我有 A、B 两个类，在 A 中注入 B，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于 B，则在配置类中存在多个实例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"b1"</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"b2"</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的项目启动之后，必然会抛出如下异常：</p><p><img src="http://img.itboyhub.com/2022/08/20230726195132.png" alt></p><p>当然，对于这样的问题，相信有经验的同学都知道该怎么解决：</p><ol><li>可以使用 @Resource 注解，使用该注解时指定具体的 Bean 名称即可。</li><li>在 @Autowired 注解之上，再多加一个 @Qualifier(“b1”) 注解，通过该注解去指定要加载的 Bean 名称。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"b1"</span>)</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在多个 B 对象的某一个之上，添加 @Primary 注解，表示当存在重复的 B 对象时，优先使用哪一个。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"b1"</span>)</span><br><span class="line">    <span class="hljs-meta">@Primary</span></span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"b2"</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了这三个，还有没有其他办法呢？必须有！！！在 <a href="https://mp.weixin.qq.com/s/gY7tetEEBe4A9ElHanr2qg" target="_blank" rel="noopener">Spring 中 @Qualifier 注解还能这么用？</a> 一文中，松哥还和大家扩展了 @Qualifier 注解的其他用法，感兴趣的小伙伴不要错过哦。</p><p>这里三个方法，其中 @Resource 是 JSR 中提供的注解，我这里先不展开，松哥后面专门再来和大家聊 @Resource 注解的注入原理。今天我主要是想和小伙伴们分享一下后面两种方案的实现原理。</p><h2 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h2><p>本文基于前面<a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>一文展开，所以如果还没看过改文章的小伙伴，建议先去阅读一下，这有助于更好的理解本文。</p><h3 id="2-1-doResolveDependency"><a href="#2-1-doResolveDependency" class="headerlink" title="2.1 doResolveDependency"></a>2.1 doResolveDependency</h3><p>在<a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>的 3.3 小节中，我们提到，给 A 注入 B 的时候，会调用到 doResolveDependency 方法，我们再来看下该方法：</p><p>DefaultListableBeanFactory#doResolveDependency：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doResolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line"><span class="hljs-keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (matchingBeans.size() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line"><span class="hljs-keyword">if</span> (autowiredBeanName == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line"><span class="hljs-comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line"><span class="hljs-comment">// (before 4.3 in particular when we didn't even look for collection beans).</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，首先调用了 findAutowireCandidates 方法去找到所有满足条件的 Class。Map 中的 key 就是 Bean 的名称，value 则是一个 Class，此时还没有实例化。</p><p>如果我们是通过 @Qualifier 注解来解决问题的，那么问题就在 findAutowireCandidates 方法中被解决了。这个在前面的文章 <a href="https://mp.weixin.qq.com/s/gY7tetEEBe4A9ElHanr2qg" target="_blank" rel="noopener">Spring 中 @Qualifier 注解还能这么用？</a> 中已经和小伙伴们聊过了。</p><p>如果 @Qualifier 注解没把问题解决掉，就会导致最终查询到的 matchingBeans 的数量大于 1，那么就会进入到接下来的 if 环节中，通过 determineAutowireCandidate 方法进一步确定到底使用哪一个 Bean，@Primary 注解的处理，就在该方法中完成。</p><h3 id="2-2-determineAutowireCandidate"><a href="#2-2-determineAutowireCandidate" class="headerlink" title="2.2 determineAutowireCandidate"></a>2.2 determineAutowireCandidate</h3><p>DefaultListableBeanFactory#determineAutowireCandidate</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determineAutowireCandidate</span><span class="hljs-params">(Map&lt;String, Object&gt; candidates, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; requiredType = descriptor.getDependencyType();</span><br><span class="line">String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);</span><br><span class="line"><span class="hljs-keyword">if</span> (primaryCandidate != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> primaryCandidate;</span><br><span class="line">&#125;</span><br><span class="line">String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);</span><br><span class="line"><span class="hljs-keyword">if</span> (priorityCandidate != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> priorityCandidate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Fallback</span></span><br><span class="line"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">String candidateName = entry.getKey();</span><br><span class="line">Object beanInstance = entry.getValue();</span><br><span class="line"><span class="hljs-keyword">if</span> ((beanInstance != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.resolvableDependencies.containsValue(beanInstance)) ||</span><br><span class="line">matchesBeanName(candidateName, descriptor.getDependencyName())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> candidateName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里边一共做了三种尝试：</p><ol><li>第一个尝试就是调用 determinePrimaryCandidate 方法去确定最佳候选 Bean，这个方法本质上就是通过 @Primary 注解找到最佳 BeanName。</li><li>如果第一步没有找到最佳 BeanName，那么接下来会调用 determineHighestPriorityCandidate 方法去查找最佳 Bean，该方法本质上是通过查找 JSR-330 中的 @Priority 注解，来确定 Bean 的优先级。</li><li>如果前两步都没找到合适的 BeanName，那么接下来这个 for 循环则是通过 Bean 的名称进行匹配了，即 A 类中变量的名称和目标 Bean 的名称是否匹配，如果能匹配上，那也可以。这也就是我么常说的 @Autowired 注解先按照类型去匹配，如果类型匹配不上，就会按照名称去匹配。</li></ol><p>上面大致介绍了这个方法的执行思路，接下来我们就来看一下执行细节。</p><h4 id="2-2-1-determinePrimaryCandidate"><a href="#2-2-1-determinePrimaryCandidate" class="headerlink" title="2.2.1 determinePrimaryCandidate"></a>2.2.1 determinePrimaryCandidate</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determinePrimaryCandidate</span><span class="hljs-params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">String primaryBeanName = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">String candidateBeanName = entry.getKey();</span><br><span class="line">Object beanInstance = entry.getValue();</span><br><span class="line"><span class="hljs-keyword">if</span> (isPrimary(candidateBeanName, beanInstance)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (primaryBeanName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> candidateLocal = containsBeanDefinition(candidateBeanName);</span><br><span class="line"><span class="hljs-keyword">boolean</span> primaryLocal = containsBeanDefinition(primaryBeanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (candidateLocal &amp;&amp; primaryLocal) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line"><span class="hljs-string">"more than one 'primary' bean found among candidates: "</span> + candidates.keySet());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidateLocal) &#123;</span><br><span class="line">primaryBeanName = candidateBeanName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">primaryBeanName = candidateBeanName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> primaryBeanName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrimary</span><span class="hljs-params">(String beanName, Object beanInstance)</span> </span>&#123;</span><br><span class="line">String transformedBeanName = transformedBeanName(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (containsBeanDefinition(transformedBeanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getMergedLocalBeanDefinition(transformedBeanName).isPrimary();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> (getParentBeanFactory() <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory parent &amp;&amp;</span><br><span class="line">parent.isPrimary(transformedBeanName, beanInstance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下这个方法的执行逻辑。</p><p>参数 candidates 中保存了所有符合条件的 BeanDefinition，参数 key 就是 Bean 的名称，Value 则是对应的 BeanDefinition。现在就去遍历 candidates，在遍历的时候，调用 isPrimary 方法去判断这个 BeanDefinition 上是否含有 @Primary 注解，isPrimary 方法的逻辑比较简单，我就不啰嗦了，该方法中涉及到 getMergedLocalBeanDefinition 方法去父容器中查找两个细节，这个松哥在之前的文章中也都和大家聊过了（<a href="https://mp.weixin.qq.com/s/C8EnAU4A-6bvgm5jr3AK4w" target="_blank" rel="noopener">Spring BeanDefinition：父子关系解密</a>、<a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">Spring 中的父子容器是咋回事？</a>）。</p><p>在查找的过程中，如果有满足条件的 BeanName，则赋值给 primaryBeanName 变量然后返回，如果存在多个满足条件的 BeanName，那就抛出 NoUniqueBeanDefinitionException 异常。</p><h4 id="2-2-2-determineHighestPriorityCandidate"><a href="#2-2-2-determineHighestPriorityCandidate" class="headerlink" title="2.2.2 determineHighestPriorityCandidate"></a>2.2.2 determineHighestPriorityCandidate</h4><p>要理解 determineHighestPriorityCandidate 方法，得先了解 @Priority 注解的用法。考虑到有的小伙伴可能还不熟悉 @Priority 注解，我这里也跟大家稍微说两句。</p><p>@Priority 注解作用有点类似于 @Order，可以用来指定一个 Bean 的优先级，这是 JSR 中提供的注解，所以如果想使用这个注解，需要先添加依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>jakarta.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在类上添加该注解，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IBService</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Priority</span>(<span class="hljs-number">100</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BServiceImpl1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBService</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Priority</span>(<span class="hljs-number">101</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BServiceImpl2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBService</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Priority 注解中的数字表示优先级，数字越大优先级越小。将来在 A 中注入 IBService 时，就会优先查找优先级高的 Bean。虽然 @Priority 注解可以加在类上，也可以加在方法上，但是在具体实践中，加在方法上这个注解并不会生效，只能加在类上面。至于原因，大家看完接下来的源码分析就懂了。</p><p>现在我们再来看下 determineHighestPriorityCandidate 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determineHighestPriorityCandidate</span><span class="hljs-params">(Map&lt;String, Object&gt; candidates, Class&lt;?&gt; requiredType)</span> </span>&#123;</span><br><span class="line">String highestPriorityBeanName = <span class="hljs-keyword">null</span>;</span><br><span class="line">Integer highestPriority = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">String candidateBeanName = entry.getKey();</span><br><span class="line">Object beanInstance = entry.getValue();</span><br><span class="line"><span class="hljs-keyword">if</span> (beanInstance != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Integer candidatePriority = getPriority(beanInstance);</span><br><span class="line"><span class="hljs-keyword">if</span> (candidatePriority != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (highestPriorityBeanName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (candidatePriority.equals(highestPriority)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoUniqueBeanDefinitionException(requiredType, candidates.size(),</span><br><span class="line"><span class="hljs-string">"Multiple beans found with the same priority ('"</span> + highestPriority +</span><br><span class="line"><span class="hljs-string">"') among candidates: "</span> + candidates.keySet());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidatePriority &lt; highestPriority) &#123;</span><br><span class="line">highestPriorityBeanName = candidateBeanName;</span><br><span class="line">highestPriority = candidatePriority;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">highestPriorityBeanName = candidateBeanName;</span><br><span class="line">highestPriority = candidatePriority;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> highestPriorityBeanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>determineHighestPriorityCandidate 方法的整体处理思路跟 determinePrimaryCandidate 方法特别像，不同的是 determinePrimaryCandidate 方法处理的是 @Primary 注解，而 determineHighestPriorityCandidate 方法处理的是 @Priority 注解。</p><p>determineHighestPriorityCandidate 方法也是遍历 candidates，然后调用 getPriority 方法获取到具体的优先级的值。然后根据这个具体的数字选定一个合适的 beanName 返回，如果存在多个优先级相同的 bean，那么就会抛出 NoUniqueBeanDefinitionException 异常。</p><p>最后再来看下 getPriority 方法，几经辗转之后，该方法会调用到 AnnotationAwareOrderComparator#getPriority 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getPriority</span><span class="hljs-params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> Class&lt;?&gt; clazz) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> OrderUtils.getPriority(clazz);</span><br><span class="line">&#125;</span><br><span class="line">Integer priority = OrderUtils.getPriority(obj.getClass());</span><br><span class="line"><span class="hljs-keyword">if</span> (priority == <span class="hljs-keyword">null</span>  &amp;&amp; obj <span class="hljs-keyword">instanceof</span> DecoratingProxy decoratingProxy) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getPriority(decoratingProxy.getDecoratedClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里最终就是调用 OrderUtils.getPriority 方法去查找参数 clazz 上的 @Priority 注解，并找到注解上对应的值返回。OrderUtils.getPriority 在执行的时候，参数时 clazz，即只会查找 clazz 上的 注解，并不会查找方法上的注解，因此前面我说 @Priority 注解要加在类上才有效。</p><h4 id="2-2-3-按名称匹配"><a href="#2-2-3-按名称匹配" class="headerlink" title="2.2.3 按名称匹配"></a>2.2.3 按名称匹配</h4><p>最后我们再来看下按照名字去匹配的逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// Fallback</span></span><br><span class="line"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : candidates.entrySet()) &#123;</span><br><span class="line">String candidateName = entry.getKey();</span><br><span class="line">Object beanInstance = entry.getValue();</span><br><span class="line"><span class="hljs-keyword">if</span> ((beanInstance != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.resolvableDependencies.containsValue(beanInstance)) ||</span><br><span class="line">matchesBeanName(candidateName, descriptor.getDependencyName())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> candidateName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matchesBeanName</span><span class="hljs-params">(String beanName, @Nullable String candidateName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (candidateName != <span class="hljs-keyword">null</span> &amp;&amp;</span><br><span class="line">(candidateName.equals(beanName) || ObjectUtils.containsElement(getAliases(beanName), candidateName)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里也是遍历 candidates 集合，然后调用 matchesBeanName 方法，在该方法中，会去判断候选的 BeanName 和需要注入的变量名（<code>descriptor.getDependencyName()</code>）是否相等，如果相等，就直接返回即可。即下面这种代码不需要额外的注解是可以运行不会报错的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    B b1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，经过上面的分析，现在小伙伴们明白了 @Primary 注解的完整处理逻辑了吧～本文结合<a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a> 和 <a href="https://mp.weixin.qq.com/s/gY7tetEEBe4A9ElHanr2qg" target="_blank" rel="noopener">Spring 中 @Qualifier 注解还能这么用？</a> 一起食用效果更好哦！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-问题分析&quot;&gt;&lt;a href=&quot;#1-问题分析&quot; class=&quot;headerlink&quot; title=&quot;1. 问题分析&quot;&gt;&lt;/a&gt;1. 问题分析&lt;/h2&gt;&lt;p&gt;当我们使用 Spring 的时候，有时候会遇到下面这种情况。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring BeanDefinition 也分父子？</title>
    <link href="http://www.javaboy.org/2023/0816/spring-beandefintion-parent.html"/>
    <id>http://www.javaboy.org/2023/0816/spring-beandefintion-parent.html</id>
    <published>2023-08-16T09:18:25.000Z</published>
    <updated>2023-09-12T09:40:49.858Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring 框架中，BeanDefinition 是一个核心概念，用于定义和配置 bean 的元数据，虽然在实际应用中，我们一般并不会或者很少直接定义 BeanDefinition，但是，我们在 XML 文件中所作的配置，以及利用 Java 代码做的各种 Spring 配置，都会被解析为 BeanDefinition，然后才会做进一步的处理。BeanDefinition 允许开发人员以一种声明性的方式定义和组织 bean，这里有很多属性，今天松哥单纯的来和小伙伴们聊一聊它的 parentName 属性，parentName 属性在 BeanDefinition 中扮演着重要的角色，用于建立 bean 之间的父子关系。</p><a id="more"></a><blockquote><p>之前松哥有一篇文章和小伙伴们聊了 BeanFactory 之间的父子关系（<a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">Spring 中的父子容器是咋回事？</a>），大家注意和今天的内容进行区分，今天我们聊的是 BeanDefinition 之间的父子关系。</p></blockquote><p>BeanDefinition 的 parentName 属性的主要功能是允许我们在创建一个 bean 的同时，能够继承另一个已经定义好的 bean。通过指定 parentName 属性，我们可以重用已有 bean 的配置，并在此基础上进行修改或扩展。</p><p>先不废话了，我先来举两个例子，小伙伴们先感受一下 BeanDefinition 的作用。</p><h2 id="1-实践"><a href="#1-实践" class="headerlink" title="1. 实践"></a>1. 实践</h2><p>假设我有如下两个类，首先是一个动物的基类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer age;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有一个 Dog 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer age;</span><br><span class="line">    <span class="hljs-keyword">private</span> String color;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小伙伴们注意，这里的 Dog 类并没有继承自 Animal 类，但是有两个跟 Animal 同名的属性。之所以这样设计是希望小伙伴们理解 BeanDefinition 中的 parentName 属性和 Java 中的继承并无关系，虽然大部分情况下我们用到 parentName 的时候，Java 中相关的类都是继承关系。</p></blockquote><p>现在，有一些通用的属性我想在 Animal 中进行配置，Dog 中特有的属性则在 Dog 中进行配置，我们来看下通过 XML 和 Java 分别该如何配置。</p><h3 id="1-1-XML-配置"><a href="#1-1-XML-配置" class="headerlink" title="1.1 XML 配置"></a>1.1 XML 配置</h3><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"animal"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.demo.p2.Animal"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"小黑"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"3"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.demo.p2.Dog"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dog"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"animal"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"黑色"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小伙伴们看到，首先我们配置 Animal，Animal 中有 name 和 age 两个属性，然后我又配置了 Dog Bean，并未之指定了 parent 为 animal，然后给 Dog 设置了 color 属性。</p><p>现在，Dog Bean 定义出来的 BeanDefinition 中将来就包含了 animal 中的属性值。</p><h3 id="1-2-Java-配置"><a href="#1-2-Java-配置" class="headerlink" title="1.2 Java 配置"></a>1.2 Java 配置</h3><p>再来看看 Java 配置该如何写。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">RootBeanDefinition pbd = <span class="hljs-keyword">new</span> RootBeanDefinition();</span><br><span class="line">MutablePropertyValues pValues = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pValues.add(<span class="hljs-string">"name"</span>, <span class="hljs-string">"小黄"</span>);</span><br><span class="line">pbd.setBeanClass(Animal.class);</span><br><span class="line">pbd.setPropertyValues(pValues);</span><br><span class="line">GenericBeanDefinition cbd = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">cbd.setBeanClass(Dog.class);</span><br><span class="line">cbd.setParentName(<span class="hljs-string">"parent"</span>);</span><br><span class="line">MutablePropertyValues cValues = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">cValues.add(<span class="hljs-string">"name"</span>, <span class="hljs-string">"小强"</span>);</span><br><span class="line">cbd.setPropertyValues(cValues);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"parent"</span>, pbd);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"child"</span>, cbd);</span><br><span class="line">ctx.refresh();</span><br><span class="line">Dog child = (Dog) ctx.getBean(<span class="hljs-string">"child"</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"child = "</span> + child);</span><br></pre></td></tr></table></figure><p>这里我使用了 RootBeanDefinition 来做 parent，其实从名字上就能看出来 RootBeanDefinition 适合做 parent，并且 RootBeanDefinition 不能作为 child。强行设置运行时会抛出异常，RootBeanDefinition#setParentName 方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setParentName</span><span class="hljs-params">(@Nullable String parentName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (parentName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Root bean cannot be changed into a child bean with parent reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MutablePropertyValues 是为相应的对象设置属性值。</p><p>child 我这里使用了 GenericBeanDefinition，这个主要是做 child 的处理，最早有一个专门做 child 的 ChildBeanDefinition，不过自从 Spring2.5 开始提供了 GenericBeanDefinition 之后，现在用来做 child 首选 GenericBeanDefinition。</p><p>在上述案例中，parent 和 child 都设置了 name 属性，那么 child 会覆盖掉 parent，这一点和 Java 中的继承一致。</p><p>用法就是这样，并不难。</p><p>这就是 Spring BeanDefinition 中的父子关系问题。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>那么接下来我们也把这块的源码稍微来分析一下。</p><p>简便起见，我们就不从 Bean 的创建开始分析了，直接来看和 BeanDefinition 中 parentName 属性相关的地方，但是前面涉及到的方法还是给小伙伴们梳理一下，就是下图：</p><p><img src="http://img.itboyhub.com/2022/08/20230801221259.png" alt></p><p>那么这里涉及到的关键方法其实就是 AbstractBeanFactory#getMergedBeanDefinition：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> RootBeanDefinition <span class="hljs-title">getMergedBeanDefinition</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">RootBeanDefinition mbd = <span class="hljs-keyword">null</span>;</span><br><span class="line">RootBeanDefinition previous = <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (containingBd == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mbd = <span class="hljs-keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || mbd.stale) &#123;</span><br><span class="line">previous = mbd;</span><br><span class="line"><span class="hljs-keyword">if</span> (bd.getParentName() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Use copy of given root bean definition.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> RootBeanDefinition rootBeanDef) &#123;</span><br><span class="line">mbd = rootBeanDef.cloneBeanDefinition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">mbd = <span class="hljs-keyword">new</span> RootBeanDefinition(bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Child bean definition: needs to be merged with parent.</span></span><br><span class="line">BeanDefinition pbd;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line"><span class="hljs-keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (getParentBeanFactory() <span class="hljs-keyword">instanceof</span> ConfigurableBeanFactory parent) &#123;</span><br><span class="line">pbd = parent.getMergedBeanDefinition(parentBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(parentBeanName,</span><br><span class="line"><span class="hljs-string">"Parent name '"</span> + parentBeanName + <span class="hljs-string">"' is equal to bean name '"</span> + beanName +</span><br><span class="line"><span class="hljs-string">"': cannot be resolved without a ConfigurableBeanFactory parent"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Deep copy with overridden values.</span></span><br><span class="line">mbd = <span class="hljs-keyword">new</span> RootBeanDefinition(pbd);</span><br><span class="line">mbd.overrideFrom(bd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">mbd.setScope(SCOPE_SINGLETON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// A bean contained in a non-singleton bean cannot be a singleton itself.</span></span><br><span class="line"><span class="hljs-comment">// Let's correct this on the fly here, since this might be the result of</span></span><br><span class="line"><span class="hljs-comment">// parent-child merging for the outer bean, in which case the original inner bean</span></span><br><span class="line"><span class="hljs-comment">// definition will not have inherited the merged outer bean's singleton status.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (containingBd != <span class="hljs-keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">mbd.setScope(containingBd.getScope());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Cache the merged bean definition for the time being</span></span><br><span class="line"><span class="hljs-comment">// (it might still get re-merged later on in order to pick up metadata changes)</span></span><br><span class="line"><span class="hljs-keyword">if</span> (containingBd == <span class="hljs-keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (previous != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">copyRelevantMergedBeanDefinitionCaches(previous, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法看名字就是要获取一个合并之后的 BeanDefinition，就是将 child 中的属性和 parent 中的属性进行合并，然后返回，这个方法中有一个名为 mbd 的变量，这就是合并之后的结果。</p><ol><li>首先会尝试从 mergedBeanDefinitions 变量中获取到合并之后的 BeanDefinition，mergedBeanDefinitions 相当于就是一个临时缓存，如果之前已经获取过了，那么获取成功之后就将之保存到 mergedBeanDefinitions 中，如果是第一次进入到该方法中，那么该变量中就没有我们需要的数据，所以会继续执行后面的步骤。</li><li>当第 1 步并未拿到 mbd 的时候，接下来继续判断 <code>bd.getParentName()</code> 是否为空，这个其实就是查看当前的 BeanDefinition 是否有设置 parentName，如果有设置，这里获取到的就不为 null，否则为 null。如果这里获取到的值为 null，那么就会根据当前传入的 BeanDefinition 生成一个 mbd，至于具体的生成方式：如果传入的 BeanDefinition 是 RootBeanDefinition 类型的，则调用 clone 方法去生成 mbd（本质上也是 new 一个新的 RootBeanDefinition），如果传入的 BeanDefinition 不是 RootBeanDefinition 类型的，则直接 new 一个新的 RootBeanDefinition，在 new 的过程中，会把传入的 BeanDefinition 上的属性都复制到新的 RootBeanDefinition 中。</li><li>如果 <code>bd.getParentName()</code> 不为空，则意味着存在 parent BeanDefinition，所以就要进行合并处理了，合并时候又有一个小细节，如果 parentBeanName 等于当前的 beanName，由于 Spring 在同一个容器中不允许存在同名的 bean，所以这就说明 parentBeanName 可能是父容器的 Bean，此时就要去父容器中去处理，当然最终调用到的还是当前方法，关于父子容器这一块，小伙伴们可以参考松哥之前的 <a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">Spring 中的父子容器是咋回事？</a> 一文。如果 parentBeanName 不等于当前 beanName，那么现在就可以调用 getMergedBeanDefinition 方法去获取到 parentBeanDefinition 了，getMergedBeanDefinition 是当前方法的重载方法，该方法最终也会调用到当前方法，原因就在于 parentBeanDefinition 本身也可能存在 parentBeanDefinition。</li><li>有了 pbd 之后，接下来 new 一个 RootBeanDefinition，然后调用 overrideFrom 方法进行属性合并，合并的方式就是用传入的 BeanDefinition 中的属性去覆盖 pbd 中同名的属性。</li><li>最后就是再设置 scope 属性等，然后把 mbd 返回即可。</li></ol><p>核心流程就是上面这个步骤，如此之后，拿到手的就是和 parent 合并之后的 BeanDefinition 了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>最后我们再来稍微总结下：</p><p>使用 parentName 属性的一个主要优势是提高代码的可维护性和重用性。当我们需要创建多个相似的 bean 时，可以通过定义一个基础 bean，并在其他 bean 中使用 parentName 属性来继承其配置。这样，我们只需在基础 bean 中定义一次配置，而不必为每个派生 bean 重复相同的配置。</p><p>另一个使用 parentName 属性的场景是在多个层次结构中定义 bean。假设我们有一个通用的基础服务层 bean，而不同的业务模块需要在此基础上进行扩展。通过使用 parentName 属性，我们可以为每个业务模块定义一个派生 bean，并在其中添加特定于模块的配置。这种层次结构的定义使得我们可以更好地组织和管理不同模块之间的 bean。</p><p>通过使用 parentName 属性，我们可以轻松地创建和管理 bean 的层次结构。这种继承关系使得我们可以更好地组织和重用 bean 的配置，减少了代码的冗余性。同时，它还提供了一种灵活的方式来定义不同模块之间的 bean，使得应用程序更易于扩展和维护。</p><p>综上所述，Spring 框架中的 BeanDefinition 的 parentName 属性允许我们在定义 bean 时建立父子关系，从而提高代码的可维护性和重用性。通过继承已有 bean 的配置，我们可以避免重复编写相似的配置，并更好地组织和管理不同层次结构的 bean。</p><p>有的小伙伴们可能会搞混今天内容和之前松哥所写的 Spring 父子容器之间的关系，小伙伴们参考这篇文章就清楚啦：<a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">Spring 中的父子容器是咋回事？</a>。</p><p>另外，Spring BeanDefinition 中的 parentName 和 Java 中的继承虽然有点像，但是并不能同等看待，它们之间也还是有一些区别的：</p><ol><li>概念和作用：Java 中的继承是一种面向对象的编程概念，用于定义类之间的父子关系，子类继承父类的属性和方法。而在 Spring 中，BeanDefinition 的 parentName 属性是用于定义 bean 之间的父子关系，一个派生 bean 可以继承另一个已定义的 bean 的配置。</li><li>语法和用法：在 Java 中，继承是通过使用关键字 <code>extends</code> 来实现的，子类通过继承父类来获得父类的属性和方法。而在 Spring 中，通过在 BeanDefinition 中配置 parentName 属性来指定一个 bean 的父 bean，从而继承父 bean 的配置。</li><li>范围和应用：Java 中的继承主要用于类的继承关系，用于定义类之间的层次结构和代码的重用。而在 Spring 中，BeanDefinition 的继承主要用于定义 bean 之间的配置继承关系，用于组织和管理 bean 的配置，提高代码的可维护性和重用性。</li></ol><p>好啦，Spring BeanDefinition 中的 parentName 属性现在大家明白了吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Spring 框架中，BeanDefinition 是一个核心概念，用于定义和配置 bean 的元数据，虽然在实际应用中，我们一般并不会或者很少直接定义 BeanDefinition，但是，我们在 XML 文件中所作的配置，以及利用 Java 代码做的各种 Spring 配置，都会被解析为 BeanDefinition，然后才会做进一步的处理。BeanDefinition 允许开发人员以一种声明性的方式定义和组织 bean，这里有很多属性，今天松哥单纯的来和小伙伴们聊一聊它的 parentName 属性，parentName 属性在 BeanDefinition 中扮演着重要的角色，用于建立 bean 之间的父子关系。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中 @Qualifier 注解还能这么用？</title>
    <link href="http://www.javaboy.org/2023/0814/spring-qualifier.html"/>
    <id>http://www.javaboy.org/2023/0814/spring-qualifier.html</id>
    <published>2023-08-14T09:18:07.000Z</published>
    <updated>2023-09-12T09:40:21.988Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>今天想和小伙伴们聊一聊 @Qualifier 注解的完整用法，同时也顺便分析一下它的实现原理。</p><a id="more"></a><p>说到 @Qualifier，有的小伙伴可能会觉得诧异，这也只得写一篇文章？确实，但凡有点开发经验，多多少少可能都遇到过 @Qualifier 注解的使用场景，然而，对于大部分小伙伴来说，我们平时开发遇到的 @Qualifier 注解使用场景，只是 @Qualifier 注解功能中很小的一部分而已，今天咱们就来完整的捋一捋。</p><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p>首先和小伙伴们回顾一下 @Qualifier 注解的基本用法，基本用法我从四个方面来和大家介绍，只有先把这些基本用法捋清楚了，在看源码的时候才会有种醍醐灌顶的感觉。</p><h3 id="1-1-指定-Bean-名称"><a href="#1-1-指定-Bean-名称" class="headerlink" title="1.1 指定 Bean 名称"></a>1.1 指定 Bean 名称</h3><p>说到 @Qualifier 注解，大家最容易想到的就是处理 Bean 注入的问题了，假设我有如下 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(value = <span class="hljs-string">"b1"</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"b2"</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 B 向 Spring 容器中注册了两个，名字分别是 b1 和 b2。</p><p>现在在 A 中想要使用 B，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 @Autowired 注解是按照类型进行 Bean 的注入的，此时 Spring 容器中存在两个 B 实例，那么注入就会出错，通过 @Qualifier 注解我们可以指定具体想要使用哪一个 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"b1"</span>)</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就指定了在注入时使用 b1 这个对象了。</p><blockquote><p>当然，对于这个问题，其实解决方案很多，如使用 @Primary 注解、使用 @Bean 注解但是额外加配置等都能解决问题，不过本文主题是 @Qualifier，所以暂时先不和大家讨论其它方案。</p></blockquote><h3 id="1-2-不指定-Bean-名称"><a href="#1-2-不指定-Bean-名称" class="headerlink" title="1.2 不指定 Bean 名称"></a>1.2 不指定 Bean 名称</h3><p>在 1.1 小节中，我们使用 @Qualifier 注解时指定了需要注入的 Bean 名称，其实也可以不指定 Bean 名称，不指定 Bean 名称的话，我们就需要在两个地方进行配置。</p><p>首先在 Bean 注入的时候，添加 @Qualifier 注解：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(value = <span class="hljs-string">"b1"</span>)</span><br><span class="line">    <span class="hljs-meta">@Qualifier</span></span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"b2"</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到，这里给 b1 添加了 @Qualifier 注解，但是未设置任何 value，然后在需要进行 B 对象注入的地方，也添加 @Qualifier 注解：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-meta">@Qualifier</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也能解决问题。</p><h3 id="1-3-自定义注解"><a href="#1-3-自定义注解" class="headerlink" title="1.3 自定义注解"></a>1.3 自定义注解</h3><p>例如我可以自定义一个注解，专门用来注入 b1 对象的注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Inherited</span></span><br><span class="line"><span class="hljs-meta">@Target</span>(&#123;ElementType.FIELD,ElementType.METHOD,ElementType.TYPE,ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="hljs-meta">@Qualifier</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> B1Qualifier &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后分别在注册 Bean 和使用 Bean 的时候，添加该注解：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(value = <span class="hljs-string">"b1"</span>)</span><br><span class="line">    <span class="hljs-meta">@B</span>1Qualifier</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"b2"</span>)</span><br><span class="line">    <span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-meta">@B</span>1Qualifier</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也是一个问题解决办法。</p><h3 id="1-4-XML-中的配置"><a href="#1-4-XML-中的配置" class="headerlink" title="1.4 XML 中的配置"></a>1.4 XML 中的配置</h3><p>前面跟大家说的都是在 Java 代码中进行配置的，我们也可以通过 XML 文件进行配置，并且在 XML 文件配置的过程中，还可以配置多个不同的属性，我举个例子。</p><p>假设我现在准备向 Spring 容器中注入两个 B，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.p3.B"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"b1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"b11"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.springframework.beans.factory.annotation.Qualifier"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">qualifier</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.p3.B"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"b2"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小伙伴们看到，在第一个 bean 标签中，我加入了 qualifier 标签，这个标签的 value 是 b11，type 则是 @Qualifier 本身，这个 type 其实也可以不配置，不配置的话默认也是 @Qualifier 注解本身；在第二个 bean 标签中我只加了 qualifier 标签，并未配置任何属性（相当于 1.2 小节的案例）。</p><p>现在，当我想要在 A 中注入 B 的时候，可以按照如下方式来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"b11"</span>)</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家注意，这里 @Qualifier 注解的 value 是 b11，对应了 qualifier 标签中的 value 属性，表示将 id 为 b1 的 Bean 注入到 A 中的 b 属性上。</p><p>如果没有为 @Qualifier 设置 value，那么就会将 id 为 b2 的 Bean 注入进来，这个就相当于我们前面 1.2 小节的案例。</p><p>前面我们使用的是 @Qualifier 注解中的 value 属性，实际上，qualifier 标签支持更多的属性定义。但问题是 @Qualifier 注解只有一个 value 属性，如果想要使用其它的属性进行匹配，那么就得使用自定义注解了（当然，这种场景实际上使用较少）。</p><p>如果想要自定义注解去匹配 qualifier 标签中提供的多种属性，那么我们可以按照如下方式来进行配置。</p><p>首先我们自定义注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Inherited</span></span><br><span class="line"><span class="hljs-meta">@Target</span>(&#123;ElementType.FIELD,ElementType.METHOD,ElementType.TYPE,ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="hljs-meta">@Qualifier</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyQualifier &#123;</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个组合注解，本质上还是 @Qualifier，但是现在多了一个我们自定义的 name 属性。</p><p>接下来在 XML 中使用该注解：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.javaboy.bean.p3.B"</span> id=<span class="hljs-string">"b1"</span>&gt;</span><br><span class="line">    &lt;qualifier type=<span class="hljs-string">"org.javaboy.bean.p3.MyQualifier"</span>&gt;</span><br><span class="line">        &lt;attribute key=<span class="hljs-string">"name"</span> value=<span class="hljs-string">"b11"</span>/&gt;</span><br><span class="line">    &lt;/qualifier&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.javaboy.bean.p3.B"</span> id=<span class="hljs-string">"b2"</span>&gt;</span><br><span class="line">    &lt;qualifier type=<span class="hljs-string">"org.javaboy.bean.p3.MyQualifier"</span>&gt;</span><br><span class="line">        &lt;attribute key=<span class="hljs-string">"name"</span> value=<span class="hljs-string">"b22"</span>/&gt;</span><br><span class="line">    &lt;/qualifier&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>接下来在 Bean 注入的时候，就可以使用 @MyQualifier 进行匹配了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-meta">@MyQualifier</span>(name = <span class="hljs-string">"b11"</span>)</span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就表示匹配 name 属性为 b11 的 Bean。</p><p>以上基本上就是 @Qualifier 注解在 Spring 容器中的一些用法了，接下来松哥将通过源码分析，来和小伙伴们一起探讨上面这些功能到底是怎么实现的。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>为了小伙伴们能轻松掌握 @Qualifier 的源码，一些前置的步骤我这里就不和大家分析了，重点就看 @Qualifier 注解的处理过程，其他未尽内容，将在后续文章中我会继续和大家分享。</p><p>由于 @Qualifier 注解一般都是搭配 @Autowired 注解一起使用的，所以解析 @Qualifier  注解的源码离不开 @Autowired 的注入过程，刚好松哥在之前的文章中已经和小伙伴们聊过 @Autowired 注解的注入过程了，还没看过该文章的小伙伴建议先阅读该文章，这有助于理解接下来的内容。</p><ul><li><a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a></li></ul><h3 id="2-1-doResolveDependency"><a href="#2-1-doResolveDependency" class="headerlink" title="2.1 doResolveDependency"></a>2.1 doResolveDependency</h3><p>在<a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>的 3.3 小节中，我们提到，给 A 注入 B 的时候，会调用到 doResolveDependency 方法，我们再来看下该方法：</p><p>DefaultListableBeanFactory#doResolveDependency：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doResolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line"><span class="hljs-keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，首先调用了 findAutowireCandidates 方法去找到所有满足条件的 Class。Map 中的 key 就是 Bean 的名称，value 则是一个 Class，此时还没有实例化。</p><p>对于 @Qualifier 注解的处理就在 findAutowireCandidates 方法中。</p><h3 id="2-2-findAutowireCandidates"><a href="#2-2-findAutowireCandidates" class="headerlink" title="2.2 findAutowireCandidates"></a>2.2 findAutowireCandidates</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Map&lt;String, Object&gt; <span class="hljs-title">findAutowireCandidates</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable String beanName, Class&lt;?&gt; requiredType, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line">String[] candidateNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line"><span class="hljs-keyword">this</span>, requiredType, <span class="hljs-keyword">true</span>, descriptor.isEager());</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，首先调用 <code>BeanFactoryUtils.beanNamesForTypeIncludingAncestors</code> 方法查找出 B 这种类型的所有 beanName，对于本文一开始的案例来说，这里拿到两个 beanName，分别是 b1、b2，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20230726211433.png" alt></p><p>接下来就去遍历 candidateNames，在遍历的时候，有两个判断条件：</p><ol><li>isSelfReference：这个方法是判断给定的 beanName 是否自引用，即是否指向原始 bean 或者原始 bean 上的工厂方法，这个判断跟本文案例关系不大。</li><li>isAutowireCandidate：这个方法从名字上就能看出来，判断这个 beanName 是否是一个候选的注入 beanName，很明显，这个跟本文案例相关，我们继续来看该方法。</li></ol><p>在 isAutowireCandidate 方法，又依次调了三次 isAutowireCandidate 方法，也就是说 isAutowireCandidate 方法一共调了四次之后，将会来到关键的 QualifierAnnotationAutowireCandidateResolver#isAutowireCandidate 方法中。</p><p><img src="http://img.itboyhub.com/2022/08/20230726212613.png" alt></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAutowireCandidate</span><span class="hljs-params">(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> match = <span class="hljs-keyword">super</span>.isAutowireCandidate(bdHolder, descriptor);</span><br><span class="line"><span class="hljs-keyword">if</span> (match) &#123;</span><br><span class="line">match = checkQualifiers(bdHolder, descriptor.getAnnotations());</span><br><span class="line"><span class="hljs-keyword">if</span> (match) &#123;</span><br><span class="line">MethodParameter methodParam = descriptor.getMethodParameter();</span><br><span class="line"><span class="hljs-keyword">if</span> (methodParam != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Method method = methodParam.getMethod();</span><br><span class="line"><span class="hljs-keyword">if</span> (method == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">void</span>.class == method.getReturnType()) &#123;</span><br><span class="line">match = checkQualifiers(bdHolder, methodParam.getMethodAnnotations());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> match;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前方法中，首先会调用 <code>super.isAutowireCandidate</code> 方法去判断这个 Bean 将来是否被允许注入到其他 Bean 中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAutowireCandidate</span><span class="hljs-params">(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">super</span>.isAutowireCandidate(bdHolder, descriptor)) &#123;</span><br><span class="line"><span class="hljs-comment">// If explicitly false, do not proceed with any other checks...</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> checkGenericTypeMatch(bdHolder, descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又是两件事，第一个是调用父类方法进行判断，这里单纯只是判断 autowireCandidate 属性是否为 true，如果这个属性为 false，就表示这个 Bean 不能被注入到其他 Bean 中，默认情况下该属性为 true，如果想要设置这个属性为 false，则可以在 @Bean 注解中设置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span>(value = <span class="hljs-string">"b1"</span>,autowireCandidate = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从这个层面讲，本文第一小节提出来的问题还有一种解决方案，就是把 autowireCandidate 属性设置为 false。</p></blockquote><p>checkGenericTypeMatch 则主要是用来检查类型是否匹配，这个就不去细看了。</p><p>现在回到前面的 isAutowireCandidate 方法中，super.isAutowireCandidate 方法的匹配结果为 true，那么接下来就该 checkQualifiers 方法了。</p><p>checkQualifiers 方法从名字上就能看出来，就是用来检查 @Qualifier 注解的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkQualifiers</span><span class="hljs-params">(BeanDefinitionHolder bdHolder, Annotation[] annotationsToSearch)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ObjectUtils.isEmpty(annotationsToSearch)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SimpleTypeConverter typeConverter = <span class="hljs-keyword">new</span> SimpleTypeConverter();</span><br><span class="line"><span class="hljs-keyword">for</span> (Annotation annotation : annotationsToSearch) &#123;</span><br><span class="line">Class&lt;? extends Annotation&gt; type = annotation.annotationType();</span><br><span class="line"><span class="hljs-keyword">boolean</span> checkMeta = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">boolean</span> fallbackToMeta = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (isQualifier(type)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!checkQualifier(bdHolder, annotation, typeConverter)) &#123;</span><br><span class="line">fallbackToMeta = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">checkMeta = <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (checkMeta) &#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会遍历传进来的注解，传进来的注解数组是 A 中 B 属性上的所有注解，以本文第一小节的案例为 1，这里是有两个注解，分别是 @Autowired 和 @Qualifier。</p><p>在这个方法中会去遍历注解数组，判断注解是否为 @Qualifier 类型的，如果是，则调用 checkQualifier 方法做进一步检查。</p><p>isQualifier 方法的逻辑很简单：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isQualifier</span><span class="hljs-params">(Class&lt;? extends Annotation&gt; annotationType)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Class&lt;? extends Annotation&gt; qualifierType : <span class="hljs-keyword">this</span>.qualifierTypes) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (annotationType.equals(qualifierType) || annotationType.isAnnotationPresent(qualifierType)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断是遍历 qualifierTypes 集合，将集合中的注解类型挨个拿出来和传入的参数进行比对，之所以是一个集合而不是直接拿 @Qualifier 注解做比对，是因为这个注解在 JSR-330 中也有一个实现，如果项目用到了 JSR-330 的话，那么 qualifierTypes 集合中就有两个注解。</p><p>checkQualifier 方法算是整个 @Qualifier 处理最为核心的部分了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkQualifier</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">BeanDefinitionHolder bdHolder, Annotation annotation, TypeConverter typeConverter)</span> </span>&#123;</span><br><span class="line">Class&lt;? extends Annotation&gt; type = annotation.annotationType();</span><br><span class="line">RootBeanDefinition bd = (RootBeanDefinition) bdHolder.getBeanDefinition();</span><br><span class="line">AutowireCandidateQualifier qualifier = bd.getQualifier(type.getName());</span><br><span class="line"><span class="hljs-keyword">if</span> (qualifier == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">qualifier = bd.getQualifier(ClassUtils.getShortName(type));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (qualifier == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// First, check annotation on qualified element, if any</span></span><br><span class="line">Annotation targetAnnotation = getQualifiedElementAnnotation(bd, type);</span><br><span class="line"><span class="hljs-comment">// Then, check annotation on factory method, if applicable</span></span><br><span class="line"><span class="hljs-keyword">if</span> (targetAnnotation == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">targetAnnotation = getFactoryMethodAnnotation(bd, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (targetAnnotation == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">RootBeanDefinition dbd = getResolvedDecoratedDefinition(bd);</span><br><span class="line"><span class="hljs-keyword">if</span> (dbd != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">targetAnnotation = getFactoryMethodAnnotation(dbd, type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (targetAnnotation == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Look for matching annotation on the target class</span></span><br><span class="line"><span class="hljs-keyword">if</span> (getBeanFactory() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; beanType = getBeanFactory().getType(bdHolder.getBeanName());</span><br><span class="line"><span class="hljs-keyword">if</span> (beanType != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">targetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(beanType), type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// Not the usual case - simply forget about the type check...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (targetAnnotation == <span class="hljs-keyword">null</span> &amp;&amp; bd.hasBeanClass()) &#123;</span><br><span class="line">targetAnnotation = AnnotationUtils.getAnnotation(ClassUtils.getUserClass(bd.getBeanClass()), type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (targetAnnotation != <span class="hljs-keyword">null</span> &amp;&amp; targetAnnotation.equals(annotation)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Object&gt; attributes = AnnotationUtils.getAnnotationAttributes(annotation);</span><br><span class="line"><span class="hljs-keyword">if</span> (attributes.isEmpty() &amp;&amp; qualifier == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// If no attributes, the qualifier must be present</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : attributes.entrySet()) &#123;</span><br><span class="line">String attributeName = entry.getKey();</span><br><span class="line">Object expectedValue = entry.getValue();</span><br><span class="line">Object actualValue = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-comment">// Check qualifier first</span></span><br><span class="line"><span class="hljs-keyword">if</span> (qualifier != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">actualValue = qualifier.getAttribute(attributeName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (actualValue == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Fall back on bean definition attribute</span></span><br><span class="line">actualValue = bd.getAttribute(attributeName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (actualValue == <span class="hljs-keyword">null</span> &amp;&amp; attributeName.equals(AutowireCandidateQualifier.VALUE_KEY) &amp;&amp;</span><br><span class="line">expectedValue <span class="hljs-keyword">instanceof</span> String &amp;&amp; bdHolder.matchesName((String) expectedValue)) &#123;</span><br><span class="line"><span class="hljs-comment">// Fall back on bean name (or alias) match</span></span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (actualValue == <span class="hljs-keyword">null</span> &amp;&amp; qualifier != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Fall back on default, but only if the qualifier is present</span></span><br><span class="line">actualValue = AnnotationUtils.getDefaultValue(annotation, attributeName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (actualValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">actualValue = typeConverter.convertIfNecessary(actualValue, expectedValue.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!expectedValue.equals(actualValue)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来细细的说一下这个方法。</p><ol><li>该方法首先获取到注解的类型，一般情况下，这里拿到的注解就是 @Qualifier，如果使用了自定义注解的话，那么这里拿到的就是自定义注意，需要和小伙伴么强调一下，这里的注解是指 A 类中 B 属性上的注解（并非提供 B 对象的 Java 方法上的注解）。</li><li>接下来会执行 bd.getQualifier 方法，分别以第 1 步中拿到的注解全路径（org.springframework.beans.factory.annotation.Qualifier）和短路径（Qualifier）为参数，去搜索看是否能够获取到一个 qualifier。那么什么时候能够获取到值呢？本文 1.4 小节的情况可以获取到值，如：A 类有一个 B 属性，B 属性上有一个 @MyQualifier 注解，那么这里就会尝试去 RootBeanDefinition 中也找到一个该注解，其实就是去看 XML 中是否有配置，XML 如果有配置，则直接进入第 8 步。</li><li>当然，对于 1.4 小节这种案例启示我们日常开发中很少写，所以一般情况下，经过第 2 步之后，qualifier 变量还是为 null。那么接下来就调用 getQualifiedElementAnnotation 方法去查找注解。这个方法松哥感觉也是一个特别冷门的用法。该方法的本质实际上去查找当前 Bean 的定义中，是否存在 qualifiedElement，如果存在，则直接读取 qualifiedElement 上的 @Qualifier 注解。松哥举一个简单例子，来给大家演示一下什么情况下，getQualifiedElementAnnotation 方法返回值不为 null。</li></ol><p>A 类和 1.1 小节的案例一样，依然是通过 @Qualifier 注解去描述想要注入一个名为 b1 的 Bean，B 类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"b1"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在配置文件中加载：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.scan(<span class="hljs-string">"org.javaboy.bean.p3"</span>);</span><br><span class="line">RootBeanDefinition bd = <span class="hljs-keyword">new</span> RootBeanDefinition();</span><br><span class="line">bd.setBeanClass(B.class);</span><br><span class="line">bd.setQualifiedElement(B.class);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"b1"</span>, bd);</span><br><span class="line">ctx.refresh();</span><br></pre></td></tr></table></figure><p>大家看到，在这个配置文件中，我向 Spring 容器手动注册了一个 BeanDefinition，并为这个 BeanDefinition 设置了 QualifiedElement 属性。如此之后，在上面第 3 步的方法中，系统就会找到这个 QualifiedElement（即 B.class），然后读取出来该类上面的注解，如果读取到了，就直接进入到第 7 步。</p><p>回到主线，我们来继续看第 4 步。</p><ol start="4"><li>一般来说，第 3 步这种写法也很少见，所以基本上都会进入到第 4 步，现在是执行 getFactoryMethodAnnotation 方法，这个方法就是去找到 JavaConfig 配置类中 b1() 方法上的 @Qualifier 注解，这种是比较常见的，一般在这一步，就可以拿到 targetAnnotation 了，获取到 targetAnnotation 之后继续执行第 步。</li><li>当然，第 4 步也有可能没有拿到 targetAnnotation，虽然这种情况比较少见，但是也和小伙伴们说一下，如果第 4 步没有获取到 targetAnnotation，那么接下来会调用 getResolvedDecoratedDefinition 方法获取到一个装饰之后的 BeanDefinition，然后继续获取从中获取 targetAnnotation。这里所谓的 DecoratedDefinition 其实就是一个 BeanDefinitionHolder，这个里边保存了一个 BeanDefinition，这种配置其实比较繁琐，一般我们很少用，给小伙伴们简单演示下，如下：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">RootBeanDefinition rbd = <span class="hljs-keyword">new</span> RootBeanDefinition();</span><br><span class="line">GenericBeanDefinition bd = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">bd.setBeanClass(B.class);</span><br><span class="line">rbd.setDecoratedDefinition(<span class="hljs-keyword">new</span> BeanDefinitionHolder(bd, <span class="hljs-string">"b99"</span>));</span><br><span class="line">rbd.setBeanClass(B.class);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"b99"</span>, rbd);</span><br><span class="line">ctx.register(JavaConfig.class);</span><br><span class="line">ctx.refresh();</span><br></pre></td></tr></table></figure><p>这个日常开发中应该很少用，小伙伴们了解即可。</p><p>回到住下，我么继续来看第 6 步。</p><ol start="6"><li>如果前面几步还是没有拿到 targetAnnotation，那么接下来就要去类上面查找，查看目标类上是否有 @Qualifier 注解了（如果我们在 B 类上添加了 @Qualifier 注解，就会在这里拿到），去类上面找注解的时候，分别先按照 bdHolder 中的名字找类型，按照类型找注解以及按照 db 类型找注解的方式去找。关于 targetAnnotation 的各种查找方式就上面这些，其实就是去找一下目标类上是否存在 @Qualifier 注解，存在的话，就拿到这个注解。</li><li>接下来，会有一个有意思的判断，即，如果找到了 targetAnnotation，并且 targetAnnotation 还等于参数传进来的 annotation，那么这不就是 1.2 小节的情况吗？找到的 targetAnnotation 是 JavaConfig 类中 Bean 方法上的注解，参数传进来的则是 A 类中 B 属性上的注解，这俩相同的话，那没错了，这个 Bean 就正是需要的。</li><li>如果前面几步都没能 return，那么接下来就把传入的参数 annotation 中的属性都提取出来，如果参数上没有任何属性，即相当于 A 类的 B 属性上，虽然有 @Qualifier 注解，但是只有该注解，没有任何属性，那么显然匹配不上，直接返回 false。</li><li>当第 8 步成功拿到传入参数的 annotation 属性之后，接下来就遍历这些属性，获取到属性的 key 是 attributeName 以及 value 是 expectedValue，如果在前面第 2 步中拿到了 qualifier，那么就从 qualifier 中获取对应的属性值进行比较；如果 qualifier 中没有获取到 value，则从 BeanDefinition 的属性去获取也可以，但是很显然这些一般都是没有值的，拿不到。</li><li>如果还没有拿到 actualValue，并且 attributeName 是 value，并且 expectedValue 是字符串类型，然后判断 bdHolder.matchesName 中是否包含 expectedValue，这个判断实质上就是查看 bdHolder 中定义的 Bean 名称、别名等，是否和 expectedValue 相等，本文 1.1 小节中的案例，将在这里被比对到然后 continue，这里之所以不急着直接 return，是担心后面还有其他属性不满足，如果后续其他属性都满足条件，那么直接在方法结尾处返回 true 即可。</li><li>如果前面还是没能返回，并且 qualifier 不为空，那么就尝试去获取传入注解的默认值，然后进行比较。</li></ol><p>以上就是 checkQualifier 方法完整的比较流程。总结一下，其实就两步：</p><ul><li>先去找目标类上是否也存在 @Qualifier 注解，就是前面 7 步找 targetAnnotation 的过程，如果目标类上也存在该注解，直接做注解的比对即可，就不去管属性了。</li><li>如果没有 targetAnnotation，即 @Qualifier 注解只出现在需求的一方（A 类属性上才有），那么就把这个唯一的 @Qualifier 注解的属性拿出来，分别跟 XML 配置、BeanDefinition 属性、BeanName 等做比较，如果比对上了，就返回 true。</li></ul><p>checkQualifier 方法看完了，现在我们回到 checkQualifiers 方法中，如果 checkQualifier 返回 true，那么 checkMeta 就会为 false，这个表示是否检查元注解，即如果 checkQualifier 比对失败，就会遍历当前注解的元注解，找到 @Qualifier，然后继续调用 checkQualifier 方法进行比较，后续逻辑和前面基本一致，我就不赘述了。</p><p>好了，经过上面一整套流程后，findAutowireCandidates 方法所返回的 matchingBeans 就只有一个目标 Bean 了～</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>今天和小伙伴们梳理了一下 @Qualifier 注解的作用，老实说，松哥在源码分析的过程中，也 GET 到 Spring 许多新的玩法，感兴趣的小伙伴赶紧去试试吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;今天想和小伙伴们聊一聊 @Qualifier 注解的完整用法，同时也顺便分析一下它的实现原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>透过源码，捋清楚循环依赖到底是如何解决的！</title>
    <link href="http://www.javaboy.org/2023/0809/spring-cycle-reference.html"/>
    <id>http://www.javaboy.org/2023/0809/spring-cycle-reference.html</id>
    <published>2023-08-09T09:17:52.000Z</published>
    <updated>2023-09-12T09:40:17.652Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>以下内容基于 Spring6.0.4。</p><p>关于 Spring 循环依赖，松哥已经连着发了三篇文章了，本篇文章松哥从源码的角度来和小伙伴们捋一捋 Spring 循环依赖到底是如何解决了。如果没看过前面的文章建议先看一下，大家在面试中如果遇到循环依赖相关的问题，其实看前面三篇文章就可以答出来了，本文主要是从源码角度来验证一下我们前面文章所讲的内容是无误的。</p><a id="more"></a><p>前三篇传送门：</p><ol><li><a href="https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA" target="_blank" rel="noopener">如何通过三级缓存解决 Spring 循环依赖</a></li><li><a href="https://mp.weixin.qq.com/s/Un8pyET2XDXpDY4FnRbwXw" target="_blank" rel="noopener">Spring 能解决所有循环依赖吗？</a></li><li><a href="https://mp.weixin.qq.com/s/GjI4xPGXscCGQtcalwnJKQ" target="_blank" rel="noopener">@Lazy 注解为啥就能破解死循环？</a></li></ol><p>小伙伴们一定要先熟悉前面文章的内容，否则今天的源码可能会看起来有些吃力。</p><p>接下来我通过一个简单的循环依赖的案例，来和大家梳理一下完整的 Bean 循环依赖处理流程。</p><h2 id="1-案例设计"><a href="#1-案例设计" class="headerlink" title="1. 案例设计"></a>1. 案例设计</h2><p>假设我有如下 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样一个简单的循环依赖，默认情况下，A 会被先加载，然后在 A 中做属性填充的时候，去创建了 B，创建 B 的时候又需要 A，就会从缓存中拿到 A，大致流程如此，接下来我们结合源码来验证一下这个流程。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>首先我们来看获取 Bean 的时候，如何利用这三级缓存。</p><p>小伙伴们知道，获取 Bean 涉及到的就是 getBean 方法，像我们上面这个案例，由于都是单例的形式，所以 Bean 的初始化其实在容器创建的时候就完成了。</p><p><img src="http://img.itboyhub.com/2022/08/20230725204634.png" alt></p><p>在 preInstantiateSingletons 方法中，又调用到 <code>AbstractBeanFactory#getBean</code> 方法，进而调用到 <code>AbstractBeanFactory#doGetBean</code> 方法。</p><p><img src="http://img.itboyhub.com/2022/08/20230710191829.png" alt></p><p>Bean 的初始化就是从这里开始的，我们就从这里来开始看起吧。</p><h3 id="2-1-doGetBean"><a href="#2-1-doGetBean" class="headerlink" title="2.1 doGetBean"></a>2.1 doGetBean</h3><p>AbstractBeanFactory#doGetBean（方法较长，节选部分关键内容）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">doGetBean</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, <span class="hljs-keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">String beanName = transformedBeanName(name);</span><br><span class="line">Object beanInstance;</span><br><span class="line"><span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-keyword">null</span> &amp;&amp; args == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line"><span class="hljs-comment">// We're assumably within a circular reference.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="hljs-comment">// Not found -&gt; check parent.</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory abf) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line">StartupStep beanCreation = <span class="hljs-keyword">this</span>.applicationStartup.start(<span class="hljs-string">"spring.beans.instantiate"</span>)</span><br><span class="line">.tag(<span class="hljs-string">"beanName"</span>, name);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (requiredType != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">beanCreation.tag(<span class="hljs-string">"beanType"</span>, requiredType::toString);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"><span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="hljs-string">"Circular depends-on relationship between '"</span> + beanName + <span class="hljs-string">"' and '"</span> + dep + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="hljs-string">"'"</span> + beanName + <span class="hljs-string">"' depends on missing bean '"</span> + dep + <span class="hljs-string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Create bean instance.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较长，我来和大家说几个关键的点：</p><ol><li>首先这个方法一开始就调用了 getSingleton 方法，这个是尝试从三级缓存中获取到想要的 Bean，但是，当我们第一次初始化 A 的时候，很显然这一步是无法获取到 A 的实例的，所以这一步会返回 null。</li><li>如果第一步拿到了 Bean，那么接下来就进入到 if 分支中，直接获取到想要的 beanInstance 实例；否则进入到第三步。</li><li>如果第一步没有从三级缓存中拿到 Bean，那么接下来就要检查是否是循环依赖了，首先调用 isPrototypeCurrentlyInCreation 方法判断当前 Bean 是否已经在创建了，如果已经在创建了，那么显然要抛异常出去了（BeanCurrentlyInCreationException）。接下来就去 parent 容器中各种查找，看能否找到需要的 Bean，Spring 中的父子容器问题松哥在之前的文章中也已经讲过了，小伙伴们可以参考：<a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">Spring 中的父子容器是咋回事？</a>。</li><li>如果从父容器中也没找到 Bean，那么接下来就会调用 markBeanAsCreated 方法来标记当前 Bean 已经创建或者正准备创建。</li><li>接下来会去标记一下创建步骤，同时检查一下 Bean 的 dependsOn 属性是否存在循环关系，这些跟我们本文关系都不大，我就不去展开了。</li><li>关键点来了，接下来判断如果我们当前 Bean 是单例的，那么就调用 getSingleton 方法去获取一个实例，该方法的第二个参数一个 Lambda 表达式，表达式的核心内容就是调用 createBean 方法去创建一个 Bean 实例，该方法将不负众望，拿到最终想要的 Bean。</li></ol><p>以上就是 doGetBean 方法中几个比较重要的点。</p><p>其中有两个方法我们需要展开讲一下，第一个方法就是去三级缓存中查询 Bean 的 getSingleton 方法（步骤一），第二个方法则是去获取到 Bean 实例的 getSingleton 方法（步骤六），这是两个重载方法。</p><p>接下来我们就来分析一下这两个方法。</p><h3 id="2-2-查询三级缓存"><a href="#2-2-查询三级缓存" class="headerlink" title="2.2 查询三级缓存"></a>2.2 查询三级缓存</h3><p>DefaultSingletonBeanRegistry#getSingleton：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="hljs-comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="hljs-keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先去 singletonObjects 中查找，这就是所谓的一级缓存，如果这里能直接找到想要的对象，那么直接返回即可。</li><li>如果一级缓存中不存在想要的 Bean，那么接下来就该去二级缓存 earlySingletonObjects 中查找了，二级缓存要是有我们想要的 Bean，那么也是直接返回即可。</li><li>二级缓存中如果也不存在，那么就是加锁然后去三级缓存中查找了，三级缓存是 singletonFactories，我们从 singletonFactories 中获取到的是一个 ObjectFactory 对象，这是一个 Lambda 表达式，调用这里的 getObject 方法最终有可能会促成提前 AOP，至于这个 Lambda 表达式的内容，松哥在前面的文章中已经和小伙伴们介绍过了，这里先不啰嗦（<a href="https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA" target="_blank" rel="noopener">如何通过三级缓存解决 Spring 循环依赖</a>）。</li><li>如果走到三级缓存这一步了，从三级缓存中拿到了想要的数据，那么就把数据存入到二级缓存 earlySingletonObjects 中，以备下次使用。同时，移除三级缓存中对应的数据。</li></ul><p>当我们第一次创建 A 对象的时候，很显然三级缓存中都不可能有数据，所以这个方法最终返回 null。</p><h3 id="2-3-获取-Bean-实例"><a href="#2-3-获取-Bean-实例" class="headerlink" title="2.3 获取 Bean 实例"></a>2.3 获取 Bean 实例</h3><p>接下来看 2.1 小节步骤六的获取 Bean 的方法。</p><p>DefaultSingletonBeanRegistry#getSingleton（方法较长，节选部分关键内容）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line"><span class="hljs-string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line"><span class="hljs-string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">&#125;</span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="hljs-keyword">boolean</span> newSingleton = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">boolean</span> recordSuppressedExceptions = (<span class="hljs-keyword">this</span>.suppressedExceptions == <span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">newSingleton = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (newSingleton) &#123;</span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这个方法首先也是尝试从一级缓存中获取到想要的 Bean，如果 Bean 为 null，就开始施法了。</li><li>首先会去判断一下，如果这个工厂的单例正在销毁，那么这个 Bean 的创建就不被允许。</li><li>接下来会有一堆准备工作，关键点在 <code>singletonFactory.getObject();</code> 地方，这个就是方法第二个参数传进来的回调函数，将来在回调函数中，会调用到 createBean 方法，真正开始 A 这个 Bean 的创建。将 A 对象创建成功之后，会把 newSingleton 设置为 true，第 4 步会用到。</li><li>现在调用 addSingleton 方法，把创建成功的 Bean 添加到缓存中。</li></ol><p>我们来看下 addSingleton 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line"><span class="hljs-keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="hljs-keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看一下，一级缓存中存入 Bean，二级缓存和三级缓存移除该 Bean，同时在 registeredSingletons 集合中记录一下当前 Bean 已经创建。</p><p>所以现在的重点其实又回到了 createBean 方法了。</p><h3 id="2-4-createBean"><a href="#2-4-createBean" class="headerlink" title="2.4 createBean"></a>2.4 createBean</h3><p>createBean 方法其实就到了 Bean 的创建流程了。bean 的创建流程在前面几篇 Spring 源码相关的文章中也都有所涉猎，所以今天我就光说一些跟本文主题相关的几个点。</p><p>createBean 方法最终会调用到 AbstractAutowireCapableBeanFactory#doCreateBean 方法，这个方法也是比较长的，而我是关心如下几个地方：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="hljs-keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我比较在意的有两个地方，一个是调用 addSingletonFactory 方法向三级缓存中添加回调函数，回调函数是 getEarlyBeanReference，如果有需要，将来会通过这个回调提前进行 AOP，即使没有 AOP，就是普通的循环依赖，三级缓存也是会被调用的，这个大家继续往后看就知道了，<strong>另外还有一个比较重要的地方，在本方法一开始的时候，就已经创建出来 A 对象了，这个时候的 A 对象是一个原始 Bean，即单纯的只是通过反射把对象创建出来了，Bean 还没有经历过完整的生命周期，这里 getEarlyBeanReference 方法的第三个参数就是该 Bean，这个也非常重要，牢记，后面会用到。</strong></p><p>第二个地方就是 populateBean 方法，当执行到这个方法的时候，A 对象已经创建出来了，这个方法是给 A 对象填充属性用的，因为接下来要注入 B 对象，就在这个方法中完成的。</p><p>由于我们第 1 小节是通过 @Autowired 来注入 Bean 的，所以现在在 populateBean 方法也主要是处理 @Autowired 注入的情况，那么这个松哥之前写过文章，小伙伴们参考<a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>，具体的注入细节我这里就不重复了，单说在注入的过程中，会经过一个 DefaultListableBeanFactory#doResolveDependency 方法，这个方法就是用来解析 B 对象的（至于如何到达 doResolveDependency 方法的，小伙伴们参考 <a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a>一文）。</p><p>doResolveDependency 方法也是比较长，我这里贴出来和本文相关的几个关键地方：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doResolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String beanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line"><span class="hljs-keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;</span><br><span class="line">raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">String autowiredBeanName;</span><br><span class="line">Object instanceCandidate;</span><br><span class="line"><span class="hljs-keyword">if</span> (matchingBeans.size() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line"><span class="hljs-keyword">if</span> (autowiredBeanName == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span></span><br><span class="line"><span class="hljs-comment">// possibly it was meant to be an empty collection of multiple regular beans</span></span><br><span class="line"><span class="hljs-comment">// (before 4.3 in particular when we didn't even look for collection beans).</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// We have exactly one match.</span></span><br><span class="line">Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">autowiredBeanName = entry.getKey();</span><br><span class="line">instanceCandidate = entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (autowiredBeanNames != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (instanceCandidate <span class="hljs-keyword">instanceof</span> Class) &#123;</span><br><span class="line">instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在这个方法中，首先调用 findAutowireCandidates 方法，以类型为依据，找到所有满足条件的 Class 并组成一个 Map 返回。例如第一小节的案例，这里就会找到所有 B 类型的 Class，通过一个 Map 返回。</li><li>如果第一步返回的 Map 存在多条记录，那么就必须从中挑选一个出来，这就是 <code>matchingBeans.size() &gt; 1</code> 的情况。</li><li>如果第一步返回的 Map 只有一条记录，那么就从 Map 中提取出来 key 和 value，此时的 value 是一个 Class，所以接下来还要调用 <code>descriptor.resolveCandidate</code> 去完成 Class 到对象的转变。</li></ol><p>而 <code>descriptor.resolveCandidate</code> 方法又开启了新一轮的 Bean 初始化，只不过这次初始化的 B 对象，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveCandidate</span><span class="hljs-params">(String beanName, Class&lt;?&gt; requiredType, BeanFactory beanFactory)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> beanFactory.getBean(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-后续流程"><a href="#2-5-后续流程" class="headerlink" title="2.5 后续流程"></a>2.5 后续流程</h3><p>后续流程其实就是上面的步骤，我就直接来跟大家说一说，就不贴代码了。</p><p>现在系统调用 <code>beanFactory.getBean</code> 方法去查找 B 对象，结果又是走一遍本文第二小节的所有流程，当 B 创建出来之后，也要去做属性填充，此时需要在 B 中注入 A，那么又来到本文的 2.4 小节，最终又是调用到 <code>resolveCandidate</code> 方法去获取 A 对象。</p><p>此时，在获取 A 对象的过程中，又会调用到 doGetBean 这个方法，在这个方法中调用 <code>getSingleton</code> 的时候（2.1 小节的第一步），这个时候的执行逻辑就跟前面不一样了，我们再来看下这个方法的源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="hljs-comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="hljs-keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在还是尝试从三级缓存中获取 A，此时一二级缓存中还是没有 A，但是三级缓存中有一个回调函数，当执行 <code>singletonFactory.getObject()</code> 方法的时候，就会触发该回调函数，这个回调函数就是我们前面 2.4 小节提到的 getEarlyBeanReference 方法，我们现在来看下这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有一个参数 Bean，这个参数 Bean 会经过一些后置处理器处理之后返回，后置处理器主要是看一下这个 Bean 是否需要 AOP，如果需要就进行 AOP 处理，如果不需要，直接就把这个参数 Bean 返回就行了。至于这个参数是哪来的，我在 2.4 小节中已经加黑标记出来了，这个参数 Bean 其实就是原始的 A 对象！</p><p>好了，现在 B 对象就从缓存池中拿到了原始的 A 对象，B 对象属性注入完毕，对象创建成功，进而导致 A 对象也创建成功。</p><p>大功告成。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>老实说，如果小伙伴们认认真真看过松哥最近发的 Spring 源码文章，今天的内容很好懂～至此，Spring 循环依赖，从思路到源码，都和大家分析完毕了～感兴趣的小伙伴可以 DEBUG 走一遍哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;关于 Spring 循环依赖，松哥已经连着发了三篇文章了，本篇文章松哥从源码的角度来和小伙伴们捋一捋 Spring 循环依赖到底是如何解决了。如果没看过前面的文章建议先看一下，大家在面试中如果遇到循环依赖相关的问题，其实看前面三篇文章就可以答出来了，本文主要是从源码角度来验证一下我们前面文章所讲的内容是无误的。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码解读视频来啦</title>
    <link href="http://www.javaboy.org/2023/0807/spring-video.html"/>
    <id>http://www.javaboy.org/2023/0807/spring-video.html</id>
    <published>2023-08-07T09:17:35.000Z</published>
    <updated>2023-09-12T09:40:12.703Z</updated>
    
    <content type="html"><![CDATA[<p>关注松哥最近文章的小伙伴可能都发现了，松哥最近一直在更 Spring 源码相关的文章，而且小伙伴们的评价都还不错哦～</p><a id="more"></a><p><img src="http://img.itboyhub.com/2022/08/iShot_2023-08-05_21.23.49.png" alt><br><img src="http://img.itboyhub.com/2022/08/iShot_2023-08-05_21.23.40.png" alt><br><img src="http://img.itboyhub.com/2022/08/iShot_2023-08-05_21.23.12.png" alt><br><img src="http://img.itboyhub.com/2022/08/iShot_2023-08-05_21.29.15.png" alt></p><p>小伙伴们的评价给了我信心，思虑再三，我决定出一套 Spring 源码解析的视频课程。</p><p>Spring 在 Java 企业级开发中的重要性自不必多说，凡是做这一行，Spring 基本上都会涉及到，然而 Spring 博大精深，从第一次发布到现在已经 21 年了，我们在日常开发中接触过很多框架，生命力超过 20 年的确实不多见，由此我们也可以看到，Spring 确实有其独到之处。</p><p>然而很多小伙伴对于 Spring 的应用停留在基本使用阶段，对于进阶用法往往不太熟悉，这样在日常开发中遇到一些跟 Spring 相关的 BUG 往往不知道从何处入手。如果对 Spring 源码有一定的了解，那么不仅能够应付日常的开发工作，同时也可以看看优秀的框架到底是如何设计的，我们天天背 23 种设计模式，但是到了工作中很多人不知道该如何使用，那么不妨来看看 Spring 源码，看看 Spring 源码是如何使用设计模式的。</p><p>另一方面，Spring 源码也是大家从初中级工程师迈向高级工程师必须跨过的一道坎，并不是说你懂了 Spring 源码就是高级工程师或者架构师了，但是如果 Spring 你只会使用不懂原理，那么显然你不是一个高级工程师。</p><p>说了这么多，只是想告诉大家，作为一名 Java 工程师，Spring 源码对我们来说很重要。</p><p>那么我这套课程整体上我会分为两个部分：</p><p><strong>第一部分：</strong></p><p>这一部分我主要是想要和各位小伙伴分享 Spring 的基本用法，特别是包括一些比较冷门的用法。因为我在最近写文章中发现，很多小伙伴看源码看不懂，一个非常重要的原因是因为他不懂 Spring 的用法，或者是他只懂一些很简单的用法，这就导致在看源码的时候就不明白为啥会有这个东西。</p><p><img src="http://img.itboyhub.com/2022/08/20230805215457.png" alt></p><p>有的小伙伴可能知道松哥在 2020 年的时候出过一套 Spring 基础课发布在 B 站上，那么这次的基础课会在之前的基础之上，至少扩展 70% 的内容，一方面是因为之前课程是免费的，在时间精力有限的情况下，只能讲一些特别常见的用法，没有办法面面俱到；另一方面则是因为松哥自己本身也是在不断学习不断进步，2020 年到现在三年过去了，松哥在公司项目不断的实践中，对 Spring 也有了更多的理解，也有了更多的东西能够和小伙伴们分享了。</p><p><strong>第二部分：</strong></p><p>这一部分就主要是 Spring 的源码解析了。</p><p>源码解析我主要是从四个方面来和大家分享：</p><ol><li>IoC 容器源码解析。</li><li>AOP 源码解析。</li><li>JdbcTemplate。</li><li>Spring 事务解析。</li></ol><p>上面这四块，除了第三点相对来说容易一些，另外三个都相对复杂一点，1、2 点更是重中之重，算是整个 Spring 的核心。相信小伙伴们在面试之前背八股文的时候，多多少少都有背过一些 Spring 源码相关的内容，那么通过这次松哥的源码讲解，我会让大家对自己所背的八股文有更深一步的理解，知其然更知其所以然。松哥之前也写过一些关于源码的文章，但是整体感受是一些比较复杂的地方，文字的表现力还是稍逊于视频，用视频能够跟大家更好的分享出来这里边的条条框框。</p><p>以上就是本次视频课程的一个大致规划。</p><p>不知道小伙伴们平时有没有录过视频课程，如果有录过视频课程，应该知道视频录制是需要大量的时间投入的，用爱发电显然是不现实的，这件事要能保质保量持之以恒的做下去，还是需要有收益，大家都是成年人，这个应该很好理解。</p><p>这次松哥这套 Spring 源码深度解读视频定价 ¥399。目前刚开始录所以有 5 折优惠，即只要 199，买过 vhr 和 TienChin 的小伙伴应该都知道，后面随着录制内容越来越多，购买人数变多，优惠力度也会降低。</p><p>好啦，最后再统一回答大家几个关于视频的问题。</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码一人一码。至于小伙伴们推荐的阿里网盘等，由于空间、分享文件类型等限制，并无法用在加密视频分发中。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：视频可以试看吗？</strong></p><p>其实我最近在公号发的视频，大家都可以当作试看的，反正的录视频风格是不变的。小伙伴们主要看这种讲课风格是否能够接受。</p><p><strong>Q4：可以砍价吗？</strong></p><p>不可以，这个价格已经很便宜了，没法砍了（悄悄告诉大家，从 vhr 到 tienchin，暂时没有人砍价成功过），另外就是松哥是没有客服运营这些的，你加的微信就是我，咱都是纯粹的技术人，老实说我并不懂砍价，但是我会用沉默代表拒绝。</p><p><strong>Q5：视频多久更新完毕？</strong></p><p>我会争取在一个月之内更完第一部分，两个月之内更完第二部分。</p><p><strong>Q6：这套视频适合哪些人看？</strong></p><p>学习这套视频，有 Spring 基础更佳，没有也可以。对于有 Spring 基础的小伙伴来说，我会保证你学到一些之前从未了解到的 Spring 玩法，对于没有 Spring 基础的小伙伴来说，这套视频从 0 开始的，那一样也适合你。</p><p><strong>Q7：看视频有问题可以问吗？</strong></p><p>购买视频后我会统一拉一个微信群，视频有问题可以在群里交流。</p><p><strong>Q8：这套视频我能学到啥？</strong></p><p>从 Spring 基础用法到源码理解统统搞定。如果你还没接触过 Spring，这套视频从基础用法到源码分析，可以让大家一步到位掌握 Spring；如果已经有一些 Spring 使用经验了，那么这套视频可以帮你进一步提升，掌握 Spring 原理。不过需要提醒大家的是，这套视频不包括 SpringMVC 相关的内容。</p><hr><p><strong>好啦，5 折 199 抄底就在今天啦！</strong></p><p>P.s.：可能有小伙伴加了松哥多个微信，其实没有必要重复添加，任意一个都能找到我。当然，如果你还没有松哥微信，扫码加微信，<strong>备注 spring</strong>，发红包 199 上车吧（买过 vhr 或者 tienchin 的小伙伴可在此基础上再优惠 ¥30 哦）～</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png" alt></p><p>以下是最近发的一些 Spring 进阶内容的文章，小伙伴们可以参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/fsX45Sz47Xnnx5C_xQVRMg" target="_blank" rel="noopener">Spring AOP 中的代理对象是怎么创建出来的？</a></li><li><a href="https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA" target="_blank" rel="noopener">如何通过三级缓存解决 Spring 循环依赖</a></li><li><a href="https://mp.weixin.qq.com/s/GjI4xPGXscCGQtcalwnJKQ" target="_blank" rel="noopener">@Lazy 注解为啥就能破解死循环？</a></li><li><a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw" target="_blank" rel="noopener">@Autowired 到底是怎么把变量注入进来的？</a></li><li><a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">Spring 中的父子容器是咋回事？</a></li><li><a href="https://mp.weixin.qq.com/s/r3rnVhU8vr58Cw__UWOVLA" target="_blank" rel="noopener">Spring 中 BeanFactory 和 FactoryBean 有何区别？</a></li><li><a href="https://mp.weixin.qq.com/s/ZjN1XPamDaYZmvFbyI1KTQ" target="_blank" rel="noopener">BeanFactoryPostProcessor 和 BeanPostProcessor 有什么区别？</a></li><li><a href="https://mp.weixin.qq.com/s/L6QTK5RNFNTTu2fOd4SwMw" target="_blank" rel="noopener">用 Spring 管理 Controller，你觉得可行吗？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关注松哥最近文章的小伙伴可能都发现了，松哥最近一直在更 Spring 源码相关的文章，而且小伙伴们的评价都还不错哦～&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>最新版 Spring Security，该如何实现动态权限管理？</title>
    <link href="http://www.javaboy.org/2023/0804/spring-security-6-permission.html"/>
    <id>http://www.javaboy.org/2023/0804/spring-security-6-permission.html</id>
    <published>2023-08-04T09:17:17.000Z</published>
    <updated>2023-09-12T09:40:09.775Z</updated>
    
    <content type="html"><![CDATA[<p>在松哥之前的教程中，曾经和小伙伴们聊过动态权限管理的问题，大家在公众号江南一点雨后台回复 s用不了在松哥之前的教程中，曾经和小伙伴们聊过动态权限管理的问题，大家在公众号江南一点雨后台回复 ss 有lss 有oDF 教程。</p><a id="more"></a><p>但是，不知道小伙伴们是否有留意过，进入到 Spring Boot3 之后，Spring Security 现在也进化到 Spring Security6 了，Spring Security6 的用法跟之前比起来还是有很大差异，松哥之前写了篇文章和小伙伴们介绍 Spring Security6 中的一些变化：<a href="https://mp.weixin.qq.com/s/RXNt1M3KND4aJbr0ZhHing" target="_blank" rel="noopener">Spring Security6 全新写法，大变样！</a>。</p><p>最近有小伙伴说松哥你之前讲的动态权限定义的方式，新版中用不了了，我抽空看了下，今天就和小伙伴们聊聊这个话题。</p><h2 id="1-权限开发思路"><a href="#1-权限开发思路" class="headerlink" title="1. 权限开发思路"></a>1. 权限开发思路</h2><p>先来说权限开发的思路，当我们设计好 RBAC 权限之后，具体到代码层面，我们有两种实现思路：</p><ol><li>直接在接口/Service 层方法上添加权限注解，这样做的好处是实现简单，但是有一个问题就是权限硬编码，每一个方法需要什么权限都是代码中配置好的，后期如果想通过管理页面修改是不可能的，要修改某一个方法所需要的权限只能改代码。</li><li>将请求和权限的关系通过数据库来描述，每一个请求需要什么权限都在数据库中配置好，当请求到达的时候，动态查询，然后判断权限是否满足，这样做的好处是比较灵活，将来需要修改接口和权限之间的关系时，可以通过管理页面点击几下，问题就解决了，不用修改代码，松哥之前的 vhr 中就是这样做的。</li></ol><blockquote><p>有的小伙伴觉得第二种方案无法做到按钮级别的权限控制，这其实是一个误解。想要做到按钮级别的权限控制，只需要数据库中细化配置即可。</p></blockquote><h2 id="2-具体实践"><a href="#2-具体实践" class="headerlink" title="2. 具体实践"></a>2. 具体实践</h2><h3 id="2-1-旧方案回顾"><a href="#2-1-旧方案回顾" class="headerlink" title="2.1 旧方案回顾"></a>2.1 旧方案回顾</h3><p>在 vhr 中，松哥是通过重写两个类来和实现动态权限的。</p><p>第一个类是收集权限元数据的类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomFilterInvocationSecurityMetadataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterInvocationSecurityMetadataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAttributes</span><span class="hljs-params">(Object object)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="hljs-title">getAllConfigAttributes</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getAttributes 方法中，根据当前请求的 URL 地址（从参数 Object 中可提取出来），然后根据权限表中的配置，分析出来当前请求需要哪些权限并返回。</p><p>另外我还重写了一个决策器，其实决策器也可以不重写，就看你自己的需求，如果 Spring Security 自带的决策器无法满足你的需求，那么可以自己写一个决策器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUrlDecisionManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decide</span><span class="hljs-params">(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; configAttributes)</span> <span class="hljs-keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decide 方法就是做决策的地方，第一个参数中可以提取出当前用户具备什么权限，第三个参数是当前请求需要什么权限，比较一下就行了，如果当前用户不具备需要的权限，则直接抛出 AccessDeniedException 异常即可。</p><p>最后，通过 Bean 的后置处理器 BeanPostProcessor，将这两个配置类放到 Spring Security 的 FilterSecurityInterceptor 拦截器中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                    object.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">                    object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);</span><br><span class="line">                    <span class="hljs-keyword">return</span> object;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .and()</span><br><span class="line">            <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致上的逻辑就是如此，以上类完整代码小伙伴们可以参考 <a href="https://github.com/lenve/vhr。" target="_blank" rel="noopener">https://github.com/lenve/vhr。</a></p><h3 id="2-2-新方案"><a href="#2-2-新方案" class="headerlink" title="2.2 新方案"></a>2.2 新方案</h3><p>不过以上代码在目前最新的 Spring Security6 中用不了了，不是因为类过期了，而是因为类被移除了！哪个类被移除了？FilterSecurityInterceptor。</p><p>FilterSecurityInterceptor 这个过滤器以前是做权限处理的，但是在新版的 Spring Security6 中，这个拦截器被 AuthorizationFilter 代替了。</p><p>老实说，新版的方案其实更合理一些，传统的方案感觉带有很多前后端不分的影子，现在就往更纯粹的前后端分离奔去。</p><p>由于新版中连 FilterSecurityInterceptor 都不用了，所以旧版的方案显然行不通了，新版的方案实际上更加简单。</p><blockquote><p>虽然新旧写法不同，但是核心思路是一模一样。</p></blockquote><p>我们来看下新版的配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeHttpRequests(register -&gt; register.anyRequest().access((authentication, object) -&gt; &#123;</span><br><span class="line">                <span class="hljs-comment">//表示请求的 URL 地址和数据库的地址是否匹配上了</span></span><br><span class="line">                <span class="hljs-keyword">boolean</span> isMatch = <span class="hljs-keyword">false</span>;</span><br><span class="line">                <span class="hljs-comment">//获取当前请求的 URL 地址</span></span><br><span class="line">                String requestURI = object.getRequest().getRequestURI();</span><br><span class="line">                List&lt;MenuWithRoleVO&gt; menuWithRole = menuService.getMenuWithRole();</span><br><span class="line">                <span class="hljs-keyword">for</span> (MenuWithRoleVO m : menuWithRole) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (antPathMatcher.match(m.getUrl(), requestURI)) &#123;</span><br><span class="line">                        isMatch = <span class="hljs-keyword">true</span>;</span><br><span class="line">                        <span class="hljs-comment">//说明找到了请求的地址了</span></span><br><span class="line">                        <span class="hljs-comment">//这就是当前请求需要的角色</span></span><br><span class="line">                        List&lt;Role&gt; roles = m.getRoles();</span><br><span class="line">                        <span class="hljs-comment">//获取当前登录用户的角色</span></span><br><span class="line">                        Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.get().getAuthorities();</span><br><span class="line">                        <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">                            <span class="hljs-keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">                                <span class="hljs-keyword">if</span> (authority.getAuthority().equals(role.getName())) &#123;</span><br><span class="line">                                    <span class="hljs-comment">//说明当前登录用户具备当前请求所需要的角色</span></span><br><span class="line">                                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">true</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">if</span> (!isMatch) &#123;</span><br><span class="line">                    <span class="hljs-comment">//说明请求的 URL 地址和数据库的地址没有匹配上，对于这种请求，统一只要登录就能访问</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (authentication.get() <span class="hljs-keyword">instanceof</span> AnonymousAuthenticationToken) &#123;</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>);</span><br><span class="line">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                        <span class="hljs-comment">//说明用户已经认证了</span></span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthorizationDecision(<span class="hljs-keyword">false</span>);</span><br><span class="line">            &#125;))</span><br><span class="line">            .formLogin(form -&gt; </span><br><span class="line">            <span class="hljs-comment">//...</span></span><br><span class="line">            )</span><br><span class="line">            .csrf(csrf -&gt; </span><br><span class="line">            <span class="hljs-comment">//...</span></span><br><span class="line">            )</span><br><span class="line">            .exceptionHandling(e -&gt; </span><br><span class="line">            <span class="hljs-comment">//...</span></span><br><span class="line">            )</span><br><span class="line">            .logout(logout -&gt;</span><br><span class="line">            <span class="hljs-comment">//...</span></span><br><span class="line">            );</span><br><span class="line">    <span class="hljs-keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路还是和之前一样，只不过现在的工作都在 access 方法中完成。</p><p>access 方法的回调中有两个参数，第一个参数是 authentication，很明显，这就是当前登录成功的用户对象，从这里我们就可以提取出来当前用户所具备的权限。</p><p>第二个参数 object 实际上是一个 RequestAuthorizationContext，从这个里边可以提取出来当前请求对象 HttpServletRequest，进而提取出来当前请求的 URL 地址，然后依据权限表中的信息，判断出当前请求需要什么权限，再和 authentication 中提取出来的当前用户所具备的权限进行对比即可。</p><p>如果当前登录用户具备请求所需要的权限，则返回 <code>new AuthorizationDecision(true);</code>，否则返回 <code>new AuthorizationDecision(false);</code> 即可。</p><p>其实无论什么框架，只要能把其中一个版本掌握个 70%，以后无论它怎么升级，你都能快速上手！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在松哥之前的教程中，曾经和小伙伴们聊过动态权限管理的问题，大家在公众号江南一点雨后台回复 s用不了在松哥之前的教程中，曾经和小伙伴们聊过动态权限管理的问题，大家在公众号江南一点雨后台回复 ss 有lss 有oDF 教程。&lt;/p&gt;
    
    </summary>
    
      <category term="SpringSecurity" scheme="http://www.javaboy.org/categories/SpringSecurity/"/>
    
    
      <category term="SpringSecurity" scheme="http://www.javaboy.org/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>Spring 容器原始 Bean 是如何创建的？</title>
    <link href="http://www.javaboy.org/2023/0802/spring-bean-instance.html"/>
    <id>http://www.javaboy.org/2023/0802/spring-bean-instance.html</id>
    <published>2023-08-02T09:17:03.000Z</published>
    <updated>2023-09-12T09:40:06.529Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容基于 Spring6.0.4。</p><p>这个话题其实非常庞大，我本来想从 getBean 方法讲起，但一想这样讲完估计很多小伙伴就懵了，所以我们还是一步一步来，今天我主要是想和小伙伴们讲讲 Spring 容器创建 Bean 最最核心的 createBeanInstance 方法，这个方法专门用来创建一个原始 Bean 实例。</p><a id="more"></a><p>松哥这里就以 Spring 源码中方法的执行顺序为例来和小伙伴们分享。</p><h2 id="1-doCreateBean"><a href="#1-doCreateBean" class="headerlink" title="1. doCreateBean"></a>1. doCreateBean</h2><p>AbstractAutowireCapableBeanFactory#doCreateBean 就是 Bean 的创建方法，但是 Bean 的创建涉及到的步骤非常多，包括各种需要调用的前置后置处理器方法，今天我主要是想和大家聊聊单纯的创建 Bean 的过程，其他方法咱们后面文章继续。</p><p>在 doCreateBean 方法中，有如下一行方法调用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="hljs-keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line">Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createBeanInstance 这个方法就是真正的根据我们的配置去创建一个 Bean 了。</p><h2 id="2-createBeanInstance"><a href="#2-createBeanInstance" class="headerlink" title="2. createBeanInstance"></a>2. createBeanInstance</h2><p>先来看源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">createBeanInstance</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (beanClass != <span class="hljs-keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="hljs-string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line"><span class="hljs-keyword">boolean</span> resolved = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">boolean</span> autowireNecessary = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (args == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="hljs-keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Candidate constructors for autowiring?</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Preferred constructors for default construction?</span></span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line"><span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是核心的 Bean 的创建方法了，因此这个方法我来和大家详细分析一下。</p><h3 id="2-1-resolveBeanClass"><a href="#2-1-resolveBeanClass" class="headerlink" title="2.1 resolveBeanClass"></a>2.1 resolveBeanClass</h3><p>这个方法是用来解析出来当前的 beanClass 对象，它的<strong>核心逻辑就是根据我们在 XML 文件中配置的类的全路径，通过反射加载出来这个 Class</strong>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">protected</span> Class&lt;?&gt; resolveBeanClass(RootBeanDefinition mbd, String beanName, Class&lt;?&gt;... typesToMatch)</span><br><span class="line"><span class="hljs-keyword">throws</span> CannotLoadBeanClassException &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> mbd.getBeanClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会调用 <code>mbd.hasBeanClass()</code> 方法去判断是否已经通过反射加载出来 beanClass 了，如果加载出来了就直接返回，没有加载的话，就继续执行下面的 doResolveBeanClass 去加载。</p><blockquote><p>什么时候会走 if 这条线呢？松哥举一个例子，如果我们设置某一个 Bean 的 Scope 是 prototype 的话，那么当第二次获取该 Bean 的实例的时候，就会走 if 这条线。</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> Class&lt;?&gt; doResolveBeanClass(RootBeanDefinition mbd, Class&lt;?&gt;... typesToMatch)</span><br><span class="line"><span class="hljs-keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">String className = mbd.getBeanClassName();</span><br><span class="line"><span class="hljs-keyword">if</span> (className != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object evaluated = evaluateBeanDefinitionString(className, mbd);</span><br><span class="line"><span class="hljs-keyword">if</span> (!className.equals(evaluated)) &#123;</span><br><span class="line"><span class="hljs-comment">// A dynamically resolved expression, supported as of 4.2...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (evaluated <span class="hljs-keyword">instanceof</span> Class&lt;?&gt; clazz) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (evaluated <span class="hljs-keyword">instanceof</span> String str) &#123;</span><br><span class="line">className = str;</span><br><span class="line">freshResolve = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Invalid class name expression result: "</span> + evaluated);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (freshResolve) &#123;</span><br><span class="line"><span class="hljs-comment">// When resolving against a temporary class loader, exit early in order</span></span><br><span class="line"><span class="hljs-comment">// to avoid storing the resolved Class in the bean definition.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (dynamicLoader != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> dynamicLoader.loadClass(className);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ClassUtils.forName(className, dynamicLoader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Resolve regularly, caching the result in the BeanDefinition...</span></span><br><span class="line"><span class="hljs-keyword">return</span> mbd.resolveBeanClass(beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按理说，根据我们配置的类的全路径加载出来一个 Class 应该是非常容易的，直接 Class.forName 就可以了。</p><p>但是！！！</p><p>如果对 Spring 用法比较熟悉的小伙伴就知道，配置 Class 全路径的时候，我们不仅可以像下面这样老老实实配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.Book"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>我们甚至可以使用 SpEL 来配置 Bean 名称，例如我有如下类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanNameUtils</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"org.javaboy.bean.User"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个 getName 方法，这个方法返回的是一个类的全路径，现在我们在 XML 文件中可以这样配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.BeanNameUtils"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"beanNameUtils"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"#&#123;beanNameUtils.name&#125;"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在 XML 的 class 属性中，我们可以直接使用 SpEL 去引用一个方法的执行，用该方法的返回值作为 class 的值。</p><p>了解了 Spring 中的这个玩法，再去看上面的源码就很好懂了：</p><ul><li>首先调用 <code>mbd.getBeanClassName();</code> 去获取到类路径。</li><li>接下来调用 <code>evaluateBeanDefinitionString</code> 方法进行 SpEL 运算，这个运算的目的是为了解析 className 中的 SpEL 表达式，当然，一般情况下 className 就是一个普通的字符串，不是 SpEL 表达式，那么解析完成之后就还是原本的字符串。如果是 className 是一个 SpEL，那么合法的解析结果分为两种：<ul><li>首先就是解析之后拿到了一个 Class，那这个就是我们想要的结果，直接返回即可。</li><li>要么就是解析出来是一个字符串，松哥上面举的例子就是这种情况，那么就把这个字符串赋值给 className，并且将 freshResolve 属性设置为 true，然后在接下来的 if 分支中去加载 Class。</li></ul></li></ul><p>当然，上面这些都是处理特殊情况，一般我们配置的普通 Bean，都是直接走最后一句 <code>mbd.resolveBeanClass(beanClassLoader)</code>，这个方法的逻辑其实很好懂，我把代码贴出来小伙伴们来瞅一瞅：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">public</span> Class&lt;?&gt; resolveBeanClass(<span class="hljs-meta">@Nullable</span> ClassLoader classLoader) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">String className = getBeanClassName();</span><br><span class="line"><span class="hljs-keyword">if</span> (className == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt; resolvedClass = ClassUtils.forName(className, classLoader);</span><br><span class="line"><span class="hljs-keyword">this</span>.beanClass = resolvedClass;</span><br><span class="line"><span class="hljs-keyword">return</span> resolvedClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就相当直白了，根据 className 加载出来 Class 对象，然后给 beanClass 属性也设置上值，这就和一开始的 <code>if (mbd.hasBeanClass())</code> 对应上了。</p><p>好了，到此，我们总算是根据 className 拿到 Class 对象了。</p><h3 id="2-2-Supplier-和-factory-method"><a href="#2-2-Supplier-和-factory-method" class="headerlink" title="2.2 Supplier 和 factory-method"></a>2.2 Supplier 和 factory-method</h3><p>好了，回到一开始的源码中，接下来该执行如下两行代码了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="hljs-keyword">if</span> (instanceSupplier != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd.getFactoryMethodName() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个松哥在前面的文章中和小伙伴们已经讲过了（<a href>Spring5 中更优雅的第三方 Bean 注入</a>）：前面的 obtainFromSupplier 方法是 Spring5 开始推出来的 Supplier，通过回调的方式去获取一个对象；第二个方法 instantiateUsingFactoryMethod 则是通过配置的 factory-method 来获取到一个 Bean 实例。</p><p>对这两个方法不熟悉的小伙伴可以参考前面的文章：<a href>Spring5 中更优雅的第三方 Bean 注入</a>。</p><h3 id="2-3-re-create-逻辑"><a href="#2-3-re-create-逻辑" class="headerlink" title="2.3 re-create 逻辑"></a>2.3 re-create 逻辑</h3><p>继续回到一开始的源码中，接下来是一段 re-create 的处理逻辑，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">boolean</span> resolved = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">boolean</span> autowireNecessary = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (args == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="hljs-keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面的介绍，我们现在已经获取到 Class 对象了，接下来直接调用相应的构造方法就可以获取到 Bean 实例了。但是这个 Class 对象可能存在多个构造方法，所以还需要一堆流程去确定到底调用哪个构造方法。</p><p>所以这里会先去判断 resolvedConstructorOrFactoryMethod 是否不为空，不为空的话，说明这个 Bean 之前已经创建过了，该用什么方法创建等等问题都已经确定了，所以这次就不用重新再去确定了（<code>resolved = true</code>）。另一方面，autowireNecessary 表示构造方法的参数是否已经处理好了，这个属性为 true 则表示构造方法的参数已经处理好了，那么就可以调用 autowireConstructor 方法去创建一个 Bean 出来，否则调用 instantiateBean 方法初始化 Bean。</p><p>这里涉及到的 autowireConstructor 和 instantiateBean 方法我们先不细说了，因为在后面还会再次涉及到。</p><h3 id="2-4-构造器注入"><a href="#2-4-构造器注入" class="headerlink" title="2.4 构造器注入"></a>2.4 构造器注入</h3><p>继续回到一开始的源码中，接下来就是针对各种处理器的预处理了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看 determineConstructorsFromBeanPostProcessors 方法，这个方法主要是考虑到你可能提供了 SmartInstantiationAwareBeanPostProcessor，松哥在前面的文章中和大家专门讲过 BeanPostProcessor（<a href="https://mp.weixin.qq.com/s/ZjN1XPamDaYZmvFbyI1KTQ" target="_blank" rel="noopener">BeanFactoryPostProcessor 和 BeanPostProcessor 有什么区别？</a>），这里的 SmartInstantiationAwareBeanPostProcessor 算是 BeanPostProcessor 的一种，也是 Bean 的一种增强器。SmartInstantiationAwareBeanPostProcessor 中有一个 determineCandidateConstructors 方法，这个方法返回某一个 Bean 的构造方法，将来可以通过这个构造方法初始化某一个 Bean。</p><p>我给大家举一个简单例子，假设我有如下类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"=====no args====="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(ObjectProvider&lt;String&gt; username)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"args==username"</span>);</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username.getIfAvailable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter/toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我在 Spring 容器中注册这个对象：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照我们已有的知识，这个将来会调用 User 的无参构造方法去完成 User 对象的初始化。</p><p>但是现在，假设我添加如下一个处理器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySmartInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartInstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) <span class="hljs-keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"user"</span>.equals(beanName)) &#123;</span><br><span class="line">            Constructor&lt;?&gt; constructor = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                constructor = beanClass.getConstructor(ObjectProvider.class);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Constructor[]&#123;constructor&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> SmartInstantiationAwareBeanPostProcessor.<span class="hljs-keyword">super</span>.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 determineCandidateConstructors 方法中，返回一个有参构造方法，那么将来 Spring 容器会通过这里返回的有参构造方法去创建 User 对象，而不是通过无参构造方法去创建 User 对象。</p><p>最后，将这个处理器注册到 Spring 容器：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.MySmartInstantiationAwareBeanPostProcessor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>现在，当我们启动 Spring 容器的时候，User 就是通过有参构造方法初始化的，而不是无参构造方法。之所以会这样，就是因为本小节一开始提到的源码 <code>determineConstructorsFromBeanPostProcessors</code>，这个方法就是去查看有无 SmartInstantiationAwareBeanPostProcessor，如果有，就调用对应的方法找到处理器并返回。</p><p>这个弄懂之后，if 中其他几种情况就好理解了，<code>mbd.getResolvedAutowireMode()</code> 是查看当前对象的注入方式，这个一般是在 XML 中配置的，不过日常开发中我们一般不会配置这个属性，如果需要配置，方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"constructor"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果添加了 <code>autowire=&quot;constructor&quot;</code> 就表示要通过构造方法进行注入，那么这里也会进入到 if 中。</p><p>if 里边剩下的几个条件都好说，就是看是否有配置构造方法参数，如果配置了，那么也直接调用相应的构造方法就行了。</p><p>这里最终执行的是 autowireConstructor 方法，这个方法比较长，我就不贴出来了，和大家说一说它的思路：</p><ol><li>首先把能获取到的构造方法都拿出来，如果构造方法只有一个，且目前也没有任何和构造方法有关的参数，那就直接用这个构造方法就行了。</li><li>如果第一步不能解决问题，接下来就遍历所有的构造方法，并且和已有的参数进行参数数量和类型比对，找到合适的构造方法并调用。</li></ol><h3 id="2-5-PreferredConstructors"><a href="#2-5-PreferredConstructors" class="headerlink" title="2.5 PreferredConstructors"></a>2.5 PreferredConstructors</h3><p>继续回到一开始的源码中，接下来是这样了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line"><span class="hljs-keyword">if</span> (ctors != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码看字面好理解，就是获取到主构造方法，不过这个是针对 Kotlin 的，跟我们 Java 无关，我就不啰嗦了。</p><h3 id="2-6-instantiateBean"><a href="#2-6-instantiateBean" class="headerlink" title="2.6 instantiateBean"></a>2.6 instantiateBean</h3><p>最后就是 instantiateBean 方法了，这个方法就比较简单了，我把代码贴一下小伙伴们应该自己都能看明白：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title">instantiateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Object beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="hljs-keyword">this</span>);</span><br><span class="line">BeanWrapper bw = <span class="hljs-keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="hljs-keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">Constructor&lt;?&gt; constructorToUse;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="hljs-keyword">if</span> (constructorToUse == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line"><span class="hljs-keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInstantiationException(clazz, <span class="hljs-string">"Specified class is an interface"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanInstantiationException(clazz, <span class="hljs-string">"No default constructor found"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Must generate CGLIB subclass.</span></span><br><span class="line"><span class="hljs-keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面小伙伴么可以看到，本质上其实就是调用了 <code>constructorToUse = clazz.getDeclaredConstructor();</code>，获取到一个公开的无参构造方法，然后据此创建一个 Bean 实例出来。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好了，这就是 Spring 容器中 Bean 的创建过程，我这里单纯和小伙伴们分享了原始 Bean 的创建这一个步骤，这块内容其实非常庞杂，以后有空我会再和小伙伴们分享。</p><p>最后，给上面分析的方法生成了一个时序图，小伙伴们作为参考。</p><p><img src="http://img.itboyhub.com/2022/08/20230706193026.png" alt></p><p>其实看 Spring 源码，松哥最大的感悟就是小伙伴们一定要了解 Spring 的各种用法，在此基础之上，源码就很好懂，如果你只会 Spring 一些基本用法，那么源码一定是看得云里雾里的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容基于 Spring6.0.4。&lt;/p&gt;
&lt;p&gt;这个话题其实非常庞大，我本来想从 getBean 方法讲起，但一想这样讲完估计很多小伙伴就懵了，所以我们还是一步一步来，今天我主要是想和小伙伴们讲讲 Spring 容器创建 Bean 最最核心的 createBeanInstance 方法，这个方法专门用来创建一个原始 Bean 实例。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP 中的代理对象是怎么创建出来的？</title>
    <link href="http://www.javaboy.org/2023/0731/spring-aop-source.html"/>
    <id>http://www.javaboy.org/2023/0731/spring-aop-source.html</id>
    <published>2023-07-31T09:16:44.000Z</published>
    <updated>2023-09-12T09:40:01.827Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>今天和小伙伴们聊一聊 Spring AOP 中的代理对象是怎么创建出来的，透过这个过程再去熟悉一下 Bean 的创建过程。</p><a id="more"></a><blockquote><p>最近几篇文章都是和小伙伴们聊 Spring 容器的一些使用细节，结合这些细节再看一看源码，等到这些功能都看完之后，我会再做一个汇总，到时候小伙伴们对 Spring 容器的整个创建过程就会有一个比较完整的了解了。</p></blockquote><h2 id="1-AOP-用法"><a href="#1-AOP-用法" class="headerlink" title="1. AOP 用法"></a>1. AOP 用法</h2><p>先来一个简单的案例，小伙伴们先回顾一下 AOP，假设我有如下类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"hello javaboy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我写一个切面，拦截 UserService 中的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Aspect</span></span><br><span class="line"><span class="hljs-meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"execution(* org.javaboy.bean.aop.UserService.*(..))"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        String name = jp.getSignature().getName();</span><br><span class="line">        System.out.println(name+<span class="hljs-string">" 方法开始执行了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们看一下从 Spring 容器中获取到的 UserService 对象：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"aop.xml"</span>);</span><br><span class="line">UserService us = ctx.getBean(UserService.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"us.getClass() = "</span> + us.getClass());</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230716184310.png" alt></p><p>可以看到，获取到的 UserService 是一个代理对象。</p><p>其他各种类型的通知我这里就不说了，不熟悉的小伙伴可以在公众号【江南一点雨】后台回复 ssm，有松哥录制的免费入门视频。</p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h2><p>那么注入到 Spring 容器中的 UserService，为什么在获取的时候变成了一个代理对象，而不是原本的 UserService 了呢？</p><p>整体上来说，我们可以将 Spring Bean 的生命周期分为四个阶段，分别是：</p><ol><li>实例化。</li><li>属性赋值。</li><li>初始化。</li><li>销毁。</li></ol><p>如下图：</p><p><img src="http://img.itboyhub.com/2022/08/spring_bean_lifecycle.png" alt></p><p>首先实例化就是通过反射，先把 Bean 的实例创建出来；接下来属性赋值就是给创建出来的 Bean 的各个属性赋值；接下来的初始化就是给 Bean 应用上各种需要的后置处理器；最后则是销毁。</p><h3 id="2-1-doCreateBean"><a href="#2-1-doCreateBean" class="headerlink" title="2.1 doCreateBean"></a>2.1 doCreateBean</h3><p>AOP 代理对象的创建是在初始化这个过程中完成的，所以今天我们就从初始化这里开始看起。</p><p>AbstractAutowireCapableBeanFactory#doCreateBean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里有一个 initializeBean 方法，在这个方法中会对 Bean 执行各种后置处理器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="hljs-keyword">null</span> ? mbd.getResourceDescription() : <span class="hljs-keyword">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共是执行了四个方法，也都是非常常见的 Bean 初始化方法：</p><ol><li>invokeAwareMethods：执行 Aware 接口下的 Bean。</li><li>applyBeanPostProcessorsBeforeInitialization：执行 BeanPostProcessor 中的前置方法。</li><li>invokeInitMethods：执行 Bean 的初始化方法 init。</li><li>applyBeanPostProcessorsAfterInitialization：执行 BeanPostProcessor 中的后置方法。</li></ol><p>1、3 这两个方法很明显跟 AOP 关系不大，我们自己平时创建的 AOP 对象基本上都是在 applyBeanPostProcessorsAfterInitialization 中进行处理的，我们来看下这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyBeanPostProcessorsAfterInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里就是遍历各种 BeanPostProcessor，并执行其 postProcessAfterInitialization 方法，将执行结果赋值给 result 并返回。</p><h3 id="2-2-postProcessAfterInitialization"><a href="#2-2-postProcessAfterInitialization" class="headerlink" title="2.2 postProcessAfterInitialization"></a>2.2 postProcessAfterInitialization</h3><p>BeanPostProcessor 有一个实现类 AbstractAutoProxyCreator，在 AbstractAutoProxyCreator 的 postProcessAfterInitialization 方法中，进行了 AOP 的处理：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (Boolean.FALSE.equals(<span class="hljs-keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Create proxy if we have advice.</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="hljs-keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先会尝试去缓存中获取代理对象，如果缓存中没有的话，则会调用 wrapIfNecessary 方法进行 AOP 的创建。</p><p>正常来说，普通 AOP 的创建，前面三个 if 的条件都是不满足的。第一个 if 是说 beanName 是否是一个 targetSource，显然我们这里不是；第二个 if 是说这个 Bean 是不是不需代理（结合<a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw" target="_blank" rel="noopener">上篇文章</a>一起理解），我们这里显然是需要代理的；第三个 if 的作用我们也在<a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw" target="_blank" rel="noopener">上篇文章</a>中和小伙伴们介绍过，这里就不再赘述了。</p><blockquote><p>关于第二个 if 我多说一句，如果这里进来的是一个切面的 Bean，例如第一小节中的 LogAspect，这种 Bean 显然是不需要代理的，所以会在第二个方法中直接返回，如果是其他普通的 Bean，则第二个 if 并不会进来。</p></blockquote><p>所在在 wrapIfNecessary 中，最重要的方法实际上就是两个：getAdvicesAndAdvisorsForBean 和 createProxy，前者用来找出来所有跟当前类匹配的切面，后者则用来创建代理对象。</p><h3 id="2-3-getAdvicesAndAdvisorsForBean"><a href="#2-3-getAdvicesAndAdvisorsForBean" class="headerlink" title="2.3 getAdvicesAndAdvisorsForBean"></a>2.3 getAdvicesAndAdvisorsForBean</h3><p>这个方法，说白了，就是查找各种 Advice（通知/增强） 和 Advisor（切面）。来看下到底怎么找的：</p><p>AbstractAdvisorAutoProxyCreator#getAdvicesAndAdvisorsForBean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, <span class="hljs-meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可看到，这个方法主要就是调用 findEligibleAdvisors 去获取到所有的切面，继续：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findEligibleAdvisors</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="hljs-keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一共有三个主要方法：</p><ul><li>findCandidateAdvisors：这个方法是查询到所有候选的 Advisor，说白了，就是把项目启动时注册到 Spring 容器中所有切面都找到，由于一个 Aspect 中可能存在多个 Advice，每个 Advice 最终都能封装为一个 Advisor，所以在具体查找过程中，找到 Aspect Bean 之后，还需要遍历 Bean 中的方法。</li><li>findAdvisorsThatCanApply：这个方法主要是从上个方法找到的所有切面中，根据切点过滤出来能够应用到当前 Bean 的切面。</li><li>extendAdvisors：这个是添加一个 DefaultPointcutAdvisor 切面进来，这个切面使用的 Advice 是 ExposeInvocationInterceptor，ExposeInvocationInterceptor 的作用是用于暴露  MethodInvocation 对象到 ThreadLocal 中，如果其他地方需要使用当前的 MethodInvocation 对象，直接通过调用 currentInvocation 方法取出即可。</li></ul><p>接下来我们就来看一下这三个方法的具体实现。</p><h4 id="2-3-1-findCandidateAdvisors"><a href="#2-3-1-findCandidateAdvisors" class="headerlink" title="2.3.1 findCandidateAdvisors"></a>2.3.1 findCandidateAdvisors</h4><p>AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findCandidateAdvisors</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="hljs-keyword">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">advisors.addAll(<span class="hljs-keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的关键在于通过 buildAspectJAdvisors 构建出所有的切面，这个方法有点复杂：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Advisor&gt; <span class="hljs-title">buildAspectJAdvisors</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;</span><br><span class="line"><span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">aspectNames = <span class="hljs-keyword">this</span>.aspectBeanNames;</span><br><span class="line"><span class="hljs-keyword">if</span> (aspectNames == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">aspectNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line"><span class="hljs-keyword">this</span>.beanFactory, Object.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line"><span class="hljs-comment">// would be cached by the Spring container but would not have been weaved.</span></span><br><span class="line">Class&lt;?&gt; beanType = <span class="hljs-keyword">this</span>.beanFactory.getType(beanName, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (beanType == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">aspectNames.add(beanName);</span><br><span class="line">AspectMetadata amd = <span class="hljs-keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line"><span class="hljs-keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);</span><br><span class="line">List&lt;Advisor&gt; classAdvisors = <span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">&#125;</span><br><span class="line">advisors.addAll(classAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Per target or per this.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Bean with name '"</span> + beanName +</span><br><span class="line"><span class="hljs-string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">&#125;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory =</span><br><span class="line"><span class="hljs-keyword">new</span> PrototypeAspectInstanceFactory(<span class="hljs-keyword">this</span>.beanFactory, beanName);</span><br><span class="line"><span class="hljs-keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line"><span class="hljs-keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">List&lt;Advisor&gt; cachedAdvisors = <span class="hljs-keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line"><span class="hljs-keyword">if</span> (cachedAdvisors != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">advisors.addAll(cachedAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">MetadataAwareAspectInstanceFactory factory = <span class="hljs-keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">advisors.addAll(<span class="hljs-keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法第一次进来的时候，aspectNames 变量是没有值的，所以会先进入到 if 分支中，给 aspectNames 和 aspectBeanNames 两个变量赋值。</p><p>具体过程就是首先调用 BeanFactoryUtils.beanNamesForTypeIncludingAncestors 方法（不熟悉该方法的小伙伴参考 <a href="https://mp.weixin.qq.com/s/06Mmgnhhu98lQtQ8X13QBA" target="_blank" rel="noopener">Spring 中的父子容器是咋回事？</a>一文），去当前容器以及当前容器的父容器中，查找到所有的 beanName，将返回的数组赋值给 beanNames 变量，然后对 beanNames 进行遍历。</p><p>遍历时，首先调用 isEligibleBean 方法，这个方法是检查给定名称的 Bean 是否符合自动代理的条件的，这个细节我们就不看了，因为一般情况下，我们项目中的 AOP 都是自动代理的。</p><p>接下来根据 beanName，找到对应的 bean 类型 beanType，然后调用 advisorFactory.isAspect 方法去判断这个 beanType 是否是一个 Aspect，具体的判断过程<a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw" target="_blank" rel="noopener">上篇文章</a>讲过了，小伙伴们可以参考。</p><p>如果当前 beanName 对应的 Bean 是一个 Aspect，那么就把 beanName 添加到 aspectNames 集合中，并且把 beanName 和 beanType 封装为一个 AspectMetadata 对象。</p><p>接下来会去判断 kind 是否为 SINGLETON，这个默认都是 SINGLETON，所以这里会进入到分支中，进来之后，会调用 <code>this.advisorFactory.getAdvisors</code> 方法去 Aspect 中找到各种通知和切点并封装成 Advisor 对象返回，由于一个切面中可能定义多个通知，所以最终返回的 Advisor 是一个集合，最后把找到的 Advisor 集合存入到 advisorsCache 缓存中。</p><p>后面方法的逻辑就很好懂了，从 advisorsCache 中找到某一个 aspect 对应的所有 Advisor，并将之存入到 advisors 集合中，然后返回集合。</p><p>这样，我们就找到了所有的 Advisor。</p><blockquote><p>额外多说一句，在<a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw" target="_blank" rel="noopener">上篇文章</a>中，松哥最后留了一个彩蛋，当时说普通的 Bean 会走到 shouldSkip 方法中，这个 shouldSkip 方法最终就会走到 buildAspectJAdvisors 中来，所以<a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw" target="_blank" rel="noopener">上篇文章</a>后来就没和大家分析 buildAspectJAdvisors 方法了。其实，如果在 shouldSkip 方法中就调用了 buildAspectJAdvisors，那么就完成了 Advisor 的收集了，后续每次直接获取就可以了。</p></blockquote><h4 id="2-3-2-findAdvisorsThatCanApply"><a href="#2-3-2-findAdvisorsThatCanApply" class="headerlink" title="2.3.2 findAdvisorsThatCanApply"></a>2.3.2 findAdvisorsThatCanApply</h4><p>接下来 findAdvisorsThatCanApply 方法主要是从众多的 Advisor 中，找到能匹配上当前 Bean 的 Advisor，小伙伴们知道，每一个 Advisor 都包含一个切点 Pointcut，不同的切点意味着不同的拦截规则，所以现在需要进行匹配，检查当前类需要和哪个 Advisor 匹配：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Advisor&gt; <span class="hljs-title">findAdvisorsThatCanApply</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">ProxyCreationContext.setCurrentProxiedBeanName(<span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实际上就是调用了静态方法 AopUtils.findAdvisorsThatCanApply 去查找匹配的 Advisor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Advisor&gt; <span class="hljs-title">findAdvisorsThatCanApply</span><span class="hljs-params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> candidateAdvisors;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line"><span class="hljs-keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line"><span class="hljs-comment">// already processed</span></span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">eligibleAdvisors.add(candidate);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中首先会去判断 Advisor 的类型是否是 IntroductionAdvisor 类型，IntroductionAdvisor 类型的 Advisor 只能在类级别进行拦截，灵活度不如 PointcutAdvisor，所以我们一般都不是 IntroductionAdvisor，因此这里最终会走入到最后一个分支中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canApply</span><span class="hljs-params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="hljs-keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor ia) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ia.getClassFilter().matches(targetClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor pca) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// It doesn't have a pointcut so we assume it applies.</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里小伙伴们就能看到，IntroductionAdvisor 类型的 Advisor 只需要调用 ClassFilter 过滤一下就行了，ClassFilter 松哥在前面的文章中已经介绍过了（<a href="https://mp.weixin.qq.com/s/QmCAdAnIJt7mQDkjpDMo7w" target="_blank" rel="noopener">玩一玩编程式 AOP</a>），小伙伴们看这里的匹配逻辑也是非常 easy！而 PointcutAdvisor 类型的 Advisor 则会继续调用 canApply 方法进行判断：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canApply</span><span class="hljs-params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="hljs-keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line"><span class="hljs-keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line"><span class="hljs-comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (methodMatcher <span class="hljs-keyword">instanceof</span> IntroductionAwareMethodMatcher iamm) &#123;</span><br><span class="line">introductionAwareMethodMatcher = iamm;</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; classes = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span> (!Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">classes.add(ClassUtils.getUserClass(targetClass));</span><br><span class="line">&#125;</span><br><span class="line">classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line"><span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line"><span class="hljs-keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (introductionAwareMethodMatcher != <span class="hljs-keyword">null</span> ?</span><br><span class="line">introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :</span><br><span class="line">methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看一下，这里就是先按照类去匹配，匹配通过则继续按照方法去匹配，方法匹配器要是设置的 true，那就直接返回 true 就行了，否则就加载当前类，也就是 targetClass，然后遍历 targetClass 中的所有方法，最后调用 <code>introductionAwareMethodMatcher.matches</code> 方法去判断方法是否和切点契合。</p><p>就这样，我们就从所有的 Advisor 中找到了所有和当前类匹配的 Advisor 了。</p><h4 id="2-3-3-extendAdvisors"><a href="#2-3-3-extendAdvisors" class="headerlink" title="2.3.3 extendAdvisors"></a>2.3.3 extendAdvisors</h4><p>这个是添加一个 DefaultPointcutAdvisor 切面进来，这个切面使用的 Advice 是 ExposeInvocationInterceptor，ExposeInvocationInterceptor 的作用是用于暴露 MethodInvocation 对象到 ThreadLocal 中，如果其他地方需要使用当前的 MethodInvocation 对象，直接通过调用 currentInvocation 方法取出即可。</p><p>这个方法的逻辑比较简单，我就不贴出来了，小伙伴们可以自行查看。</p><h3 id="2-4-createProxy"><a href="#2-4-createProxy" class="headerlink" title="2.4 createProxy"></a>2.4 createProxy</h3><p>看完了 getAdvicesAndAdvisorsForBean 方法，我们已经找到了适合我们的 Advisor，接下来继续看 createProxy 方法，这个方法用来创建一个代理对象：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> buildProxy(beanClass, beanName, specificInterceptors, targetSource, <span class="hljs-keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">buildProxy</span><span class="hljs-params">(Class&lt;?&gt; beanClass, @Nullable String beanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Object[] specificInterceptors, TargetSource targetSource, <span class="hljs-keyword">boolean</span> classOnly)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory clbf) &#123;</span><br><span class="line">AutoProxyUtils.exposeTargetClass(clbf, beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line">ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();</span><br><span class="line">proxyFactory.copyFrom(<span class="hljs-keyword">this</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line"><span class="hljs-comment">// Explicit handling of JDK proxy targets and lambdas (for introduction advice scenarios)</span></span><br><span class="line"><span class="hljs-keyword">if</span> (Proxy.isProxyClass(beanClass) || ClassUtils.isLambdaClass(beanClass)) &#123;</span><br><span class="line"><span class="hljs-comment">// Must allow for introductions; can't just set interfaces to the proxy's interfaces only.</span></span><br><span class="line"><span class="hljs-keyword">for</span> (Class&lt;?&gt; ifc : beanClass.getInterfaces()) &#123;</span><br><span class="line">proxyFactory.addInterface(ifc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// No proxyTargetClass flag enforced, let's apply our default checks...</span></span><br><span class="line"><span class="hljs-keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">proxyFactory.setProxyTargetClass(<span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">proxyFactory.addAdvisors(advisors);</span><br><span class="line">proxyFactory.setTargetSource(targetSource);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line">proxyFactory.setFrozen(<span class="hljs-keyword">this</span>.freezeProxy);</span><br><span class="line"><span class="hljs-keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">proxyFactory.setPreFiltered(<span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Use original ClassLoader if bean class not locally loaded in overriding class loader</span></span><br><span class="line">ClassLoader classLoader = getProxyClassLoader();</span><br><span class="line"><span class="hljs-keyword">if</span> (classLoader <span class="hljs-keyword">instanceof</span> SmartClassLoader smartClassLoader &amp;&amp; classLoader != beanClass.getClassLoader()) &#123;</span><br><span class="line">classLoader = smartClassLoader.getOriginalClassLoader();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> (classOnly ? proxyFactory.getProxyClass(classLoader) : proxyFactory.getProxy(classLoader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不知道小伙伴们看了是否觉得眼熟，这就是前面发的<a href="https://mp.weixin.qq.com/s/opcyaV5iLjYHaJuD9yEMUA" target="_blank" rel="noopener">另类 AOP，编程式 AOP！</a>一文中的内容，所以这块源码大家自己看看就好了，我就不啰嗦了。</p><p>好啦，经过上面这一顿操作，代理对象就创建出来了～本文是一个大致的逻辑，还有一些特别细的小细节没和小伙伴们梳理，咱们有面有空松哥继续整文章和大家介绍</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;今天和小伙伴们聊一聊 Spring AOP 中的代理对象是怎么创建出来的，透过这个过程再去熟悉一下 Bean 的创建过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>听说 Spring Bean 的创建还有一条捷径？</title>
    <link href="http://www.javaboy.org/2023/0728/spring-bean-create.html"/>
    <id>http://www.javaboy.org/2023/0728/spring-bean-create.html</id>
    <published>2023-07-28T09:16:29.000Z</published>
    <updated>2023-09-12T09:39:57.423Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在 Spring Bean 的创建方法中，有如下一段代码：</p><a id="more"></a><p>AbstractAutowireCapableBeanFactory#createBean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="hljs-keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平时说的 Bean 的创建逻辑都是指 doCreateBean 方法中的逻辑，在松哥前面几篇文章中，凡是涉及到 Bean 的创建流程的，我说的也都是 doCreateBean 方法的流程。</p><p>但是小伙伴们注意，在 doCreateBean 方法执行之前，其实还有一个 resolveBeforeInstantiation 方法会先执行，而这个方法可能就直接产生一个 Bean 了！如果这个方法直接产生一个 Bean 了，那么 doCreateBean 方法中的逻辑就不会生效了。</p><p>那么 resolveBeforeInstantiation 方法存在的意义是什么呢？其实大家从该方法的注释上大概也能看出一些端倪出来了：</p><blockquote><p>给 BeanPostProcessor 一个机会去创建一个代理对象，用这个代理对象来代替目标 Bean。</p></blockquote><h2 id="1-resolveBeforeInstantiation"><a href="#1-resolveBeforeInstantiation" class="headerlink" title="1. resolveBeforeInstantiation"></a>1. resolveBeforeInstantiation</h2><p>看下面的源码小伙伴们一定要先搞清楚两个比较相似的单词，否则看到后面就乱了：</p><ul><li>instantiation：实例化，从 Class 到 Bean 就是实例化。</li><li>initialization：初始化，给 Bean 做各种配置就是初始化。</li></ul><p>搞明白这两个单词，我们来看源码。</p><p>首先我先来和小伙伴们稍微梳理一下 resolveBeforeInstantiation 方法。</p><p>AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">resolveBeforeInstantiation</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">Object bean = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line"><span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line"><span class="hljs-keyword">if</span> (targetType != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mbd.beforeInstantiationResolved = (bean != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看一下，这里有一个判断条件，mbd.isSynthetic 是判断是否是一个合成 Bean，这种一般都是 Spring 定义的，我们自定义的 Bean 一般都不属于这一类，然后后面的 hasInstantiationAwareBeanPostProcessors 方法则是判断当前是否存在 InstantiationAwareBeanPostProcessor 类型的后置处理器，如果存在，则进入到 if 分支中。</p><p>如果我们想要在 resolveBeforeInstantiation 方法中就完成 Bean 的处理，那么就需要自己提供一个 InstantiationAwareBeanPostProcessor 类型的后置处理器。</p><p>接下来会调用两个方法：</p><ul><li>applyBeanPostProcessorsBeforeInstantiation：从名字可以看出来，这个是在实例化之前触发的方法，所以这个方法的参数还是 Class，因为还未实例化。</li><li>applyBeanPostProcessorsAfterInitialization：从名字可以看出来，这个是在初始化之后出发的方法，所以这个方法的参数是 Bean，因为此时已经完成了初始化了。</li></ul><h3 id="1-1-applyBeanPostProcessorsBeforeInstantiation"><a href="#1-1-applyBeanPostProcessorsBeforeInstantiation" class="headerlink" title="1.1 applyBeanPostProcessorsBeforeInstantiation"></a>1.1 applyBeanPostProcessorsBeforeInstantiation</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">applyBeanPostProcessorsBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) &#123;</span><br><span class="line">Object result = bp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方就很简单了，就是执行 InstantiationAwareBeanPostProcessor 类型的后置处理器的 postProcessBeforeInstantiation 方法。</p><h3 id="1-2-applyBeanPostProcessorsAfterInitialization"><a href="#1-2-applyBeanPostProcessorsAfterInitialization" class="headerlink" title="1.2 applyBeanPostProcessorsAfterInitialization"></a>1.2 applyBeanPostProcessorsAfterInitialization</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">applyBeanPostProcessorsAfterInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">Object result = existingBean;</span><br><span class="line"><span class="hljs-keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (current == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是执行 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p><p>所以这块的源码其实并不难，道理很简单。</p><h3 id="1-3-案例"><a href="#1-3-案例" class="headerlink" title="1.3 案例"></a>1.3 案例</h3><p>松哥写一个简单的案例小伙伴们来看下。</p><p>假设我有一个 BookService，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"hello javaboy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我再创建一个 InstantiationAwareBeanPostProcessor 类型的后置处理器，并且重写前面提到的 postProcessBeforeInstantiation 和 postProcessAfterInitialization 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (beanClass == BookService.class) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(beanClass);</span><br><span class="line">            enhancer.setCallback((MethodInterceptor) (obj, method, args, proxy) -&gt; &#123;</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                System.out.println(name + <span class="hljs-string">" 方法开始执行了..."</span>);</span><br><span class="line">                Object invoke = proxy.invokeSuper(obj, args);</span><br><span class="line">                System.out.println(name + <span class="hljs-string">" 方法执行结束了..."</span>);</span><br><span class="line">                <span class="hljs-keyword">return</span> invoke;</span><br><span class="line">            &#125;);</span><br><span class="line">            BookService bookService = (BookService) enhancer.create();</span><br><span class="line">            <span class="hljs-keyword">return</span> bookService;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> InstantiationAwareBeanPostProcessor.<span class="hljs-keyword">super</span>.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"bean.getClass() ========= "</span> + bean.getClass());</span><br><span class="line">        <span class="hljs-keyword">return</span> InstantiationAwareBeanPostProcessor.<span class="hljs-keyword">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 postProcessBeforeInstantiation 方法中，如果要创建的 Bean 是 BookService，则这里通过 Enhancer 来创建一个 CGLIB 的代理对象，如果是其他的 Bean 的创建，则调用父类方法即可。这样重写之后，就会导致在 1.1 小节中，获取到的 result 就是一个代理的 BookService 对象。</p><p>在 postProcessAfterInitialization 方法中，我未做任何额外处理，就是把拿到的 Bean 打印了一下，此时我们拿到手的 Bean 其实就是前面 postProcessBeforeInstantiation 方法生成的代理对象，然后这里调用父类方法去返回，实际上就是把参数 Bean 原封不动返回。</p><p>最后将这两个 Bean 注册到 Spring 容器中：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.aop2.BookService"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bookService"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.bean.aop2.MyInstantiationAwareBeanPostProcessor"</span></span></span><br><span class="line"><span class="hljs-tag">          <span class="hljs-attr">id</span>=<span class="hljs-string">"myInstantiationAwareBeanPostProcessor"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后初始化 Spring 容器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"aop2.xml"</span>);</span><br><span class="line">BookService bs = ctx.getBean(BookService.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"bs.getClass() = "</span> + bs.getClass());</span><br><span class="line">bs.hello();</span><br></pre></td></tr></table></figure><p>最终执行结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230718192602.png" alt></p><p>可以看到，最终拿到的 BookService 就是一个代理对象，从源码层面来讲，这个代理对象在 resolveBeforeInstantiation 方法中就生成了，后续的 doCreateBean 方法实际上并未执行。</p><p>这就是 resolveBeforeInstantiation 方法的作用，实际上就是给 BeanPostProcessor 一个机会去创建一个代理对象，用这个代理对象来代替目标 Bean。</p><h2 id="2-源码实践"><a href="#2-源码实践" class="headerlink" title="2. 源码实践"></a>2. 源码实践</h2><p>松哥为什么会关注到这个方法呢？</p><p>如果有小伙伴研究过 Spring AOP 源码，就会发现这个方法在处理 Spring AOP 的时候，有一个用武之地。</p><p>当我们在 Spring AOP 中，往往通过如下代码来定义切面：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-meta">@Aspect</span></span><br><span class="line"><span class="hljs-meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类上面有一个 @Aspect 注解，那么问题来了，Spring 是如何识别出这是一个切面而非普通的 Bean 的？</p><p>答案就是在 1.1 小节中的 applyBeanPostProcessorsBeforeInstantiation 方法中，这个方法会遍历所有 InstantiationAwareBeanPostProcessor 类型的后置处理器，InstantiationAwareBeanPostProcessor 有一个子类是 AnnotationAwareAspectJAutoProxyCreator，在这个处理器中，识别出来了 LogAspect 是一个切面。</p><p>具体识别方法如下：</p><p>首先调用 AnnotationAwareAspectJAutoProxyCreator 的 postProcessBeforeInstantiation 方法（实际上是 AnnotationAwareAspectJAutoProxyCreator 的父类 AbstractAutoProxyCreator 中的方法）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">Object cacheKey = getCacheKey(beanClass, beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个地方开始，分成了两条线：</p><ol><li>如果是一个切面 Bean 的话，则执行第一个方法 isInfrastructureClass 就可以返回 true 了。</li><li>如果是一个普通 Bean 的话，则第一个方法会返回 false，此时就会执行第二个方法 shouldSkip（虽然该方法也会返回 false），但是该方法有一些其他的价值在里边。</li></ol><h3 id="2-1-切面-Bean"><a href="#2-1-切面-Bean" class="headerlink" title="2.1 切面 Bean"></a>2.1 切面 Bean</h3><p>我们先来看 isInfrastructureClass 方法，先来看切面 Bean 是怎么处理的。</p><p>这个方法我摘了一部分出来，我们重点关注 isInfrastructureClass 方法，这个方法用来判断当前类是否是一个 Aspect：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInfrastructureClass</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">super</span>.isInfrastructureClass(beanClass) ||</span><br><span class="line">(<span class="hljs-keyword">this</span>.aspectJAdvisorFactory != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.aspectJAdvisorFactory.isAspect(beanClass)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断主要是两方面：</p><ol><li>调用父类的方法去判断当前类是否和 AOP 相关：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInfrastructureClass</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> retVal = Advice.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Pointcut.class.isAssignableFrom(beanClass) ||</span><br><span class="line">Advisor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">AopInfrastructureBean.class.isAssignableFrom(beanClass);</span><br><span class="line"><span class="hljs-keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就不用我解释了，这些都是我们在 AOP 中的老熟人了。</p><ol start="2"><li>调用 <code>aspectJAdvisorFactory.isAspect</code> 方法去判断当前类是否包含 @Aspect 注解：</li></ol><p>AbstractAspectJAdvisorFactory#isAspect</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAspect</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAspectAnnotation</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (AnnotationUtils.findAnnotation(clazz, Aspect.class) != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码可太好理解了，就是检查当前类是否有 <code>@Aspect</code> 注解。后面那个 compiledByAjc 方法是检查是否需要 ajc 编译，这个我们一般都不需要，所以，只要 hasAspectAnnotation 方法返回 true，整体上就会返回 true。</p><p>如果我们的类上包含 <code>@Aspect</code> 注解，那么最终就会在将当前类名加入到 advisedBeans Map 中，在 advisedBeans 这个 Map 中，key 是当前 Bean 的名称，value 则是 false 是一个标记，表示当前类不需要生成代理类。</p><p>这就是 isInfrastructureClass 方法执行的大致逻辑。</p><h3 id="2-2-普通-Bean"><a href="#2-2-普通-Bean" class="headerlink" title="2.2 普通 Bean"></a>2.2 普通 Bean</h3><p>如果是普通 Bean 的话，很明显 isInfrastructureClass 方法会返回 false，这就会导致 shouldSkip 方法去执行，这个方法名虽然叫 shouldSkip，但是却干了不少实事。</p><p>这个方法我会在下篇文章中和小伙伴们分享 AOP 的创建过程中再和大家详解，这里先说一句，这个方法会把各种 Aspect Bean 都收集整理起来，将来根据这些 Bean 去生成 Advisor。</p><p>好啦，这就是 resolveBeforeInstantiation 方法的作用，感兴趣的小伙伴可以自己 DEBUG 看一些哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在 Spring Bean 的创建方法中，有如下一段代码：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
</feed>
