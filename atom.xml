<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-01-13T01:58:22.680Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot2 系列教程(一)纯 Java 搭建 SSM 项目</title>
    <link href="http://www.javaboy.org/2020/0112/java-ssm.html"/>
    <id>http://www.javaboy.org/2020/0112/java-ssm.html</id>
    <published>2020-01-12T01:22:24.000Z</published>
    <updated>2020-01-13T01:58:22.680Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring Boot 项目中，正常来说是不存在 XML 配置，这是因为 Spring Boot 不推荐使用 XML ，注意，并非不支持，Spring Boot 推荐开发者使用 Java 配置来搭建框架，Spring Boot 中，大量的自动化配置都是通过 Java 配置来实现的，这一套实现方案，我们也可以自己做，即自己也可以使用纯 Java 来搭建一个 SSM 环境，即在项目中，不存在任何 XML 配置，包括 web.xml 。</p><p>环境要求：</p><ul><li>使用纯 Java 来搭建 SSM 环境，要求 Tomcat 的版本必须在 7 以上。</li></ul><h1 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h1><h2 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1 创建工程"></a>1 创建工程</h2><p>创建一个普通的 Maven 工程（注意，这里可以不必创建 Web 工程），并添加 SpringMVC 的依赖，同时，这里环境的搭建需要用到 Servlet ，所以我们还需要引入 Servlet 的依赖（一定不能使用低版本的 Servlet），最终的 pom.xml 文件如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-添加-Spring-配置"><a href="#2-添加-Spring-配置" class="headerlink" title="2 添加 Spring 配置"></a>2 添加 Spring 配置</h2><p>工程创建成功之后，首先添加 Spring 的配置文件，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.javaboy"</span>, useDefaultFilters = <span class="hljs-keyword">true</span>, excludeFilters = &#123;<span class="hljs-meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION, classes = Controller.class)&#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个配置，我说如下几点：</p><ul><li>@Configuration 注解表示这是一个配置类，在我们这里，这个配置的作用类似于 applicationContext.xml</li><li>@ComponentScan 注解表示配置包扫描，里边的属性和 xml 配置中的属性都是一一对应的，useDefaultFilters 表示使用默认的过滤器，然后又除去 Controller 注解，即在 Spring 容器中扫描除了 Controller 之外的其他所有 Bean 。</li></ul><h2 id="3-添加-SpringMVC-配置"><a href="#3-添加-SpringMVC-配置" class="headerlink" title="3 添加 SpringMVC 配置"></a>3 添加 SpringMVC 配置</h2><p>接下来再来创建 springmvc 的配置文件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.javaboy"</span>,useDefaultFilters = <span class="hljs-keyword">false</span>,includeFilters = &#123;<span class="hljs-meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = Controller.class)&#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，如果不需要在 SpringMVC 中添加其他的额外配置，这样就可以了。即 视图解析器、JSON 解析、文件上传……等等，如果都不需要配置的话，这样就可以了。</strong></p><h2 id="4-配置-web-xml"><a href="#4-配置-web-xml" class="headerlink" title="4 配置 web.xml"></a>4 配置 web.xml</h2><p>此时，我们并没有 web.xml 文件，这时，我们可以使用 Java 代码去代替 web.xml 文件，这里会用到 WebApplicationInitializer ，具体定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebInit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebApplicationInitializer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//首先来加载 SpringMVC 的配置文件</span></span><br><span class="line">        AnnotationConfigWebApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigWebApplicationContext();</span><br><span class="line">        ctx.register(SpringMVCConfig.class);</span><br><span class="line">        <span class="hljs-comment">// 添加 DispatcherServlet</span></span><br><span class="line">        ServletRegistration.Dynamic springmvc = servletContext.addServlet(<span class="hljs-string">"springmvc"</span>, <span class="hljs-keyword">new</span> DispatcherServlet(ctx));</span><br><span class="line">        <span class="hljs-comment">// 给 DispatcherServlet 添加路径映射</span></span><br><span class="line">        springmvc.addMapping(<span class="hljs-string">"/"</span>);</span><br><span class="line">        <span class="hljs-comment">// 给 DispatcherServlet 添加启动时机</span></span><br><span class="line">        springmvc.setLoadOnStartup(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebInit 的作用类似于 web.xml，这个类需要实现 WebApplicationInitializer  接口，并实现接口中的方法，当项目启动时，onStartup 方法会被自动执行，我们可以在这个方法中做一些项目初始化操作，例如加载 SpringMVC 容器，添加过滤器，添加 Listener、添加 Servlet 等。</p><p><strong>注意：</strong></p><p>由于我们在 WebInit 中只是添加了 SpringMVC 的配置，这样项目在启动时只会去加载 SpringMVC 容器，而不会去加载 Spring 容器，如果一定要加载 Spring 容器，需要我们修改 SpringMVC 的配置，在 SpringMVC 配置的包扫描中也去扫描 @Configuration 注解，进而加载 Spring 容器，还有一种方案可以解决这个问题，就是直接在项目中舍弃 Spring 配置，直接将所有配置放到 SpringMVC 的配置中来完成，这个在 SSM 整合时是没有问题的，在实际开发中，较多采用第二种方案，第二种方案，SpringMVC 的配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.javaboy"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方案中，所有的注解都在 SpringMVC 中扫描，采用这种方案的话，则 Spring 的配置文件就可以删除了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h2><p>最后，添加一个 HelloController ，然后启动项目进行测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，访问接口，结果如下：</p><p><img src="./img/1-1.png" alt></p><h2 id="6-其他配置"><a href="#6-其他配置" class="headerlink" title="6 其他配置"></a>6 其他配置</h2><h3 id="6-1-静态资源过滤"><a href="#6-1-静态资源过滤" class="headerlink" title="6.1 静态资源过滤"></a>6.1 静态资源过滤</h3><p>静态资源过滤在 SpringMVC 的 XML 中的配置如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">"/**"</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在 Java 配置的 SSM 环境中，如果要配置静态资源过滤，需要让 SpringMVC 的配置继承 WebMvcConfigurationSupport ，进而重写 WebMvcConfigurationSupport 中的方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.javaboy"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="hljs-string">"/js/**"</span>).addResourceLocations(<span class="hljs-string">"classpath:/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写 addResourceHandlers 方法，在这个方法中配置静态资源过滤，这里我将静态资源放在 resources 目录下，所以资源位置是 <code>classpath:/</code> ，当然，资源也可以放在 webapp 目录下，此时只需要修改配置中的资源位置即可。如果采用 Java 来配置 SSM 环境，一般来说，可以不必使用 webapp 目录，除非要使用 JSP 做页面模板，否则可以忽略 webapp 目录。</p><h3 id="6-2-视图解析器"><a href="#6-2-视图解析器" class="headerlink" title="6.2 视图解析器"></a>6.2 视图解析器</h3><p>在 XML 文件中，通过如下方式配置视图解析器：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果通过 Java 类，一样也可以实现类似功能。</p><p>首先为我们的项目添加 webapp 目录，webapp 目录中添加一个 jsp 目录，jsp 目录中添加 jsp 文件：</p><p><img src="./img/1-2.png" alt></p><p>然后引入 JSP 的依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在配置类中，继续重写方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.javaboy"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureViewResolvers</span><span class="hljs-params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.jsp(<span class="hljs-string">"/jsp/"</span>, <span class="hljs-string">".jsp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在 Controller 中添加控制器即可访问 JSP 页面：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-路径映射"><a href="#6-3-路径映射" class="headerlink" title="6.3 路径映射"></a>6.3 路径映射</h3><p>有的时候，我们的控制器的作用仅仅只是一个跳转，就像上面小节中的控制器，里边没有任何业务逻辑，像这种情况，可以不用定义方法，可以直接通过路径映射来实现页面访问。如果在 <code>XML</code> 中配置路径映射，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/hello"</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">"hello"</span> <span class="hljs-attr">status-code</span>=<span class="hljs-string">"200"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这行配置，表示如果用户访问 <code>/hello</code> 这个路径，则直接将名为 <code>hello</code> 的视图返回给用户，并且响应码为 <code>200</code>，这个配置就可以替代 <code>Controller</code> 中的方法。</p><p>相同的需求，如果在 <code>Java</code> 代码中，写法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.javaboy"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="hljs-string">"/hello3"</span>).setViewName(<span class="hljs-string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，用户访问 <code>/hello3</code> 接口，就能看到名为 <code>hello</code> 的视图文件。</p><h3 id="6-4-JSON-配置"><a href="#6-4-JSON-配置" class="headerlink" title="6.4 JSON 配置"></a>6.4 JSON 配置</h3><p>SpringMVC 可以接收JSON 参数，也可以返回 JSON 参数，这一切依赖于 HttpMessageConverter。</p><p>HttpMessageConverter 可以将一个 JSON 字符串转为 对象，也可以将一个对象转为 JSON 字符串，实际上它的底层还是依赖于具体的 JSON 库。</p><p>所有的 JSON 库要在 SpringMVC 中自动返回或者接收 JSON，都必须提供和自己相关的 HttpMessageConverter 。</p><p>SpringMVC 中，默认提供了 Jackson 和 gson 的 HttpMessageConverter ，分别是：MappingJackson2HttpMessageConverter 和 GsonHttpMessageConverter 。</p><p>正因为如此，我们在 SpringMVC 中，如果要使用 JSON ，对于 jackson 和 gson 我们只需要添加依赖，加完依赖就可以直接使用了。具体的配置是在 AllEncompassingFormHttpMessageConverter 类中完成的。</p><p>如果开发者使用了 fastjson，那么默认情况下，SpringMVC 并没有提供 fastjson 的 HttpMessageConverter ，这个需要我们自己提供，如果是在 XML 配置中，fastjson 除了加依赖，还要显式配置 HttpMessageConverter，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Java 配置的 SSM 中，我们一样也可以添加这样的配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ComponentScan</span>(basePackages = <span class="hljs-string">"org.javaboy"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringMVCConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        FastJsonHttpMessageConverter converter = <span class="hljs-keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">        converter.setDefaultCharset(Charset.forName(<span class="hljs-string">"UTF-8"</span>));</span><br><span class="line">        FastJsonConfig fastJsonConfig = <span class="hljs-keyword">new</span> FastJsonConfig();</span><br><span class="line">        fastJsonConfig.setCharset(Charset.forName(<span class="hljs-string">"UTF-8"</span>));</span><br><span class="line">        converter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">        converters.add(converter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以在接口中直接返回 JSON 了，此时的 JSON 数据将通过 fastjson 生成。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，本文通过一个简单的例子向读者展示了使用 Java 来配置 Spring+SpringMVC 环境，事实上，只要这两个配置 OK ，再加入 MyBatis 就是非常容易的事了，本文相关的案例松哥已经上传到 GitHub 上了：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a>。</p><p>关于本文，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 Spring Boot 项目中，正常来说是不存在 XML 配置，这是因为 Spring Boot 不推荐使用 XML ，注意，并非不支持，Spring Boot 推荐开发者使用 Java 配置来搭建框架，Spring Boot 中，大量的自动化配置都是通过 Java 配
      
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>天呐，世界上还有免费的域名，赶紧抢注一个压压惊</title>
    <link href="http://www.javaboy.org/2020/0110/free-domain.html"/>
    <id>http://www.javaboy.org/2020/0110/free-domain.html</id>
    <published>2020-01-10T01:26:39.000Z</published>
    <updated>2020-01-10T02:09:14.203Z</updated>
    
    <content type="html"><![CDATA[<p>你可能想不到，这世界上还有免费的顶级域名！虽然这不是什么大新闻，可是很多小伙伴可能还不知道。</p><a id="more"></a><p>前两天刚和大家聊了不花一分钱搭建个人博客的事情（<a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a>）,在这篇文章中，你要真的一分钱都不想花，那就要接受 GitHub 提供的默认域名，GitHub 默认提供的域名是二级域名，这个默认的二级域名可能不太好记。</p><p>另一方面，有的时候大家做一些简单开发，想把自己的应用扔到服务器上去跑，这个时候，给服务器配置一个域名操作起来也会方便很多。so。。。</p><p>今天松哥再和大家透漏几个真正免费的顶级域名。虽然免费，但是注册过程还是挺麻烦的，不过好在不要钱，麻烦就麻烦吧。</p><p>为什么说注册过程麻烦呢？因为免费域名你要去网站上申请，要申请就要先网站上注册一个账户，就跟你去国内云服务厂商去买域名一样，购买之前你得先注册个账户。</p><p>这些免费域名麻烦就麻烦在注册账户非常麻烦，要注意的地方非常多，不过一个核心的指导思想就是你全程伪装成你在美帝（所以要全程开网络代理，并且代理服务器还要在美帝），否则的话，你会发现找不到注册链接，找不到购买按钮等等。</p><p>松哥亲测，虽然麻烦，但是只要你按照网上的步骤来，是可以申请成功的。</p><p>好了，废话不多说，下面我来介绍我们今天的四大主角：.ml 域名、.cf 域名、.ga 域名以及 .tk 域名。</p><h3 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h3><p>以 .ML 顶级域名为例，我们可以在 freenom 网站上进行申请。申请地址如下：</p><ul><li><a href="http://www.freenom.com/en/index.html" target="_blank" rel="noopener">http://www.freenom.com/en/index.html</a></li></ul><p>打开这个网站，我们首先会看到如下页面：</p><p><img src="http://www.javaboy.org/images/other/110-1.png" alt></p><p>然后在输入框中输入你要查询的域名，例如我这里是 javaboy：</p><p><img src="http://www.javaboy.org/images/other/110-2.png" alt></p><p>然后进入到购物车，选择右边的 12 个月免费期：</p><p><img src="http://www.javaboy.org/images/other/110-3.png" alt></p><p>选择完成后，点击 Continue 按钮进入到下一步：</p><p><img src="http://www.javaboy.org/images/other/110-4.png" alt></p><p>这里非常关键，地址信息要和你的代理服务器信息一致（如果你不知道代理服务器的具体地址，可以用 Google 随便搜索一个东西，拉到最下面，就有 IP 地址所属的位置），所有信息都用英文填写，涉及到地址，要真实可查，并且要有关联，例如你的 Address 和 Zip Code、City、Country 以及 State/Region 之间有必然关系，邮箱地址建议使用国外邮箱，手机号码可以随意填写。</p><p>购买完成后，在首页找到 My Domains ，就可以去配置 DNS 了。</p><p>另外三个申请步骤基本都差不多，要注意的事项也都差不多，只不过注册地址不一样罢了：</p><ul><li>.CF 申请地址：<a href="http://www.dot.cf" target="_blank" rel="noopener">http://www.dot.cf</a></li><li>.GA 申请地址：<a href="http://www.dot.ga" target="_blank" rel="noopener">http://www.dot.ga</a></li><li>.TK 申请地址：<a href="http://www.dot.tk" target="_blank" rel="noopener">http://www.dot.tk</a></li></ul><h3 id="域名介绍"><a href="#域名介绍" class="headerlink" title="域名介绍"></a>域名介绍</h3><p>接下来我也简单介绍一下这几个域名，为什么他们是免费的？</p><p>.ML 域名来自马里，中文有“美丽”之意，任何人都可以注册，没有任何限制，也不收取任何费用。<br>.CF 域名来自中非共和国，目前由(SOCATEL) 管理，由荷兰的 Freedom Registry 公司负责运作。<br>.GA 域名来自非洲国家加蓬。<br>.TK 域名算是一个老牌的域名了，据说目前活跃的域名超过 1600 万个，这里估计国人也贡献了不少。</p><p>这些比较奇特的顶级域名 Google 肯定会收录，百度暂不清楚。</p><p>最后，虽然这些域名不要钱，不过如果大家想正儿八经的搞一个自己的博客网站，松哥还是建议花几十块买一个 .com 域名，也不贵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你可能想不到，这世界上还有免费的顶级域名！虽然这不是什么大新闻，可是很多小伙伴可能还不知道。&lt;/p&gt;
    
    </summary>
    
      <category term="domain" scheme="http://www.javaboy.org/categories/domain/"/>
    
    
      <category term="domain" scheme="http://www.javaboy.org/tags/domain/"/>
    
  </entry>
  
  <entry>
    <title>MacBook Pro 入手一年了，到底香不香？</title>
    <link href="http://www.javaboy.org/2020/0108/mackbookpro.html"/>
    <id>http://www.javaboy.org/2020/0108/mackbookpro.html</id>
    <published>2020-01-08T01:26:24.000Z</published>
    <updated>2020-01-10T02:08:23.400Z</updated>
    
    <content type="html"><![CDATA[<p>最近又有小伙伴问到底值不值得入手一台 MacBook Pro，松哥自己在 2018 年 10 月份的时候入手了一台，到现在为止，也用了一年多了，今天就来和小伙伴们聊一聊使用感受，至于到底值不值，需要大家自行判断。</p><a id="more"></a><p>我的第一台笔记本是大一第二学期（2012 年 4 月份）入手的，是一台 Sony 的 VAIO，这台电脑现在也一直在用，给大家录制的视频教程都是用这台电脑录制了，在接近 8 年的时间里，这台笔记本一直是我的主力机，更重要的是从来没有拿去修过，质量很棒，因此当我想要换电脑的时候，首先考虑的还是 VAIO，可惜 Sony 在 2014 年将 PC 业务整体出售，VAIO 这个品牌也卖给了 JIP（Japan Industrial Partners Inc.），从此退出了笔记本电脑市场。</p><p>排除了 VAIO 之后，剩下的选项就是 MacBook Pro 了。其实很早就想入手一台 mbp 了，2016 年那会，刚毕业一年，薪水翻了三倍，我想入手一台 mbp 奖励自己，但后来还是控制住自己了，买了一个固态硬盘给我的 Windows 装上了，然后就把买 mbp 这个欲望压下来了。去年 10 月份的时候，我的第一本书刚刚交稿给出版社，还是蛮激动的，心想这下可以买一个 mbp 了吧，这次没能成功控制住自己，于是就买了，要买就买好的，于是我在 Apple 官网定制了一台 32G 内存的 mbp，当时还送了一个 beat solo 耳机。</p><p>耳机一直是女票在用，我就不多说了，我这次主要和大家说说作为一个程序员，我比较关注的开发工具的使用感受。</p><h2 id="idea-秒开"><a href="#idea-秒开" class="headerlink" title="idea 秒开"></a>idea 秒开</h2><p>第一次知道原来 IntelliJ IDEA 可以秒开。最早用 Windows 的时候，那会还不是固态硬盘，每天到公司后，先按下开机键，然后去打杯水，回来电脑刚好开机，然后点下 idea 图标，再去上个厕所，回来后 idea 也开好了，后来换了个固态硬盘，Windows 开机基本上可以控制在 10s 之内，所以每条到公司的流程也调整了下，先开机，然后等一会开机完成后，开 idea，然后再去打水，回来的时候 idea 就刚好开好。</p><p>用了 mbp 之后，idea 和 webstorm 这两个平时开发用的最多的软件，基本都可以秒开，相应的，idea 在项目编译运行的时候，也要快很多。这样开发效率提升可不是一丁半点。</p><h2 id="不用关机"><a href="#不用关机" class="headerlink" title="不用关机"></a>不用关机</h2><p>mbp 还有一个非常有用的地方就是不用关机，想想你做开发，idea、webstorm、vscode、sequel pro、postman、命令行等等开了一堆，现在下班了，全部关掉回家，明天来了再挨个打开，不是很费事么？mac 用完了，直接合上盖就可以了，下次再打开盖子，这些东西都还可以接着使用。不用再一个一个打开。</p><p>我刚开始用的时候，对这个功能很不习惯，每次用完还是习惯性的关机，后来时间久了，慢慢就接受了，现在我的 mbp 估计都快一年没关过机了，依然用着很流畅。</p><h2 id="命令行好用"><a href="#命令行好用" class="headerlink" title="命令行好用"></a>命令行好用</h2><p>mbp 里边的命令行也是非常方便，远程连接 Linux 服务器时，甚至不需要额外准备第三方工具，直接在命令行用命令连接。</p><p>但是在命令行连接远程服务器，如果 ssh 连接空闲一段时间后，就会自动断开，下次又得重新连接，我在网上看了一些方案之后，后来还是决定用一些工具得了，综合比较后，使用了 Royal TSX，既可以做远程连接，又可以方便的上传文件。</p><h2 id="Adobe-Pr-真快"><a href="#Adobe-Pr-真快" class="headerlink" title="Adobe Pr 真快"></a>Adobe Pr 真快</h2><p>因为我今年一直在录视频教程，视频要二次处理剪辑啥的，二次处理我使用了 Adobe Premiere Pro ，刚开始我是在 Windows 上处理的，但是太慢了，一个 10 分钟左右的视频，渲染起来的时间接近 20 分钟，漫长的等待实在有点受不了，后来就把视频的二次处理换到 mbp 上来处理，10 分钟的视频，大概一两分钟就可以渲染好，速度非常快。</p><p>不过在 mbp 上处理视频，也有一个问题，就是视频长的时候（10 分钟以上），可以明显的听到电脑风扇呼呼响，渲染完成后，电脑又会慢慢冷静下来，这是一个非常明显的变化。这个让我有点吃惊，因为我印象中，mbp 应该比较擅长做视频处理，但是这块实际操作起来，感觉它还是有点压力。</p><p>至于为什么不在 mbp 上使用 FINAL CUT，这是因为有的时候我还需要搭配着 Windows 使用，为了能够在 Windows 和 mbp 之间平滑切换，选择了 Adobe Pr。</p><h2 id="Docker-必备"><a href="#Docker-必备" class="headerlink" title="Docker 必备"></a>Docker 必备</h2><p>个人觉得，使用 mbp，一定安装一个 Docker，Docker 在 mbp 上安装非常方便，比 windows 省事很多，Docker 装好之后，以后的 MySQL、RabbitMQ、Redis、Nginx 等工具，都可以直接使用 Docker 来安装，方便了很多。我一直就是这样搞的。</p><p>不过 Docker 使用过程中，遇到过一次超级耗内存的情况，就是有一次突然电脑风扇呼呼响，检查之后发现是 Docker 的问题，关掉的 Docker 之后就好了，不过后来使用 Docker 没再遇到这个情况。</p><h2 id="Sequel-Pro"><a href="#Sequel-Pro" class="headerlink" title="Sequel Pro"></a>Sequel Pro</h2><p>数据库连接工具我使用了 Sequel Pro，在 Windows 上，我一直是 Navicat 和 SQLyog 两个切换着使用，mbp 上也有 Navicat ，但是搞起来比较麻烦，我就懒得去弄了，于是入乡随俗，选择了 Sequel Pro。</p><p>Sequel Pro 其实用着也没啥不方便的地方，感觉我自己的平时的需求都够用了。</p><h2 id="mbp-Vs-Ubuntu"><a href="#mbp-Vs-Ubuntu" class="headerlink" title="mbp Vs Ubuntu"></a>mbp Vs Ubuntu</h2><p>在公司做开发的时候，用 Ubuntu 做主力系统也用了很长一段时间，这也是我后来切换到 mbp 上之后，没有太多的陌生感的原因之一。个人感觉 mbp 和 Ubuntu 有很多相似的地方，相比于 Ubuntu ，mbp 最大的优势在于软件生态丰富，像 Adobe 全家桶，微信这些东西，在 mbp 上安装就不用折腾。</p><p>小伙伴们要是未来有入手 mbp 的打算，我建议现在可以在 Windows 笔记本上整一个双系统，装上 Ubuntu，这样有一天当你想切换到 mbp 上时，就可以平滑过渡。</p><h2 id="还要-Windows-系统吗"><a href="#还要-Windows-系统吗" class="headerlink" title="还要 Windows 系统吗"></a>还要 Windows 系统吗</h2><p>老实说，Windows 还是离不开。至少我这边有不少事情还是需要在 Windows 上做，例如平时给大家录制视频教程，mbp 当然也可以录，但是录出来的视频文件超级大，不利于分发和传播，所以我一直选择在 Windows 上录制。不过我不太喜欢在 mbp 上搞 Windows ，所以现在是两台笔记本，mbp 是主力，之前那台用了八年的 Windows 打辅助，两台设备切换着用。</p><p>其实在电脑上我不太喜欢折腾，一般能满足需求，我就会一直先用着。换了 mbp 之后，使用最多的软件还是那几个开发工具，其他 mbp 上的功能发掘的少，不过也在慢慢摸索。</p><p>整体来说，还是比较香的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近又有小伙伴问到底值不值得入手一台 MacBook Pro，松哥自己在 2018 年 10 月份的时候入手了一台，到现在为止，也用了一年多了，今天就来和小伙伴们聊一聊使用感受，至于到底值不值，需要大家自行判断。&lt;/p&gt;
    
    </summary>
    
      <category term="MacBookPro" scheme="http://www.javaboy.org/categories/MacBookPro/"/>
    
    
      <category term="MacBookPro" scheme="http://www.javaboy.org/tags/MacBookPro/"/>
    
  </entry>
  
  <entry>
    <title>不用花一分线，松哥手把手教你上线个人博客</title>
    <link href="http://www.javaboy.org/2020/0106/hexo-blog.html"/>
    <id>http://www.javaboy.org/2020/0106/hexo-blog.html</id>
    <published>2020-01-06T01:26:07.000Z</published>
    <updated>2020-01-10T02:07:30.905Z</updated>
    
    <content type="html"><![CDATA[<p>有不少小伙伴私信松哥，打听松哥的博客是怎么做的，其实这个我之前和大家聊过，今天就再来说一说。</p><a id="more"></a><p>我记得是 2015 年 4 月 15 在CSDN上发表了我的第一篇博客，是一个学习笔记，从那之后开启了我博客写作之路，到今天为止 4 年多了。</p><p>这 4 年时间我在 CSDN 上发表的博客最多，共有 550 篇原创，CSDN 是我的大本营，不过在这期间也有断断续续在其他公共平台上发过博客，例如 sf、博客园、掘金、慕课网等，但是都是非常零散，2016 年的时候，利用我的 GitHub 也搭建了一个个人站点，但是只是试验了几个页面，并没有好好去维护。</p><p>今年搞了一个自己的独立博客 <code>http://www.javaboy.org</code> ，从四月份到现在，博客 PV 和 UV 都以肉眼可见的速度增长，我也是蛮开心的。因为大家个人独立博客最怕的就是流量，这也是我把这个事情拖了 4 年才做的原因之一，但是真正动手做之后，我发现搭建个人独立博客比想象的要容易很多，至于流量，只要内容 OK，流量也都不是事。</p><p>今天我就来和大家聊一聊如何搭建一个个人博客。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>目前静态博客站点非常流行，所以我其实不太建议大家再去搞动态博客系统，那样要操心的事情太多了。使用搭建静态博客，可以让我们把大部分精力集中在博客写作上，而不是无休止的耗费在博客搭建上（很多小伙伴搭建博客的时候兴致勃勃，搭建完成后就意兴阑珊，然后就没有然后了，空留一个博客网站摆在那里）。</p><p>静态博客选型，松哥目前接触到的主要是两种方案：</p><ol><li>GitHub 上 结合 Jekyll 搭建的博客，Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和我们的 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。</li><li>本地渲染好 HTML 后，上传到服务端，代表作品就是 hexo。</li></ol><p>简单说，第一种方式，就是我们在本地写好 markdown 之后，直接上传到服务端，服务端会自动渲染成 HTML，然后展示给用户，第二种方案则是我们在本地写好 markdown 之后，在本地将 markdown 渲染成 HTML，然后将渲染好的 HTML 上传到服务端。（markdown 小伙伴们应该都了解吧，我就不做过多介绍了）</p><p>这两种方案松哥都有用，大家见到的 <code>http://www.javaboy.org</code>，是我使用 hexo+icarus 实现的。大家见到的 <code>http://springboot.javaboy.org</code>、<code>http://spring.javaboy.org</code>、<code>http://springmvc.javaboy.org</code>、<code>http://mybatis.javaboy.org</code>、<code>http://maven.javaboy.org</code> 等，则是我使用 Jekyll 来做的，两种方案各有优缺点，这个松哥后面再和大家详述。</p><p>今天主要和大家聊一聊 <code>http://www.javaboy.org</code> 站点的搭建，也就是我采用了 hexo+icarus 来实现的。</p><p>这个博客的所有资金投入就是几十块钱买了一个域名，再就没花钱了。站点托管在 GitHub 上，评论系统也用了 GitHub 来做，如果你能接受 GitHub 提供的默认域名，那你甚至连域名都不用买了，接下来我们就来看看这个东西怎么实现。</p><blockquote><p>如果大家玩过松哥的微人事(<a href="https://github.com/lenve/vhr)或者" target="_blank" rel="noopener">https://github.com/lenve/vhr)或者</a> V 部落(<a href="https://github.com/lenve/VBlog)，那么对于" target="_blank" rel="noopener">https://github.com/lenve/VBlog)，那么对于</a> hexo 上手可能非常容易，因为这个里边也使用了 nodejs，和微人事的前段操作有很多相同的地方。</p></blockquote><h2 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h2><p>用 Hexo 搭建，要是有一点点前端 Node 的使用经验更佳，没有当然也没关系，因为与之相关的命令并不多。使用 Hexo 需要提前在电脑上安装好 Node 和 Git ，安装成功后，就可以开始 Hexo 的安装了。步骤如下：</p><ol><li>安装 Hexo</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ol start="2"><li>在本地创建一个博客目录</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p>上面这个命令执行完后，会在本地创建一个 blog 目录，这里边就是独立博客所必须的一些文件，然后进入到这个目录中，执行 <code>npm install</code> 命令，安装相关的依赖。</p><p>安装完成后，会生成如下目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p>这里几个文件/文件夹，我们先来关注其中两个 _config.yml 和 themes 目录， _config.yml 文件中，我们可以做网站的一些基本配置，例如 网站的 title，描述，关键字、图标等，这些配置大都见名知意。如下：</p><p><img src="http://www.javaboy.org/images/other/106-1.png" alt></p><p>配置完成后，定位到 blog 目录，执行 <code>hexo s</code> 就可以在本地启动项目了，启动成功后，浏览器中输入 <code>http://localhost:4000</code> 就可以看到网站了。</p><p>说到 <code>hexo s</code> 命令，这里有几个常用命令需要给大家介绍下，分别是：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">简写</th><th style="text-align:left">中文含义</th></tr></thead><tbody><tr><td style="text-align:left">hexo server</td><td style="text-align:left">hexo s</td><td style="text-align:left">本地启动</td></tr><tr><td style="text-align:left">hexo generate</td><td style="text-align:left">hexo g</td><td style="text-align:left">生成静态文件</td></tr><tr><td style="text-align:left">hexo deploy</td><td style="text-align:left">hexo d</td><td style="text-align:left">部署网站</td></tr><tr><td style="text-align:left">hexo clean</td><td style="text-align:left"></td><td style="text-align:left">清除缓存和已经生成的静态文件</td></tr></tbody></table><p>这四个算是松哥这两天使用最多的命令，其他的命令，大伙可以参考<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a>。</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>一般来说，主题都会自己配置一个，个人感觉 Hexo 的生态还是比较丰富的，有很多可选的主题，Hexo 默认使用的主题是 landscape ，松哥最早使用了 hexo-theme-next 主题。博客在本地跑起来之后，接下来就是修改主题，主题修改的第一步就是先选一个自己认为好看的主题，选好之后，首先将之克隆到 <code>./themes</code> 目录下，这个目录下原本有有一个 landscape 文件夹，里边放的默认的样式，当然开发者也可以直接将主题文件下载好拷贝进来，但是我还是建议使用 clone ，使用 clone ，假如有一天这个主题更新了，只需要 pull 一下就可以获取到最新样式了。</p><p>以 hexo-theme-next 主题为例， clone 命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>克隆成功后，修改 hexo 的 _config.yml 文件，将主题修改为 next，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>主题创建好之后，接下来就是对主题的配置了，这个比较容易，直接参考<a href="https://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">官方文档</a>即可。配置完成后，执行如下命令，即可看到新的主题效果：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>命令含义可以参考上面的表格，这里不再赘述。</p><p>这个 next 主题我大概用了两三个月，现在换成了 icarus，大家在主题配置的时候，只要会配置一个，其他多个肯定也就没有问题了。</p><h2 id="绑定到-GitHub"><a href="#绑定到-GitHub" class="headerlink" title="绑定到 GitHub"></a>绑定到 GitHub</h2><p>大家可能已经迫不及待想要把博客上传到 GitHub 了，绑定到 Github 步骤也很简单，首先以 <code>自己的GitHub ID.github.io</code> 为名创建一个 public 仓库，例如我的 ID 为 lenve，创建的仓库如下：</p><p><img src="http://www.javaboy.org/images/other/23-2.png" alt></p><p>创建成功之后，修改 hexo 的 <code>_config.yml</code> 文件，配置 GitHub 地址，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lenve/lenve.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这里根据自己的地址来配置即可，配置完成后，执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>执行完成后，就可以将数据上传到 GitHub 了（当然这里需要大家提前配置一下 GitHub 的公钥，具体可以参考<a href="https://mp.weixin.qq.com/s/x5bRe4QBMoVFKv5jNl9iRw" target="_blank" rel="noopener">Git关联远程仓库</a>）。</p><p>上传成功后，访问 <code>https://lenve.github.io</code> 就可以看到自己的个人站点了，这是 GitHub 默认给我们提供的域名。</p><p>如果你对 GitHub 提供的域名不满意，也可以自己申请一个域名，分分钟就配置好了。</p><h2 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h2><p>域名申请建议使用国外的域名提供商，不用备案（一个字，快！不用等），松哥使用了 godaddy ，主要是因为这个服务商支持支付宝付款，域名申请就比较容易了，无需多说，不过类似的域名提供商其实很多，大家不一定用这个，也可以自己再看看。</p><h2 id="域名和-GitHub-绑定"><a href="#域名和-GitHub-绑定" class="headerlink" title="域名和 GitHub 绑定"></a>域名和 GitHub 绑定</h2><p>域名申请成功之后，接下来的配置，也分为两部分。</p><h3 id="GitHub-配置"><a href="#GitHub-配置" class="headerlink" title="GitHub 配置"></a>GitHub 配置</h3><p>首先在博客所在目录下的 source 目录中（<strong>注意不要放错位置了</strong>），创建一个 CNAME 文件，文件内容就是你的域名，如下：</p><p><img src="http://www.javaboy.org/images/other/23-3.png" alt></p><p>然后执行 <code>hexo d</code> 命令将这个文件上传到 GitHub 就可以了。</p><p>在网上看到有人直接在 GitHub 上配置这个，如下图：</p><p><img src="http://www.javaboy.org/images/other/23-4.png" alt></p><p>这种方式也可以，这种方式会自动生成一个 CNAME 文件到当前仓库中，但是松哥在这里不推荐大家使用这种方式，因为如果你在本地执行了 <code>hexo clean</code> ，然后再去上传，就会丢失掉 CNAME 文件，然后又得重新配置。<strong>关键是当你执行了 <code>hexo clean</code> 之后，你可能还发现不了 CNAME 文件已经丢失了。</strong></p><h3 id="域名解析配置"><a href="#域名解析配置" class="headerlink" title="域名解析配置"></a>域名解析配置</h3><p>域名解析这块，当时遇到了一些问题，后来松哥使用了国内的 DNSPod 去做域名解析了，没有使用 godaddy 提供的域名解析。使用 DNSPod 首先要做的，就是修改 godaddy 提供的域名解析服务，登录自己的 godaddy 账号，找到域名管理，修改域名解析服务为 DNSPod ，如下：</p><p><img src="http://www.javaboy.org/images/other/23-5.png" alt></p><p>然后登录到 DNSPod（没有账号注册一个），然后添加自己的域名解析，如下图：</p><p><img src="http://www.javaboy.org/images/other/23-6.png" alt></p><p>添加两条 A 记录，指向 GitHub 的 IP 地址，再添加一条 CNAME ，指向你的 GitHub 域名就可以了。 </p><p>如此之后，大功告成！</p><p><img src="http://www.javaboy.org/images/other/23-7.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，不知道小伙伴们有没有 GET 到呢？这个不用花很多钱，就是一个域名的费用而已（如果你不想用 GitHub 提供的域名的话），也不需要额外买服务器，hexo 的使用也很简单，有兴趣小伙伴赶快实践下吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有不少小伙伴私信松哥，打听松哥的博客是怎么做的，其实这个我之前和大家聊过，今天就再来说一说。&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://www.javaboy.org/categories/blog/"/>
    
    
      <category term="blog" scheme="http://www.javaboy.org/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>听说你的 IDEA 昨天掉链子了？松哥给你准备了大招</title>
    <link href="http://www.javaboy.org/2020/0105/idea.html"/>
    <id>http://www.javaboy.org/2020/0105/idea.html</id>
    <published>2020-01-05T01:25:51.000Z</published>
    <updated>2020-01-10T02:05:45.614Z</updated>
    
    <content type="html"><![CDATA[<p>昨天一直在忙，中午抽空瞅了一眼技术群，天呐，竟然都在切磋 IDEA 激活码的事情，瞬间明白可能 jetbrains 又在搞事情了。</p><a id="more"></a><p>我大概了解了下，这次出事的主要是 2019 版，之前的 2018 版没有受影响。</p><p>我也是 2018 版用了好久才切换到 2019 版上面来的，刚用 2019 版的时候还没啥感觉，用久了发现 2019 版确实挺好用的，里边有很多新增的特性，这些我以后可以和大家细细的去聊，这里就不再多说。</p><p>由于国内目前的版权环境，使用正版 IDEA 的小伙伴可能并不多，正版一套其实还是蛮贵的，特别是对于一些学生党来说简直就是天价了，不过 jetbrains 公司还算是比较人性化的，提供了多种免费获取正版授权的方案。</p><p>第一种就是开源项目。如果你有一个不错的开源项目，而且一直在维护，那么你可以向 jetbrains 公司申请全家桶软件的激活码，这就是正儿八经的正版软件了。这条路看着容易，其实对大部分小伙伴来说还是有挺高的门槛的。</p><p>另一个适合在校大学生的方案就是使用一个 edu 邮箱，向 jetbrains 公司申请激活码。因为大部分学校可能都会给学生分配一个 edu 邮箱，用这个邮箱在 jetbrains 官网注册账号，然后就可以轻松获取到一个激活码。</p><p>个人感觉第二种方案其实漏洞比较大，因为获取一个 edu 邮箱太过 easy 了，即使学校不给，作为一个专业的程序员，还是有很多办法获取到一个 edu 邮箱的，我看到群里很多小伙伴都是采用了这种方案解决的。</p><p>不过如果已经工作了，自身条件也允许，其实也可以尝试一下正版 IDEA，毕竟作为一个程序员，应该是能够感受到一个好的 IDE 开发之不易的。</p><p><strong>当然，如果你既没有拿的出手的开源项目，也搞不到 edu 邮箱，不妨在松哥公众号后台回复 idea，看看松哥给你的惊喜。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天一直在忙，中午抽空瞅了一眼技术群，天呐，竟然都在切磋 IDEA 激活码的事情，瞬间明白可能 jetbrains 又在搞事情了。&lt;/p&gt;
    
    </summary>
    
      <category term="idea" scheme="http://www.javaboy.org/categories/idea/"/>
    
    
      <category term="idea" scheme="http://www.javaboy.org/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>2019 原创技术干货整理</title>
    <link href="http://www.javaboy.org/2020/0103/2019-article.html"/>
    <id>http://www.javaboy.org/2020/0103/2019-article.html</id>
    <published>2020-01-03T01:25:37.000Z</published>
    <updated>2020-01-10T02:05:01.448Z</updated>
    
    <content type="html"><![CDATA[<p>公众号的文章改整理一下了，老有小伙伴表示文章找不到，确实是这样，公众号的文章看过了没消化，后来再想找到有点难，有的小伙伴机智的收藏了一下，但是因为收藏夹里的东西太多了，后来还是不好找。</p><a id="more"></a><p>其实松哥公众号上的文章，大家都可以直接在松哥博客上搜索，博客右上角有一个搜索功能：</p><p><img src="http://www.javaboy.org/images/other/104-1.png" alt></p><p>好了，今天我就把 2019 年公众号上的原创干货整理出来，做成索引，方便小伙伴们查找。</p><h2 id="Spring-Boot-系列"><a href="#Spring-Boot-系列" class="headerlink" title="Spring Boot 系列"></a>Spring Boot 系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/DSbR-0Mi6fRGgPQSnL47Pg" target="_blank" rel="noopener">纯 Java 搭建 SSM 项目</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486390&amp;idx=2&amp;sn=351d689ae8e541915ab7c8fcbdb45793&amp;chksm=e9c359d6deb4d0c0afdffa191895bb09adec55625945e3f05c7a4f1528636f86915b493d5ef8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">创建 Spring Boot 项目的三种方式</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486397&amp;idx=2&amp;sn=44f4206b0431e3200fee9a058d6087f8&amp;chksm=e9c359dddeb4d0cbb9fcd7b9c5108a71900dcee28db16c91468797c92ef9678ae7d91da212f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解 spring-boot-starter-parent</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486427&amp;idx=2&amp;sn=91c4462d44f3866bc9ee4cc71feb4e89&amp;chksm=e9c359bbdeb4d0ada43758582d061da9282bb31d6911eb9aada36e61cd70c841426154549665&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解配置文件 application.properties ！</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486440&amp;idx=2&amp;sn=51d96a2a11013c38b0756f634005521a&amp;chksm=e9c35988deb4d09eebd49c04088bdf7038035a454c88aaef3c62c23ccc6cef29ffe68f3d93fa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot中的 yaml 配置</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486499&amp;idx=2&amp;sn=ce229938f5284e3a43e04e9f84121bd1&amp;chksm=e9c35e43deb4d75571c430f42758930f2e963df4bd692dcbc52beac0c6907f9d172ad533904a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">自定义 Spring Boot 中的 starter</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486535&amp;idx=2&amp;sn=2a0c95e2c10ff2d3dea883a4d0352da9&amp;chksm=e9c35e27deb4d73116f17a5105ae40dd08e25dc3393e916b270683d46f459938f263b966bdc0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解自动化配置的原理</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486559&amp;idx=2&amp;sn=8a78f43c2ba9d820011ec1f953b1e9d0&amp;chksm=e9c35e3fdeb4d7292592937036e5835dbd5d4eb7c81ebc15c84b5c87950d7ccf2d9d21f24ee5&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中配置 Https</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486582&amp;idx=2&amp;sn=ad1c5eac40c85b54e7545a382450a640&amp;chksm=e9c35e16deb4d700e3c3913ab1c890ad8020027113e1bfdf37578bee1e40d5e8fe03a657b780&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Thymeleaf</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486670&amp;idx=2&amp;sn=3f7d624d4dd0c3cef09c24a7616845d4&amp;chksm=e9c35eaedeb4d7b85a1e52249522fa997b3d8cdd975b8bc5fdfeefcc30ce0136867f9c1dd1cb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Freemarker</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486682&amp;idx=2&amp;sn=c3c203a006e19a18b09f768073fd37c4&amp;chksm=e9c35ebadeb4d7acb85b14f1ede981a3a212c5051164022a46cc529939051f0651aa1d0a36fd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中的静态资源配置</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486694&amp;idx=2&amp;sn=8f5b293ab5707b97ef16ddf553575b82&amp;chksm=e9c35e86deb4d7909ea7adf3a0b0507204a900088e4ec56a5efc0392f9948d660e4f29e31eb0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">@ControllerAdvice 的三种使用场景</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486703&amp;idx=2&amp;sn=3a61e9b2a9a4d2c0a6925958b6818a26&amp;chksm=e9c35e8fdeb4d7993e4ccc72565dfabf973b6b7b26acb849449504163be95ac9a89ad180b287&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中的全局异常处理</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486714&amp;idx=2&amp;sn=cc5164e4ee779241998c4d4173449bbc&amp;chksm=e9c35e9adeb4d78c89f70a483c4e30ac20bdfcda8715e71bd5b31706e1549eb766550bb620db&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">CORS 解决跨域问题</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486744&amp;idx=2&amp;sn=14b4eb78b9ef8b3528a305619a5f9a66&amp;chksm=e9c35f78deb4d66e61e3dfd91943a872ba8a2afbc5e41582c9b4414f5bc2fb9fd06ca7c6c4ff&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">定义系统启动任务的两种方式</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486770&amp;idx=2&amp;sn=03c4d34b5497b5328444237adf049038&amp;chksm=e9c35f52deb4d6442e007665ca8d48518582c8e22cb229f1fe5b0a467aa9bcf0650f54883aac&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">定时任务的两种实现方式</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486800&amp;idx=2&amp;sn=39965b130bdfc39e66a2d40a84d7ba57&amp;chksm=e9c35f30deb4d62602fd19cb12b8b755cf4be37de3e0510e2a3c7104b01446681355822947bd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringBoot 整合 Swagger2</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486819&amp;idx=2&amp;sn=38914644e5fb688d9bf662e112f90aad&amp;chksm=e9c35f03deb4d615e7ddff95a3fccfafaeda21d5a05605de526f31f75faa0ba458200936c501&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 中自定义 SpringMVC 配置</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486840&amp;idx=2&amp;sn=5d4f75a81b3d8eb02f288a92015f247c&amp;chksm=e9c35f18deb4d60eba6a3ecbe886999ef6c284ea3afce9f0f0b06a93def0dfc00ffc116f4d8b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 JdbcTemplate</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486879&amp;idx=2&amp;sn=16df1ab5688b6df3f4ae59ffa685e00a&amp;chksm=e9c35fffdeb4d6e994d15d66af1d2ab59f491c1dbe99932f4584ed025947ed1ae176b6226720&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合JdbcTemplate 多数据源</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486904&amp;idx=2&amp;sn=8168bef3766c91d65838bb2708d051cc&amp;chksm=e9c35fd8deb4d6ce4533758b6c9871a81dcfd045382623bcc1a593b8c23aacfc9440ff0e984d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">整合 MyBatis</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486912&amp;idx=3&amp;sn=425b82e363554a3fdb89cd955044a314&amp;chksm=e9c35fa0deb4d6b630a0b875cbf923b7c2e64313b74d1d827ebcdbb4cd85839e5f83e789df0c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">整合 MyBatis 多数据源</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486935&amp;idx=2&amp;sn=dc8d2596d9238f27db47c7e74696bd76&amp;chksm=e9c35fb7deb4d6a1e5ccd9d6e7f4326a241c849a555b2e4c8c30a75cb902ba283460a12fb5c1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解 Spring Data Jpa</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486959&amp;idx=2&amp;sn=9d29a875d4d475267a9b7855544bdbca&amp;chksm=e9c35f8fdeb4d6991f8f89fb065be43d48f5949a26c892c3ef2a13606cf6f79e7e63b735fdc4&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Redis</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247486982&amp;idx=2&amp;sn=ca166f7b88d7c8e3aa16aa3742e8d2ef&amp;chksm=e9c35c66deb4d5705ed48d8d2234e38148e6a71f613e90a6fd6f93bb29aaa9be42db488c3f83&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Nginx 极简扫盲入门</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487019&amp;idx=2&amp;sn=2bdb576650d4e493606312544c29d641&amp;chksm=e9c35c4bdeb4d55d29272bf904098345b913f517c07c35cef05c172ae0c440cda1c190b14479&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Session 共享</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487052&amp;idx=2&amp;sn=21806ea097f28e30bd1ec15fb7d0ee44&amp;chksm=e9c35c2cdeb4d53a185b4a444b9c8c82f5724730ba990dca1f1c7906ac3a1461944c193e1969&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Redis</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487066&amp;idx=2&amp;sn=1e411c6543c1dbf9f80219a0db6203a4&amp;chksm=e9c35c3adeb4d52cb298a79344dec218071f429624181b6d4d603519cefbd878d5c45bb40679&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Ehcache</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487103&amp;idx=2&amp;sn=6b83609faf02d0a2a6e153c7db78a3ad&amp;chksm=e9c35c1fdeb4d5098bbc1c4093aff970dd303e3e8c7edaa5d514cfa454973a5ca3ceaa0c7bdd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 构建 RESTful 风格应用</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487130&amp;idx=2&amp;sn=5cf21ef43cc34c572a05eda61907e310&amp;chksm=e9c35cfadeb4d5ecd1be5913e366f62e7f651c4d15805641cdea9db05e3580d5e284f14edb0a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 整合 Shiro</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487146&amp;idx=3&amp;sn=ccd3d37ac7678821c9308453a6eb7f16&amp;chksm=e9c35ccadeb4d5dc2faae80c78852233735a924b0c31c8a64403b4f5fbe2df56d3adc3f5eb6d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">整合 Spring Security</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487167&amp;idx=2&amp;sn=21ca4e87814086580fbf2fd2c3ea00c7&amp;chksm=e9c35cdfdeb4d5c98730cba97f2e50fc8e3b151b48811f7f11eefa39049e4ff4626122e7c75d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Security 添加验证码</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487212&amp;idx=2&amp;sn=54d59ea55f7f9df6c7dbd0be3849ae65&amp;chksm=e9c35c8cdeb4d59ab5f26df6f389a81e4d0029a943e0aedce010716147ac6dd4b5338f6ba778&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringSecurity 使用 JSON 格式登录</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487219&amp;idx=2&amp;sn=5a90dde59f21b1ee036488350edc8c6d&amp;chksm=e9c35c93deb4d5851dd345c53c614278c0e5549c65f1db3df8088d1b407cc860952c62970ff1&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SpringSecurity 中角色继承的坑</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487270&amp;idx=2&amp;sn=dcc3bb1660145cb2ff3ce3cecd85b012&amp;chksm=e9c35d46deb4d4500f2b918ec0d5168f4e6fe929d71be094ff5568c43d1135aad570021adb2d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Security 整合 JWT</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487283&amp;idx=2&amp;sn=1cf5dddbed5c0ea728f44fcf17e1d375&amp;chksm=e9c35d53deb4d445f38d1bcd509bbcd00f6950da83384013b2ded615ae1eed104affb264d2e7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Security 非法请求直接返回 JSON</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487291&amp;idx=2&amp;sn=d8f0b196710a06c2deb04b0d569f29cd&amp;chksm=e9c35d5bdeb4d44dd479f3f6c234110b6d7a61930382a8e7ff3da7acd594da68dfbc35afaa8d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 热部署</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487374&amp;idx=2&amp;sn=e6d50ebecc5ffa67fa0999706729c53c&amp;chksm=e9c35deedeb4d4f8e7b1f9c18122b0c12173323aa5fcd505359fbd66b5bfcf74f3cd601b9f56&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 可执行 jar 分析</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487418&amp;idx=2&amp;sn=f4afea6e7b2cf33e00819dbe54bf82ed&amp;chksm=e9c35ddadeb4d4cc10198f3c02ed4c4321c6eeac82991138f87a9d24dd8e6473c92e2113dca0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">部署 Spring Boot 到远程 Docker 容器</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487440&amp;idx=2&amp;sn=91e352ab638a63cbc126f011b4de923d&amp;chksm=e9c35db0deb4d4a668155ad4fd07004da5cb33b8a6518b3c1440973b1eacfa3d3d708d5ec101&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">使用 Jib 部署 Spring Boot</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487459&amp;idx=2&amp;sn=6d1405b414e1787d3fa08806ae096fd2&amp;chksm=e9c35d83deb4d4956f03d9e262f22f5499174db8cea3e0bb78fcff3dc260e1d4dc325fa6f6df&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Boot 邮件发送的 5 种姿势</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247487506&amp;idx=2&amp;sn=6b269e8f2c37ea55ea09850afe1f84b1&amp;chksm=e9c34272deb4cb641a2349b8ce7c43c59f33370ddcc67670648b3d468efa77bd0dac746a2922&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Spring Session 中的 Bug</a></li><li><a href="https://mp.weixin.qq.com/s/kJou5tMWuMZpbrtGoaLrdg" target="_blank" rel="noopener">Spring Boot 2.2.0 中的 Bug</a></li><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw" target="_blank" rel="noopener">Spring Boot 开发微信公众号（一）</a></li><li><a href="https://mp.weixin.qq.com/s/1jTl9kBeFeibjbe5EbsCzg" target="_blank" rel="noopener">Spring Boot 开发微信公众号（二）</a></li><li><a href="https://mp.weixin.qq.com/s/deUN4S34y6xwaWnY4Y4jpg" target="_blank" rel="noopener">15 道 Spring Boot 面试题</a></li></ol><h2 id="前后端分离系列"><a href="#前后端分离系列" class="headerlink" title="前后端分离系列"></a>前后端分离系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/HWRYAR16vLE1XFep6_i1tA" target="_blank" rel="noopener">一个Java程序猿眼中的前后端分离以及Vue.js入门</a></li><li><a href="https://mp.weixin.qq.com/s/Qbqvlo7ftbyP6dnbuUcxrw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离，两种文件上传方式总结！</a></li><li><a href="https://mp.weixin.qq.com/s/K8ANNmm6ZrP2xMyK6LGZ_g" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，前端网络请求封装与配置</a></li><li><a href="https://mp.weixin.qq.com/s/5GsOO4QK9AnR0K6FdZixOw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，权限管理的一点思路</a></li><li><a href="https://mp.weixin.qq.com/s/f5kZM3TVZzdv1tI0THjnIg" target="_blank" rel="noopener">前后端分离时代，Java 程序员的变与不变！</a></li><li><a href="https://mp.weixin.qq.com/s/szgfT3tnYMCHSeiE3_QnpA" target="_blank" rel="noopener">学艺不精，总是掉坑！前后端分离历险记</a></li><li><a href="https://mp.weixin.qq.com/s/C7PIck3SIPPTcA3NX3ELoQ" target="_blank" rel="noopener">使用 Nginx 部署前后端分离项目，解决跨域问题</a></li><li><a href="https://mp.weixin.qq.com/s/GvqLzCZngQiMqVE_ZTafeA" target="_blank" rel="noopener">喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了</a></li><li><a href="https://mp.weixin.qq.com/s/NV7pRVnR6sLSjI2Snjl_aQ" target="_blank" rel="noopener">前后端分离开发中动态菜单的两种实现方案</a></li><li><a href="https://mp.weixin.qq.com/s/wwZDx4sRbXjVJPqccRcJvg" target="_blank" rel="noopener">前后端分离，我怎么就选择了 Spring Boot + Vue 技术栈？</a></li></ol><h2 id="MySQL-系列"><a href="#MySQL-系列" class="headerlink" title="MySQL 系列"></a>MySQL 系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/_lsNyXHrsu131mHONQi5rg" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(一)</a></li><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li><li><a href="https://mp.weixin.qq.com/s/xVJjsONasLroJrAGEiuitw" target="_blank" rel="noopener">借力 Docker ，三分钟搞定 MySQL 主从复制！</a></li><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li><li><a href="https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ" target="_blank" rel="noopener">What？Tomcat 竟然也算中间件？</a></li><li><a href="https://mp.weixin.qq.com/s/qWf5XZzhgpSuIGpE2T6iJg" target="_blank" rel="noopener">分布式数据库中间件 MyCat 搞起来！</a></li><li><a href="https://mp.weixin.qq.com/s/4DvKAKiG2sFe_vEQ0mUkeQ" target="_blank" rel="noopener">数据库分库分表，分片配置轻松入门！</a></li><li><a href="https://mp.weixin.qq.com/s/oNsTcrWCjntQefD2B0sq1A" target="_blank" rel="noopener">分布式数据库如何实现主键全局自增？</a></li><li><a href="https://mp.weixin.qq.com/s/OZ0Uqv7UCiyhhRurNdVi4A" target="_blank" rel="noopener">给数据库减负的八个思路</a></li><li><a href="https://mp.weixin.qq.com/s/3eCXo2XhhgT5ZTia3mGbKQ" target="_blank" rel="noopener">MyBatis 中 @Param 注解的四种使用场景，最后一种经常被人忽略！</a></li><li><a href="https://mp.weixin.qq.com/s/-CPpM0xPbqip6Zx6TKzCDQ" target="_blank" rel="noopener">MyBatis中主键回填的两种实现方式</a></li></ol><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ol><li><a href="https://mp.weixin.qq.com/s/Lr5CwOSqYvx-JrFCSGf_Dw" target="_blank" rel="noopener">起早贪黑几个月，我写完了人生第一本书！</a></li><li><a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a></li><li><a href="https://mp.weixin.qq.com/s/wLSM1bHK4-rjOa3WuS46CQ" target="_blank" rel="noopener">一个野生程序员的自我修养</a></li><li><a href="https://mp.weixin.qq.com/s/IJZukUhu-Rec8lF9KQseoQ" target="_blank" rel="noopener">我的第一本书，被选作大学教材了！</a></li><li><a href="https://mp.weixin.qq.com/s/Zx4jiw5QVv3CBa87_K9_Gw" target="_blank" rel="noopener">一个转行程序员的买房经历</a></li><li><a href="https://mp.weixin.qq.com/s/2tSD3U2nmIR-7L-U0sTtUQ" target="_blank" rel="noopener">当公司倒闭时，我在干什么？</a></li><li><a href="https://mp.weixin.qq.com/s/u00E39EyalzRBere_5kpOA" target="_blank" rel="noopener">跟着平台混了四年，现在要单飞了！</a></li><li><a href="https://mp.weixin.qq.com/s/d4x-kNNTfXOh9AODe0Pzzg" target="_blank" rel="noopener">每次回西安，都会动摇我继续留在深圳的决心</a></li><li><a href="https://mp.weixin.qq.com/s/BRQl02_a1FVDXckXjFsJ5Q" target="_blank" rel="noopener">1024，20个入行故事，浮世中见证着程序员的奋斗</a></li><li><a href="https://mp.weixin.qq.com/s/CGK8Labju1CjdkI3omgz-g" target="_blank" rel="noopener">搬砖不易，和大家聊聊松哥经历过的两次裁员</a></li><li><a href="https://mp.weixin.qq.com/s/Jchy_VCMPeCjpKQsfW8k-Q" target="_blank" rel="noopener">华为云 open day，带你看看别人家的公司</a></li></ol><h2 id="系列教程"><a href="#系列教程" class="headerlink" title="系列教程"></a>系列教程</h2><ol><li><a href="https://mp.weixin.qq.com/s/CyMXvY-IzY-69Q_uYxxXMA" target="_blank" rel="noopener">Maven 入门，Maven + IDEA 创建多模块项目，松哥手敲了 30 多页教程给大家送来了</a></li><li><a href="https://mp.weixin.qq.com/s/4N0qWTHM2CuUFRoBIBUHwQ" target="_blank" rel="noopener">来了，松哥纯手工打造的超 50 页 Spring 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/4v7VPjSjf5DW86I3ecptFw" target="_blank" rel="noopener">来了，松哥纯手工打造 80 多页的 SpringMVC 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/sf_ZtaZllP4RdyftZghoHQ" target="_blank" rel="noopener">MyBatis 教程来啦，松哥手码的 SSM 教程总算齐活了，小伙伴们可以下载啦</a></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><a href="https://mp.weixin.qq.com/s/XiUUgFvUQ3y8FUDSXbhEKA" target="_blank" rel="noopener">2019 Java 全栈工程师进阶路线图，一定要收藏！</a></li><li><a href="https://mp.weixin.qq.com/s/_eMbFDal-vfWKwHXDAolbw" target="_blank" rel="noopener">快来！松哥的免费资源库更新啦！</a></li><li><a href="https://mp.weixin.qq.com/s/6PPYwrNestz-gvmB4ZkAqQ" target="_blank" rel="noopener">两步解决maven依赖导入失败问题</a></li><li><a href="https://mp.weixin.qq.com/s/3kyaY0bwoZw3D_big2F11A" target="_blank" rel="noopener">小程序开发框架WePY和mpvue使用感受</a></li><li><a href="https://mp.weixin.qq.com/s/g6D5b_YilzLeBH3pdjRnww" target="_blank" rel="noopener">干货|6个牛逼的基于Vue.js的后台控制面板，接私活必备</a></li><li><a href="https://mp.weixin.qq.com/s/CDnUVdktu1OKiR1HxFwv3Q" target="_blank" rel="noopener">Jpa VS MyBatis，你用哪个？</a></li><li><a href="https://mp.weixin.qq.com/s/HLP_9tyh_uU6XU5zJtks2A" target="_blank" rel="noopener">SpringMVC 方法三种类型返回值总结，你用过几种？</a></li><li><a href="https://mp.weixin.qq.com/s/rQGOyistMMz-X3kI0x21gQ" target="_blank" rel="noopener">天呐，我的服务器竟然也被黑客攻击了！</a></li><li><a href="https://mp.weixin.qq.com/s/OCMea0O_ussoGpMSb3R1oA" target="_blank" rel="noopener">Java 开发中到底该不该用 Lombok？</a></li><li><a href="https://mp.weixin.qq.com/s/_M0oqA9H4DXvB0xdgHjPGw" target="_blank" rel="noopener">想让自己的项目6666，可是 Chrome 不答应！</a></li><li><a href="https://mp.weixin.qq.com/s/MUPcD_-7NMF32tFLj9zhFQ" target="_blank" rel="noopener">天天吹微服务，单体应用有啥不好？</a></li><li><a href="https://mp.weixin.qq.com/s/KxyxlZoZpRWrbK3FJ7lAGA" target="_blank" rel="noopener">身边的人都说微服务好，好在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/pGpRXFqIJN7IhQ5qyNPmRw" target="_blank" rel="noopener">IDEA 神器入坑指南！17 个常用快捷键奉上！</a></li><li><a href="https://mp.weixin.qq.com/s/BwI8q9Cj3BfCbVUURc9DlA" target="_blank" rel="noopener">Spring 中用 XML 装配 Bean，竟然有五种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/PbFyhErajZoQPJ_G3osJeQ" target="_blank" rel="noopener">浏览 GitHub 太卡了？教你两招！</a></li><li><a href="https://mp.weixin.qq.com/s/yhDqHfbWJmRlPR0Nt1UUyg" target="_blank" rel="noopener">原创的离线版 Redis 教程，给力！</a></li><li><a href="https://mp.weixin.qq.com/s/F2jee_Y7J7lrOHfyXBBSvw" target="_blank" rel="noopener">微人事 star 数超 10k 啦！聊聊如何打造一个 star 数超 10k 的开源项目</a></li><li><a href="https://mp.weixin.qq.com/s/T_GIavgSPQBoJGqZ-2PJVQ" target="_blank" rel="noopener">晚十点半之前下班是耻辱？老板干嘛老爱和员工谈创业精神？</a></li><li><a href="https://mp.weixin.qq.com/s/9aMRFEXbh0-usVE96uZ8Ag" target="_blank" rel="noopener">学 Maven，看松哥这一篇就够了</a></li><li><a href="https://mp.weixin.qq.com/s/PZA4IjqXpQt1TWlCWguyvQ" target="_blank" rel="noopener">学习 Spring，看松哥这篇万余字的干货，够用了！</a></li><li><a href="https://mp.weixin.qq.com/s/Eo2RRB6zKQuPDMWlnCHDrw" target="_blank" rel="noopener">两年了，微人事项目迎来了一次重大更新</a></li><li><a href="https://mp.weixin.qq.com/s/7rvGBlfYie9A_4_J1uoqpg" target="_blank" rel="noopener">跟松哥学 SpringMVC（1/2）</a></li><li><a href="https://mp.weixin.qq.com/s/yNFFDWa8srJL0ArRE4H0oA" target="_blank" rel="noopener">跟松哥学 SpringMVC（2/2）</a></li></ol><h2 id="视频干货"><a href="#视频干货" class="headerlink" title="视频干货"></a>视频干货</h2><ol><li><a href="https://mp.weixin.qq.com/s/qN01Le434FWom0c3jqiQmA" target="_blank" rel="noopener">为了帮助前后端分离的新手，我做了一次大胆的尝试！</a></li><li><a href="https://mp.weixin.qq.com/s/sgjm09_e8ue5blXqPgeXZA" target="_blank" rel="noopener">说出来你可能不信，Spring Boot 中 Session 共享不超过 5 行代码！</a></li><li><a href="https://mp.weixin.qq.com/s/1rVPzJGCtDZKvMoA4BYzIA" target="_blank" rel="noopener">Spring Boot 整合 OAuth2，松哥手把手教你！</a></li><li><a href="https://mp.weixin.qq.com/s/Rrj7oco3K8kJBsTxEEdz9g" target="_blank" rel="noopener">Spring Boot 结合 WebSocket 实现在线聊天</a></li><li><a href="https://mp.weixin.qq.com/s/Sn59dxwtsEWoj2wdynQuRQ" target="_blank" rel="noopener">Spring Security 结合 Jwt 实现无状态登录</a></li><li><a href="https://mp.weixin.qq.com/s/qxMkC6H4XfCT4LqMrYtgsQ" target="_blank" rel="noopener">手把手教你 Spring Boot 整合 Spring Data Jpa</a></li><li><a href="https://mp.weixin.qq.com/s/OMgoUfH8lk8hDfuqWXGWTA" target="_blank" rel="noopener">Spring Boot + Vue，手把手教你做文件上传</a></li><li><a href="https://mp.weixin.qq.com/s/eun-ChD5KyN6LsbR9qFfiQ" target="_blank" rel="noopener">使用 Spring Security 实现微人事前后端分离登录接口</a></li><li><a href="https://mp.weixin.qq.com/s/rH5MeKuTnXbyaDaGsU4wNw" target="_blank" rel="noopener">Spring Boot 在后端如何控制前端 Vue 中菜单动态加载？</a></li><li><a href="https://mp.weixin.qq.com/s/7KftnJRj-3xnB3Eo-eUhbw" target="_blank" rel="noopener">手把手教你 Spring Boot 整合 Redis</a></li><li><a href="https://mp.weixin.qq.com/s/FoNVyAR1BkYfutFq9sjJNQ" target="_blank" rel="noopener">新版微人事部署教程来啦</a></li></ol><h2 id="优质投稿"><a href="#优质投稿" class="headerlink" title="优质投稿"></a>优质投稿</h2><ol><li><a href="https://mp.weixin.qq.com/s/Tup0cP2ZCdzodD8790Hr1w" target="_blank" rel="noopener">Spring Security 工作原理概览</a></li><li><a href="https://mp.weixin.qq.com/s/_szH8aN6HDR_1Z5Nyu4pmA" target="_blank" rel="noopener">MySQL复合索引和单列索引的单表查询分析</a></li><li><a href="https://mp.weixin.qq.com/s/r52hmD71TtiJjlOzQUvRlA" target="_blank" rel="noopener">干货推荐|Java并发编程核心概念一览，面试必备！</a></li><li><a href="https://mp.weixin.qq.com/s/7Dod-NcukPjYuQizGEdZdg" target="_blank" rel="noopener">面试干货 | Java 能否自定义一个类叫 java.lang.System？</a></li><li><a href="https://mp.weixin.qq.com/s/KoAUQm1-FXbi2WObrH3DOw" target="_blank" rel="noopener">Java 中的 jar ，天天见，可是你知道它的运行机制吗？</a></li><li><a href="https://mp.weixin.qq.com/s/U9WGULQoxdtWXGng_dpOdA" target="_blank" rel="noopener">干货 | 鸟瞰 MySQL，唬住面试官！</a></li><li><a href="https://mp.weixin.qq.com/s/8LhYFMQYfWfcDIti5qLMoA" target="_blank" rel="noopener">读者来稿：想和你聊聊 TCC</a></li></ol><p>好了，小伙伴们收藏好这篇文章，就不怕再也找不到松哥 2019 年的原创干货了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公众号的文章改整理一下了，老有小伙伴表示文章找不到，确实是这样，公众号的文章看过了没消化，后来再想找到有点难，有的小伙伴机智的收藏了一下，但是因为收藏夹里的东西太多了，后来还是不好找。&lt;/p&gt;
    
    </summary>
    
      <category term="2019" scheme="http://www.javaboy.org/categories/2019/"/>
    
    
      <category term="2019-article" scheme="http://www.javaboy.org/tags/2019-article/"/>
    
  </entry>
  
  <entry>
    <title>2019 ，值了</title>
    <link href="http://www.javaboy.org/2020/0101/2019-life.html"/>
    <id>http://www.javaboy.org/2020/0101/2019-life.html</id>
    <published>2020-01-01T01:25:25.000Z</published>
    <updated>2020-01-10T02:03:56.747Z</updated>
    
    <content type="html"><![CDATA[<p>松哥是一个超级没有安全感的人，这可能和小时候的经历有关。</p><p>工作之后，互联网行业见过了太多的裁员与公司倒闭，这些事情，松哥自己都经历过好几波：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/CGK8Labju1CjdkI3omgz-g" target="_blank" rel="noopener">搬砖不易，和大家聊聊松哥经历过的两次裁员</a></li><li><a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a></li></ul><p>因此，从刚刚开始工作，就没敢放松警惕，一直在不断学习，不断的提高，只有不断的学习，不断的输出技术，才会让我有一点点安全感，才会感到踏实。</p><p>但是在 2019 年之前，我从来没想过可以凭技术输出赚钱，那个时候，我只是想凭着技术输出，获取一些技术影响力，帮助自己在跳槽的时候加分，化解职场风险（我的第一次跳槽就是因写博客结缘，对方的负责人通过 CSDN 博客找到我，给出了翻倍的薪水，参见：<a href="https://mp.weixin.qq.com/s/Zx4jiw5QVv3CBa87_K9_Gw" target="_blank" rel="noopener">一个转行程序员的买房经历</a>），不停的技术输出只是为了让我在找工作的时候更加从容。</p><p>但是在 3 月份，华为组织了一场云享专家与 MVP 的线下技术交流活动，活动中认识了纯洁的微笑，活动结束后和大佬约了个饭，微笑哥和我聊了公众号的事情，对我来说，就像打开了一扇新大门，于是从 3 月份开始，就认认真真开始做公众号，技术输出，到现在，坚持了差不多十个月了，公众号上的收获可能是 2019 最大的收获。</p><p>当然除了公众号，还有视频教程、新书等，接下来我想从这几个方面和大家聊聊我的 2019。</p><h2 id="关于书"><a href="#关于书" class="headerlink" title="关于书"></a>关于书</h2><p>其实我一直有点自卑，去年虽然辛辛苦苦写了书，但是信心不足，新书刚刚开始销售的时候，我心里想着首印能够卖完就算不错了。</p><p>没想到的是，这本书还比较受小伙伴们的欢迎，以至于后来加印多次。当然这也可能是和清华大学出版社强大的教材销售渠道有关，因为有不少小伙伴加我微信表示这本书他们在学校有用到（<a href="https://mp.weixin.qq.com/s/IJZukUhu-Rec8lF9KQseoQ" target="_blank" rel="noopener">我的第一本书，被选作大学教材了！</a>）。</p><p>不过老实说，写书其实不挣钱，技术图书出版社给到作者的稿酬基本都是 8%，也就是说一本售价 ¥70 的书，到作者手上就是 ¥5.6，再扣除个人所得税，还不到这个数。找过我的几家出版社，我打听了下，基本都是这个样子，所以你会看到，相比于写书，有不少作者宁愿去一些平台上出一些在线课程。</p><p>不过写书也有一些其他好处，例如可以和人吹牛。松哥因为这本书，结识了很多大佬，也认识了在座的各位小伙伴，这真是一件让人超级满足的事情。</p><h2 id="关于视频"><a href="#关于视频" class="headerlink" title="关于视频"></a>关于视频</h2><p>视频的成绩，有点出乎我的意料。</p><p>2 月份刚从老家回到深圳的时候，我就想针对书录制一套视频教程，但是一集都没录完，就放弃了，太费事了。</p><p>后来从 3 月份开始做公众号之后，我也学着其他大佬一样，开通了我自己的知识星球（Java 达摩院），出乎我意料的是，开通的头一天，就有十来个小伙伴加入了，感觉都是真爱呀。</p><p>一开始星球的定位就是给大家解决问题，聊一聊前后端分离，分享一些资源，后来发现这条路根本走不通，很多时候，大家的问题不是一言两语能搞定的，除非是一些非常典型的问题。等到六月份的时候，我一度想关闭星球，因为我觉得很难在星球上给大家提供有价值的东西，就这样犹犹豫豫到了 7 月。7 月份的时候，由于 Spring Cloud 专栏写完了，周末时间又腾出来了，加上那段时间有不少小伙伴问松哥有没有 Spring Boot 视频，于是我就下定决心，决定认认真真录一套和书配套的视频教程。</p><p>出乎我意料的是，这套视频非常受小伙伴们欢迎，截止到昨天，视频已经卖出了 1000+ 份，其中有 1/4 的小伙伴都是经朋友或者同学的介绍来的，这也给了我极大的信心，决定认认真真把这套视频教程搞完。</p><p>关于视频教程，我还想多说一句：录制视频教程，一开始当然是为了赚点外快。但是在我心里，比赚钱更重要的是小伙伴的认可，如果你认可我的 vhr，认可我的技术文章，那你买视频，我不会让大家失望，这是双赢；如果不认可的话，我其实是非常不建议购买我的视频教程的。</p><h2 id="关于公众号"><a href="#关于公众号" class="headerlink" title="关于公众号"></a>关于公众号</h2><p>公众号是我 2017 年申请的，到 2019 年 3 月份才 5200+ 读者，然后从 3 月份开始，下定决心做之后，用户的增长一直还比较可观，上周刚刚突破了 3W。这一路的历程也是比较艰辛的（<a href="https://mp.weixin.qq.com/s/Y7IqyoL140l1YV0AuJLD1w" target="_blank" rel="noopener">一个小小的里程碑！</a>）.</p><p>公众号 2019 年的原创技术文章大概也在 100 多篇，平均三天一篇技术干货。这些文章我两天会抽空整理好，制作好一个索引，方便大家查找。</p><p>公众号对我来说更重要的意义可能可能不仅仅是读者的增长，更在于我总算 GET 到了流量时代的商业模式了，以前都是一窍不通，而现在总算打开了新局面，在我了解到公众号的玩法之前，对于副业赚钱，我一直停留在接私活上，这也导致我在刚工作的几年里，做了好几个私活，做完之后，慢慢发现外包赚的都是辛苦钱，都是牺牲自己的业余休息时间赚来的，但是没办法，没有其他的副业思路，直到 2019 开始认认真真搞公众号。</p><p>说到公众号这个事情，我觉得我是起了个大早赶了个晚集。我 2014 年就做过公众号后台开发，那个时候大学还没毕业，2017 年注册了自己的公众号，但是一直都不懂这个东西怎么玩，直到 2019 才开窍，用后知后觉来形容一点都不为过。不过在坚持了 10 个多月之后，总算见到了一点点黎明前的曙光。</p><p>公众号的事，未来还要仰仗各位小伙伴多多支持，当然松哥也会提供更多的干货出来，后面也会和大家公布 2020 年的干货计划。</p><h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>清明节期间，松哥终于搭建好了自己的个人博客，有了一个更加专业的展示自己博客内容的平台。从刚开始的每日个位数的 PV，到现在每日超过 2000 PV，也是不易。博客的流量谷歌搜索占了大头，因为博客托管在 GitHub 上，所以来自百度的流量比较少，不过这也导致了一个问题，就是博客的访问量比较慢，最近也打算抽空把博客迁到国内的云平台上。</p><p>松哥个人博客，目前做好了不少站点，对 Spring Boot+Spring Cloud+前后端分离感兴趣的小伙伴，这绝对是一个很棒的学习资源。</p><ul><li><a href="http://www.javaboy.org">http://www.javaboy.org</a></li><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li><li><a href="http://spring.javaboy.org" target="_blank" rel="noopener">http://spring.javaboy.org</a></li><li><a href="http://springmvc.javaboy.org" target="_blank" rel="noopener">http://springmvc.javaboy.org</a></li><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li><li><a href="http://maven.javaboy.org" target="_blank" rel="noopener">http://maven.javaboy.org</a></li></ul><p>2020 还有很多新的计划，小伙伴们关注就对了哈哈。</p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>忘了以前在哪里看到的，有人说副业做的好的人，本职工作都不会差，副业做不好的话，本职工作也不能做很好，所以本职工作就不和大家细聊了，对得起自己，对得起老板，这个就不和大家细聊了。</p><p>2019 年差不多就是这些事情吧，2020 年有很多干货计划，小伙伴们敬请期待吧。</p><p>2019 年，小伙伴们要是有值得铭记的故事，欢迎投稿。好的文章，松哥可能会送你一套松哥自制的 Spring Boot 视频教程哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥是一个超级没有安全感的人，这可能和小时候的经历有关。&lt;/p&gt;
&lt;p&gt;工作之后，互联网行业见过了太多的裁员与公司倒闭，这些事情，松哥自己都经历过好几波：&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot + Vue 视频教程喜迎大结局</title>
    <link href="http://www.javaboy.org/2019/1231/springboot-video.html"/>
    <id>http://www.javaboy.org/2019/1231/springboot-video.html</id>
    <published>2019-12-31T01:23:23.000Z</published>
    <updated>2020-01-10T01:55:23.147Z</updated>
    
    <content type="html"><![CDATA[<p>松哥的自己录制的 Spring Boot+微人事项目在经过几个月的加班加点后，终于迎来了大结局。</p><a id="more"></a><p>这套视频目前大概一共有 <strong>270 集，80 个小时</strong>左右，具体的大家可以参考下面这个目录：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line">├─第 0 章 准备工作</span><br><span class="line">│      01.开篇_1.mp4</span><br><span class="line">│      02.回顾 XML 配置 Spring.mp4</span><br><span class="line">│      03.Java配置SSM-1.mp4</span><br><span class="line">│      04.Java配置SSM-2.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 01 章 Spring Boot 入门</span><br><span class="line">│      01.SpringBoot介绍.mp4</span><br><span class="line">│      02.SpringBoot项目的三种创建方式.mp4</span><br><span class="line">│      03.SpringBoot启动类上的注解.mp4</span><br><span class="line">│      04.SpringBoot中parent的理解-1.mp4</span><br><span class="line">│      05.SpringBoot中parent的理解-2.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 02 章 Spring Boot 基础配置</span><br><span class="line">│      01.Banner配置.mp4</span><br><span class="line">│      02.容器相关配置.mp4</span><br><span class="line">│      03.Spring属性注入.mp4</span><br><span class="line">│      04.类型安全的属性注入.mp4</span><br><span class="line">│      05.YAML配置.mp4</span><br><span class="line">│      06.Profile.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 03 章 Spring Boot 整合视图层技术</span><br><span class="line">│      01.SpringBoot 整合视图层技术.mp4</span><br><span class="line">│      02.Spring Boot 整合 Freemarker.mp4</span><br><span class="line">│      03.Feemarker 常用指令.mp4</span><br><span class="line">│      04.整合 Thymeleaf.mp4</span><br><span class="line">│      05.整合 jsp.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 04 章 Spring Boot 整合 Web 开发</span><br><span class="line">│      01.Spring Boot 默认的 JSON 解析方案.mp4</span><br><span class="line">│      02.使用 Gson 处理 JSON.mp4</span><br><span class="line">│      03.Spring Boot 整合 Fastjson.mp4</span><br><span class="line">│      04.Spring Boot 默认的静态资源访问方案.mp4</span><br><span class="line">│      05.两种方式自定义静态资源位置.mp4</span><br><span class="line">│      06.Spring Boot 文件上传.mp4</span><br><span class="line">│      07.Ajax 实现文件上传.mp4</span><br><span class="line">│      08.多文件上传.mp4</span><br><span class="line">│      09.@ControllerAdvice 的三种用法.mp4</span><br><span class="line">│      10.@ControllerAdvice 处理全局异常_1.mp4</span><br><span class="line">│      11.@ControllerAdvice 预设全局数据.mp4</span><br><span class="line">│      12.@ControllerAdvice 请求参数预处理.mp4</span><br><span class="line">│      13.Spring Boot 自定义错误页.mp4</span><br><span class="line">│      14.Spring Boot 异常处理源码分析.mp4</span><br><span class="line">│      15.Spring Boot 自定义异常数据.mp4</span><br><span class="line">│      16.Spring Boot 自定义异常视图.mp4</span><br><span class="line">│      17.Spring Boot 通过 CORS 实现跨域.mp4</span><br><span class="line">│      18.Spring Boot 中加载 XML 配置.mp4</span><br><span class="line">│      19.Spring Boot 中注册拦截器.mp4</span><br><span class="line">│      20.CommandLineRunner 实现系统启动任务.mp4</span><br><span class="line">│      21.ApplicationRunner 实现系统启动任务.mp4</span><br><span class="line">│      22.Spring Boot 整合 Web 基础组件.mp4</span><br><span class="line">│      23.Spring Boot 路径映射.mp4</span><br><span class="line">│      24.Spring Boot 中使用类型转换器.mp4</span><br><span class="line">│      25.Spring Boot 整合 AOP.mp4</span><br><span class="line">│      26.Spring Boot 自定义欢迎页.mp4</span><br><span class="line">│      27.Spring Boot 自定义 favicon.mp4</span><br><span class="line">│      28.Spring Boot 除去自动化配置.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 05 章 Spring Boot 整合持久层技术</span><br><span class="line">│      01.Spring Boot 整合持久层技术.mp4</span><br><span class="line">│      02.Spring Boot 整合 JdbcTemplate.mp4</span><br><span class="line">│      03.Spring Boot 整合 JdbcTemplate 多数据源.mp4</span><br><span class="line">│      04.Spring Boot 整合 MyBatis.mp4</span><br><span class="line">│      05.Spring Boot 整合 MyBatis 多数据源.mp4</span><br><span class="line">│      06.Spring Data 和 Jpa 简介.mp4</span><br><span class="line">│      07.Spring Boot 整合 Spring Data Jpa.mp4</span><br><span class="line">│      08.Spring Data Jpa 关键字定义查询方法.mp4</span><br><span class="line">│      09.Spring Data Jpa 自定义查询 SQL.mp4</span><br><span class="line">│      10.Spring Data Jpa 自定义数据修改 SQL.mp4</span><br><span class="line">│      11.Spring Boot 整合 Jpa 多数据源.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 06 章 Spring Boot 整合 NoSQL</span><br><span class="line">│      01.Spring Boot 整合 NoSQL.mp4</span><br><span class="line">│      02.Spring Boot 整合 Redis.mp4</span><br><span class="line">│      03.为什么需要 session 共享.mp4</span><br><span class="line">│      04.Nginx 简介.mp4</span><br><span class="line">│      05.Spring Session 实现 Session 共享.mp4</span><br><span class="line">│      06.引入 Nginx 负载均衡.mp4</span><br><span class="line">│      07.MongoDB 安装.mp4</span><br><span class="line">│      08.Spring Boot 整合 MongoDB.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 07 章 构建 REST 服务</span><br><span class="line">│      01.RESTful 简介.mp4</span><br><span class="line">│      02.搭建 Jpa 环境.mp4</span><br><span class="line">│      03.Spring Boot 中 REST 默认提供的增删改查.mp4</span><br><span class="line">│      04.Spring Boot 中 REST 自定义查询方法.mp4</span><br><span class="line">│      05.REST 配置 CORS.mp4</span><br><span class="line">│      06.自定义 REST 配置.mp4</span><br><span class="line">│      07.MongoDB 实现 REST.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 08 章 开发者工具与单元测试</span><br><span class="line">│      01.Devtools 简介.mp4</span><br><span class="line">│      02.devtools 工作原理-.mp4</span><br><span class="line">│      03.自定义监控资源.mp4</span><br><span class="line">│      04.LiveReload 自动刷新页面.mp4</span><br><span class="line">│      05.禁用自动重启.mp4</span><br><span class="line">│      06.项目重启中的全局配置.mp4</span><br><span class="line">│      07.Spring Boot 单元测试介绍.mp4</span><br><span class="line">│      08.Service 测试.mp4</span><br><span class="line">│      09.Controller 测试.mp4</span><br><span class="line">│      10.JSON 测试.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 09 章 Spring Boot 缓存</span><br><span class="line">│      01.Spring Cache 介绍.mp4</span><br><span class="line">│      02.Spring Cache 整合 Redis.mp4</span><br><span class="line">│      03.Spring Cache 整合 Ehcache.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 10 章 Spring Boot 安全管理</span><br><span class="line">│      01.安全管理介绍.mp4</span><br><span class="line">│      02.Spring  Security 初体验.mp4</span><br><span class="line">│      03.手工配置用户名密码.mp4</span><br><span class="line">│      04.HttpSecurity 配置.mp4</span><br><span class="line">│      05.登录表单详细配置.mp4</span><br><span class="line">│      06.注销登录配置.mp4</span><br><span class="line">│      07.多个 HttpSecurity.mp4</span><br><span class="line">│      08.密码加密.mp4</span><br><span class="line">│      09.方法安全.mp4</span><br><span class="line">│      10.基于数据库的认证.mp4</span><br><span class="line">│      11.角色继承.mp4</span><br><span class="line">│      12.动态配置权限.mp4</span><br><span class="line">│      13.OAuth2 简介.mp4</span><br><span class="line">│      14.Spring Security 结合 OAuth2.mp4</span><br><span class="line">│      15.整合 Shiro 方式一.mp4</span><br><span class="line">│      16.整合 Shiro 方式二.mp4</span><br><span class="line">│      17.Spring Security 使用 JSON 登录.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 11 章 Spring Boot 整合 WebSocket</span><br><span class="line">│      01.WebSocket 介绍.mp4</span><br><span class="line">│      02.WebSocket 实现在线群聊.mp4</span><br><span class="line">│      03.WebSocket 实现在线单聊.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 12 章 消息服务</span><br><span class="line">│      01.消息服务.mp4</span><br><span class="line">│      02.ActiveMQ 安装.mp4</span><br><span class="line">│      03.Spring Boot 整合 ActiveMQ.mp4</span><br><span class="line">│      04.RabbitMQ 简介并安装.mp4</span><br><span class="line">│      05.Spring Boot 整合 RabbitMQ.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 13 章 企业开发</span><br><span class="line">│      01.邮件协议简介.mp4</span><br><span class="line">│      02.申请 QQ 邮箱授权码.mp4</span><br><span class="line">│      03.发送简单邮件.mp4</span><br><span class="line">│      04.发送带附件的邮件.mp4</span><br><span class="line">│      05.发送带图片资源的邮件.mp4</span><br><span class="line">│      06.Thymeleaf 做邮件模板.mp4</span><br><span class="line">│      07.Freemarker 做邮件模板.mp4</span><br><span class="line">│      08.Spring Boot 定时任务实现方案一(@Scheduled).mp4</span><br><span class="line">│      09.Spring Boot 定时任务实现方案二(Quartz).mp4</span><br><span class="line">│      10.Spring Boot 整合 Swagger2.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 14 章 应用监控</span><br><span class="line">│      01.应用端点.mp4</span><br><span class="line">│      02.Health 端点.mp4</span><br><span class="line">│      03.Info 端点.mp4</span><br><span class="line">│      04.监控信息可视化.mp4</span><br><span class="line">│      05.邮件报警.mp4</span><br><span class="line">│      </span><br><span class="line">├─第 15 章 项目构建与部署</span><br><span class="line">│      01.jar.mp4</span><br><span class="line">│      02.war.mp4</span><br><span class="line">│      </span><br><span class="line">└─第 16 章 微人事项目实战</span><br><span class="line">        001.项目介绍.mp4</span><br><span class="line">        002.项目技术架构.mp4</span><br><span class="line">        003.Vue 学习规划.mp4</span><br><span class="line">        004.Vue 初体验.mp4</span><br><span class="line">        005.Vue 条件指令.mp4</span><br><span class="line">        006.Vue 循环指令.mp4</span><br><span class="line">        007.Vue 处理用户输入.mp4</span><br><span class="line">        008.Vue 处理用户输入.mp4</span><br><span class="line">        009.Vue 组件初体验.mp4</span><br><span class="line">        010.Vue 实例.mp4</span><br><span class="line">        011.Vue 模板语法.mp4</span><br><span class="line">        012.Vue 计算属性.mp4</span><br><span class="line">        013.Vue 侦听器.mp4</span><br><span class="line">        014.Vue Class 绑定.mp4</span><br><span class="line">        015.Vue Style 绑定.mp4</span><br><span class="line">        016.Vue 条件渲染.mp4</span><br><span class="line">        017.Vue 列表渲染.mp4</span><br><span class="line">        018.Vue 事件处理.mp4</span><br><span class="line">        019.Vue 表单输入绑定.mp4</span><br><span class="line">        020.Vue 组件基础.mp4</span><br><span class="line">        021.Vue 总结.mp4</span><br><span class="line">        022.Spa 单页面应用介绍.mp4</span><br><span class="line">        023.node 和 npm.mp4</span><br><span class="line">        024.创建一个单页面应用.mp4</span><br><span class="line">        025.Vue 工程目录介绍.mp4</span><br><span class="line">        026.Vue 单页面项目运行.mp4</span><br><span class="line">        027.Vue 工程代码解析.mp4</span><br><span class="line">        028.vue-cli3 构建 Vue 项目.mp4</span><br><span class="line">        029.vue-cli3 项目结构介绍.mp4</span><br><span class="line">        030.微人事登录页面制作.mp4</span><br><span class="line">        031.处理前端登录事件.mp4</span><br><span class="line">        032.服务端环境搭建.mp4</span><br><span class="line">        033.服务端登录接口制作(一).mp4</span><br><span class="line">        034.服务端登录接口制作(二).mp4</span><br><span class="line">        035.前后端接口对接.mp4</span><br><span class="line">        036.登录页面跳转.mp4</span><br><span class="line">        037.前端请求方法封装.mp4</span><br><span class="line">        038.Home 页 title 制作.mp4</span><br><span class="line">        039.左边导航菜单制作.mp4</span><br><span class="line">        040.菜单项接口介绍.mp4</span><br><span class="line">        041.服务端菜单接口设计.mp4</span><br><span class="line">        042.Vuex 介绍与安装.mp4</span><br><span class="line">        043.Vuex 配置.mp4</span><br><span class="line">        044.菜单请求工具类封装.mp4</span><br><span class="line">        045.前端页面添加并完善菜单请求.mp4</span><br><span class="line">        046.左边导航菜单加载.mp4</span><br><span class="line">        047.页面加载问题解决.mp4</span><br><span class="line">        048.微人事首页完善.mp4</span><br><span class="line">        049.前后端分离权限管理思路探讨.mp4</span><br><span class="line">        050.后端接口权限设计.mp4</span><br><span class="line">        051.权限问题解决.mp4</span><br><span class="line">        052.权限管理继续完善.mp4</span><br><span class="line">        053.基础信息设置.mp4</span><br><span class="line">        054.职位管理前端页面设计.mp4</span><br><span class="line">        055.职位管理后端接口设计.mp4</span><br><span class="line">        056.职位管理前后端接口对接.mp4</span><br><span class="line">        057.职位管理前后端对接问题解决.mp4</span><br><span class="line">        058.职位修改操作.mp4</span><br><span class="line">        059.职位批量删除实现.mp4</span><br><span class="line">        060.职称管理前端页面设计.mp4</span><br><span class="line">        061.职称管理后端接口设计.mp4</span><br><span class="line">        062.职称管理前后端接口对接.mp4</span><br><span class="line">        063.职称批量删除实现.mp4</span><br><span class="line">        064.解决职位管理中的一个小问题.mp4</span><br><span class="line">        065.权限组前端页面制作.mp4</span><br><span class="line">        066.权限组用户角色前后端接口对接.mp4</span><br><span class="line">        067.权限组菜单树展示.mp4</span><br><span class="line">        068.菜单角色关系修改.mp4</span><br><span class="line">        069.权限组角色添加.mp4</span><br><span class="line">        070.权限组角色删除.mp4</span><br><span class="line">        071.[补充]登录问题完善.mp4</span><br><span class="line">        072.部门管理数据展示和搜索.mp4</span><br><span class="line">        073.部门树展示添加与删除.mp4</span><br><span class="line">        074.部门树的动态修改[添加].mp4</span><br><span class="line">        075.部门树的动态修改[删除].mp4</span><br><span class="line">        076.操作员管理接口设计.mp4</span><br><span class="line">        077.操作员管理页面展示.mp4</span><br><span class="line">        078.用户状态更新操作.mp4</span><br><span class="line">        079.操作员角色更新.mp4</span><br><span class="line">        080.操作员搜索.mp4</span><br><span class="line">        081.操作员删除.mp4</span><br><span class="line">        082.[补充]增加数据加载进度条.mp4</span><br><span class="line">        083.员工管理后端接口设计.mp4</span><br><span class="line">        084.员工管理工具栏展示.mp4</span><br><span class="line">        085.员工管理员工数据展示.mp4</span><br><span class="line">        086.员工管理员工数据分页.mp4</span><br><span class="line">        087.员工管理之员工搜索.mp4</span><br><span class="line">        088.员工添加接口设计.mp4</span><br><span class="line">        089.员工添加页面绘制.mp4</span><br><span class="line">        090.员工添加页面下拉框数据加载.mp4</span><br><span class="line">        091.员工添加页面工号加载.mp4</span><br><span class="line">        092.员工添加页面部门列表展示.mp4</span><br><span class="line">        093.员工添加.mp4</span><br><span class="line">        094.员工添加数据校验.mp4</span><br><span class="line">        095.[问题处理]部门管理问题处理.mp4</span><br><span class="line">        096.员工删除.mp4</span><br><span class="line">        097.员工信息更新.mp4</span><br><span class="line">        098.[问题处理]自动计算合同期限问题.mp4</span><br><span class="line">        099.[问题处理]权限组取消角色的所有权限.mp4</span><br><span class="line">        100.员工数据导出(Excel 导出).mp4</span><br><span class="line">        101.员工数据导入(Excel 上传).mp4</span><br><span class="line">        102.员工数据导入(Excel 解析).mp4</span><br><span class="line">        103.员工数据导入(插入数据库).mp4</span><br><span class="line">        104.员工高级搜索页面设计.mp4</span><br><span class="line">        105.员工高级搜索页面动画.mp4</span><br><span class="line">        106.禁用普通搜索.mp4</span><br><span class="line">        107.员工高级搜索功能.mp4</span><br><span class="line">        108.项目模块化改造.mp4</span><br><span class="line">        109.准备 RabbitMQ 消息中间件.mp4</span><br><span class="line">        110.搭建邮件服务.mp4</span><br><span class="line">        111.自动发送员工入职欢迎邮件.mp4</span><br><span class="line">        112.[号外]开发环境的变化.mp4</span><br><span class="line">        113.工资账套服务端接口设计.mp4</span><br><span class="line">        114.工资账套前端页面设计.mp4</span><br><span class="line">        115.添加工资账套页面设计.mp4</span><br><span class="line">        116.工资账套添加页面设计.mp4</span><br><span class="line">        117.工资账套添加前后端接口对接.mp4</span><br><span class="line">        118.工资账套删除.mp4</span><br><span class="line">        119.工资账套编辑与刷新.mp4</span><br><span class="line">        120.员工账套数据展示.mp4</span><br><span class="line">        121.员工工资账套调整页面设计.mp4</span><br><span class="line">        122.员工工资账套更新.mp4</span><br><span class="line">        123.员工工资账套设置分页.mp4</span><br><span class="line">        124.修改工资账套问题解决.mp4</span><br><span class="line">        125.聊天页面方案介绍.mp4</span><br><span class="line">        126.项目首页增加聊天入口.mp4</span><br><span class="line">        127.聊天页面绘制.mp4</span><br><span class="line">        128.调整聊天页面个人信息.mp4</span><br><span class="line">        129.用户列表展示.mp4</span><br><span class="line">        130.服务端消息处理配置.mp4</span><br><span class="line">        131.前端的聊天配置.mp4</span><br><span class="line">        132.消息首发测试.mp4</span><br><span class="line">        133.用户列表优化.mp4</span><br><span class="line">        134.消息发送处理.mp4</span><br><span class="line">        135.消息接收处理.mp4</span><br><span class="line">        136.聊天数据展示.mp4</span><br><span class="line">        137.聊天消息自动刷新.mp4</span><br><span class="line">        138.聊天完善.mp4</span><br><span class="line">        139.聊天消息提示.mp4</span><br><span class="line">        140.新消息提示红点.mp4</span><br><span class="line">        141.聊天消息动态提示.mp4</span><br></pre></td></tr></table></figure><p>这套视频的前 15 章主要是讲了 Spring Boot 的基本用法，第 16 章主要是讲微人事项目，微人事项目是从零开始手把手带领大家来做的，这个手把手也包括前端 Vue，视频的具体内容，可以参考上面的目录。</p><p>Spring Boot 录完之后，接下来就要开始更新 Spring Cloud 了，松哥最近也是在积极准备中，估计元旦之后就可以开始更新 Spring Cloud 了。</p><p><strong>按照我们之前的约定，每有一套课程完结的时候，就会调整一下价格，元旦临近，我们就在元旦之后再调整。也就是 12 月 31 和 1 月 1 号，依然是 199，从 1 月 2 号开始，199 元（老实说 199 也不贵，这么多视频，这么多内容，在各个视频平台对比下就知道了）。</strong></p><p>关于视频的评价，松哥之前秀过好多次了，这次就再秀一把，有不少小伙伴都是朋友推荐来的，相比于赚钱，小伙伴们的认可更让我开心：</p><p><img src="http://www.javaboy.org/images/other/103-1.png" alt><br><img src="http://www.javaboy.org/images/other/103-2.jpg" alt><br><img src="http://www.javaboy.org/images/other/103-3.jpg" alt><br><img src="http://www.javaboy.org/images/other/103-4.jpg" alt></p><p>另外你可能无法想象，在购买人群中，竟然还有西交大的老师：</p><p><img src="http://www.javaboy.org/images/other/103-6.jpg" alt></p><p>还有这是上次松哥推视频的时候小伙伴们的评价，可以看到看了视频的小伙伴都是非常认可松哥的视频教程的：</p><p><img src="http://www.javaboy.org/images/other/103-5.png" alt></p><p>好了，我就不炫耀了。下面我列举了小伙伴们关于这套视频常见的一些问题：</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，需要自己下载后一机一码授权播放。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>松哥有在某平台发布视频课程（很短，讲了几个知识点，只有两三个小时），因为课程未上线，暂时不方便透露。不过可以告诉大家的是，我在该平台发布的课程，平台抽 6 成，我拿 4 成，也就是说，这个 199 的课程，如果放到平台上销售，至少卖 400 块钱；另一方面，这也不仅仅是钱的事，即使可以放在平台上，我也不会拿去在平台上销售的。</p><p><strong>Q3：以后录的视频都可以看吗？</strong></p><p>这次松哥一共计划出四套视频课程，Spring Boot、微人事、Spring Cloud 以及 Redis，其中前两个目前已经录完了，Spring Cloud 将从 1 月份开始更新，Spring Cloud 录完之后，录 Redis，也就是 199 一共可以看这四套视频。</p><p><strong>Q4：可以砍价吗？</strong></p><p>不可以。首先因为 199 就不贵，即使不算后面的 Spring Cloud 和 Redis，单纯就现在的 Spring Boot+微人事，<strong>270 集，80 个小时</strong>，199 就不贵，更何况未来还有 Spring Cloud 和 Redis。上次有个小伙伴，加了我微信后，上来就问 60 卖不卖，松哥这暴脾气，二话没说就拉黑了。我是兼职录的视频，起早贪黑几个月录了这些视频，在他眼里就值 60 块钱，那就是我的技术在他眼里就值这点钱，我觉得这是对一个程序员最大的侮辱，没法忍。</p><p><strong>Q5：星球是怎么回事？</strong></p><p>星球主要是用来更新视频下载地址的地方，大家在这套视频教程时遇到问题时，都可以在星球上提问。</p><p><strong>Q6：视频会搞活动吗？</strong></p><p>自从我开始录视频以来，从来没有过促销活动，以前没有，以后也不会有。</p><p><strong>Q7：付费视频和免费视频有什么区别？</strong></p><p>免费视频是我在网上搜集别人录制的视频，大家在公众号后台回复 <code>2TB</code> 可以获取，付费视频是我自己录制的，录完之后都有二次剪辑，去噪，花费了很大功夫，因此是付费的。</p><p><strong>Q8：看视频有问题可以问吗？</strong></p><p>参考 Q6。</p><p><strong>Q9：这套视频适合哪些人看？</strong></p><p>学习这套视频，后端需要有 SSM 基础，前端需要有 js 基础（可以不懂 Vue，第十六章视频会讲）。要是不懂 SSM，可以先看松哥之前手敲 5 万余字的 SSM 教程。</p><p><strong>Q10：可以只买其中一套吗？</strong></p><p>可以，但是价格不变。因为购买单独的一部分，我要给你单独加密，单独上传，单独设置课程，单独生成授权码，这一套流程下来，费时费力，所以价格不变。</p><p>好了，加松哥微信，发红包 199，和 1000+ 小伙伴一起撸 Spring Boot + Vue 以及微人事项目吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥的自己录制的 Spring Boot+微人事项目在经过几个月的加班加点后，终于迎来了大结局。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.777Z</published>
    <updated>2020-01-13T01:53:46.519Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot2.2.0 这个版本发布没多久，Spring Boot2.2.1 就出来，看似不太重要的版本，却发生了一个小小变化，导致不少小伙伴掉坑了，我本来也没太在意，但是最近有快十个小伙伴在微信上问这个问题，看来我必须得写篇文章说下了，防止小伙伴们掉坑了。</p><p>到底是什么问题呢？其实就是 Freemarker 后缀变化的问题，一开始收到这个问题的时候，我以为就是小伙伴们学习不认真导致的，也没太在意：</p><p><img src="./img/45-1.png" alt><br><img src="./img/45-2.png" alt></p><p>结果最近不停有人掉坑，我觉得很有必要给各位小伙伴提个醒。</p><p>很多小伙伴可能很早就接触过 Freemarker，这个模板在 SSM 中也可以使用，只不过需要我们自己的配置东西稍微有点多。但是在之前我们使用 Freemarker 时，这个模板文件的后缀是 ftl，所以我们理所当然的认为这是标准后缀。</p><p>其实不然。</p><p>在 Freemarker 中，还有两个后缀，一个叫做 ftlh，这个用在 HTML 模板中，另一个叫做 ftlx，这个用在 XML 模板中。</p><p>Spring Boot2.2.0 之前，Freemarker 模板默认采用的后缀就是 ftl，我们可以看下 FreeMarkerProperties 类的部分源码（Spring Boot2.2.0 之前的版本）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="hljs-string">"spring.freemarker"</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">"classpath:/templates/"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".ftl"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap();</span><br><span class="line">    <span class="hljs-keyword">private</span> String[] templateLoaderPath = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"classpath:/templates/"</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> preferFileSystemAccess = <span class="hljs-keyword">true</span>;</span><br></pre></td></tr></table></figure><p>可以看到，DEFAULT_SUFFIX 变量中定义的 Freemarker 默认的后缀还是 <code>.ftl</code>。</p><p>从 Spring Boot2.2.0 开始，FreeMarkerProperties 文件内容就发生了变化，最新的 FreeMarkerProperties 文件部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="hljs-string">"spring.freemarker"</span></span><br><span class="line">)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">"classpath:/templates/"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">""</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".ftlh"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap();</span><br><span class="line">    <span class="hljs-keyword">private</span> String[] templateLoaderPath = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"classpath:/templates/"</span>&#125;;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> preferFileSystemAccess = <span class="hljs-keyword">true</span>;</span><br></pre></td></tr></table></figure><p>可以看到，这个时候在 DEFAULT_SUFFIX 变量中定义的默认后缀变成 <code>.ftlh</code> 了。</p><p>就这样一个小小变化，就把很多初次接触 Spring Boot 的小伙伴搞晕啦。</p><p>那么这个问题如何解决呢？当大家发现了原因，应该也就能找到解决办法了，其实很简单，两个思路：</p><ul><li>将 Freemarker 模板的后缀改为 <code>.ftlh</code>，推荐这种方式</li><li>在 application.properties 中修改默认配置</li></ul><p>第一种方案，就是我们在定义 Freemarker 模板的时候，直接将原来的 ftl 改成 ftlh 就可以了，像下面这张图这样：</p><p><img src="./img/45-3.png" alt></p><p>这样框架就能找到相应的模板文件了。</p><p>第二种方案就是 Freemarker 模板的后缀不变，依然是 <code>ftl</code>，然后我们在 application.properties 中修改默认的后缀配置，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.freemarker.suffix=.ftl</span><br></pre></td></tr></table></figure><p>这样就是人为强行把 Freemarker 模板的后缀又改回 <code>.ftl</code> 了。</p><p>这两种方案都可以解决这个问题。</p><p><strong>其实这个问题很简单，只要你看了 FreeMarkerProperties 类的源码，这个问题一下就明了了。</strong></p><p>松哥刚开始录 Spring Boot 视频的时候，当时最新版是 2.1.6，后来随着视频录制，Spring Boot 版本一直在变化，视频里一直是跟随最新版录制，不过在讲 Freemarker 这块的时候，还是 2.1.6，所以当时还不存在上面这个问题。虽然问题不存在，但是我在视频中却是带领小伙伴们看了 FreeMarkerProperties 类的源码的，出了问题之后，有小伙伴就机智的去翻这个类的源码，然后自己顺利的把问题解决了。感觉深得松哥真传，吾心甚慰。</p><p><img src="./img/45-4.png" alt></p><p>好了，一个小小的坑，小伙伴们在这里遇到问题稍稍留意下就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring Boot2.2.0 这个版本发布没多久，Spring Boot2.2.1 就出来，看似不太重要的版本，却发生了一个小小变化，导致不少小伙伴掉坑了，我本来也没太在意，但是最近有快十个小伙伴在微信上问这个问题，看来我必须得写篇文章说下了，防止小伙伴们掉坑了。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.776Z</published>
    <updated>2020-01-13T01:53:46.518Z</updated>
    
    <content type="html"><![CDATA[<p>不知道各位小伙伴在生产环境都是怎么部署 Spring Boot 的，打成 jar 直接一键运行？打成 war 扔到 Tomcat 容器中运行？不过据松哥了解，容器化部署应该是目前的主流方案。</p><p>不同于传统的单体应用，微服务由于服务数量众多，在部署的时候出问题的可能性更大，这个时候，结合 Docker 来部署，就可以很好的解决这个问题，这也是目前使用较多的方案之一。</p><p>将 Spring Boot 项目打包到 Docker 容器中部署，有很多不同的方法，今天松哥主要来和大家聊一聊如何将 Spring Boot 项目一键打包到远程 Docker 容器，然后通过运行一个镜像的方式来启动一个 Spring Boot 项目。</p><p>至于其他的 Spring Boot 结合 Docker 的用法，大家不要着急，后续的文章，松哥会和大家慢慢的一一道来。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><h3 id="1-1-准备-Docker"><a href="#1-1-准备-Docker" class="headerlink" title="1.1 准备 Docker"></a>1.1 准备 Docker</h3><p>我这里以 CentOS7 为例来给大家演示。</p><p>首先需要在 CentOS7 上安装好 Docker，这个安装方式网上很多，我就不多说了，我自己去年写过一个 Docker 入门教程，大家可以在公众号后台回复 <code>Docker</code> 获取教程下载地址。</p><p>Docker 安装成功之后，我们首先需要修改 Docker 配置，开启允许远程访问 Docker 的功能，开启方式很简单，修改 <code>/usr/lib/systemd/system/docker.service</code> 文件，加入如下内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="./img/41-1.png" alt></p><p>配置完成后，保存退出，然后重启 Docker：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload    </span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>Docker 重启成功之后，Docker 的准备工作就算是 OK 了。</p><h3 id="1-2-准备-IDEA"><a href="#1-2-准备-IDEA" class="headerlink" title="1.2 准备 IDEA"></a>1.2 准备 IDEA</h3><p>IDEA 上的准备工作，主要是安装一个 Docker 插件，点击 <code>File-&gt;Settings-&gt;Plugins-&gt;Browse Repositories</code> 如下：</p><p><img src="./img/41-2.png" alt></p><p>点击右边绿色的 Install 按钮，完成安装，安装完成之后需要重启一下 IDEA。</p><p>IDEA 重启成功之后，我们依次打开 <code>File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Docker</code> ，然后配置一下 Docker 的远程连接地址：</p><p><img src="./img/41-3.png" alt></p><p>配置一下 Docker 的地址，配置完成后，可以看到下面有一个 Connection successful 提示，这个表示 Docker 已经连接上了。</p><p>如此之后，我们的准备工作就算是 OK 了。</p><h2 id="2-准备项目"><a href="#2-准备项目" class="headerlink" title="2.准备项目"></a>2.准备项目</h2><p>接下来我们来创建一个简单的 Spring Boot 项目（只需要引入 <code>spring-boot-starter-web</code> 依赖即可），项目创建成功之后，我们再创建一个普通的 <code>HelloDockerController</code>，用来做测试，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloDockerController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello docker!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很简单的接口，无需多说。</p><h2 id="3-配置-Dockerfile"><a href="#3-配置-Dockerfile" class="headerlink" title="3.配置 Dockerfile"></a>3.配置 Dockerfile</h2><p>接下来，在项目的根目录下，我创建一个 Dockerfile ，作为我镜像的构建文件，具体位置如下图：</p><p><img src="./img/41-4.png" alt></p><p>文件内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM hub.c.163.com/library/java:latest</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD target/docker-<span class="hljs-number">0.0</span>.1-SNAPSHOT.jar app.jar</span><br><span class="line">ENTRYPOINT [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/app.jar"</span>]</span><br></pre></td></tr></table></figure><p>这里只有简单的四行，我说一下：</p><ol><li>Spring Boot 项目的运行依赖 Java 环境，所以我自己的镜像基于 Java 镜像来构建。</li><li>考虑到 Docker 官方镜像下载较慢，我这里使用了网易提供的 Docker 镜像。</li><li>由于 Spring Boot 运行时需要 tmp 目录，这里数据卷配置一个 /tmp 目录出来。</li><li>将本地 target 目录中打包好的 .jar 文件复制一份新的 到 /app.jar。</li><li>最后就是配置一下启动命令，由于我打包的 jar 已经成为 app.jar 了，所以启动命令也是启动 app.jar。</li></ol><p>这是我们配置的一个简单的 Dockerfile。</p><h2 id="4-配置-Maven-插件"><a href="#4-配置-Maven-插件" class="headerlink" title="4.配置 Maven 插件"></a>4.配置 Maven 插件</h2><p>接下来在 pom.xml 文件中，添加如下插件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dockerHost</span>&gt;</span>http://192.168.66.131:2375<span class="hljs-tag">&lt;/<span class="hljs-name">dockerHost</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>javaboy/$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">imageTags</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">imageTag</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageTag</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">imageTags</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">forceTags</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">forceTags</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个插件的配置不难理解：</p><ol><li>首先在 execution 节点中配置当执行 mvn package 的时候，顺便也执行一下 docker:build</li><li>然后在 configuration 中分别配置 Docker 的主机地址，镜像的名称，镜像的 tags，其中 dockerDirectory 表示指定 Dockerfile 的位置。</li><li>最后 resource 节点中再配置一下 jar 的位置和名称即可。</li></ol><p>OK，做完这些我们就算大功告成了。</p><h2 id="5-打包运行"><a href="#5-打包运行" class="headerlink" title="5.打包运行"></a>5.打包运行</h2><p>接下来对项目进行打包，打包完成后，项目会自动构建成一个镜像，并且上传到 Docker 容器中，打包方式如下：</p><p><img src="./img/41-5.png" alt></p><p>打包过程会稍微有一点旧，因为还包含了镜像的构建，特别是第一次打包，需要下载基础镜像，会更慢一些。</p><p>部分打包日志如下（项目构建过程）:</p><p><img src="./img/41-6.png" alt></p><p>项目打包成功之后，我们就可以在 Docker 容器中看到我们刚刚打包成的镜像了，如下：</p><p><img src="./img/41-7.png" alt></p><h3 id="5-1-运行方式一"><a href="#5-1-运行方式一" class="headerlink" title="5.1 运行方式一"></a>5.1 运行方式一</h3><p>此时，我们可以直接在 Linux 上像创建普通容器一样创建这个镜像的容器，然后启动，执行如下命令即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name javaboy -p 8080:8080 javaboy/docker:0.0.1</span><br></pre></td></tr></table></figure><p>启动成功之后，我们就可以访问容器中的接口了。</p><p>但是这种操作显然还是有点麻烦，结合我们一开始安装的 Docker 插件，这个运行步骤还可以做进一步的简化。</p><h3 id="5-2-运行方式二"><a href="#5-2-运行方式二" class="headerlink" title="5.2 运行方式二"></a>5.2 运行方式二</h3><p>大家注意，此时我们的 IDEA 中多了一个选项，就是 docker，如下：</p><p><img src="./img/41-8.png" alt></p><p>点击左边的绿色启动按钮，连接上 Docker 容器，连接成功之后，我们就可以看到目前 Docker 中的所有容器和镜像了，当然也包括我们刚刚创建的 Docker 镜像，如下：</p><p><img src="./img/41-9.png" alt></p><p>此时，我们选中这个镜像，右键单击，即可基于此镜像创建出一个容器，如下图：</p><p><img src="./img/41-10.png" alt></p><p>我们选择 Create container，然后填入容器的一些必要信息，配置一下容器名称，镜像 ID 会自动填上，暴露的端口使用 Specify 即可，然后写上端口的映射关系：</p><p><img src="./img/41-11.png" alt></p><p>配置完成后，点击下方的 <code>run</code> 按钮，就可以开始运行了。运行日志如下：</p><p><img src="./img/41-12.png" alt></p><p>注意，这个日志是在 Docker 的那个窗口里打印出来的。</p><p>项目运行成功之后，在浏览器输入远程服务器的地址，就可以访问了：</p><p><img src="./img/41-13.png" alt></p><p>如此之后，我们的 Spring Boot 项目就算顺利发布到远程 Docker 容器中了。</p><p>好玩吗？试试！</p><p>本文案例我已经上传到 GitHub，小伙伴们可以参考：<a href="https://github.com/lenve/javaboy-code-samples​" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples​</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知道各位小伙伴在生产环境都是怎么部署 Spring Boot 的，打成 jar 直接一键运行？打成 war 扔到 Tomcat 容器中运行？不过据松哥了解，容器化部署应该是目前的主流方案。&lt;/p&gt;
&lt;p&gt;不同于传统的单体应用，微服务由于服务数量众多，在部署的时候出问题的可
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.776Z</published>
    <updated>2020-01-13T01:53:46.532Z</updated>
    
    <content type="html"><![CDATA[<p>邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。</p><h1 id="邮件基础"><a href="#邮件基础" class="headerlink" title="邮件基础"></a>邮件基础</h1><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。  </p><p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。  </p><p>生活中我们投递一封邮件要经过如下几个步骤：  </p><ol><li>深圳的小王先将邮件投递到深圳的邮局  </li><li>深圳的邮局将邮件运送到上海的邮局  </li><li>上海的小张来邮局取邮件   </li></ol><p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> ：  </p><ol><li><a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器  </li><li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器  </li><li><a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 登录网易的邮件服务器查看邮件  </li></ol><p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。  </p><p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件与 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><p>最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。  </p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>目前国内大部分的邮件服务商都不允许直接使用用户名/密码的方式来在代码中发送邮件，都是要先申请授权码，这里以 QQ 邮箱为例，向大家演示授权码的申请流程：首先我们需要先登录 QQ 邮箱网页版，点击上方的设置按钮：  </p><p><img src="./img/43-1.jpg" alt="p266">  </p><p>然后点击账户选项卡：  </p><p><img src="./img/43-2.jpg" alt="p267">  </p><p>在账户选项卡中找到开启POP3/SMTP选项，如下：  </p><p><img src="./img/43-3.jpg" alt="p268">  </p><p>点击开启，开启相关功能，开启过程需要手机号码验证，按照步骤操作即可，不赘述。开启成功之后，即可获取一个授权码，将该号码保存好，一会使用。</p><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p>接下来，我们就可以创建项目了，Spring Boot 中，对于邮件发送提供了自动配置类，开发者只需要加入相关依赖，然后配置一下邮箱的基本信息，就可以发送邮件了。</p><ul><li>首先创建一个 Spring Boot 项目，引入邮件发送依赖：</li></ul><p><img src="./img/43-4.png" alt></p><p>创建完成后，项目依赖如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置邮箱基本信息</li></ul><p>项目创建成功后，接下来在 application.properties 中配置邮箱的基本信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=587</span><br><span class="line">spring.mail.username=1510161612@qq.com</span><br><span class="line">spring.mail.password=ubknfzhjkhrbbabe</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory</span><br><span class="line">spring.mail.properties.mail.debug=true</span><br></pre></td></tr></table></figure><p>配置含义分别如下：</p><ul><li>配置 SMTP 服务器地址</li><li>SMTP 服务器的端口</li><li>配置邮箱用户名</li><li>配置密码，注意，不是真正的密码，而是刚刚申请到的授权码</li><li>默认的邮件编码</li><li>配饰 SSL 加密工厂</li><li>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</li></ul><p>如果不知道 smtp 服务器的端口或者地址的的话，可以参考 腾讯的邮箱文档</p><ul><li><a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371" target="_blank" rel="noopener">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371</a></li></ul><p>做完这些之后，Spring Boot 就会自动帮我们配置好邮件发送类，相关的配置在 <code>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration</code> 类中，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; MimeMessage.class, MimeType.class, MailSender.class &#125;)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(MailSender.class)</span><br><span class="line"><span class="hljs-meta">@Conditional</span>(MailSenderCondition.class)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(MailProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，可以看到，导入了另外一个配置 <code>MailSenderPropertiesConfiguration</code> 类，这个类中，提供了邮件发送相关的工具类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mail"</span>, name = <span class="hljs-string">"host"</span>)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderPropertiesConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MailProperties properties;</span><br><span class="line">        MailSenderPropertiesConfiguration(MailProperties properties) &#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> JavaMailSenderImpl <span class="hljs-title">mailSender</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                JavaMailSenderImpl sender = <span class="hljs-keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">                applyProperties(sender);</span><br><span class="line">                <span class="hljs-keyword">return</span> sender;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里创建了一个 <code>JavaMailSenderImpl</code> 的实例， <code>JavaMailSenderImpl</code> 是 <code>JavaMailSender</code> 的一个实现，我们将使用 <code>JavaMailSenderImpl</code> 来完成邮件的发送工作。</p><p>做完如上两步，邮件发送的准备工作就算是完成了，接下来就可以直接发送邮件了。</p><p>具体的发送，有 5 种不同的方式，我们一个一个来看。</p><h2 id="发送简单邮件"><a href="#发送简单邮件" class="headerlink" title="发送简单邮件"></a>发送简单邮件</h2><p>简单邮件就是指邮件内容是一个普通的文本文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JavaMailSender javaMailSender;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSimpleMail</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();</span><br><span class="line">    message.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    message.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    message.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    message.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    message.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    message.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    message.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    javaMailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上往下，代码含义分别如下：</p><ol><li>构建一个邮件对象</li><li>设置邮件主题</li><li>设置邮件发送者</li><li>设置邮件接收者，可以有多个接收者</li><li>设置邮件抄送人，可以有多个抄送人</li><li>设置隐秘抄送人，可以有多个</li><li>设置邮件发送日期</li><li>设置邮件的正文</li><li>发送邮件</li></ol><p>最后执行该方法，就可以实现邮件的发送，发送效果图如下：</p><p><img src="./img/43-5.png" alt></p><h2 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h2><p>邮件的附件可以是图片，也可以是普通文件，都是支持的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAttachFileMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    helper.addAttachment(<span class="hljs-string">"javaboy.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里在构建邮件对象上和前文有所差异，这里是通过 javaMailSender 来获取一个复杂邮件对象，然后再利用 MimeMessageHelper 对邮件进行配置，MimeMessageHelper 是一个邮件配置的辅助工具类，创建时候的 true 表示构建一个 multipart message 类型的邮件，有了 MimeMessageHelper 之后，我们针对邮件的配置都是由 MimeMessageHelper 来代劳。</p><p>最后通过 addAttachment 方法来添加一个附件。</p><p>执行该方法，邮件发送效果图如下：</p><p><img src="./img/43-6.png" alt></p><h2 id="发送带图片资源的邮件"><a href="#发送带图片资源的邮件" class="headerlink" title="发送带图片资源的邮件"></a>发送带图片资源的邮件</h2><p>图片资源和附件有什么区别呢？图片资源是放在邮件正文中的，即一打开邮件，就能看到图片。但是一般来说，不建议使用这种方式，一些公司会对邮件内容的大小有限制（因为这种方式是将图片一起发送的）。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendImgResMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"&lt;p&gt;hello 大家好，这是一封测试邮件，这封邮件包含两种图片，分别如下&lt;/p&gt;&lt;p&gt;第一张图片：&lt;/p&gt;&lt;img src='cid:p01'/&gt;&lt;p&gt;第二张图片：&lt;/p&gt;&lt;img src='cid:p02'/&gt;"</span>,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p01"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>)));</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p02"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy2.png"</span>)));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的邮件 text 是一个 HTML 文本，里边涉及到的图片资源先用一个占位符占着，setText 方法的第二个参数 true 表示第一个参数是一个 HTML 文本。</p><p>setText 之后，再通过 addInline 方法来添加图片资源。</p><p>最后执行该方法，发送邮件，效果如下：</p><p><img src="./img/43-7.png" alt></p><p>在公司实际开发中，第一种和第三种都不是使用最多的邮件发送方案。因为正常来说，邮件的内容都是比较的丰富的，所以大部分邮件都是通过 HTML 来呈现的，如果直接拼接 HTML 字符串，这样以后不好维护，为了解决这个问题，一般邮件发送，都会有相应的邮件模板。最具代表性的两个模板就是 <code>Freemarker</code> 模板和 <code>Thyemeleaf</code> 模板了。</p><h2 id="使用-Freemarker-作邮件模板"><a href="#使用-Freemarker-作邮件模板" class="headerlink" title="使用 Freemarker 作邮件模板"></a>使用 Freemarker 作邮件模板</h2><p>首先需要引入 Freemarker 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>resources/templates</code> 目录下创建一个 <code>mail.ftl</code> 作为邮件发送模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;salary&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，将邮件模板渲染成 HTML ，然后发送即可。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFreemarkerMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException, IOException, TemplateException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    <span class="hljs-comment">//构建 Freemarker 的基本配置</span></span><br><span class="line">    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_0);</span><br><span class="line">    <span class="hljs-comment">// 配置模板位置</span></span><br><span class="line">    ClassLoader loader = MailApplication.class.getClassLoader();</span><br><span class="line">    configuration.setClassLoaderForTemplateLoading(loader, <span class="hljs-string">"templates"</span>);</span><br><span class="line">    <span class="hljs-comment">//加载模板</span></span><br><span class="line">    Template template = configuration.getTemplate(<span class="hljs-string">"mail.ftl"</span>);</span><br><span class="line">    User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    user.setNum(<span class="hljs-number">1</span>);</span><br><span class="line">    user.setSalary((<span class="hljs-keyword">double</span>) <span class="hljs-number">99999</span>);</span><br><span class="line">    StringWriter out = <span class="hljs-keyword">new</span> StringWriter();</span><br><span class="line">    <span class="hljs-comment">//模板渲染，渲染的结果将被保存到 out 中 ，将out 中的 html 字符串发送即可</span></span><br><span class="line">    template.process(user, out);</span><br><span class="line">    helper.setText(out.toString(),<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，虽然引入了 <code>Freemarker</code> 的自动化配置，但是我们在这里是直接 <code>new Configuration</code> 来重新配置 <code>Freemarker</code> 的，所以 Freemarker 默认的配置这里不生效，因此，在填写模板位置时，值为 <code>templates</code> 。</p><p>调用该方法，发送邮件，效果图如下：</p><p><img src="./img/43-8.png" alt></p><h2 id="使用-Thymeleaf-作邮件模板"><a href="#使用-Thymeleaf-作邮件模板" class="headerlink" title="使用 Thymeleaf 作邮件模板"></a>使用 Thymeleaf 作邮件模板</h2><p>推荐在 Spring Boot 中使用 Thymeleaf 来构建邮件模板。因为 Thymeleaf 的自动化配置提供了一个 TemplateEngine，通过 TemplateEngine 可以方便的将 Thymeleaf 模板渲染为 HTML ，同时，Thymeleaf 的自动化配置在这里是继续有效的 。</p><p>首先，引入 Thymeleaf 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，创建 <code>Thymeleaf</code> 邮件模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;username&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;num&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;salary&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来发送邮件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendThymeleafMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    Context context = <span class="hljs-keyword">new</span> Context();</span><br><span class="line">    context.setVariable(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"num"</span>,<span class="hljs-string">"000001"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"salary"</span>, <span class="hljs-string">"99999"</span>);</span><br><span class="line">    String process = templateEngine.process(<span class="hljs-string">"mail.html"</span>, context);</span><br><span class="line">    helper.setText(process,<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法，发送邮件，效果图如下：</p><p><img src="./img/43-8.png" alt></p><p>好了，这就是我们今天说的 5 种邮件发送姿势，不知道你掌握了没有呢？</p><p>本文案例已经上传到 GitHub：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a>。</p><p>有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.776Z</published>
    <updated>2020-01-13T01:53:46.518Z</updated>
    
    <content type="html"><![CDATA[<p>之前松哥和大家分享过一篇将 Spring Boot 项目部署到远程 Docker 上的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/7DrvNHM6MGc7lwz8JDULSQ" target="_blank" rel="noopener">一键部署 Spring Boot 到远程 Docker 容器</a></li></ul><p>但是这种部署有一个问题，就是一个小小的 helloworld 构建成镜像之后，竟然都有 660 MB+，这就有点过分了；而且这种方式步骤繁琐，很多人看了头大。</p><p>因此松哥今天想再和大家聊一聊另外一种方案 <strong>Jib</strong>，这是谷歌开源的一个容器化运行方案，使用它我们将 Spring Boot 进行容器化部署只要两步：</p><ul><li>第一步配置 Maven Plugin</li><li>第二步构建</li></ul><p>我们一起来看看。</p><h2 id="Jib"><a href="#Jib" class="headerlink" title="Jib"></a>Jib</h2><p>在之前那篇文章中，我们将 Spring Boot 项目进行容器化部署，要求开发人员要有一定的 Docker 技能作为支撑，然而在实际开发中，并非每个人都是 Docker 专家，或者说会用 Docker。</p><p>有鉴于此，Google 搞出来一个 Jib，使 Spring Boot 容器化部署变得更加简便，开发人员可以不需要任何 Docker 相关的技能，就能将 Spring Boot 项目构建成 Docker 中的镜像，而且还可以“顺便”将镜像 push 到 register 上，极大的简化了部署过程。</p><p>Jib 使用 Java 开发，使用也非常简单，可以作为 Maven 或者 Gradle 的插件直接集成到我们的项目中。它利用镜像分层和注册表缓存来实现快速、增量的构建。Jib 会自动读取项目的构建配置，代码组织到不同的层（依赖项、资源、类）中，然后它只会重新构建和推送发生变更的层。在项目进行快速迭代时，Jib 只将发生变更的层推送到 registers 来缩短构建时间。</p><p>好了，大致了解了 Jib 之后，接下来我们来看看 Jib 要怎么使用。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Jib 可以直接将构建好的镜像 push 到 registers 上，如果公司有自己的私有镜像站的话，可以直接推送到私有镜像站上，本文我就将构建好的镜像推送到官方的 Docker Hub 上，因此需要大家提前准备一个 Docker Hub 的账号，账号大家可以直接去 Docker Hub 上面注册（<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a>），大家要是对 Docker Hub 这些东西不了解，可以在公众号后台回复 docker，获取松哥自制的 Docker 教程。</p><h2 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h2><p>首先我们来创建一个 Spring Boot 工程，创建时只需要添加一个 Web 依赖即可：</p><p><img src="./img/42-1.png" alt></p><p>项目创建成功后，添加一个 HelloController 用来做测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello jib"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在 pom.xml 中添加上 Jib 的插件，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.cloud.tools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jib-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>openjdk:alpine<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>docker.io/wongsung/dockerjib<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">tags</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>v1<span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">tags</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">auth</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>wongsung<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>你的密码<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">auth</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于这段配置，我说如下几点：</p><ol><li>首先就是版本号的问题，我这里使用的是 <code>1.7.0</code> ，网上有的教程比较老，用的 0.x 的版本，老的版本在配置 Docker 认证的时候非常麻烦，所以版本这块建议大家使用当前最新版。</li><li>from 中的配置表示本镜像构建所基于的根镜像为 <code>openjdk:alpine</code></li><li>to 中的配置表示本镜像构建完成后，要发布到哪里去，如果是发布到私有镜像站，就写自己私有镜像站的地址，如果是发布到 Docker Hub 上，就参考我这里的写法 <code>docker.io/wongsung/dockerjib</code>，其中 wongsung 表示你在 Docker Hub 上注册的用户名，dockerjib 表示你镜像的名字，可以随意取。</li><li>tags 中配置的是自己镜像的版本。</li><li>auth 中配置你在 Docker Hub 上的用户名/密码。</li><li>executions 节点中的就是常规配置了，我就不再多说了。</li></ol><p>配置完成后，在命令行执行如下命令将当前下项目构建成一个 Docker 镜像并 push 到 Docker Hub：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile jib:build</span><br></pre></td></tr></table></figure><p>构建完成后，我们在 Docker Hub 上就能看到自己的镜像了：</p><p><img src="./img/42-2.png" alt></p><p>接下来，启动 Docker ，在 Docker 中执行如下命令拉取镜像下来并运行：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mydockerjib -p 8080:8080 docker.io/wongsung/dockerjib:v1</span><br></pre></td></tr></table></figure><p>启动成功后，我们在浏览器中就可以直接访问我们刚才的 Spring Boot 项目中的 hello 接口了：</p><p><img src="./img/42-3.png" alt></p><p>是不是很方便？比我第一次给大家介绍的方案要方便很多。</p><p><strong>注意</strong></p><p>这种方式是将项目构建成镜像后并 push 到 registers 上，这种构建方式不需要你本地安装 Docker，如果你需要在本地运行镜像，那当然需要 Docker，单纯的构建是不需要 Docker 环境的。</p><h2 id="本地构建"><a href="#本地构建" class="headerlink" title="本地构建"></a>本地构建</h2><p>如果你电脑本地刚好安装了 Docker ，有 Docker 环境，那么也可以将项目构建成本地 Docker 的镜像，</p><p>首先我们来查看一下本地镜像：</p><p><img src="./img/42-4.png" alt></p><p>可以看到只有 MySQL 镜像，然后我们执行如下命令构建本地镜像：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile jib:dockerBuild</span><br></pre></td></tr></table></figure><p>看到如下构建日志信息表示构建成功：</p><p><img src="./img/42-5.png" alt></p><p>构建完成后，我们再来看本地镜像：</p><p><img src="./img/42-6.png" alt></p><p>可以都看到，已经构建成功了，接下来启动命令和上面一样，我就不重复展示了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>容器的出现，让我们的 Java 程序比任何时候都接近“一次编写，到处运行”，Spring Boot 容器化部署也是越来越方便，后面有空松哥再和大家聊聊结合 jenkins 的用法，好了，本文的案例我已经上传到 GitHub：<a href="https://github.com/lenve/javaboy-code-samples，有问题欢迎留言讨论。" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples，有问题欢迎留言讨论。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前松哥和大家分享过一篇将 Spring Boot 项目部署到远程 Docker 上的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7DrvNHM6MGc7lwz8JDULSQ&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.776Z</published>
    <updated>2020-01-13T01:53:46.519Z</updated>
    
    <content type="html"><![CDATA[<p>真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。</p><p>如果大家没看过松哥之前写的 Spring Boot 整合 Spring Session，可以先回顾下：</p><ul><li><a href="https://mp.weixin.qq.com/s/qf-cQ7wI_Sp5pENTLlCRJw" target="_blank" rel="noopener">Spring Boot2 系列教程(二十八)Spring Boot 整合 Session 共享</a></li></ul><h2 id="第一次踩坑"><a href="#第一次踩坑" class="headerlink" title="第一次踩坑"></a>第一次踩坑</h2><p>事情是这样的，大概在今年 6 月初的时候，我在项目中使用到了 Session 共享，当时采用的方案就是 Redis+Spring Session。本来这是一个很简单的问题，我在以前的项目中也用过多次这种方案，早已轻车熟路，但是那次有点不对劲，项目启动时候报了如下错误：</p><p><img src="./img/44-1.png" alt></p><p>一模一样的代码，但是运行就是会出错，我感觉莫名其妙。因为在 Spring Boot 中整合 Spring Session 是一个非常简单的操作，就几行 Redis 的配置而已，我在确认了代码没问题之后，很快想到了可能是版本问题，因为当时 Spring Boot2.1.5 刚刚发布，我喜欢用最新版。于是我尝试将 Spring Boot 的版本切换到 2.1.4 ，切换回去之后，果然就 OK了，再次启动项目又不会报错了。于是基本确定这是 Spring Boot 的版本升级带来的问题。</p><p>但是当时我并没有深究，我以为就是官方出于安全考虑，让你在使用 Redis 时强制加上 Spring Security（因为根据错误提示，很容想到加上 Spring Security 依赖），加上 Spring Security 依赖之后，果然就没有问题了，我也没有多想，这件事就这样过了。​</p><h2 id="第二次踩坑"><a href="#第二次踩坑" class="headerlink" title="第二次踩坑"></a>第二次踩坑</h2><p>前两天我在给星球上的小伙伴录制 Spring Boot 视频的时候，采用了  Spring Boot 最新版 2.1.7，也是 Spring Session，但是在创建项目的时候，忘记添加 Spring Security 依赖了（第一次踩坑之后，我每次用 Spring Session 都会自觉的加上 Spring Security 依赖），运行的时候竟然没报错！我就郁闷了。</p><p>于是我去试了 Spring Boot2.1.4、Spring Boot2.1.6 发现都没有问题，在使用 Spring Session 的时候都不需要添加 Spring Security 依赖，只有 Spring Boot2.1.5 才有这个问题。于是我大概明白了，这可能是一个 Bug，而不是版本升级的新功能。</p><p>这一次，那我就打算追究一下问题的根源。</p><h2 id="源头"><a href="#源头" class="headerlink" title="源头"></a>源头</h2><p>要追究问题的源头，我们当然得从 Spring Session 的自动化配置类开始。</p><p>在 Spring Boot2.1.5 的 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类中，我看到如下源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectProvider&lt;SpringSessionRememberMeServices&gt; springSessionRememberMeServices)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//.....</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer</span><br><span class="line">.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line">springSessionRememberMeServices.ifAvailable((</span><br><span class="line">rememberMeServices) -&gt; cookieSerializer.setRememberMeRequestAttribute(</span><br><span class="line">SpringSessionRememberMeServices.REMEMBER_ME_LOGIN_ATTR));</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这一段源码中我们可以看到，这里使用到了 SpringSessionRememberMeServices ，而这个类中则用到 Spring Security 中相关的类。因此，如果不引入 Spring Security 就会报错。</p><p>我们再来看看 Spring Boot2.1.6 中 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类的源码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line"><span class="hljs-keyword">if</span> (ClassUtils.isPresent(REMEMBER_ME_SERVICES_CLASS, getClass().getClassLoader())) &#123;</span><br><span class="line"><span class="hljs-keyword">new</span> RememberMeServicesCookieSerializerCustomizer().apply(cookieSerializer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 Spring Boot2.1.6 中，这个问题已经得到修复。这里就没有 2.1.5 那么冲动了，上来了先用 <code>ClassUtils.isPresent</code> 方法判断了下 REMEMBER_ME_SERVICES_CLASS(<code>org.springframework.security.web.authentication.RememberMeServices</code>) 是否存在，存在的话，才有后面的操作。</p><p>至此，这个问题就总算弄懂了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>大家平时遇到问题，如果项目不是很赶的话，可以留意多想想，多追究一下原因，说不定你会有很多意外的收获。我这次就是一个活生生的例子，一开始没多想，后来又发现不对劲，前前后后一折腾，反而又多浪费了一些时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。&lt;/p&gt;
&lt;p&gt;如果大家没看过松哥之前写的 Spring Boot 整合 Spring Sessi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.776Z</published>
    <updated>2020-01-13T01:53:46.518Z</updated>
    
    <content type="html"><![CDATA[<p>前两天被人问到这样一个问题:</p><p>“松哥，为什么我的 Spring Boot 项目打包成的 jar ，被其他项目依赖之后，总是报找不到类的错误？”</p><p>大伙有这样的疑问，就是因为还没搞清楚可执行 jar 和普通 jar 到底有什么区别？今天松哥就和大家来聊一聊这个问题。</p><h2 id="多了一个插件"><a href="#多了一个插件" class="headerlink" title="多了一个插件"></a>多了一个插件</h2><p>Spring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 <code>java -jar xxx.jar</code> 命令执行，普通的 <code>jar</code> 主要是被其他应用依赖，<code>Spring Boot</code> 打成的 <code>jar</code> 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。</p><p>有的小伙伴可能就有疑问了，既然同样是执行 <code>mvn package</code> 命令进行项目打包，为什么 Spring Boot 项目就打成了可执行 jar ，而普通项目则打包成了不可执行 jar 呢？</p><p>这我们就不得不提 Spring Boot 项目中一个默认的插件配置 <code>spring-boot-maven-plugin</code> ，这个打包插件存在 5 个方面的功能，从插件命令就可以看出：</p><p><img src="./img/40-1.png" alt></p><p>五个功能分别是：</p><ul><li>build-info：生成项目的构建信息文件 build-info.properties</li><li>repackage：这个是默认 goal，在 <code>mvn package</code> 执行之后，这个命令再次打包生成可执行的 jar，同时将 <code>mvn package</code> 生成的 jar 重命名为 <code>*.origin</code></li><li>run：这个可以用来运行 Spring Boot 应用</li><li>start：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li><li>stop：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li></ul><p>这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置。</p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>repackage 功能的 作用，就是在打包的时候，多做一点额外的事情：</p><ol><li>首先 <code>mvn package</code> 命令 对项目进行打包，打成一个 <code>jar</code>，这个 <code>jar</code> 就是一个普通的 <code>jar</code>，可以被其他项目依赖，但是不可以被执行</li><li><code>repackage</code> 命令，对第一步 打包成的 <code>jar</code> 进行再次打包，将之打成一个 可执行 <code>jar</code> ，通过将第一步打成的 <code>jar</code> 重命名为 <code>*.original</code> 文件</li></ol><p>举个例子：</p><p>对任意一个 Spring Boot 项目进行打包，可以执行 <code>mvn package</code> 命令，也可以直接在 <code>IDEA</code> 中点击 <code>package</code> ，如下 ：</p><p><img src="./img/40-2.png" alt></p><p>打包成功之后， <code>target</code> 中的文件如下：</p><p><img src="./img/40-3.png" alt></p><p>这里有两个文件，第一个 <code>restful-0.0.1-SNAPSHOT.jar</code> 表示打包成的可执行 <code>jar</code> ，第二个 <code>restful-0.0.1-SNAPSHOT.jar.original</code> 则是在打包过程中 ，被重命名的 <code>jar</code>，这是一个不可执行 <code>jar</code>，但是可以被其他项目依赖的 <code>jar</code>。通过对这两个文件的解压，我们可以看出这两者之间的差异。</p><h2 id="两种-jar-的比较"><a href="#两种-jar-的比较" class="headerlink" title="两种 jar 的比较"></a>两种 jar 的比较</h2><p>可执行 <code>jar</code> 解压之后，目录如下：</p><p><img src="./img/40-4.png" alt></p><p>可以看到，可执行 jar 中，我们自己的代码是存在 于 <code>BOOT-INF/classes/</code> 目录下，另外，还有一个 <code>META-INF</code> 的目录，该目录下有一个 <code>MANIFEST.MF</code> 文件，打开该文件，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: restful</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Start-Class: org.javaboy.restful.RestfulApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Spring-Boot-Version: 2.1.6.RELEASE</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure><p>可以看到，这里定义了一个 <code>Start-Class</code>，这就是可执行 <code>jar</code> 的入口类，<code>Spring-Boot-Classes</code> 表示我们自己代码编译后的位置，<code>Spring-Boot-Lib</code> 则表示项目依赖的 <code>jar</code> 的位置。</p><p>换句话说，如果自己要打一个可执行 <code>jar</code> 包的话，除了添加相关依赖之外，还需要配置 <code>META-INF/MANIFEST.MF</code> 文件。</p><p>这是可执行 jar 的结构，那么不可执行 jar 的结构呢？</p><p>我们首先将默认的后缀 <code>.original</code> 除去，然后给文件重命名，重命名完成，进行解压：</p><p><img src="./img/40-5.png" alt></p><p>解压后可以看到，不可执行 <code>jar</code> 根目录就相当于我们的 <code>classpath</code>，解压之后，直接就能看到我们的代码，它也有 <code>META-INF/MANIFEST.MF</code> 文件，但是文件中没有定义启动类等。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: restful</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>这个不可以执行 <code>jar</code> 也没有将项目的依赖打包进来。</p><p>从这里我们就可以看出，两个 <code>jar</code> ，虽然都是 <code>jar</code> 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。</p><h2 id="一次打包两个-jar"><a href="#一次打包两个-jar" class="headerlink" title="一次打包两个 jar"></a>一次打包两个 jar</h2><p>一般来说，Spring Boot 直接打包成可执行 <code>jar</code> 就可以了，不建议将 Spring Boot 作为普通的 <code>jar</code> 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 <code>Maven</code> 项目，然后在 Spring Boot 中引用这个 <code>Maven</code> 项目。</p><p>如果非要将 Spring Boot 打包成一个普通 <code>jar</code> 被其他项目依赖，技术上来说，也是可以的，给 <code>spring-boot-maven-plugin</code> 插件添加如下配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置的 <code>classifier</code> 表示可执行 <code>jar</code> 的名字，配置了这个之后，在插件执行 <code>repackage</code> 命令时，就不会给 <code>mvn package</code> 所打成的 <code>jar</code> 重命名了，所以，打包后的 jar 如下：</p><p><img src="./img/40-6.png" alt></p><p>第一个 jar 表示可以被其他项目依赖的 jar ，第二个 jar 则表示一个可执行 jar。</p><p>好了，关于 Spring Boot 中 jar 的问题，我们就说这么多，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天被人问到这样一个问题:&lt;/p&gt;
&lt;p&gt;“松哥，为什么我的 Spring Boot 项目打包成的 jar ，被其他项目依赖之后，总是报找不到类的错误？”&lt;/p&gt;
&lt;p&gt;大伙有这样的疑问，就是因为还没搞清楚可执行 jar 和普通 jar 到底有什么区别？今天松哥就和大家来
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.775Z</published>
    <updated>2020-01-13T01:53:46.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾热部署"><a href="#回顾热部署" class="headerlink" title="回顾热部署"></a>回顾热部署</h1><p>Spring Boot 中的热部署相信大家都用过吧，只需要添加 <code>spring-boot-devtools</code> 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：</p><ul><li>base classloader</li><li>restart classloader</li></ul><p>其中 base classloader 用来加载那些不会变化的类，例如各种第三方依赖，而 restart classloader 则用来加载那些会发生变化的类，例如你自己写的代码。Spring Boot 中热部署的原理就是当代码发生变化时，base classloader 不变，而 restart classloader 则会被废弃，被另一个新的 restart classloader 代替。在整个过程中，因为只重新加载了变化的类，所以启动速度要被重启快。</p><p>但是有另外一个问题，就是静态资源文件！使用 devtools ，默认情况下当静态资源发生变化时，并不会触发项目重启。虽然我们可以通过配置解决这一问题，但是没有必要！因为静态资源文件发生变化后不需要编译，按理说保存后刷新下就可以访问到了。</p><p>那么如何才能实现静态资源变化后，不编译就能自动刷新呢？ LiveReload 可以帮助我们实现这一功能！</p><h1 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h1><p>devtools 中默认嵌入了 LiveReload 服务器，利用 LiveReload 可以实现静态文件的热部署，LiveReload 可以在资源发生变化时自动触发浏览器更新，LiveReload 支持 Chrome、Firefox 以及 Safari 。以 Chrome 为例，在 Chrome 应用商店搜索 LiveReload ，结果如下图：</p><p><img src="./img/39-1.png" alt></p><p>将第一个搜索结果添加到 Chrome 中，添加成功后，在 Chrome 右上角有一个 LiveReload 图标</p><p><img src="./img/39-2.png" alt></p><p>在浏览器中打开项目的页面，然后点击浏览器右上角的 LiveReload 按钮，打开 LiveReload 连接。</p><p><strong>注意：</strong></p><p>LiveReload 是和浏览器选项卡绑定在一起的，在哪个选项卡中打开了 LiveReload，就在哪个选项卡中访问页面，这样才有效果。</p><p>打开 LiveReload 之后，我们启动一个加了 devtools 依赖的 Spring Boot 项目：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时随便在 resources/static 目录下添加一个静态 html 页面，然后启动 Spring Boot 项目，在<strong>打开了 LiveReload 的选项卡中访问 html 页面</strong>。</p><p>访问成功后，我们再去手动修改 html 页面代码，修改成功后，回到浏览器，不用做任何操作，就会发现浏览器自动刷新了，页面已经更新了。</p><p>整个过程中，我的 Spring Boot 项目并没有重启。</p><p>如果开发者安装并且启动了 LiveReload 插件，同时也添加了 devtools 依赖，但是却并不想当静态页面发生变化时浏览器自动刷新，那么可以在 application.properties 中添加如下代码进行配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.livereload.enabled=false</span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>建议开发者使用 LiveReload 策略而不是项目重启策略来实现静态资源的动态加载，因为项目重启所耗费时间一般来说要超过使用LiveReload 所耗费的时间。</p><p>Firefox 也可以安装 LiveReload 插件，装好之后和 Chrome 用法基本一致，这里不再赘述。</p><p>如果小伙伴们的 Chrome 商店使用不便，可以在松哥公众号后台回复 livereload，松哥有下载好的离线安装包。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回顾热部署&quot;&gt;&lt;a href=&quot;#回顾热部署&quot; class=&quot;headerlink&quot; title=&quot;回顾热部署&quot;&gt;&lt;/a&gt;回顾热部署&lt;/h1&gt;&lt;p&gt;Spring Boot 中的热部署相信大家都用过吧，只需要添加 &lt;code&gt;spring-boot-devtools
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.775Z</published>
    <updated>2020-01-13T01:53:46.516Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用：</p><ol><li><a href="https://mp.weixin.qq.com/s/88zkkf6WyS_Jtv74qOdr8Q" target="_blank" rel="noopener">手把手带你入门 Spring Security！</a></li><li><a href="https://mp.weixin.qq.com/s/B9t0EtOCiM3wiCbosByMrQ" target="_blank" rel="noopener">Spring Security 登录添加验证码</a></li><li><a href="https://mp.weixin.qq.com/s/QApGe7I94lAMiYy8qbLZ9A" target="_blank" rel="noopener">SpringSecurity 登录使用 JSON 格式数据</a></li><li><a href="https://mp.weixin.qq.com/s/-K8W06y_-hvJvIgNsk3V_A" target="_blank" rel="noopener">Spring Security 中的角色继承问题</a></li><li><a href="https://mp.weixin.qq.com/s/Ykzo5sWdfmKig810Gp8JRw" target="_blank" rel="noopener">Spring Security 中使用 JWT!</a></li><li><a href="https://mp.weixin.qq.com/s/1rVPzJGCtDZKvMoA4BYzIA" target="_blank" rel="noopener">Spring Security 结合 OAuth2</a></li></ol><p>不过，今天要和小伙伴们聊一聊 Spring Security 中的另外一个问题，那就是在 Spring Security 中未获认证的请求默认会重定向到登录页，但是在前后端分离的登录中，这个默认行为则显得非常不合适，今天我们主要来看看如何实现未获认证的请求直接返回 JSON ，而不是重定向到登录页面。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这里关于 Spring Security 的基本用法我就不再赘述了，如果小伙伴们不了解，可以参考上面的 6 篇文章。</p><p>大家知道，在自定义 Spring Security 配置的时候，有这样几个属性：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login"</span>)</span><br><span class="line">            <span class="hljs-comment">//其他配置</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个比较重要的属性：</p><ul><li>loginProcessingUrl：这个表示配置处理登录请求的接口地址，例如你是表单登录，那么 form 表单中 action 的值就是这里填的值。</li><li>loginPage：这个表示登录页的地址，例如当你访问一个需要登录后才能访问的资源时，系统就会自动给你通过重定向跳转到这个页面上来。</li></ul><p>这种配置在前后端不分的登录中是没有问题的，在前后端分离的登录中，这种配置就有问题了。我举个简单的例子，例如我想访问 <code>/hello</code> 接口，但是这个接口需要登录之后才能访问，我现在没有登录就直接去访问这个接口了，那么系统会给我返回 302，让我去登录页面，在前后端分离中，我的后端一般是没有登录页面的，就是一个提示 JSON，例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">"尚未登录，请登录!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整代码大家可以参考我的微人事项目。</p></blockquote><p>也就是说，当我没有登录直接去访问 <code>/hello</code> 这个接口的时候，我会看到上面这段 JSON 字符串。在前后端分离开发中，这个看起来没问题（后端不再做页面跳转，无论发生什么都是返回 JSON）。但是问题就出在这里，系统默认的跳转是一个重定向，就是说当你访问 <code>/hello</code> 的时候，服务端会给浏览器返回 302，同时响应头中有一个 Location 字段，它的值为 <code>http://localhost:8081/login</code> ，也就是告诉浏览器你去访问 <code>http://localhost:8081/login</code> 地址吧。浏览器收到指令之后，就会直接去访问 <code>http://localhost:8081/login</code> 地址，如果此时是开发环境并且请求还是 Ajax 请求，就会发生跨域。因为前后端分离开发中，前端我们一般在 NodeJS 上启动，然后前端的所有请求通过 NodeJS 做请求转发，现在服务端直接把请求地址告诉浏览器了，浏览器就会直接去访问 <code>http://localhost:8081/login</code> 了，而不会做请求转发了，因此就发生了跨域问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>很明显，上面的问题我们不能用跨域的思路来解决，虽然这种方式看起来也能解决问题，但不是最佳方案。</p><p>如果我们的 Spring Security 在用户未获认证的时候去请求一个需要认证后才能请求的数据，此时不给用户重定向，而是直接就返回一个 JSON，告诉用户这个请求需要认证之后才能发起，就不会有上面的事情了。</p><p>这里就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Performs the redirect (or forward) to the login form URL.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationException authException)</span> </span>&#123;</span><br><span class="line">String redirectUrl = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (useForward) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (forceHttps &amp;&amp; <span class="hljs-string">"http"</span>.equals(request.getScheme())) &#123;</span><br><span class="line">redirectUrl = buildHttpsRedirectUrlForRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (redirectUrl == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String loginForm = determineUrlToUseForThisRequest(request, response,</span><br><span class="line">authException);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Server side forward to: "</span> + loginForm);</span><br><span class="line">&#125;</span><br><span class="line">RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);</span><br><span class="line">&#125;</span><br><span class="line">redirectStrategy.sendRedirect(request, response, redirectUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p><p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login"</span>)</span><br><span class="line">            <span class="hljs-comment">//其他配置</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable().exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(<span class="hljs-keyword">new</span> AuthenticationEntryPoint() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                PrintWriter out = resp.getWriter();</span><br><span class="line">                RespBean respBean = RespBean.error(<span class="hljs-string">"访问失败!"</span>);</span><br><span class="line">                <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;</span><br><span class="line">                    respBean.setMsg(<span class="hljs-string">"请求失败，请联系管理员!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，一个小小的重定向问题和小伙伴们分享下，不知道大家有没有看懂呢？这也是我最近在重构微人事的时候遇到的问题。预计 12 月份，微人事的 Spring Boot 版本会升级到目前最新版，请小伙伴们留意哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/88zkkf6WyS_Jtv74qOdr8Q&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.775Z</published>
    <updated>2020-01-13T01:53:46.531Z</updated>
    
    <content type="html"><![CDATA[<p>在前后端分离的项目中，登录策略也有不少，不过 JWT 算是目前比较流行的一种解决方案了，本文就和大家来分享一下如何将 Spring Security 和 JWT 结合在一起使用，进而实现前后端分离时的登录解决方案。</p><h2 id="1-无状态登录"><a href="#1-无状态登录" class="headerlink" title="1 无状态登录"></a>1 无状态登录</h2><h3 id="1-1-什么是有状态？"><a href="#1-1-什么是有状态？" class="headerlink" title="1.1 什么是有状态？"></a>1.1 什么是有状态？</h3><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h3 id="1-2-什么是无状态"><a href="#1-2-什么是无状态" class="headerlink" title="1.2 什么是无状态"></a>1.2 什么是无状态</h3><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3 如何实现无状态"></a>1.3 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="1-4-JWT"><a href="#1-4-JWT" class="headerlink" title="1.4 JWT"></a>1.4 JWT</h3><h4 id="1-4-1-简介"><a href="#1-4-1-简介" class="headerlink" title="1.4.1 简介"></a>1.4.1 简介</h4><p>JWT，全称是 Json Web Token， 是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权：</p><p><img src="./img/37-1.png" alt></p><p>JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的 Java 实现是 GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p><h4 id="1-4-2-JWT数据格式"><a href="#1-4-2-JWT数据格式" class="headerlink" title="1.4.2 JWT数据格式"></a>1.4.2 JWT数据格式</h4><p>JWT 包含三部分数据：</p><ul><li><p>Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul></li></ul><p>我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据。</p><ul><li><p>Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></li></ul><p>这部分也会采用 Base64Url 编码，得到第二部分数据。</p><ul><li>Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成。用于验证整个数据完整和可靠性。</li></ul><p>生成的数据格式如下图：</p><p><img src="./img/37-2.png" alt></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h4 id="1-4-3-JWT-交互流程"><a href="#1-4-3-JWT-交互流程" class="headerlink" title="1.4.3 JWT 交互流程"></a>1.4.3 JWT 交互流程</h4><p>流程图：</p><p> <img src="./img/37-3.png" alt></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如 API）</li></ol><p>因为 JWT 签发的 token 中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了 RESTful 的无状态规范。</p><h3 id="1-5-JWT-存在的问题"><a href="#1-5-JWT-存在的问题" class="headerlink" title="1.5 JWT 存在的问题"></a>1.5 JWT 存在的问题</h3><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p><ol><li>续签问题，这是被很多人诟病的问题之一，传统的 cookie+session 的方案天然的支持续签，但是 jwt 由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入 redis，虽然可以解决问题，但是 jwt 也变得不伦不类了。</li><li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改 secret 来实现注销，服务端 secret 修改后，已经颁发的未过期的 token 就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li><li>密码重置，密码重置后，原本的 token 依然可以访问系统，这时候也需要强制修改 secret。</li><li>基于第 2 点和第 3 点，一般建议不同用户取不同 secret。</li></ol><h2 id="2-实战"><a href="#2-实战" class="headerlink" title="2 实战"></a>2 实战</h2><p>说了这么久，接下来我们就来看看这个东西到底要怎么用？</p><h3 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h3><p>首先我们来创建一个 Spring Boot 项目，创建时需要添加 Spring Security 依赖，创建完成后，添加 <code>jjwt</code> 依赖，完整的 pom.xml 文件如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在项目中创建一个简单的 User 对象实现 UserDetails 接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccountNonLocked</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCredentialsNonExpired</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//省略getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我们的用户对象，先放着备用，再创建一个 HelloController，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello jwt !"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello admin !"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloController 很简单，这里有两个接口，设计是 <code>/hello</code> 接口可以被具有 user 角色的用户访问，而 <code>/admin</code> 接口则可以被具有 admin 角色的用户访问。</p><h3 id="2-2-JWT-过滤器配置"><a href="#2-2-JWT-过滤器配置" class="headerlink" title="2.2 JWT 过滤器配置"></a>2.2 JWT 过滤器配置</h3><p>接下来提供两个和 JWT 相关的过滤器配置：</p><ol><li>一个是用户登录的过滤器，在用户的登录的过滤器中校验用户是否登录成功，如果登录成功，则生成一个token返回给客户端，登录失败则给前端一个登录失败的提示。</li><li>第二个过滤器则是当其他请求发送来，校验token的过滤器，如果校验成功，就让请求继续执行。</li></ol><p>这两个过滤器，我们分别来看，先看第一个：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtLoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">JwtLoginFilter</span><span class="hljs-params">(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(defaultFilterProcessesUrl));</span><br><span class="line">        setAuthenticationManager(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> AuthenticationException, IOException, ServletException </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> ObjectMapper().readValue(req.getInputStream(), User.class);</span><br><span class="line">        <span class="hljs-keyword">return</span> getAuthenticationManager().authenticate(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, FilterChain chain, Authentication authResult)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        Collection&lt;? extends GrantedAuthority&gt; authorities = authResult.getAuthorities();</span><br><span class="line">        StringBuffer as = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">            as.append(authority.getAuthority())</span><br><span class="line">                    .append(<span class="hljs-string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String jwt = Jwts.builder()</span><br><span class="line">                .claim(<span class="hljs-string">"authorities"</span>, as)<span class="hljs-comment">//配置用户角色</span></span><br><span class="line">                .setSubject(authResult.getName())</span><br><span class="line">                .setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512,<span class="hljs-string">"sang@123"</span>)</span><br><span class="line">                .compact();</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(jwt));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException failed)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="hljs-string">"登录失败!"</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个类，我说如下几点：</p><ol><li>自定义 JwtLoginFilter 继承自 AbstractAuthenticationProcessingFilter，并实现其中的三个默认方法。</li><li>attemptAuthentication 方法中，我们从登录参数中提取出用户名密码，然后调用 AuthenticationManager.authenticate() 方法去进行自动校验。</li><li>第二步如果校验成功，就会来到 successfulAuthentication 回调中，在 successfulAuthentication 方法中，将用户角色遍历然后用一个 <code>,</code> 连接起来，然后再利用 Jwts 去生成 token，按照代码的顺序，生成过程一共配置了四个参数，分别是用户角色、主题、过期时间以及加密算法和密钥，然后将生成的 token 写出到客户端。</li><li>第二步如果校验失败就会来到 unsuccessfulAuthentication 方法中，在这个方法中返回一个错误提示给客户端即可。</li></ol><p>再来看第二个 token 校验的过滤器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) servletRequest;</span><br><span class="line">        String jwtToken = req.getHeader(<span class="hljs-string">"authorization"</span>);</span><br><span class="line">        System.out.println(jwtToken);</span><br><span class="line">        Claims claims = Jwts.parser().setSigningKey(<span class="hljs-string">"sang@123"</span>).parseClaimsJws(jwtToken.replace(<span class="hljs-string">"Bearer"</span>,<span class="hljs-string">""</span>))</span><br><span class="line">                .getBody();</span><br><span class="line">        String username = claims.getSubject();<span class="hljs-comment">//获取当前登录用户名</span></span><br><span class="line">        List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(<span class="hljs-string">"authorities"</span>));</span><br><span class="line">        UsernamePasswordAuthenticationToken token = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, <span class="hljs-keyword">null</span>, authorities);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class="line">        filterChain.doFilter(req,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个过滤器，我说如下几点：</p><ol><li>首先从请求头中提取出 authorization 字段，这个字段对应的 value 就是用户的 token。</li><li>将提取出来的 token 字符串转换为一个 Claims 对象，再从 Claims 对象中提取出当前用户名和用户角色，创建一个 UsernamePasswordAuthenticationToken 放到当前的 Context 中，然后执行过滤链使请求继续执行下去。</li></ol><p>如此之后，两个和 JWT 相关的过滤器就算配置好了。</p><h3 id="2-3-Spring-Security-配置"><a href="#2-3-Spring-Security-配置" class="headerlink" title="2.3 Spring Security 配置"></a>2.3 Spring Security 配置</h3><p>接下来我们来配置 Spring Security,如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication().withUser(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">                .password(<span class="hljs-string">"456"</span>)</span><br><span class="line">                .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/hello"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .antMatchers(HttpMethod.POST, <span class="hljs-string">"/login"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .addFilterBefore(<span class="hljs-keyword">new</span> JwtLoginFilter(<span class="hljs-string">"/login"</span>,authenticationManager()),UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .addFilterBefore(<span class="hljs-keyword">new</span> JwtFilter(),UsernamePasswordAuthenticationFilter.class)</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>简单起见，这里我并未对密码进行加密，因此配置了 NoOpPasswordEncoder 的实例。</li><li>简单起见，这里并未连接数据库，我直接在内存中配置了两个用户，两个用户具备不同的角色。</li><li>配置路径规则时， <code>/hello</code> 接口必须要具备 user 角色才能访问， <code>/admin</code> 接口必须要具备 admin 角色才能访问，POST 请求并且是 <code>/login</code> 接口则可以直接通过，其他接口必须认证后才能访问。</li><li>最后配置上两个自定义的过滤器并且关闭掉 csrf 保护。</li></ol><h3 id="2-4-测试"><a href="#2-4-测试" class="headerlink" title="2.4 测试"></a>2.4 测试</h3><p>做完这些之后，我们的环境就算完全搭建起来了，接下来启动项目然后在 POSTMAN 中进行测试，如下：</p><p><img src="./img/37-4.png" alt></p><p>登录成功后返回的字符串就是经过 base64url 转码的 token，一共有三部分，通过一个 <code>.</code> 隔开，我们可以对第一个 <code>.</code> 之前的字符串进行解码，即 Header，如下：</p><p><img src="./img/37-5.png" alt></p><p>再对两个 <code>.</code> 之间的字符解码，即 payload：</p><p><img src="./img/37-6.png" alt></p><p>可以看到，我们设置信息，由于 base64 并不是加密方案，只是一种编码方案，因此，不建议将敏感的用户信息放到 token 中。</p><p>接下来再去访问 <code>/hello</code> 接口，注意认证方式选择 Bearer Token，Token 值为刚刚获取到的值，如下：</p><p><img src="./img/37-7.png" alt></p><p>可以看到，访问成功。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这就是 JWT 结合 Spring Security 的一个简单用法，讲真，如果实例允许，类似的需求我还是推荐使用 OAuth2 中的 password 模式。</p><p>不知道大伙有没有看懂呢？如果没看懂，松哥还有一个关于这个知识点的视频教程，如下：</p><ul><li><a href="https://mp.weixin.qq.com/s/Sn59dxwtsEWoj2wdynQuRQ" target="_blank" rel="noopener">Spring Security + JWT 视频教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前后端分离的项目中，登录策略也有不少，不过 JWT 算是目前比较流行的一种解决方案了，本文就和大家来分享一下如何将 Spring Security 和 JWT 结合在一起使用，进而实现前后端分离时的登录解决方案。&lt;/p&gt;
&lt;h2 id=&quot;1-无状态登录&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.775Z</published>
    <updated>2020-01-13T01:53:46.516Z</updated>
    
    <content type="html"><![CDATA[<p>今天想和小伙伴们来聊一聊 SpringSecurity 中的角色继承问题。</p><p>角色继承实际上是一个很常见的需求，因为大部分公司治理可能都是金字塔形的，上司可能具备下属的部分甚至所有权限，这一现实场景，反映到我们的代码中，就是角色继承了。Spring Security 中为开发者提供了相关的角色继承解决方案，但是这一解决方案在最近的SpringSecurity 版本变迁中，使用方法有所变化。今天除了和小伙伴们分享角色继承外，也来顺便说说这种变化，避免小伙伴们踩坑，同时购买了我的书的小伙伴也需要留意，书是基于 Spring Boot2.0.4 这个版本写的，这个话题和最新版 Spring Boot 的还是有一点差别。</p><h2 id="1-版本分割线"><a href="#1-版本分割线" class="headerlink" title="1.版本分割线"></a>1.版本分割线</h2><p>上文说过，SpringSecurity 在角色继承上有两种不同的写法，在 Spring Boot2.0.8（对应Spring Security 也是5.0.11）上面是一种写法，从 Spring Boot2.1.0（对应 Spring Security5.1.1）又是另外一种写法，本文将从这两种角度出发，向读者介绍两种不同的角色继承写法。</p><h2 id="2-以前的写法"><a href="#2-以前的写法" class="headerlink" title="2.以前的写法"></a>2.以前的写法</h2><p>这里说的以前写法，就是指 SpringBoot2.0.8（含）之前的写法，在之前的写法中，角色继承只需要开发者提供一个 RoleHierarchy 接口的实例即可，例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">    String hierarchy = <span class="hljs-string">"ROLE_dba &gt; ROLE_admin ROLE_admin &gt; ROLE_user"</span>;</span><br><span class="line">    roleHierarchy.setHierarchy(hierarchy);</span><br><span class="line">    <span class="hljs-keyword">return</span> roleHierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们提供了一个 RoleHierarchy 接口的实例，使用字符串来描述了角色之间的继承关系， <code>ROLE_dba</code> 具备 <code>ROLE_admin</code> 的所有权限，而 <code>ROLE_admin</code> 则具备 <code>ROLE_user</code> 的所有权限，继承与继承之间用一个空格隔开。提供了这个 Bean 之后，以后所有具备 <code>ROLE_user</code> 角色才能访问的资源， <code>ROLE_dba</code> 和 <code>ROLE_admin</code> 也都能访问，具备 <code>ROLE_amdin</code> 角色才能访问的资源， <code>ROLE_dba</code> 也能访问。</p><h2 id="3-现在的写法"><a href="#3-现在的写法" class="headerlink" title="3.现在的写法"></a>3.现在的写法</h2><p>但是上面这种写法仅限于 SpringBoot2.0.8（含）之前的版本，在之后的版本中，这种写法则不被支持，新版的写法是下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RoleHierarchyImpl roleHierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">    String hierarchy = <span class="hljs-string">"ROLE_dba &gt; ROLE_admin \n ROLE_admin &gt; ROLE_user"</span>;</span><br><span class="line">    roleHierarchy.setHierarchy(hierarchy);</span><br><span class="line">    <span class="hljs-keyword">return</span> roleHierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变化主要就是分隔符，将原来用空格隔开的地方，现在用换行符了。这里表达式的含义依然和上面一样，不再赘述。</p><p>上面两种不同写法都是配置角色的继承关系，配置完成后，接下来指定角色和资源的对应关系即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests().antMatchers(<span class="hljs-string">"/admin/**"</span>)</span><br><span class="line">            .hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/db/**"</span>)</span><br><span class="line">            .hasRole(<span class="hljs-string">"dba"</span>)</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/user/**"</span>)</span><br><span class="line">            .hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表示 <code>/db/**</code> 格式的路径需要具备 dba 角色才能访问，<code>/admin/**</code> 格式的路径则需要具备 admin 角色才能访问， <code>/user/**</code> 格式的路径，则需要具备 user 角色才能访问，此时提供相关接口，会发现，dba 除了访问 <code>/db/**</code> ，也能访问 <code>/admin/**</code> 和 <code>/user/**</code> ，admin 角色除了访问 <code>/admin/**</code> ，也能访问 <code>/user/**</code> ，user 角色则只能访问 <code>/user/**</code>。</p><h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4.源码分析"></a>4.源码分析</h2><p>这样两种不同的写法，其实也对应了两种不同的解析策略，角色继承关系的解析在 RoleHierarchyImpl 类的 buildRolesReachableInOneStepMap 方法中，Spring Boot2.0.8（含）之前该方法的源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRolesReachableInOneStepMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="hljs-string">"(\\s*([^\\s&gt;]+)\\s*&gt;\\s*([^\\s&gt;]+))"</span>);</span><br><span class="line">Matcher roleHierarchyMatcher = pattern</span><br><span class="line">.matcher(<span class="hljs-keyword">this</span>.roleHierarchyStringRepresentation);</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneStepMap = <span class="hljs-keyword">new</span> HashMap&lt;GrantedAuthority, Set&lt;GrantedAuthority&gt;&gt;();</span><br><span class="line"><span class="hljs-keyword">while</span> (roleHierarchyMatcher.find()) &#123;</span><br><span class="line">GrantedAuthority higherRole = <span class="hljs-keyword">new</span> SimpleGrantedAuthority(</span><br><span class="line">roleHierarchyMatcher.group(<span class="hljs-number">2</span>));</span><br><span class="line">GrantedAuthority lowerRole = <span class="hljs-keyword">new</span> SimpleGrantedAuthority(</span><br><span class="line">roleHierarchyMatcher.group(<span class="hljs-number">3</span>));</span><br><span class="line">Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.containsKey(higherRole)) &#123;</span><br><span class="line">rolesReachableInOneStepSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.put(higherRole,</span><br><span class="line">rolesReachableInOneStepSet);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">rolesReachableInOneStepSet = <span class="hljs-keyword">this</span>.rolesReachableInOneStepMap</span><br><span class="line">.get(higherRole);</span><br><span class="line">&#125;</span><br><span class="line">addReachableRoles(rolesReachableInOneStepSet, lowerRole);</span><br><span class="line">logger.debug(<span class="hljs-string">"buildRolesReachableInOneStepMap() - From role "</span> + higherRole</span><br><span class="line">+ <span class="hljs-string">" one can reach role "</span> + lowerRole + <span class="hljs-string">" in one step."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码中我们可以看到，角色的继承关系是通过正则表达式进行解析，通过空格进行切分，然后构建相应的 map 出来。</p><p>Spring Boot2.1.0（含）之后该方法的源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRolesReachableInOneStepMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneStepMap = <span class="hljs-keyword">new</span> HashMap&lt;GrantedAuthority, Set&lt;GrantedAuthority&gt;&gt;();</span><br><span class="line"><span class="hljs-keyword">try</span> (BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(</span><br><span class="line"><span class="hljs-keyword">new</span> StringReader(<span class="hljs-keyword">this</span>.roleHierarchyStringRepresentation))) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (String readLine; (readLine = bufferedReader.readLine()) != <span class="hljs-keyword">null</span>;) &#123;</span><br><span class="line">String[] roles = readLine.split(<span class="hljs-string">" &gt; "</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; roles.length; i++) &#123;</span><br><span class="line">GrantedAuthority higherRole = <span class="hljs-keyword">new</span> SimpleGrantedAuthority(</span><br><span class="line">roles[i - <span class="hljs-number">1</span>].replaceAll(<span class="hljs-string">"^\\s+|\\s+$"</span>, <span class="hljs-string">""</span>));</span><br><span class="line">GrantedAuthority lowerRole = <span class="hljs-keyword">new</span> SimpleGrantedAuthority(roles[i].replaceAll(<span class="hljs-string">"^\\s+|\\s+$</span></span><br><span class="line"><span class="hljs-string">Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet;</span></span><br><span class="line"><span class="hljs-string">if (!this.rolesReachableInOneStepMap.containsKey(higherRole)) &#123;</span></span><br><span class="line"><span class="hljs-string">rolesReachableInOneStepSet = new HashSet&lt;GrantedAuthority&gt;();</span></span><br><span class="line"><span class="hljs-string">this.rolesReachableInOneStepMap.put(higherRole, rolesReachableInOneStepSet);</span></span><br><span class="line"><span class="hljs-string">&#125; else &#123;</span></span><br><span class="line"><span class="hljs-string">rolesReachableInOneStepSet = this.rolesReachableInOneStepMap.get(higherRole);</span></span><br><span class="line"><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">addReachableRoles(rolesReachableInOneStepSet, lowerRole);</span></span><br><span class="line"><span class="hljs-string">if (logger.isDebugEnabled()) &#123;</span></span><br><span class="line"><span class="hljs-string">logger.debug("</span>buildRolesReachableInOneStepMap() - From role <span class="hljs-string">" + higherRole</span></span><br><span class="line"><span class="hljs-string">+ "</span> one can reach role <span class="hljs-string">" + lowerRole + "</span> in one step.<span class="hljs-string">");</span></span><br><span class="line"><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">&#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="hljs-string">throw new IllegalStateException(e);</span></span><br><span class="line"><span class="hljs-string">&#125;</span></span><br><span class="line"><span class="hljs-string">&#125;</span></span><br></pre></td></tr></table></figure><p>从这里我们可以看到，这里并没有一上来就是用正则表达式，而是先将角色继承字符串转为一个 BufferedReader，然后一行一行的读出来，再进行解析，最后再构建相应的 map。从这里我们可以看出为什么前后版本对此有不同的写法。</p><p>那么小伙伴在开发过程中，还是需要留意这一个差异。好了，角色继承我们就先说到这里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天想和小伙伴们来聊一聊 SpringSecurity 中的角色继承问题。&lt;/p&gt;
&lt;p&gt;角色继承实际上是一个很常见的需求，因为大部分公司治理可能都是金字塔形的，上司可能具备下属的部分甚至所有权限，这一现实场景，反映到我们的代码中，就是角色继承了。Spring Securi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://www.javaboy.org/2019/1231/0.html"/>
    <id>http://www.javaboy.org/2019/1231/0.html</id>
    <published>2019-12-31T00:36:08.774Z</published>
    <updated>2020-01-13T01:53:46.530Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 SpringSecurity 中，大伙都知道默认的登录数据是通过 key/value 的形式来传递的，默认情况下不支持 JSON格式的登录数据，如果有这种需求，就需要自己来解决，本文主要和小伙伴来聊聊这个话题。  </p><h2 id="基本登录方案"><a href="#基本登录方案" class="headerlink" title="基本登录方案"></a>基本登录方案</h2><p>在说如何使用 JSON 登录之前，我们还是先来看看基本的登录吧，本文为了简单，SpringSecurity 在使用中就不连接数据库了，直接在内存中配置用户名和密码，具体操作步骤如下：  </p><ul><li>创建 Spring Boot 工程</li></ul><p>首先创建 SpringBoot 工程，添加 SpringSecurity 依赖，如下：  </p><pre><code class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><ul><li>添加 Security 配置</li></ul><p>创建 SecurityConfig，完成 SpringSecurity 的配置，如下：  </p><pre><code class="java"><span class="meta">@Configuration</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>{    <span class="meta">@Bean</span>    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>{        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();    }    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>{        auth.inMemoryAuthentication().withUser(<span class="string">"zhangsan"</span>).password(<span class="string">"$2a$10$2O4EwLrrFPEboTfDOtC0F.RpUMk.3q3KvBHRx7XXKUMLBGjOOBs8q"</span>).roles(<span class="string">"user"</span>);    }    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>{    }    <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>{        http.authorizeRequests()                .anyRequest().authenticated()                .and()                .formLogin()                .loginProcessingUrl(<span class="string">"/doLogin"</span>)                .successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() {                    <span class="meta">@Override</span>                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>{                        RespBean ok = RespBean.ok(<span class="string">"登录成功！"</span>,authentication.getPrincipal());                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);                        PrintWriter out = resp.getWriter();                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(ok));                        out.flush();                        out.close();                    }                })                .failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() {                    <span class="meta">@Override</span>                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>{                        RespBean error = RespBean.error(<span class="string">"登录失败"</span>);                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);                        PrintWriter out = resp.getWriter();                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));                        out.flush();                        out.close();                    }                })                .loginPage(<span class="string">"/login"</span>)                .permitAll()                .and()                .logout()                .logoutUrl(<span class="string">"/logout"</span>)                .logoutSuccessHandler(<span class="keyword">new</span> LogoutSuccessHandler() {                    <span class="meta">@Override</span>                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLogoutSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>{                        RespBean ok = RespBean.ok(<span class="string">"注销成功！"</span>);                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);                        PrintWriter out = resp.getWriter();                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(ok));                        out.flush();                        out.close();                    }                })                .permitAll()                .and()                .csrf()                .disable()                .exceptionHandling()                .accessDeniedHandler(<span class="keyword">new</span> AccessDeniedHandler() {                    <span class="meta">@Override</span>                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>{                        RespBean error = RespBean.error(<span class="string">"权限不足，访问失败"</span>);                        resp.setStatus(<span class="number">403</span>);                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);                        PrintWriter out = resp.getWriter();                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(error));                        out.flush();                        out.close();                    }                });    }}</code></pre><p>这里的配置虽然有点长，但是很基础，配置含义也比较清晰，首先提供 BCryptPasswordEncoder 作为 PasswordEncoder，可以实现对密码的自动加密加盐，非常方便，然后提供了一个名为 <code>zhangsan</code> 的用户，密码是 <code>123</code> ，角色是 <code>user</code> ，最后配置登录逻辑，所有的请求都需要登录后才能访问，登录接口是 <code>/doLogin</code> ，用户名的 key 是 username，密码的 key 是 password，同时配置登录成功、登录失败以及注销成功、权限不足时都给用户返回 JSON 提示，另外，这里虽然配置了登录页面为 <code>/login</code> ，实际上这不是一个页面，而是一段 JSON，在 LoginController 中提供该接口，如下：  </p><pre><code class="java"><span class="meta">@RestController</span><span class="meta">@ResponseBody</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>{    <span class="meta">@GetMapping</span>(<span class="string">"/login"</span>)    <span class="function"><span class="keyword">public</span> RespBean <span class="title">login</span><span class="params">()</span> </span>{        <span class="keyword">return</span> RespBean.error(<span class="string">"尚未登录，请登录"</span>);    }    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>{        <span class="keyword">return</span> <span class="string">"hello"</span>;    }}</code></pre><p>这里 <code>/login</code> 只是一个 JSON 提示，而不是页面， <code>/hello</code> 则是一个测试接口。  </p><p>OK，做完上述步骤就可以开始测试了，运行 SpringBoot 项目，访问 <code>/hello</code> 接口，结果如下：  </p><p><img src="./img/35-1.png" alt>  </p><p>此时先调用登录接口进行登录，如下：  </p><p><img src="./img/35-2.png" alt>  </p><p>登录成功后，再去访问 <code>/hello</code> 接口就可以成功访问了。  </p><h2 id="使用-JSON-登录"><a href="#使用-JSON-登录" class="headerlink" title="使用 JSON 登录"></a>使用 JSON 登录</h2><p>上面演示的是一种原始的登录方案，如果想将用户名密码通过 JSON 的方式进行传递，则需要自定义相关过滤器，通过分析源码我们发现，默认的用户名密码提取在 UsernamePasswordAuthenticationFilter 过滤器中，部分源码如下：  </p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationFilter</span> <span class="keyword">extends</span></span><span class="class">        <span class="title">AbstractAuthenticationProcessingFilter</span> </span>{    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FORM_USERNAME_KEY = <span class="string">"username"</span>;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_SECURITY_FORM_PASSWORD_KEY = <span class="string">"password"</span>;    <span class="keyword">private</span> String usernameParameter = SPRING_SECURITY_FORM_USERNAME_KEY;    <span class="keyword">private</span> String passwordParameter = SPRING_SECURITY_FORM_PASSWORD_KEY;    <span class="keyword">private</span> <span class="keyword">boolean</span> postOnly = <span class="keyword">true</span>;    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationFilter</span><span class="params">()</span> </span>{        <span class="keyword">super</span>(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">"/login"</span>, <span class="string">"POST"</span>));    }    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span><span class="function"><span class="params">            HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>{        <span class="keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) {            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(                    <span class="string">"Authentication method not supported: "</span> + request.getMethod());        }        String username = obtainUsername(request);        String password = obtainPassword(request);        <span class="keyword">if</span> (username == <span class="keyword">null</span>) {            username = <span class="string">""</span>;        }        <span class="keyword">if</span> (password == <span class="keyword">null</span>) {            password = <span class="string">""</span>;        }        username = username.trim();        UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(                username, password);        <span class="comment">// Allow subclasses to set the "details" property</span>        setDetails(request, authRequest);        <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);    }    <span class="function"><span class="keyword">protected</span> String <span class="title">obtainPassword</span><span class="params">(HttpServletRequest request)</span> </span>{        <span class="keyword">return</span> request.getParameter(passwordParameter);    }    <span class="function"><span class="keyword">protected</span> String <span class="title">obtainUsername</span><span class="params">(HttpServletRequest request)</span> </span>{        <span class="keyword">return</span> request.getParameter(usernameParameter);    }    <span class="comment">//...</span>    <span class="comment">//...</span>}</code></pre><p>从这里可以看到，默认的 <code>用户名/密码</code> 提取就是通过 request 中的 getParameter 来提取的，如果想使用 JSON 传递用户名密码，只需要将这个过滤器替换掉即可，自定义过滤器如下：  </p><pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>{    <span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>{        <span class="keyword">if</span> (request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)                || request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) {            ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">null</span>;            <span class="keyword">try</span> (InputStream is = request.getInputStream()) {                Map&lt;String,String&gt; authenticationBean = mapper.readValue(is, Map.class);                authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(                        authenticationBean.get(<span class="string">"username"</span>), authenticationBean.get(<span class="string">"password"</span>));            } <span class="keyword">catch</span> (IOException e) {                e.printStackTrace();                authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(                        <span class="string">""</span>, <span class="string">""</span>);            } <span class="keyword">finally</span> {                setDetails(request, authRequest);                <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);            }        }        <span class="keyword">else</span> {            <span class="keyword">return</span> <span class="keyword">super</span>.attemptAuthentication(request, response);        }    }}</code></pre><p>这里只是将用户名/密码的获取方案重新修正下，改为了从 JSON 中获取用户名密码，然后在 SecurityConfig 中作出如下修改：  </p><pre><code class="java"><span class="meta">@Override</span><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>{    http.authorizeRequests().anyRequest().authenticated()            .and()            .formLogin()            .and().csrf().disable();    http.addFilterAt(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);}<span class="meta">@Bean</span><span class="function">CustomAuthenticationFilter <span class="title">customAuthenticationFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{    CustomAuthenticationFilter filter = <span class="keyword">new</span> CustomAuthenticationFilter();    filter.setAuthenticationSuccessHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() {        <span class="meta">@Override</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>{            resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);            PrintWriter out = resp.getWriter();            RespBean respBean = RespBean.ok(<span class="string">"登录成功!"</span>);            out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(respBean));            out.flush();            out.close();        }    });    filter.setAuthenticationFailureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() {        <span class="meta">@Override</span>        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException </span>{            resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);            PrintWriter out = resp.getWriter();            RespBean respBean = RespBean.error(<span class="string">"登录失败!"</span>);            out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(respBean));            out.flush();            out.close();        }    });    filter.setAuthenticationManager(authenticationManagerBean());    <span class="keyword">return</span> filter;}</code></pre><p>将自定义的 CustomAuthenticationFilter 类加入进来即可，接下来就可以使用 JSON 进行登录了，如下：  </p><p><img src="./img/35-3.png" alt>  </p><p>本文案例，我已经上传到 GitHub ，欢迎大家 star：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></p><p>好了，本文就先介绍到这里，有问题欢迎留言讨论。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用 SpringSecurity 中，大伙都知道默认的登录数据是通过 key/value 的形式来传递的，默认情况下不支持 JSON格式的登录数据，如果有这种需求，就需要自己来解决，本文主要和小伙伴来聊聊这个话题。  &lt;/p&gt;
&lt;h2 id=&quot;基本登录方案&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MyBatis 教程姗姗来迟，松哥手码的 SSM 教程总算齐活了，小伙伴们可以下载啦</title>
    <link href="http://www.javaboy.org/2019/1230/mybatis-guide.html"/>
    <id>http://www.javaboy.org/2019/1230/mybatis-guide.html</id>
    <published>2019-12-30T01:23:06.000Z</published>
    <updated>2020-01-10T01:51:17.545Z</updated>
    
    <content type="html"><![CDATA[<p>上周末去了趟南京，昨晚到家都十二点多了，今天一大早起来整理 MyBatis 教程，现在总算搞好了，至此，松哥自制的 SSM 教程现在总算齐活了。</p><a id="more"></a><p>这套 Maven+SSM 教程总页数在 230 页左右，总字数在 5 万字左右，带领刚入行的小伙伴巩固下知识点，或者没接触过 SSM 的小伙伴入个门绝对是够用了。</p><p>其中，Maven、Spring、SpringMVC 的教程之前都已经发布过了：</p><ul><li><a href="https://mp.weixin.qq.com/s/CyMXvY-IzY-69Q_uYxxXMA" target="_blank" rel="noopener">Maven 教程</a></li><li><a href="https://mp.weixin.qq.com/s/4N0qWTHM2CuUFRoBIBUHwQ" target="_blank" rel="noopener">Spring 教程</a></li><li><a href="https://mp.weixin.qq.com/s/4v7VPjSjf5DW86I3ecptFw" target="_blank" rel="noopener">SpringMVC 教程</a></li></ul><p>今天要发布的这份 MyBatis 教程，松哥和大家详细聊了 MyBatis 一些常见用法，如 基本配置、一对一查询、一对多查询、Mapper 配置、逆向工程等，不过时间仓促，还有一些更加高级的玩法松哥在未来也会慢慢完善。</p><p>和前面的教程一样，这个 MyBatis 教程松哥也提供了线上版和离线版，线上版地址：</p><ul><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li></ul><p><img src="http://www.javaboy.org/images/other/101-1.png" alt></p><p>离线版是一个 pdf 文档，小伙伴们在松哥公众号后台回复 mybatis 可以获取离线版下载地址。</p><p><img src="http://www.javaboy.org/images/other/101-2.png" alt><br><img src="http://www.javaboy.org/images/other/101-3.png" alt></p><p><strong>注意</strong></p><blockquote><p>由于这个教程里涉及到的代码 Demo 比较多，我看了一下生成的 pdf，代码的排版不是很好看，换行有一点点乱，不方便阅读，因此建议大家通过在线版学习，也就是松哥上面给出来的那个网站。在线版网速可能有一点点慢，松哥后期也会对这个问题进行处理，请小伙伴们留意星球公告哦。</p></blockquote><p>现在，松哥自己的站点，已经做好的有：</p><ul><li><a href="http://www.javaboy.org">http://www.javaboy.org</a></li><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li><li><a href="http://maven.javaboy.org" target="_blank" rel="noopener">http://maven.javaboy.org</a></li><li><a href="http://spring.javaboy.org" target="_blank" rel="noopener">http://spring.javaboy.org</a></li><li><a href="http://springmvc.javaboy.org" target="_blank" rel="noopener">http://springmvc.javaboy.org</a></li><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li></ul><p>未来还计划出：</p><ul><li><a href="http://shiro.javaboy.org" target="_blank" rel="noopener">http://shiro.javaboy.org</a></li><li><a href="http://mongodb.javaboy.org" target="_blank" rel="noopener">http://mongodb.javaboy.org</a></li><li><a href="http://redis.javaboy.org" target="_blank" rel="noopener">http://redis.javaboy.org</a></li><li><a href="http://elasticsearch.javaboy.org" target="_blank" rel="noopener">http://elasticsearch.javaboy.org</a></li><li>…</li></ul><p>小伙伴们敬请期待哦。</p><p>好了，MyBatis 撸起来吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周末去了趟南京，昨晚到家都十二点多了，今天一大早起来整理 MyBatis 教程，现在总算搞好了，至此，松哥自制的 SSM 教程现在总算齐活了。&lt;/p&gt;
    
    </summary>
    
      <category term="MyBatis" scheme="http://www.javaboy.org/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
  </entry>
  
</feed>
