<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2019-08-14T13:54:36.228Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot 中的同一个 Bug，竟然把我坑了两次！</title>
    <link href="http://www.javaboy.org/2019/0814/springboot-bug.html"/>
    <id>http://www.javaboy.org/2019/0814/springboot-bug.html</id>
    <published>2019-08-14T13:52:22.000Z</published>
    <updated>2019-08-14T13:54:36.228Z</updated>
    
    <content type="html"><![CDATA[<p>真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。</p><a id="more"></a><p>如果大家没看过松哥之前写的 Spring Boot 整合 Spring Session，可以先回顾下：</p><ul><li><a href="https://mp.weixin.qq.com/s/xs67SzSkMLz6-HgZVxTDFw" target="_blank" rel="noopener">Spring Boot 一个依赖搞定 session 共享，没有比这更简单的方案了！</a></li></ul><h1 id="第一次踩坑"><a href="#第一次踩坑" class="headerlink" title="第一次踩坑"></a>第一次踩坑</h1><p>事情是这样的，大概在今年 6 月初的时候，我在项目中使用到了 Session 共享，当时采用的方案就是 Redis+Spring Session。本来这是一个很简单的问题，我在以前的项目中也用过多次这种方案，早已轻车熟路，但是那次有点不对劲，项目启动时候报了如下错误：</p><p><img src="http://www.javaboy.org/images/boot/31-1.png" alt></p><p>一模一样的代码，但是运行就是会出错，我感觉莫名其妙。因为在 Spring Boot 中整合 Spring Session 是一个非常简单的操作，就几行 Redis 的配置而已，我在确认了代码没问题之后，很快想到了可能是版本问题，因为当时 Spring Boot2.1.5 刚刚发布，我喜欢用最新版。于是我尝试将 Spring Boot 的版本切换到 2.1.4 ，切换回去之后，果然就 OK了，再次启动项目又不会报错了。于是基本确定这是 Spring Boot 的版本升级带来的问题。</p><p>但是当时我并没有深究，我以为就是官方出于安全考虑，让你在使用 Redis 时强制加上 Spring Security（因为根据错误提示，很容想到加上 Spring Security 依赖），加上 Spring Security 依赖之后，果然就没有问题了，我也没有多想，这件事就这样过了。​</p><h1 id="第二次踩坑"><a href="#第二次踩坑" class="headerlink" title="第二次踩坑"></a>第二次踩坑</h1><p>前两天我在给星球上的小伙伴录制 Spring Boot 视频的时候，采用了  Spring Boot 最新版 2.1.7，也是 Spring Session，但是在创建项目的时候，忘记添加 Spring Security 依赖了（第一次踩坑之后，我每次用 Spring Session 都会自觉的加上 Spring Security 依赖），运行的时候竟然没报错！我就郁闷了。</p><p>于是我去试了 Spring Boot2.1.4、Spring Boot2.1.6 发现都没有问题，在使用 Spring Session 的时候都不需要添加 Spring Security 依赖，只有 Spring Boot2.1.5 才有这个问题。于是我大概明白了，这可能是一个 Bug，而不是版本升级的新功能。</p><p>这一次，那我就打算追究一下问题的根源。</p><h1 id="源头"><a href="#源头" class="headerlink" title="源头"></a>源头</h1><p>要追究问题的源头，我们当然得从 Spring Session 的自动化配置类开始。</p><p>在 Spring Boot2.1.5 的 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类中，我看到如下源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectProvider&lt;SpringSessionRememberMeServices&gt; springSessionRememberMeServices)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//.....</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer</span><br><span class="line">.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line">springSessionRememberMeServices.ifAvailable((</span><br><span class="line">rememberMeServices) -&gt; cookieSerializer.setRememberMeRequestAttribute(</span><br><span class="line">SpringSessionRememberMeServices.REMEMBER_ME_LOGIN_ATTR));</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这一段源码中我们可以看到，这里使用到了 SpringSessionRememberMeServices ，而这个类中则用到 Spring Security 中相关的类。因此，如果不引入 Spring Security 就会报错。</p><p>我们再来看看 Spring Boot2.1.6 中 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类的源码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line"><span class="hljs-keyword">if</span> (ClassUtils.isPresent(REMEMBER_ME_SERVICES_CLASS, getClass().getClassLoader())) &#123;</span><br><span class="line"><span class="hljs-keyword">new</span> RememberMeServicesCookieSerializerCustomizer().apply(cookieSerializer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 Spring Boot2.1.6 中，这个问题已经得到修复。这里就没有 2.1.5 那么冲动了，上来了先用 <code>ClassUtils.isPresent</code> 方法判断了下 REMEMBER_ME_SERVICES_CLASS(<code>org.springframework.security.web.authentication.RememberMeServices</code>) 是否存在，存在的话，才有后面的操作。</p><p>至此，这个问题就总算弄懂了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大家平时遇到问题，如果项目不是很赶的话，可以留意多想想，多追究一下原因，说不定你会有很多意外的收获。我这次就是一个活生生的例子，一开始没多想，后来又发现不对劲，前前后后一折腾，反而又多浪费了一些时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 加入 Https 功能有那么难吗？</title>
    <link href="http://www.javaboy.org/2019/0813/springboot-https.html"/>
    <id>http://www.javaboy.org/2019/0813/springboot-https.html</id>
    <published>2019-08-13T13:47:14.000Z</published>
    <updated>2019-08-14T13:48:17.638Z</updated>
    
    <content type="html"><![CDATA[<p>https 现在已经越来越普及了，特别是做一些小程序或者公众号开发的时候，https 基本上都是刚需了。</p><a id="more"></a><p>不过一个 https 证书还是挺费钱的，个人开发者可以在各个云服务提供商那里申请一个免费的证书。我印象中有效期一年，可以申请 20 个。</p><p>今天要和大家聊的是在 Spring Boot 项目中，如何开启 https 配置，为我们的接口保驾护航。</p><h1 id="https-简介"><a href="#https-简介" class="headerlink" title="https 简介"></a>https 简介</h1><p>我们先来看看什么是 https，根据 wikipedia 上的介绍：</p><blockquote><p>超文本传输安全协议(HyperText Transfer Protocol Secure)，缩写：HTTPS；常称为 HTTP over TLS、HTTP over SSL 或 HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司(Netscape)在 1994 年首次提出，随后扩展到互联网上。</p></blockquote><p>历史上，HTTPS 连接经常用于网络上的交易支付和企业信息系统中敏感信息的传输。在 2000 年代末至 2010 年代初，HTTPS 开始广泛使用，以确保各类型的网页真实，保护账户和保持用户通信，身份和网络浏览的私密性。</p><p>另外，还有一种安全超文本传输协议（S-HTTP），也是 HTTP 安全传输的一种实现，但是 HTTPS 的广泛应用而成为事实上的 HTTP 安全传输实现，S-HTTP并没有得到广泛支持。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先我们需要有一个 https 证书，我们可以从各个云服务厂商处申请一个免费的，不过自己做实验没有必要这么麻烦，我们可以直接借助 Java 自带的 JDK 管理工具 keytool 来生成一个免费的 https 证书。</p><p>进入到 <code>%JAVVA_HOME%\bin</code> 目录下，执行如下命令生成一个数字证书：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias tomcathttps -keyalg RSA -keysize 2048  -keystore D:\javaboy.p12 -validity 365</span><br></pre></td></tr></table></figure><p>命令含义如下：</p><ul><li>genkey 表示要创建一个新的密钥。</li><li>alias 表示 keystore 的别名。</li><li>keyalg 表示使用的加密算法是 RSA ，一种非对称加密算法。</li><li>keysize 表示密钥的长度。</li><li>keystore 表示生成的密钥存放位置。</li><li>validity 表示密钥的有效时间，单位为天。</li></ul><p>具体生成过程如下图：</p><p><img src="http://www.javaboy.org/images/boot/30-1.png" alt></p><p>命令执行完成后 ，我们在 D 盘目录下会看到一个名为 javaboy.p12 的文件。如下图：</p><p><img src="http://www.javaboy.org/images/boot/30-2.png" alt></p><p>有了这个文件之后，我们的准备工作就算是 OK 了。</p><h1 id="引入-https"><a href="#引入-https" class="headerlink" title="引入 https"></a>引入 https</h1><p>接下来我们需要在项目中引入 https。</p><p>将上面生成的 javaboy.p12 拷贝到 Spring Boot 项目的 resources 目录下。然后在 application.properties 中添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.ssl.key-store=classpath:javaboy.p12</span><br><span class="line">server.ssl.key-alias=tomcathttps</span><br><span class="line">server.ssl.key-store-password=111111</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>key-store表示密钥文件名。</li><li>key-alias表示密钥别名。</li><li>key-store-password就是在cmd命令执行过程中输入的密码。</li></ul><p>配置完成后，就可以启动 Spring Boot 项目了，此时如果我们直接使用 Http 协议来访问接口，就会看到如下错误：</p><p><img src="http://www.javaboy.org/images/boot/30-3.png" alt></p><p>改用 https 来访问 ，结果如下：</p><p><img src="http://www.javaboy.org/images/boot/30-4.png" alt></p><p>这是因为我们自己生成的 https 证书不被浏览器认可，不过没关系，我们直接点击继续访问就可以了（实际项目中只需要更换一个被浏览器认可的 https 证书即可）。</p><p><img src="http://www.javaboy.org/images/boot/30-5.png" alt></p><h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><p>考虑到 Spring Boot 不支持同时启动 HTTP 和 HTTPS ，为了解决这个问题，我们这里可以配置一个请求转发，当用户发起 HTTP 调用时，自动转发到 HTTPS 上。</p><p>具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        TomcatServletWebServerFactory factory = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory()&#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessContext</span><span class="hljs-params">(Context context)</span> </span>&#123;</span><br><span class="line">                SecurityConstraint constraint = <span class="hljs-keyword">new</span> SecurityConstraint();</span><br><span class="line">                constraint.setUserConstraint(<span class="hljs-string">"CONFIDENTIAL"</span>);</span><br><span class="line">                SecurityCollection collection = <span class="hljs-keyword">new</span> SecurityCollection();</span><br><span class="line">                collection.addPattern(<span class="hljs-string">"/*"</span>);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(constraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        <span class="hljs-keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> Connector <span class="hljs-title">createTomcatConnector</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Connector connector = <span class="hljs-keyword">new</span></span><br><span class="line">                Connector(<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">        connector.setScheme(<span class="hljs-string">"http"</span>);</span><br><span class="line">        connector.setPort(<span class="hljs-number">8081</span>);</span><br><span class="line">        connector.setSecure(<span class="hljs-keyword">false</span>);</span><br><span class="line">        connector.setRedirectPort(<span class="hljs-number">8080</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们配置了 Http 的请求端口为 8081，所有来自 8081 的请求，将被自动重定向到 8080 这个 https 的端口上。</p><p>如此之后，我们再去访问 http 请求，就会自动重定向到 https。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Spring Boot 中加入 https 其实很方便。如果你使用了 nginx 或者 tomcat 的话，https 也可以发非常方便的配置，从各个云服务厂商处申请到 https 证书之后，官方都会有一个详细的配置教程，一般照着做，就不会错了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;https 现在已经越来越普及了，特别是做一些小程序或者公众号开发的时候，https 基本上都是刚需了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Https" scheme="http://www.javaboy.org/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的自我修养</title>
    <link href="http://www.javaboy.org/2019/0812/life.html"/>
    <id>http://www.javaboy.org/2019/0812/life.html</id>
    <published>2019-08-12T13:55:46.000Z</published>
    <updated>2019-08-14T13:58:22.897Z</updated>
    
    <content type="html"><![CDATA[<p>6 月 25 对我来说是一个特殊的日子，2011 年 6 月 25 ，高考分数出来，我去了遥远的南方读书。2015 年 6 月 25 正式步入社会！每年到了这个日子，总不免唏嘘感慨！(今年 6 月 25 我的公众号读者突破了 1w,也算是一个特殊日子吧！)</p><a id="more"></a><h1 id="关于高中"><a href="#关于高中" class="headerlink" title="关于高中"></a>关于高中</h1><p>高中非常幸运，也非常不幸！这得从两方面说起。</p><p>我的母亲虽然生活在农村，但是她在教育我时，非常有眼光。我们镇上的初中，大部分学生的最高目标就是读我们县城最好的高中，但是从我上初一开始，我母亲就希望我能努力学习，以后能去西安读更好的高中上更好的大学。中考结束后，我的成绩还算可以（县里排第二）。那几年，西安的高中喜欢到周边县里去挖人，我有幸被选中，去了西安读高中。高中三年不仅免去了学费，也免去了生活费（住宿+吃饭），相当于高中没有花费家里一分钱，对一个农村孩子来说，这省下了相当大一笔钱，因此我说非常幸运！</p><p>到了西安后，我才发现，我中考的分数，在我高中那个火箭班里，排在中间的位置，我前面大概有 20-30 人左右，真是不敢想象城乡教育差距这么大！</p><p>同学们穿着耐克、阿迪（很多牌子我也不认识，只是知道这很贵），我母亲在我们镇上打工一个月才 600 块钱，两个月的薪水估计才能买人家一件衣服，巨大的落差让我感到自卑，自卑又变得敏感孤僻，这种状态下，很难融入到同学中，经常独来独往，最后这种状态就影响到学习了，最后的自信也崩塌了。</p><p>放假回到家里，看到父母对我的期望，亲戚朋友都觉得我很厉害，只有我自己知道我是一只菜鸟。这种家人殷切期望叠加上自己糟糕的成绩，真是非常痛苦，我刚开始时候两周回一次家，后来高二高三基本一个学期才回去一次（虽然从学校到家里也就 1 个多小时），平时都呆在学校里，这样感觉会稍微好一点。</p><p>高中三年，就是这样浑浑噩噩，孤独、自卑、敏感 ，进而变得冷漠、自私，真是艰难的三年。这也是我说不幸的原因。</p><p>虽然一直状态很差，但是我并没有放弃自己，还是艰难的向前走，从来没有自暴自弃。高考虽然没有达到预期分数，可是也没有太差劲。</p><p>不过话说回来，从农村到城市，这个过程总是要经历，高中经历这么大落差，大学就会好很多了，落差不会这么大。</p><h1 id="关于大学"><a href="#关于大学" class="headerlink" title="关于大学"></a>关于大学</h1><p>2011 年 6 月 25 ，高考分数出来，我基本上没有考虑西安的学校，高中三年，西安真的呆够了。</p><p>从小到大，去过最远的地方就是高一军训的时候从西安去了渭南，坐了 4 个小时大巴车，激动。这次读大学，我想趁机出趟远门，想离西安远一点，甚至不太想再回来。</p><p>大学学费一年 4600 ，家里有压力，后来经过县上红十字会牵线，一个陕北的叔叔资助了我的大学学费，非常感动。</p><p>这几年一直在外奔波，其实我很想有一天也能做类似的事情，4600 一个程序员可能不到一个礼拜就赚到了，资助一个大学生读四年书也没什么压力，但是可能改变的是一个人的一生，大部分程序员可能都生活在一线城市，可能很难想象西北地区或者西南地区一些农村的贫困状态。</p><p>大学离家很远，也是我第一次出远门，但是一走就是一年半。大二过年时候才回家，也是我大学四年唯一一次在家里过年。</p><p>大一寒假没回家，呆在学校盘算着赚点生活费，思来想去只有做家教能赚到钱，也相对轻松一些。然后期末考试结束之后，我就印刷了几十张自我介绍，附上电话，趁着夜色，去附近的公交车站、小区门口都给张贴上，我心想只要有一个电话来，这个东西就算没有白贴。回到宿舍等电话，焦急又期待，要是寒假没有找到合适的工作，白白在学校呆一个月啥事没干，那就太浪费了，而且生活费还有点捉襟见肘，当时想着，如果没人来电话咨询，那我第二天就去更远的小区张贴广告。</p><p>还好后面有两个家长来电话咨询，一个是初中生，另一个是小学生，那个初中生后来足足被我教了 1 年半，直到我后来决定 all in Java 才没有继续做家教了。</p><p>两个家教，一个是下午，另一个是晚上。我放假之前从学校图书馆借了很多书，每天早上起床后，先在宿舍看书到 12 点左右，然后去吃午饭，吃完就从学校出发，先去第一个初中生那里，上完课大概到下午 5 点左右，然后出来吃个饭，再坐公交车在 7 点之前到另外一家。</p><p>有一天晚上九点上完课，外面下大雨，南方冬天的雨很冷，又夹杂着大风，孩子家长给我了 20 块钱让我打车回去，不过我最终还是选择坐公交车回学校了，打车这种高级玩意还是不太舍得，到学校后衣服都湿透了，就是冷。印象中那天好像还是南方的小年夜。</p><p>我从家里去学校的时候，以为海南的冬天很暖和，没有带冬天的衣服，实际海口的冬天也冷的要命，那个时候京东淘宝也还不太会玩，不懂网上购物，也就没买衣服，就那样哆哆嗦嗦的过完了冬天。</p><p>大学做家教，赚了一点点钱，够当时花了，那个时候觉得做家教赚钱简直太容易了。现在回头看看，一个学期辛辛苦苦赚个千把块，做程序员一下就赚回来了。所以我觉得大学还是多多学习专业知识，多多提高专业技能，兼职偶尔做一下也能接受，要是本末倒置了，毕业之后可能就会后悔了。</p><p>其实我不太喜欢跟别人讲这些事，因为我觉得没有谁是容易的，每个人都有自己的心酸，有时间唠叨这个还不如去做点实在的事情提高自己。不过偶尔回忆一下还是可以的，可以鞭策自己继续奋斗，不要放弃。</p><h1 id="关于-Java"><a href="#关于-Java" class="headerlink" title="关于 Java"></a>关于 Java</h1><p>大学学习基本上中规中矩，成绩没有名列前茅，但是也没挂过科，虽然我后面侧重于搞开发，但是专业课也没有荒废，大四拿了优秀毕业论文，算是给大学画上一个完美句号。</p><p>大一的时候一心想转到中文系，没能成功。</p><p>大二时候，校公选课无意间选修了 Java语言程序设计 ，从此打开了一个新世界，后来就走上了自学 Java 的道路。</p><p>刚开始的时候是最艰难的，关于计算机的很多概念都是空白的，学习也没有方向，JavaSE 学完之后都不知道干啥，jsp、html 啥的全都不懂。</p><p>后来在大二第二学期遇到了张老师，非常专业也非常敬业的一位老师，美中不足的是老师做 <code>.NET</code> ，而我当时对 <code>.NET</code> 实在提不起兴趣。但是老师给我指明了很多学习的方向，前端、跨平台、Java 的方向等等，那个时候 HTML5 标准还没公布，老师已经让我关注这方面的信息，在老师的指导下，我感觉慢慢打开了局面，进入到软件开发的世界。</p><p>很多人觉得我幸运，遇到了一位好老师，是的，毕业多年我一直心怀感激。2016 年的时候，老师去广工大出差，我当时刚好在广州上班，学弟告诉我老师去广州了，我赶紧趁老师有时间约出来吃个饭。去年新书出版后，到手的第一本书恭恭敬敬写上祝福，送给了大学老师。</p><p>我大一的时候参加了学生会，但是因为办事不力，被自动剔除了（实际上是因为进去之后我就后悔了，所以消极怠工），后来也没参加其他社团，所以我的时间一直都是大把的，但是我从来没有宅在宿舍睡大觉。</p><p>大一的时候有课上课，没课就去图书馆。有的时候早上一二节没课，三四节有课，我也都会按时起床，先去图书馆，到时间了就去上课。大二的时候，开始搞 Java 之后，我就很少去图书馆了，老师给提供了一个安静的，可以放电脑的学习场地，基本上每天就宅在那里学习。</p><p><img src="http://www.javaboy.org/images/other/46-1.webp" alt></p><p>这张照片是我上大三的时候拍的，那个时候晚上十一点之后回寝室基本是家常便饭。印象深刻的是有一年过年没回家（实际上只有大二过年回家了），除夕晚上在搞数据库行转列，因为第二天打算搞一个 GIS 应用，所以前一天要把数据库搞好，除夕晚上弄到 10 点左右回寝室。</p><p>没有人逼你，但是我们自己总得给自己立一点规矩。</p><p>还好，大二到大四，没有白费。大四春招找工作时候是异常顺利，一周之内拿了三个不同方向的 offer ：Android ，Java Swing 以及 JavaEE。</p><p>学 Java 之后，还有另外一个好处，就是整个人变得自信了，我发现我能做这些事，而且能做的很好，自信之后，精神状态 OK 了，很多事情做起来就很顺了。</p><h1 id="关于爱情"><a href="#关于爱情" class="headerlink" title="关于爱情"></a>关于爱情</h1><p>和女票在一起今年也是第八个年头了。</p><p>我们大一时候在一起，女票一直是学霸，毕业之后保送到西北工业大学读研，期间受学校资助被派去昆士兰大学访学，回来后现在做大数据开发。</p><p>大学四年，毕业之后又异地了三年（她在西安，我在广州），去年 4 月份女票硕士毕业从西安来深圳，终于又团聚了。</p><p>估计松哥很快会结婚了吧~</p><h1 id="关于买房"><a href="#关于买房" class="headerlink" title="关于买房"></a>关于买房</h1><p>买房是我工作至今最为骄傲的事情之一，我觉得这是对我的一个证明。</p><p>我刚毕业的时候，薪水是 5000 ，转正之后是 6250 ，包住。我和女票说我每个月攒 4000 块钱，每年攒 5W，等你研究生毕业的时候，我差不多就能在西安买房了。想法还是太天真，女票去年研究生毕业的时候，西安的房价已经翻了一翻。</p><p>刚工作头半年没攒下钱，第一家公司干了 5 个月就跳槽了，第二年薪水就飞了，不到一年时间翻了三倍。于是在 2016 年 11 月的时候，我用打工攒下来的十几万在西安上车了。买房的时候，家里才只有两万块钱，那几年供我和妹妹读书，家里没有什么积蓄，我妈东拼西凑又借了两万，家里一共出了四万块钱，剩下的十几万首付都是我出的。</p><p>记得刚买完房那会，元气大伤。回到广州都没钱交房租了，和同事合租的房子，交房租的时候让同事先帮忙垫着，等了十多天工资下来了，才缓了口气。</p><p>买房也是一件非常幸运的事情的，西安那个时候只要 20% 的首付，我 11 月交完首付，王永康 12 月当上了西安市委书记，然后西安房价就一路狂飙刹不住车，首付也提高到 30%-40% ，买房还要摇号。真是惊险万分。</p><p><img src="http://www.javaboy.org/images/other/46-2.jpeg" alt></p><p>这是去年 12 月底交房的时候拍的，房子顺利交付，但是我已经不太想回西安了，虽然留在深圳可能会很累，但是以我的性格，回去了，估计也不会过得轻松。所以，先争取吧，或许以后去广州也说不定。</p><h1 id="关于写书"><a href="#关于写书" class="headerlink" title="关于写书"></a>关于写书</h1><p>只要坚持写博客，出书的机会其实有很多。2016 年的时候就有出版社的编辑老师找我，但是当时刚刚工作，实在没啥好写的，于是就婉拒了。后来还是有很多编辑老师找来，我都没有答应。</p><p>2018 年刚过完年，那时候我搞 Spring Boot + Vue 也有一段时间了，自我感觉积累了一点点料，有种想和大伙分享的欲望，另一方面也觉得该为自己的职业生涯留下一点东西，不能就这么默默无闻的搬一辈子砖，在认真考虑后，决定写一本 Spring Boot 相关的书，刚好清华社的夏老师没过几天就加了我微信，邀请我写一本 Spring Boot 相关的书，于是一拍即合，这件事就愉快的定下来了。</p><p>写书期间，每天早上 7 点起床，写到 8 点半然后去上班，晚上 6 点下班后，差不多 7 点开始写，写到 11 点半，周末写两天，拒掉了大部分的社交活动，差不多就这样连续了几个月，交稿的时候有种高考结束的感觉，有的小伙伴可能觉得我是个假程序员，竟然不加班，老实说，敝司确实不怎么加班。</p><p>稿子交到出版社之后，还要经过 <code>排版-&gt;编辑-&gt;改错-&gt;初审-&gt;复审-&gt;终审-&gt;发稿-&gt;申请书号、CIP-&gt;封面设计-&gt;出片-&gt;下厂印制-&gt;发样书-&gt;入库-&gt;上市销售</code> ，整个过程大约持续了三个多月。到今年年初的时候，《Spring Boot + Vue 全栈开发实战》终于出版了，迄今为止，书已经加印了 5 次了。</p><p><img src="http://www.javaboy.org/images/other/46-3.jpg" alt></p><h1 id="关于公众号"><a href="#关于公众号" class="headerlink" title="关于公众号"></a>关于公众号</h1><p>公众号是我在 2017 年申请的，但是一直之前一直没有认真做，今年微笑哥（公众号：纯洁的微笑）给了我一些很实在的建议，也帮了我很多，现在打算用心去做公众号，尽量保持原创，希望有一天能够像微笑哥一样把公众号做好。</p><p>这张照片是华为云云享专家线下活动时候和微笑哥拍的，正是微笑哥的建议促使我认真做公众号，也非常感谢微笑哥的提携与帮助。<br><img src="http://www.javaboy.org/images/other/46-4.jpg" alt></p><p>从小学到初中到高中到大学，读书的时候每个阶段都有对我帮助很大影响很大的老师，直到现在一些做事风格都受老师影响。工作后也有给过我很多帮助的领导同事，现在做公众号也有大佬指导，<strong>虽然感觉一直都很辛苦，但是一直也很幸运。</strong></p><h1 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h1><p>刚毕业的时候，想着以后要回西安发展。现在广深两地呆久了，有点喜欢上这里了，现在很希望以后能留在这里，眼前紧迫的事情就是能早点在这边买房安家，深圳的房子太贵了，广州还可以考虑下，目前也在积极准备中。</p><p>头发依旧茂盛，所以程序员这个工作还能继续干。写代码写文章都是让人舒适惬意的事情，在可预见的未来，应该会一直写下去。</p><p>公众号也是未来坚持的一个方向，也希望能把公众号做好。</p><p>不知不觉码了三千多字，感谢大家看我唠叨了这么多！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6 月 25 对我来说是一个特殊的日子，2011 年 6 月 25 ，高考分数出来，我去了遥远的南方读书。2015 年 6 月 25 正式步入社会！每年到了这个日子，总不免唏嘘感慨！(今年 6 月 25 我的公众号读者突破了 1w,也算是一个特殊日子吧！)&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://www.javaboy.org/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://www.javaboy.org/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 修改静态资源一定要重启项目才会生效吗？未必！</title>
    <link href="http://www.javaboy.org/2019/0808/springboot-livereload.html"/>
    <id>http://www.javaboy.org/2019/0808/springboot-livereload.html</id>
    <published>2019-08-08T13:40:59.000Z</published>
    <updated>2019-08-14T13:44:26.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾热部署"><a href="#回顾热部署" class="headerlink" title="回顾热部署"></a>回顾热部署</h1><p>Spring Boot 中的热部署相信大家都用过吧，只需要添加 <code>spring-boot-devtools</code> 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：</p><a id="more"></a><ul><li>base classloader</li><li>restart classloader</li></ul><p>其中 base classloader 用来加载那些不会变化的类，例如各种第三方依赖，而 restart classloader 则用来加载那些会发生变化的类，例如你自己写的代码。Spring Boot 中热部署的原理就是当代码发生变化时，base classloader 不变，而 restart classloader 则会被废弃，被另一个新的 restart classloader 代替。在整个过程中，因为只重新加载了变化的类，所以启动速度要被重启快。</p><p>但是有另外一个问题，就是静态资源文件！使用 devtools ，默认情况下当静态资源发生变化时，并不会触发项目重启。虽然我们可以通过配置解决这一问题，但是没有必要！因为静态资源文件发生变化后不需要编译，按理说保存后刷新下就可以访问到了。</p><p>那么如何才能实现静态资源变化后，不编译就能自动刷新呢？ LiveReload 可以帮助我们实现这一功能！</p><h1 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h1><p>devtools 中默认嵌入了 LiveReload 服务器，利用 LiveReload 可以实现静态文件的热部署，LiveReload 可以在资源发生变化时自动触发浏览器更新，LiveReload 支持 Chrome、Firefox 以及 Safari 。以 Chrome 为例，在 Chrome 应用商店搜索 LiveReload ，结果如下图：</p><p><img src="http://www.javaboy.org/images/boot/27-1.png" alt></p><p>将第一个搜索结果添加到 Chrome 中，添加成功后，在 Chrome 右上角有一个 LiveReload 图标</p><p><img src="http://www.javaboy.org/images/boot/27-2.png" alt></p><p>在浏览器中打开项目的页面，然后点击浏览器右上角的 LiveReload 按钮，打开 LiveReload 连接。</p><p><strong>注意：</strong></p><p>LiveReload 是和浏览器选项卡绑定在一起的，在哪个选项卡中打开了 LiveReload，就在哪个选项卡中访问页面，这样才有效果。</p><p>打开 LiveReload 之后，我们启动一个加了 devtools 依赖的 Spring Boot 项目：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时随便在 resources/static 目录下添加一个静态 html 页面，然后启动 Spring Boot 项目，在<strong>打开了 LiveReload 的选项卡中访问 html 页面</strong>。</p><p>访问成功后，我们再去手动修改 html 页面代码，修改成功后，回到浏览器，不用做任何操作，就会发现浏览器自动刷新了，页面已经更新了。</p><p>整个过程中，我的 Spring Boot 项目并没有重启。</p><p>如果开发者安装并且启动了 LiveReload 插件，同时也添加了 devtools 依赖，但是却并不想当静态页面发生变化时浏览器自动刷新，那么可以在 application.properties 中添加如下代码进行配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.livereload.enabled=false</span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>建议开发者使用 LiveReload 策略而不是项目重启策略来实现静态资源的动态加载，因为项目重启所耗费时间一般来说要超过使用LiveReload 所耗费的时间。</p><p>Firefox 也可以安装 LiveReload 插件，装好之后和 Chrome 用法基本一致，这里不再赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回顾热部署&quot;&gt;&lt;a href=&quot;#回顾热部署&quot; class=&quot;headerlink&quot; title=&quot;回顾热部署&quot;&gt;&lt;/a&gt;回顾热部署&lt;/h1&gt;&lt;p&gt;Spring Boot 中的热部署相信大家都用过吧，只需要添加 &lt;code&gt;spring-boot-devtools&lt;/code&gt; 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="LiveReload" scheme="http://www.javaboy.org/tags/LiveReload/"/>
    
  </entry>
  
  <entry>
    <title>身边的人都说微服务好，好在哪？</title>
    <link href="http://www.javaboy.org/2019/0805/microservice.html"/>
    <id>http://www.javaboy.org/2019/0805/microservice.html</id>
    <published>2019-08-05T13:37:31.000Z</published>
    <updated>2019-08-14T13:40:04.721Z</updated>
    
    <content type="html"><![CDATA[<p>微服务这么火，多少人多少公司都想试试水。</p><a id="more"></a><p>松哥了解到很多小伙伴在找 Java 开发工作时，如果这个公司用的微服务架构，就觉得很牛逼，进去了很有前景，如果没用微服务，甚者还用的是以前的 SSH ，就会觉得没前景，不想去。由此可见微服务在大家心中的分量。</p><p>不过话说回来，并非每一个项目都是适合用微服务架构，也并非每一个公司都需要微服务架构。松哥有个朋友在某网红茶公司做微服务开发，新项目架构师强行上马微服务，结果项目上线后，一个小小的变更都要修改许多服务才能解决，没办法，架构师只能卷铺盖走人了，项目又变回了单体应用。</p><p>我觉得这样的例子不是个案，项目要不要上马微服务，还是要看项目和公司的具体情况，不盲目，不跟风。</p><p>上周和大家聊了单体应用存在的问题：</p><ul><li><a href="https://mp.weixin.qq.com/s/MUPcD_-7NMF32tFLj9zhFQ" target="_blank" rel="noopener">天天吹微服务，单体应用有啥不好？</a></li></ul><p>今天我就来和大家聊一聊微服务到底有哪些好处，又有哪些弊端。</p><h1 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h1><h2 id="大项目可以持续交付"><a href="#大项目可以持续交付" class="headerlink" title="大项目可以持续交付"></a>大项目可以持续交付</h2><p>微服务将一个大系统拆分成很多个互相独立的服务，每一个服务都可以由一个团队去完成，并且配备自己的开发、部署，而且可以独立于其他的团队。每一个团队开发的微服务都可以由自己的代码仓库、以及部署流水线等，互不相扰。</p><p>在微服务中，一个大项目被拆分成 n 多个小项目，每一个小项目都可以非常方便的进行测试、部署，而不会牵一发而动全身，原本需要全员高度警戒的项目上线，现在分散到不同的团队中去完成。</p><p>松哥六月底参加深圳的一个线下技术活动，某在线编程的 CEO 谈到他们公司的发版，说：“我说话的这会儿，我们可能就有新版本在发布。”，这句话令我印象深刻。传统的单体应用，没人敢这么搞，微服务时代，这一切才变得可能。</p><h2 id="易于维护"><a href="#易于维护" class="headerlink" title="易于维护"></a>易于维护</h2><p>这个不必多说，相信大家都理解。</p><p>一个传统的单体应用，如果你新接手，一时半会还不一定能理出一个头绪，而如果是微服务，由于比较小巧玲珑，一个微服务只负责一件事情，很容易理出头绪，然后上手开发。</p><p>并且相对于单体应用，微服务规模都比较小，无论你用 Eclipse 还是 IDEA，项目启动、测试速度都比较快。</p><h2 id="服务可以独立扩展"><a href="#服务可以独立扩展" class="headerlink" title="服务可以独立扩展"></a>服务可以独立扩展</h2><p>独立扩展，可以让我们充分使用硬件资源。</p><p>传统的单体应用，所有的功能模块都写在一起，有的模块是 CPU 运算密集型的，有的模块则是对内存需求更大的，这些模块的代码写在一起，部署的时候，我们只能选择 CPU 运算更强，内存更大的机器，如果采用了了微服务架构，不同的系统独立部署，压力大的时候，可以独立进行集群化部署，这些操作都不会影响到已经运行的其他微服务，非常灵活。</p><h2 id="更强的容错性"><a href="#更强的容错性" class="headerlink" title="更强的容错性"></a>更强的容错性</h2><p>由于每一个微服务都是独立运行的，处理得当，我们在微服务架构中可以实现更好的故障隔离。当一个微服务发生问题时，例如内存泄漏，不会影响到其他的微服务。</p><h2 id="可以灵活的采用最新技术"><a href="#可以灵活的采用最新技术" class="headerlink" title="可以灵活的采用最新技术"></a>可以灵活的采用最新技术</h2><p>传统的单体应用一个非常大的弊端就是技术栈升级非常麻烦，这也是为什么你经常会见到用 10 年前的技术栈做的项目，现在还需要继续开发维护。不是他们不愿意升级，而是升级实在是太麻烦了，伤筋动骨。</p><p>而在微服务架构中，每一个服务都是独立运行的，单个微服务的技术升级则非常容易。你可以随意去尝试你喜欢的最新技术。因为试错成本很低，因此大家可以尽情的玩耍。</p><h1 id="微服务的弊端"><a href="#微服务的弊端" class="headerlink" title="微服务的弊端"></a>微服务的弊端</h1><p>事物都有两面性，微服务也有一些挑战，这些挑战性问题如果处理不好，你使用微服务可能反而适得其反。那么都有哪些问题呢？</p><ul><li><strong>服务的拆分</strong></li></ul><p><strong>个人觉得，这是最大的挑战，我了解到一些公司做微服务，但是服务拆分的乱七八糟。这样到后期越搞越乱，越搞越麻烦，你可能会觉得微服务真坑爹，后悔当初信了松哥的说微服务好的鬼话。</strong></p><ul><li>分布式系统带来的挑战</li></ul><p>记得以前在网上看到过一个段子：</p><blockquote><p>没用分布式架构之前，你只有一个问题：并发性能不足。用了分布式架构，多出了一堆问题：数据如何同步、主键如何产生、如何熔断、分布式事务如何处理……。</p></blockquote><p>这个段子形象的说明了分布式系统带来的挑战。</p><ul><li>多个研发团队的协调管理</li></ul><p>传统的单体应用开发，一个团队管理好就行了，现在不同的团队开发不同的微服务，要协调多个团队共同配合，才能做好微服务开发，这对项目管理提出了挑战。</p><p>好了，本文就先说这么多，大伙可以留言说说你的项目有没有使用微服务，出于什么样的考虑而使用了目前的架构呢？</p><p>参考资料：</p><p>[1] Chris Richardson.微服务架构设计模式[M].北京：机械工业出版社，2019.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务这么火，多少人多少公司都想试试水。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>条件注解，Spring Boot 的基石！</title>
    <link href="http://www.javaboy.org/2019/0802/springboot-conditional.html"/>
    <id>http://www.javaboy.org/2019/0802/springboot-conditional.html</id>
    <published>2019-08-02T12:26:48.000Z</published>
    <updated>2019-08-14T12:40:12.788Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot 中的自动化配置确实够吸引人，甚至有人说 Spring Boot 让 Java 又一次焕发了生机，这话虽然听着有点夸张，但是不可否认的是，曾经臃肿繁琐的 Spring 配置确实让人感到头大，而 Spring Boot 带来的全新自动化配置，又确实缓解了这个问题。</p><a id="more"></a><p>你要是问这个自动化配置是怎么实现的，很多人会说不就是 starter 嘛！那么 starter 的原理又是什么呢？松哥以前写过一篇文章，介绍了自定义 starter：</p><ul><li><a href="https://mp.weixin.qq.com/s/tKr_shLQnvcQADr4mvcU3A" target="_blank" rel="noopener">徒手撸一个 Spring Boot 中的 Starter ，解密自动化配置黑魔法！</a></li></ul><p>这里边有一个非常关键的点，那就是<strong>条件注解</strong>，甚至可以说条件注解是整个 Spring Boot 的基石。</p><p>条件注解并非一个新事物，这是一个存在于 Spring 中的东西，我们在 Spring 中常用的 profile 实际上就是条件注解的一个特殊化。</p><p>想要把 Spring Boot 的原理搞清，条件注解必须要会用，因此今天松哥就来和大家聊一聊条件注解。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Spring4 中提供了更加通用的条件注解，让我们可以在满足不同条件时创建不同的 Bean，这种配置方式在 Spring Boot 中得到了广泛的使用，大量的自动化配置都是通过条件注解来实现的，查看松哥之前的 Spring Boot 文章，凡是涉及到源码解读的文章，基本上都离不开条件注解：</p><ul><li><a href="https://mp.weixin.qq.com/s/YXBFFtWvSwR6dVLbaGDxcQ" target="_blank" rel="noopener">干货|最新版 Spring Boot2.1.5 教程+案例合集</a></li></ul><p>有的小伙伴可能没用过条件注解，但是开发环境、生产环境切换的 Profile 多多少少都有用过吧？实际上这就是条件注解的一个特例。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>抛开 Spring Boot，我们来单纯的看看在 Spring 中条件注解的用法。</p><p>首先我们来创建一个普通的 Maven 项目，然后引入 spring-context，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后定义一个 Food 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Food</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">showName</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Food 接口有一个 showName 方法和两个实现类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Food</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"米饭"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Noodles</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Food</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"面条"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别是 Rice 和 Noodles 两个类，两个类实现了 showName 方法，然后分别返回不同值。</p><p>接下来再分别创建 Rice 和 Noodles 的条件类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoodlesCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> context.getEnvironment().getProperty(<span class="hljs-string">"people"</span>).equals(<span class="hljs-string">"北方人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RiceCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> context.getEnvironment().getProperty(<span class="hljs-string">"people"</span>).equals(<span class="hljs-string">"南方人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 matches 方法中做条件属性判断，当系统属性中的 people 属性值为 ‘北方人’ 的时候，NoodlesCondition 的条件得到满足，当系统中 people 属性值为 ‘南方人’ 的时候，RiceCondition 的条件得到满足，换句话说，哪个条件得到满足，一会就会创建哪个 Bean 。</p><p>接下来我们来配置 Rice 和 Noodles ：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"food"</span>)</span><br><span class="line">    <span class="hljs-meta">@Conditional</span>(RiceCondition.class)</span><br><span class="line">    <span class="hljs-function">Food <span class="hljs-title">rice</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"food"</span>)</span><br><span class="line">    <span class="hljs-meta">@Conditional</span>(NoodlesCondition.class)</span><br><span class="line">    <span class="hljs-function">Food <span class="hljs-title">noodles</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Noodles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类，大家重点注意两个地方：</p><ul><li>两个 Bean 的名字都为 food，这不是巧合，而是有意取的。两个 Bean 的返回值都为其父类对象 Food。</li><li>每个 Bean 上都多了 @Conditional 注解，当 @Conditional 注解中配置的条件类的 matches 方法返回值为 true 时，对应的 Bean 就会生效。</li></ul><p>配置完成后，我们就可以在 main 方法中进行测试了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ctx.getEnvironment().getSystemProperties().put(<span class="hljs-string">"people"</span>, <span class="hljs-string">"南方人"</span>);</span><br><span class="line">        ctx.register(JavaConfig.class);</span><br><span class="line">        ctx.refresh();</span><br><span class="line">        Food food = (Food) ctx.getBean(<span class="hljs-string">"food"</span>);</span><br><span class="line">        System.out.println(food.showName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们创建一个 AnnotationConfigApplicationContext 实例用来加载 Java 配置类，然后我们添加一个 property 到 environment 中，添加完成后，再去注册我们的配置类，然后刷新容器。容器刷新完成后，我们就可以从容器中去获取 food 的实例了，这个实例会根据 people 属性的不同，而创建出来不同的 Food 实例。</p><p>这个就是 Spring 中的条件注解。</p><h1 id="进化"><a href="#进化" class="headerlink" title="进化"></a>进化</h1><p>条件注解还有一个进化版，那就是 Profile。我们一般利用 Profile 来实现在开发环境和生产环境之间进行快速切换。其实 Profile 就是利用条件注解来实现的。</p><p>还是刚才的例子，我们用 Profile 来稍微改造一下：</p><p>首先 Food、Rice 以及 Noodles 的定义不用变，条件注解这次我们不需要了，我们直接在 Bean 定义时添加 @Profile 注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"food"</span>)</span><br><span class="line">    <span class="hljs-meta">@Profile</span>(<span class="hljs-string">"南方人"</span>)</span><br><span class="line">    <span class="hljs-function">Food <span class="hljs-title">rice</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"food"</span>)</span><br><span class="line">    <span class="hljs-meta">@Profile</span>(<span class="hljs-string">"北方人"</span>)</span><br><span class="line">    <span class="hljs-function">Food <span class="hljs-title">noodles</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Noodles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次不需要条件注解了，取而代之的是 @Profile 。然后在 Main 方法中，按照如下方式加载 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ctx.getEnvironment().setActiveProfiles(<span class="hljs-string">"南方人"</span>);</span><br><span class="line">        ctx.register(JavaConfig.class);</span><br><span class="line">        ctx.refresh();</span><br><span class="line">        Food food = (Food) ctx.getBean(<span class="hljs-string">"food"</span>);</span><br><span class="line">        System.out.println(food.showName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果和上面的案例一样。</p><p>这样看起来 @Profile 注解貌似比 @Conditional 注解还要方便，那么 @Profile 注解到底是什么实现的呢？</p><p>我们来看一下 @Profile 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(ProfileCondition.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Profile &#123;</span><br><span class="line">String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它也是通过条件注解来实现的。条件类是 ProfileCondition ，我们来看看：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line"><span class="hljs-keyword">if</span> (attrs != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Object value : attrs.get(<span class="hljs-string">"value"</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里就明白了，其实还是我们在条件注解中写的那一套东西，只不过 @Profile 注解自动帮我们实现了而已。</p><p>@Profile 虽然方便，但是不够灵活，因为具体的判断逻辑不是我们自己实现的。而 @Conditional 则比较灵活。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>两个例子向大家展示了条件注解在 Spring 中的使用，它的一个核心思想就是当满足某种条件的时候，某个 Bean 才会生效，而正是这一特性，支撑起了 Spring Boot 的自动化配置。</p><p>好了，本文就说到这里，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot 中的自动化配置确实够吸引人，甚至有人说 Spring Boot 让 Java 又一次焕发了生机，这话虽然听着有点夸张，但是不可否认的是，曾经臃肿繁琐的 Spring 配置确实让人感到头大，而 Spring Boot 带来的全新自动化配置，又确实缓解了这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="条件注解" scheme="http://www.javaboy.org/tags/%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中用 XML 装配 Bean，竟然有五种姿势！</title>
    <link href="http://www.javaboy.org/2019/0801/spring-xml.html"/>
    <id>http://www.javaboy.org/2019/0801/spring-xml.html</id>
    <published>2019-08-01T12:26:27.000Z</published>
    <updated>2019-08-14T12:40:03.344Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot 系列还在不断的更新，有小伙伴和松哥抱怨对 Spring 还不太懂，其实我 2016 年的时候写过一点点 Spring 的教程，但是不够详细，因此，最近决定再挖一个坑，和大家聊聊 Spring 的一些常见用法，也顺便聊聊源码。</p><a id="more"></a><p>Spring 和 Spring Boot 强相关，因此，相信这个系列不会烂尾。</p><p>本想写一些高大上的架构方面的，可是考虑到有很多读者是刚入行的状态，因此还是决定先把 Spring 也和大家过一遍,当然这些东西会穿插着来，尽量满足每一个小伙伴的需求。</p><p>今天就先来和大家聊一聊 Spring 中 XML 装配 Bean 的一些经常被人忽略的细节。</p><p>使用 XML 配置 Spring ，很多人都用过，可能有的小伙伴没认真总结过，今天我们就来稍微总结下，算是开启我们的 Spring 之旅。</p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>XML 配置是最原始最古老的 Bean 的装配方案，曾经我们的项目离不开它，而如今，我们却在慢慢的抛弃它，没办法，时代在进步，我们也要进步呀。为了能看懂前辈们写的代码，我们还是有必要来看一下如何通过 XML 来装配 Bean。</p><p>首先我们来创建一个普通的 Maven 工程（不用创建成 web 工程），创建成功之后，引入 Spring 相关的依赖，这里只要引入 spring-context 即可，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建成功之后，我们再来创建一个 Book 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在 resources 目录下创建一个 beans.xml 文件，作为 Spring 的配置文件，然后在里边配置一个 Book bean，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，我们在 class 属性中配置类的全路径，id 则表示 bean 的名称，也可以通过 name 属性来指定 bean 的名称，大部分场景下两者无任何差别，会有一些特殊场景下（例如用,隔开多个实例名，两者的处理方案不同），两者有区别。</p><p>然后我们在 Java 代码中加载这个配置文件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:beans.xml"</span>);</span><br></pre></td></tr></table></figure><p><strong>题外话：</strong></p><p>ClassPathXmlApplicationContext 是配置文件众多的加载方式之一，表示从 classpath 下加载配置文件，这也是较常用的加载方式之一。其他常见的加载方式如下：</p><p><img src="http://www.javaboy.org/images/spring/1-1.png" alt></p><p>从这些不同的实现类中可以看到，我们也可以直接从文件系统中加载 Spring 的 XML 配置文件，使用 FileSystemXmlApplicationContext 类即可。</p><p>配置文件加载完成后，我们就可以从 Spring 容器中去获取这些 Bean 了，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book book = (Book) ctx.getBean(<span class="hljs-string">"book"</span>);</span><br></pre></td></tr></table></figure><p>这个表示根据 id 获取相应的 Bean ，我们也可以通过类型来获取，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book b1 = ctx.getBean(Book.class);</span><br></pre></td></tr></table></figure><p>两种方式推荐第一种。</p><p>第二种通过类型获取 Bean 的方式存在一个问题，就是容器中同一个类如果存在多个实例，通过类型获取肯定会出错。</p><p>但是此时我们获取到的 Bean 中的属性全部为 null，没有值，这是因为我们在配置的时候没有给属性指定值。</p><p>在配置 Bean 时，给 Bean 指定相关的属性值，我们有几种不同的方式：</p><h2 id="1-构造方法指定"><a href="#1-构造方法指定" class="headerlink" title="1.构造方法指定"></a>1.构造方法指定</h2><p>首先我们可以通过构造方法指定 bean 的属性值，前提是我们为 Book 类提供一个有参构造方法（大家在创建有参构造方法时，一定记得再顺手加一个无参构造方法）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(Integer id, String name, Double price)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">        <span class="hljs-keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中，我们就可以通过构造方法注入相关值了：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book2"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"三国演义"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用构造方法注入相关值的时候，也可以使用下标来描述参数的顺序，注意如果使用下标，参数顺序不能错：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book3"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"红楼梦"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"100"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注入成功之后，当我们再次去获取 Bean 的时候，就可以看到这些属性了。</p><h2 id="2-通过属性注入"><a href="#2-通过属性注入" class="headerlink" title="2.通过属性注入"></a>2.通过属性注入</h2><p>当然也可以通过属性注入，这是一种更为常见的方式：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-p名称空间注入"><a href="#3-p名称空间注入" class="headerlink" title="3.p名称空间注入"></a>3.p名称空间注入</h2><p>p 名称空间本质上还是通过属性注入的，只不过写法有些差异，p 名称空间注入方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book5"</span> <span class="hljs-attr">p:id</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">"西游记"</span> <span class="hljs-attr">p:price</span>=<span class="hljs-string">"40"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上三种不同的属性注入方式，我给大家演示的都是注入基本数据类型，如果注入的是一个对象的话，只需要通过 ref 属性来指明对象的引用即可。</p></blockquote><h1 id="特殊属性注入"><a href="#特殊属性注入" class="headerlink" title="特殊属性注入"></a>特殊属性注入</h1><p>除了这些基本属性之外，还有一些特殊属性，例如集合、数组、map 等。我们分别来看。</p><h2 id="集合-数组"><a href="#集合-数组" class="headerlink" title="集合/数组"></a>集合/数组</h2><p>集合/数组的注入方式基本一致，首先我们给项目添加一个集合属性，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;String&gt; authors;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性注入时，可以通过 array 节点注入值：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>lisi<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以通过 list 节点注入值：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>lisi<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有一个可能大家使用比较少的方式，就是通过 utils:list 来创建集合属性，然后配置到 Book 属性中去，即可：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span> /&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">utils:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"authors"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">utils:list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式比较少见。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 的注入也有几种不同的方式，可以通过属性指定，也可以通过 utils 来搞定，先来看第一种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;String&gt; authors;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; info;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 xml 文件中通过如下方式指定属性值：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"zhangsan"</span>/&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以通过 utils 来指定 map 的值，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"info"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">utils:map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"info"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"lisi"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"98"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">utils:map</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><p>properties 属性也是一样的配置方案。既可以通过 props 属性指定，也可以通过 utils 来指定，例如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;String&gt; authors;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; info;</span><br><span class="line">    <span class="hljs-keyword">private</span> Properties info2;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 props 属性指定方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"info"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info2"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"name"</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"age"</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 utils 指定方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"info"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info2"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"info2"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">utils:properties</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"info2"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"name"</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"age"</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">utils:properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了这几种装配方式之外，我们也可以通过工厂方法装配。</p><h1 id="工厂方法装配"><a href="#工厂方法装配" class="headerlink" title="工厂方法装配"></a>工厂方法装配</h1><p>工厂方法装配可以分为静态工厂和实例工厂两种方式，我们分别来看。</p><h2 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h2><p>静态工厂方法装配需要我们先创建一个静态工厂方法，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookFactory</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Book <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Book();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中装配：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.BookFactory"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book6"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>此时我们去容器中获取 book6 这个实例，拿到的就是你在静态工厂中返回的 Book 实例。</p><h2 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h2><p>实例工厂方法则是指工厂方法是一个普通方法，不是静态的，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookFactory2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Book();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中，我们需要首先配置 BookFactory2 的实例，然后才能调用实例中的方法获取 Book 对象，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.BookFactory2"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bookFactory2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book7"</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"bookFactory2"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>工厂方法装配的价值在哪里呢？</p><p>例如 Druid 中的 DataSource 对象，通过 <code>DruidDataSourceBuilder.create().build()</code> 方法来构建，如果我们想在 XML 中做这个配置，显然不太容易，此时就可以使用工厂方法装配了。</p><p>好了，这就是 XML 装配 Bean 的一个简单介绍，比较简单，但是为了知识的完整性，我还是稍微写了下，能看到这里的都是真爱啊！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot 系列还在不断的更新，有小伙伴和松哥抱怨对 Spring 还不太懂，其实我 2016 年的时候写过一点点 Spring 的教程，但是不够详细，因此，最近决定再挖一个坑，和大家聊聊 Spring 的一些常见用法，也顺便聊聊源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>天天吹微服务，单体应用有啥不好？</title>
    <link href="http://www.javaboy.org/2019/0729/microservice.html"/>
    <id>http://www.javaboy.org/2019/0729/microservice.html</id>
    <published>2019-07-29T00:17:40.000Z</published>
    <updated>2019-07-29T00:23:09.251Z</updated>
    
    <content type="html"><![CDATA[<p>单体应用确实有问题！</p><p>最近在研究微服务架构，有一点点心得，打算在公众号上写几篇文章和大家慢慢分享下。</p><a id="more"></a><p>这个话题有点大，我会分几篇文章和大家慢慢说，今天就先来说说传统的单体应用有哪些弊端，正是因为单体应用存在的弊端，使得我们不得不考虑发展微服务。</p><p>人类发展的历史就是一个社会分工不断细化的历史，从这个角度来讲，微服务这种将一个复杂的大项目拆分为众多小项目，然后程序员分工合作，共同完成项目，这种协作方式是符合历史潮流的。</p><p>这是我们站在今天的角度来说的，曾经的单体应用也是先进生产力的代表。</p><p>但是，随着互联网的发展，我们对一个系统的要求越来越高，单体应用已经很难适应当前的开发，因此在回答我们为什么要使用微服务这个问题之前，我们有必要来聊一聊单体应用目前都面临哪些问题。</p><h1 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h1><h2 id="1-项目过度复杂"><a href="#1-项目过度复杂" class="headerlink" title="1.项目过度复杂"></a>1.项目过度复杂</h2><p>你要创建一个简单的用户管理系统，二话不说，直接创建 Maven 项目然后开干就完事了，这没问题，因为这很简单。</p><p>但是你要说想搞一个淘宝网站，或者你想搞一个用友 U8 系统，那你恐怕就得先慢慢设计系统架构了。单体应用，由于就是一个项目，所有的功能都是写在一个项目中，不可避免的出现项目过度复杂的情况。而且这种复杂情况会不断恶化。</p><p>有的小伙伴可能有这样的经验，刚入职了一家公司，新接手了一个项目，上面催的很急，让你赶快修复几个 bug ，项目复杂，光是实体类的包就有好几个 bean、model、pojo 等，一个项目被很多人经手之后，到你手里，早已经一团乱麻，你小心翼翼尽量不碰触到已有的功能，终于修完了几个 bug，搞了俩礼拜，你觉得这个项目太坑爹了，不想干了，于是接盘侠从你手里接到了一个复杂度又上升了一步的项目。</p><p>就这样，一个原本简简单单的单体项目，在变复杂的路上一去不复返。</p><h2 id="2-开发速度缓慢"><a href="#2-开发速度缓慢" class="headerlink" title="2.开发速度缓慢"></a>2.开发速度缓慢</h2><p>单体应用开发速度缓慢，因为单体应用复杂了之后，项目变得异常臃肿而且庞大，每一次编译构建、运行以及测试，都需要花费大量时间，而且如果测试有问题，又得从头来一遍，注意，这里的每一次从头编译构建等都是整个项目的从头编译构建。</p><p>即使你可能只要修改某一个参数，你也得把上面整个流程走一遍，相当于每一次的修改都是牵一发而动全身的操作。</p><p>速度没法快。</p><h2 id="3-不易扩展"><a href="#3-不易扩展" class="headerlink" title="3.不易扩展"></a>3.不易扩展</h2><p>项目中不同模块对计算机的性能要求不一样，例如使用 Redis 来保存了大量的热点数据，那么我们希望服务器的内存非常大，另外有一个模块涉及到了图片处理，我们又希望服务器的 CPU 非常强，如果是单体应用部署的话，那么这些条件服务器都要满足。</p><h2 id="4-技术栈不易扩展"><a href="#4-技术栈不易扩展" class="headerlink" title="4.技术栈不易扩展"></a>4.技术栈不易扩展</h2><p>单体应用还有一个劣势就是技术栈不易扩展，一旦你选定了某一个技术栈来开发项目，以后很难在技术栈上做切换。有的公司还会自己搞一套系统，这种在当时看起来好像都没有啥问题，可是经过几年之后，回头再看，已经很过时了，很 low 了，当初设计系统的人可能已经离职了，刚入职的新手也不敢动这个老古董，只能在这个老古董上面忍痛开发。</p><p>有的时候，有一个服务需要处理高并发，你很想用 Go 语言来做，可是做不到，没法引入其他语言。</p><p>这些都是单体应用的劣势，如果有微服务，上面这些问题都将得到解决。</p><h1 id="曾经的优势"><a href="#曾经的优势" class="headerlink" title="曾经的优势"></a>曾经的优势</h1><p>当然，事物都是有两面性的，单体应用也有它自己的优势，例如：</p><ul><li>开发简单，一个 IDE 就可以快速构建出一个单体应用</li><li>测试简单</li><li>部署简单，Tomcat 安装好之后，应用扔上去就行了</li><li>集群化部署也很容易，多个 Tomcat + 一个 Nginx 分分钟就搭建好集群环境了</li></ul><p>这么多优势，还是难掩劣势。</p><p>不过大家在做项目的时候，还是要结合实际情况来选择，不能因为微服务厉害，所有项目都是微服务，如果你仅仅只想做一个用户的增删改查，那么很明显，创建一个简单的单体应用是最合适的。</p><p>好了，本文主要和大家分享了传统单体应用存在的一些问题，正是因为这些问题，我们需要引入微服务，下篇文章，我们就来看看微服务有哪些优势。</p><p>参考资料：</p><p>[1] Chris Richardson.微服务架构设计模式[M].北京：机械工业出版社，2019.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单体应用确实有问题！&lt;/p&gt;
&lt;p&gt;最近在研究微服务架构，有一点点心得，打算在公众号上写几篇文章和大家慢慢分享下。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="单体应用" scheme="http://www.javaboy.org/tags/%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>手把手带你入门 Spring Security！</title>
    <link href="http://www.javaboy.org/2019/0725/springboot-springsecurity.html"/>
    <id>http://www.javaboy.org/2019/0725/springboot-springsecurity.html</id>
    <published>2019-07-25T00:44:50.000Z</published>
    <updated>2019-07-25T00:47:08.592Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。</p><a id="more"></a><p>相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。</p><p>自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。</p><p>因此，一般来说，常见的安全管理技术栈的组合是这样的：</p><ul><li>SSM + Shiro</li><li>Spring Boot/Spring Cloud + Spring Security</li></ul><p><strong>注意，这只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。</strong></p><p>我们来看下具体使用。</p><h1 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h1><p>在 Spring Boot 中使用 Spring Security 非常容易，引入依赖即可：</p><p><img src="http://www.javaboy.org/images/boot/25-1.png" alt></p><p>pom.xml 中的 Spring Security 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要加入依赖，项目的所有接口都会被自动保护起来。</p><h1 id="2-初次体验"><a href="#2-初次体验" class="headerlink" title="2.初次体验"></a>2.初次体验</h1><p>我们创建一个 HelloController:</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <code>/hello</code> ，需要登录之后才能访问。</p><p><img src="http://www.javaboy.org/images/boot/25-2.png" alt></p><p>当用户从浏览器发送请求访问 <code>/hello</code> 接口时，服务端会返回 <code>302</code> 响应码，让客户端重定向到 <code>/login</code> 页面，用户在 <code>/login</code> 页面登录，登陆成功之后，就会自动跳转到 <code>/hello</code> 接口。</p><p>另外，也可以使用 <code>POSTMAN</code> 来发送请求，使用 <code>POSTMAN</code> 发送请求时，可以将用户信息放在请求头中（这样可以避免重定向到登录页面）：</p><p><img src="http://www.javaboy.org/images/boot/25-3.png" alt></p><p>通过以上两种不同的登录方式，可以看出，Spring Security 支持两种不同的认证方式：</p><ul><li>可以通过 form 表单来认证</li><li>可以通过 HttpBasic 来认证</li></ul><h1 id="3-用户名配置"><a href="#3-用户名配置" class="headerlink" title="3.用户名配置"></a>3.用户名配置</h1><p>默认情况下，登录的用户名是 <code>user</code> ，密码则是项目启动时随机生成的字符串，可以从启动的控制台日志中看到默认密码：</p><p><img src="http://www.javaboy.org/images/boot/25-4.png" alt></p><p>这个随机生成的密码，每次启动时都会变。对登录的用户名/密码进行配置，有三种不同的方式：</p><ul><li>在 application.properties 中进行配置</li><li>通过 Java 代码配置在内存中</li><li>通过 Java 从数据库中加载</li></ul><p>前两种比较简单，第三种代码量略大，本文就先来看看前两种，第三种后面再单独写文章介绍，也可以参考我的<a href>微人事项目</a>。</p><h2 id="3-1-配置文件配置用户名-密码"><a href="#3-1-配置文件配置用户名-密码" class="headerlink" title="3.1 配置文件配置用户名/密码"></a>3.1 配置文件配置用户名/密码</h2><p>可以直接在 application.properties 文件中配置用户的基本信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=123</span><br></pre></td></tr></table></figure><p>配置完成后，重启项目，就可以使用这里配置的用户名/密码登录了。</p><h2 id="3-2-Java-配置用户名-密码"><a href="#3-2-Java-配置用户名-密码" class="headerlink" title="3.2 Java 配置用户名/密码"></a>3.2 Java 配置用户名/密码</h2><p>也可以在 Java 代码中配置用户名密码，首先需要我们创建一个 Spring Security 的配置类，集成自 WebSecurityConfigurerAdapter 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//下面这两行配置表示在内存中配置了两个用户</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"javaboy"</span>).roles(<span class="hljs-string">"admin"</span>).password(<span class="hljs-string">"$2a$10$OR3VSksVAmCzc.7WeaRPR.t0wyCsIj24k0Bne8iKWV1o.V9wsP8Xe"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="hljs-string">"lisi"</span>).roles(<span class="hljs-string">"user"</span>).password(<span class="hljs-string">"$2a$10$p1H8iWa8I4.CA.7Z8bwLjes91ZpY.rYREGHQEInNtAp4NzL6PLKxi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在 configure 方法中配置了两个用户，用户的密码都是加密之后的字符串(明文是 123)，从 Spring5 开始，强制要求密码要加密，如果非不想加密，可以使用一个过期的 PasswordEncoder 的实例 NoOpPasswordEncoder，但是不建议这么做，毕竟不安全。</p><p>Spring Security 中提供了 BCryptPasswordEncoder 密码编码工具，可以非常方便的实现密码的加密加盐，相同明文加密出来的结果总是不同，这样就不需要用户去额外保存<code>盐</code>的字段了，这一点比 Shiro 要方便很多。</p><h1 id="4-登录配置"><a href="#4-登录配置" class="headerlink" title="4.登录配置"></a>4.登录配置</h1><p>对于登录接口，登录成功后的响应，登录失败后的响应，我们都可以在 WebSecurityConfigurerAdapter 的实现类中进行配置。例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    VerifyCodeFilter verifyCodeFilter;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http</span><br><span class="line">        .authorizeRequests()<span class="hljs-comment">//开启登录配置</span></span><br><span class="line">        .antMatchers(<span class="hljs-string">"/hello"</span>).hasRole(<span class="hljs-string">"admin"</span>)<span class="hljs-comment">//表示访问 /hello 这个接口，需要具备 admin 这个角色</span></span><br><span class="line">        .anyRequest().authenticated()<span class="hljs-comment">//表示剩余的其他接口，登录之后就能访问</span></span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        <span class="hljs-comment">//定义登录页面，未登录时，访问一个需要登录之后才能访问的接口，会自动跳转到该页面</span></span><br><span class="line">        .loginPage(<span class="hljs-string">"/login_p"</span>)</span><br><span class="line">        <span class="hljs-comment">//登录处理接口</span></span><br><span class="line">        .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">        <span class="hljs-comment">//定义登录时，用户名的 key，默认为 username</span></span><br><span class="line">        .usernameParameter(<span class="hljs-string">"uname"</span>)</span><br><span class="line">        <span class="hljs-comment">//定义登录时，用户密码的 key，默认为 password</span></span><br><span class="line">        .passwordParameter(<span class="hljs-string">"passwd"</span>)</span><br><span class="line">        <span class="hljs-comment">//登录成功的处理器</span></span><br><span class="line">        .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="hljs-string">"success"</span>);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .failureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="hljs-string">"fail"</span>);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()<span class="hljs-comment">//和表单登录相关的接口统统都直接通过</span></span><br><span class="line">            .and()</span><br><span class="line">            .logout()</span><br><span class="line">            .logoutUrl(<span class="hljs-string">"/logout"</span>)</span><br><span class="line">            .logoutSuccessHandler(<span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="hljs-string">"logout success"</span>);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .httpBasic()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在 successHandler 方法中，配置登录成功的回调，如果是前后端分离开发的话，登录成功后返回 JSON 即可，同理，failureHandler 方法中配置登录失败的回调，logoutSuccessHandler 中则配置注销成功的回调。</p><h1 id="5-忽略拦截"><a href="#5-忽略拦截" class="headerlink" title="5.忽略拦截"></a>5.忽略拦截</h1><p>如果某一个请求地址不需要拦截的话，有两种方式实现：</p><ul><li>设置该地址匿名访问</li><li>直接过滤掉该地址，即该地址不走 Spring Security 过滤器链</li></ul><p>推荐使用第二种方案，配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="hljs-string">"/vercode"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 另外一个强大之处就是它可以结合 OAuth2 ，玩出更多的花样出来，这些我们在后面的文章中再和大家细细介绍。</p><p>本文就先说到这里，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 中 @Param 注解的四种使用场景，最后一种经常被人忽略！</title>
    <link href="http://www.javaboy.org/2019/0723/mybatis-@param.html"/>
    <id>http://www.javaboy.org/2019/0723/mybatis-@param.html</id>
    <published>2019-07-23T00:36:00.000Z</published>
    <updated>2019-07-23T00:37:14.013Z</updated>
    
    <content type="html"><![CDATA[<p>有一些小伙伴觉得 MyBatis 只有方法中存在多个参数的时候，才需要添加 @Param 注解，其实这个理解是不准确的。即使 MyBatis 方法只有一个参数，也可能会用到 @Param 注解。</p><a id="more"></a><p>但是，在你总结出规律之前，你可能会觉得莫名其妙，有的时候一个参数明明不用添加 @Param 注解，有的时候，却需要添加，不添加会报错。</p><p>有的人会觉得这是 MyBatis 各个版本差异的锅，不可否认，MyBatis 发展很快，不同版本之间的差异还挺明显的，不过这个加不加 @Param 注解的问题，却并不是版本的锅！今天松哥就和大家来聊一聊这个问题，到底哪些情况下需要添加 @Param 注解。</p><p>首先，如下几个需要添加 @Param 注解的场景，相信大家都已经有共识了：</p><ul><li>第一种：方法有多个参数，需要 @Param 注解</li></ul><p>例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">Integer <span class="hljs-title">insert</span><span class="hljs-params">(@Param(<span class="hljs-string">"username"</span>)</span> String username, @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"address"</span>)</span> String address)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 XML 文件如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insert"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.javaboy.helloboot.bean.User"</span>&gt;</span></span><br><span class="line">    insert into user (username,address) values (#&#123;username&#125;,#&#123;address&#125;);</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是最常见的需要添加 @Param 注解的场景。</p><ul><li>第二种：方法参数要取别名，需要 @Param 注解</li></ul><p>当需要给参数取一个别名的时候，我们也需要 @Param 注解，例如方法定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">getUserByUsername</span><span class="hljs-params">(@Param(<span class="hljs-string">"name"</span>)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 XML 定义如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserByUsername"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.javaboy.helloboot.bean.User"</span>&gt;</span></span><br><span class="line">    select * from user where username=#&#123;name&#125;;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>老实说，这种需求不多，费事。</p><ul><li>第三种：XML 中的 SQL 使用了 $ ，那么参数中也需要 @Param 注解</li></ul><p>$ 会有注入漏洞的问题，但是有的时候你不得不使用 $ 符号，例如要传入列名或者表名的时候，这个时候必须要添加 @Param 注解，例如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getAllUsers</span><span class="hljs-params">(@Param(<span class="hljs-string">"order_by"</span>)</span>String order_by)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 XML 定义如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getAllUsers"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.helloboot.bean.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"order_by!=null and order_by!=''"</span>&gt;</span></span><br><span class="line">        order by $&#123;order_by&#125; desc</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前面这三种，都很容易懂，相信很多小伙伴也都懂，除了这三种常见的场景之外，还有一个特殊的场景，经常被人忽略。</p><ul><li>第四种，那就是动态 SQL ，如果在动态 SQL 中使用了参数作为变量，那么也需要 @Param 注解，即使你只有一个参数。</li></ul><p>如果我们在动态 SQL 中用到了 参数作为判断条件，那么也是一定要加 @Param 注解的，例如如下方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getUserById</span><span class="hljs-params">(@Param(<span class="hljs-string">"id"</span>)</span>Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义出来的 SQL 如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"getUserById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.helloboot.bean.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"id!=null"</span>&gt;</span></span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种情况，即使只有一个参数，也需要添加 @Param 注解，而这种情况却经常被人忽略！</p><p>好了，不知道大家有没有 GET 到呢？有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一些小伙伴觉得 MyBatis 只有方法中存在多个参数的时候，才需要添加 @Param 注解，其实这个理解是不准确的。即使 MyBatis 方法只有一个参数，也可能会用到 @Param 注解。&lt;/p&gt;
    
    </summary>
    
      <category term="MyBatis" scheme="http://www.javaboy.org/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://www.javaboy.org/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 邮件发送的 5 种姿势！</title>
    <link href="http://www.javaboy.org/2019/0717/springboot-mail.html"/>
    <id>http://www.javaboy.org/2019/0717/springboot-mail.html</id>
    <published>2019-07-17T00:30:51.000Z</published>
    <updated>2019-07-17T00:34:57.250Z</updated>
    
    <content type="html"><![CDATA[<p>邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。</p><a id="more"></a><h1 id="邮件基础"><a href="#邮件基础" class="headerlink" title="邮件基础"></a>邮件基础</h1><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。  </p><p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。  </p><p>生活中我们投递一封邮件要经过如下几个步骤：  </p><ol><li>深圳的小王先将邮件投递到深圳的邮局  </li><li>深圳的邮局将邮件运送到上海的邮局  </li><li>上海的小张来邮局取邮件   </li></ol><p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> ：  </p><ol><li><a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器  </li><li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器  </li><li><a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 登录网易的邮件服务器查看邮件  </li></ol><p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。  </p><p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件与 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><p>最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。  </p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>目前国内大部分的邮件服务商都不允许直接使用用户名/密码的方式来在代码中发送邮件，都是要先申请授权码，这里以 QQ 邮箱为例，向大家演示授权码的申请流程：首先我们需要先登录 QQ 邮箱网页版，点击上方的设置按钮：  </p><p><img src="http://www.javaboy.org/images/mail/24-1.jpg" alt="p266">  </p><p>然后点击账户选项卡：  </p><p><img src="http://www.javaboy.org/images/mail/24-2.jpg" alt="p267">  </p><p>在账户选项卡中找到开启POP3/SMTP选项，如下：  </p><p><img src="http://www.javaboy.org/images/mail/24-3.jpg" alt="p268">  </p><p>点击开启，开启相关功能，开启过程需要手机号码验证，按照步骤操作即可，不赘述。开启成功之后，即可获取一个授权码，将该号码保存好，一会使用。</p><h1 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h1><p>接下来，我们就可以创建项目了，Spring Boot 中，对于邮件发送提供了自动配置类，开发者只需要加入相关依赖，然后配置一下邮箱的基本信息，就可以发送邮件了。</p><ul><li>首先创建一个 Spring Boot 项目，引入邮件发送依赖：</li></ul><p><img src="http://www.javaboy.org/images/mail/24-4.png" alt></p><p>创建完成后，项目依赖如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置邮箱基本信息</li></ul><p>项目创建成功后，接下来在 application.properties 中配置邮箱的基本信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.mail.host=smtp.qq.com</span><br><span class="line">spring.mail.port=587</span><br><span class="line">spring.mail.username=1510161612@qq.com</span><br><span class="line">spring.mail.password=ubknfzhjkhrbbabe</span><br><span class="line">spring.mail.default-encoding=UTF-8</span><br><span class="line">spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory</span><br><span class="line">spring.mail.properties.mail.debug=true</span><br></pre></td></tr></table></figure><p>配置含义分别如下：</p><ul><li>配置 SMTP 服务器地址</li><li>SMTP 服务器的端口</li><li>配置邮箱用户名</li><li>配置密码，注意，不是真正的密码，而是刚刚申请到的授权码</li><li>默认的邮件编码</li><li>配饰 SSL 加密工厂</li><li>表示开启 DEBUG 模式，这样，邮件发送过程的日志会在控制台打印出来，方便排查错误</li></ul><p>如果不知道 smtp 服务器的端口或者地址的的话，可以参考 腾讯的邮箱文档</p><ul><li><a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371" target="_blank" rel="noopener">https://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=371</a></li></ul><p>做完这些之后，Spring Boot 就会自动帮我们配置好邮件发送类，相关的配置在 <code>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration</code> 类中，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; MimeMessage.class, MimeType.class, MailSender.class &#125;)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(MailSender.class)</span><br><span class="line"><span class="hljs-meta">@Conditional</span>(MailSenderCondition.class)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(MailProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，可以看到，导入了另外一个配置 <code>MailSenderPropertiesConfiguration</code> 类，这个类中，提供了邮件发送相关的工具类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mail"</span>, name = <span class="hljs-string">"host"</span>)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSenderPropertiesConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MailProperties properties;</span><br><span class="line">        MailSenderPropertiesConfiguration(MailProperties properties) &#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.properties = properties;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> JavaMailSenderImpl <span class="hljs-title">mailSender</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                JavaMailSenderImpl sender = <span class="hljs-keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">                applyProperties(sender);</span><br><span class="line">                <span class="hljs-keyword">return</span> sender;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里创建了一个 <code>JavaMailSenderImpl</code> 的实例， <code>JavaMailSenderImpl</code> 是 <code>JavaMailSender</code> 的一个实现，我们将使用 <code>JavaMailSenderImpl</code> 来完成邮件的发送工作。</p><p>做完如上两步，邮件发送的准备工作就算是完成了，接下来就可以直接发送邮件了。</p><p>具体的发送，有 5 种不同的方式，我们一个一个来看。</p><h2 id="发送简单邮件"><a href="#发送简单邮件" class="headerlink" title="发送简单邮件"></a>发送简单邮件</h2><p>简单邮件就是指邮件内容是一个普通的文本文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JavaMailSender javaMailSender;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSimpleMail</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    SimpleMailMessage message = <span class="hljs-keyword">new</span> SimpleMailMessage();</span><br><span class="line">    message.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    message.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    message.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    message.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    message.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    message.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    message.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    javaMailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上往下，代码含义分别如下：</p><ol><li>构建一个邮件对象</li><li>设置邮件主题</li><li>设置邮件发送者</li><li>设置邮件接收者，可以有多个接收者</li><li>设置邮件抄送人，可以有多个抄送人</li><li>设置隐秘抄送人，可以有多个</li><li>设置邮件发送日期</li><li>设置邮件的正文</li><li>发送邮件</li></ol><p>最后执行该方法，就可以实现邮件的发送，发送效果图如下：</p><p><img src="http://www.javaboy.org/images/mail/24-5.png" alt></p><h2 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h2><p>邮件的附件可以是图片，也可以是普通文件，都是支持的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendAttachFileMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"这是测试邮件的正文"</span>);</span><br><span class="line">    helper.addAttachment(<span class="hljs-string">"javaboy.jpg"</span>,<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里在构建邮件对象上和前文有所差异，这里是通过 javaMailSender 来获取一个复杂邮件对象，然后再利用 MimeMessageHelper 对邮件进行配置，MimeMessageHelper 是一个邮件配置的辅助工具类，创建时候的 true 表示构建一个 multipart message 类型的邮件，有了 MimeMessageHelper 之后，我们针对邮件的配置都是由 MimeMessageHelper 来代劳。</p><p>最后通过 addAttachment 方法来添加一个附件。</p><p>执行该方法，邮件发送效果图如下：</p><p><img src="http://www.javaboy.org/images/mail/24-6.png" alt></p><h2 id="发送带图片资源的邮件"><a href="#发送带图片资源的邮件" class="headerlink" title="发送带图片资源的邮件"></a>发送带图片资源的邮件</h2><p>图片资源和附件有什么区别呢？图片资源是放在邮件正文中的，即一打开邮件，就能看到图片。但是一般来说，不建议使用这种方式，一些公司会对邮件内容的大小有限制（因为这种方式是将图片一起发送的）。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendImgResMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    helper.setText(<span class="hljs-string">"&lt;p&gt;hello 大家好，这是一封测试邮件，这封邮件包含两种图片，分别如下&lt;/p&gt;&lt;p&gt;第一张图片：&lt;/p&gt;&lt;img src='cid:p01'/&gt;&lt;p&gt;第二张图片：&lt;/p&gt;&lt;img src='cid:p02'/&gt;"</span>,<span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p01"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy.png"</span>)));</span><br><span class="line">    helper.addInline(<span class="hljs-string">"p02"</span>,<span class="hljs-keyword">new</span> FileSystemResource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Downloads\\javaboy2.png"</span>)));</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的邮件 text 是一个 HTML 文本，里边涉及到的图片资源先用一个占位符占着，setText 方法的第二个参数 true 表示第一个参数是一个 HTML 文本。</p><p>setText 之后，再通过 addInline 方法来添加图片资源。</p><p>最后执行该方法，发送邮件，效果如下：</p><p><img src="http://www.javaboy.org/images/mail/24-7.png" alt></p><p>在公司实际开发中，第一种和第三种都不是使用最多的邮件发送方案。因为正常来说，邮件的内容都是比较的丰富的，所以大部分邮件都是通过 HTML 来呈现的，如果直接拼接 HTML 字符串，这样以后不好维护，为了解决这个问题，一般邮件发送，都会有相应的邮件模板。最具代表性的两个模板就是 <code>Freemarker</code> 模板和 <code>Thyemeleaf</code> 模板了。</p><h2 id="使用-Freemarker-作邮件模板"><a href="#使用-Freemarker-作邮件模板" class="headerlink" title="使用 Freemarker 作邮件模板"></a>使用 Freemarker 作邮件模板</h2><p>首先需要引入 Freemarker 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>resources/templates</code> 目录下创建一个 <code>mail.ftl</code> 作为邮件发送模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;salary&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，将邮件模板渲染成 HTML ，然后发送即可。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendFreemarkerMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException, IOException, TemplateException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    <span class="hljs-comment">//构建 Freemarker 的基本配置</span></span><br><span class="line">    Configuration configuration = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_0);</span><br><span class="line">    <span class="hljs-comment">// 配置模板位置</span></span><br><span class="line">    ClassLoader loader = MailApplication.class.getClassLoader();</span><br><span class="line">    configuration.setClassLoaderForTemplateLoading(loader, <span class="hljs-string">"templates"</span>);</span><br><span class="line">    <span class="hljs-comment">//加载模板</span></span><br><span class="line">    Template template = configuration.getTemplate(<span class="hljs-string">"mail.ftl"</span>);</span><br><span class="line">    User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    user.setNum(<span class="hljs-number">1</span>);</span><br><span class="line">    user.setSalary((<span class="hljs-keyword">double</span>) <span class="hljs-number">99999</span>);</span><br><span class="line">    StringWriter out = <span class="hljs-keyword">new</span> StringWriter();</span><br><span class="line">    <span class="hljs-comment">//模板渲染，渲染的结果将被保存到 out 中 ，将out 中的 html 字符串发送即可</span></span><br><span class="line">    template.process(user, out);</span><br><span class="line">    helper.setText(out.toString(),<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，虽然引入了 <code>Freemarker</code> 的自动化配置，但是我们在这里是直接 <code>new Configuration</code> 来重新配置 <code>Freemarker</code> 的，所以 Freemarker 默认的配置这里不生效，因此，在填写模板位置时，值为 <code>templates</code> 。</p><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://www.javaboy.org/images/mail/24-8.png" alt></p><h2 id="使用-Thymeleaf-作邮件模板"><a href="#使用-Thymeleaf-作邮件模板" class="headerlink" title="使用 Thymeleaf 作邮件模板"></a>使用 Thymeleaf 作邮件模板</h2><p>推荐在 Spring Boot 中使用 Thymeleaf 来构建邮件模板。因为 Thymeleaf 的自动化配置提供了一个 TemplateEngine，通过 TemplateEngine 可以方便的将 Thymeleaf 模板渲染为 HTML ，同时，Thymeleaf 的自动化配置在这里是继续有效的 。</p><p>首先，引入 Thymeleaf 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，创建 <code>Thymeleaf</code> 邮件模板：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎加入 xxx 大家庭，您的入职信息如下：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;username&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>工号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;num&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>薪水<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;salary&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #ff1a0e"</span>&gt;</span>一起努力创造辉煌<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来发送邮件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendThymeleafMail</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">    MimeMessage mimeMessage = javaMailSender.createMimeMessage();</span><br><span class="line">    MimeMessageHelper helper = <span class="hljs-keyword">new</span> MimeMessageHelper(mimeMessage, <span class="hljs-keyword">true</span>);</span><br><span class="line">    helper.setSubject(<span class="hljs-string">"这是一封测试邮件"</span>);</span><br><span class="line">    helper.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);</span><br><span class="line">    helper.setTo(<span class="hljs-string">"25xxxxx755@qq.com"</span>);</span><br><span class="line">    helper.setCc(<span class="hljs-string">"37xxxxx37@qq.com"</span>);</span><br><span class="line">    helper.setBcc(<span class="hljs-string">"14xxxxx098@qq.com"</span>);</span><br><span class="line">    helper.setSentDate(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    Context context = <span class="hljs-keyword">new</span> Context();</span><br><span class="line">    context.setVariable(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"num"</span>,<span class="hljs-string">"000001"</span>);</span><br><span class="line">    context.setVariable(<span class="hljs-string">"salary"</span>, <span class="hljs-string">"99999"</span>);</span><br><span class="line">    String process = templateEngine.process(<span class="hljs-string">"mail.html"</span>, context);</span><br><span class="line">    helper.setText(process,<span class="hljs-keyword">true</span>);</span><br><span class="line">    javaMailSender.send(mimeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法，发送邮件，效果图如下：</p><p><img src="http://www.javaboy.org/images/mail/24-8.png" alt></p><p>好了，这就是我们今天说的 5 种邮件发送姿势，不知道你掌握了没有呢？</p><p>本文案例已经上传到 GitHub：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a>。</p><p>有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;邮件发送其实是一个非常常见的需求，用户注册，找回密码等地方，都会用到，使用 JavaSE 代码发送邮件，步骤还是挺繁琐的，Spring Boot 中对于邮件发送，提供了相关的自动化配置类，使得邮件发送变得非常容易，本文我们就来一探究竟！看看使用 Spring Boot 发送邮件的 5 中姿势。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Mail" scheme="http://www.javaboy.org/tags/Mail/"/>
    
  </entry>
  
  <entry>
    <title>2019 Java 全栈工程师进阶路线图，一定要收藏</title>
    <link href="http://www.javaboy.org/2019/0715/java-fullstack.html"/>
    <id>http://www.javaboy.org/2019/0715/java-fullstack.html</id>
    <published>2019-07-15T00:50:47.000Z</published>
    <updated>2019-07-15T00:52:51.629Z</updated>
    
    <content type="html"><![CDATA[<p>技术更新日新月异，对于初入职场的同学来说，经常会困惑该往那个方向发展，这一点松哥是深有体会的。</p><a id="more"></a><p>我刚开始学习 Java 那会，最大的问题就是不知道该学什么，以及学习的顺序，我相信这也是很多初学者经常面临的问题。​我当时经常胡子眉毛一把抓，那会学习资料倒是不缺，学校图书馆啥都有，就是无从下手，后来有高人指导之后，进步就很快了。</p><p>精研某一个方向，或者走全栈路线，都是可以的，两种路线各有优缺点，如果非要整个争个高下，我觉得没有必要。</p><p>自己喜欢的，才是最好的，我读书的时候就接过几百块钱的小活，没几个钱，要是跟人合作更没有赚头了，所以后来我一直在尝试全栈的路线，也一直在这条路上努力。</p><p>专精于某一方面，成为某一个领域的执牛耳者，也是让人钦佩了。</p><p>结合我自己的经验，我整理了一份 Java 全栈工程师进阶路线图，给大家参考。我整理出来的大部分知识点都有相关的学习资源，大家在公众号后台回复相应的口令就可以获取相关资源（<a href="https://mp.weixin.qq.com/s/yOVbTBVk4CJy6a0lrKjLXA" target="_blank" rel="noopener">学习资源口令</a>）。</p><p>希望大家明白，如果你是在校学生，有大把时间，个人觉得这些东西可以挨个去学，如果你已经工作了，可以根据公司的业务需求有针对性的去学习，<strong>下面的列表仅仅起一个参考的作用</strong>，当你想学的时候，知道有哪些东西需要学习。</p><h2 id="乾坤大挪移第一层"><a href="#乾坤大挪移第一层" class="headerlink" title="乾坤大挪移第一层"></a>乾坤大挪移第一层</h2><p>第一层心法，主要都是基本语法，程序设计入门，悟性高者十天半月可成，差一点的 3 到 6 个月也说不准。如果有其他开发语言的功底相助，并且有张无忌的悟性与运气，相信第一层只在片刻之间就练成了。</p><p>第一层主要包括如下部分（已经列好顺序）：</p><ol><li>Java 基础语法</li><li>Java 面向对象</li><li>Java 常用类详解</li><li>Java 异常机制</li><li>Java 集合与数据结构</li><li>Java IO</li><li>Java 多线程</li><li>Java 网络编程</li><li>Java 注解+反射</li><li>23 种设计模式</li><li>正则表达式</li><li>XML 解析/ JSON 解析</li><li>Java 10、11、12 新特性</li><li>AIO、BIO、NIO</li></ol><h2 id="乾坤大挪移第二层"><a href="#乾坤大挪移第二层" class="headerlink" title="乾坤大挪移第二层"></a>乾坤大挪移第二层</h2><p>第二层主要是修炼数据库，从基本用法到查询优化、读写分离等等都需要掌握，这里以 MySQL 数据库为例：</p><ol><li>数据库的基本概念</li><li>数据库和表的基本操作</li><li>索引与数据完整性约束</li><li>数据库中的各种复杂查询操作</li><li>MySQL 中常见函数的使用</li><li>存储过程、触发器以及事件等</li><li>数据库的备份与恢复</li><li>数据库用户管理与数据库安全性</li><li>事务和多用户</li><li>读写分离环境搭建+实践</li><li>JDBC</li><li>常见数据库连接池的配置+使用</li></ol><h2 id="乾坤大挪移第三层"><a href="#乾坤大挪移第三层" class="headerlink" title="乾坤大挪移第三层"></a>乾坤大挪移第三层</h2><p>第三层主要是修炼 Web 基础，主要包括前端的基础知识，先不用深入学习前端，后端的 Jsp/Servlet，有人会说现在公司都不用 Jsp/Servlet 了，还学这些干嘛？但是万变不离其宗，哪个顶尖高手不是从扎马步开始的？这些掌握好了，框架的原理才好理解。</p><ol><li>HTML</li><li>CSS</li><li>JavaScript</li><li>jQuery</li><li>Tomcat</li><li>Servlet（基本用法，Session、Cookie 等）</li><li>Jsp（原理、九大内置对象等）</li><li>EL 和 JSTL</li><li>过滤器/监听器等</li><li>Ajax</li><li>EasyUI</li><li>ECharts</li><li>BootStrap</li><li>Git/Svn</li><li>WebSocket</li></ol><p>前三层练好后，做个大学的毕设应该是够用了。</p><h2 id="乾坤大挪移第四层"><a href="#乾坤大挪移第四层" class="headerlink" title="乾坤大挪移第四层"></a>乾坤大挪移第四层</h2><p>第四层主要是修炼各种框架以及工具：</p><ol><li>Spring</li><li>SpringMVC</li><li>MyBatis</li><li>Maven/Gradle</li><li>Freemarker/Thymeleaf</li><li>Linux</li><li>ActiveMQ/RabbitMQ</li><li>Netty</li><li>Zookeeper</li><li>Dubbo</li><li>Redis</li><li>RBAC</li><li>Shiro</li><li>Elasticsearch</li><li>Nginx</li><li>SSO</li><li>Activiti</li><li>Quartz</li><li>Spring Batch</li><li>MongoDB</li><li>Spring Cache</li><li>Jpa</li></ol><p>这一层修炼完，你已经基本上达到了阳顶天的水平了，阳顶天是明教教主，那你出去找个项目经理的位置坐坐估计差不多吧。</p><h2 id="乾坤大挪移第五层"><a href="#乾坤大挪移第五层" class="headerlink" title="乾坤大挪移第五层"></a>乾坤大挪移第五层</h2><p>最后还不得不说 Java 目前最火的微服务，这也是一项必备技能：</p><ol><li>Spring Boot 基本原理</li><li>Spring Boot 基础配置</li><li>Spring Boot 整理视图层技术</li><li>Spring Boot 整合 Web 开发</li><li>Spring Boot 整合持久层技术</li><li>Spring Boot 整合 NoSQL</li><li>Spring Boot 构建 RESTful 服务</li><li>Spring Boot 整合各种缓存</li><li>Spring Boot 安全管理</li><li>Spring Boot 整合 WebSocket</li><li>Spring Boot 整合消息服务</li><li>Spring Boot 整合 Swagger、邮件等</li><li>Spring Boot 应用监控</li><li>Spring Cloud Eureka、Consul</li><li>微服务注册与消费</li><li>Spring Cloud OpenFeign</li><li>服务容错保护 Resilience4j</li><li>Spring Cloud Zuul/Gateway</li><li>Spring Cloud Config</li><li>Spring Cloud Bus</li><li>Spring Cloud Stream</li><li>Spring Cloud Sleuth/Zipkin</li><li>Spring Cloud Admin</li><li>Spring Cloud Alibaba</li></ol><p>第五层修炼成功后，让老板加波薪水应该是可以的吧！</p><h2 id="乾坤大挪移第六层"><a href="#乾坤大挪移第六层" class="headerlink" title="乾坤大挪移第六层"></a>乾坤大挪移第六层</h2><p>第六层主要是修炼前端，前端这几年发展的非常快，早已经不是画页面了，JavaScript 被玩的越来越溜了，所以前端不可小觑：</p><ol><li>HTML5 新特性</li><li>CSS3</li><li>ES6</li><li>JS 模块化</li><li>less</li><li>NodeJS</li><li>Webpack</li><li>Grunt</li><li>Gulp</li><li>Zepto</li><li>mpvue</li><li>AngularJS/Vue/React（非专业前端建议修炼其中一个即可）</li></ol><p>据说乾坤大挪移的作者也只修炼到这一层。</p><p>练习到这一层，基本上前后端通杀，做个架构师，或者独立接私活妥妥的了。</p><h2 id="乾坤大挪移第七层"><a href="#乾坤大挪移第七层" class="headerlink" title="乾坤大挪移第七层"></a>乾坤大挪移第七层</h2><p>本层主要修炼：</p><ul><li>《养发护发指南》</li><li>《颈椎病康复指南》</li><li>《腰椎间盘突出康复指南》</li><li>…..</li></ul><p>祝大家早日习得盖世神功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;技术更新日新月异，对于初入职场的同学来说，经常会困惑该往那个方向发展，这一点松哥是深有体会的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库如何实现主键全局自增？</title>
    <link href="http://www.javaboy.org/2019/0712/mycat-id-autoincrement.html"/>
    <id>http://www.javaboy.org/2019/0712/mycat-id-autoincrement.html</id>
    <published>2019-07-12T04:55:28.000Z</published>
    <updated>2019-07-12T04:57:50.308Z</updated>
    
    <content type="html"><![CDATA[<p>前面和大家介绍了 MyCat 中数据库不同的分片规则，从留言中看出大家对分布式数据库中间件还挺感兴趣，因此今天就再来一篇，聊一聊主键全局自增要如何实现。</p><a id="more"></a><p>关于数据库分库分表的问题，我们前面还有几篇铺垫的文章，阅读前面的文章有助于更好的理解本文：</p><hr><ol><li><a href="https://mp.weixin.qq.com/s/_lsNyXHrsu131mHONQi5rg" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(一)</a></li><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li><li><a href="https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ" target="_blank" rel="noopener">What？Tomcat 竟然也算中间件？</a></li><li><a href="https://mp.weixin.qq.com/s/qWf5XZzhgpSuIGpE2T6iJg" target="_blank" rel="noopener">分布式数据库中间件 MyCat 搞起来！</a></li><li><a href="https://mp.weixin.qq.com/s/4DvKAKiG2sFe_vEQ0mUkeQ" target="_blank" rel="noopener">数据库分库分表，分片配置轻松入门！</a></li></ol><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>主键自增这应该算是一个非常常见的需求，在单机数据库中，这个需求一个 <code>auto_increment</code> 就能实现，但是在数据库集群中，这个需求却变复杂了，因为存在多个数据库实例 ，各自都是主键自增，合在一起就不是主键自增了。</p><h1 id="最简单的思路"><a href="#最简单的思路" class="headerlink" title="最简单的思路"></a>最简单的思路</h1><p>最简单的办法莫过于通过设置主键自增的步长和起始偏移量来处理这个问题。默认情况下，主键自增步长为 1 ，如果我们有三个数据库实例，我们可以将主键自增步长设置为 3 ，这样对于第一个数据库实例而言，主键自增就是 1、4、7、10…，对于第二个数据库实例而言，主键自增就是 2、5、8、11…，对于第三个数据库实例而言，主键自增就是 3、6、9、12….。</p><p>MSSQL 可以直接在 SQL 中指定主键的自增步长和起始偏移量，但是 MySQL 则需要修改数据库配置才能实现，因此这里不推荐使用这种方式。</p><h1 id="MyCat-的办法"><a href="#MyCat-的办法" class="headerlink" title="MyCat 的办法"></a>MyCat 的办法</h1><p>MyCat 作为一个分布式数据库中间，屏蔽了数据库集群的操作，让我们操作数据库集群就像操作单机版数据库一样，对于主键自增，它有自己的方案：</p><ol><li>通过本地文件实现</li><li>通过数据库实现</li><li>通过本地时间戳实现</li><li>通过分布式 ZK ID 生成器实现</li><li>通过 ZK 递增方式实现</li></ol><p>今天我们就先来看看看如何通过 ZK 递增的方式实现主键全局自增。</p><p>配置步骤如下：</p><ul><li>首先修改主键自增方式为 4 ，4 表示使用 zookeeper 实现主键自增。</li></ul><p>server.xml</p><p><img src="http://www.javaboy.org/images/mysql/9-1.png" alt></p><ul><li>配置表自增，并且设置主键</li></ul><p>schema.xml</p><p><img src="http://www.javaboy.org/images/mysql/9-2.png" alt></p><p>设置主键自增，并且设置主键为 id 。</p><ul><li>配置 zookeeper 的信息</li></ul><p>在 myid.properties 中配置 zookeeper 信息：</p><p><img src="http://www.javaboy.org/images/mysql/9-3.png" alt></p><ul><li>配置要自增的表</li></ul><p>sequence_conf.properties</p><p><img src="http://www.javaboy.org/images/mysql/9-4.png" alt></p><p>注意，这里表名字要大写。</p><ol><li>TABLE.MINID 某线程当前区间内最小值</li><li>TABLE.MAXID 某线程当前区间内最大值</li><li>TABLE.CURID 某线程当前区间内当前值</li><li>文件配置的MAXID以及MINID决定每次取得区间，这个对于每个线程或者进程都有效</li><li>文件中的这三个属性配置只对第一个进程的第一个线程有效，其他线程和进程会动态读取 ZK</li></ol><ul><li>重启 MyCat 测试</li></ul><p>最后重启 MyCat ，删掉之前创建的表，然后创建新表进行测试即可。</p><p>好了，本文主要向大家介绍了 MyCat 实现主键全局自增的方案。不知道大家有没有 GET 到呢？有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和大家介绍了 MyCat 中数据库不同的分片规则，从留言中看出大家对分布式数据库中间件还挺感兴趣，因此今天就再来一篇，聊一聊主键全局自增要如何实现。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MyCat" scheme="http://www.javaboy.org/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>数据库分库分表，都有哪些分片规则？</title>
    <link href="http://www.javaboy.org/2019/0712/mycat-rule.html"/>
    <id>http://www.javaboy.org/2019/0712/mycat-rule.html</id>
    <published>2019-07-12T04:50:12.000Z</published>
    <updated>2019-07-12T04:58:05.877Z</updated>
    
    <content type="html"><![CDATA[<p>上次和大伙聊了 MyCat 的安装，今天来说一个新的话题，就是数据库的分片。</p><a id="more"></a><p>当我们把 MyCat + MySQL 的架构搭建完成之后，接下来面临的一个问题就是，数据库的分片规则：有那么多 MySQL ，一条记录通过 MyCat 到底要插入到哪个 MySQL 中？这就是我们今天要讨论的问题。</p><p>关于数据库分库分表的问题，我们前面还有几篇铺垫的文章，阅读前面的文章有助于更好的理解本文：</p><hr><ol><li><a href="https://mp.weixin.qq.com/s/_lsNyXHrsu131mHONQi5rg" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(一)</a></li><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li><li><a href="https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ" target="_blank" rel="noopener">What？Tomcat 竟然也算中间件？</a></li><li><a href="https://mp.weixin.qq.com/s/qWf5XZzhgpSuIGpE2T6iJg" target="_blank" rel="noopener">分布式数据库中间件 MyCat 搞起来！</a></li></ol><hr><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="逻辑库"><a href="#逻辑库" class="headerlink" title="逻辑库"></a>逻辑库</h2><p>一般来说，对于应用而言，数据库中间件是透明的，应用并不需要去了解中间件复杂的运作过程，中间件对应用来说就是透明的，我们操作中间件就像操作一个普通的 MySQL 一样，这就是 MyCat 的优势之一。</p><p>但是我们毕竟操作的不是 MySQL ，而是 MyCat ，MyCat 中的数据库并不真正存储数据，数据还是存储在 MySQL 中，因此，我们可以将 MyCat 看作是一个或者多个数据库集群构成的逻辑库。</p><p><img src="http://www.javaboy.org/images/mysql/6-2.png" alt></p><h2 id="逻辑表"><a href="#逻辑表" class="headerlink" title="逻辑表"></a>逻辑表</h2><p>逻辑表又有几种不同的划分：</p><ul><li>逻辑表</li></ul><p>既然有逻辑库，那么就会有逻辑表。</p><p>因为数据库分片之后，本来存储在一张表中的数据现在被分散到 N 张表中去了，但是在应用程序眼里，还是只有一张表，它也只操作这一张表，这张表并不真正存储数据，数据存储在 N 张物理表中，这个并不真正存储数据的表称之为逻辑表。</p><ul><li>分片表</li></ul><p>分片表，是指那些原有的很大数据的表，需要切分到多个数据库的表，这样，每个分片都有一部分数据，所有分片构成了完整的数据。 </p><ul><li>非分片表</li></ul><p>一个数据库中并不是所有的表都很大，某些表是可以不用进行切分的，非分片是相对分片表来说的，就是那些不需要进行数据切分的表。</p><ul><li>ER 表</li></ul><p>关系型数据库是基于实体关系模型之上，通过其描述了真实世界中事物与关系，Mycat 中的 ER 表即是来源于此。根据这一思路，提出了基于 E-R 关系的数据分片策略，子表的记录与所关联的父表记录存放在同一个数据分片上，即子表依赖于父表，通过表分组保证数据 join 不会跨库操作。</p><p>表分组是解决跨分片数据 join 的一种很好的思路，也是数据切分规划的重要一条规则。</p><ul><li>全局表</li></ul><p>一个真实的业务系统中，往往存在大量的类似字典表的表，这些表基本上很少变动，字典表具有以下几个特性：</p><ul><li>变动不频繁 </li><li>数据量总体变化不大 </li><li>数据规模不大，很少有超过数十万条记录</li></ul><p>对于这类的表，在分片的情况下，当业务表因为规模而进行分片以后，业务表与这些附属的字典表之间的关联，就成了比较棘手的问题，所以 MyCat 中通过数据冗余来解决这类表的 join ，即所有的分片都有一份数据的拷贝，所有将字典表或者符合字典表特性的一些表定义为全局表。</p><p>数据冗余是解决跨分片数据 join 的一种很好的思路，也是数据切分规划的另外一条重要规则。</p><h2 id="分片节点"><a href="#分片节点" class="headerlink" title="分片节点"></a>分片节点</h2><p>数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点（dataNode）。 </p><h2 id="节点主机"><a href="#节点主机" class="headerlink" title="节点主机"></a>节点主机</h2><p>数据切分后，每个分片节点（dataNode）不一定都会独占一台机器，同一机器上面可以有多个分片数据库，这样一个或多个分片节点（dataNode）所在的机器就是节点主机（dataHost）,为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（dataNode）均衡的放在不同的节点主机（dataHost）。 </p><h2 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h2><p>前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难度。 </p><p>MyCat 提供的分片规则有如下几种：</p><ul><li>分片枚举</li><li>固定分片 hash 算法</li><li>范围约定</li><li>取模</li><li>按日期（天）分片</li><li>取模范围约束</li><li>截取数字做 hash 求模范围约束</li><li>应用指定</li><li>截取数字 hash 解析</li><li>一致性 hash</li><li>按单月小时拆分</li><li>范围求模分片</li><li>日期范围 hash 分片</li><li>冷热数据分片</li><li>自然月分片</li></ul><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>这里向大家简单介绍 5 种规则。</p><h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>有一些表，数据量不大，也不怎么修改，主要是查询操作，例如系统配置表，这一类表我们可以使用 global 这种分片规则。global 的特点是，该表会在所有的库中都创建，而且每一个库中都保存了该表的完整数据。具体配置方式，就是在 schema.xml 的 table 节点中添加一个 type 属性，值为 global：</p><p><img src="http://www.javaboy.org/images/mysql/8-1.png" alt></p><p>配置完成后，重启 mycat</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mycat restart</span><br></pre></td></tr></table></figure><p>重启完成后，要删除之前已经创建的 <code>t_user</code> 表，然后重新创建表，创建完成后，向表中插入数据，可以看到，db1、db2 以及 db3 中都有数据了。</p><p><img src="http://www.javaboy.org/images/mysql/8-2.png" alt></p><p>这里 虽然查询出来的记录只有一条，实际上 db1、db2 以及 db3 中都有该条记录。</p><p>总结：global 适合于 数据量不大、以查询为主、增删改较少的表。</p><h2 id="sharding-by-intfile"><a href="#sharding-by-intfile" class="headerlink" title="sharding-by-intfile"></a>sharding-by-intfile</h2><p>sharding-by-intfile 这个是枚举分片，就是在数据表中专门设计一个字段，以后根据这个字段的值来决定数据插入到哪个 dataNode 上。</p><p>注意，在配置 sharding-by-intfile 规则时，一定要删除 type=”global” ，否则配置不会生效。具体配置如下：</p><p><img src="http://www.javaboy.org/images/mysql/8-3.png" alt></p><p>配置完成后，还需要指定枚举的数据。枚举的数据可以在 rule.xml　中查看。</p><p><img src="http://www.javaboy.org/images/mysql/8-4.png" alt></p><p>在 rule.xml 文件中，首先找到 tableRule 的名字为 sharding-by-intfile 的节点，这个节点中定义了两个属性，一个是 columns 表示一会在数据表中定义的枚举列的名字（数据表中一会需要创建一个名为 sharding_id 的列，这个列的值决定了该条数据保存在哪个数据库实例中），这个名字可以自定义；另外一个属性叫做 algorithm ，这是指 sharding-by-intfile 所对应的算法名称。根据这个名称，可以找到具体的算法：</p><p><img src="http://www.javaboy.org/images/mysql/8-5.png" alt></p><p>还是在 rule.xml 文件中，我们找到了 hash-int ，class 表示这个算法对应的 Java 类的路径。第一个属性 mapFile 表示相关的配置文件，从这个文件名可以看出，这个文件 就在 conf 目录下。</p><p>打开 conf 目录下的 partition-hash-int.txt 文件，内容如下：</p><p><img src="http://www.javaboy.org/images/mysql/8-6.png" alt></p><p>前面的数字表示枚举的值 ，后面的数字表示 dataNode 的下标，所以前面的数字可以自定义，后面的数字不能随意定义。</p><p>配置完成后，重启 MyCat ，然后进行测试：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_user (id integer primary key,username varchar(255),sharding_id integer);</span><br><span class="line">insert into t_user(id,username,sharding_id) values(1,&apos;www.javaboy.org&apos;,0);</span><br><span class="line">insert into t_user(id,username,sharding_id) values(1,&apos;www.javaboy.org&apos;,1);</span><br><span class="line">insert into t_user(id,username,sharding_id) values(1,&apos;www.javaboy.org&apos;,2);</span><br><span class="line">select  * from t_user;</span><br></pre></td></tr></table></figure><p>执行完后，sharding_id 对应值分别为 0 、1 、2 的记录分别插入到 db1 、db2 以及 db3 中。</p><h2 id="auto-sharding-long"><a href="#auto-sharding-long" class="headerlink" title="auto-sharding-long"></a>auto-sharding-long</h2><p>auto-sharding-long 表示按照既定的范围去存储数据。就是提前规划好某个字段的值在某个范围时，相应的记录存到某个 dataNode 中。</p><p>配置方式，首先修改路由规则：</p><p><img src="http://www.javaboy.org/images/mysql/8-7.png" alt></p><p>然后去 rule.xml 中查看对应的算法了规则相关的配置：</p><p><img src="http://www.javaboy.org/images/mysql/8-8.png" alt></p><p>可以看到，默认是按照 id 的范围来划分数据的存储位置的，对应的算法就是 rang-long 。</p><p>继续查看，可以找到算法对应的类，以及相关的配置文件，这个配置文件也在 conf 目录下，打开该文件：</p><p><img src="http://www.javaboy.org/images/mysql/8-9.png" alt></p><p>如上配置，表示 当 id 的取值在 0-5之间时，将数据存储到 db1 中，当 id 在 5-10 之间时，存储到 db2 中，当 id 的取值在 10-1500W 之间时，存储到 db3 中。</p><p>配置完成后，重启 MyCat ，测试：</p><p><img src="http://www.javaboy.org/images/mysql/8-10.png" alt></p><h2 id="mod-long"><a href="#mod-long" class="headerlink" title="mod-long"></a>mod-long</h2><p>取模：根据表中的某一个字段，做取模操作。根据取模的结果将记录存放在不同的 dataNode 上。这种方式不需要再添加额外字段。</p><p><img src="http://www.javaboy.org/images/mysql/8-11.png" alt></p><p>然后去 rule.xml 中配置一下 dataNode 的个数。</p><p><img src="http://www.javaboy.org/images/mysql/8-12.png" alt></p><p>可以看到，取模的字段是 id ，取模的算法名称是 mod-long ，再看具体的算法：</p><p><img src="http://www.javaboy.org/images/mysql/8-13.png" alt></p><p>在具体的算法中，配置了 dataNode 的个数为 3。</p><p>然后保存退出，重启 MyCat，进行测试：</p><p><img src="http://www.javaboy.org/images/mysql/8-14.png" alt></p><h2 id="sharding-by-murmur"><a href="#sharding-by-murmur" class="headerlink" title="sharding-by-murmur"></a>sharding-by-murmur</h2><p>前面介绍的几种方式，都存在一个问题，如果数据库要扩容，之前配置会失效，可能会出现数据库查询紊乱。因此我们要引入一致性 hash 这样一种分片规则，可以解决这个问题。具体配置和前面一样：</p><p><img src="http://www.javaboy.org/images/mysql/8-15.png" alt></p><p>另外需要注意，在 rule.xml 中修改默认 dataNode 的数量：</p><p><img src="http://www.javaboy.org/images/mysql/8-16.png" alt></p><p>修改完后，重启 MyCat ，进行测试。</p><p>好了，本文主要向大家介绍了 MyCat 的五种不同的切片规则。有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li><a href="http://www.mycat.io/" target="_blank" rel="noopener">MyCat 官网</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次和大伙聊了 MyCat 的安装，今天来说一个新的话题，就是数据库的分片。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MyCat" scheme="http://www.javaboy.org/tags/MyCat/"/>
    
  </entry>
  
  <entry>
    <title>公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</title>
    <link href="http://www.javaboy.org/2019/0710/vhr.html"/>
    <id>http://www.javaboy.org/2019/0710/vhr.html</id>
    <published>2019-07-10T01:43:19.000Z</published>
    <updated>2019-07-10T01:48:44.082Z</updated>
    
    <content type="html"><![CDATA[<p>公司倒闭 1 年多了，而我在公司倒闭时候做的开源项目，最近却上了 GitHub Trending，看着这个数据，真是不胜唏嘘。</p><a id="more"></a><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>2017 年 11 月份的时候，松哥所在的公司因为经营不善要关门了，关门的是深圳分公司，北京总部还在正常运转。</p><p>然后就是北京那边来人，和深圳的员工挨个谈话，谈裁员和赔偿，公司制度还算完善，都按照劳动合同法走，有的同事担心公司最后不按劳动合同法走，因此觉得先拿钱先走比价划算。我当时主要考虑到两个原因，并不着急走：</p><ol><li>公司毕竟是香港上市公司，跑的了和尚跑不了庙，深圳关门了，北京那边还在运转，所以我不太担心公司赖账的事。</li><li>年底工作不好找，11 月拿赔偿走人，还有俩月才过年，这个时候不太容易拿到满意的 offer，很多公司年底都关闭 HC 了。</li></ol><p>基于上面两点考虑，我当时并不急着走人，当公司说还需要有人留下来善后一直到 2018 年 1 月 31 号的时候，我就争取了下，然后就给留下来了。</p><p>留下来后并没有太多事情要做。划水划了一周，同事在楼下叫我：“老王下来聊天”，于是下楼跟他们吹吹牛，虽然吹牛，不过大多数时候还是在筹划来年找工作的事，不过我觉得这样没什么用，与其天天规划，不如来点实实在在的东西，为来年找工作积累一点筹码。</p><h1 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h1><p>心里想着手上就开始行动了，技术栈就选择当时最流行的 Spring Boot + Vue 前后端分离，业务就打算先做一个简单的博客试试水，博客的业务比较简单，做起来快，于是，V部落项目就诞生了：</p><p><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a></p><p>一个简单的博客后台管理，集成了博客编辑、发表、排版引入了 md 编辑器，博客的分类展示等，记得不到一周时间就弄完了，毕竟还是非常容易的。</p><p><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目发布后，我认认真真的写了一个介绍的 README，README 和我以前的开源项目一样，就是展示了一下项目的效果图，然后说了下要如何部署运行就完了。虽然自我感觉良好，但是并没有引起太多人关注。</p><p>在为数不多的几个关注中，我发现小伙伴在运行项目时候总是会遇到各种各样的问题，很多人多前后端分离的这种开发方式非常陌生，很多后端工程师甚至不懂，没听说过前端工程化，很多小伙伴在 GitHub 上提了很多非常简单的 issue，他们在部署<a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目时老是出错。</p><p>另一方面，由于博客项目比较简单，Vue 中很多高级功能没用上，例如状态管理，还有前后端分离时的动态权限管理，这些都没有体现出来。再加上当时才是 12 月，离过年还早着，我心想着再做一个业务复杂点的，然后把这些之前没用到的技能点都给用上。于是就有了<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>项目，这也是我们今天的主角，上了 6 月份 GitHub Trending。</p><h1 id="微人事"><a href="#微人事" class="headerlink" title="微人事"></a>微人事</h1><p>微人事项目，我就吸取 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>的经验，没有等项目完全发布后再上传到 GitHub 上，而是边做变更新，每做完一个功能，就写一个文档，把实现的思路，代码的原理等都记录下来，然后在打一个 tag ，发布到 GitHub 上，这样，即使是一些新手，跟着文档，也能完全做出来。</p><p>这是当时的一些提交记录：</p><p><img src="http://www.javaboy.org/images/other/51-1.png" alt></p><p>基本上每隔一两天就能完成一个新功能，然后就提交一次，这样的更新频率一直持续到 2018 年 1 月 20 之前，1 月 21 号女票从昆士兰大学访学回来，陪她在深圳玩了几天，然后把女票送回家，耽搁了好几天没更新。</p><p>到了 1 月 31 号，公司正式关门，我也就回家了，先去了女票家，在她家里呆了十多天，顺便完成了用 WebSocket 实现在线聊天的功能，提交了两个版本。</p><p>下面这两个是在女票家里提交的：</p><p><img src="http://www.javaboy.org/images/other/51-3.png" alt></p><p>这两次提交之后，差不多就回家过年了，我家在岭上没有网，因此过年期间就没再继续做这个项目了，年后从家里到深圳的当天就拿到 offer 了，上班后就比较忙了，这个项目也就更新的慢了，没有再提交比较大的版本了，主要是一些修修补补的操作。</p><h1 id="ALL-IN"><a href="#ALL-IN" class="headerlink" title="ALL IN"></a>ALL IN</h1><p>现在不是流行一个词叫做 <code>all in</code> ，用来形容我当时的状态再贴切不过了。</p><p><strong>兴趣来了，谁都拦不住</strong>。那一段时间晚上经常在家里搞到一两点，第二天正常上班。记得那一年平安夜那天是周日，我早上依然按时起床去了公司，因为当天我的 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目就要收尾了，在公司里搞到晚上 9 点多，终于弄完了，第二天就可以发布了。然后收拾东西，骑着摩拜从科兴科学园那里出发，先走北环大道，然后再下到大沙河边上，沿着大沙河骑到西丽大学城，因为是平安夜，一路上都没什么行人，到家后还没吃饭，去楼下的餐厅随便吃点，店主一家人正在准备他们的平安夜饭，见有客人，抽出一个人给我弄了一碗面，然后我就独自边玩手机边吃饭，他们一家人围在旁边的桌子上吃他们的平安夜饭，这种感觉很奇怪，孤独又充实。</p><p>吃完回到宿舍，和女票视频，心理盘算着女票再过 20 多天就从昆士兰回来了，慢慢就睡着了，第二天到公司，我的 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目就正式上线了。</p><p><strong>当你沉迷于一件事情的时候，效率非常高。</strong></p><p>那段时间，我每天骑车上下班，一边骑着自行车，心里就在想着这个功能要怎么做更好，那个功能得怎么样实现，一路上就这样不断的规划着，到了公司，放下书包，就赶紧打开电脑挨个试验路上的各种想法，做出来了就很开心，在已经没有几个人的公司走走转转休息下，然后继续坐下 coding。</p><p>有一个周末去公司做这两个开源项目的时候，中午去吃饭，两只狗懒洋洋的躺在马路中间晒太阳，我甚至有点羡慕(下图拍摄于南山科兴科学园附近，我吃饭喜欢走远一点，多溜达溜达，不知不觉就溜达到工地了，见到这么惬意一幕，冬天的太阳，真的舒服)。</p><p><img src="http://www.javaboy.org/images/other/51-4.jpeg" alt></p><p>项目在 GitHub 上开源之后，有好几位小伙伴发邮件希望能在毕设中引用这个项目，记得有一位是国内高校 top20 的研究生，我当时又诧异又激动。后来也有好几个小伙伴加松哥微信表示想将这个项目作为脚手架用在公司的项目中，虽然没能亲眼见见小伙伴的项目，但是想到自己的项目帮到了这么多人，还是挺开心的。</p><p>这两个开源项目也带给我不少收获，技术上的提升+认识很多优秀的小伙伴，并且因此还出了一本书，也算是收获满满吧。</p><h1 id="上榜"><a href="#上榜" class="headerlink" title="上榜"></a>上榜</h1><p>前两天有个小伙伴发消息说是看到我的项目出现 GitHub Trending 上了，我点开看了下，果然是的。</p><p>我是在 2013 年 11 月份注册的 GitHub，但是很长一段时间都没啥活动，后来也断断续续做过几个开源项目，但是都没啥动静，我总结其中一个原因可能也是因为我没好好对待项目，README 只是随便写写，读者一般很难上手项目，从<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>开始，我懂得了，你想要让别人重视你的项目，你首先得自己重视自己的项目。</p><p>这里再向大家安利一波这个开源项目<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>，这是一个使用了 Spring Boot + Vue 开发的前后端分离的人力资源管理系统，有一个非常完整的文档：</p><p><img src="http://www.javaboy.org/images/other/51-2.png" alt></p><p>项目地址：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></p><p>欢迎大家点击阅读原文查看本项目。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>另外再给大家一个小小建议，如果你是初次接触前后端分离，可以先看 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>项目，这个项目不论从技术点还是业务上来说，都要比<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>简单， <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>搞懂之后，再来学习<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>就会容易很多了。</p><p>如果你只是刚刚接触 Java，那么松哥也有一个前后端不分开源项目可以给你练手：</p><ul><li><a href="https://github.com/lenve/CoolMeeting" target="_blank" rel="noopener">https://github.com/lenve/CoolMeeting</a></li></ul><p>这个项目做的比较早，功能做的相对较全，但是介绍文档没有<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>那么详细，大家可以参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司倒闭 1 年多了，而我在公司倒闭时候做的开源项目，最近却上了 GitHub Trending，看着这个数据，真是不胜唏嘘。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.javaboy.org/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.javaboy.org/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用 Java 发送邮件，不用框架！</title>
    <link href="http://www.javaboy.org/2019/0709/java-mail.html"/>
    <id>http://www.javaboy.org/2019/0709/java-mail.html</id>
    <published>2019-07-09T08:02:43.000Z</published>
    <updated>2019-07-09T08:07:33.550Z</updated>
    
    <content type="html"><![CDATA[<p>邮件发送也是一个老生常谈的问题了，代码虽然简单，但是许多小伙伴对过程不太理解，所以还是打算和各位小伙伴聊聊这个话题。  </p><a id="more"></a><h1 id="邮件协议"><a href="#邮件协议" class="headerlink" title="邮件协议"></a>邮件协议</h1><p>我们经常会听到各种各样的邮件协议，比如 SMTP、POP3、IMAP ，那么这些协议有什么作用，有什么区别？我们先来讨论一下这个问题。  </p><p>SMTP 是一个基于 TCP/IP 的应用层协议，江湖地位有点类似于 HTTP，SMTP 服务器默认监听的端口号为 25 。看到这里，小伙伴们可能会想到既然 SMTP 协议是基于 TCP/IP 的应用层协议，那么我是不是也可以通过 Socket 发送一封邮件呢？回答是肯定的。  </p><p>生活中我们投递一封邮件要经过如下几个步骤：  </p><ol><li>深圳的小王先将邮件投递到深圳的邮局  </li><li>深圳的邮局将邮件运送到上海的邮局  </li><li>上海的小张来邮局取邮件   </li></ol><p>这是一个缩减版的生活中邮件发送过程。这三个步骤可以分别对应我们的邮件发送过程，假设从 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 发送邮件到 <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> ：  </p><ol><li><a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 先将邮件投递到腾讯的邮件服务器  </li><li>腾讯的邮件服务器将我们的邮件投递到网易的邮件服务器  </li><li><a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 登录网易的邮件服务器查看邮件  </li></ol><p>邮件投递大致就是这个过程，这个过程就涉及到了多个协议，我们来分别看一下。  </p><p>SMTP 协议全称为 Simple Mail Transfer Protocol，译作简单邮件传输协议，它定义了邮件客户端软件于 SMTP 服务器之间，以及 SMTP 服务器与 SMTP 服务器之间的通信规则。</p><p>也就是说 <a href="mailto:aaa@qq.com" target="_blank" rel="noopener">aaa@qq.com</a> 用户先将邮件投递到腾讯的 SMTP 服务器这个过程就使用了 SMTP 协议，然后腾讯的 SMTP 服务器将邮件投递到网易的 SMTP 服务器这个过程也依然使用了 SMTP 协议，SMTP 服务器就是用来收邮件。</p><p>而 POP3 协议全称为 Post Office Protocol ，译作邮局协议，它定义了邮件客户端与 POP3 服务器之间的通信规则，那么该协议在什么场景下会用到呢？当邮件到达网易的 SMTP 服务器之后， <a href="mailto:111@163.com" target="_blank" rel="noopener">111@163.com</a> 用户需要登录服务器查看邮件，这个时候就该协议就用上了：邮件服务商都会为每一个用户提供专门的邮件存储空间，SMTP 服务器收到邮件之后，就将邮件保存到相应用户的邮件存储空间中，如果用户要读取邮件，就需要通过邮件服务商的 POP3 邮件服务器来完成。</p><p>最后，可能也有小伙伴们听说过 IMAP 协议，这个协议是对 POP3 协议的扩展，功能更强，作用类似，这里不再赘述。  </p><h1 id="发送QQ邮件准备工作"><a href="#发送QQ邮件准备工作" class="headerlink" title="发送QQ邮件准备工作"></a>发送QQ邮件准备工作</h1><p>首先我们需要先登录 QQ 邮箱网页版，点击上方的设置按钮：  </p><p><img src="http://www.javaboy.org/images/mail/1.jpg" alt="p266">  </p><p>然后点击账户选项卡：  </p><p><img src="http://www.javaboy.org/images/mail/2.jpg" alt="p267">  </p><p>在账户选项卡中找到开启POP3/SMTP选项，如下：  </p><p><img src="http://www.javaboy.org/images/mail/3.jpg" alt="p268">  </p><p>点击开启，开启相关功能，开启过程需要手机号码验证，按照步骤操作即可，不赘述。开启成功之后，即可获取一个授权码，将该号码保存好，一会使用。  </p><p>然后我们需要 JavaxMail 这个 jar 包，小伙伴可以直接去Maven中央仓库下载，这里不再赘述。  </p><h1 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h1><h2 id="简单邮件"><a href="#简单邮件" class="headerlink" title="简单邮件"></a>简单邮件</h2><p>如果我们只发送一个简单的文本，发送方式就比较简单，整个过程可以分为三步如下：  </p><p>第一步：构造 SMTP 邮件服务器的基本环境  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="hljs-keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.host"</span>, <span class="hljs-string">"smtp.qq.com"</span>);</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.transport.protocol"</span>, <span class="hljs-string">"smtp"</span>);</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.smtp.auth"</span>, <span class="hljs-string">"true"</span>);</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.smtp.socketFactory.class"</span>, <span class="hljs-string">"javax.net.ssl.SSLSocketFactory"</span>);</span><br><span class="line">properties.setProperty(<span class="hljs-string">"mail.smtp.port"</span>, <span class="hljs-string">"465"</span>);</span><br><span class="line">Session session = Session.getDefaultInstance(properties);</span><br><span class="line">session.setDebug(<span class="hljs-keyword">true</span>);</span><br></pre></td></tr></table></figure><p>第二步：构造邮件  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MimeMessage mimeMessage = <span class="hljs-keyword">new</span> MimeMessage(session);</span><br><span class="line">mimeMessage.addRecipients(Message.RecipientType.TO, <span class="hljs-string">"111@qq.com"</span>);<span class="hljs-comment">//设置收信人</span></span><br><span class="line">mimeMessage.addRecipients(Message.RecipientType.CC, <span class="hljs-string">"222@qq.com"</span>);<span class="hljs-comment">//抄送</span></span><br><span class="line">mimeMessage.setFrom(<span class="hljs-string">"1510161612@qq.com"</span>);<span class="hljs-comment">//邮件发送人</span></span><br><span class="line">mimeMessage.setSubject(<span class="hljs-string">"测试邮件主题"</span>);<span class="hljs-comment">//邮件主题</span></span><br><span class="line">mimeMessage.setContent(<span class="hljs-string">"Hello,这是一封测试邮件"</span>, <span class="hljs-string">"text/html;charset=utf-8"</span>);<span class="hljs-comment">//正文</span></span><br></pre></td></tr></table></figure><p>第三步：发送邮件  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transport transport = session.getTransport();</span><br><span class="line">transport.connect(<span class="hljs-string">"smtp.qq.com"</span>, <span class="hljs-string">"333@qq.com"</span>, <span class="hljs-string">"刚刚申请到的授权码"</span>);</span><br><span class="line">transport.sendMessage(mimeMessage, mimeMessage.getAllRecipients());<span class="hljs-comment">//发送邮件，第二个参数为收件人</span></span><br><span class="line">transport.close();</span><br></pre></td></tr></table></figure><h2 id="复杂邮件"><a href="#复杂邮件" class="headerlink" title="复杂邮件"></a>复杂邮件</h2><p>发送复杂邮件，第一步和第三步也是一样的，只有第二步构造邮件的过程比较麻烦，那么接下来给小伙伴们演示一个发送一封图文+两个附件的邮件。要发送复杂邮件，得先熟悉三个概念，如下：  </p><ol><li>MimeMessage：该类是个能理解MIME类型和头的电子邮件消息  </li><li>MimeMultipart：该类定义了增加、删除以及获取邮件不同部分内容的方法  </li><li>MimeBodyPart：该对象代表一个MimeMessage对象内容的一部分。每个MimeBodyPart被认为有两部分：MIME类型和匹配这个类型的内容  </li></ol><p>完整的邮件生成过程如下(第一步和第三步参考上文)：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">MimeMessage mimeMessage = <span class="hljs-keyword">new</span> MimeMessage(session);</span><br><span class="line">mimeMessage.addRecipients(Message.RecipientType.TO, <span class="hljs-string">"111@qq.com"</span>);<span class="hljs-comment">//设置收信人</span></span><br><span class="line">mimeMessage.addRecipients(Message.RecipientType.CC, <span class="hljs-string">"222@qq.com"</span>);<span class="hljs-comment">//抄送</span></span><br><span class="line">mimeMessage.setFrom(<span class="hljs-string">"333@qq.com"</span>);<span class="hljs-comment">//邮件发送人</span></span><br><span class="line">mimeMessage.setSubject(<span class="hljs-string">"测试邮件主题"</span>);<span class="hljs-comment">//邮件主题</span></span><br><span class="line"></span><br><span class="line">MimeMultipart mixed = <span class="hljs-keyword">new</span> MimeMultipart(<span class="hljs-string">"mixed"</span>);</span><br><span class="line">mimeMessage.setContent(mixed);<span class="hljs-comment">//设置整封邮件的MIME消息体为混合的组合关系</span></span><br><span class="line"></span><br><span class="line">MimeBodyPart attach1 = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//创建附件1</span></span><br><span class="line">MimeBodyPart attach2 = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//创建附件2</span></span><br><span class="line">MimeBodyPart content = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//创建邮件正文</span></span><br><span class="line"></span><br><span class="line">mixed.addBodyPart(attach1);<span class="hljs-comment">//将附件一添加到MIME消息体中</span></span><br><span class="line">mixed.addBodyPart(attach2);<span class="hljs-comment">//将附件二添加到MIME消息体中</span></span><br><span class="line">mixed.addBodyPart(content);<span class="hljs-comment">//将正文添加到消息体中</span></span><br><span class="line"></span><br><span class="line">FileDataSource fds1 = <span class="hljs-keyword">new</span> FileDataSource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Desktop\\1.png"</span>));<span class="hljs-comment">//构造附件一的数据源</span></span><br><span class="line">DataHandler dh1 = <span class="hljs-keyword">new</span> DataHandler(fds1);<span class="hljs-comment">//数据处理</span></span><br><span class="line">attach1.setDataHandler(dh1);<span class="hljs-comment">//设置附件一的数据源</span></span><br><span class="line">attach1.setFileName(<span class="hljs-string">"1.png"</span>);<span class="hljs-comment">//设置附件一的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//附件二的操作与附件一类似，这里就不一一注释了</span></span><br><span class="line">FileDataSource fds2 = <span class="hljs-keyword">new</span> FileDataSource(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\Users\\sang\\Desktop\\博客笔记.xlsx"</span>));</span><br><span class="line">DataHandler dh2 = <span class="hljs-keyword">new</span> DataHandler(fds2);</span><br><span class="line">attach2.setDataHandler(dh2);</span><br><span class="line">attach2.setFileName(MimeUtility.encodeText(<span class="hljs-string">"博客笔记.xlsx"</span>));<span class="hljs-comment">//设置文件名时，如果有中文，可以通过MimeUtility类中的encodeText方法进行编码，避免乱码</span></span><br><span class="line"></span><br><span class="line">MimeMultipart bodyMimeMultipart = <span class="hljs-keyword">new</span> MimeMultipart(<span class="hljs-string">"related"</span>);<span class="hljs-comment">//设置正文的MIME类型</span></span><br><span class="line">content.setContent(bodyMimeMultipart);<span class="hljs-comment">//将bodyMimeMultipart添加到正文消息体中</span></span><br><span class="line"></span><br><span class="line">MimeBodyPart bodyPart = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//正文的HTML部分</span></span><br><span class="line">bodyPart.setContent(<span class="hljs-string">"&lt;h1&gt;Hello大家好，这是一封测试邮件&lt;img src='cid:2.png'/&gt;&lt;/h1&gt;"</span>,<span class="hljs-string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">MimeBodyPart picPart = <span class="hljs-keyword">new</span> MimeBodyPart();<span class="hljs-comment">//正文的图片部分</span></span><br><span class="line">DataHandler dataHandler = <span class="hljs-keyword">new</span> DataHandler(<span class="hljs-keyword">new</span> FileDataSource(<span class="hljs-string">"C:\\Users\\sang\\Desktop\\2.png"</span>));</span><br><span class="line">picPart.setDataHandler(dataHandler);</span><br><span class="line">picPart.setContentID(<span class="hljs-string">"2.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//将正文的HTML和图片部分分别添加到bodyMimeMultipart中</span></span><br><span class="line">bodyMimeMultipart.addBodyPart(bodyPart);</span><br><span class="line">bodyMimeMultipart.addBodyPart(picPart);</span><br><span class="line"></span><br><span class="line">mimeMessage.saveChanges();</span><br></pre></td></tr></table></figure><p>OK，Java Mail 发送 QQ 邮件就是这么简单，至于其他的如 163，sina 等，写法类似，这里我就不赘述了。  </p><p>有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;邮件发送也是一个老生常谈的问题了，代码虽然简单，但是许多小伙伴对过程不太理解，所以还是打算和各位小伙伴聊聊这个话题。  &lt;/p&gt;
    
    </summary>
    
      <category term="mail" scheme="http://www.javaboy.org/categories/mail/"/>
    
    
      <category term="java" scheme="http://www.javaboy.org/tags/java/"/>
    
      <category term="mail" scheme="http://www.javaboy.org/tags/mail/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 打包成的可执行 jar ，为什么不能被其他项目依赖？</title>
    <link href="http://www.javaboy.org/2019/0709/springboot-jar.html"/>
    <id>http://www.javaboy.org/2019/0709/springboot-jar.html</id>
    <published>2019-07-09T02:19:18.000Z</published>
    <updated>2019-07-09T02:33:37.056Z</updated>
    
    <content type="html"><![CDATA[<p>前两天被人问到这样一个问题:</p><p>“松哥，为什么我的 Spring Boot 项目打包成的 jar ，被其他项目依赖之后，总是报找不到类的错误？”</p><a id="more"></a><p>大伙有这样的疑问，就是因为还没搞清楚可执行 jar 和普通 jar 到底有什么区别？今天松哥就和大家来聊一聊这个问题。</p><h1 id="多了一个插件"><a href="#多了一个插件" class="headerlink" title="多了一个插件"></a>多了一个插件</h1><p>Spring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 <code>java -jar xxx.jar</code> 命令执行，普通的 <code>jar</code> 主要是被其他应用依赖，<code>Spring Boot</code> 打成的 <code>jar</code> 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。</p><p>有的小伙伴可能就有疑问了，既然同样是执行 <code>mvn package</code> 命令进行项目打包，为什么 Spring Boot 项目就打成了可执行 jar ，而普通项目则打包成了不可执行 jar 呢？</p><p>这我们就不得不提 Spring Boot 项目中一个默认的插件配置 <code>spring-boot-maven-plugin</code> ，这个打包插件存在 5 个方面的功能，从插件命令就可以看出：</p><p><img src="http://www.javaboy.org/images/boot/23-1.png" alt></p><p>五个功能分别是：</p><ul><li>build-info：生成项目的构建信息文件 build-info.properties</li><li>repackage：这个是默认 goal，在 <code>mvn package</code> 执行之后，这个命令再次打包生成可执行的 jar，同时将 <code>mvn package</code> 生成的 jar 重命名为 <code>*.origin</code></li><li>run：这个可以用来运行 Spring Boot 应用</li><li>start：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li><li>stop：这个在 <code>mvn integration-test</code> 阶段，进行 <code>Spring Boot</code> 应用生命周期的管理</li></ul><p>这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置。</p><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><p>repackage 功能的 作用，就是在打包的时候，多做一点额外的事情：</p><ol><li>首先 <code>mvn package</code> 命令 对项目进行打包，打成一个 <code>jar</code>，这个 <code>jar</code> 就是一个普通的 <code>jar</code>，可以被其他项目依赖，但是不可以被执行</li><li><code>repackage</code> 命令，对第一步 打包成的 <code>jar</code> 进行再次打包，将之打成一个 可执行 <code>jar</code> ，通过将第一步打成的 <code>jar</code> 重命名为 <code>*.original</code> 文件</li></ol><p>举个例子：</p><p>对任意一个 Spring Boot 项目进行打包，可以执行 <code>mvn package</code> 命令，也可以直接在 <code>IDEA</code> 中点击 <code>package</code> ，如下 ：</p><p><img src="http://www.javaboy.org/images/boot/23-2.png" alt></p><p>打包成功之后， <code>target</code> 中的文件如下：</p><p><img src="http://www.javaboy.org/images/boot/23-3.png" alt></p><p>这里有两个文件，第一个 <code>restful-0.0.1-SNAPSHOT.jar</code> 表示打包成的可执行 <code>jar</code> ，第二个 <code>restful-0.0.1-SNAPSHOT.jar.original</code> 则是在打包过程中 ，被重命名的 <code>jar</code>，这是一个不可执行 <code>jar</code>，但是可以被其他项目依赖的 <code>jar</code>。通过对这两个文件的解压，我们可以看出这两者之间的差异。</p><h1 id="两种-jar-的比较"><a href="#两种-jar-的比较" class="headerlink" title="两种 jar 的比较"></a>两种 jar 的比较</h1><p>可执行 <code>jar</code> 解压之后，目录如下：</p><p><img src="http://www.javaboy.org/images/boot/23-4.png" alt></p><p>可以看到，可执行 jar 中，我们自己的代码是存在 于 <code>BOOT-INF/classes/</code> 目录下，另外，还有一个 <code>META-INF</code> 的目录，该目录下有一个 <code>MANIFEST.MF</code> 文件，打开该文件，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: restful</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Start-Class: org.javaboy.restful.RestfulApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF/classes/</span><br><span class="line">Spring-Boot-Lib: BOOT-INF/lib/</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Spring-Boot-Version: 2.1.6.RELEASE</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure><p>可以看到，这里定义了一个 <code>Start-Class</code>，这就是可执行 <code>jar</code> 的入口类，<code>Spring-Boot-Classes</code> 表示我们自己代码编译后的位置，<code>Spring-Boot-Lib</code> 则表示项目依赖的 <code>jar</code> 的位置。</p><p>换句话说，如果自己要打一个可执行 <code>jar</code> 包的话，除了添加相关依赖之外，还需要配置 <code>META-INF/MANIFEST.MF</code> 文件。</p><p>这是可执行 jar 的结构，那么不可执行 jar 的结构呢？</p><p>我们首先将默认的后缀 <code>.original</code> 除去，然后给文件重命名，重命名完成，进行解压：</p><p><img src="http://www.javaboy.org/images/boot/23-5.png" alt></p><p>解压后可以看到，不可执行 <code>jar</code> 根目录就相当于我们的 <code>classpath</code>，解压之后，直接就能看到我们的代码，它也有 <code>META-INF/MANIFEST.MF</code> 文件，但是文件中没有定义启动类等。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: restful</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>这个不可以执行 <code>jar</code> 也没有将项目的依赖打包进来。</p><p>从这里我们就可以看出，两个 <code>jar</code> ，虽然都是 <code>jar</code> 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。</p><h1 id="一次打包两个-jar"><a href="#一次打包两个-jar" class="headerlink" title="一次打包两个 jar"></a>一次打包两个 jar</h1><p>一般来说，Spring Boot 直接打包成可执行 <code>jar</code> 就可以了，不建议将 Spring Boot 作为普通的 <code>jar</code> 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 <code>Maven</code> 项目，然后在 Spring Boot 中引用这个 <code>Maven</code> 项目。</p><p>如果非要将 Spring Boot 打包成一个普通 <code>jar</code> 被其他项目依赖，技术上来说，也是可以的，给 <code>spring-boot-maven-plugin</code> 插件添加如下配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">classifier</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">classifier</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置的 <code>classifier</code> 表示可执行 <code>jar</code> 的名字，配置了这个之后，在插件执行 <code>repackage</code> 命令时，就不会给 <code>mvn package</code> 所打成的 <code>jar</code> 重命名了，所以，打包后的 jar 如下：</p><p><img src="http://www.javaboy.org/images/boot/23-6.png" alt></p><p>第一个 jar 表示可以被其他项目依赖的 jar ，第二个 jar 则表示一个可执行 jar。</p><p>好了，关于 Spring Boot 中 jar 的问题，我们就说这么多，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天被人问到这样一个问题:&lt;/p&gt;
&lt;p&gt;“松哥，为什么我的 Spring Boot 项目打包成的 jar ，被其他项目依赖之后，总是报找不到类的错误？”&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 整合 Freemarker，50 多行配置是怎么省略掉的？</title>
    <link href="http://www.javaboy.org/2019/0705/springboot-freemarker.html"/>
    <id>http://www.javaboy.org/2019/0705/springboot-freemarker.html</id>
    <published>2019-07-05T04:14:59.000Z</published>
    <updated>2019-07-27T12:59:43.473Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot2 系列教程接近完工，最近进入修修补补阶段。Freemarker 整合貌似还没和大家聊过，因此今天把这个补充上。</p><a id="more"></a><p>已经完工的 Spring Boot2 教程，大家可以参考这里：</p><ol><li><a href="https://mp.weixin.qq.com/s/YXBFFtWvSwR6dVLbaGDxcQ" target="_blank" rel="noopener">干货|最新版 Spring Boot2.1.5 教程+案例合集</a></li></ol><h1 id="Freemarker-简介"><a href="#Freemarker-简介" class="headerlink" title="Freemarker 简介"></a>Freemarker 简介</h1><p>这是一个相当老牌的开源的免费的模版引擎。通过 Freemarker 模版，我们可以将数据渲染成 HTML 网页、电子邮件、配置文件以及源代码等。Freemarker 不是面向最终用户的，而是一个 Java 类库，我们可以将之作为一个普通的组件嵌入到我们的产品中。</p><p>来看一张来自 Freemarker 官网的图片：</p><p><img src="http://www.javaboy.org/images/boot/22-1.png" alt></p><p>可以看到，Freemarker 可以将模版和数据渲染成 HTML 。</p><p>Freemarker 模版后缀为 <code>.ftl</code>(FreeMarker Template Language)。FTL 是一种简单的、专用的语言，它不是像 Java 那样成熟的编程语言。在模板中，你可以专注于如何展现数据， 而在模板之外可以专注于要展示什么数据。</p><p>好了，这是一个简单的介绍，接下来我们来看看 Freemarker 和 Spring Boot 的一个整合操作。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>在 SSM 中整合 Freemarker ，所有的配置文件加起来，前前后后大约在 50 行左右，Spring Boot 中要几行配置呢？ 0 行！</p><h2 id="1-创建工程"><a href="#1-创建工程" class="headerlink" title="1.创建工程"></a>1.创建工程</h2><p>首先创建一个 Spring Boot 工程，引入 Freemarker 依赖，如下图：</p><p><img src="http://www.javaboy.org/images/boot/22-2.png" alt></p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>工程创建完成后，在 <code>org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration</code> 类中，可以看到关于 Freemarker 的自动化配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class &#125;)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(FreeMarkerProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class,</span><br><span class="line">                FreeMarkerNonWebConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看出，当 <code>classpath</code> 下存在 <code>freemarker.template.Configuration</code> 以及 <code>FreeMarkerConfigurationFactory</code> 时，配置才会生效，也就是说当我们引入了 <code>Freemarker</code> 之后，配置就会生效。但是这里的自动化配置只做了模板位置检查，其他配置则是在导入的 <code>FreeMarkerServletWebConfiguration</code> 配置中完成的。那么我们再来看看 <code>FreeMarkerServletWebConfiguration</code> 类，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet.class, FreeMarkerConfigurer.class &#125;)</span><br><span class="line"><span class="hljs-meta">@AutoConfigureAfter</span>(WebMvcAutoConfiguration.class)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFreeMarkerConfiguration</span> </span>&#123;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">FreeMarkerServletWebConfiguration</span><span class="hljs-params">(FreeMarkerProperties properties)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">super</span>(properties);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span>(FreeMarkerConfig.class)</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> FreeMarkerConfigurer <span class="hljs-title">freeMarkerConfigurer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                FreeMarkerConfigurer configurer = <span class="hljs-keyword">new</span> FreeMarkerConfigurer();</span><br><span class="line">                applyProperties(configurer);</span><br><span class="line">                <span class="hljs-keyword">return</span> configurer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-meta">@Bean</span></span><br><span class="line">        <span class="hljs-meta">@ConditionalOnMissingBean</span>(name = <span class="hljs-string">"freeMarkerViewResolver"</span>)</span><br><span class="line">        <span class="hljs-meta">@ConditionalOnProperty</span>(name = <span class="hljs-string">"spring.freemarker.enabled"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> FreeMarkerViewResolver <span class="hljs-title">freeMarkerViewResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                FreeMarkerViewResolver resolver = <span class="hljs-keyword">new</span> FreeMarkerViewResolver();</span><br><span class="line">                getProperties().applyToMvcViewResolver(resolver);</span><br><span class="line">                <span class="hljs-keyword">return</span> resolver;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来简单看下这段源码：</p><ol><li>@ConditionalOnWebApplication 表示当前配置在 web 环境下才会生效。</li><li>ConditionalOnClass 表示当前配置在存在 Servlet 和 FreeMarkerConfigurer 时才会生效。</li><li>@AutoConfigureAfter 表示当前自动化配置在 WebMvcAutoConfiguration 之后完成。</li><li>代码中，主要提供了 FreeMarkerConfigurer 和 FreeMarkerViewResolver。</li><li>FreeMarkerConfigurer 是 Freemarker 的一些基本配置，例如 templateLoaderPath、defaultEncoding 等</li><li>FreeMarkerViewResolver 则是视图解析器的基本配置，包含了viewClass、suffix、allowRequestOverride、allowSessionOverride 等属性。</li></ol><p>另外还有一点，在这个类的构造方法中，注入了 FreeMarkerProperties：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.freemarker"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreeMarkerProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTemplateViewResolverProperties</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_TEMPLATE_LOADER_PATH = <span class="hljs-string">"classpath:/templates/"</span>;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PREFIX = <span class="hljs-string">""</span>;</span><br><span class="line">        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SUFFIX = <span class="hljs-string">".ftl"</span>;</span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * Well-known FreeMarker keys which are passed to FreeMarker's Configuration.</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        <span class="hljs-keyword">private</span> Map&lt;String, String&gt; settings = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeMarkerProperties 中则配置了 Freemarker 的基本信息，例如模板位置在 <code>classpath:/templates/</code> ，再例如模板后缀为 <code>.ftl</code>，那么这些配置我们以后都可以在 application.properties 中进行修改。</p><p>如果我们在 SSM 的 XML 文件中自己配置 Freemarker ，也不过就是配置这些东西。现在，这些配置由  FreeMarkerServletWebConfiguration​  帮我们完成了。</p><h2 id="2-创建类"><a href="#2-创建类" class="headerlink" title="2.创建类"></a>2.创建类</h2><p>首先我们来创建一个 User 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来创建 <code>UserController</code>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">            user.setId((<span class="hljs-keyword">long</span>) i);</span><br><span class="line">            user.setUsername(<span class="hljs-string">"javaboy&gt;&gt;&gt;&gt;"</span> + i);</span><br><span class="line">            user.setAddress(<span class="hljs-string">"www.javaboy.org&gt;&gt;&gt;&gt;"</span> + i);</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"users"</span>, users);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 freemarker 中渲染数据：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户编号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名称<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户地址<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">#list</span> <span class="hljs-attr">users</span> <span class="hljs-attr">as</span> <span class="hljs-attr">user</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.id&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.username&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$&#123;user.address&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">#list</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="http://www.javaboy.org/images/boot/22-3.png" alt></p><h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><p>如果我们要修改模版文件位置等，可以在 application.properties 中进行配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring.freemarker.allow-request-override=false</span><br><span class="line">spring.freemarker.allow-session-override=false</span><br><span class="line">spring.freemarker.cache=false</span><br><span class="line">spring.freemarker.charset=UTF-8</span><br><span class="line">spring.freemarker.check-template-location=true</span><br><span class="line">spring.freemarker.content-type=text/html</span><br><span class="line">spring.freemarker.expose-request-attributes=false</span><br><span class="line">spring.freemarker.expose-session-attributes=false</span><br><span class="line">spring.freemarker.suffix=.ftl</span><br><span class="line">spring.freemarker.template-loader-path=classpath:/templates/</span><br></pre></td></tr></table></figure><p>配置文件按照顺序依次解释如下：</p><ol><li>HttpServletRequest的属性是否可以覆盖controller中model的同名项</li><li>HttpSession的属性是否可以覆盖controller中model的同名项</li><li>是否开启缓存</li><li>模板文件编码</li><li>是否检查模板位置</li><li>Content-Type的值</li><li>是否将HttpServletRequest中的属性添加到Model中</li><li>是否将HttpSession中的属性添加到Model中</li><li>模板文件后缀</li><li>模板文件位置</li></ol><p>好了，整合完成之后，Freemarker 的更多用法，就和在 SSM 中使用 Freemarker 一样了，这里我就不再赘述。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本文和大家简单聊一聊 Spring Boot 整合 Freemarker，算是对 Spring Boot2 教程的一个补充（后面还会有一些补充），有问题欢迎留言讨论。</p><p>本项目案例，我已经上传到 GitHub 上，欢迎大家 star：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot2 系列教程接近完工，最近进入修修补补阶段。Freemarker 整合貌似还没和大家聊过，因此今天把这个补充上。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
      <category term="Freemarker" scheme="http://www.javaboy.org/tags/Freemarker/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离时代，Java 程序员的变与不变！</title>
    <link href="http://www.javaboy.org/2019/0701/fronted-backend.html"/>
    <id>http://www.javaboy.org/2019/0701/fronted-backend.html</id>
    <published>2019-07-01T02:22:32.000Z</published>
    <updated>2019-07-01T02:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>事情的起因是这样的，有个星球的小伙伴向邀请松哥在知乎上回答一个问题，原题是：</p><a id="more"></a><ul><li>前后端分离的时代，Java后台程序员的技术建议？</li></ul><p>松哥认真看了下这个问题，感觉对于初次接触前后端分离的小伙伴来说，可能都会存在这样的疑问，于是决定通过这篇文章和大家聊一聊这个话题。</p><p>我这里还是尽量从一个 Java 程序员的角度来说说这个问题，这样大家可能更好理解。</p><h1 id="从一个题外话开始"><a href="#从一个题外话开始" class="headerlink" title="从一个题外话开始"></a>从一个题外话开始</h1><p>很多小伙伴可能知道，松哥本科是经管学院的，亚当•斯密的《国富论》多多少少还是了解一点。书中提到人类社会的本质就是分工协作，亚当•斯密认为人类之间的专业分工可以极大的提高生产力、创造财富，专业分工也是工业革命的基础。人类社会的发展过程就是一个专业分工不断细化、不断深化的过程，从最早的农牧分家到手工业农业分家再到商人的出现，其实都是专业分工不断细化深化的体现。</p><p>我们的开发世界也是一个小宇宙，专业分工不断细化也是一个趋势，从这个角度来说，前后端分离，都是值得积极拥抱的。</p><p>前后端分离的开发方式在最近几年突然火起来，松哥认为有两方面的原因：</p><ol><li>前端的发展。前端经过近几年的发展，已经不再是我们传统所说的HTML+画图了，各种概念层出不穷，webpack、RxJs、Node、Redux、ssr、NuxtJs等，前端已经可以胜任很多事情，也能够完成更加丰富的用户交互。</li><li>移动互联网的发展。前两年移动互联网的火爆，很多公司的产品都要在多个平台上线，Android、iOS、小程序、公众号、PC 等等各个平台都要展示，不可能针对不同的设备开发一套后端，应该是多个前端共用同一个后端，这是就不能采用传统的前后端不分的方式来开发后端程序了。正是这样的业务需求，促进了前后端分离的发展。</li></ol><h1 id="变与不变"><a href="#变与不变" class="headerlink" title="变与不变"></a>变与不变</h1><p>程序员之间的分工协作方式有所变化，开发方式当然也会随着一起变化。但是这种变化其实是非常细微的，很容易上手的。</p><h2 id="变"><a href="#变" class="headerlink" title="变"></a>变</h2><ul><li>工作内容变</li></ul><p>老实说，前后端分离之后，对 Java 程序员的要求变低了，以前大家大家出去面试 Java 工程师，如果是前后端不分的话，前端基本上也是必问的，常见的问题就是各种元素选择器，这也很好理解，因为在前后端不分的开发方式中，后端工程师多多少少是要写一点前端代码的，你很难完完全全的只写 Java 代码。但是在这种情况下，你要写的前端代码其实都是很简单的，不会是特别难的。</p><p>前后端分离之后，Java 程序员只需要专注于后台业务逻辑，对外接收前台传来的参数，根据参数给出不同的响应即可，基本上不需要写前端代码。因为这个时候的前端不同于前后端不分时候的前端，前后端分离之后，前端还是有一定的难度，较为常见的是 SPA 应用，涉及到 NodeJS、Webpack 等，此时如果还要让后端工程师写前端代码，对后端工程师的技术要求就会比较高。</p><p>不过话说回来，前后端分离后，如果你还能即写前端又写后端，那可以让老板加薪了。</p><ul><li>接口变</li></ul><p>前后端不分的时候，很少会涉及到接口设计，以 SpringMVC 为例，你可能返回的始终是 ModelAndView 一类的东西，前后端分离之后，我们基本上不需要返回页面了，后端主要是返回 JSON 数据，所以关键是设计好各种接口。</p><p>一个比较好的实践方案是设计满足 RESTful 规范的接口，语义明确，简洁明了，看到 URL 就知道你想干嘛！</p><ul><li>开发流程变化</li></ul><p>前后端分离之后，前端不可能等后端开发好接口之后再去开发，如果这样，原本两个月做完的项目可能就得 4 个月才能完成。</p><p>一般在开发之前，整个项目组需要先设计好一个接口文档，一般可以采用 Swagger 来做接口文档(<a href="https://mp.weixin.qq.com/s/iTsTqEeqT9K84S091ycdog" target="_blank" rel="noopener">SpringBoot整合Swagger2，再也不用维护接口文档了！</a>)，文档中约定了接口的详细信息，前后端分别按照既定的接口规范去开发，在尚未开发完成时，可以借助 Mock 来进行测试。</p><p>前端也是使用模拟数据进行测试，开发完成之后，前后端接口联调，完成测试。</p><h2 id="不变"><a href="#不变" class="headerlink" title="不变"></a>不变</h2><p>其实除了前后端交互方式发生变化之外，其他的地方都是不变的。</p><p>前后端分离，一般来说是不会影响后端技术架构的，你使用了 SSM 或者 Spring Boot 或者 Dubbo 或者微服务，无论什么，这些技术架构既可以支撑你前后端不分的项目，也可以支撑你前后端分离的项目。</p><p>因此我说后端技术架构不受前后端分离影响。</p><p>另一方面，技术的根本不变，例如你做 Java 开发，该会的 SSM/SpringBoot/Redis/Nginx/Dubbo/SpringCloud/MySQL/MyCat/ELK/…等等，都还得会。</p><p>所以，还是去老老实实撸代码吧！</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果仅仅从一个 Java 程序员的角度来说，前后端分离开发这种方式，其实是解放了 Java 程序员，可以让我们专注于后端的工作，不用再去写前端代码，术业有专攻，可以写出更优质的后端代码。不过话说回来，如果想保持一个良好的竞争力，还是有必要去了解一下目前流行的前端开发方式。</p><p>前后端分离不是终点，只是软件开发方式演变大潮下的一个点而已，未来的路还很长，还有很多东西需要我们去学习，这只是一个其中一个而已。</p><p>最后再给大家推荐几篇松哥之前写的前后端分离的文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/HWRYAR16vLE1XFep6_i1tA" target="_blank" rel="noopener">一个Java程序猿眼中的前后端分离以及Vue.js入门</a></li><li><a href="https://mp.weixin.qq.com/s/Qbqvlo7ftbyP6dnbuUcxrw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离，两种文件上传方式总结！</a></li><li><a href="https://mp.weixin.qq.com/s/K8ANNmm6ZrP2xMyK6LGZ_g" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，前端网络请求封装与配置</a></li><li><a href="https://mp.weixin.qq.com/s/5GsOO4QK9AnR0K6FdZixOw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，权限管理的一点思路</a></li></ol><p>再推荐两个入门项目：</p><ol><li><a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a></li><li><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V部落</a></li></ol><p>好了，本文就说到这里，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事情的起因是这样的，有个星球的小伙伴向邀请松哥在知乎上回答一个问题，原题是：&lt;/p&gt;
    
    </summary>
    
      <category term="前后端分离" scheme="http://www.javaboy.org/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
      <category term="前后端分离" scheme="http://www.javaboy.org/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库中间件 MyCat 搞起来！</title>
    <link href="http://www.javaboy.org/2019/0628/mycat-install.html"/>
    <id>http://www.javaboy.org/2019/0628/mycat-install.html</id>
    <published>2019-06-28T00:33:57.000Z</published>
    <updated>2019-06-28T02:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 MyCat 的铺垫文章已经写了三篇了：</p><ol><li><a href="https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA" target="_blank" rel="noopener">MySQL 只能做小项目？松哥要说几句公道话！</a></li><li><a href="https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w" target="_blank" rel="noopener">北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！</a></li><li><a href="https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ" target="_blank" rel="noopener">What？Tomcat 竟然也算中间件？</a></li></ol><p>今天终于可以迎接我们的大 Boss 出场了！</p><a id="more"></a><h1 id="MyCat-简介"><a href="#MyCat-简介" class="headerlink" title="MyCat 简介"></a>MyCat 简介</h1><p>前面文章我们提到，如果数据量比较大的话，我们需要对数据进行分库分表，分完之后，原本存在一个数据库中的数据，现在就存在多个数据库中了，就像下面这样：</p><p><img src="http://www.javaboy.org/images/mysql/6-2.png" alt></p><p>那么此时 MyCat 所扮演的角色就是分布式数据库中间件！</p><p>MyCat 是一个开源的分布式数据库中间件，它实现了 MySQL 协议，在开发者眼里，他就是一个数据库代理，我们甚至可以使用 MySQL 的客户端工具以及命令行来访问 MyCat 。</p><p>MyCat 现在已经不仅仅只支持 MySQL 了，同时也支持 MSSQL、Oracle、DB2、以及 PostgreSQL等主流数据库。甚至像 MongoDB 这种 NoSQL 也支持。</p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="搭建读写分离"><a href="#搭建读写分离" class="headerlink" title="搭建读写分离"></a>搭建读写分离</h2><p>要搞 MyCat ，一般要先搭建好 MySQL 的读写分离，MySQL 的读写分离可以参考松哥之前的这篇文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li></ol><h2 id="MyCat-安装"><a href="#MyCat-安装" class="headerlink" title="MyCat 安装"></a>MyCat 安装</h2><p>环境：</p><ul><li>CentOS7</li><li>JDK1.8</li></ul><p>MyCat 使用 Java 开发，因此，运行 MyCat ，一定要具备 Java 环境，配置 Java 运行环境这个比较容易，网上资料也很多，我就不详细介绍了。</p><p>Java 环境安装好之后，首先下载 MyCat：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.mycat.io/1.6.7.1/Mycat-server-1.6.7.1-release-20190213150257-linux.tar.gz</span><br></pre></td></tr></table></figure><p>下载完成后，对下载文件进行解压。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Mycat-server-1.6.7.1-release-20190213150257-linux.tar.gz</span><br></pre></td></tr></table></figure><p>解压成功后，会出现一个 <code>mycat</code> 目录，进入到 <code>mycat/conf</code> 目录，对 <code>mycat</code> 进行配置：</p><p>首先来配置 <code>schema.xml</code> 文件：</p><p><img src="http://www.javaboy.org/images/mysql/7-1.png" alt></p><ol><li>首先在 <code>schema</code> 中指定逻辑库的名字，逻辑库是指 <code>MyCat</code> 中的库，这个库不存储数据，数据存储在 <code>MySQL</code> 中的物理库中。</li><li>逻辑库中配置逻辑表，配置逻辑表时，需要指定 <code>dataNode</code> 节点， <code>dataNode</code> 就是指数据库存储的位置</li><li>配置  <code>dataNode</code> ，<code>dataNode</code> 指定  <code>dataHost</code> 和物理库的名字。</li><li><code>dataHost</code> 则配置 <code>MySQL</code> 的主机和从机的位置，登录密码等。主机和从机都可以配置多个。</li></ol><p>配置完 schema.xml 后 ，接下来配置 server.xml。</p><p>server.xml  中主要配置 MyCat 的登录用户名和密码，以及需要操作的逻辑库。</p><p><img src="http://www.javaboy.org/images/mysql/7-2.png" alt></p><p>配置完成后，接下来就可以启动 MyCat 了 。</p><p>执行 MyCat 解压目录下的 bin 目录下的 mycat 命令，可以启动 MyCat</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/mycat start</span><br></pre></td></tr></table></figure><p>如果启动后，提示无法创建 <code>mycat.pid</code> 文件，就自己手动创建一个 <code>mycat.pid</code> 文件。启动成功之后，就可以在本地连接 <code>MyCat</code> 了，连接方式和 <code>MySQL</code> 一样，唯一的区别在于端口号不同。</p><p>在连接  <code>MyCat</code> 之前，先在 <code>MySQL</code> 物理库中创建 <code>db1</code>、<code>db2</code> 以及 <code>db3</code> 三个数据库。</p><p>使用 <code>SQLyog</code> 连接：</p><p><img src="http://www.javaboy.org/images/mysql/7-3.png" alt></p><p>也可以在 <code>cmd</code> 命令行登录 <code>MyCat</code> ：</p><p><img src="http://www.javaboy.org/images/mysql/7-4.png" alt></p><p>登录成功后 ，在 <code>MyCat</code>  的窗口中，执行如下命令，创建表：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table t_user (id integer primary key,username varchar(255))</span><br></pre></td></tr></table></figure><p>执行成功后，我们会发现物理库中出现了相应的表。<br>接下来，手动往各个物理库的物理表中存储一条数据，然后在  MyCat 窗口中查询：</p><p><img src="http://www.javaboy.org/images/mysql/7-5.png" alt></p><p>这样就可以查询到 三个库中的三个表中的数据。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>整个过程不难，但是有的小伙伴在第一次配置的过程中还是容易出错，因此我这里还是来说两句，出错了要如何定位。</p><p>一般来说，配置 MyCat 出错，问题可能发生在两个阶段。第一个阶段就是客户端连接 MyCat 出错，第二个阶段就是 MyCat 连接 MySQL 出错。</p><p>无论你是使用 SQLyog 还是 Navicat ，我们在连接数据库的过程中，都可以先测试连接，很多人卡在这一步。</p><p>如果在测试连接的时候就连接不通，说明是 MyCat 的问题，这个时候检查步骤如下：</p><ol><li>首先当然是查看日志信息，看能不能找出端倪</li><li>通过 jps 命令查看 mycat 是否成功启动</li><li>检查 server.xml 中配置是否正确，用户名密码是否输入正确</li></ol><p>这是第一种可能的问题，第二种问题就是测试连接没问题，但是测试完后，却连接不上。反映到 Navicat 上，就是测试连接没问题，测完之后，点击连接名要打开连接时，Navicat 就崩了，出现这个问题一般是 MyCat 在连接 MySQL 出问题了，这个时候就要去检查 schema.xml 文件中关于 MySQL 主机和从机的配置是否正确，数据库地址是否正确，用户名密码是否正确。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好了，本文主要简单介绍了下 MyCat 的安装问题，下篇文章我们来看 MyCat 中的分片规则问题。</p><p>参考资料：</p><ol><li><a href="http://www.mycat.io/" target="_blank" rel="noopener">MyCat 官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 MyCat 的铺垫文章已经写了三篇了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 只能做小项目？松哥要说几句公道话！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7pj5E2HvmiejBJrW0T86oQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What？Tomcat 竟然也算中间件？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天终于可以迎接我们的大 Boss 出场了！&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="MyCat" scheme="http://www.javaboy.org/tags/MyCat/"/>
    
  </entry>
  
</feed>
