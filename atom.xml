<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2019-09-21T06:48:59.572Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给数据库减负的八个思路</title>
    <link href="http://www.javaboy.org/2019/0921/mysql.html"/>
    <id>http://www.javaboy.org/2019/0921/mysql.html</id>
    <published>2019-09-21T06:47:18.000Z</published>
    <updated>2019-09-21T06:48:59.572Z</updated>
    
    <content type="html"><![CDATA[<p>传统的企业级应用，其实很少会有海量应用，因为企业的规模本身就摆在那里，能有多少数据？高并发？海量数据？不存在的！</p><p>不过在互联网公司中，因为应用大多是面向广大人民群众，数据量动辄上千万上亿，那么这些海量数据要怎么存储？光靠数据库吗？肯定不是。</p><a id="more"></a><p>今天松哥和大家简单的聊一聊这个话题。</p><p>海量数据，光用数据库肯定是没法搞定的，即使不读松哥这篇文章，相信大家也能凝聚这样的共识，海量数据，不是说一种方案、两种方案就能搞定，它是一揽子方案。那么这一揽子方案都包含哪些东西呢？松哥从以下八个方面来和大家聊聊。</p><h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h1><p>首先第一种解决方案就是缓存了。</p><p>缓存，我们可以将数据直接缓存在内从中，例如 Map、也可以使用缓存框架如 Redis 等，将一些需要频繁使用的热点数据保存在缓存中，每当用户来访问的时候，就可以直接将缓存中的数据返回给用户，这样可以有效降低服务器的压力。</p><p>可以缓存起来使用的数据，一般都不能对实时性要求太高。</p><h1 id="2-页面静态化"><a href="#2-页面静态化" class="headerlink" title="2.页面静态化"></a>2.页面静态化</h1><p>页面静态化其实可以算作是缓存的另外一种形式，相当于直接将相关的页面渲染结果缓存起来。首先大家知道，在我们的 Web 项目中，资源分为两大类：</p><ul><li>静态资源</li><li>动态资源</li></ul><p>静态资源就是我们常见的 HTML、CSS、JavaScript、图片等资源，这些资源可以不经过服务端处理，就可以直接返回给前端浏览器，浏览器就可以直接显示出来。</p><p>动态资源则是指我们项目中的 Servlet 接口、Jsp 文件、Freemarker 等，这些需要经过服务端渲染之后，才可以返回前端的资源。</p><p>在实际项目中，静态资源的访问速度要远远高于动态资源，动态资源往往很容易遇到服务器瓶颈、数据库瓶颈，因此，对于一些不经常更新的页面，或者说更新比较缓慢的页面，我们可以通过页面静态化，将一个动态资源保存为静态资源，这样当服务端需要访问的时候，直接将静态资源返回，就可以避免去操作数据库了，降低数据库的压力。</p><p>例如松哥以前做过的一个电商项目，系统根据大数据统计，自动统计出用户当前搜索的热点商品，这些热点商品，10 分钟更新一次，也就是说，在十分钟内，用户登录上来看到的热点商品都是相同的。那么就没有必要每次都去查询数据库，而是将热点数据的页面，通过输出流自动写到服务器上，写成一个普通的 HTML 文件，下次用户来访问，在 10 分钟有效期内，直接将 HTML 页面返回给用户，就不必操作数据库了。</p><p>一般来说，Freemarker、Velocity 等都有相关的方法可以帮助我们快速将动态页面生成静态页面。</p><p>这就是页面静态化。</p><h1 id="3-数据库优化"><a href="#3-数据库优化" class="headerlink" title="3.数据库优化"></a>3.数据库优化</h1><p>很多时候程序跑得慢，不是因为设备落后，而是因为数据库 SQL 写的太差劲。</p><p>要解决海量数据的问题，数据库优化肯定也是不可避免的。一般来说，我们可以从 SQL 优化、表结构优化、以及数据库分区分表等多个方面来对数据库进行优化。数据库优化其实也是一门巨大的学问，松哥以后看有时间写个连载和大家仔细聊聊这个话题。</p><h1 id="4-热点数据分离"><a href="#4-热点数据分离" class="headerlink" title="4.热点数据分离"></a>4.热点数据分离</h1><p>数据库中的数据，虽然是海量数据，但是这些数据并不见得所有数据都是活跃数据，例如用户注册，有的用户注册完就消失的无影无踪了，而有的用户则在不停的登录，因此，对于这两种不同的用户，我们可以将活跃用户分离出来，在主要操作的数据表中只保存活跃用户数据。每次用户登录，先去主表中查看有没有记录，有的话，直接登录，没有的话，再去查看其他表。</p><p>通过判断用户在某一段时间内的登录次数，就可以很快分离出热点数据。</p><h1 id="5-合并数据库操作"><a href="#5-合并数据库操作" class="headerlink" title="5.合并数据库操作"></a>5.合并数据库操作</h1><p>这个方案的宗旨其实是减少数据库操作的次数，例如多次插入操作，我们可以合并成一条 SQL 搞定。多个不同条件的查询，如果条件允许的话，也可以合并成为一个查询，尽量减少数据库的操作，减少在网络上消耗，同时也降低数据库的压力。</p><h1 id="6-数据库读写分离"><a href="#6-数据库读写分离" class="headerlink" title="6.数据库读写分离"></a>6.数据库读写分离</h1><p>数据库的读写分离其实松哥在之前的 MyCat 中也和大伙聊过了（<a href="https://mp.weixin.qq.com/s/oNsTcrWCjntQefD2B0sq1A" target="_blank" rel="noopener">MyCat 系列</a>），读写分离之后，一方面可以提高数据库的操作效率，另一方面也算是对数据库的一个备份。这一块的具体操作大家可以参考松哥前面的文章。</p><h1 id="7-分布式数据库"><a href="#7-分布式数据库" class="headerlink" title="7.分布式数据库"></a>7.分布式数据库</h1><p>数据库读写分离之后，无形中增大了代码的复杂度，所以一般还需要借助分布式数据库中间件，这样可以有效提高数据库的弹性，可以方便的随时为数据库扩容，同时也降低代码的耦合度。</p><h1 id="8-NoSQL-和-Hadoop"><a href="#8-NoSQL-和-Hadoop" class="headerlink" title="8.NoSQL 和 Hadoop"></a>8.NoSQL 和 Hadoop</h1><p>另外，引入 NoSQL 和 Hadoop 也是解决方案之一。NoSQL 突破了关系型数据库中对表结构、字段等定义的条条框框，使用户可以非常灵活方便的操作，另外 NoSQL 通过多个存储块存储数据的特点，使得天然具备操作大数据的优势（快）。不过，老实说，NoSQL 目前还是在互联网项目中比较常见，在传统的企业级应用中还是比较少见。</p><p>Hadoop 就不必说了，大数据处理利器。</p><p>很多时候技术和架构只是一个工具，所有的东西都摆在你面前，关键是如何把这些东西组合在一起，使之产生最大化收益，这就需要大家慢慢琢磨，松哥后面也尽量和大家多分享一些这方面的经验。</p><p>好了，简单的从 8 个方面和大家聊一聊这个问题，大家在工作中有没有遇到类似问题呢？你都是怎么处理的？欢迎留言讨论。</p><p>参考资料：</p><p>[1] 韩路彪.看透Spring MVC：源代码分析与实践[M].北京：机械工业出版社，2015.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传统的企业级应用，其实很少会有海量应用，因为企业的规模本身就摆在那里，能有多少数据？高并发？海量数据？不存在的！&lt;/p&gt;
&lt;p&gt;不过在互联网公司中，因为应用大多是面向广大人民群众，数据量动辄上千万上亿，那么这些海量数据要怎么存储？光靠数据库吗？肯定不是。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了</title>
    <link href="http://www.javaboy.org/2019/0920/springboot-vue-online.html"/>
    <id>http://www.javaboy.org/2019/0920/springboot-vue-online.html</id>
    <published>2019-09-20T05:07:20.000Z</published>
    <updated>2019-09-21T06:05:01.688Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了一周的域名备案昨天终于搞定了。</p><p>松哥第一时间想到赶紧把<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>部署上去，我知道很多小伙伴已经等不及了。</p><a id="more"></a><h2 id="1-也曾经上过线"><a href="#1-也曾经上过线" class="headerlink" title="1. 也曾经上过线"></a>1. 也曾经上过线</h2><p>其实这两个项目当时刚做好的时候，我就把它们部署到服务器上了，以帮助小伙伴们更好的查看效果。但是那个是一台国外服务器，之所以购买国外服务器，主要是嫌国内备案麻烦，当然也有其他大家都懂的原因。</p><p>国外服务器有方便的地方，同时也有很多不便，例如网络不稳，随时有失联的风险。所以我在 2018 年年初，虽然把这两个项目都部署在服务器上，但是很多小伙伴的访问体验都不好，主要还是网络的问题。后来一段时间，经过几轮围剿与反围剿，这台服务器就彻底和松哥失联了。</p><p>失联之后，因为工作比较忙，我也就懒得去折腾了，所以导致<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>大家在很长一段时间内无法在线查看效果。</p><h2 id="2-重新上线"><a href="#2-重新上线" class="headerlink" title="2. 重新上线"></a>2. 重新上线</h2><p>最近因为有一些其他的计划，于是购买了阿里云服务，完事之后就是备案，所有东西都搞定之后，想着先把<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>部署起来，方便大家查看效果。</p><p>说干就干，我首先规划了两个二级域名：</p><ul><li><a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a></li><li><a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a></li></ul><p>这两个二级域名分别用来部署 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>和<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>。</p><p>大家可以通过这两个地址查看效果：</p><p><strong><a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a></strong></p><p><img src="http://www.javaboy.org/images/fronted-backend/70-1.png" alt></p><p><strong><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a></strong></p><p><img src="http://www.javaboy.org/images/fronted-backend/70-2.png" alt></p><p>为了确保每位小伙伴都能看到完整的演示效果，防止有的小伙伴不慎把所有数据清空了，导致其他小伙伴啥都看不到，我只开通了演示账户的查询和部分字段的更新权限，因此大家在查看演示效果时，可能会有一些涉及到增删改的操作会执行失败，请勿见怪，将项目部署到本地运行之后，就可以查看完整效果了。</p><h2 id="3-技能树"><a href="#3-技能树" class="headerlink" title="3. 技能树"></a>3. 技能树</h2><p>既然都写到这儿了，就和大家聊一聊这两个部署是怎么实现的。</p><h3 id="3-1-部署方案选择"><a href="#3-1-部署方案选择" class="headerlink" title="3.1 部署方案选择"></a>3.1 部署方案选择</h3><p>大家知道前后端分离部署的时候，我们有两种不同的方案：</p><ul><li>一种就是将前端项目打包编译之后，放到后端项目中（例如 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下）</li><li>另外一种则是将前端打包之后的静态资源用 Nginx 来部署，后端单独部署只需要单纯的提供接口即可。</li></ul><p>一般在公司项目中，我们更多的是采用后者。不过松哥这里部署为了省事，我采用了第一种方案。（以后抽空我会和大家聊聊第二种部署方案）</p><h3 id="3-2-域名映射"><a href="#3-2-域名映射" class="headerlink" title="3.2 域名映射"></a>3.2 域名映射</h3><p>域名映射这块简单，登录阿里云后台，添加两个 A 记录即可。</p><p><img src="http://www.javaboy.org/images/fronted-backend/70-3.png" alt></p><h3 id="3-3-启动-Spring-Boot"><a href="#3-3-启动-Spring-Boot" class="headerlink" title="3.3 启动 Spring Boot"></a>3.3 启动 Spring Boot</h3><p>将<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>分别打包上传到服务器，这个过程应该就不用我多说了吧，然后分别启动这两个项目，两个项目的默认端口分别是 8081 和 8082，命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar vblog.jar &gt; vblog.log &amp;</span><br><span class="line">nohup java -jar vhr.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><p>将两个项目的运行日志分别写入到 vblog.log 和 vhr.log 文件中。</p><p>启动成功之后，我们就可以通过 <code>itboyhub.com:8081</code> 和 <code>itboyhub.com:8082</code> 两个端口来分别访问这两个项目了。但是这还没达到松哥的目标，我想通过二级域名来访问，并且想通过 80 端口来访问，这就要借助 Nginx 了。</p><p><strong>注意</strong></p><p>启动完成后，大家需要登录阿里云后台，确认 8081 和 8082 端口已经开启。</p><h3 id="3-4-Nginx-配置"><a href="#3-4-Nginx-配置" class="headerlink" title="3.4 Nginx 配置"></a>3.4 Nginx 配置</h3><p>Nginx 的基本用法，大家可以参考松哥的这篇旧文：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></li></ul><p>这里我们主要来看看 Nginx 的配置。</p><p>由于有两个二级域名，而且未来服务器还要配置其他域名，因此域名要能够做到动态解析，因此在具体配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  *.itboyhub.com;</span><br><span class="line"></span><br><span class="line">    if ($http_host ~* &quot;^(.*?)\.itboyhub\.com$&quot;) &#123;</span><br><span class="line">            set $domain $1;</span><br><span class="line">    &#125;</span><br><span class="line">    # 其他配置...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先监听的端口为 80</li><li>二级域名则用一个通配符 <code>*</code> 代替</li><li>接下来在 if 语句用，通过正则表达式提取出二级域名的名字，交给变量 $domain，以备后用。</li></ul><p>接下来配置转发规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  if ($domain ~* &quot;vhr&quot;) &#123;</span><br><span class="line">    proxy_pass http://itboyhub.com:8082;</span><br><span class="line">  &#125;</span><br><span class="line">  if ($domain ~* &quot;vblog&quot;) &#123;</span><br><span class="line">    proxy_pass http://itboyhub.com:8081;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  tcp_nodelay     on;</span><br><span class="line">  proxy_set_header Host            $host;</span><br><span class="line">  proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当定义的 $domain 中包含 vhr 字符时，将请求转发到 <a href="http://itboyhub.com:8082" target="_blank" rel="noopener">http://itboyhub.com:8082</a></li><li>当定义的 $domain 中包含 vblog 字符时，将请求转发到 <a href="http://itboyhub.com:8081" target="_blank" rel="noopener">http://itboyhub.com:8081</a></li><li>最后再配置将代理服务器收到的用户的信息传到 real server 上</li></ul><p>另一方面，由于默认的后端首页是 <code>/index.html</code>，如果用户直接访问 <a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a> 或者 <a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a>，会被权限管理机制拦截（会自动重定向到 <code>/login_p</code>），因此，如果用户访问地址中没有 <code>/index.html</code> ，则自动添加上 <code>/index.html</code>，配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /login_p &#123;</span><br><span class="line">   if ($domain ~* &quot;vhr&quot;) &#123;</span><br><span class="line">     rewrite ^/(.*)$ http://vhr.itboyhub.com/index.html permanent;</span><br><span class="line">   &#125;</span><br><span class="line">   if ($domain ~* &quot;vblog&quot;) &#123;</span><br><span class="line">     rewrite ^/(.*)$ http://vblog.itboyhub.com/index.html permanent;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这行配置在 <code>location /</code> 之前进行配置，这里两个 if 的含义和前面的一样，不再赘述。</p><p>OK，如此之后我们的配置就算是完成了（上面 nginx 完整的配置文件小伙伴可以在公众号后台回复 nginx.conf 获取​）。</p><p>接下来我们就可以通过如下两个二级域名访问这两个开源项目了，小伙伴们赶紧试一把吧。</p><ul><li><a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a></li><li><a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a></li></ul><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>最后，再向小伙伴们安利一把这两个开源项目：</p><ul><li><a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li><li><a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>如果你要学习 Spring Boot + Vue 前后端分离项目，这两个是不可多得的好资料。 其中 V 部落无论是从技术点还是业务上来说，都要简单一些，所以如果你是新手，可以先看看 V 部落。微人事虽然稍微复杂一点，但好在松哥配有完整的开发文档，照着开发文档，相信大家也能理解大部分的功能。文档如下：</p><p><img src="http://www.javaboy.org/images/fronted-backend/70-4.png" alt></p><p>如果大家在部署的过程中遇到问题，也可以参考松哥手把手的部署视频：</p><ul><li><a href="https://mp.weixin.qq.com/s/qN01Le434FWom0c3jqiQmA" target="_blank" rel="noopener">微人事项目部署视频教程</a></li></ul><p>好了，本文说到这里，小伙伴们有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了一周的域名备案昨天终于搞定了。&lt;/p&gt;
&lt;p&gt;松哥第一时间想到赶紧把&lt;a href=&quot;https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微人事&lt;/a&gt;和 &lt;a href=&quot;https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;V 部落&lt;/a&gt;部署上去，我知道很多小伙伴已经等不及了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>一个小小的里程碑！啥也不说了，签名书奉上！</title>
    <link href="http://www.javaboy.org/2019/0917/official-accounts-20000.html"/>
    <id>http://www.javaboy.org/2019/0917/official-accounts-20000.html</id>
    <published>2019-09-17T05:06:41.000Z</published>
    <updated>2019-09-21T06:04:43.642Z</updated>
    
    <content type="html"><![CDATA[<p>就在昨天，松哥的公众号【江南一点雨】迎来了第 20000 个读者，算是一个小小的里程碑吧。</p><a id="more"></a><p>距离公众号读者到达 10000 差不多过去三个月了，3 个月时间，用户又增加了 10000，很多小伙伴可能不知道，我在今年 3 月份的时候，公众号的读者才只有 5200+，到现在差不多半年时间，用户增长了 15000，今天我想和大家聊聊我的运营故事。</p><p>故事很简单，无非就是<strong>死撑</strong>二字。</p><h3 id="漫不经心的开始"><a href="#漫不经心的开始" class="headerlink" title="漫不经心的开始"></a>漫不经心的开始</h3><p>我是在 2017 年 2 月 19 号申请的公众号，到 2019 年 1 月 31 号的时候，公众号的用户才终于突破 5000，这 5000+ 小伙伴基本上都是看了我的博客或者开源项目关注了我的公众号。我觉得早期关注我的小伙伴真的很不容易，因为那个时候，我公众号基本上都是连着更一两个月，然后又歇好几个月，歇几个月之后，又开始更，断断续续的，在这样的状态下还没有取关，真爱无疑。</p><p>这一段时间里，我没有专门去运营公众号，也是因为不懂公众号要怎么运营，公众号在我眼里就只是一个类似于 CSDN、sf 那样的博客发布平台而已，我甚至傻傻的想着通过公众号里边的阅读原文增加博客的访问量。不得不说，松哥在运营公众号这事上后知后觉没有一丁点的天赋。</p><p>基于这样不成熟的想法，这一段时间也谈不上坚持，就是顺其自然，心情好了发几篇，心情不好了就断更几个月。</p><h3 id="下定决心"><a href="#下定决心" class="headerlink" title="下定决心"></a>下定决心</h3><p>今年 3 月份，华为云组织了云享专家的线下活动，活动中认识了微笑哥（公众号：纯洁的微笑），活动结束后和微笑哥一起吃了个饭，听他讲做公众号的事，感觉很有意思，也极大的吸引到我。于是当天晚上回到家，我就下定决心今年要好好做我的公众号。</p><h3 id="小号的倔强"><a href="#小号的倔强" class="headerlink" title="小号的倔强"></a>小号的倔强</h3><p>下定决心后，真正要动手的时候，我却发现没有头绪。我只有 5000+ 读者，一篇原创技术干货只有 200 左右的阅读，怎么办？这时候是我最缺乏信心的时候，因为我也不知道我是否适合做这个事。虽然我从大学毕业那年就开始写博客，但是把公众号当成一件事认认真真去做，还是有些不够自信。</p><p>刚好那段时间，我写了一篇文章，回忆了一路坚持写博客，再到最后出书的历程(<a href="https://mp.weixin.qq.com/s/Lr5CwOSqYvx-JrFCSGf_Dw" target="_blank" rel="noopener">起早贪黑几个月，我写完了人生第一本书！</a>)，在写这篇文章的时候，我就在想，当初决定要写博客，其实也不知道写了之后有没有用，就是觉得时间不能浪费，于是就开干了，写博客这事是典型的坚持了之后才看到希望。那么做公众号是否也一样？把当初写博客的那股劲用到写公众号上，先坚持几个月，看看到底怎么样，就这样，我慢慢的说服了自己，不要怂，就是干。</p><p>做公众号虽然有很多运营技巧，但其实最关键的就是内容，没有内容，再多技巧都是白搭，对于像松哥这样的小号而言，内容就更显得重要了，所以我从一开始就下定决心，要坚持做原创，实际上从 2017 年到 2019 年 3 月份，我的公众号上基本都是原创技术干货，而且我几乎很少写零散的问题解决方案，基本上都是成体系的教程，例如：</p><ul><li><a href="https://mp.weixin.qq.com/s/RqGddTAfIxSZOhfkjqhMFg" target="_blank" rel="noopener">Spring Cloud 系列</a></li><li><a href="https://mp.weixin.qq.com/s/0Bukv4bFGMWosG8SWWoDDw" target="_blank" rel="noopener">Redis 系列</a></li><li><a href="https://mp.weixin.qq.com/s/WSloXbauYnecGTFWizH9HQ" target="_blank" rel="noopener">Git 系列</a></li><li><a href="https://mp.weixin.qq.com/s/8L-RMZorVAFVamzncVTQBw" target="_blank" rel="noopener">MongoDB 系列</a></li><li><a href="https://mp.weixin.qq.com/s/8d3OxnGX17ik1g7H_ocwIA" target="_blank" rel="noopener">Elasticsearch 系列</a></li><li><a href="https://mp.weixin.qq.com/s/bAL90MQvSM1SJsye_LQ5Nw" target="_blank" rel="noopener">Docker 系列</a></li></ul><p>这些系列教程都是我一个字一个字码出来的。于是我就想继续延续我公众号原创的这一优良传统。</p><p>于是，<strong>从今年 3 月份到现在，一共发了 106 篇原创</strong>，这些原创主要围绕 Spring Boot 和前后端分离来写的(例如 <a href="https://mp.weixin.qq.com/s/tm1IqiEvRZwDAb-F5yJ5Aw" target="_blank" rel="noopener">Spring Boot 系列</a>)，当然也有一个小小的 MyCat 系列，这些松哥以后都会给大家整理好。</p><p>由于一直坚持原创，公众号的阅读数也慢慢上来了，从 200 到 300、500、700、1000….直到现在的 2000 左右，不断增长的阅读给了我继续做下去的信心。</p><h3 id="全靠死撑"><a href="#全靠死撑" class="headerlink" title="全靠死撑"></a>全靠死撑</h3><p>然而写原创并不容易，特别是写出一篇皆大欢喜的原创更难。今天的文章发了，就得琢磨明天发啥，明天的准备好了，又得琢磨后天发发啥，每天晚上写到 12 点如同家常便饭，因为一篇文章不是把几百个字码出来就完事了，你要写案例，写 Demo，然后运行 Demo，截图保存，然后在文章中使用，这个过程费时费力，一篇原创干货往往要好几个小时才能出炉。</p><p>松哥写原创技术文最疯狂的时候，差不多连续两个月，篇篇原创，大家可以翻一下 4 月到 7 月的文章。那个时候我经常一坐好几个小时，坐久了腰疼屁股疼，最近买了个升降桌，情况才得以慢慢缓解。</p><p>松哥并不是全职做公众号，白天和大部分小伙伴一样，松哥也要上班，晚上回家后，除了写公众号上的技术文章之外，还有很多其他的事情要做。3-6 月份期间，应慕课网邀请，我和微笑哥一起在慕课网上出了一个 Spring Cloud 微服务开发实践 的专栏，那段时间，晚上除了写公众号，还要写专栏，周末也是一样。专栏在六月份完工之后，七月份松哥又开始录制 Spring Boot + 微人事 的视频教程，这个教程目前还在录制中，没有完工，所以我基本上没有什么业余活动，周末也是正常作息，时间都是一分一分抠出来的，除了偶尔去游个泳。</p><p>七月底的时候，实在是有点扛不住了，那段时间状态很差，做事效率也很低，但看着每天增长的数据，实在不忍心放弃，最终还是坚持了下来。</p><h3 id="不得不说的广告"><a href="#不得不说的广告" class="headerlink" title="不得不说的广告"></a>不得不说的广告</h3><p>做公众号这段时间，松哥前前后后算起来一共就接过 4 个商业广告，老实说，这个数字在我目前这个同量级的号主中算是很少了，很少的原因不是因为我接不到广告，相反，随着号越来越大，找上门的广告主其实挺多的，每天公众号后台都有很多广告主留言，只不过基本上都被我拒绝掉了。</p><p>但是有的时候松哥推荐其他号主，这个还是希望大家能理解，因为做公众号，或者说写一篇技术干货，从松哥的角度来说，当然是希望文章被越多的人看到越好，毕竟几个小时产出一篇技术干货，结果就十来个人看了，自己心里都凉透了，写作的动力也会减弱，而公众号本身是一个封闭的平台，通过其他号主的推荐，显然可以有效的将自己的文章曝光给更多的小伙伴，因此这个还是希望小伙伴们能多多理解。</p><h3 id="革命尚未成功，同志仍需努力"><a href="#革命尚未成功，同志仍需努力" class="headerlink" title="革命尚未成功，同志仍需努力"></a>革命尚未成功，同志仍需努力</h3><p>松哥经历过公司倒闭，技术栈也从当年如日中天的 Android 切换到如今的 JavaEE，深知这个行业虽然薪水高，但是高处不胜寒，技术之路不进则退，那些火爆一时的技术，让人眼花缭乱的薪水，极有可能冲昏你的头脑，当潮水退去，日子最难过的就是技术菜鸟了。所以，Coding 与学习之路不能停下来，这也是我一直坚持写博客的原因之一，写完一篇博客就会感觉到充实，要是长时间没写，会有很强烈的不安全感，似乎要被技术同行抛弃了。</p><p>自从松哥开始认真做公众号，也认识了很多同行，我最近发现 4 月份认识的公众号主有好几个人都停更了，说明做公众号这个事确实不易。很多时候你都不用拼智商、拼资源、拼人脉，靠死撑，就能够超过很多同行了。</p><p>当然我也希望自己能把做公众号这件事认真坚持下去。小伙伴平时看到了合胃口的文章，顺手点个在看我就很开心啦，如果还能转发一下，那松哥就要膨胀了。</p><p>好了，和大家又叨叨了这么多，最后，5 本松哥自己的签名书《Spring Boot + Vue 全栈开发实战》送给经常来公众号打卡的小伙伴。</p><p>送书规则：大家留言说说<strong>你坚持做的最久的一件事</strong>，我会挑选出 5 位幸运读者，签名版《Spring Boot + Vue 全栈开发实战》包邮到家。也欢迎各位小伙伴多来公众号打卡学习哦，可以有效提高送书时的获奖概率哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就在昨天，松哥的公众号【江南一点雨】迎来了第 20000 个读者，算是一个小小的里程碑吧。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 神器入坑指南！17 个常用快捷键奉上！</title>
    <link href="http://www.javaboy.org/2019/0827/intellij-idea.html"/>
    <id>http://www.javaboy.org/2019/0827/intellij-idea.html</id>
    <published>2019-08-27T05:03:09.000Z</published>
    <updated>2019-09-21T06:03:56.278Z</updated>
    
    <content type="html"><![CDATA[<p>我前几年写过一个 Android Studio 中的快捷键教程，发表在 CSDN 上，最近有小伙伴看我讲 Spring Boot 视频，IDEA 用的还比较溜，问我有没有整理好的快捷键，我一般就直接把当时写的 Android Studio 的快捷键发给他。因为大家知道 as 其实就是基于 IDEA 来做的。</p><a id="more"></a><p>不过鉴于很多小伙伴有快速掌握 IDEA 的需求 ，因此我打算抽空写一个系列的教程，带着大家从头到尾来学习下 IDEA 的使用。欢迎小伙伴们搬好小板凳持续关注。</p><p>本文就当作是一个引子吧。</p><h1 id="我为什么用-IDEA"><a href="#我为什么用-IDEA" class="headerlink" title="我为什么用 IDEA"></a>我为什么用 IDEA</h1><p>曾经我也是 Eclipse 坚定的拥趸者。</p><p>刚开始学 Java 那会，用了一个非常小巧的开发工具 JCreator，只有几 MB 大小，分为社区版和专业版，专业版是收费的。校公选课上老师就用了这个工具，我也跟着用这个，用这个学完了整个 JavaSE，很多基础的算法题我都是用这个工具完成的。比起现在动辄几百 MB 几 G 的 IDE 而言，这个真的可以算作是小巧玲珑。今天还特意去网上搜了一下 JCreator，发现已经好久没有更新了，估计是凉了。</p><p>后来接触到 JavaWeb 之后，就用了 Eclipse 系的 IDE 了。</p><p>Eclipse、MyEclipse 以及 Spring Tool Suite，这些都算是 Eclipse 系的 IDE，其中 STS 使用时间最久了。大学毕业后做过一段时间的 Android 开发，当时用的也是 Eclipse。当时的 Eclipse 用的滚瓜烂熟，从 Eclipse 切换到 IDEA 上犹豫了好久，后来想想我还年轻，程序员之路才刚刚开始，不应该放弃尝试新事物，于是就尝试切换到 Android Studio 上，大概一周时间，各种快捷键就用顺手了，并且慢慢喜欢上了这个开发工具，后来又做回老本行 Java 后端，就顺手用了 IntelliJ IDEA，这两年前后端都做，前端果断选择 WebStorm，快捷键都是一样的，也是很顺手。</p><p>另外 Java 官方还有一个 IDE ，NetBeans，这个工具这几年存在感愈来愈弱。我自己也只是在刚开始学习 Java 的时候好奇尝试过，基本上没用这个做过项目。</p><h1 id="IDEA-介绍"><a href="#IDEA-介绍" class="headerlink" title="IDEA 介绍"></a>IDEA 介绍</h1><p>IDEA 全称 IntelliJ IDEA，由 JetBrains 公司开发，公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。对于 IDEA ，该公司致力于提供一个面向 JVM，功能强大且符合人体工程学的 IDE，所谓的面向 JVM，就是 IDEA 要支持所有运行在 JVM 上的开发语言，例如 Scala，Kotlin 等。</p><p>IDEA 在业界被公认为最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Maven、JUnit、Svn、Git、代码审查等方面的功能可以说是超常的。</p><h1 id="IDEA-中的版本问题"><a href="#IDEA-中的版本问题" class="headerlink" title="IDEA 中的版本问题"></a>IDEA 中的版本问题</h1><p>IDEA 目前共分为两个版本，社区版和旗舰版。社区版功能单一但是免费，使用社区版直接创建 Maven 项目或者 Spring Boot 项目都不支持，旗舰版功能丰富但是收费。我自己因为在 GitHub 上有几个比较受欢迎的开源项目（<a href="https://github.com/lenve），因为这些项目，我申请到" target="_blank" rel="noopener">https://github.com/lenve），因为这些项目，我申请到</a> JetBrains 一整套的官方授权。</p><p>大家安装办法很多，这个应该不用我多说，大伙都有办法搞定。</p><h1 id="IDEA-各种特性"><a href="#IDEA-各种特性" class="headerlink" title="IDEA 各种特性"></a>IDEA 各种特性</h1><p>IDEA 中有很多好玩的特性，我们来逐个看下：</p><ul><li>智能的选取</li></ul><p>有的时候我们可能需要从某个变量到表达式到方法甚至到类，扩充者选取，这个时候就可以使用 Ctrll+W 来实现：</p><p><img src="http://www.javaboy.org/images/tools/1-1.gif" alt></p><ul><li>丰富的导航模式</li></ul><p>IDEA 提供了丰富的导航查看模式，例如 Ctrll+E 显示最近打开过的文件:</p><p><img src="http://www.javaboy.org/images/tools/1-2.png" alt></p><p>Ctrll+N 或者连按两下 Shift，会出现一个类名搜索框，有的时候查看源码用这个非常方便。</p><p><img src="http://www.javaboy.org/images/tools/1-3.png" alt></p><ul><li>历史记录功能</li></ul><p>在 IDEA 中，你可以不用借助 Git 或者 Svn 之类的工具，就可以查看文件修改历史。</p><p><img src="http://www.javaboy.org/images/tools/1-4.gif" alt></p><ul><li>辅助编码</li></ul><p>这个其实算不上两点，因为基本上各种 Java 开发工具都有。Java Bean 中常见的 toString()、hashCode()、equals() 以及所有的get/set 方法都可以自动生成（Windows 是 Alt+Insert，Mac 是 Command +N）。</p><ul><li>XML 的完美支持</li></ul><p>这个算是最赞的功能之一了。Eclipse 中做 Spring 开发，多多少少你得提前准备好一套 Spring 配置模板，而在 IDEA 中则不需要。引入 Spring 依赖之后，就会有 Spring 的 XML 模板，可以直接用。因此，如果使用 IDEA，每个人都可以不用参考任何外部文件配置 SSM。</p><ul><li>列编辑模式</li></ul><p>这个也是我经常使用的功能之一，在有的场景下非常方便，按住 Alt 键就可以快速实现列编辑：</p><p><img src="http://www.javaboy.org/images/tools/1-5.gif" alt></p><ul><li>预置模板</li></ul><p>这个基本上大部分 IDE 都有，只不过在 IDEA 中，提供的内置模板更加丰富，例如 main 方法的生成：</p><p><img src="http://www.javaboy.org/images/tools/1-6.gif" alt></p><p>这是系统自带的，按下 Ctrll+J，然后点击右上角的小灯泡，我们也可以自定义代码模板。</p><ul><li>对 Git 的友好支持</li></ul><p>IDEA 集成了目前大部分的版本工智工具插件，例如 CVS、Svn、Git 等，包括 GitHub 也可以在 IDEA 中非常愉快的使用。</p><ul><li>智能代码</li></ul><p>自动检查代码，发现与预置规范有出入的代码给出提示，自动完成修改。</p><p><img src="http://www.javaboy.org/images/tools/1-7.gif" alt></p><p>当然还有很多其他特性，我就不一一列举了。本系列后面的文章会向大家逐个介绍。</p><h1 id="从-Eclipse-切换过来注意事项"><a href="#从-Eclipse-切换过来注意事项" class="headerlink" title="从 Eclipse 切换过来注意事项"></a>从 Eclipse 切换过来注意事项</h1><p>如果大家是从 Eclipse 上切换到 IDEA ，我总结了以下几个常见问题：</p><ul><li>快捷键问题</li></ul><p>IDEA 支持使用 Eclipse 那一套快捷键，但是个人非常不建议切换，感觉没有必要，增加以后的使用成本，可能还会错过一些 IDEA 中非常棒的功能。当然如果你只是想稍微的尝试一下 IDEA，那就无所谓了。</p><ul><li>保存问题</li></ul><p>IDEA 中没有保存按钮，当然你也不用 Ctrll+S 了，工具会自动帮我们保存，这一点也和 Eclipse 不同。不知道大家有没有在工作中遇到突然停电的问题，我以前遇到过一次，幸好当时使用的是 IDEA，损失不大。</p><ul><li>项目目录</li></ul><p>这个可能是很多初次接触 IDEA 的小伙伴最不习惯的地方了。Eclipse 中一个窗口中可以打开多个 Project，也可以打开多个 Module，但是在 IDEA 中，一个窗口只能打开一个 Project（当然 Module 也是可以打开多个的），如果在 IDEA 中要打开一个新的 Project ，只能再打开一个新的窗口。</p><p>很多人将 IDEA 中的 Project 类比为 Eclipse 中的 workspace，将 IDEA 中的 module 类比为 Eclipse 中的 Project，我认为这个虽然形象但是极为不恰当的，Project 和 Module 就当成正常的 Project 和 Module 就行了。</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><p>这里主要是 Windows 上的快捷键，Mac 上部分快捷键会有一点点小小差异。</p><ul><li>Ctrl+N </li></ul><p>这个可以用来快速搜索类。</p><ul><li>Ctrl+Shift+N</li></ul><p>这个可以用来快速搜索文件。</p><ul><li>Ctrl+ALT+SPACE</li></ul><p>代码提示（类似于ALT+/），这个快捷键使用场景并不多，大部分情况下 IDEA 都会主动提示。</p><ul><li>ALT+F7 </li></ul><p>这个用来查看某一个方法或者变量在哪里被使用了。</p><ul><li>Ctrl+Q</li></ul><p>查看代码提示及内容，这个说起来并没有 Eclipse 方便，Eclipse 中将光标放在类名或者方法名上就会出现 doc，但是在 IDEA 中需要按下 Ctrl+q 才会出现。</p><ul><li>Ctrl+B </li></ul><p>查看类的定义，也可以像 Eclipse 一样，按下 Ctrl 再鼠标左键单击。</p><ul><li>Ctrl+F12</li></ul><p>这个可以列出类中的所有方法。</p><ul><li>SHIFT+F6</li></ul><p>变量或者类名重命名。</p><ul><li>ALT+INSERT</li></ul><p>生成 get/set/toString/hashCode/equals 等方法</p><ul><li>Ctrl+ALT+T </li></ul><p>代码包裹，选中代码后，可以被 for/if/trycache 等代码块包裹：</p><p><img src="http://www.javaboy.org/images/tools/1-8.png" alt></p><ul><li>Ctrl+ALT+B</li></ul><p>查看接口或者抽象类的子类。也可以通过 Ctrl+H 来查看。</p><ul><li>Ctrl+D</li></ul><p>代码复制到新的一行</p><ul><li>Ctrl+Y</li></ul><p>删除当前行</p><ul><li>Ctrl+Alt+↑/↓</li></ul><p>代码向上或者向下移动</p><ul><li>Ctrl+Alt+enter</li></ul><p>在当前行的上面创建新的一行</p><ul><li>Ctrl+enter</li></ul><p>在当前行的下面新建一行（光标不用移动到当前行的最末尾处）。</p><p>好了，本文就当是一个引子吧，后面再来和大家详细聊聊 IDEA 中的其他细节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我前几年写过一个 Android Studio 中的快捷键教程，发表在 CSDN 上，最近有小伙伴看我讲 Spring Boot 视频，IDEA 用的还比较溜，问我有没有整理好的快捷键，我一般就直接把当时写的 Android Studio 的快捷键发给他。因为大家知道 as 其实就是基于 IDEA 来做的。&lt;/p&gt;
    
    </summary>
    
      <category term="IDEA" scheme="http://www.javaboy.org/categories/IDEA/"/>
    
    
      <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>40 篇原创干货，带你进入 Spring Boot 殿堂！</title>
    <link href="http://www.javaboy.org/2019/0826/springboot-guide.html"/>
    <id>http://www.javaboy.org/2019/0826/springboot-guide.html</id>
    <published>2019-08-26T05:03:45.000Z</published>
    <updated>2019-09-21T06:03:47.008Z</updated>
    
    <content type="html"><![CDATA[<p>两个月前，松哥总结过一次已经完成的 Spring Boot 教程，当时感受到了小伙伴们巨大的热情。</p><p>两个月过去了，松哥的 Spring Boot 教程又更新了不少，为了方便小伙伴们查找，这里再给大家做一个索引参考。</p><a id="more"></a><p>需要再次说明的是，这一系列教程不是终点，而是一个起点，松哥后期还会不断完善这个教程，也会持续更新 Spring Boot 最新版本的教程，希望能帮到大家。教程索引如下：</p><h2 id="Spring-Boot2-教程合集"><a href="#Spring-Boot2-教程合集" class="headerlink" title="Spring Boot2 教程合集"></a>Spring Boot2 教程合集</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ol><li><a href="https://mp.weixin.qq.com/s/NC_0oaeBzRjCB34U_ZWxIQ" target="_blank" rel="noopener">纯 Java 代码搭建 SSM 环境</a></li><li><a href="https://mp.weixin.qq.com/s/FMVut8slVZJdxxLf3Y6jLw" target="_blank" rel="noopener">创建一个 Spring Boot 项目的三种方法</a></li><li><a href="https://mp.weixin.qq.com/s/2w6B4fMdbTK_mGjnaMG4BQ" target="_blank" rel="noopener">理解 Spring Boot 项目中的 parent</a></li></ol><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><ol><li><a href="https://mp.weixin.qq.com/s/cUhzpo8zkQq09d8S4WkAsw" target="_blank" rel="noopener">配置文件 application.properties</a></li><li><a href="https://mp.weixin.qq.com/s/dbSBzFICIDPLkj5Tuv2-yA" target="_blank" rel="noopener">yaml配置简介</a></li><li><a href="https://mp.weixin.qq.com/s/WOmOXN_IK0IMjL0_hlAOFA" target="_blank" rel="noopener">Spring Boot 支持 Https</a></li><li><a href="https://mp.weixin.qq.com/s/tKr_shLQnvcQADr4mvcU3A" target="_blank" rel="noopener">徒手撸一个 Spring Boot 中的 Starter</a></li><li><a href="https://mp.weixin.qq.com/s/sUtYqosiHjWYj-QPKY0Iew" target="_blank" rel="noopener">条件注解，Spring Boot 的基石！</a></li></ol><h3 id="整合视图层"><a href="#整合视图层" class="headerlink" title="整合视图层"></a>整合视图层</h3><ol><li><a href="https://mp.weixin.qq.com/s/7tgiuFceyZPHBZcLnPmkfw" target="_blank" rel="noopener">Spring Boot 整合 Thymeleaf</a></li><li><a href="https://mp.weixin.qq.com/s/zXwAy1dMlITqHOdBNeZEKg" target="_blank" rel="noopener">Spring Boot 整合 Freemarker</a></li></ol><h3 id="整合-Web-开发"><a href="#整合-Web-开发" class="headerlink" title="整合 Web 开发"></a>整合 Web 开发</h3><ol><li><a href="https://mp.weixin.qq.com/s/rjscYivhLwg-2ECqps1J-A" target="_blank" rel="noopener">Spring Boot 中的静态资源</a></li><li><a href="https://mp.weixin.qq.com/s/P-iQ0MH1GLJuO5dNHXEgVw" target="_blank" rel="noopener">@ControllerAdvice 注解的三种使用场景！</a></li><li><a href="https://mp.weixin.qq.com/s/w26MvCWQ1RO4CUJrfXi5AA" target="_blank" rel="noopener">Spring Boot 异常处理方案</a></li><li><a href="https://mp.weixin.qq.com/s/ASEJwiswLu1UCRE-e2twYQ" target="_blank" rel="noopener">CORS 解决跨域问题</a></li><li><a href="https://mp.weixin.qq.com/s/3HFAoAl1OjZ_YnLbQLDF3g" target="_blank" rel="noopener">Spring Boot 定义系统启动任务</a></li><li><a href="https://mp.weixin.qq.com/s/_20RYBkjKrB4tdpXI3hBOA" target="_blank" rel="noopener">Spring Boot 中实现定时任务</a></li><li><a href="https://mp.weixin.qq.com/s/iTsTqEeqT9K84S091ycdog" target="_blank" rel="noopener">SpringBoot整合Swagger2</a></li></ol><h3 id="整合持久层技术"><a href="#整合持久层技术" class="headerlink" title="整合持久层技术"></a>整合持久层技术</h3><ol><li><a href="https://mp.weixin.qq.com/s/X4-e1cf3uZafg8XtMJeo_Q" target="_blank" rel="noopener">Spring Boot 整合 JdbcTemplate</a></li><li><a href="https://mp.weixin.qq.com/s/7po83-CAoryo1eglumW42Q" target="_blank" rel="noopener">Spring Boot 整合 JdbcTemplate 多数据源</a></li><li><a href="https://mp.weixin.qq.com/s/HOnX2XRDWrQ9oOKLo1ueKw" target="_blank" rel="noopener">SpringBoot 整合 MyBatis</a></li><li><a href="https://mp.weixin.qq.com/s/9YXwk2-4zIq60WFuy6nXdw" target="_blank" rel="noopener">Spring Boot 整合 MyBatis 多数据源</a></li><li><a href="https://mp.weixin.qq.com/s/Fg5ssXuvabZwEfRMKfpY9Q" target="_blank" rel="noopener">一文读懂 Spring Data Jpa！</a></li></ol><blockquote><p>Spring Boot 整合 Jpa 的教程欢迎大家在松哥的个人博客(<a href="http://www.javaboy.org)上查看，之前发布在公众号上的教程总是被公众号官方判断为有敏感词，但我一直没找到相关敏感词，所以文章总是发送失败。">http://www.javaboy.org)上查看，之前发布在公众号上的教程总是被公众号官方判断为有敏感词，但我一直没找到相关敏感词，所以文章总是发送失败。</a></p></blockquote><h3 id="整合-NoSQL"><a href="#整合-NoSQL" class="headerlink" title="整合 NoSQL"></a>整合 NoSQL</h3><ol><li><a href="https://mp.weixin.qq.com/s/cgDtmjPWTdh44bSlLC0Qsw" target="_blank" rel="noopener">Spring Boot 操作 Redis</a></li><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></li><li><a href="https://mp.weixin.qq.com/s/xs67SzSkMLz6-HgZVxTDFw" target="_blank" rel="noopener">Spring Boot 一个依赖搞定 session 共享</a></li></ol><h3 id="整合缓存框架"><a href="#整合缓存框架" class="headerlink" title="整合缓存框架"></a>整合缓存框架</h3><ol><li><a href="https://mp.weixin.qq.com/s/UpTewC66iJyzq0osm_0cfw" target="_blank" rel="noopener">Spring Boot + Spring Cache + Redis</a></li><li><a href="https://mp.weixin.qq.com/s/i9a3VOf_GMN_UBQ-8tKi3A" target="_blank" rel="noopener">Spring Boot + Spring Cache + Ehcache</a></li></ol><h3 id="构建-REST-服务"><a href="#构建-REST-服务" class="headerlink" title="构建 REST 服务"></a>构建 REST 服务</h3><ol><li><a href="https://mp.weixin.qq.com/s/7uO87SOu93XH2Y3iWxWicg" target="_blank" rel="noopener">10 行代码构建 RESTful 风格应用</a></li></ol><h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><ol><li><a href="https://mp.weixin.qq.com/s/JU_-gn-yZ4VJJXTZvo7nZQ" target="_blank" rel="noopener">Spring Boot 整合 Shiro</a></li><li><a href="https://mp.weixin.qq.com/s/HKJOlatXDS8awBNyCe9JMg" target="_blank" rel="noopener">手把手带你入门 Spring Security！</a></li><li><a href="https://mp.weixin.qq.com/s/oDow2miLIst-R4NNzc_i4g" target="_blank" rel="noopener">Spring Security 登录添加验证码</a></li><li><a href="https://mp.weixin.qq.com/s/X1t-VCxzxIcQKOAu-pJrdw" target="_blank" rel="noopener">SpringSecurity 登录使用 JSON 格式数据</a></li><li><a href="https://mp.weixin.qq.com/s/7D0qJiEIzNuz8VAVvZsXCA" target="_blank" rel="noopener">Spring Security 中的角色继承问题</a></li><li><a href="https://mp.weixin.qq.com/s/riyFQSrkQBQBCyomE__fLA" target="_blank" rel="noopener">Spring Security 中使用 JWT!</a></li></ol><h3 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h3><ol><li><a href="https://mp.weixin.qq.com/s/jS6sy-owtnGitIAf_z894g" target="_blank" rel="noopener">LiveReload 使用</a></li></ol><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><ol><li><a href="https://mp.weixin.qq.com/s/wTr-8VxAnfB9VUnQO6DDxA" target="_blank" rel="noopener">可执行 jar 与普通 jar</a></li></ol><h3 id="企业开发"><a href="#企业开发" class="headerlink" title="企业开发"></a>企业开发</h3><ol><li><a href="https://mp.weixin.qq.com/s/8UiEMpono-hUrRVwvDjUgA" target="_blank" rel="noopener">Spring Boot 整合邮件发送</a></li></ol><h3 id="Spring-Boot-中的-Bug"><a href="#Spring-Boot-中的-Bug" class="headerlink" title="Spring Boot 中的 Bug"></a>Spring Boot 中的 Bug</h3><ol><li><a href="https://mp.weixin.qq.com/s/UDwtZgsxsTILPYpBemwJ1g" target="_blank" rel="noopener">Spring Boot2.1.5 中的 Bug</a></li></ol><h3 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h3><ol><li><a href="https://mp.weixin.qq.com/s/deUN4S34y6xwaWnY4Y4jpg" target="_blank" rel="noopener">15 个 Spring Boot 高频面试题</a></li><li><a href="https://mp.weixin.qq.com/s/L8z4MOfP37fooNpYw-1mQg" target="_blank" rel="noopener">八个开源的 Spring Boot 学习资源</a></li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>另外，还有一件重要的事，就是松哥把微信公众号中文章的案例，都整理到 GitHub 上了，<strong>每个案例都对应了一篇解读的文章</strong>，方便大家学习。松哥以前写博客没养成好习惯，有的案例丢失了，现在在慢慢整理补上。</p><p>GitHub 仓库地址：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a>，欢迎大家 star。已有的案例如下图：</p><p><img src="http://www.javaboy.org/images/boot/19-1.png" alt></p><h2 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h2><p>为了方便大家学习，松哥同时整理了一个在线电子书，地址：<a href="http://springboot.javaboy.org，如下图：" target="_blank" rel="noopener">http://springboot.javaboy.org，如下图：</a></p><p><img src="http://www.javaboy.org/images/boot/32-1.png" alt></p><p>在线电子书内容和公众号上面的一样，不过大家在 pc 端打开方便一些。</p><p>另外需要强调的是，这个总结不是结束，而是一个新的开始，<code>Spring Boot2.1.7</code> 8 月 6 号发布，松哥会继续追踪，继续产出最新版的教程，欢迎小伙伴们继续关注。</p><p>好了，这就是松哥说的干货，大家撸起袖子加油学吧！如果这个资料帮到你了，欢迎转发或者右下角在看哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个月前，松哥总结过一次已经完成的 Spring Boot 教程，当时感受到了小伙伴们巨大的热情。&lt;/p&gt;
&lt;p&gt;两个月过去了，松哥的 Spring Boot 教程又更新了不少，为了方便小伙伴们查找，这里再给大家做一个索引参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>完结撒花！129 集 21 个小时，松哥自制的 Spring Boot2 系列视频教程杀青啦！</title>
    <link href="http://www.javaboy.org/2019/0825/springboot-video.html"/>
    <id>http://www.javaboy.org/2019/0825/springboot-video.html</id>
    <published>2019-08-25T05:04:16.000Z</published>
    <updated>2019-09-21T06:04:04.264Z</updated>
    
    <content type="html"><![CDATA[<p>松哥的 Spring Boot 教程分为几个阶段。</p><h2 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h2><p>松哥最早在 2016 年底的时候开始写 Spring Boot 系列的教程，记得当时在广州上班，年底那段时间在深圳出差，在深圳人生地不熟，下班回到酒店，就开始写博客，写 Spring Boot 教程。</p><a id="more"></a><p>我写的 Spring Boot 教程，不敢说是顶呱呱，但是我相信对大家来说绝对是有用的。我在 CSDN 上写了 400 多篇原创干货，其中访问量最高的几篇竟然都是 Spring Boot 相关的：</p><p><img src="http://www.javaboy.org/images/boot/35-1.png" alt></p><p>Spring Boot 火爆程度可见一斑。不过这些都是基于这是基于早期的 Spring Boot 版本写的（1.4.x）。</p><p>Spring Boot 也算是业界有名的版本帝，版本更新非常快，这也从侧面说明了 Spring Boot 发展速度之快。于是松哥的教程一直没有停。</p><h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><p>我在 2017 年推出了两个 Spring Boot + Vue 前后端分离项目。目前在 GitHub 上 star 数分别超过 8.8k 和 2.8k（<a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a>）。</p><ul><li><a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li><li><a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>为什么这两个项目这么火呢？我也分析过原因，单纯的 Spring Boot 并不难，单纯的 Vue 也不难，相对于 React 和 Angular ，Vue 算是最容易上手的前端框架了。但是要把前后端结合起来，这就有难度了，对前端工程师而言，数据库、Java、Redis 等等，都要花时间去学习，对后端工程师而言，前端的 ES6、webpack、前端工程化、Vue 等等也都要花时间去研究。</p><p>而我这两个开源项目，则打通了前后端，从一个 Java 工程师的角度，带领小伙伴既写后端接口，又写前端页面，快速实现一个常规的企业后台管理系统。</p><p>时代变了，单兵作战、快速迭代才有未来。从这个角度来讲，每个人都不应只专注于后端的 CRUD，我觉得这是这两个开源项目受欢迎的原因。</p><h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>2018 年，应清华社夏老师的邀请，出版了 《Spring Boot + Vue 全栈开发实战》 一书。把 Spring Boot 开发中的知识点做了一番仔细的整理，同时也在自己脑海中将 Spring Boot 教程体系化。</p><p>新书出版至今，已经加印多次，还被国内某一本大学选作教材（<a href="https://mp.weixin.qq.com/s/IJZukUhu-Rec8lF9KQseoQ" target="_blank" rel="noopener">我的第一本书，被选作大学教材了！</a>）。</p><p>加了很多读者的微信，也收到读者不少反馈。我发现一些很简单的知识点，大家照着书写还是有问题，虽然我也提供了很多配套案例，可是还是会收到不少小伙伴的求助，很多东西搞不定。</p><p>于是，继续出教程….</p><h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><p>时间到了 2019 年，Spring Boot 又经过了好几次版本变更，我自己也写了不少新版教程：</p><ul><li><a href="https://mp.weixin.qq.com/s/tm1IqiEvRZwDAb-F5yJ5Aw" target="_blank" rel="noopener">40 篇原创干货，带你进入 Spring Boot 殿堂！</a></li></ul><p>还利用业余时间整理了一个电子书出来：</p><p><img src="http://www.javaboy.org/images/boot/35-2.png" alt></p><p>可以说，在 Spring Boot 布道的路上从未停止。</p><p>除了这些图文教程之外，松哥最近也抽时间录制了一套 Spring Boot 视频教程，这套教程分为两个阶段：</p><ol><li>Spring Boot 精讲系列</li><li>Spring Boot + Vue 项目实战系列</li></ol><p>目前第一阶段的视频已经录制完毕，共 129 集 21 个小时，全程高能无废话，可以说是满满的干货，大家可以看一下目录：</p><p><img src="http://www.javaboy.org/images/boot/35-3.png" alt></p><p>从 9 月份开始，我将开始录制第二阶段的内容，第二阶段我会手把手带领大家做一个 Spring Boot + Vue 的实战项目，具体的项目就是我在 GitHub 上的开源项目 vhr(<a href="https://github.com/lenve/vhr)，该项目目前已经超过" target="_blank" rel="noopener">https://github.com/lenve/vhr)，该项目目前已经超过</a> 8.8k star。这个项目我会带领大家从头开始搭建 Spring Boot + Vue 前后端分离环境，权限设计，RESTful 接口设计等，预计两个月之内更新完毕。</p><p>看过我博客的小伙伴应该知道，我的博客的思路清晰，小伙伴按照我博客的思路都能够做出来效果，我的视频教程和博客的风格一致，一样也是思路清晰条理清楚，这不是我的自夸，有小伙伴的评价为证：</p><p><img src="http://www.javaboy.org/images/boot/35-4.jpg" alt><br><img src="http://www.javaboy.org/images/boot/35-5.jpg" alt><br><img src="http://www.javaboy.org/images/boot/35-6.jpg" alt></p><p>除了这两个视频之外，后期也会录制其他视频教程，目前确定的有 Cloud 和 Redis，其他的还在规划中，不过可以确定的是，每个月都会发布我自己录制的视频教程。</p><p>这些视频的录制，我花费了巨大的时间成本，很多时候我都是晚上十二点才到家，然后早上六点起来录视频,录到八点半，然后去上班：</p><p><img src="http://www.javaboy.org/images/boot/35-7.jpeg" alt></p><p>晚上回到家，除了写博客，还要对录好的视频剪辑，去噪，这是一个细活：</p><p><img src="http://www.javaboy.org/images/boot/35-8.jpeg" alt><br><img src="http://www.javaboy.org/images/boot/35-9.jpeg" alt></p><p>巨大的时间付出，保证了视频的质量，当然也决定了这是一套付费视频。</p><p>我自己还在网上搜集了很多别人录制的视频，这些视频对我来说没有多大成本，都是网络上找的，因此我都免费送给大家了，在我公众号底部菜单里有免费视频，这些免费视频大家都可以领取，我不会拿这些随处可见的视频来卖钱。</p><p>如果大家想要试看视频，可以参考如下两篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/sgjm09_e8ue5blXqPgeXZA" target="_blank" rel="noopener">Spring Boot 整合 Spring Session</a></li><li><a href="https://mp.weixin.qq.com/s/GcMuJ23WVvo2s_6LSgR4fA" target="_blank" rel="noopener">Spring Boot 中 CORS 解决跨域</a></li></ul><p>欢迎大家加入星球，一起学习进步！现在直接扫码加入星球需要 199，这里我提供另外一个优惠的方式，大家可以加我微信，发红包只要 119，然后我手动拉你进星球。星球上每有一个课程完结的时候，就会提升一次价格，早点加入就是优势。<strong>同时为了保证加入星球的小伙伴的权益，我可以向大家保证，你在其他地方不会看到一模一样的免费的整套视频教程，因为这些视频都是我自己录制的，全部都是加密之后发布的，所以请大家放心。</strong></p><p><img src="http://www.javaboy.org/images/boot/35-10.jpeg" alt><br><img src="http://www.javaboy.org/images/boot/35-11.png" alt></p><p>感谢大家信任。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥的 Spring Boot 教程分为几个阶段。&lt;/p&gt;
&lt;h2 id=&quot;2016&quot;&gt;&lt;a href=&quot;#2016&quot; class=&quot;headerlink&quot; title=&quot;2016&quot;&gt;&lt;/a&gt;2016&lt;/h2&gt;&lt;p&gt;松哥最早在 2016 年底的时候开始写 Spring Boot 系列的教程，记得当时在广州上班，年底那段时间在深圳出差，在深圳人生地不熟，下班回到酒店，就开始写博客，写 Spring Boot 教程。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Video" scheme="http://www.javaboy.org/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>一键部署 Spring Boot 到远程 Docker 容器，就是这么秀！</title>
    <link href="http://www.javaboy.org/2019/0819/springboot-docker.html"/>
    <id>http://www.javaboy.org/2019/0819/springboot-docker.html</id>
    <published>2019-08-19T05:04:47.000Z</published>
    <updated>2019-09-21T06:04:12.782Z</updated>
    
    <content type="html"><![CDATA[<p>不知道各位小伙伴在生产环境都是怎么部署 Spring Boot 的，打成 jar 直接一键运行？打成 war 扔到 Tomcat 容器中运行？不过据松哥了解，容器化部署应该是目前的主流方案。</p><a id="more"></a><p>不同于传统的单体应用，微服务由于服务数量众多，在部署的时候出问题的可能性更大，这个时候，结合 Docker 来部署，就可以很好的解决这个问题，这也是目前使用较多的方案之一。</p><p>将 Spring Boot 项目打包到 Docker 容器中部署，有很多不同的方法，今天松哥主要来和大家聊一聊如何将 Spring Boot 项目一键打包到远程 Docker 容器，然后通过运行一个镜像的方式来启动一个 Spring Boot 项目。</p><p>至于其他的 Spring Boot 结合 Docker 的用法，大家不要着急，后续的文章，松哥会和大家慢慢的一一道来。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><h3 id="1-1-准备-Docker"><a href="#1-1-准备-Docker" class="headerlink" title="1.1 准备 Docker"></a>1.1 准备 Docker</h3><p>我这里以 CentOS7 为例来给大家演示。</p><p>首先需要在 CentOS7 上安装好 Docker，这个安装方式网上很多，我就不多说了，我自己去年写过一个 Docker 入门教程，大家可以在公众号后台回复 <code>Docker</code> 获取教程下载地址。</p><p>Docker 安装成功之后，我们首先需要修改 Docker 配置，开启允许远程访问 Docker 的功能，开启方式很简单，修改 <code>/usr/lib/systemd/system/docker.service</code> 文件，加入如下内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://www.javaboy.org/images/boot/34-1.png" alt></p><p>配置完成后，保存退出，然后重启 Docker：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload    </span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><p>Docker 重启成功之后，Docker 的准备工作就算是 OK 了。</p><h3 id="1-2-准备-IDEA"><a href="#1-2-准备-IDEA" class="headerlink" title="1.2 准备 IDEA"></a>1.2 准备 IDEA</h3><p>IDEA 上的准备工作，主要是安装一个 Docker 插件，点击 <code>File-&gt;Settings-&gt;Plugins-&gt;Browse Repositories</code> 如下：</p><p><img src="http://www.javaboy.org/images/boot/34-2.png" alt></p><p>点击右边绿色的 Install 按钮，完成安装，安装完成之后需要重启一下 IDEA。</p><p>IDEA 重启成功之后，我们依次打开 <code>File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Docker</code> ，然后配置一下 Docker 的远程连接地址：</p><p><img src="http://www.javaboy.org/images/boot/34-3.png" alt></p><p>配置一下 Docker 的地址，配置完成后，可以看到下面有一个 Connection successful 提示，这个表示 Docker 已经连接上了。</p><p>如此之后，我们的准备工作就算是 OK 了。</p><h2 id="2-准备项目"><a href="#2-准备项目" class="headerlink" title="2.准备项目"></a>2.准备项目</h2><p>接下来我们来创建一个简单的 Spring Boot 项目（只需要引入 <code>spring-boot-starter-web</code> 依赖即可），项目创建成功之后，我们再创建一个普通的 <code>HelloDockerController</code>，用来做测试，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloDockerController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello docker!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很简单的接口，无需多说。</p><h2 id="3-配置-Dockerfile"><a href="#3-配置-Dockerfile" class="headerlink" title="3.配置 Dockerfile"></a>3.配置 Dockerfile</h2><p>接下来，在项目的根目录下，我创建一个 Dockerfile ，作为我镜像的构建文件，具体位置如下图：</p><p><img src="http://www.javaboy.org/images/boot/34-4.png" alt></p><p>文件内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM hub.c.163.com/library/java:latest</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD target/docker-<span class="hljs-number">0.0</span>.1-SNAPSHOT.jar app.jar</span><br><span class="line">ENTRYPOINT [<span class="hljs-string">"java"</span>,<span class="hljs-string">"-jar"</span>,<span class="hljs-string">"/app.jar"</span>]</span><br></pre></td></tr></table></figure><p>这里只有简单的四行，我说一下：</p><ol><li>Spring Boot 项目的运行依赖 Java 环境，所以我自己的镜像基于 Java 镜像来构建。</li><li>考虑到 Docker 官方镜像下载较慢，我这里使用了网易提供的 Docker 镜像。</li><li>由于 Spring Boot 运行时需要 tmp 目录，这里数据卷配置一个 /tmp 目录出来。</li><li>将本地 target 目录中打包好的 .jar 文件复制一份新的 到 /app.jar。</li><li>最后就是配置一下启动命令，由于我打包的 jar 已经成为 app.jar 了，所以启动命令也是启动 app.jar。</li></ol><p>这是我们配置的一个简单的 Dockerfile。</p><h2 id="4-配置-Maven-插件"><a href="#4-配置-Maven-插件" class="headerlink" title="4.配置 Maven 插件"></a>4.配置 Maven 插件</h2><p>接下来在 pom.xml 文件中，添加如下插件：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dockerHost</span>&gt;</span>http://192.168.66.131:2375<span class="hljs-tag">&lt;/<span class="hljs-name">dockerHost</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>javaboy/$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">imageTags</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">imageTag</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageTag</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">imageTags</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">forceTags</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">forceTags</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">dockerDirectory</span>&gt;</span>$&#123;project.basedir&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">dockerDirectory</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个插件的配置不难理解：</p><ol><li>首先在 execution 节点中配置当执行 mvn package 的时候，顺便也执行一下 docker:build</li><li>然后在 configuration 中分别配置 Docker 的主机地址，镜像的名称，镜像的 tags，其中 dockerDirectory 表示指定 Dockerfile 的位置。</li><li>最后 resource 节点中再配置一下 jar 的位置和名称即可。</li></ol><p>OK，做完这些我们就算大功告成了。</p><h2 id="5-打包运行"><a href="#5-打包运行" class="headerlink" title="5.打包运行"></a>5.打包运行</h2><p>接下来对项目进行打包，打包完成后，项目会自动构建成一个镜像，并且上传到 Docker 容器中，打包方式如下：</p><p><img src="http://www.javaboy.org/images/boot/34-5.png" alt></p><p>打包过程会稍微有一点旧，因为还包含了镜像的构建，特别是第一次打包，需要下载基础镜像，会更慢一些。</p><p>部分打包日志如下（项目构建过程）:</p><p><img src="http://www.javaboy.org/images/boot/34-6.png" alt></p><p>项目打包成功之后，我们就可以在 Docker 容器中看到我们刚刚打包成的镜像了，如下：</p><p><img src="http://www.javaboy.org/images/boot/34-7.png" alt></p><h3 id="5-1-运行方式一"><a href="#5-1-运行方式一" class="headerlink" title="5.1 运行方式一"></a>5.1 运行方式一</h3><p>此时，我们可以直接在 Linux 上像创建普通容器一样创建这个镜像的容器，然后启动，执行如下命令即可：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name javaboy -p 8080:8080 javaboy/docker:0.0.1</span><br></pre></td></tr></table></figure><p>启动成功之后，我们就可以访问容器中的接口了。</p><p>但是这种操作显然还是有点麻烦，结合我们一开始安装的 Docker 插件，这个运行步骤还可以做进一步的简化。</p><h3 id="5-2-运行方式二"><a href="#5-2-运行方式二" class="headerlink" title="5.2 运行方式二"></a>5.2 运行方式二</h3><p>大家注意，此时我们的 IDEA 中多了一个选项，就是 docker，如下：</p><p><img src="http://www.javaboy.org/images/boot/34-8.png" alt></p><p>点击左边的绿色启动按钮，连接上 Docker 容器，连接成功之后，我们就可以看到目前 Docker 中的所有容器和镜像了，当然也包括我们刚刚创建的 Docker 镜像，如下：</p><p><img src="http://www.javaboy.org/images/boot/34-9.png" alt></p><p>此时，我们选中这个镜像，右键单击，即可基于此镜像创建出一个容器，如下图：</p><p><img src="http://www.javaboy.org/images/boot/34-10.png" alt></p><p>我们选择 Create container，然后填入容器的一些必要信息，配置一下容器名称，镜像 ID 会自动填上，暴露的端口使用 Specify 即可，然后写上端口的映射关系：</p><p><img src="http://www.javaboy.org/images/boot/34-11.png" alt></p><p>配置完成后，点击下方的 <code>run</code> 按钮，就可以开始运行了。运行日志如下：</p><p><img src="http://www.javaboy.org/images/boot/34-12.png" alt></p><p>注意，这个日志是在 Docker 的那个窗口里打印出来的。</p><p>项目运行成功之后，在浏览器输入远程服务器的地址，就可以访问了：</p><p><img src="http://www.javaboy.org/images/boot/34-13.png" alt></p><p>如此之后，我们的 Spring Boot 项目就算顺利发布到远程 Docker 容器中了。</p><p>好玩吗？试试！</p><p>本文案例我已经上传到 GitHub，小伙伴们可以参考：<a href="https://github.com/lenve/javaboy-code-samples​" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples​</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道各位小伙伴在生产环境都是怎么部署 Spring Boot 的，打成 jar 直接一键运行？打成 war 扔到 Tomcat 容器中运行？不过据松哥了解，容器化部署应该是目前的主流方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Docker" scheme="http://www.javaboy.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学艺不精，总是掉坑！前后端分离历险记</title>
    <link href="http://www.javaboy.org/2019/0818/springboot-vue-axios.html"/>
    <id>http://www.javaboy.org/2019/0818/springboot-vue-axios.html</id>
    <published>2019-08-18T05:05:17.000Z</published>
    <updated>2019-09-21T06:04:18.790Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot + Vue 这一对技术栈目前看来可以说是非常的火热，关于 Spring Boot 松哥已经写过多篇教程，如：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/tm1IqiEvRZwDAb-F5yJ5Aw" target="_blank" rel="noopener">40 篇原创干货，带你进入 Spring Boot 殿堂！</a></li></ul><p>前后端分离的文章也写过好几篇了，例如：</p><ul><li><a href="https://mp.weixin.qq.com/s/HWRYAR16vLE1XFep6_i1tA" target="_blank" rel="noopener">一个Java程序猿眼中的前后端分离以及Vue.js入门</a></li><li><a href="https://mp.weixin.qq.com/s/aBBJoG0gx1f-M8WFNacpxQ" target="_blank" rel="noopener">前后端分离开发思路探讨</a></li><li><a href="https://mp.weixin.qq.com/s/f5kZM3TVZzdv1tI0THjnIg" target="_blank" rel="noopener">前后端分离时代，Java 程序员的变与不变！</a></li></ul><p>相信大家也从中学到了不少干货。</p><p>老实说，前后端分离其实并不难，前后端分离之后，Java 工程师只需要专心写页面就可以了，在我看来工作可比以前轻松多了。</p><p>如果让一个专业的前端工程师来写前端页面，其实也不难，Vue 算是三大前端框架中最容易上手的了。</p><p>那怎么样就有难度了呢？</p><p>让同一个人既写前端又写后端！</p><p>我知道很多小伙伴在这里总是想不通，很多人 clone 了松哥在 GitHub 上的开源项目下来之后，问的最多的问题就是前后端是怎么通信的？跨域是怎么解决的？刚好松哥最近在这里踩了个坑，就来和大家聊一聊这个问题。</p><h2 id="不是跨域的跨域"><a href="#不是跨域的跨域" class="headerlink" title="不是跨域的跨域"></a>不是跨域的跨域</h2><p>如果你直接在项目中引入 Vue，像用 jQuery 那样用 Vue，那没什么问题，你应该也不会有跨域的疑问。但是如果你做的是单页面应用(SPA)，那么必然会有这样的疑问，跨域问题怎么搞！</p><p>因为在单页面应用中，前端项目可以单独通过 node 启动，它单独占用一个端口，后端项目启动后也是另外一个端口，此时从前端发送请求到后端，由于两者处于不同的端口之上，因此必然存在一个跨域问题。</p><p>但是大家想想，这个跨域有可能只是在开发环境下存在，生产环境下有可能不存在。因为当项目开发完成之后，我们对前端项目进行打包，打包后部署在 Nginx 上或者直接拷贝到后端项目中运行都可以（一般使用前者）：</p><ul><li>如果是前者，后端接口也通过 Nginx 进行映射，这个时候就不会存在跨域问题了</li><li>如果是后者，那就更简单了，部署的时候前后端代码放在一起，更不会有跨域问题了</li></ul><p>因此，解决这个所谓的 “跨域” 问题，我们不能按照传统的思路来（通过 JSONP 或者 CORS），因为在项目真正上线后，所谓的跨域问题可能就会消失。</p><p>那么这个问题怎么解决呢？我们可以在前端 nodejs 中配置请求转发。</p><p>配置请求转发其实不难，不过 vue-cli2 和 vue-cli3 的写法稍有不同，这也是我前一段时间踩坑的地方。</p><h2 id="vue-cli2-方案"><a href="#vue-cli2-方案" class="headerlink" title="vue-cli2 方案"></a>vue-cli2 方案</h2><p>如果我们使用的 vue-cli2 来创建的 SPA 应用，创建成功之后，在项目的 config 目录下有一个 index.js 文件，在这个文件中，我们可以进行请求转发配置，如下图：</p><p><img src="http://www.javaboy.org/images/fe/7-1.png" alt></p><p>配置内容如下：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">  dev: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Paths</span></span><br><span class="line">    assetsSubDirectory: <span class="hljs-string">'static'</span>,</span><br><span class="line">    assetsPublicPath: <span class="hljs-string">'/'</span>,</span><br><span class="line">    proxyTable: &#123;</span><br><span class="line">      <span class="hljs-string">'/'</span>: &#123;</span><br><span class="line">        target: <span class="hljs-string">'http://localhost:8082'</span>,</span><br><span class="line">        changeOrigin: <span class="hljs-literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="hljs-string">'^/'</span>: <span class="hljs-string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="hljs-string">'/ws/*'</span>: &#123;</span><br><span class="line">        target: <span class="hljs-string">'ws://127.0.0.1:8082'</span>,</span><br><span class="line">        ws: <span class="hljs-literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>proxyTable 就是我们配置的转发路由表。这个里边我们一共配置了两个规则：</p><ul><li>第一个是拦截所有 HTTP 请求，将之转发到后端服务器上（前端默认端口是 8080），后端的端口是 8082。至于拦截规则 <code>/</code> ，大家可以自定义，根据实际情况来写，例如所有的 HTTP 请求都有一个统一的前缀 api，那么这里就可以写 <code>/api</code>。</li><li>第二个是拦截所有的 websocket 请求进行转发，我这里给所有的 websocket 请求取了一个统一的前缀 <code>/ws</code></li></ul><p>如果你有更多的拦截规则，继续在这里配置就可以了，这些配置只会在开发环境下生效，当项目编译打包时，这些配置是不会打包进去的，也就是说，项目发布的时候，这些配置是失效的，这个时候我们通过 Nginx 或者将前端代码拷贝到后端，就可以解决生产环境下的跨域问题了（<strong>相当于开发时候的跨域在生产环境下不存在</strong>）。</p><p>相对来说，vue-cli2 在这里的配置还比较容易。</p><h2 id="vue-cli3-方案"><a href="#vue-cli3-方案" class="headerlink" title="vue-cli3 方案"></a>vue-cli3 方案</h2><p>vue-cli3 去年出来后，当时就尝了一把鲜，但是可能 vue-cli2 用久了，一时半会还不愿意接受 vue-cli3 ，于是尝鲜完了之后就放下了，没怎么用了。直到前两天，新项目尝试了一下 vue-cli3，结果在请求转发这块就掉坑里了。</p><p>一开始没多想，还是 vue-cli2 里边的老办法，只不过是在 vue-cli3 创建的项目的 vue.config.js 文件中进行配置，文件位置如下图：</p><p><img src="http://www.javaboy.org/images/fe/7-2.png" alt></p><p>注意，使用 vue-cli3 创建的 SPA 应用，没有 config 目录了，因此请求转发的配置我们要在 vue.config.js 这个配置文件中来配置。</p><p>一开始我直接把 vue-cli2 中的请求转发配置拷贝过来，这样发送 HTTP 请求倒是没问题，但是 websocket 请求一直有问题，后来经过仔细分析，发现这两者在请求转发配置上有一点点差异，我们来看看 vue-cli3 中的请求转发配置(这也是我这里 vue.config.js 文件的完整内容)；</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> proxyObj = &#123;&#125;;</span><br><span class="line">proxyObj[<span class="hljs-string">'/ws'</span>] = &#123;</span><br><span class="line">    ws: <span class="hljs-literal">true</span>,</span><br><span class="line">    target: <span class="hljs-string">"ws://localhost:8081"</span></span><br><span class="line">&#125;;</span><br><span class="line">proxyObj[<span class="hljs-string">'/'</span>] = &#123;</span><br><span class="line">    ws: <span class="hljs-literal">false</span>,</span><br><span class="line">    target: <span class="hljs-string">"http://localhost:8081"</span>,</span><br><span class="line">    changeOrigin: <span class="hljs-literal">true</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">        <span class="hljs-string">'^/'</span>: <span class="hljs-string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: <span class="hljs-string">'localhost'</span>,</span><br><span class="line">        port: <span class="hljs-number">8080</span>,</span><br><span class="line">        proxy: proxyObj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们创建一个 proxyObj 用来放各种代理对象，至于代理的内容这里的则和 vue-cli2 中的没有太多差异。要注意的是，HTTP 请求代理中，多了一个属性 <code>ws: false</code>，用过 vue-cli3 同学可能发现了，如果不加这个属性，浏览器控制台会一直报连不上 socket 的错，加上就没事了。</p><p>最后在 devServer 中指定项目的 host 和 port ，然后再配置一下 proxy 对象就可以啦。</p><p>这就是我们在 vue-cli3 中请求的配置。</p><p>不过这里的配置老实说没有什么难度，做过一次就会啦，要是没做过，头一次可能得折腾半天。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很多小伙伴一直对于前后端分离开发，前后端请求是如何对接的一直有疑问，希望这篇文章能够给你一些启发。如果看懂了，可以点个在看或者转发支持下哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot + Vue 这一对技术栈目前看来可以说是非常的火热，关于 Spring Boot 松哥已经写过多篇教程，如：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>浏览 GitHub 太卡了？教你两招！</title>
    <link href="http://www.javaboy.org/2019/0817/github-chrome.html"/>
    <id>http://www.javaboy.org/2019/0817/github-chrome.html</id>
    <published>2019-08-17T05:05:39.000Z</published>
    <updated>2019-09-21T06:04:26.767Z</updated>
    
    <content type="html"><![CDATA[<p>老实说，GitHub 在国内的使用体验并不算太好，这其中最大的原因就是网络了。</p><a id="more"></a><p>GitHub 访问起来比较卡，这个看起来貌似无解。国内的 gitee 网速倒是可以，但是无法代替 GitHub，个人感觉 gitee 上还是开源项目多一些，工具类库要少一些。</p><p>在网络比较卡的情况下，如果我们想在线查看 GitHub 上项目的源码，是非常的不方便，我们需要不断的进入到某个目录中，然后再退出来，再进入到其他目录中，这样每一次都要加载页面，查看起来非常不便。</p><p>今天松哥就给大家介绍两款浏览器插件 SourceGraph 和 Octotree ，使用这两个浏览器插件可以非常方便的在线查看 GitHub 上项目的源码。Chrome 或者 Firefox 都可以安装此插件。</p><h2 id="SourceGraph"><a href="#SourceGraph" class="headerlink" title="SourceGraph"></a>SourceGraph</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>SourceGraph 是一个依据 Apache2.0 开源协议开源的一个工具，集代码查看、review PR、代码搜索等功能于一身。开发者必备。</p><h3 id="支持的浏览器"><a href="#支持的浏览器" class="headerlink" title="支持的浏览器"></a>支持的浏览器</h3><p>虽然我们大部分情况下可能都是在 Chrome 或者 Firefox 上使用 SourceGraph，不过实际上，SourceGraph 支持的平台可不止 Chrome 和 Firefox ，包括 Vscode 在内的大多数工具都支持，如下：</p><p><img src="http://www.javaboy.org/images/tools/2-1.png" alt></p><p>可以看到有 Chrome、Firefox、VsCode、Jet Brains全家桶(IDEA、WebStorm 等)、Vi、Sublime、Atom。</p><h3 id="支持的平台"><a href="#支持的平台" class="headerlink" title="支持的平台"></a>支持的平台</h3><p>那我们用这个都可以浏览哪些网站的代码呢？除了 GitHub 还有哪些平台也受到支持呢？</p><p><img src="http://www.javaboy.org/images/tools/2-2.png" alt></p><p>可以看到，常见的 GitHub、GitLab、Bitbucket 都获得了支持，还有像 Phabricator、Azure DevOps、AWS CodeCommit 也都有较好的支持。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Firefox 大家可以直接搜索安装，<strong>Chrome，要是上网不方便，松哥已经帮大家下载好了，公众号后台回复 sourcegraph，获取 SourceGraph 离线包下载地址</strong>，离线包下载后之后，直接拖到浏览器上安装即可。</p><p>这里我就来和大家演示下正常安装，在 Chrome 的 Store 中搜索 SourceGraph ，如下：</p><p><img src="http://www.javaboy.org/images/tools/2-3.png" alt></p><p>搜到之后点击右边的 <strong>添加至 Chrome</strong> 按钮即可，我这边因为已经装过了，所以按钮是评分，安装完成之后，浏览器上会多出一个 SourceGraph 图标，如下：</p><p><img src="http://www.javaboy.org/images/tools/2-4.png" alt></p><p>这样 SourceGraph 就安装好了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>此时我们在 GitHub 上打开任意一个项目，以松哥的微人事为例，如下：</p><p><img src="http://www.javaboy.org/images/tools/2-5.png" alt></p><p>可以看到，在项目的 Watch 旁边多了一个按钮，这个按钮就是 SourceGraph，我们点击一下，就可以进入到 SourceGraph 页面：</p><p><img src="http://www.javaboy.org/images/tools/2-6.png" alt></p><p>这就像一个开发工具一样，我们在右边可以轻松的展开项目的包，想看哪个文件就看哪个。上面的搜索框支持正则表达式搜索，可以方便的查找到项目中相关变量的定义。</p><p>SourceGraph 中还可以查看变量被定义或者被引用的位置(这个功能要登录 SourceGraph 后才可以使用)：</p><p><img src="http://www.javaboy.org/images/tools/2-7.png" alt></p><p>是不是都可以当成 IDE 来用了。</p><p>有了这些功能，我们再在 GitHub 上浏览项目就方便多了，小伙伴们不妨试试。</p><h2 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Octotree(<a href="https://www.octotree.io/" target="_blank" rel="noopener">https://www.octotree.io/</a>) 是一款浏览器插件，Chrome 和 Firefox 、Opera 对此都有很好的支持。这个插件可以将 GitHub 上项目代码以树形格式展示，而且在展示的列表中，我们可以下载指定的文件，而不需要下载整个项目。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>Firefox 安装 Octotree 很容易，问题不大，但是 Chrome 上安装，可能有的小伙伴不太方便，松哥已经将 Chrome 上 Octotree 的离线安装包下载好了，大家在我公众号后台回复 octotree 就可以获取下载链接。</p><p>当然，如果大家方便的话，可以直接在 Chrome 商店中搜索，如下：</p><p><img src="http://www.javaboy.org/images/tools/2-8.png" alt></p><p>选择第一个免费版的安装就可以了。</p><p>装好之后，浏览器右上角就会有一个相应的图标，如下：</p><p><img src="http://www.javaboy.org/images/tools/2-9.png" alt></p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>Octotree 安装成功之后，打开一个 GitHub 网页，我们在左边就可以看到 Octotree 插件，如下：</p><p><img src="http://www.javaboy.org/images/tools/2-10.png" alt></p><p>这样就可以快速打开并浏览一个 GitHub 文件了。</p><p>点击文件名前面的图标，就可以在一个单独的网页中打开这个文件。</p><p>好了，这两个神器就说到这里，小伙伴们不妨试试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老实说，GitHub 在国内的使用体验并不算太好，这其中最大的原因就是网络了。&lt;/p&gt;
    
    </summary>
    
      <category term="GitHub" scheme="http://www.javaboy.org/categories/GitHub/"/>
    
    
      <category term="Chrome" scheme="http://www.javaboy.org/tags/Chrome/"/>
    
      <category term="GitHub" scheme="http://www.javaboy.org/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中自定义 SpringMVC 配置，到底继承谁？</title>
    <link href="http://www.javaboy.org/2019/0816/spring-boot-springmvc.html"/>
    <id>http://www.javaboy.org/2019/0816/spring-boot-springmvc.html</id>
    <published>2019-08-16T05:06:09.000Z</published>
    <updated>2019-09-21T06:04:33.447Z</updated>
    
    <content type="html"><![CDATA[<p>用过 Spring Boot 的小伙伴都知道，我们只需要在项目中引入 <code>spring-boot-starter-web</code> 依赖，SpringMVC 的一整套东西就会自动给我们配置好，但是，真实的项目环境比较复杂，系统自带的配置不一定满足我们的需求，往往我们还需要结合实际情况自定义配置。</p><a id="more"></a><p>自定义配置就有讲究了，由于 Spring Boot 的版本变迁，加上这一块本身就有几个不同写法，很多小伙伴在这里容易搞混，今天松哥就来和大家说一说这个问题。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>首先我们需要明确，跟自定义 SpringMVC 相关的类和注解主要有如下四个：</p><ul><li>WebMvcConfigurerAdapter</li><li>WebMvcConfigurer</li><li>WebMvcConfigurationSupport</li><li>@EnableWebMvc</li></ul><p>这四个中，除了第四个是注解，另外三个两个类一个接口，里边的方法看起来好像都类似，但是实际使用效果却大不相同，因此很多小伙伴容易搞混，今天松哥就来和大家聊一聊这个问题。</p><h2 id="WebMvcConfigurerAdapter"><a href="#WebMvcConfigurerAdapter" class="headerlink" title="WebMvcConfigurerAdapter"></a>WebMvcConfigurerAdapter</h2><p>我们先来看 WebMvcConfigurerAdapter，这个是在 Spring Boot 1.x 中我们自定义 SpringMVC 时继承的一个抽象类，这个抽象类本身是实现了 WebMvcConfigurer 接口，然后抽象类里边都是空方法，我们来看一下这个类的声明：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//各种 SpringMVC 配置的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看这个类的注释：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * An implementation of &#123;<span class="hljs-doctag">@link</span> WebMvcConfigurer&#125; with empty methods allowing</span></span><br><span class="line"><span class="hljs-comment"> * subclasses to override only the methods they're interested in.</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@deprecated</span> as of 5.0 &#123;<span class="hljs-doctag">@link</span> WebMvcConfigurer&#125; has default methods (made</span></span><br><span class="line"><span class="hljs-comment"> * possible by a Java 8 baseline) and can be implemented directly without the</span></span><br><span class="line"><span class="hljs-comment"> * need for this adapter</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br></pre></td></tr></table></figure><p>这段注释关于这个类说的很明白了。同时我们也看到，从 Spring5 开始，由于我们要使用 Java8，而 Java8 中的接口允许存在 default 方法，因此官方建议我们直接实现 WebMvcConfigurer 接口，而不是继承 WebMvcConfigurerAdapter 。</p><p><strong>也就是说，在 Spring Boot 1.x 的时代，如果我们需要自定义 SpringMVC 配置，直接继承 WebMvcConfigurerAdapter 类即可。</strong></p><h2 id="WebMvcConfigurer"><a href="#WebMvcConfigurer" class="headerlink" title="WebMvcConfigurer"></a>WebMvcConfigurer</h2><p>根据上一小节的解释，小伙伴们已经明白了，WebMvcConfigurer 是我们在 Spring Boot 2.x 中实现自定义配置的方案。</p><p>WebMvcConfigurer 是一个接口，接口中的方法和 WebMvcConfigurerAdapter 中定义的空方法其实一样，所以用法上来说，基本上没有差别，从 Spring Boot 1.x 切换到 Spring Boot 2.x ，只需要把继承类改成实现接口即可。</p><p>松哥在之前的案例中(<a href="https://mp.weixin.qq.com/s/tm1IqiEvRZwDAb-F5yJ5Aw" target="_blank" rel="noopener">40 篇原创干货，带你进入 Spring Boot 殿堂！</a>)，凡是涉及到自定义 SpringMVC 配置的地方，也都是通过实现 WebMvcConfigurer 接口来完成的。</p><h2 id="WebMvcConfigurationSupport"><a href="#WebMvcConfigurationSupport" class="headerlink" title="WebMvcConfigurationSupport"></a>WebMvcConfigurationSupport</h2><p>前面两个都好理解，还有一个 WebMvcConfigurationSupport ，这个又是干什么用的呢？</p><p>松哥之前有一篇文章中用过这个类，不知道小伙伴们有没有留意，就是下面这篇：</p><ul><li><a href="https://mp.weixin.qq.com/s/NC_0oaeBzRjCB34U_ZWxIQ" target="_blank" rel="noopener">纯 Java 代码搭建 SSM 环境</a></li></ul><p>这篇文章我放弃了 Spring 和 SpringMVC 的 xml 配置文件，转而用 Java 代替这两个 xml 配置。那么在这里我自定义 SpringMVC 配置的时候，就是通过继承 WebMvcConfigurationSupport 类来实现的。在 WebMvcConfigurationSupport 类中，提供了用 Java 配置 SpringMVC 所需要的所有方法。我们来看一下这个方法的摘要：</p><p><img src="http://www.javaboy.org/images/boot/37-1.png" alt></p><p>有一点眼熟，可能有小伙伴发现了，这里的方法其实和前面两个类中的方法基本是一样的。</p><p>在这里首先大家需要明确的是，WebMvcConfigurationSupport 类本身是没有问题的，我们自定义 SpringMVC 的配置是可以通过继承 WebMvcConfigurationSupport 来实现的。但是继承 WebMvcConfigurationSupport 这种操作我们一般只在 Java 配置的 SSM 项目中使用，Spring Boot 中基本上不会这么写，为什么呢？</p><p>小伙伴们知道，Spring Boot 中，SpringMVC 相关的自动化配置是在 WebMvcAutoConfiguration 配置类中实现的，那么我们来看看这个配置类的生效条件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(WebMvcConfigurationSupport.class)</span><br><span class="line"><span class="hljs-meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE + <span class="hljs-number">10</span>)</span><br><span class="line"><span class="hljs-meta">@AutoConfigureAfter</span>(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="line">ValidationAutoConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从这个类的注解中可以看到，它的生效条件有一条，就是当不存在 WebMvcConfigurationSupport 的实例时，这个自动化配置才会生生效。因此，如果我们在 Spring Boot 中自定义 SpringMVC 配置时选择了继承 WebMvcConfigurationSupport，就会导致 Spring Boot 中 SpringMVC 的自动化配置失效。</p><p><strong>Spring Boot 给我们提供了很多自动化配置，很多时候当我们修改这些配置的时候，并不是要全盘否定 Spring Boot 提供的自动化配置，我们可能只是针对某一个配置做出修改，其他的配置还是按照 Spring Boot 默认的自动化配置来，而继承 WebMvcConfigurationSupport 来实现对 SpringMVC 的配置会导致所有的 SpringMVC 自动化配置失效，因此，一般情况下我们不选择这种方案。</strong></p><p>在 Java 搭建的 SSM 项目中(<a href="https://mp.weixin.qq.com/s/NC_0oaeBzRjCB34U_ZWxIQ" target="_blank" rel="noopener">纯 Java 代码搭建 SSM 环境</a>)，因为本身就没什么自动化配置，所以我们使用了继承 WebMvcConfigurationSupport。</p><h2 id="EnableWebMvc"><a href="#EnableWebMvc" class="headerlink" title="@EnableWebMvc"></a>@EnableWebMvc</h2><p>最后还有一个 @EnableWebMvc 注解，这个注解很好理解，它的作用就是启用 WebMvcConfigurationSupport。我们来看看这个注解的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Adding this annotation to an &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Configuration</span>&#125; class imports the Spring MVC</span></span><br><span class="line"><span class="hljs-comment"> * configuration from &#123;<span class="hljs-doctag">@link</span> WebMvcConfigurationSupport&#125;, e.g.:</span></span><br></pre></td></tr></table></figure><p>可以看到，加了这个注解，就会自动导入 WebMvcConfigurationSupport，所以在 Spring Boot 中，我们也不建议使用 @EnableWebMvc 注解，因为它一样会导致 Spring Boot 中的 SpringMVC 自动化配置失效。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不知道上面的解释小伙伴有没有看懂？我再简单总结一下：</p><ol><li>Spring Boot 1.x 中，自定义 SpringMVC 配置可以通过继承 WebMvcConfigurerAdapter 来实现。</li><li>Spring Boot 2.x 中，自定义 SpringMVC 配置可以通过实现 WebMvcConfigurer 接口来完成。</li><li>如果在 Spring Boot 中使用继承 WebMvcConfigurationSupport 来实现自定义 SpringMVC 配置，或者在 Spring Boot 中使用了 @EnableWebMvc 注解，都会导致 Spring Boot 中默认的 SpringMVC 自动化配置失效。</li><li>在纯 Java 配置的 SSM 环境中，如果我们要自定义 SpringMVC 配置，有两种办法，第一种就是直接继承自 WebMvcConfigurationSupport 来完成 SpringMVC 配置，还有一种方案就是实现 WebMvcConfigurer 接口来完成自定义 SpringMVC 配置，如果使用第二种方式，则需要给 SpringMVC 的配置类上额外添加 @EnableWebMvc 注解，表示启用 WebMvcConfigurationSupport，这样配置才会生效。换句话说，在纯 Java 配置的 SSM 中，如果你需要自定义 SpringMVC 配置，你离不开 WebMvcConfigurationSupport ，所以在这种情况下建议通过继承 WebMvcConfigurationSupport 来实现自动化配置。</li></ol><p>不知道小伙伴们有没有看懂呢？有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过 Spring Boot 的小伙伴都知道，我们只需要在项目中引入 &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 依赖，SpringMVC 的一整套东西就会自动给我们配置好，但是，真实的项目环境比较复杂，系统自带的配置不一定满足我们的需求，往往我们还需要结合实际情况自定义配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>七个开源的 Spring Boot 前后端分离项目，一定要收藏！</title>
    <link href="http://www.javaboy.org/2019/0815/springboot-vue.html"/>
    <id>http://www.javaboy.org/2019/0815/springboot-vue.html</id>
    <published>2019-08-15T05:06:25.000Z</published>
    <updated>2019-09-21T06:04:38.152Z</updated>
    
    <content type="html"><![CDATA[<p>前后端分离已经在慢慢走进各公司的技术栈，根据松哥了解到的消息，不少公司都已经切换到这个技术栈上面了。即使贵司目前没有切换到这个技术栈上面，松哥也非常建议大家学习一下前后端分离开发，以免在公司干了两三年，SSH 框架用的滚瓜烂熟，出来却发现自己依然没有任何优势！</p><a id="more"></a><p>其实前后端分离本身并不难，后段提供接口，前端做数据展示，关键是这种思想。很多人做惯了前后端不分的开发，在做前后端分离的时候，很容易带进来一些前后端不分时候的开发思路，结果做出来的产品不伦不类，因此松哥这里给大家整理了几个开源的前后端分离项目，帮助大家快速掌握前后端分离开发技术栈。</p><h2 id="美人鱼"><a href="#美人鱼" class="headerlink" title="美人鱼"></a>美人鱼</h2><ul><li>star 数 3499</li><li>项目地址： <a href="https://gitee.com/mumu-osc/NiceFish" target="_blank" rel="noopener">https://gitee.com/mumu-osc/NiceFish</a></li></ul><p>听名字就知道这是个不错的项目，事实上确实不赖。NiceFish（美人鱼） 是一个系列项目，目标是示范前后端分离的开发模式:前端浏览器、移动端、Electron 环境中的各种开发模式；后端有两个版本：SpringBoot 版本和 SpringCloud 版本，前端有 Angular 、React 以及 Electron 等版本。</p><p>项目效果图：</p><p><img src="http://www.javaboy.org/images/fe/5-1.png" alt></p><h2 id="微人事"><a href="#微人事" class="headerlink" title="微人事"></a>微人事</h2><ul><li>star 数 9313</li><li>项目地址：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li></ul><p>微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot + Vue 开发。项目打通了前后端，并且提供了非常详尽的文档，从 Spring Boot 接口设计到前端 Vue 的开发思路，作者全部都记录在项目的 wiki 中，是不可多得的 Java 全栈学习资料。</p><p>项目效果图:</p><p><img src="http://www.javaboy.org/images/fe/5-3.png" alt></p><p>项目部分文档截图：</p><p><img src="http://www.javaboy.org/images/fe/5-2.png" alt></p><h2 id="bootshiro"><a href="#bootshiro" class="headerlink" title="bootshiro"></a>bootshiro</h2><ul><li>star 数 1370</li><li>项目地址： <a href="https://gitee.com/tomsun28/bootshiro" target="_blank" rel="noopener">https://gitee.com/tomsun28/bootshiro</a></li></ul><p>bootshiro 是基于 Spring Boot + Shiro + JWT 的真正 RESTful URL 资源无状态认证权限管理系统的后端,前端 usthe 。区别于一般项目，该项目提供页面可配置式的、动态的 RESTful api 安全管理支持，并且实现数据传输动态秘钥加密，jwt 过期刷新，用户操作监控等，加固应用安全。</p><p>项目效果图：</p><p><img src="http://www.javaboy.org/images/fe/5-5.png" alt></p><h2 id="open-capacity-platform"><a href="#open-capacity-platform" class="headerlink" title="open-capacity-platform"></a>open-capacity-platform</h2><ul><li>star 数 2643</li><li>项目地址：<a href="https://gitee.com/owenwangwen/open-capacity-platform" target="_blank" rel="noopener">https://gitee.com/owenwangwen/open-capacity-platform</a></li></ul><p>open-capacity-platform 微服务能力开放平台，简称 ocp ，是基于 layui + springcloud 的企业级微服务框架(用户权限管理，配置中心管理，应用管理，….)，其核心的设计目标是分离前后端，快速开发部署，学习简单，功能强大，提供快速接入核心接口能力，其目标是帮助企业搭建一套类似百度能力开放平台的框架。</p><p>项目效果图：</p><p><img src="http://www.javaboy.org/images/fe/5-6.png" alt></p><h2 id="V-部落"><a href="#V-部落" class="headerlink" title="V 部落"></a>V 部落</h2><ul><li>star 数 2902</li><li>项目地址：<a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>V部落是一个多用户博客管理平台，采用 Vue + SpringBoot + ElementUI 开发。<strong>这个项目最大的优势是简单，属于功能完整但是又非常简单的那种，非常非常适合初学者。</strong></p><p>项目效果图：</p><p><img src="http://www.javaboy.org/images/fe/5-4.png" alt></p><h2 id="悟空-CRM"><a href="#悟空-CRM" class="headerlink" title="悟空 CRM"></a>悟空 CRM</h2><ul><li>star 数 650</li><li>项目地址：<a href="https://gitee.com/wukongcrm/72crm-java" target="_blank" rel="noopener">https://gitee.com/wukongcrm/72crm-java</a></li></ul><p>悟空 CRM 是基于 jfinal + vue + ElementUI 的前后端分离 CRM 系统。</p><p>老实说，jfinal 了解下就行了，没必要认真研究，Vue + ElementUI 的组合可以认真学习下、前后端交互的方式可以认真学习下。</p><p><img src="http://www.javaboy.org/images/fe/5-7.png" alt></p><h2 id="paascloud-master"><a href="#paascloud-master" class="headerlink" title="paascloud-master"></a>paascloud-master</h2><ul><li>star 数 5168</li><li>项目地址：<a href="https://github.com/paascloud/paascloud-master" target="_blank" rel="noopener">https://github.com/paascloud/paascloud-master</a></li></ul><p>paascloud-master 核心技术为 SpringCloud + Vue 两个全家桶实现，采取了取自开源用于开源的目标，所以能用开源绝不用收费框架，整体技术栈只有阿里云短信服务是收费的，都是目前 java 前瞻性的框架，可以为中小企业解决微服务架构难题，可以帮助企业快速建站。由于服务器成本较高，尽量降低开发成本的原则，本项目由 10 个后端项目和 3 个前端项目共同组成。真正实现了基于 RBAC、jwt 和 oauth2 的无状态统一权限认证的解决方案，实现了异常和日志的统一管理，实现了 MQ 落地保证 100% 到达的解决方案。</p><p>项目效果图：</p><p><img src="http://www.javaboy.org/images/fe/5-8.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>他山之石，可以攻玉。当我们学会了很多知识点之后，需要一个项目来将这些知识点融会贯通，这些开源项目就是很好的资料。现在前后端分离开发方式日渐火热，松哥也强烈建议大家有空学习下这种开发方式。虽然我们身为 Java 工程师，可是也不能固步自封，看看前端单页面应用怎么构建，看看前端工程化是怎么回事，这些都有助于我们开发出更加合理好用的后端接口。好了，七个开源项目，助力大家在全栈的路上更进一步！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前后端分离已经在慢慢走进各公司的技术栈，根据松哥了解到的消息，不少公司都已经切换到这个技术栈上面了。即使贵司目前没有切换到这个技术栈上面，松哥也非常建议大家学习一下前后端分离开发，以免在公司干了两三年，SSH 框架用的滚瓜烂熟，出来却发现自己依然没有任何优势！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中的同一个 Bug，竟然把我坑了两次！</title>
    <link href="http://www.javaboy.org/2019/0814/springboot-bug.html"/>
    <id>http://www.javaboy.org/2019/0814/springboot-bug.html</id>
    <published>2019-08-14T13:52:22.000Z</published>
    <updated>2019-08-14T13:54:36.228Z</updated>
    
    <content type="html"><![CDATA[<p>真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。</p><a id="more"></a><p>如果大家没看过松哥之前写的 Spring Boot 整合 Spring Session，可以先回顾下：</p><ul><li><a href="https://mp.weixin.qq.com/s/xs67SzSkMLz6-HgZVxTDFw" target="_blank" rel="noopener">Spring Boot 一个依赖搞定 session 共享，没有比这更简单的方案了！</a></li></ul><h1 id="第一次踩坑"><a href="#第一次踩坑" class="headerlink" title="第一次踩坑"></a>第一次踩坑</h1><p>事情是这样的，大概在今年 6 月初的时候，我在项目中使用到了 Session 共享，当时采用的方案就是 Redis+Spring Session。本来这是一个很简单的问题，我在以前的项目中也用过多次这种方案，早已轻车熟路，但是那次有点不对劲，项目启动时候报了如下错误：</p><p><img src="http://www.javaboy.org/images/boot/31-1.png" alt></p><p>一模一样的代码，但是运行就是会出错，我感觉莫名其妙。因为在 Spring Boot 中整合 Spring Session 是一个非常简单的操作，就几行 Redis 的配置而已，我在确认了代码没问题之后，很快想到了可能是版本问题，因为当时 Spring Boot2.1.5 刚刚发布，我喜欢用最新版。于是我尝试将 Spring Boot 的版本切换到 2.1.4 ，切换回去之后，果然就 OK了，再次启动项目又不会报错了。于是基本确定这是 Spring Boot 的版本升级带来的问题。</p><p>但是当时我并没有深究，我以为就是官方出于安全考虑，让你在使用 Redis 时强制加上 Spring Security（因为根据错误提示，很容想到加上 Spring Security 依赖），加上 Spring Security 依赖之后，果然就没有问题了，我也没有多想，这件事就这样过了。​</p><h1 id="第二次踩坑"><a href="#第二次踩坑" class="headerlink" title="第二次踩坑"></a>第二次踩坑</h1><p>前两天我在给星球上的小伙伴录制 Spring Boot 视频的时候，采用了  Spring Boot 最新版 2.1.7，也是 Spring Session，但是在创建项目的时候，忘记添加 Spring Security 依赖了（第一次踩坑之后，我每次用 Spring Session 都会自觉的加上 Spring Security 依赖），运行的时候竟然没报错！我就郁闷了。</p><p>于是我去试了 Spring Boot2.1.4、Spring Boot2.1.6 发现都没有问题，在使用 Spring Session 的时候都不需要添加 Spring Security 依赖，只有 Spring Boot2.1.5 才有这个问题。于是我大概明白了，这可能是一个 Bug，而不是版本升级的新功能。</p><p>这一次，那我就打算追究一下问题的根源。</p><h1 id="源头"><a href="#源头" class="headerlink" title="源头"></a>源头</h1><p>要追究问题的源头，我们当然得从 Spring Session 的自动化配置类开始。</p><p>在 Spring Boot2.1.5 的 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类中，我看到如下源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectProvider&lt;SpringSessionRememberMeServices&gt; springSessionRememberMeServices)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//.....</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer</span><br><span class="line">.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line">springSessionRememberMeServices.ifAvailable((</span><br><span class="line">rememberMeServices) -&gt; cookieSerializer.setRememberMeRequestAttribute(</span><br><span class="line">SpringSessionRememberMeServices.REMEMBER_ME_LOGIN_ATTR));</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这一段源码中我们可以看到，这里使用到了 SpringSessionRememberMeServices ，而这个类中则用到 Spring Security 中相关的类。因此，如果不引入 Spring Security 就会报错。</p><p>我们再来看看 Spring Boot2.1.6 中 <code>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration</code> 类的源码，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(DefaultCookieSerializerCondition.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultCookieSerializer <span class="hljs-title">cookieSerializer</span><span class="hljs-params">(ServerProperties serverProperties)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">map.from(cookie::getMaxAge).to((maxAge) -&gt; cookieSerializer.setCookieMaxAge((<span class="hljs-keyword">int</span>) maxAge.getSeconds()));</span><br><span class="line"><span class="hljs-keyword">if</span> (ClassUtils.isPresent(REMEMBER_ME_SERVICES_CLASS, getClass().getClassLoader())) &#123;</span><br><span class="line"><span class="hljs-keyword">new</span> RememberMeServicesCookieSerializerCustomizer().apply(cookieSerializer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> cookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 Spring Boot2.1.6 中，这个问题已经得到修复。这里就没有 2.1.5 那么冲动了，上来了先用 <code>ClassUtils.isPresent</code> 方法判断了下 REMEMBER_ME_SERVICES_CLASS(<code>org.springframework.security.web.authentication.RememberMeServices</code>) 是否存在，存在的话，才有后面的操作。</p><p>至此，这个问题就总算弄懂了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大家平时遇到问题，如果项目不是很赶的话，可以留意多想想，多追究一下原因，说不定你会有很多意外的收获。我这次就是一个活生生的例子，一开始没多想，后来又发现不对劲，前前后后一折腾，反而又多浪费了一些时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真是郁闷，不过这事又一次提醒我解决问题还是要根治，不能囫囵吞枣，否则相同的问题可能会以不同的形式出现，每次都得花时间去搞。刨根问底，一步到位，再遇到类似问题就可以分分钟解决了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 加入 Https 功能有那么难吗？</title>
    <link href="http://www.javaboy.org/2019/0813/springboot-https.html"/>
    <id>http://www.javaboy.org/2019/0813/springboot-https.html</id>
    <published>2019-08-13T13:47:14.000Z</published>
    <updated>2019-08-14T13:48:17.638Z</updated>
    
    <content type="html"><![CDATA[<p>https 现在已经越来越普及了，特别是做一些小程序或者公众号开发的时候，https 基本上都是刚需了。</p><a id="more"></a><p>不过一个 https 证书还是挺费钱的，个人开发者可以在各个云服务提供商那里申请一个免费的证书。我印象中有效期一年，可以申请 20 个。</p><p>今天要和大家聊的是在 Spring Boot 项目中，如何开启 https 配置，为我们的接口保驾护航。</p><h1 id="https-简介"><a href="#https-简介" class="headerlink" title="https 简介"></a>https 简介</h1><p>我们先来看看什么是 https，根据 wikipedia 上的介绍：</p><blockquote><p>超文本传输安全协议(HyperText Transfer Protocol Secure)，缩写：HTTPS；常称为 HTTP over TLS、HTTP over SSL 或 HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司(Netscape)在 1994 年首次提出，随后扩展到互联网上。</p></blockquote><p>历史上，HTTPS 连接经常用于网络上的交易支付和企业信息系统中敏感信息的传输。在 2000 年代末至 2010 年代初，HTTPS 开始广泛使用，以确保各类型的网页真实，保护账户和保持用户通信，身份和网络浏览的私密性。</p><p>另外，还有一种安全超文本传输协议（S-HTTP），也是 HTTP 安全传输的一种实现，但是 HTTPS 的广泛应用而成为事实上的 HTTP 安全传输实现，S-HTTP并没有得到广泛支持。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先我们需要有一个 https 证书，我们可以从各个云服务厂商处申请一个免费的，不过自己做实验没有必要这么麻烦，我们可以直接借助 Java 自带的 JDK 管理工具 keytool 来生成一个免费的 https 证书。</p><p>进入到 <code>%JAVVA_HOME%\bin</code> 目录下，执行如下命令生成一个数字证书：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias tomcathttps -keyalg RSA -keysize 2048  -keystore D:\javaboy.p12 -validity 365</span><br></pre></td></tr></table></figure><p>命令含义如下：</p><ul><li>genkey 表示要创建一个新的密钥。</li><li>alias 表示 keystore 的别名。</li><li>keyalg 表示使用的加密算法是 RSA ，一种非对称加密算法。</li><li>keysize 表示密钥的长度。</li><li>keystore 表示生成的密钥存放位置。</li><li>validity 表示密钥的有效时间，单位为天。</li></ul><p>具体生成过程如下图：</p><p><img src="http://www.javaboy.org/images/boot/30-1.png" alt></p><p>命令执行完成后 ，我们在 D 盘目录下会看到一个名为 javaboy.p12 的文件。如下图：</p><p><img src="http://www.javaboy.org/images/boot/30-2.png" alt></p><p>有了这个文件之后，我们的准备工作就算是 OK 了。</p><h1 id="引入-https"><a href="#引入-https" class="headerlink" title="引入 https"></a>引入 https</h1><p>接下来我们需要在项目中引入 https。</p><p>将上面生成的 javaboy.p12 拷贝到 Spring Boot 项目的 resources 目录下。然后在 application.properties 中添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.ssl.key-store=classpath:javaboy.p12</span><br><span class="line">server.ssl.key-alias=tomcathttps</span><br><span class="line">server.ssl.key-store-password=111111</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>key-store表示密钥文件名。</li><li>key-alias表示密钥别名。</li><li>key-store-password就是在cmd命令执行过程中输入的密码。</li></ul><p>配置完成后，就可以启动 Spring Boot 项目了，此时如果我们直接使用 Http 协议来访问接口，就会看到如下错误：</p><p><img src="http://www.javaboy.org/images/boot/30-3.png" alt></p><p>改用 https 来访问 ，结果如下：</p><p><img src="http://www.javaboy.org/images/boot/30-4.png" alt></p><p>这是因为我们自己生成的 https 证书不被浏览器认可，不过没关系，我们直接点击继续访问就可以了（实际项目中只需要更换一个被浏览器认可的 https 证书即可）。</p><p><img src="http://www.javaboy.org/images/boot/30-5.png" alt></p><h1 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h1><p>考虑到 Spring Boot 不支持同时启动 HTTP 和 HTTPS ，为了解决这个问题，我们这里可以配置一个请求转发，当用户发起 HTTP 调用时，自动转发到 HTTPS 上。</p><p>具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        TomcatServletWebServerFactory factory = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory()&#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessContext</span><span class="hljs-params">(Context context)</span> </span>&#123;</span><br><span class="line">                SecurityConstraint constraint = <span class="hljs-keyword">new</span> SecurityConstraint();</span><br><span class="line">                constraint.setUserConstraint(<span class="hljs-string">"CONFIDENTIAL"</span>);</span><br><span class="line">                SecurityCollection collection = <span class="hljs-keyword">new</span> SecurityCollection();</span><br><span class="line">                collection.addPattern(<span class="hljs-string">"/*"</span>);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(constraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        <span class="hljs-keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> Connector <span class="hljs-title">createTomcatConnector</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Connector connector = <span class="hljs-keyword">new</span></span><br><span class="line">                Connector(<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line">        connector.setScheme(<span class="hljs-string">"http"</span>);</span><br><span class="line">        connector.setPort(<span class="hljs-number">8081</span>);</span><br><span class="line">        connector.setSecure(<span class="hljs-keyword">false</span>);</span><br><span class="line">        connector.setRedirectPort(<span class="hljs-number">8080</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们配置了 Http 的请求端口为 8081，所有来自 8081 的请求，将被自动重定向到 8080 这个 https 的端口上。</p><p>如此之后，我们再去访问 http 请求，就会自动重定向到 https。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>Spring Boot 中加入 https 其实很方便。如果你使用了 nginx 或者 tomcat 的话，https 也可以发非常方便的配置，从各个云服务厂商处申请到 https 证书之后，官方都会有一个详细的配置教程，一般照着做，就不会错了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;https 现在已经越来越普及了，特别是做一些小程序或者公众号开发的时候，https 基本上都是刚需了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Https" scheme="http://www.javaboy.org/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>一个野生程序员的自我修养</title>
    <link href="http://www.javaboy.org/2019/0812/life.html"/>
    <id>http://www.javaboy.org/2019/0812/life.html</id>
    <published>2019-08-12T13:55:46.000Z</published>
    <updated>2019-08-14T13:58:22.897Z</updated>
    
    <content type="html"><![CDATA[<p>6 月 25 对我来说是一个特殊的日子，2011 年 6 月 25 ，高考分数出来，我去了遥远的南方读书。2015 年 6 月 25 正式步入社会！每年到了这个日子，总不免唏嘘感慨！(今年 6 月 25 我的公众号读者突破了 1w,也算是一个特殊日子吧！)</p><a id="more"></a><h1 id="关于高中"><a href="#关于高中" class="headerlink" title="关于高中"></a>关于高中</h1><p>高中非常幸运，也非常不幸！这得从两方面说起。</p><p>我的母亲虽然生活在农村，但是她在教育我时，非常有眼光。我们镇上的初中，大部分学生的最高目标就是读我们县城最好的高中，但是从我上初一开始，我母亲就希望我能努力学习，以后能去西安读更好的高中上更好的大学。中考结束后，我的成绩还算可以（县里排第二）。那几年，西安的高中喜欢到周边县里去挖人，我有幸被选中，去了西安读高中。高中三年不仅免去了学费，也免去了生活费（住宿+吃饭），相当于高中没有花费家里一分钱，对一个农村孩子来说，这省下了相当大一笔钱，因此我说非常幸运！</p><p>到了西安后，我才发现，我中考的分数，在我高中那个火箭班里，排在中间的位置，我前面大概有 20-30 人左右，真是不敢想象城乡教育差距这么大！</p><p>同学们穿着耐克、阿迪（很多牌子我也不认识，只是知道这很贵），我母亲在我们镇上打工一个月才 600 块钱，两个月的薪水估计才能买人家一件衣服，巨大的落差让我感到自卑，自卑又变得敏感孤僻，这种状态下，很难融入到同学中，经常独来独往，最后这种状态就影响到学习了，最后的自信也崩塌了。</p><p>放假回到家里，看到父母对我的期望，亲戚朋友都觉得我很厉害，只有我自己知道我是一只菜鸟。这种家人殷切期望叠加上自己糟糕的成绩，真是非常痛苦，我刚开始时候两周回一次家，后来高二高三基本一个学期才回去一次（虽然从学校到家里也就 1 个多小时），平时都呆在学校里，这样感觉会稍微好一点。</p><p>高中三年，就是这样浑浑噩噩，孤独、自卑、敏感 ，进而变得冷漠、自私，真是艰难的三年。这也是我说不幸的原因。</p><p>虽然一直状态很差，但是我并没有放弃自己，还是艰难的向前走，从来没有自暴自弃。高考虽然没有达到预期分数，可是也没有太差劲。</p><p>不过话说回来，从农村到城市，这个过程总是要经历，高中经历这么大落差，大学就会好很多了，落差不会这么大。</p><h1 id="关于大学"><a href="#关于大学" class="headerlink" title="关于大学"></a>关于大学</h1><p>2011 年 6 月 25 ，高考分数出来，我基本上没有考虑西安的学校，高中三年，西安真的呆够了。</p><p>从小到大，去过最远的地方就是高一军训的时候从西安去了渭南，坐了 4 个小时大巴车，激动。这次读大学，我想趁机出趟远门，想离西安远一点，甚至不太想再回来。</p><p>大学学费一年 4600 ，家里有压力，后来经过县上红十字会牵线，一个陕北的叔叔资助了我的大学学费，非常感动。</p><p>这几年一直在外奔波，其实我很想有一天也能做类似的事情，4600 一个程序员可能不到一个礼拜就赚到了，资助一个大学生读四年书也没什么压力，但是可能改变的是一个人的一生，大部分程序员可能都生活在一线城市，可能很难想象西北地区或者西南地区一些农村的贫困状态。</p><p>大学离家很远，也是我第一次出远门，但是一走就是一年半。大二过年时候才回家，也是我大学四年唯一一次在家里过年。</p><p>大一寒假没回家，呆在学校盘算着赚点生活费，思来想去只有做家教能赚到钱，也相对轻松一些。然后期末考试结束之后，我就印刷了几十张自我介绍，附上电话，趁着夜色，去附近的公交车站、小区门口都给张贴上，我心想只要有一个电话来，这个东西就算没有白贴。回到宿舍等电话，焦急又期待，要是寒假没有找到合适的工作，白白在学校呆一个月啥事没干，那就太浪费了，而且生活费还有点捉襟见肘，当时想着，如果没人来电话咨询，那我第二天就去更远的小区张贴广告。</p><p>还好后面有两个家长来电话咨询，一个是初中生，另一个是小学生，那个初中生后来足足被我教了 1 年半，直到我后来决定 all in Java 才没有继续做家教了。</p><p>两个家教，一个是下午，另一个是晚上。我放假之前从学校图书馆借了很多书，每天早上起床后，先在宿舍看书到 12 点左右，然后去吃午饭，吃完就从学校出发，先去第一个初中生那里，上完课大概到下午 5 点左右，然后出来吃个饭，再坐公交车在 7 点之前到另外一家。</p><p>有一天晚上九点上完课，外面下大雨，南方冬天的雨很冷，又夹杂着大风，孩子家长给我了 20 块钱让我打车回去，不过我最终还是选择坐公交车回学校了，打车这种高级玩意还是不太舍得，到学校后衣服都湿透了，就是冷。印象中那天好像还是南方的小年夜。</p><p>我从家里去学校的时候，以为海南的冬天很暖和，没有带冬天的衣服，实际海口的冬天也冷的要命，那个时候京东淘宝也还不太会玩，不懂网上购物，也就没买衣服，就那样哆哆嗦嗦的过完了冬天。</p><p>大学做家教，赚了一点点钱，够当时花了，那个时候觉得做家教赚钱简直太容易了。现在回头看看，一个学期辛辛苦苦赚个千把块，做程序员一下就赚回来了。所以我觉得大学还是多多学习专业知识，多多提高专业技能，兼职偶尔做一下也能接受，要是本末倒置了，毕业之后可能就会后悔了。</p><p>其实我不太喜欢跟别人讲这些事，因为我觉得没有谁是容易的，每个人都有自己的心酸，有时间唠叨这个还不如去做点实在的事情提高自己。不过偶尔回忆一下还是可以的，可以鞭策自己继续奋斗，不要放弃。</p><h1 id="关于-Java"><a href="#关于-Java" class="headerlink" title="关于 Java"></a>关于 Java</h1><p>大学学习基本上中规中矩，成绩没有名列前茅，但是也没挂过科，虽然我后面侧重于搞开发，但是专业课也没有荒废，大四拿了优秀毕业论文，算是给大学画上一个完美句号。</p><p>大一的时候一心想转到中文系，没能成功。</p><p>大二时候，校公选课无意间选修了 Java语言程序设计 ，从此打开了一个新世界，后来就走上了自学 Java 的道路。</p><p>刚开始的时候是最艰难的，关于计算机的很多概念都是空白的，学习也没有方向，JavaSE 学完之后都不知道干啥，jsp、html 啥的全都不懂。</p><p>后来在大二第二学期遇到了张老师，非常专业也非常敬业的一位老师，美中不足的是老师做 <code>.NET</code> ，而我当时对 <code>.NET</code> 实在提不起兴趣。但是老师给我指明了很多学习的方向，前端、跨平台、Java 的方向等等，那个时候 HTML5 标准还没公布，老师已经让我关注这方面的信息，在老师的指导下，我感觉慢慢打开了局面，进入到软件开发的世界。</p><p>很多人觉得我幸运，遇到了一位好老师，是的，毕业多年我一直心怀感激。2016 年的时候，老师去广工大出差，我当时刚好在广州上班，学弟告诉我老师去广州了，我赶紧趁老师有时间约出来吃个饭。去年新书出版后，到手的第一本书恭恭敬敬写上祝福，送给了大学老师。</p><p>我大一的时候参加了学生会，但是因为办事不力，被自动剔除了（实际上是因为进去之后我就后悔了，所以消极怠工），后来也没参加其他社团，所以我的时间一直都是大把的，但是我从来没有宅在宿舍睡大觉。</p><p>大一的时候有课上课，没课就去图书馆。有的时候早上一二节没课，三四节有课，我也都会按时起床，先去图书馆，到时间了就去上课。大二的时候，开始搞 Java 之后，我就很少去图书馆了，老师给提供了一个安静的，可以放电脑的学习场地，基本上每天就宅在那里学习。</p><p><img src="http://www.javaboy.org/images/other/46-1.webp" alt></p><p>这张照片是我上大三的时候拍的，那个时候晚上十一点之后回寝室基本是家常便饭。印象深刻的是有一年过年没回家（实际上只有大二过年回家了），除夕晚上在搞数据库行转列，因为第二天打算搞一个 GIS 应用，所以前一天要把数据库搞好，除夕晚上弄到 10 点左右回寝室。</p><p>没有人逼你，但是我们自己总得给自己立一点规矩。</p><p>还好，大二到大四，没有白费。大四春招找工作时候是异常顺利，一周之内拿了三个不同方向的 offer ：Android ，Java Swing 以及 JavaEE。</p><p>学 Java 之后，还有另外一个好处，就是整个人变得自信了，我发现我能做这些事，而且能做的很好，自信之后，精神状态 OK 了，很多事情做起来就很顺了。</p><h1 id="关于爱情"><a href="#关于爱情" class="headerlink" title="关于爱情"></a>关于爱情</h1><p>和女票在一起今年也是第八个年头了。</p><p>我们大一时候在一起，女票一直是学霸，毕业之后保送到西北工业大学读研，期间受学校资助被派去昆士兰大学访学，回来后现在做大数据开发。</p><p>大学四年，毕业之后又异地了三年（她在西安，我在广州），去年 4 月份女票硕士毕业从西安来深圳，终于又团聚了。</p><p>估计松哥很快会结婚了吧~</p><h1 id="关于买房"><a href="#关于买房" class="headerlink" title="关于买房"></a>关于买房</h1><p>买房是我工作至今最为骄傲的事情之一，我觉得这是对我的一个证明。</p><p>我刚毕业的时候，薪水是 5000 ，转正之后是 6250 ，包住。我和女票说我每个月攒 4000 块钱，每年攒 5W，等你研究生毕业的时候，我差不多就能在西安买房了。想法还是太天真，女票去年研究生毕业的时候，西安的房价已经翻了一翻。</p><p>刚工作头半年没攒下钱，第一家公司干了 5 个月就跳槽了，第二年薪水就飞了，不到一年时间翻了三倍。于是在 2016 年 11 月的时候，我用打工攒下来的十几万在西安上车了。买房的时候，家里才只有两万块钱，那几年供我和妹妹读书，家里没有什么积蓄，我妈东拼西凑又借了两万，家里一共出了四万块钱，剩下的十几万首付都是我出的。</p><p>记得刚买完房那会，元气大伤。回到广州都没钱交房租了，和同事合租的房子，交房租的时候让同事先帮忙垫着，等了十多天工资下来了，才缓了口气。</p><p>买房也是一件非常幸运的事情的，西安那个时候只要 20% 的首付，我 11 月交完首付，王永康 12 月当上了西安市委书记，然后西安房价就一路狂飙刹不住车，首付也提高到 30%-40% ，买房还要摇号。真是惊险万分。</p><p><img src="http://www.javaboy.org/images/other/46-2.jpeg" alt></p><p>这是去年 12 月底交房的时候拍的，房子顺利交付，但是我已经不太想回西安了，虽然留在深圳可能会很累，但是以我的性格，回去了，估计也不会过得轻松。所以，先争取吧，或许以后去广州也说不定。</p><h1 id="关于写书"><a href="#关于写书" class="headerlink" title="关于写书"></a>关于写书</h1><p>只要坚持写博客，出书的机会其实有很多。2016 年的时候就有出版社的编辑老师找我，但是当时刚刚工作，实在没啥好写的，于是就婉拒了。后来还是有很多编辑老师找来，我都没有答应。</p><p>2018 年刚过完年，那时候我搞 Spring Boot + Vue 也有一段时间了，自我感觉积累了一点点料，有种想和大伙分享的欲望，另一方面也觉得该为自己的职业生涯留下一点东西，不能就这么默默无闻的搬一辈子砖，在认真考虑后，决定写一本 Spring Boot 相关的书，刚好清华社的夏老师没过几天就加了我微信，邀请我写一本 Spring Boot 相关的书，于是一拍即合，这件事就愉快的定下来了。</p><p>写书期间，每天早上 7 点起床，写到 8 点半然后去上班，晚上 6 点下班后，差不多 7 点开始写，写到 11 点半，周末写两天，拒掉了大部分的社交活动，差不多就这样连续了几个月，交稿的时候有种高考结束的感觉，有的小伙伴可能觉得我是个假程序员，竟然不加班，老实说，敝司确实不怎么加班。</p><p>稿子交到出版社之后，还要经过 <code>排版-&gt;编辑-&gt;改错-&gt;初审-&gt;复审-&gt;终审-&gt;发稿-&gt;申请书号、CIP-&gt;封面设计-&gt;出片-&gt;下厂印制-&gt;发样书-&gt;入库-&gt;上市销售</code> ，整个过程大约持续了三个多月。到今年年初的时候，《Spring Boot + Vue 全栈开发实战》终于出版了，迄今为止，书已经加印了 5 次了。</p><p><img src="http://www.javaboy.org/images/other/46-3.jpg" alt></p><h1 id="关于公众号"><a href="#关于公众号" class="headerlink" title="关于公众号"></a>关于公众号</h1><p>公众号是我在 2017 年申请的，但是一直之前一直没有认真做，今年微笑哥（公众号：纯洁的微笑）给了我一些很实在的建议，也帮了我很多，现在打算用心去做公众号，尽量保持原创，希望有一天能够像微笑哥一样把公众号做好。</p><p>这张照片是华为云云享专家线下活动时候和微笑哥拍的，正是微笑哥的建议促使我认真做公众号，也非常感谢微笑哥的提携与帮助。<br><img src="http://www.javaboy.org/images/other/46-4.jpg" alt></p><p>从小学到初中到高中到大学，读书的时候每个阶段都有对我帮助很大影响很大的老师，直到现在一些做事风格都受老师影响。工作后也有给过我很多帮助的领导同事，现在做公众号也有大佬指导，<strong>虽然感觉一直都很辛苦，但是一直也很幸运。</strong></p><h1 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h1><p>刚毕业的时候，想着以后要回西安发展。现在广深两地呆久了，有点喜欢上这里了，现在很希望以后能留在这里，眼前紧迫的事情就是能早点在这边买房安家，深圳的房子太贵了，广州还可以考虑下，目前也在积极准备中。</p><p>头发依旧茂盛，所以程序员这个工作还能继续干。写代码写文章都是让人舒适惬意的事情，在可预见的未来，应该会一直写下去。</p><p>公众号也是未来坚持的一个方向，也希望能把公众号做好。</p><p>不知不觉码了三千多字，感谢大家看我唠叨了这么多！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;6 月 25 对我来说是一个特殊的日子，2011 年 6 月 25 ，高考分数出来，我去了遥远的南方读书。2015 年 6 月 25 正式步入社会！每年到了这个日子，总不免唏嘘感慨！(今年 6 月 25 我的公众号读者突破了 1w,也算是一个特殊日子吧！)&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://www.javaboy.org/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://www.javaboy.org/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 修改静态资源一定要重启项目才会生效吗？未必！</title>
    <link href="http://www.javaboy.org/2019/0808/springboot-livereload.html"/>
    <id>http://www.javaboy.org/2019/0808/springboot-livereload.html</id>
    <published>2019-08-08T13:40:59.000Z</published>
    <updated>2019-08-14T13:44:26.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾热部署"><a href="#回顾热部署" class="headerlink" title="回顾热部署"></a>回顾热部署</h1><p>Spring Boot 中的热部署相信大家都用过吧，只需要添加 <code>spring-boot-devtools</code> 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：</p><a id="more"></a><ul><li>base classloader</li><li>restart classloader</li></ul><p>其中 base classloader 用来加载那些不会变化的类，例如各种第三方依赖，而 restart classloader 则用来加载那些会发生变化的类，例如你自己写的代码。Spring Boot 中热部署的原理就是当代码发生变化时，base classloader 不变，而 restart classloader 则会被废弃，被另一个新的 restart classloader 代替。在整个过程中，因为只重新加载了变化的类，所以启动速度要被重启快。</p><p>但是有另外一个问题，就是静态资源文件！使用 devtools ，默认情况下当静态资源发生变化时，并不会触发项目重启。虽然我们可以通过配置解决这一问题，但是没有必要！因为静态资源文件发生变化后不需要编译，按理说保存后刷新下就可以访问到了。</p><p>那么如何才能实现静态资源变化后，不编译就能自动刷新呢？ LiveReload 可以帮助我们实现这一功能！</p><h1 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h1><p>devtools 中默认嵌入了 LiveReload 服务器，利用 LiveReload 可以实现静态文件的热部署，LiveReload 可以在资源发生变化时自动触发浏览器更新，LiveReload 支持 Chrome、Firefox 以及 Safari 。以 Chrome 为例，在 Chrome 应用商店搜索 LiveReload ，结果如下图：</p><p><img src="http://www.javaboy.org/images/boot/27-1.png" alt></p><p>将第一个搜索结果添加到 Chrome 中，添加成功后，在 Chrome 右上角有一个 LiveReload 图标</p><p><img src="http://www.javaboy.org/images/boot/27-2.png" alt></p><p>在浏览器中打开项目的页面，然后点击浏览器右上角的 LiveReload 按钮，打开 LiveReload 连接。</p><p><strong>注意：</strong></p><p>LiveReload 是和浏览器选项卡绑定在一起的，在哪个选项卡中打开了 LiveReload，就在哪个选项卡中访问页面，这样才有效果。</p><p>打开 LiveReload 之后，我们启动一个加了 devtools 依赖的 Spring Boot 项目：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时随便在 resources/static 目录下添加一个静态 html 页面，然后启动 Spring Boot 项目，在<strong>打开了 LiveReload 的选项卡中访问 html 页面</strong>。</p><p>访问成功后，我们再去手动修改 html 页面代码，修改成功后，回到浏览器，不用做任何操作，就会发现浏览器自动刷新了，页面已经更新了。</p><p>整个过程中，我的 Spring Boot 项目并没有重启。</p><p>如果开发者安装并且启动了 LiveReload 插件，同时也添加了 devtools 依赖，但是却并不想当静态页面发生变化时浏览器自动刷新，那么可以在 application.properties 中添加如下代码进行配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.livereload.enabled=false</span><br></pre></td></tr></table></figure><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>建议开发者使用 LiveReload 策略而不是项目重启策略来实现静态资源的动态加载，因为项目重启所耗费时间一般来说要超过使用LiveReload 所耗费的时间。</p><p>Firefox 也可以安装 LiveReload 插件，装好之后和 Chrome 用法基本一致，这里不再赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回顾热部署&quot;&gt;&lt;a href=&quot;#回顾热部署&quot; class=&quot;headerlink&quot; title=&quot;回顾热部署&quot;&gt;&lt;/a&gt;回顾热部署&lt;/h1&gt;&lt;p&gt;Spring Boot 中的热部署相信大家都用过吧，只需要添加 &lt;code&gt;spring-boot-devtools&lt;/code&gt; 依赖就可以轻松实现热部署。Spring Boot 中热部署最最关键的原理就是两个不同的 classloader：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="LiveReload" scheme="http://www.javaboy.org/tags/LiveReload/"/>
    
  </entry>
  
  <entry>
    <title>身边的人都说微服务好，好在哪？</title>
    <link href="http://www.javaboy.org/2019/0805/microservice.html"/>
    <id>http://www.javaboy.org/2019/0805/microservice.html</id>
    <published>2019-08-05T13:37:31.000Z</published>
    <updated>2019-08-14T13:40:04.721Z</updated>
    
    <content type="html"><![CDATA[<p>微服务这么火，多少人多少公司都想试试水。</p><a id="more"></a><p>松哥了解到很多小伙伴在找 Java 开发工作时，如果这个公司用的微服务架构，就觉得很牛逼，进去了很有前景，如果没用微服务，甚者还用的是以前的 SSH ，就会觉得没前景，不想去。由此可见微服务在大家心中的分量。</p><p>不过话说回来，并非每一个项目都是适合用微服务架构，也并非每一个公司都需要微服务架构。松哥有个朋友在某网红茶公司做微服务开发，新项目架构师强行上马微服务，结果项目上线后，一个小小的变更都要修改许多服务才能解决，没办法，架构师只能卷铺盖走人了，项目又变回了单体应用。</p><p>我觉得这样的例子不是个案，项目要不要上马微服务，还是要看项目和公司的具体情况，不盲目，不跟风。</p><p>上周和大家聊了单体应用存在的问题：</p><ul><li><a href="https://mp.weixin.qq.com/s/MUPcD_-7NMF32tFLj9zhFQ" target="_blank" rel="noopener">天天吹微服务，单体应用有啥不好？</a></li></ul><p>今天我就来和大家聊一聊微服务到底有哪些好处，又有哪些弊端。</p><h1 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h1><h2 id="大项目可以持续交付"><a href="#大项目可以持续交付" class="headerlink" title="大项目可以持续交付"></a>大项目可以持续交付</h2><p>微服务将一个大系统拆分成很多个互相独立的服务，每一个服务都可以由一个团队去完成，并且配备自己的开发、部署，而且可以独立于其他的团队。每一个团队开发的微服务都可以由自己的代码仓库、以及部署流水线等，互不相扰。</p><p>在微服务中，一个大项目被拆分成 n 多个小项目，每一个小项目都可以非常方便的进行测试、部署，而不会牵一发而动全身，原本需要全员高度警戒的项目上线，现在分散到不同的团队中去完成。</p><p>松哥六月底参加深圳的一个线下技术活动，某在线编程的 CEO 谈到他们公司的发版，说：“我说话的这会儿，我们可能就有新版本在发布。”，这句话令我印象深刻。传统的单体应用，没人敢这么搞，微服务时代，这一切才变得可能。</p><h2 id="易于维护"><a href="#易于维护" class="headerlink" title="易于维护"></a>易于维护</h2><p>这个不必多说，相信大家都理解。</p><p>一个传统的单体应用，如果你新接手，一时半会还不一定能理出一个头绪，而如果是微服务，由于比较小巧玲珑，一个微服务只负责一件事情，很容易理出头绪，然后上手开发。</p><p>并且相对于单体应用，微服务规模都比较小，无论你用 Eclipse 还是 IDEA，项目启动、测试速度都比较快。</p><h2 id="服务可以独立扩展"><a href="#服务可以独立扩展" class="headerlink" title="服务可以独立扩展"></a>服务可以独立扩展</h2><p>独立扩展，可以让我们充分使用硬件资源。</p><p>传统的单体应用，所有的功能模块都写在一起，有的模块是 CPU 运算密集型的，有的模块则是对内存需求更大的，这些模块的代码写在一起，部署的时候，我们只能选择 CPU 运算更强，内存更大的机器，如果采用了了微服务架构，不同的系统独立部署，压力大的时候，可以独立进行集群化部署，这些操作都不会影响到已经运行的其他微服务，非常灵活。</p><h2 id="更强的容错性"><a href="#更强的容错性" class="headerlink" title="更强的容错性"></a>更强的容错性</h2><p>由于每一个微服务都是独立运行的，处理得当，我们在微服务架构中可以实现更好的故障隔离。当一个微服务发生问题时，例如内存泄漏，不会影响到其他的微服务。</p><h2 id="可以灵活的采用最新技术"><a href="#可以灵活的采用最新技术" class="headerlink" title="可以灵活的采用最新技术"></a>可以灵活的采用最新技术</h2><p>传统的单体应用一个非常大的弊端就是技术栈升级非常麻烦，这也是为什么你经常会见到用 10 年前的技术栈做的项目，现在还需要继续开发维护。不是他们不愿意升级，而是升级实在是太麻烦了，伤筋动骨。</p><p>而在微服务架构中，每一个服务都是独立运行的，单个微服务的技术升级则非常容易。你可以随意去尝试你喜欢的最新技术。因为试错成本很低，因此大家可以尽情的玩耍。</p><h1 id="微服务的弊端"><a href="#微服务的弊端" class="headerlink" title="微服务的弊端"></a>微服务的弊端</h1><p>事物都有两面性，微服务也有一些挑战，这些挑战性问题如果处理不好，你使用微服务可能反而适得其反。那么都有哪些问题呢？</p><ul><li><strong>服务的拆分</strong></li></ul><p><strong>个人觉得，这是最大的挑战，我了解到一些公司做微服务，但是服务拆分的乱七八糟。这样到后期越搞越乱，越搞越麻烦，你可能会觉得微服务真坑爹，后悔当初信了松哥的说微服务好的鬼话。</strong></p><ul><li>分布式系统带来的挑战</li></ul><p>记得以前在网上看到过一个段子：</p><blockquote><p>没用分布式架构之前，你只有一个问题：并发性能不足。用了分布式架构，多出了一堆问题：数据如何同步、主键如何产生、如何熔断、分布式事务如何处理……。</p></blockquote><p>这个段子形象的说明了分布式系统带来的挑战。</p><ul><li>多个研发团队的协调管理</li></ul><p>传统的单体应用开发，一个团队管理好就行了，现在不同的团队开发不同的微服务，要协调多个团队共同配合，才能做好微服务开发，这对项目管理提出了挑战。</p><p>好了，本文就先说这么多，大伙可以留言说说你的项目有没有使用微服务，出于什么样的考虑而使用了目前的架构呢？</p><p>参考资料：</p><p>[1] Chris Richardson.微服务架构设计模式[M].北京：机械工业出版社，2019.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微服务这么火，多少人多少公司都想试试水。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>条件注解，Spring Boot 的基石！</title>
    <link href="http://www.javaboy.org/2019/0802/springboot-conditional.html"/>
    <id>http://www.javaboy.org/2019/0802/springboot-conditional.html</id>
    <published>2019-08-02T12:26:48.000Z</published>
    <updated>2019-08-14T12:40:12.788Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot 中的自动化配置确实够吸引人，甚至有人说 Spring Boot 让 Java 又一次焕发了生机，这话虽然听着有点夸张，但是不可否认的是，曾经臃肿繁琐的 Spring 配置确实让人感到头大，而 Spring Boot 带来的全新自动化配置，又确实缓解了这个问题。</p><a id="more"></a><p>你要是问这个自动化配置是怎么实现的，很多人会说不就是 starter 嘛！那么 starter 的原理又是什么呢？松哥以前写过一篇文章，介绍了自定义 starter：</p><ul><li><a href="https://mp.weixin.qq.com/s/tKr_shLQnvcQADr4mvcU3A" target="_blank" rel="noopener">徒手撸一个 Spring Boot 中的 Starter ，解密自动化配置黑魔法！</a></li></ul><p>这里边有一个非常关键的点，那就是<strong>条件注解</strong>，甚至可以说条件注解是整个 Spring Boot 的基石。</p><p>条件注解并非一个新事物，这是一个存在于 Spring 中的东西，我们在 Spring 中常用的 profile 实际上就是条件注解的一个特殊化。</p><p>想要把 Spring Boot 的原理搞清，条件注解必须要会用，因此今天松哥就来和大家聊一聊条件注解。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Spring4 中提供了更加通用的条件注解，让我们可以在满足不同条件时创建不同的 Bean，这种配置方式在 Spring Boot 中得到了广泛的使用，大量的自动化配置都是通过条件注解来实现的，查看松哥之前的 Spring Boot 文章，凡是涉及到源码解读的文章，基本上都离不开条件注解：</p><ul><li><a href="https://mp.weixin.qq.com/s/YXBFFtWvSwR6dVLbaGDxcQ" target="_blank" rel="noopener">干货|最新版 Spring Boot2.1.5 教程+案例合集</a></li></ul><p>有的小伙伴可能没用过条件注解，但是开发环境、生产环境切换的 Profile 多多少少都有用过吧？实际上这就是条件注解的一个特例。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>抛开 Spring Boot，我们来单纯的看看在 Spring 中条件注解的用法。</p><p>首先我们来创建一个普通的 Maven 项目，然后引入 spring-context，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后定义一个 Food 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Food</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">showName</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Food 接口有一个 showName 方法和两个实现类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Food</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"米饭"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Noodles</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Food</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">showName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"面条"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别是 Rice 和 Noodles 两个类，两个类实现了 showName 方法，然后分别返回不同值。</p><p>接下来再分别创建 Rice 和 Noodles 的条件类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoodlesCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> context.getEnvironment().getProperty(<span class="hljs-string">"people"</span>).equals(<span class="hljs-string">"北方人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RiceCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> context.getEnvironment().getProperty(<span class="hljs-string">"people"</span>).equals(<span class="hljs-string">"南方人"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 matches 方法中做条件属性判断，当系统属性中的 people 属性值为 ‘北方人’ 的时候，NoodlesCondition 的条件得到满足，当系统中 people 属性值为 ‘南方人’ 的时候，RiceCondition 的条件得到满足，换句话说，哪个条件得到满足，一会就会创建哪个 Bean 。</p><p>接下来我们来配置 Rice 和 Noodles ：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"food"</span>)</span><br><span class="line">    <span class="hljs-meta">@Conditional</span>(RiceCondition.class)</span><br><span class="line">    <span class="hljs-function">Food <span class="hljs-title">rice</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"food"</span>)</span><br><span class="line">    <span class="hljs-meta">@Conditional</span>(NoodlesCondition.class)</span><br><span class="line">    <span class="hljs-function">Food <span class="hljs-title">noodles</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Noodles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类，大家重点注意两个地方：</p><ul><li>两个 Bean 的名字都为 food，这不是巧合，而是有意取的。两个 Bean 的返回值都为其父类对象 Food。</li><li>每个 Bean 上都多了 @Conditional 注解，当 @Conditional 注解中配置的条件类的 matches 方法返回值为 true 时，对应的 Bean 就会生效。</li></ul><p>配置完成后，我们就可以在 main 方法中进行测试了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ctx.getEnvironment().getSystemProperties().put(<span class="hljs-string">"people"</span>, <span class="hljs-string">"南方人"</span>);</span><br><span class="line">        ctx.register(JavaConfig.class);</span><br><span class="line">        ctx.refresh();</span><br><span class="line">        Food food = (Food) ctx.getBean(<span class="hljs-string">"food"</span>);</span><br><span class="line">        System.out.println(food.showName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们创建一个 AnnotationConfigApplicationContext 实例用来加载 Java 配置类，然后我们添加一个 property 到 environment 中，添加完成后，再去注册我们的配置类，然后刷新容器。容器刷新完成后，我们就可以从容器中去获取 food 的实例了，这个实例会根据 people 属性的不同，而创建出来不同的 Food 实例。</p><p>这个就是 Spring 中的条件注解。</p><h1 id="进化"><a href="#进化" class="headerlink" title="进化"></a>进化</h1><p>条件注解还有一个进化版，那就是 Profile。我们一般利用 Profile 来实现在开发环境和生产环境之间进行快速切换。其实 Profile 就是利用条件注解来实现的。</p><p>还是刚才的例子，我们用 Profile 来稍微改造一下：</p><p>首先 Food、Rice 以及 Noodles 的定义不用变，条件注解这次我们不需要了，我们直接在 Bean 定义时添加 @Profile 注解，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"food"</span>)</span><br><span class="line">    <span class="hljs-meta">@Profile</span>(<span class="hljs-string">"南方人"</span>)</span><br><span class="line">    <span class="hljs-function">Food <span class="hljs-title">rice</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"food"</span>)</span><br><span class="line">    <span class="hljs-meta">@Profile</span>(<span class="hljs-string">"北方人"</span>)</span><br><span class="line">    <span class="hljs-function">Food <span class="hljs-title">noodles</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Noodles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次不需要条件注解了，取而代之的是 @Profile 。然后在 Main 方法中，按照如下方式加载 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        ctx.getEnvironment().setActiveProfiles(<span class="hljs-string">"南方人"</span>);</span><br><span class="line">        ctx.register(JavaConfig.class);</span><br><span class="line">        ctx.refresh();</span><br><span class="line">        Food food = (Food) ctx.getBean(<span class="hljs-string">"food"</span>);</span><br><span class="line">        System.out.println(food.showName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果和上面的案例一样。</p><p>这样看起来 @Profile 注解貌似比 @Conditional 注解还要方便，那么 @Profile 注解到底是什么实现的呢？</p><p>我们来看一下 @Profile 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Conditional</span>(ProfileCondition.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Profile &#123;</span><br><span class="line">String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它也是通过条件注解来实现的。条件类是 ProfileCondition ，我们来看看：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class="line"><span class="hljs-keyword">if</span> (attrs != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Object value : attrs.get(<span class="hljs-string">"value"</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (context.getEnvironment().acceptsProfiles(Profiles.of((String[]) value))) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里就明白了，其实还是我们在条件注解中写的那一套东西，只不过 @Profile 注解自动帮我们实现了而已。</p><p>@Profile 虽然方便，但是不够灵活，因为具体的判断逻辑不是我们自己实现的。而 @Conditional 则比较灵活。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>两个例子向大家展示了条件注解在 Spring 中的使用，它的一个核心思想就是当满足某种条件的时候，某个 Bean 才会生效，而正是这一特性，支撑起了 Spring Boot 的自动化配置。</p><p>好了，本文就说到这里，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot 中的自动化配置确实够吸引人，甚至有人说 Spring Boot 让 Java 又一次焕发了生机，这话虽然听着有点夸张，但是不可否认的是，曾经臃肿繁琐的 Spring 配置确实让人感到头大，而 Spring Boot 带来的全新自动化配置，又确实缓解了这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="条件注解" scheme="http://www.javaboy.org/tags/%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中用 XML 装配 Bean，竟然有五种姿势！</title>
    <link href="http://www.javaboy.org/2019/0801/spring-xml.html"/>
    <id>http://www.javaboy.org/2019/0801/spring-xml.html</id>
    <published>2019-08-01T12:26:27.000Z</published>
    <updated>2019-08-14T12:40:03.344Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot 系列还在不断的更新，有小伙伴和松哥抱怨对 Spring 还不太懂，其实我 2016 年的时候写过一点点 Spring 的教程，但是不够详细，因此，最近决定再挖一个坑，和大家聊聊 Spring 的一些常见用法，也顺便聊聊源码。</p><a id="more"></a><p>Spring 和 Spring Boot 强相关，因此，相信这个系列不会烂尾。</p><p>本想写一些高大上的架构方面的，可是考虑到有很多读者是刚入行的状态，因此还是决定先把 Spring 也和大家过一遍,当然这些东西会穿插着来，尽量满足每一个小伙伴的需求。</p><p>今天就先来和大家聊一聊 Spring 中 XML 装配 Bean 的一些经常被人忽略的细节。</p><p>使用 XML 配置 Spring ，很多人都用过，可能有的小伙伴没认真总结过，今天我们就来稍微总结下，算是开启我们的 Spring 之旅。</p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>XML 配置是最原始最古老的 Bean 的装配方案，曾经我们的项目离不开它，而如今，我们却在慢慢的抛弃它，没办法，时代在进步，我们也要进步呀。为了能看懂前辈们写的代码，我们还是有必要来看一下如何通过 XML 来装配 Bean。</p><p>首先我们来创建一个普通的 Maven 工程（不用创建成 web 工程），创建成功之后，引入 Spring 相关的依赖，这里只要引入 spring-context 即可，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建成功之后，我们再来创建一个 Book 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在 resources 目录下创建一个 beans.xml 文件，作为 Spring 的配置文件，然后在里边配置一个 Book bean，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里，我们在 class 属性中配置类的全路径，id 则表示 bean 的名称，也可以通过 name 属性来指定 bean 的名称，大部分场景下两者无任何差别，会有一些特殊场景下（例如用,隔开多个实例名，两者的处理方案不同），两者有区别。</p><p>然后我们在 Java 代码中加载这个配置文件：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:beans.xml"</span>);</span><br></pre></td></tr></table></figure><p><strong>题外话：</strong></p><p>ClassPathXmlApplicationContext 是配置文件众多的加载方式之一，表示从 classpath 下加载配置文件，这也是较常用的加载方式之一。其他常见的加载方式如下：</p><p><img src="http://www.javaboy.org/images/spring/1-1.png" alt></p><p>从这些不同的实现类中可以看到，我们也可以直接从文件系统中加载 Spring 的 XML 配置文件，使用 FileSystemXmlApplicationContext 类即可。</p><p>配置文件加载完成后，我们就可以从 Spring 容器中去获取这些 Bean 了，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book book = (Book) ctx.getBean(<span class="hljs-string">"book"</span>);</span><br></pre></td></tr></table></figure><p>这个表示根据 id 获取相应的 Bean ，我们也可以通过类型来获取，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book b1 = ctx.getBean(Book.class);</span><br></pre></td></tr></table></figure><p>两种方式推荐第一种。</p><p>第二种通过类型获取 Bean 的方式存在一个问题，就是容器中同一个类如果存在多个实例，通过类型获取肯定会出错。</p><p>但是此时我们获取到的 Bean 中的属性全部为 null，没有值，这是因为我们在配置的时候没有给属性指定值。</p><p>在配置 Bean 时，给 Bean 指定相关的属性值，我们有几种不同的方式：</p><h2 id="1-构造方法指定"><a href="#1-构造方法指定" class="headerlink" title="1.构造方法指定"></a>1.构造方法指定</h2><p>首先我们可以通过构造方法指定 bean 的属性值，前提是我们为 Book 类提供一个有参构造方法（大家在创建有参构造方法时，一定记得再顺手加一个无参构造方法）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(Integer id, String name, Double price)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">        <span class="hljs-keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中，我们就可以通过构造方法注入相关值了：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book2"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"三国演义"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用构造方法注入相关值的时候，也可以使用下标来描述参数的顺序，注意如果使用下标，参数顺序不能错：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book3"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"红楼梦"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"100"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注入成功之后，当我们再次去获取 Bean 的时候，就可以看到这些属性了。</p><h2 id="2-通过属性注入"><a href="#2-通过属性注入" class="headerlink" title="2.通过属性注入"></a>2.通过属性注入</h2><p>当然也可以通过属性注入，这是一种更为常见的方式：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-p名称空间注入"><a href="#3-p名称空间注入" class="headerlink" title="3.p名称空间注入"></a>3.p名称空间注入</h2><p>p 名称空间本质上还是通过属性注入的，只不过写法有些差异，p 名称空间注入方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book5"</span> <span class="hljs-attr">p:id</span>=<span class="hljs-string">"100"</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">"西游记"</span> <span class="hljs-attr">p:price</span>=<span class="hljs-string">"40"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上三种不同的属性注入方式，我给大家演示的都是注入基本数据类型，如果注入的是一个对象的话，只需要通过 ref 属性来指明对象的引用即可。</p></blockquote><h1 id="特殊属性注入"><a href="#特殊属性注入" class="headerlink" title="特殊属性注入"></a>特殊属性注入</h1><p>除了这些基本属性之外，还有一些特殊属性，例如集合、数组、map 等。我们分别来看。</p><h2 id="集合-数组"><a href="#集合-数组" class="headerlink" title="集合/数组"></a>集合/数组</h2><p>集合/数组的注入方式基本一致，首先我们给项目添加一个集合属性，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;String&gt; authors;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性注入时，可以通过 array 节点注入值：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>lisi<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以通过 list 节点注入值：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>lisi<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有一个可能大家使用比较少的方式，就是通过 utils:list 来创建集合属性，然后配置到 Book 属性中去，即可：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span> /&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">utils:list</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"authors"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">utils:list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式比较少见。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 的注入也有几种不同的方式，可以通过属性指定，也可以通过 utils 来搞定，先来看第一种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;String&gt; authors;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; info;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 xml 文件中通过如下方式指定属性值：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"zhangsan"</span>/&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以通过 utils 来指定 map 的值，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"info"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">utils:map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"info"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"lisi"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"age"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"98"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">utils:map</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><p>properties 属性也是一样的配置方案。既可以通过 props 属性指定，也可以通过 utils 来指定，例如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> Double price;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;String&gt; authors;</span><br><span class="line">    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; info;</span><br><span class="line">    <span class="hljs-keyword">private</span> Properties info2;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 props 属性指定方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span> /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"info"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info2"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"name"</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"age"</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 utils 指定方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book4"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"水浒传"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"price"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"99"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authors"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"authors"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"info"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info2"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"info2"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">utils:properties</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"info2"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"name"</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"age"</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">utils:properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了这几种装配方式之外，我们也可以通过工厂方法装配。</p><h1 id="工厂方法装配"><a href="#工厂方法装配" class="headerlink" title="工厂方法装配"></a>工厂方法装配</h1><p>工厂方法装配可以分为静态工厂和实例工厂两种方式，我们分别来看。</p><h2 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h2><p>静态工厂方法装配需要我们先创建一个静态工厂方法，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookFactory</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Book <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Book();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中装配：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.BookFactory"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book6"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>此时我们去容器中获取 book6 这个实例，拿到的就是你在静态工厂中返回的 Book 实例。</p><h2 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h2><p>实例工厂方法则是指工厂方法是一个普通方法，不是静态的，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookFactory2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Book();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 XML 文件中，我们需要首先配置 BookFactory2 的实例，然后才能调用实例中的方法获取 Book 对象，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.BookFactory2"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bookFactory2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring.Book"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"book7"</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"bookFactory2"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>工厂方法装配的价值在哪里呢？</p><p>例如 Druid 中的 DataSource 对象，通过 <code>DruidDataSourceBuilder.create().build()</code> 方法来构建，如果我们想在 XML 中做这个配置，显然不太容易，此时就可以使用工厂方法装配了。</p><p>好了，这就是 XML 装配 Bean 的一个简单介绍，比较简单，但是为了知识的完整性，我还是稍微写了下，能看到这里的都是真爱啊！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot 系列还在不断的更新，有小伙伴和松哥抱怨对 Spring 还不太懂，其实我 2016 年的时候写过一点点 Spring 的教程，但是不够详细，因此，最近决定再挖一个坑，和大家聊聊 Spring 的一些常见用法，也顺便聊聊源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>天天吹微服务，单体应用有啥不好？</title>
    <link href="http://www.javaboy.org/2019/0729/microservice.html"/>
    <id>http://www.javaboy.org/2019/0729/microservice.html</id>
    <published>2019-07-29T00:17:40.000Z</published>
    <updated>2019-07-29T00:23:09.251Z</updated>
    
    <content type="html"><![CDATA[<p>单体应用确实有问题！</p><p>最近在研究微服务架构，有一点点心得，打算在公众号上写几篇文章和大家慢慢分享下。</p><a id="more"></a><p>这个话题有点大，我会分几篇文章和大家慢慢说，今天就先来说说传统的单体应用有哪些弊端，正是因为单体应用存在的弊端，使得我们不得不考虑发展微服务。</p><p>人类发展的历史就是一个社会分工不断细化的历史，从这个角度来讲，微服务这种将一个复杂的大项目拆分为众多小项目，然后程序员分工合作，共同完成项目，这种协作方式是符合历史潮流的。</p><p>这是我们站在今天的角度来说的，曾经的单体应用也是先进生产力的代表。</p><p>但是，随着互联网的发展，我们对一个系统的要求越来越高，单体应用已经很难适应当前的开发，因此在回答我们为什么要使用微服务这个问题之前，我们有必要来聊一聊单体应用目前都面临哪些问题。</p><h1 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h1><h2 id="1-项目过度复杂"><a href="#1-项目过度复杂" class="headerlink" title="1.项目过度复杂"></a>1.项目过度复杂</h2><p>你要创建一个简单的用户管理系统，二话不说，直接创建 Maven 项目然后开干就完事了，这没问题，因为这很简单。</p><p>但是你要说想搞一个淘宝网站，或者你想搞一个用友 U8 系统，那你恐怕就得先慢慢设计系统架构了。单体应用，由于就是一个项目，所有的功能都是写在一个项目中，不可避免的出现项目过度复杂的情况。而且这种复杂情况会不断恶化。</p><p>有的小伙伴可能有这样的经验，刚入职了一家公司，新接手了一个项目，上面催的很急，让你赶快修复几个 bug ，项目复杂，光是实体类的包就有好几个 bean、model、pojo 等，一个项目被很多人经手之后，到你手里，早已经一团乱麻，你小心翼翼尽量不碰触到已有的功能，终于修完了几个 bug，搞了俩礼拜，你觉得这个项目太坑爹了，不想干了，于是接盘侠从你手里接到了一个复杂度又上升了一步的项目。</p><p>就这样，一个原本简简单单的单体项目，在变复杂的路上一去不复返。</p><h2 id="2-开发速度缓慢"><a href="#2-开发速度缓慢" class="headerlink" title="2.开发速度缓慢"></a>2.开发速度缓慢</h2><p>单体应用开发速度缓慢，因为单体应用复杂了之后，项目变得异常臃肿而且庞大，每一次编译构建、运行以及测试，都需要花费大量时间，而且如果测试有问题，又得从头来一遍，注意，这里的每一次从头编译构建等都是整个项目的从头编译构建。</p><p>即使你可能只要修改某一个参数，你也得把上面整个流程走一遍，相当于每一次的修改都是牵一发而动全身的操作。</p><p>速度没法快。</p><h2 id="3-不易扩展"><a href="#3-不易扩展" class="headerlink" title="3.不易扩展"></a>3.不易扩展</h2><p>项目中不同模块对计算机的性能要求不一样，例如使用 Redis 来保存了大量的热点数据，那么我们希望服务器的内存非常大，另外有一个模块涉及到了图片处理，我们又希望服务器的 CPU 非常强，如果是单体应用部署的话，那么这些条件服务器都要满足。</p><h2 id="4-技术栈不易扩展"><a href="#4-技术栈不易扩展" class="headerlink" title="4.技术栈不易扩展"></a>4.技术栈不易扩展</h2><p>单体应用还有一个劣势就是技术栈不易扩展，一旦你选定了某一个技术栈来开发项目，以后很难在技术栈上做切换。有的公司还会自己搞一套系统，这种在当时看起来好像都没有啥问题，可是经过几年之后，回头再看，已经很过时了，很 low 了，当初设计系统的人可能已经离职了，刚入职的新手也不敢动这个老古董，只能在这个老古董上面忍痛开发。</p><p>有的时候，有一个服务需要处理高并发，你很想用 Go 语言来做，可是做不到，没法引入其他语言。</p><p>这些都是单体应用的劣势，如果有微服务，上面这些问题都将得到解决。</p><h1 id="曾经的优势"><a href="#曾经的优势" class="headerlink" title="曾经的优势"></a>曾经的优势</h1><p>当然，事物都是有两面性的，单体应用也有它自己的优势，例如：</p><ul><li>开发简单，一个 IDE 就可以快速构建出一个单体应用</li><li>测试简单</li><li>部署简单，Tomcat 安装好之后，应用扔上去就行了</li><li>集群化部署也很容易，多个 Tomcat + 一个 Nginx 分分钟就搭建好集群环境了</li></ul><p>这么多优势，还是难掩劣势。</p><p>不过大家在做项目的时候，还是要结合实际情况来选择，不能因为微服务厉害，所有项目都是微服务，如果你仅仅只想做一个用户的增删改查，那么很明显，创建一个简单的单体应用是最合适的。</p><p>好了，本文主要和大家分享了传统单体应用存在的一些问题，正是因为这些问题，我们需要引入微服务，下篇文章，我们就来看看微服务有哪些优势。</p><p>参考资料：</p><p>[1] Chris Richardson.微服务架构设计模式[M].北京：机械工业出版社，2019.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单体应用确实有问题！&lt;/p&gt;
&lt;p&gt;最近在研究微服务架构，有一点点心得，打算在公众号上写几篇文章和大家慢慢分享下。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="单体应用" scheme="http://www.javaboy.org/tags/%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>手把手带你入门 Spring Security！</title>
    <link href="http://www.javaboy.org/2019/0725/springboot-springsecurity.html"/>
    <id>http://www.javaboy.org/2019/0725/springboot-springsecurity.html</id>
    <published>2019-07-25T00:44:50.000Z</published>
    <updated>2019-07-25T00:47:08.592Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。</p><a id="more"></a><p>相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。</p><p>自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。</p><p>因此，一般来说，常见的安全管理技术栈的组合是这样的：</p><ul><li>SSM + Shiro</li><li>Spring Boot/Spring Cloud + Spring Security</li></ul><p><strong>注意，这只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。</strong></p><p>我们来看下具体使用。</p><h1 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h1><p>在 Spring Boot 中使用 Spring Security 非常容易，引入依赖即可：</p><p><img src="http://www.javaboy.org/images/boot/25-1.png" alt></p><p>pom.xml 中的 Spring Security 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只要加入依赖，项目的所有接口都会被自动保护起来。</p><h1 id="2-初次体验"><a href="#2-初次体验" class="headerlink" title="2.初次体验"></a>2.初次体验</h1><p>我们创建一个 HelloController:</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问 <code>/hello</code> ，需要登录之后才能访问。</p><p><img src="http://www.javaboy.org/images/boot/25-2.png" alt></p><p>当用户从浏览器发送请求访问 <code>/hello</code> 接口时，服务端会返回 <code>302</code> 响应码，让客户端重定向到 <code>/login</code> 页面，用户在 <code>/login</code> 页面登录，登陆成功之后，就会自动跳转到 <code>/hello</code> 接口。</p><p>另外，也可以使用 <code>POSTMAN</code> 来发送请求，使用 <code>POSTMAN</code> 发送请求时，可以将用户信息放在请求头中（这样可以避免重定向到登录页面）：</p><p><img src="http://www.javaboy.org/images/boot/25-3.png" alt></p><p>通过以上两种不同的登录方式，可以看出，Spring Security 支持两种不同的认证方式：</p><ul><li>可以通过 form 表单来认证</li><li>可以通过 HttpBasic 来认证</li></ul><h1 id="3-用户名配置"><a href="#3-用户名配置" class="headerlink" title="3.用户名配置"></a>3.用户名配置</h1><p>默认情况下，登录的用户名是 <code>user</code> ，密码则是项目启动时随机生成的字符串，可以从启动的控制台日志中看到默认密码：</p><p><img src="http://www.javaboy.org/images/boot/25-4.png" alt></p><p>这个随机生成的密码，每次启动时都会变。对登录的用户名/密码进行配置，有三种不同的方式：</p><ul><li>在 application.properties 中进行配置</li><li>通过 Java 代码配置在内存中</li><li>通过 Java 从数据库中加载</li></ul><p>前两种比较简单，第三种代码量略大，本文就先来看看前两种，第三种后面再单独写文章介绍，也可以参考我的<a href>微人事项目</a>。</p><h2 id="3-1-配置文件配置用户名-密码"><a href="#3-1-配置文件配置用户名-密码" class="headerlink" title="3.1 配置文件配置用户名/密码"></a>3.1 配置文件配置用户名/密码</h2><p>可以直接在 application.properties 文件中配置用户的基本信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=123</span><br></pre></td></tr></table></figure><p>配置完成后，重启项目，就可以使用这里配置的用户名/密码登录了。</p><h2 id="3-2-Java-配置用户名-密码"><a href="#3-2-Java-配置用户名-密码" class="headerlink" title="3.2 Java 配置用户名/密码"></a>3.2 Java 配置用户名/密码</h2><p>也可以在 Java 代码中配置用户名密码，首先需要我们创建一个 Spring Security 的配置类，集成自 WebSecurityConfigurerAdapter 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//下面这两行配置表示在内存中配置了两个用户</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"javaboy"</span>).roles(<span class="hljs-string">"admin"</span>).password(<span class="hljs-string">"$2a$10$OR3VSksVAmCzc.7WeaRPR.t0wyCsIj24k0Bne8iKWV1o.V9wsP8Xe"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="hljs-string">"lisi"</span>).roles(<span class="hljs-string">"user"</span>).password(<span class="hljs-string">"$2a$10$p1H8iWa8I4.CA.7Z8bwLjes91ZpY.rYREGHQEInNtAp4NzL6PLKxi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在 configure 方法中配置了两个用户，用户的密码都是加密之后的字符串(明文是 123)，从 Spring5 开始，强制要求密码要加密，如果非不想加密，可以使用一个过期的 PasswordEncoder 的实例 NoOpPasswordEncoder，但是不建议这么做，毕竟不安全。</p><p>Spring Security 中提供了 BCryptPasswordEncoder 密码编码工具，可以非常方便的实现密码的加密加盐，相同明文加密出来的结果总是不同，这样就不需要用户去额外保存<code>盐</code>的字段了，这一点比 Shiro 要方便很多。</p><h1 id="4-登录配置"><a href="#4-登录配置" class="headerlink" title="4.登录配置"></a>4.登录配置</h1><p>对于登录接口，登录成功后的响应，登录失败后的响应，我们都可以在 WebSecurityConfigurerAdapter 的实现类中进行配置。例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    VerifyCodeFilter verifyCodeFilter;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        http</span><br><span class="line">        .authorizeRequests()<span class="hljs-comment">//开启登录配置</span></span><br><span class="line">        .antMatchers(<span class="hljs-string">"/hello"</span>).hasRole(<span class="hljs-string">"admin"</span>)<span class="hljs-comment">//表示访问 /hello 这个接口，需要具备 admin 这个角色</span></span><br><span class="line">        .anyRequest().authenticated()<span class="hljs-comment">//表示剩余的其他接口，登录之后就能访问</span></span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        <span class="hljs-comment">//定义登录页面，未登录时，访问一个需要登录之后才能访问的接口，会自动跳转到该页面</span></span><br><span class="line">        .loginPage(<span class="hljs-string">"/login_p"</span>)</span><br><span class="line">        <span class="hljs-comment">//登录处理接口</span></span><br><span class="line">        .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">        <span class="hljs-comment">//定义登录时，用户名的 key，默认为 username</span></span><br><span class="line">        .usernameParameter(<span class="hljs-string">"uname"</span>)</span><br><span class="line">        <span class="hljs-comment">//定义登录时，用户密码的 key，默认为 password</span></span><br><span class="line">        .passwordParameter(<span class="hljs-string">"passwd"</span>)</span><br><span class="line">        <span class="hljs-comment">//登录成功的处理器</span></span><br><span class="line">        .successHandler(<span class="hljs-keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="hljs-string">"success"</span>);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .failureHandler(<span class="hljs-keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="hljs-string">"fail"</span>);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()<span class="hljs-comment">//和表单登录相关的接口统统都直接通过</span></span><br><span class="line">            .and()</span><br><span class="line">            .logout()</span><br><span class="line">            .logoutUrl(<span class="hljs-string">"/logout"</span>)</span><br><span class="line">            .logoutSuccessHandler(<span class="hljs-keyword">new</span> LogoutSuccessHandler() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="hljs-string">"logout success"</span>);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .httpBasic()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在 successHandler 方法中，配置登录成功的回调，如果是前后端分离开发的话，登录成功后返回 JSON 即可，同理，failureHandler 方法中配置登录失败的回调，logoutSuccessHandler 中则配置注销成功的回调。</p><h1 id="5-忽略拦截"><a href="#5-忽略拦截" class="headerlink" title="5.忽略拦截"></a>5.忽略拦截</h1><p>如果某一个请求地址不需要拦截的话，有两种方式实现：</p><ul><li>设置该地址匿名访问</li><li>直接过滤掉该地址，即该地址不走 Spring Security 过滤器链</li></ul><p>推荐使用第二种方案，配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="hljs-string">"/vercode"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 另外一个强大之处就是它可以结合 OAuth2 ，玩出更多的花样出来，这些我们在后面的文章中再和大家细细介绍。</p><p>本文就先说到这里，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
</feed>
