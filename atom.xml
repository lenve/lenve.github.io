<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2021-06-21T13:41:19.580Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebFlux 中的请求地址路由怎么玩？</title>
    <link href="http://www.javaboy.org/2021/0618/webflux-router-function.html"/>
    <id>http://www.javaboy.org/2021/0618/webflux-router-function.html</id>
    <published>2021-06-18T13:32:16.000Z</published>
    <updated>2021-06-21T13:41:19.580Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在 SpringMVC 中，我们可以通过如下一些注解来控制请求 URL 和处理器之间的映射关系：</p><a id="more"></a><ul><li>@RequestMapping</li><li>@GetMapping</li><li>@PostMapping</li><li>@DeleteMapping</li><li>@PutMapping</li></ul><p>这些注解我们在 WebFlux 中依然还可以继续使用，不过 WebFlux 也提供了自己的方案–Router。</p><p>今天我们就一起来学习下 Router 的用法。</p><h2 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h2><p>首先我们还是先来新建一个 WebFlux 项目，选择的依赖也和之前的一样，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210607190224.png" alt></p><p>这里我们还是基于 MongoDB 来做。</p><p>创建完成后，在 application.properties 中配置一下 MongoDB，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.port=27017</span><br><span class="line">spring.data.mongodb.host=127.0.0.1</span><br><span class="line">spring.data.mongodb.username=madmin</span><br><span class="line">spring.data.mongodb.password=m123</span><br><span class="line">spring.data.mongodb.database=test</span><br><span class="line">spring.data.mongodb.authentication-database=admin</span><br></pre></td></tr></table></figure><p>如此，我们的准备工作就算完成了。</p><h2 id="2-MongoDB-的准备工作"><a href="#2-MongoDB-的准备工作" class="headerlink" title="2.MongoDB 的准备工作"></a>2.MongoDB 的准备工作</h2><p>接下来我们再为 MongoDB 的使用做一些准备工作。</p><p>首先我们需要一个实体类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Document</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要一个 Repository，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableMongoRepositories</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonRepository</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveMongoRepository</span>&lt;<span class="hljs-title">Person</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 PersonRepository 的内容很简单，就继承自 ReactiveMongoRepository 即可，和上篇文章中介绍的也基本一致，松哥不再赘述。</p><h2 id="3-开发处理器"><a href="#3-开发处理器" class="headerlink" title="3.开发处理器"></a>3.开发处理器</h2><p>接下来我们来开个一个 Person 的处理器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">addPerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(personRepository.saveAll(serverRequest.bodyToMono(Person.class)), Person.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">deletePerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> personRepository.findById(Long.parseLong(serverRequest.pathVariable(<span class="hljs-string">"id"</span>)))</span><br><span class="line">                .flatMap(p -&gt; personRepository.delete(p).then(ServerResponse.ok().build()))</span><br><span class="line">                .switchIfEmpty(ServerResponse.notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">getAllPerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ServerResponse.ok().contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(personRepository.findAll(), Person.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个处理器，松哥有话说：</p><ol><li>首先这个处理器我们需要将其注入到 Spring 容器中，注入时作为一个普通组件注入即可。</li><li>所有方法的返回值类型都是 <code>Mono&lt;ServerResponse&gt;</code>，参数类型都是 ServerRequest，因为一会配置 Router 时涉及到的 HandlerFunction 里边就是这样定义的，换句话说，我们这里定义的每一个方法都满足 HandlerFunction 函数式接口。</li><li>addPerson 方法中，首先调用 ServerResponse.ok() 方法设置响应状态码为 200，然后调用 contentType 设置响应的 MediaType，最后调用 body 方法设置响应内容。</li><li>deletePerson 中，先查询要删除的数据，然后再删除即可。</li></ol><p>上面的写法有点臃肿，一些静态方法我们可以直接使用静态导入，这样代码看起来更清爽一些，修改后的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Long.parseLong;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.web.reactive.function.server.ServerResponse.notFound;</span><br><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.springframework.web.reactive.function.server.ServerResponse.ok;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonHandler</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">addPerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ok().contentType(APPLICATION_JSON)</span><br><span class="line">                .body(personRepository.saveAll(serverRequest.bodyToMono(Person.class)), Person.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">deletePerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> personRepository.findById(parseLong(serverRequest.pathVariable(<span class="hljs-string">"id"</span>)))</span><br><span class="line">                .flatMap(p -&gt; personRepository.delete(p).then(ok().build()))</span><br><span class="line">                .switchIfEmpty(notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title">getAllPerson</span><span class="hljs-params">(ServerRequest serverRequest)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ok().contentType(APPLICATION_JSON)</span><br><span class="line">                .body(personRepository.findAll(), Person.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码看起来简洁一些了，上面多了一些静态导入。我们在网上看别人写的响应式代码，大部分也都是上来就 <code>ok()...</code>。</p><h2 id="4-配置路由"><a href="#4-配置路由" class="headerlink" title="4.配置路由"></a>4.配置路由</h2><p>接下来我们来配置路由，就是将请求的 URL 地址和这些处理器之间关联起来，配置类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RouterConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">RouterFunction&lt;ServerResponse&gt; <span class="hljs-title">personRouter</span><span class="hljs-params">(PersonHandler personHandler)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> RouterFunctions</span><br><span class="line">                .nest(RequestPredicates.path(<span class="hljs-string">"/person"</span>), </span><br><span class="line">                        RouterFunctions.route(RequestPredicates.POST(<span class="hljs-string">"/"</span>), personHandler::addPerson)</span><br><span class="line">                                .andRoute(RequestPredicates.GET(<span class="hljs-string">"/"</span>), personHandler::getAllPerson)</span><br><span class="line">                                .andRoute(RequestPredicates.DELETE(<span class="hljs-string">"/&#123;id&#125;"</span>), personHandler::deletePerson));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类是这样：</p><ol><li>这个配置类的作用有点像 SpringMVC 中的 DispatcherServlet，负责请求的分发，根据不同的请求 URL，找到对应的处理器去处理（如果 DispatcherServlet 不熟悉的话，可以在公众号后台回复 <code>springmvc源码</code> 查看松哥之前关于 SpringMVC 源码分析的系列文章）。</li><li>通过 RouterFunctions 这样一个工具类来创建 RouterFunction 实例。</li><li>首先调用 nest 方法，第一个参数配置的相当于是接下来配置的地址的一个前缀，这有点类似于我们在 Controller 类上直接写 @RequestMapping 注解去配置地址。</li><li>nest 方法的第二个参数就是 RouterFunction 实例了，每一个 RouterFunction 实例通过 RouterFunctions.route 方法来构建，它的第一个参数就是请求的 URL 地址（注意这个时候配置的地址都是有一个共同的前缀），第二个参数我们通过方法引用的方式配置了一个 HandlerFunction，这个就是当前请求的处理器了。</li><li>通过 addRoute 方法可以配置多个路由策略。</li></ol><p>OK，如此，我们的配置工作就算完成了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>接下来我们来进行简单的测试。</p><p>我们一共有三个接口可以测试，先来看添加数据：</p><p><img src="http://img.itboyhub.com/2021/02/20210609214828.png" alt></p><p>这个添加接口其实也可以实现修改，如果添加的数据已经存在就会自动修改，不存在就添加（根据 id 判断数据是否存在）。</p><p>再来看删除数据：</p><p>如果删除的数据不存在，就会响应 404，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210609214937.png" alt></p><p>如果删除的数据存在，则会响应 200:</p><p><img src="http://img.itboyhub.com/2021/02/20210609215030.png" alt></p><p>最后再来看查询的接口：</p><p><img src="http://img.itboyhub.com/2021/02/20210609215058.png" alt></p><p>如此，我们的 CURD 都 OK 啦。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好啦，今天通过一篇简单的文章和大家分享了 WebFlux 中的 RouterFunction，不知道小伙伴们学废没？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在 SpringMVC 中，我们可以通过如下一些注解来控制请求 URL 和处理器之间的映射关系：&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>用 WebFlux 写个 CURD 是什么体验？</title>
    <link href="http://www.javaboy.org/2021/0617/webflux-crud.html"/>
    <id>http://www.javaboy.org/2021/0617/webflux-crud.html</id>
    <published>2021-06-17T13:32:03.000Z</published>
    <updated>2021-06-21T13:41:01.471Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们继续来搞 WebFlux！</p><a id="more"></a><p>WebFlux 最为人所诟病的是数据库的支持问题，毕竟数据是一个应用的生命，我们接触的大部分应用程序都是有数据库的，而 WebFlux 在这一方面的支持行一直比较弱，这也是大家总是吐槽它的原因。</p><p>不过从 Spring5 开始，这一问题得到了一定程度的缓解。</p><p>Spring 官方在 Spring5 发布了响应式 Web 框架 Spring WebFlux 之后急需能够满足异步响应的数据库交互 API，不过由于缺乏标准和驱动，Pivotal 团队开始自己研究响应式关系型数据库连接 Reactive Relational Database Connectivity，并提出了 R2DBC 规范 API 用来评估可行性并讨论数据库厂商是否有兴趣支持响应式的异步非阻塞驱动程序。最早只有 PostgreSQL 、H2、MSSQL 三家数据库厂商，不过现在 MySQL 也加入进来了，这是一个极大的利好。目前 R2DBC 的最新版本是 0.9.0.RELEASE。</p><p>松哥在接下来的文章中将会和大家演示 R2DBC 的用法，但是今天我们还是先来看看 WebFlux+MongoDB 的用法，毕竟这是 WebFlux 较早支持的数据库之一，各种 API 都比较成熟，我们一步一步来。</p><h2 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h2><p>方便起见，我们这里就直接创建 Spring Boot 项目，首先创建一个 Spring Boot 项目，引入 MongoDB 依赖和 WebFlux 依赖，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210607190224.png" alt></p><p>注意我们这里选择的 MongoDB 依赖是 Spring Data Reactive MongoDB，千万别选错了。</p><p>项目创建完成后，我们先在 application.properties 中对 MongoDB 进行简单配置，如下（如果小伙伴们尚不熟悉 MongoDB 的操作，可以在公众号底部菜单找到松哥原创的 MongoDB 教程）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.port=27017</span><br><span class="line">spring.data.mongodb.host=127.0.0.1</span><br><span class="line">spring.data.mongodb.username=madmin</span><br><span class="line">spring.data.mongodb.password=m123</span><br><span class="line">spring.data.mongodb.database=test</span><br><span class="line">spring.data.mongodb.authentication-database=admin</span><br></pre></td></tr></table></figure><p>多说一句，在之前的 Spring Boot 视频教程中，松哥对 MongoDB 也有过介绍，感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/aIyP77WrrswWNXaueBXj7w" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a>。</p><p>配置完 MongoDB 后，我们的准备工作就算完成了。</p><h2 id="2-实体类与-Dao"><a href="#2-实体类与-Dao" class="headerlink" title="2.实体类与 Dao"></a>2.实体类与 Dao</h2><p>接下来我们需要准备一个操作的实体类，这些都是 JPA 的基本操作，松哥就不再赘述，如果小伙伴们不熟悉的话，可以公号后台回复 666 查看原创的 Spring Boot 教程，里边有涉及到，实体类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Document</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再提供一个实体类操作的接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableMongoRepositories</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveMongoRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义一个空的接口继承自 ReactiveMongoRepository，里边什么都不用写，这套路就和松哥之前视频中介绍的 JPA 的用法如出一辙（毕竟都是 Spring Data 家族），所以这块就没啥好说的，不赘述。</p><h2 id="3-测试接口"><a href="#3-测试接口" class="headerlink" title="3.测试接口"></a>3.测试接口</h2><p>接下来我们来看看测试接口。</p><h3 id="3-1-添加"><a href="#3-1-添加" class="headerlink" title="3.1 添加"></a>3.1 添加</h3><p>首先我们来看看添加数据。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;User&gt; <span class="hljs-title">addUser</span><span class="hljs-params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完成后，返回刚刚添加成功的对象。save 方法的返回值就是 Mono。</p><p>我们来看看测试效果：</p><p><img src="http://img.itboyhub.com/2021/02/20210607193023.png" alt></p><h3 id="3-2-查询"><a href="#3-2-查询" class="headerlink" title="3.2 查询"></a>3.2 查询</h3><p>再来看看查询效果：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Flux&lt;User&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/stream/all"</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Flux&lt;User&gt; <span class="hljs-title">streamGetAll</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们提供了两个查询接口，一个就是返回 Flux，里边包含多个对象，还有一个我设置了响应的 Content-Type 为 text/event-stream，通过响应式流返回数据，具体参见【<a href>服务端推送数据，除了 WebSocket 你还能想到啥？</a>】一文。</p><p>我们来看看查询效果：</p><p><img src="http://img.itboyhub.com/2021/02/20210607194429.png" alt></p><p><img src="http://img.itboyhub.com/2021/02/20210607194357.png" alt></p><p>可以看到两种不同的查询方式返回的数据格式也有差异。前者是以数组形式一次性返回数据，后者是以 SSE 的形式多次返回数据。</p><h3 id="3-3-删除"><a href="#3-3-删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h3><p>再来看看删除。</p><p>按照 RESTful 规范，如果删除成功请求响应码就是 200，如果删除失败请求响应码就是 404，因此，我们开发出来的接口如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteUser(<span class="hljs-meta">@PathVariable</span> String id) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findById(id)</span><br><span class="line">            .flatMap(user -&gt; userDao.delete(user).then(Mono.just(<span class="hljs-keyword">new</span> ResponseEntity&lt;Void&gt;(HttpStatus.OK))))</span><br><span class="line">            .defaultIfEmpty(<span class="hljs-keyword">new</span> ResponseEntity(HttpStatus.NOT_FOUND));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从数据库中查询出相关的数据，然后调用 flatMap，在 flatMap 中对数据进行删除处理，删除完成后，给出一个 200 的响应码，如果查询的时候没有查询到数据，就给一个 404 响应码。</p><p>可以看到，删除成功后，响应码为 200：</p><p><img src="http://img.itboyhub.com/2021/02/20210607195743.png" alt></p><p>删除失败后，响应码为 404：</p><p><img src="http://img.itboyhub.com/2021/02/20210607195814.png" alt></p><h3 id="3-4-修改"><a href="#3-4-修改" class="headerlink" title="3.4 修改"></a>3.4 修改</h3><p>再来看看修改，和前面的删除类似，先查询，再修改：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PutMapping</span>(<span class="hljs-string">"/"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; updateUser(<span class="hljs-meta">@RequestBody</span> User user) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findById(user.getId())</span><br><span class="line">            .flatMap(u -&gt; userDao.save(user))</span><br><span class="line">            .map(u-&gt;<span class="hljs-keyword">new</span> ResponseEntity&lt;User&gt;(u,HttpStatus.OK))</span><br><span class="line">            .defaultIfEmpty(<span class="hljs-keyword">new</span> ResponseEntity(HttpStatus.NOT_FOUND));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/02/20210607201936.png" alt></p><p>如果修改的数据不存在的话，就会给出一个 404 响应：</p><p><img src="http://img.itboyhub.com/2021/02/20210607202007.png" alt></p><h3 id="3-5-自定义查询方法"><a href="#3-5-自定义查询方法" class="headerlink" title="3.5 自定义查询方法"></a>3.5 自定义查询方法</h3><p>松哥之前的 Spring Data Jpa 中讲的一些查询 API，这里同样是适用的（公号后台回复 666 获取之前的教程）。</p><p>例如我们可以在 UserDao 中自定义一个查询方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableMongoRepositories</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactiveMongoRepository</span>&lt;<span class="hljs-title">User</span>,<span class="hljs-title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function">Flux&lt;User&gt; <span class="hljs-title">findUserByUsernameContaining</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加一个接口调用该方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/byname"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Flux&lt;User&gt; <span class="hljs-title">getUserByName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> userDao.findUserByUsernameContaining(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样该接口就可以查询名字中包含某关键字的所有用户了。</p><p>其他关于 JPA 的用法这里都是适用的，因为在之前的文章中讲过，松哥这里就不再赘述了。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天我们就用 WebFlux 写了一个简单的 CURD，大家先来感受下 WebFlux 的基本用法，后面的文章松哥将和大家分享 WebFlux 如何连接关系型数据库，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们继续来搞 WebFlux！&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>服务端主动推送数据，除了 WebSocket 你还能想到啥？</title>
    <link href="http://www.javaboy.org/2021/0611/sse.html"/>
    <id>http://www.javaboy.org/2021/0611/sse.html</id>
    <published>2021-06-11T13:31:50.000Z</published>
    <updated>2021-06-21T13:41:57.502Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在<a href="https://mp.weixin.qq.com/s/HVJQEdOBdBG_V92j7MMmkw" target="_blank" rel="noopener">上篇文章</a>中，松哥和大家分享了 WebFlux 的基本用法，小伙伴们已经了解到使用 WebFlux 我们的返回值可以是 Mono 也可以是 Flux，如果是 Flux，由于 Flux 中包含多个元素，所以我们需要设置响应的 Content-Type 为 <code>text/event-stream</code>。考虑到很多小伙伴还没用过 <code>text/event-stream</code>，所以今天松哥再撸一篇文章来和大家聊聊 <code>text/event-stream</code>。</p><a id="more"></a><h2 id="1-SSE"><a href="#1-SSE" class="headerlink" title="1.SSE"></a>1.SSE</h2><p>首先我们来看一个概念叫做 SSE。</p><p>SSE 全称是 Server-Sent Events，它的作用和 WebSocket 的作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息，不同的是，WebSocket 是一种全双工通信协议，而 SSE 则是一种单工通信协议，即使用 SSE 只能服务器向浏览器推送信息流，浏览器如果向服务器发送信息，就是一个普通的 HTTP 请求。</p><p>使用 SSE，当服务端给客户端响应的时候，他不是发送一个一次性数据包，而是会发送一个数据流，这个时候客户端的连接不会关闭，会一直等待服务端发送过来的数据流，我们常见的视频播放其实就是这样的例子。</p><p>SSE 和 WebSocket 主要有如下区别：</p><ul><li>SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。</li><li>SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。</li><li>SSE 默认支持断线重连，WebSocket 需要自己实现。</li><li>SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。</li><li>SSE 支持自定义发送的消息类型。</li></ul><p>说了这么多，可能大家还是有点懵，接下来松哥通过一个简单的例子来向大家展示 SSE 的用法。</p><h2 id="2-开发服务端"><a href="#2-开发服务端" class="headerlink" title="2.开发服务端"></a>2.开发服务端</h2><p>根据第一小节的描述，大家也能看出来，SSE 其实和框架没有关系，所以这里松哥就创建一个普通的 Java Web 项目，用最最基本的 Servlet 来向大家演示 SSE 的功能。</p><p>首先我们创建一个 SseServlet，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/sse"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SseServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"text/event-stream;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            out.write(<span class="hljs-string">"data: 江南一点雨:"</span> + i+<span class="hljs-string">"\n\n"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">1000</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往出写 10 条数据，每写一条就睡眠 1 秒钟。代码并不难，但是这里有几个细节需要注意下：</p><ol><li>响应的 Content-Type 记得设置为 <code>text/event-stream</code>，这是关键。</li><li>每一次发送的信息，由若干个 message 组成，每个 message 之间用 <code>\n\n</code> 分隔，每个 message 内部由若干行组成。在上面的案例中，每一个 for 循环中就是发送一个 message。</li><li>每一行的数据格式是 ：<code>[field]: value\n</code>。field 有四种不同取值：<ul><li>data：data 用来表示数据内容，就像我们上面的例子。</li><li>id：id 相当于是每一条数据的唯一编号，浏览器用 <code>lastEventId</code> 属性读取这个值。一旦连接断线，浏览器会发送一个 <code>HTTP</code> 头，里面包含一个特殊的 <code>Last-Event-ID</code> 头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</li><li>event：<code>event</code> 字段表示自定义的事件类型，默认是 <code>message</code> 事件。</li><li>retry：服务器可以用 <code>retry</code> 字段，指定浏览器重新发起连接的时间间隔。</li></ul></li></ol><p>开发完成后，我们启动服务端访问 /sse 接口来看看效果：</p><p><img src="http://img.itboyhub.com/2021/02/6-3.gif" alt></p><p>可以看到，客户端每隔 1 秒就能收到服务端的数据。</p><h2 id="3-开发客户端"><a href="#3-开发客户端" class="headerlink" title="3.开发客户端"></a>3.开发客户端</h2><p>前面是一个服务端的案例，接下来我们来看看客户端的案例，新建一个 html 页面，添加如下 js：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> es = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">"/sse"</span>);</span><br><span class="line">es.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"open"</span>)</span><br><span class="line">&#125;;</span><br><span class="line">es.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(e.data);</span><br><span class="line">&#125;</span><br><span class="line">es.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"error"</span>)</span><br><span class="line">    es.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于上面这段代码：</p><ol><li>首先新建一个 EventSource 对象，参数就是服务端的地址。它还有一个可选的参数，可选参数重可以描述是否将 Cookie 一起发送出去 <code>var es = new EventSource(&quot;/es&quot;, { withCredentials: true });</code>（可在跨域时使用该参数）。</li><li>当建立连接后，就会触发 <code>onopen</code> 函数，当收到服务端发送来的消息，就会触发 <code>onmessage</code> 函数，当连接出错的时候，就会触发 <code>onerror</code> 函数。</li><li><code>es.close</code> 表示关闭 SSE 连接。</li></ol><p>这三种类型的事件，我们还可以通过如下方式来定义：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> es = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">"/sse"</span>);</span><br><span class="line">es.addEventListener(<span class="hljs-string">"open"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"open"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">es.addEventListener(<span class="hljs-string">"message"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(e.data);</span><br><span class="line">&#125;)</span><br><span class="line">es.addEventListener(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"error"</span>)</span><br><span class="line">    es.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果与上面的一致，我们来看看运行效果图：</p><p><img src="http://img.itboyhub.com/2021/02/6-4.gif" alt></p><p>消息接收完后，会触发 onerror 事件，此时我们可以关闭 SSE 连接，<strong>否则就会从头开始继续接收数据</strong>。</p><h2 id="4-自定义事件"><a href="#4-自定义事件" class="headerlink" title="4.自定义事件"></a>4.自定义事件</h2><p>我们也可以自定义 SSE 事件。</p><p>先来看服务端如何自定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/sse"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SseServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"text/event-stream;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            out.write(<span class="hljs-string">"event:javaboy\n"</span>);</span><br><span class="line">            out.write(<span class="hljs-string">"data: 江南一点雨:"</span> + i + <span class="hljs-string">"\n\n"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">1000</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，在每一行消息之前添加 <code>out.write(&quot;event:javaboy\n&quot;);</code> 表示自定义事件类型，当然我们也可以添加事件 id，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/sse"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SseServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"text/event-stream;charset=utf-8"</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            out.write(<span class="hljs-string">"event:javaboy\n"</span>);</span><br><span class="line">            out.write(<span class="hljs-string">"id:"</span> + i + <span class="hljs-string">"\n"</span>);</span><br><span class="line">            out.write(<span class="hljs-string">"data: 江南一点雨:"</span> + i + <span class="hljs-string">"\n\n"</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="hljs-number">1000</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端定义完成后，接下来我们再来看看前端该如何接收数据：</p><figure class="highlight js hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> es = <span class="hljs-keyword">new</span> EventSource(<span class="hljs-string">"/sse"</span>);</span><br><span class="line">es.addEventListener(<span class="hljs-string">"open"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"open"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">es.addEventListener(<span class="hljs-string">"javaboy"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(e.data, e.lastEventId, e);</span><br><span class="line">&#125;)</span><br><span class="line">es.addEventListener(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"error"</span>)</span><br><span class="line">    es.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时在 addEventListener 方法中，输入自定义的事件名称，然后在回调函数中处理事件。</p><p>可以通过 <code>e.lastEventId</code> 访问到消息的 id。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天主要通过几个简单的例子向大家展示 <code>text/event-stream</code> 以及 SSE 相关的知识点，相信大家在学完之后对 WebFlux 中返回值为 Flux 的接口会有更深的理解，读完本文，再去看昨天的文章【<a href="https://mp.weixin.qq.com/s/HVJQEdOBdBG_V92j7MMmkw" target="_blank" rel="noopener">WebFlux 初体验</a>】，应该会更香。</p><p>参考资料：<a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/HVJQEdOBdBG_V92j7MMmkw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;中，松哥和大家分享了 WebFlux 的基本用法，小伙伴们已经了解到使用 WebFlux 我们的返回值可以是 Mono 也可以是 Flux，如果是 Flux，由于 Flux 中包含多个元素，所以我们需要设置响应的 Content-Type 为 &lt;code&gt;text/event-stream&lt;/code&gt;。考虑到很多小伙伴还没用过 &lt;code&gt;text/event-stream&lt;/code&gt;，所以今天松哥再撸一篇文章来和大家聊聊 &lt;code&gt;text/event-stream&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 初体验</title>
    <link href="http://www.javaboy.org/2021/0608/webflux-starter.html"/>
    <id>http://www.javaboy.org/2021/0608/webflux-starter.html</id>
    <published>2021-06-08T13:31:33.000Z</published>
    <updated>2021-06-21T13:41:51.668Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前面铺垫了五篇啦，是时候请出主角了。</p><a id="more"></a><p>今天我们就先来一个简单的案例大伙体验一把 WebFlux。</p><h2 id="1-什么是-WebFlux"><a href="#1-什么是-WebFlux" class="headerlink" title="1.什么是 WebFlux"></a>1.什么是 WebFlux</h2><p>首先我们来看看什么是 WebFlux，Spring 官网上有一张经典的对比图：</p><p><img src="http://img.itboyhub.com/2021/02/20210607202806.png" alt></p><p>看着这张图，我们来仔细分析下传统的 SpringMVC 和 WebFlux 之间的区别。</p><p>Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问，所以 Spring WebFlux 可以有效提升系统的吞吐量和伸缩性，特别是在一些 IO 密集型应用中，Spring WebFlux 的优势明显。例如微服务网关 Spring Cloud Gateway 就使用了 WebFlux，这样可以有效提升网管对下游服务的吞吐量。</p><p><strong>不过需要注意的是，接口的响应时间并不会因为使用了 WebFlux 而缩短，服务端的处理结果还是得由 worker 线程处理完成之后再返回给前端。</strong></p><p>WebFlux 底层使用 Netty 容器，这点也和我们传统的 SpringMVC 不一样，不过默认端口都是 8080。WebFlux 另外也提供了对 Jetty 以及 Undertow 等容器的支持，具体使用方式和之前松哥 Spring Boot 系列中讲的一样，大家直接在 pom.xml 文件中添加相关的依赖即可。</p><p>不过需要注意的是，必须是 Servlet3.1+ 容器，如 Tomcat、Jetty，或者是非 Servlet 容器，如 Netty 和 Undertow。</p><h2 id="2-什么是-Reactor"><a href="#2-什么是-Reactor" class="headerlink" title="2.什么是 Reactor"></a>2.什么是 Reactor</h2><p>接下来还有一个概念需要和大家介绍，那就是 Reactor。</p><p>Spring Reactor 是 Pivotal 团队基于反应式编程实现的一种方案，这是一种非阻塞，并且由事件驱动的编程方案，它使用函数式编程实现。关于函数式编程，大家可以回顾松哥本系列前面的文章：<a href="https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q" target="_blank" rel="noopener">WebFlux 前置知识（一）</a>。</p><p>Reactor 是一个用于 JVM 的完全非阻塞的响应式编程框架，具备高效的需求管理，可以很好的处理 “backpressure”，它可以直接与 Java8 的函数式 API 直接集成，例如 CompletableFuture、各种 Stream 等。</p><p>Reactor 还提供了异步序列 API <strong>Flux</strong>（用于 N 个元素）和 <strong>Mono</strong>（用于 0|1 个元素），并完全遵循和实现了“响应式扩展规范”（Reactive Extensions Specification）。</p><p>换句话说，大家可以把 Reactor 理解为 Java8 中的 Stream（参见<a href="https://mp.weixin.qq.com/s/cuxnkcfAOLZuxWRmYcnKWg" target="_blank" rel="noopener">WebFlux 前置知识（三）</a>）+ Java9 中的 Reactive Stream（参见<a href="https://mp.weixin.qq.com/s/BfgQ760h_WeUOBRrgx1ubA" target="_blank" rel="noopener">WebFlux 前置知识（四）</a>）。</p><p>上面说了这么多，大家最重要是要记住 Flux 和 Mono，因为这两个东西我们在后面会反复用到。</p><ul><li>Mono：实现发布者 Publisher<t>，并返回 0 或 1 个元素。</t></li><li>Flux：实现发布者 Publisher<t>，并返回 N 个元素。</t></li></ul><p>记住关键字，他俩都是发布者 Publisher<t>。</t></p><h2 id="3-创建工程"><a href="#3-创建工程" class="headerlink" title="3.创建工程"></a>3.创建工程</h2><p>为了演示方便，松哥这里就直接采用 Spring Boot 工程了，首先我们创建一个 Spring Boot 工程，需要注意的是，以往创建 Spring Boot 时我们都是选择 Spring Web 依赖，但是这次我们选择 Spring Reactive Web 依赖，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210602192117.png" alt></p><p>添加上这一个依赖就 OK 了。</p><p>这个时候创建好的 Spring Boot 项目，底层容器是 Netty 而不是我们之前广泛使用的 Tomcat 了。</p><h3 id="3-1-Mono"><a href="#3-1-Mono" class="headerlink" title="3.1 Mono"></a>3.1 Mono</h3><p>项目创建成功后，我们可以先来体验一把 Mono 的功能，添加如下 Controller 进行测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-string">"hello2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个 /hello 接口就是一个普通的 SpringMVC 中的接口，这个在这里也是支持的。后面的 /hello2 接口返回值则是一个 Mono<string> 对象。</string></p><p>接下来启动项目，然后我们就可以愉快的访问 /hello 和 /hello2 接口了。</p><p>有人可能会说这么写的意义何在呢？</p><p>上面这个例子确实看不出来意义，我们对上面的代码进行一个改进：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String helloStr = getHelloStr();</span><br><span class="line">        System.out.println(<span class="hljs-string">"普通接口耗时："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="hljs-keyword">return</span> helloStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;String&gt; <span class="hljs-title">hello2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Mono&lt;String&gt; hello2 = Mono.fromSupplier(() -&gt; getHelloStr());</span><br><span class="line">        System.out.println(<span class="hljs-string">"WebFlux 接口耗时："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        <span class="hljs-keyword">return</span> hello2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getHelloStr</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们单独抽取出来一个方法 getHelloStr，在这个方法中，我们首先睡眠两秒钟，然后返回一个字符串，最后在接口中调用该方法获取返回的字符串。</p><p>需要注意的是，此时的 Mono<string> 是通过 Mono.fromSupplier 方法获取。</string></p><p>接下来启动项目，我们再次访问这两个接口，打印出来的日志信息如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210603210325.png" alt></p><p>可以看到：</p><ol><li>在普通接口中，请求会被阻塞，所以最终打印出来耗时 2001 毫秒。</li><li>在 WebFlux 接口中，请求不会被阻塞，所以服务端的接口耗时为 0。</li></ol><p>这下大家看到差异了吧！这比异步 Servlet 方便多了吧！</p><h3 id="3-2-Flux"><a href="#3-2-Flux" class="headerlink" title="3.2 Flux"></a>3.2 Flux</h3><p>Flux 是我们在 WebFlux 中常用的另外一种返回数据格式，我们一起来看下它的一个简单案例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/flux"</span>,produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Flux&lt;String&gt; <span class="hljs-title">flux</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Flux&lt;String&gt; flux = Flux.fromArray(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"javaboy"</span>,<span class="hljs-string">"itboyhub"</span>,<span class="hljs-string">"www.javaboy.org"</span>,<span class="hljs-string">"itboyhub.com"</span>&#125;).map(s -&gt; &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"my-&gt;data-&gt;"</span> + s;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-keyword">return</span> flux;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Flux 也是一个 Publisher，它可以由一个数组产生，上面的代码也都是基本的 Stream 操作，松哥就不再赘述了，不熟悉的小伙伴可以查看<a href="https://mp.weixin.qq.com/s/cuxnkcfAOLZuxWRmYcnKWg" target="_blank" rel="noopener">WebFlux 前置知识（三）</a>。</p><p>需要注意的是，这里返回的 Content-Type 是 MediaType.TEXT_EVENT_STREAM_VALUE，即 <code>text/event-stream</code>。</p><p>启动后，在浏览器端访问，我们来看看结果：</p><p><img src="http://img.itboyhub.com/2021/02/6-2.gif" alt></p><p><strong>text/event-stream</strong></p><p>我们日常开发中，返回的 Content-Type 基本都是 <code>application/json</code> 或者 <code>text/html</code>，很少会用到 text/event-stream，这其实也是服务器向浏览器推送消息的一种方案，这种方案和我们所熟知的 WebSocket 有一些差别，这个松哥下次专门撸一篇文章和大家介绍，这里就先不展开了。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天我们就先通过一个简单的案例和大家展示一下 WebFlux 的基本用法，当然这里还涉及到很多细节，松哥后面继续撸文章和大家介绍。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前面铺垫了五篇啦，是时候请出主角了。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>我要吐槽下跨平台</title>
    <link href="http://www.javaboy.org/2021/0606/platform.html"/>
    <id>http://www.javaboy.org/2021/0606/platform.html</id>
    <published>2021-06-06T13:32:44.000Z</published>
    <updated>2021-06-21T13:42:04.944Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作原因，接触了一点 uni-app，老实说，体验很不好，当然这不一定是 uni-app 的问题，跨平台这个需求本身就有点扯淡。</p><a id="more"></a><p>松哥接触跨平台的时间还是蛮早的，而且因为毕业后有一段时间在做移动端开发，而跨平台这种事本身就是移动端最火热，所以今天就来随便聊聊我曾经接触过的几种跨平台方案。</p><p>2012 年还在学校的时候，当时接触到的第一种跨平台方案就是 jQuery Mobile，那个年代 jQuery 是前端领域妥妥的当红小生，火热程度不亚于今天的 Vue。jQuery 官方顺势推出了 jQuery Mobile，用来支持移动端的开发。这种方案说白了就是开发基于浏览器的应用，然后在手机的浏览器上面跑。塞班、Windows Phone、Android、iOS 等都支持。但是实际上开发出来的 App，在塞班和 Windows Phone 上面的显示效果惨不忍睹。在低端 Android 手机上运行特别卡，点一下反应半天，就像浏览器网页一样慢，在三四千块的 Android 手机上或者 iPhone、iPad 上运行效果就很棒了，甚至有种原生 App 的错觉。</p><p>但是这种方案显然不是一个很好的跨平台方案，无法解决低端机上的运行效率问题，所以我一直好奇这种方案有没有商用价值？我刚刚打开 jQuery 的官网瞅了一眼，jQuery Mobile 还在，不知道小伙伴们在公司项目中有没有用过这种方案，欢迎留言说说。</p><p><img src="http://img.itboyhub.com/2021/02/20210526212556.png" alt></p><p>jQuery Mobile 是我接触的第一种跨平台方案，当时就是不懂 Android 开发，也不懂 iOS 开发，但是又想搞移动端应用，没办法就只能用 jQuery Mobile 搞了。虽然这种方案一点都不完美，但是却让我明白了跨平台的意义，多个平台同时存在时，就会一直有跨平台的需求，我们总想一套代码，运行多个平台。就像我们 Java，<code>Write once, run anywhere</code>。</p><p>当然用 jQuery Mobile 时候，还有一些配套工具如 PhoneGap、Cordova 等，这些就不一一说了。</p><p>大学刚毕业的时候，我在做 Android 开发，那一段时间接触了 RN（React Native），自己也上手学了一段时间，对 RN 整体的感觉就是运行效率比 jQuery Mobile 强多了，不过对于一个非专业前端来说，RN 上手也比 jQuery Mobile 难一些。不过 RN 我没搞太久，后来就去做 Java 了，从此很少关注移动端的东西。</p><p>不过作为一个称职的程序员，折腾是人生第一要义。搞 Java 后端开发没多久后，又玩起了小程序，现在除了微信有小程序，百度、支付宝、字节、QQ、360 等都有自己的小程序，于是大家又开始琢磨跨平台了，目前看起来比较火的似乎就是 uni-app 了。</p><p>我第一次了解到这个东西应该是在 2018 年的时候，当时我想趁着工作不忙学点东西，在晚上闲逛的时候看到了这个项目，当时感觉还是一个很小的项目，GitHub 上的 star 才 100 多，现在都 3W+ 了。不过因为之前搞移动端跨平台留下的阴影，我对这种跨平台方案都提不起兴趣，感觉都是牛皮吹的大，实际效果很有限。所以很长一段时间没，对 uni-app 的认知也只是停留在了解。</p><p>最近因为工作原因，没办法，接触了 uni-app，果然跟我想的差不多。真的很难做到 <code>Write once, run anywhere</code>，一些兼容性问题还是要特殊处理。而且这个框架还和 HBuilder 这个开发工具深度绑定，用这个工具开发就很方便，项目创建也要快很多。但是如果用 cli 命令行，那体验感就迅速下跌。而且按照官方给的模版创建出来的项目，刚打开后控制台就报错也让我很郁闷，这对新手来说是相当不友好的。</p><p>在这些问题里边我觉得最主要的还是兼容问题很难处理，无法真正做到 <code>Write once, run anywhere</code>，无法做到这一点，这个框架的意义就大打折扣了。</p><p>即使做纯粹的原生开发，都不可避免的遇到兼容问题，更不用说这种跨平台开发，兼容性问题只会多不会少。我也专门去问了身边的前端同事，他说其实还是有公司在用 uni-app，但是不多。</p><p>小伙伴们有没有用过一些跨平台的框架或者工具，欢迎留言说说你的使用感受～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作原因，接触了一点 uni-app，老实说，体验很不好，当然这不一定是 uni-app 的问题，跨平台这个需求本身就有点扯淡。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
      <category term="Platform" scheme="http://www.javaboy.org/tags/Platform/"/>
    
  </entry>
  
  <entry>
    <title>异步 Servlet 都不懂，谈何 WebFlux？</title>
    <link href="http://www.javaboy.org/2021/0602/webflux-async-servlet.html"/>
    <id>http://www.javaboy.org/2021/0602/webflux-async-servlet.html</id>
    <published>2021-06-02T13:31:19.000Z</published>
    <updated>2021-06-21T13:41:45.909Z</updated>
    
    <content type="html"><![CDATA[<p>我们日常使用的 SpringMVC，基本上都不是异步 Servlet，而学习 WebFlux，异步 Servlet 是基础，因此松哥还是花点时间来和大家聊一聊什么是异步 Servlet，这有助于大家理解我们为什么需要 WebFlux。</p><a id="more"></a><h2 id="1-什么是异步-Servlet"><a href="#1-什么是异步-Servlet" class="headerlink" title="1.什么是异步 Servlet"></a>1.什么是异步 Servlet</h2><p>先来说说什么是非异步 Servlet。</p><p>在 Servlet3.0 之前，Servlet 采用 Thread-Per-Request 的方式处理 Http 请求，即每一次请求都是由某一个线程从头到尾负责处理。</p><p>如果一个请求需要进行 IO 操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将同步地等待 IO 操作完成， 而 IO 操作是非常慢的，所以此时的线程并不能及时地释放回线程池以供后续使用，如果并发量很大的话，那肯定会造性能问题。</p><p>传统的 MVC 框架如 SpringMVC 也无法摆脱 Servlet 的桎梏，原因很简单，他们都是基于 Servlet 来实现的。如 SpringMVC 中大家所熟知的 DispatcherServlet（如果大家对于 SpringMVC 的原理不太理解，可以查看松哥之前的系列文章<a href="https://mp.weixin.qq.com/s/ldMcUawOtba8CgPgQtTIaA" target="_blank" rel="noopener">SpringMVC源码解读系列，20 篇干货完美收官！</a>）。</p><p>为了解决这一问题，Servlet3.0 中引入了异步 Servlet，然后在 Servlet3.1 中又引入了非阻塞 IO 来进一步增强异步处理的性能。</p><p>在正式开整 WebFlux 之前，我们先来了解下异步 Servlet 的一些基本玩法。</p><h2 id="2-版本关系"><a href="#2-版本关系" class="headerlink" title="2.版本关系"></a>2.版本关系</h2><p>我们要先看看 Servlet 和 Tomcat 之间的对应关系，毕竟异步 Servlet 这种事，用错了 Tomcat 版本可能就不支持了。</p><p>下图来自 Tomcat 官网（<a href="http://tomcat.apache.org/whichversion.html）：" target="_blank" rel="noopener">http://tomcat.apache.org/whichversion.html）：</a></p><p><img src="http://img.itboyhub.com/2021/02/20210601185454.png" alt></p><p>从上图我们可以看出，Servlet3.0 对应的 Tomcat 版本是 7.0.x，Servlet3.1 对应的 Tomcat 版本是 8.0.x。</p><p>换句话说，如果我们要使用异步 Servlet，Tomcat 至少要 7.0 以上的版本；如果你还想体验一把非阻塞 IO，那么 Tomcat 至少要 8.0 以上。</p><p>接下来的案例小伙伴们记得选好自己本地的 Tomcat 版本。</p><h2 id="3-基本玩法"><a href="#3-基本玩法" class="headerlink" title="3.基本玩法"></a>3.基本玩法</h2><p>先来看一个大家熟悉的同步 Servlet：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/sync"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SyncServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        printLog(request, response);</span><br><span class="line">        System.out.println(<span class="hljs-string">"总耗时："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">3000</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        response.getWriter().write(<span class="hljs-string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Servlet 大家再熟悉不过了。</p><p>前端请求到达后，我们调用 printLog 方法做一些处理，同时把 doGet 方法执行耗时打印出来。</p><p>在 printLog 中，我们先休息 3s，然后给前端返回一个字符串给前端。</p><p>前端发送请求，最终 doGet 方法中耗时 3001 毫秒。</p><p>这是我们大家熟知的同步 Servlet。在整个请求处理过程中，请求会一直占用 Servlet 线程，直到一个请求处理完毕这个线程才会被释放。</p><p>接下来我们对其稍微进行改造，使之变为一个异步 Servlet。</p><p>有人可能会说，异步有何难？直接把 printLog 方法扔到子线程里边去执行不就行了？但是这样会有另外一个问题，子线程里边没有办法通过 HttpServletResponse 直接返回数据，所以我们一定需要 Servlet 的异步支持，有了异步支持，才可以在子线程中返回数据。</p><p>我们来看改造后的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@WebServlet</span>(urlPatterns = <span class="hljs-string">"/async"</span>,asyncSupported = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; printLog(asyncContext,asyncContext.getRequest(),asyncContext.getResponse()));</span><br><span class="line">        System.out.println(<span class="hljs-string">"总耗时："</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLog</span><span class="hljs-params">(AsyncContext asyncContext, ServletRequest request, ServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">3000</span>);</span><br><span class="line">            response.getWriter().write(<span class="hljs-string">"ok"</span>);</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的改造主要有如下几方面：</p><ol><li>@WebServlet 注解上添加 asyncSupported 属性，开启异步支持。</li><li>调用 request.startAsync(); 方法开启异步上下文。</li><li>通过 JDK8 中的 CompletableFuture.runAsync 方法来启动一个子线程（当然也可以自己 new 一个子线程）。</li><li>调用 printLog 方法时的 request 和 response 重新构造，直接从 asyncContext 中获取，注意，这点是【关键】。</li><li>在 printLog 方法中，方法执行完成后，调用 asyncContext.complete() 方法通知异步上下文请求处理完毕。</li></ol><p>经过上面的改造之后，现在的控制台打印出来的总耗时几乎可以忽略不计了。</p><p>也就是说，<strong>有了异步 Servlet 之后，后台 Servlet 的线程会被及时释放，释放之后又可以去接收新的请求，进而提高应用的并发能力。</strong></p><p>第一次接触异步 Servlet 的小伙伴可能会有一个误解，以为用了异步 Servlet 后，前端的响应就会加快。这个怎么说呢？后台的并发能力提高了，前端的响应速度自然会提高，但是我们一两个简单的请求是很难看出这种提高的。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和大家分享一下异步 Servlet，作为 WebFlux 的一个前奏。至此，我们的 WebFlux 前奏已经更新了五篇了，即将进入 WebFlux 的殿堂。</p><p>前四篇前置知识传送门：</p><ol><li><a href="https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q" target="_blank" rel="noopener">WebFlux 前置知识（一）</a></li><li><a href="https://mp.weixin.qq.com/s/QZYcQFJDxTw0V-E0DTNOIw" target="_blank" rel="noopener">WebFlux 前置知识（二）</a></li><li><a href="https://mp.weixin.qq.com/s/cuxnkcfAOLZuxWRmYcnKWg" target="_blank" rel="noopener">WebFlux 前置知识（三）</a></li><li><a href="https://mp.weixin.qq.com/s/BfgQ760h_WeUOBRrgx1ubA" target="_blank" rel="noopener">WebFlux 前置知识（四）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们日常使用的 SpringMVC，基本上都不是异步 Servlet，而学习 WebFlux，异步 Servlet 是基础，因此松哥还是花点时间来和大家聊一聊什么是异步 Servlet，这有助于大家理解我们为什么需要 WebFlux。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 前置知识（四）</title>
    <link href="http://www.javaboy.org/2021/0601/webflux-publisher-subscriber.html"/>
    <id>http://www.javaboy.org/2021/0601/webflux-publisher-subscriber.html</id>
    <published>2021-06-01T13:31:01.000Z</published>
    <updated>2021-06-21T13:41:37.895Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-Backpressure"><a href="#1-Backpressure" class="headerlink" title="1.Backpressure"></a>1.Backpressure</h2><p>Backpressure 在国内被翻译成背压，这个翻译在网上被很多人吐槽，我觉得大家的吐槽是有道理的，背压单纯从字面上确实看不出来有什么意思。所以松哥这里直接用英文 Backpressure 吧。</p><a id="more"></a><p>Backpressure 是一种现象：当数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出，这种现象就叫做 Backpressure。</p><p>换句话说，上游生产数据，生产完成后通过管道将数据传到下游，下游消费数据，当下游消费速度小于上游数据生产速度时，数据在管道中积压会对上游形成一个压力，这就是 Backpressure，从这个角度来说，Backpressure 翻译成反压、回压似乎更合理一些。</p><p>Backpressure 会出现在有 Buffer 上限的系统中，当出现 Buffer 溢出的时候，就会有 Backpressure，对于 Backpressure，它的应对措施只有一个：丢弃新事件。那么什么是 Buffer 溢出呢？例如我的服务器可以同时处理 2000 个用户请求，那么我就把请求上限设置为 2000，这个 2000 就是我的 Buffer，当超出 2000 的时候，就产生了 Backpressure。</p><h2 id="2-Flow-API"><a href="#2-Flow-API" class="headerlink" title="2.Flow API"></a>2.Flow API</h2><p>JDK9 中推出了 Flow API，用以支持 Reactive Programming，即响应式编程。</p><p>在响应式编程中，会有一个数据发布者 Publisher 和数据订阅者 Subscriber，Subscriber 接收 Publisher 发布的数据并进行消费，在 Subscriber 和 Publisher 之间还存在一个 Processor，类似于一个过滤器，可以对数据进行中间处理。</p><p><img src="http://img.itboyhub.com/2021/02/20210527210826.png" alt></p><p>JDK9 中提供了 Flow API 用以支持响应式编程，另外 RxJava 和 Reactor 等框架也提供了相关的实现。</p><p>我们来看看 JDK9 中的 Flow 类：</p><p><img src="http://img.itboyhub.com/2021/02/20210527202428.png" alt></p><p>非常简洁，基本上就是按照 Reactive Programming 的设计来的：</p><p><strong>Publisher</strong></p><p>Publisher 为数据发布者，这是一个函数式接口，里边只有一个方法，通过这个方法将数据发布出去，Publisher 的定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Publisher</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> T&gt; subscriber)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Subscriber</strong></p><p>Subscriber 为数据订阅者，这个里边有四个方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subscriber</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Subscription subscription)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(T item)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onSubscribe：这个是订阅成功的回调方法，用于初始化 Subscription，并且表明可以开始接收订阅数据了。</li><li>onNext：接收下一项订阅数据的回调方法。</li><li>onError：在 Publisher 或 Subcriber 遇到不可恢复的错误时调用此方法，之后 Subscription 不会再调用 Subscriber 其他的方法。</li><li>onComplete：当接收完所有订阅数据，并且发布者已经关闭后会回调这个方法。</li></ul><p><strong>Subscription</strong></p><p>Subscription 为发布者和订阅者之间的订阅关系，用来控制消息的消费，这个里边有两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subscription</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-keyword">long</span> n)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>request：这个方法用来向数据发布者请求 n 个数据。</li><li>cancel：取消消息订阅，订阅者将不再接收数据。</li></ul><p><strong>Processor</strong></p><p>Processor 是一个空接口，不过它同时继承了 Publisher 和 Subscriber，所以它既能发布数据也能订阅数据，因此我们可以通过 Processor 来完成一些数据转换的功能，先接收数据进行处理，处理完成后再将数据发布出去，这个也有点类似于我们 JavaEE 中的过滤器。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Processor</span>&lt;<span class="hljs-title">T</span>,<span class="hljs-title">R</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Subscriber</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">Publisher</span>&lt;<span class="hljs-title">R</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-消息订阅初体验"><a href="#2-1-消息订阅初体验" class="headerlink" title="2.1 消息订阅初体验"></a>2.1 消息订阅初体验</h3><p>我们通过如下一段代码体验一下消息的订阅与发布：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="hljs-keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line">        Flow.Subscriber&lt;String&gt; subscriber = <span class="hljs-keyword">new</span> Flow.Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="hljs-keyword">private</span> Flow.Subscription subscription;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="hljs-comment">//向数据发布者请求一个数据</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"接收到 publisher 发来的消息了："</span> + item);</span><br><span class="line">                <span class="hljs-comment">//接收完成后，可以继续接收或者不接收</span></span><br><span class="line">                <span class="hljs-comment">//this.subscription.cancel();</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//出现异常，就会来到这个方法，此时直接取消订阅即可</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//发布者的所有数据都被接收，并且发布者已经关闭</span></span><br><span class="line">                System.out.println(<span class="hljs-string">"数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="hljs-comment">//配置发布者和订阅者</span></span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="line">            <span class="hljs-comment">//发送数据</span></span><br><span class="line">            publisher.submit(<span class="hljs-string">"hello:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line">        <span class="hljs-keyword">new</span> Scanner(System.in).next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>松哥稍微解释一下上面这段代码：</p><ol><li>首先创建一个 SubmissionPublisher 对象作为消息发布者。</li><li>接下来创建 Flow.Subscriber 对象作为消息订阅者，实现消息订阅者里边的四个方法，分别进行处理。</li><li>为 publisher 配置上 subscriber。</li><li>发送消息。</li><li>消息发送完成后关闭 publisher。</li><li>最后是让程序不要停止，观察消息订阅者打印情况。</li></ol><h3 id="2-2-模拟-Backpressure"><a href="#2-2-模拟-Backpressure" class="headerlink" title="2.2 模拟 Backpressure"></a>2.2 模拟 Backpressure</h3><p>Backpressure 问题在 Flow API 中得到了很好的解决。Subscriber 会将 Publisher 发布的数据缓存在 Subscription 中，其长度默认为256，相关源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Flow</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="hljs-number">256</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">defaultBufferSize</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> DEFAULT_BUFFER_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦超出这个数据量，publisher 就会降低数据发送速度。</p><p>我们对上面的案例进行修改，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="hljs-keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Flow.Subscriber&lt;String&gt; subscriber = <span class="hljs-keyword">new</span> Flow.Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="hljs-keyword">private</span> Flow.Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="hljs-comment">//向数据发布者请求一个数据</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"接收到 publisher 发来的消息了："</span> + item);</span><br><span class="line">                <span class="hljs-comment">//接收完成后，可以继续接收或者不接收</span></span><br><span class="line">                <span class="hljs-comment">//this.subscription.cancel();</span></span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//出现异常，就会来到这个方法，此时直接取消订阅即可</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//发布者的所有数据都被接收，并且发布者已经关闭</span></span><br><span class="line">                System.out.println(<span class="hljs-string">"数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"i---------&gt;"</span> + i);</span><br><span class="line">            publisher.submit(<span class="hljs-string">"hello:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line">        <span class="hljs-keyword">new</span> Scanner(System.in).next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共修改了三个地方：</p><ol><li>Subscriber#onNext 方法中，每次休息两秒再处理下一条数据。</li><li>发布数据时，一共发布 500 条数据。</li><li>打印数据发布的日志。</li></ol><p>修改完成后，我们再次启动项目，观察控制台输出：</p><p><img src="http://img.itboyhub.com/2021/02/6jkfdajfklsdjfk-1.gif" alt></p><p>可以看到，生产者先是一股脑生产了 257 条数据（hello0 在一开始就被消费了，所以缓存中实际上是 256 条），消息则是一条一条的来，由于消费的速度比较慢，所以当缓存中的数据超过 256 条之后，接下来都是消费一条，再发送一条。</p><h3 id="2-3-数据处理"><a href="#2-3-数据处理" class="headerlink" title="2.3 数据处理"></a>2.3 数据处理</h3><p><code>Flow.Processor</code> 可以像过滤器一样，对数据进行预处理，数据从 publisher 出来之后，先进入 <code>Flow.Processor</code> 中进行预处理，然后再进入 Subscriber。</p><p>修改后的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlowDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SubmissionPublisher</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Flow</span>.<span class="hljs-title">Processor</span>&lt;<span class="hljs-title">String</span>,<span class="hljs-title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">private</span> Flow.Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String item)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.submit(<span class="hljs-string">"【这是一条被处理过的数据】"</span> + item);</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="hljs-keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line">        DataFilter dataFilter = <span class="hljs-keyword">new</span> DataFilter();</span><br><span class="line">        publisher.subscribe(dataFilter);</span><br><span class="line"></span><br><span class="line">        Flow.Subscriber&lt;String&gt; subscriber = <span class="hljs-keyword">new</span> Flow.Subscriber&lt;String&gt;() &#123;</span><br><span class="line">            <span class="hljs-keyword">private</span> Flow.Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSubscribe</span><span class="hljs-params">(Flow.Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="hljs-comment">//向数据发布者请求一个数据</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"接收到 publisher 发来的消息了："</span> + item);</span><br><span class="line">                <span class="hljs-comment">//接收完成后，可以继续接收或者不接收</span></span><br><span class="line">                <span class="hljs-comment">//this.subscription.cancel();</span></span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.request(<span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//出现异常，就会来到这个方法，此时直接取消订阅即可</span></span><br><span class="line">                <span class="hljs-keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onComplete</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                <span class="hljs-comment">//发布者的所有数据都被接收，并且发布者已经关闭</span></span><br><span class="line">                System.out.println(<span class="hljs-string">"数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        dataFilter.subscribe(subscriber);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"发送消息 i---------&gt;"</span> + i);</span><br><span class="line">            publisher.submit(<span class="hljs-string">"hello:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line">        <span class="hljs-keyword">new</span> Scanner(System.in).next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单起见，我这里创建了一个局部内部类 DataFilter，DataFilter 继承自 SubmissionPublisher 并实现了 Flow.Processor 接口，由于 DataFilter 继承自 SubmissionPublisher，所以它也兼具 SubmissionPublisher 的功能。</p><p>在 DataFilter 中完成消息的处理并重新发送出去。接下来定义 publisher，让 dataFilter 作为其订阅者，再定义新的订阅者，作为 dataFilter 的订阅者。</p><p>最终运行效果如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210529131117.png" alt></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，这就是今天和大家介绍的 Java9 中的 Reactive Stream，那么至此，我们的 WebFlux 前置知识差不多告一段落了，下篇文章开始，正式开整 WebFlux。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-Backpressure&quot;&gt;&lt;a href=&quot;#1-Backpressure&quot; class=&quot;headerlink&quot; title=&quot;1.Backpressure&quot;&gt;&lt;/a&gt;1.Backpressure&lt;/h2&gt;&lt;p&gt;Backpressure 在国内被翻译成背压，这个翻译在网上被很多人吐槽，我觉得大家的吐槽是有道理的，背压单纯从字面上确实看不出来有什么意思。所以松哥这里直接用英文 Backpressure 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 前置知识（三）</title>
    <link href="http://www.javaboy.org/2021/0527/webflux-stream.html"/>
    <id>http://www.javaboy.org/2021/0527/webflux-stream.html</id>
    <published>2021-05-27T13:30:33.000Z</published>
    <updated>2021-06-21T13:41:28.371Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Stream 流式 API 也是 JDK8 开始引入的 API，用过的小伙伴都说爽，没用过的小伙伴则感到一脸懵逼。现在 JDK 已经到 16 了，可能很多人还不熟悉 Stream 流操作，这次趁着讲 WebFlux，松哥也来和大家一起回顾一下 Stream 流操作。</p><a id="more"></a><p>老实说，松哥在日常工作中，有时候刚好碰上了也会用 Stream 流，用着确实很爽，代码简洁，而且看起来高大上，确实是一个不错的东西。不过组里有很多人其实并不太熟悉 Stream 操作，所以也就没有去强行推广，但是作为一个合格的程序员，还是很有必要去学习一下 Stream 流操作的。</p><h2 id="1-Stream-流简介"><a href="#1-Stream-流简介" class="headerlink" title="1.Stream 流简介"></a>1.Stream 流简介</h2><p>说到 Stream，大家可能很容易想到 Java IO 中的各种流操作，名字看起来很像，但这其实是两个完全不同的东西。</p><p>Java8 中的 Stream 不存储数据，它通过函数式编程模式来对集合进行链状流式操作。</p><h2 id="2-基本玩法"><a href="#2-基本玩法" class="headerlink" title="2.基本玩法"></a>2.基本玩法</h2><p>先来个简单的例子感受下 Stream 的操作。</p><p>例如我有一个数组，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;</span><br></pre></td></tr></table></figure><p>现在想给这个数组求平均数，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">double</span> asDouble = IntStream.of(arr).average().getAsDouble();</span><br></pre></td></tr></table></figure><p>一行代码搞定，首先调用 IntStream.of 方法获取流对象，然后调用 average 方法计算平均数，再调用 getAsDouble 方法获取结果。全程都是方法调用，不用自己写求平均数的逻辑。</p><p>再比如求和，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> sum = IntStream.of(arr).sum();</span><br></pre></td></tr></table></figure><p>也是直接调用 sum 方法即可。</p><p>而且我们还可以在流中对数据进行二次加工，例如给数组中的每个元素先求平方再求和：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">double</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;</span><br><span class="line"><span class="hljs-keyword">double</span> sum = DoubleStream.of(arr).map(i -&gt; Math.pow(i, <span class="hljs-number">2</span>)).sum();</span><br></pre></td></tr></table></figure><p>先在 Map 中对每一个元素求平方，然后再求和。</p><p>这里就能涉及到两个概念：</p><ul><li>中间操作</li><li>终止操作</li></ul><p>所谓中间操作，就是中途求平方的操作，所谓终止操作就是最终计算出结果的操作，只要方法的返回值不是一个 Stream，那就是终止操作，否则就是中间操作。</p><h2 id="3-Stream-的创建"><a href="#3-Stream-的创建" class="headerlink" title="3.Stream 的创建"></a>3.Stream 的创建</h2><p>获取一个流的方式多种多样，最常见的就是从集合或者数组中获取一个流，当然我们也可以直接自己创建一个流出来。</p><p>一起来看下。</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>List 集合或者 Set 集合都可以直接搞一个流出来，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; s1 = list.stream();</span><br><span class="line">Set&lt;String&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; s2 = set.stream();</span><br></pre></td></tr></table></figure><p>集合中直接调用 stream 方法就可以获取到流。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>通过数组获取流的方式也很简单，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream stream = Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="数字-Stream"><a href="#数字-Stream" class="headerlink" title="数字 Stream"></a>数字 Stream</h3><p>也可以直接利用 IntStream、LongStream 等对象创建一个数字 Stream，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream s1 = IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br><span class="line">DoubleStream s2 = DoubleStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br><span class="line">LongStream s3 = LongStream.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">3L</span>);</span><br></pre></td></tr></table></figure><h3 id="自己创建"><a href="#自己创建" class="headerlink" title="自己创建"></a>自己创建</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">Supplier&lt;Integer&gt; supplier = () -&gt; random.nextInt(<span class="hljs-number">100</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.generate(supplier).limit(<span class="hljs-number">5</span>);</span><br></pre></td></tr></table></figure><p>调用  Stream.generate 方法可以自己创建一个流，自己创建的时候需要提供一个 Supplier，通过调用 Supplier 中的 get 方法自动获取到元素。</p><p>无论哪种创建方式，大家需要明白的是，Stream 并不会保存数据，它只会对数据进行加工。</p><h2 id="4-Stream-的中间操作"><a href="#4-Stream-的中间操作" class="headerlink" title="4.Stream 的中间操作"></a>4.Stream 的中间操作</h2><p>中间操作可以分为两大类：</p><ul><li>map 或者 filter 会从输入流中获取每一个元素，并且在输出流中得到一个结果，这些操作没有内部状态，称为无状态操作。</li><li>reduce、sum、max 这些操作都需要内部状态来累计计算结果，所以称为有状态操作。</li></ul><p>分别来看下：</p><p><strong>无状态操作</strong></p><ul><li>map/mapToXxx</li><li>flatMap/flatMapToXxx</li><li>filter</li><li>peek</li></ul><p><strong>有状态操作</strong></p><ul><li>distinct</li><li>sorted</li><li>limit/skip</li></ul><p><strong>map</strong></p><p>Stream.map() 是 Stream 中最常用的一个转换方法，可以把一个 Stream 对象转为另外一个 Stream 对象。map 方法所接收的参数就是一个 Function 对象，松哥在前面文章中和大家介绍过 Function 对象了，就是有输入有输出（参见<a href="https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q" target="_blank" rel="noopener">WebFlux 前置知识（一）</a>），了解了 map 的参数，那么 map 的功能就很明白了，就是对数据进行二次加工。</p><p>举个栗子，例如把一个字符串数组转为数字：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; s1 = Arrays.stream(arr);</span><br><span class="line">Stream&lt;Integer&gt; s2 = s1.map(i -&gt; Integer.valueOf(i));</span><br></pre></td></tr></table></figure><p>再比如一个数字流，给所有的元素乘 2，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).map(i -&gt; <span class="hljs-number">2</span> * i).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>最后的 forEach 就是将元素打印出来。</p><p>JDK 中也提供了一些现成的格式转换，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210522200906.png" alt></p><p>这样可以直接将元素转为 Double、Long、Obj 等类型，例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; s1 = Arrays.stream(arr);</span><br><span class="line">s1.mapToLong(i -&gt; Long.parseLong(i)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>flatMap</strong></p><p>flatMap 可以把 Stream 中的每个元素都映射为一个 Stream，然后再把这多个 Stream 合并为一个 Stream。</p><p>例如如下代码，返回的 Stream 中的元素是数组：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer[]&gt; s = Stream.of(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;);</span><br><span class="line">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>通过 flatMap 我们可以将 Stream 中的元素变为 Integer：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;, <span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;).flatMap( i -&gt; Arrays.stream(i));</span><br><span class="line">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>filter</strong></p><p>filter 操作会对一个 Stream 中的所有元素一一进行判断，不满足条件的就被过滤掉了，剩下的满足条件的元素就构成了一个新的 Stream。</p><p>例如要找到数组中所有大于 3 的元素，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).filter(i -&gt; i &gt; <span class="hljs-number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>filter 方法接收的参数是 Predicate 接口函数，关于 Predicate 接口函数，大家可以参考<a href="https://mp.weixin.qq.com/s/DiaDtt0nW38RKUqQSNKj4Q" target="_blank" rel="noopener">WebFlux 前置知识（一）</a>）一文。</p><p><strong>peek</strong></p><p>peek 的入参是 Consumer，没有返回值，因此当我们要对元素内部进行处理时，使用 peek 是比较合适的，这个时候可以不用 map（map 的入参是 Function，它是有返回值的）。peek 方法本身会继续返回流，可以对数据继续进行处理。</p><p>举个简单的数据转换的例子吧（最终返回的数据并不会被转换）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).filter(i -&gt; i &gt; <span class="hljs-number">3</span>).peek(String::valueOf).forEach(i-&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><blockquote><p>peek 方法的感觉就像数据中途被消费了一次。</p></blockquote><p><strong>distinct</strong></p><p>这个是去重。由于去重操作需要获取到其他元素的值（比较之后才知道是否重复），所以这个是有状态操作。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>sorted</strong></p><p>sorted 是排序，因为也需要知道其他元素的值，然后才能去重，所以这个也是有状态操作，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>).distinct().sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>limit/skip</strong></p><p>limit 和 skip 配合操作有点像数据库中的分页，skip 表示跳过 n 个元素，limit 表示取出 n 个元素。例如下面这个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>).stream().skip(<span class="hljs-number">2</span>).limit(<span class="hljs-number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这个会跳过 A 和 B，最终打印出 C D E。这也是一种有状态操作。</p><h2 id="5-Stream-终止操作"><a href="#5-Stream-终止操作" class="headerlink" title="5.Stream 终止操作"></a>5.Stream 终止操作</h2><p>终止操作就是最终计算出结果的操作，只要方法的返回值不是一个 Stream，那就是终止操作，否则就是中间操作。</p><p>终止操作又分为两类：</p><ul><li>短路操作：不用处理全部元素就可以返回结果。</li><li>非短路操作：必须处理所有元素才能得到最终结果。</li></ul><p>各自都包含哪些操作，我们分别来看下：</p><p><strong>非短路操作</strong></p><ul><li>forEach/forEachOrdered</li><li>collect/toArray</li><li>reduce</li><li>min/max/count</li></ul><p><strong>短路操作</strong></p><ul><li>findFirst/findAny</li><li>allMatch/anyMatch/noneMatch</li></ul><p><strong>forEach/forEachOrdered</strong></p><p>forEach 和 forEachOrdered 都是接收一个 Consumer 类型的参数，完成对参数的消费，不同的是，在并行流中，forEachOrdered 会保证执行顺序。</p><p>例如如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;</span><br><span class="line">Arrays.stream(arr).parallel().forEach(System.out::println);</span><br><span class="line">Arrays.stream(arr).parallel().forEachOrdered(System.out::println);</span><br></pre></td></tr></table></figure><p>前者打印出来的顺序不一定是 123456789，后者一定是。</p><p><strong>collect/toArray</strong></p><p>这两个都是收集器，可以将执行结果转为一个 List 集合或者一个数组：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).filter(p -&gt; p &gt; <span class="hljs-number">2</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p><strong>reduce</strong></p><p>reduce 是 Stream 的一个聚合方法，它可以把一个 Stream 的所有元素按照聚合函数聚合成一个结果。reduce 方法传入的对象是BinaryOperator 接口，它定义了一个apply 方法，负责把上次累加的结果和本次的元素进行运算，并返回累加的结果。</p><p>举个简单的例子，数组求和，当然可以直接调用 sum 计算，我们这里也可以调用 reduce 来实现，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).reduce((i, j) -&gt; i + j);</span><br><span class="line">System.out.println(optional.orElse(-<span class="hljs-number">1</span>));</span><br></pre></td></tr></table></figure><p>reduce 的参数是 BinaryOperator，这个接收两个参数，第一个参数是之前计算的结果，第二个参数是本次参与计算的元素，两者累加求和。</p><p>再比如给一段话中间加上.，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; s = Stream.of(<span class="hljs-string">"wwwjavaboyorg"</span>.split(<span class="hljs-string">""</span>)).reduce((i, j) -&gt; i + <span class="hljs-string">"."</span> + j);</span><br><span class="line">System.out.println(s.orElse(<span class="hljs-string">""</span>));</span><br></pre></td></tr></table></figure><p>最终执行结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.w.w.j.a.v.a.b.o.y.o.r.g</span><br></pre></td></tr></table></figure><p><strong>min/max/count</strong></p><p>这个就比较简单了，就是求最大值最小值，统计总个数，如下表示统计总个数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">long</span> count = s.count();</span><br><span class="line">System.out.println(<span class="hljs-string">"count = "</span> + count);</span><br></pre></td></tr></table></figure><p>如下表示统计最小值：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; s = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line">Optional&lt;Integer&gt; min = s.min(Comparator.comparingInt(i -&gt; i));</span><br><span class="line">System.out.println(<span class="hljs-string">"min.get() = "</span> + min.get());</span><br></pre></td></tr></table></figure><p><strong>findFirst/findAny</strong></p><p>这两个就是返回流中的第一个、任意一个元素，findAny 要在并行流中测试才有效果，举个栗子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">    Optional&lt;Integer&gt; first = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).parallel().findFirst();</span><br><span class="line">    System.out.println(<span class="hljs-string">"first.get() = "</span> + first.get());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="hljs-string">"============="</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">    Optional&lt;Integer&gt; first = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).parallel().findAny();</span><br><span class="line">    System.out.println(<span class="hljs-string">"first.get() = "</span> + first.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>allMatch/anyMatch/noneMatch</strong></p><p>allMatch、anyMatch、noneMatch 用来判断所有元素、任意元素或者没有元素满足给定的条件。这三个方法的参数都是一个 Predicate 接口函数。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">boolean</span> b = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>).allMatch(i -&gt; i &gt; <span class="hljs-number">5</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"b = "</span> + b);</span><br></pre></td></tr></table></figure><h2 id="6-并行流"><a href="#6-并行流" class="headerlink" title="6.并行流"></a>6.并行流</h2><p>通常情况下，对 Stream 的元素进行处理是单线程的，即一个一个元素进行处理。有时候我们希望可以并行处理 Stream 元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。</p><p>把一个普通 Stream 转换为可以并行处理的 Stream 非常简单，只需要用 parallel 方法进行转换：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">new</span> Random().ints().limit(<span class="hljs-number">50</span>).parallel().forEach(i-&gt;&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"---&gt;"</span> + i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样数据在后台就是并行打印的。</p><h2 id="7-收集器"><a href="#7-收集器" class="headerlink" title="7.收集器"></a>7.收集器</h2><p>收集器可以将计算结果重新整理收集到一个集合中，这个集合可以是一个 List/Set 获取其他，并且还可以在收集的过程中对数据进行处理。</p><p>例如我有一个 users 集合，里边保存了用户数据，用户有 username、age 以及 gender 三个属性，如下代码分别表示：</p><ul><li>提取出用户对象中的 age 属性组成新的集合并返回。</li><li>提取出用户对象中的 username 属性组成新的集合并返回。</li><li>提取出用户对象中的 gender 属性组成新的集合并返回（这里是一个 Set 集合，所以会自动去重）。</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ages = users.stream().map(User::getAge).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="hljs-string">"ages = "</span> + ages);</span><br><span class="line">List&lt;String&gt; usernames = users.stream().map(User::getUsername).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="hljs-string">"usernames = "</span> + usernames);</span><br><span class="line">Set&lt;String&gt; genders = users.stream().map(User::getGender).collect(Collectors.toSet());</span><br><span class="line">System.out.println(<span class="hljs-string">"genders = "</span> + genders);</span><br></pre></td></tr></table></figure><p><code>Collectors.toList()</code> 最终返回的是 ArrayList，<code>Collectors.toSet()</code> 最终返回的是 HashSet。</p><p>如果我们想返回一个 Vector 或者 TreeSet，也是可以的，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ages = users.stream().map(User::getAge).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="hljs-string">"ages = "</span> + ages);</span><br><span class="line">List&lt;String&gt; usernames = users.stream().map(User::getUsername).collect(Collectors.toCollection(Vector::<span class="hljs-keyword">new</span>));</span><br><span class="line">System.out.println(<span class="hljs-string">"usernames = "</span> + usernames);</span><br><span class="line">TreeSet&lt;String&gt; genders = users.stream().map(User::getGender).collect(Collectors.toCollection(TreeSet::<span class="hljs-keyword">new</span>));</span><br><span class="line">System.out.println(<span class="hljs-string">"genders = "</span> + genders);</span><br></pre></td></tr></table></figure><p>也可以获取某一个字段的统计信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics ageStatistics = users.stream().collect(Collectors.summarizingInt(User::getAge));</span><br><span class="line">System.out.println(<span class="hljs-string">"ageStatistics = "</span> + ageStatistics);</span><br></pre></td></tr></table></figure><p>这个统计信息中包含：总和、最小值、平均值以及最大值等：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ageStatistics = IntSummaryStatistics&#123;count=<span class="hljs-number">20</span>, sum=<span class="hljs-number">1222</span>, min=<span class="hljs-number">9</span>, average=<span class="hljs-number">61.100000</span>, max=<span class="hljs-number">96</span>&#125;</span><br></pre></td></tr></table></figure><p>还可以对数据进行分块，将男女不同性别统计出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;User&gt;&gt; map = users.stream().collect(Collectors.partitioningBy(u -&gt; u.getGender().equals(<span class="hljs-string">"男"</span>)));</span><br><span class="line">System.out.println(<span class="hljs-string">"map = "</span> + map);</span><br></pre></td></tr></table></figure><p>也可以按照性别对数据进行分组，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;User&gt;&gt; map2 = users.stream().collect(Collectors.groupingBy(User::getGender));</span><br><span class="line">System.out.println(<span class="hljs-string">"map2 = "</span> + map2);</span><br></pre></td></tr></table></figure><p>分组后，Map 中的 key 就是性别；分块后，Map 中的 key 就是 true/false。</p><p>再比如统计男女的人数：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; map2 = users.stream().collect(Collectors.groupingBy(User::getGender,Collectors.counting()));</span><br><span class="line">System.out.println(<span class="hljs-string">"map2 = "</span> + map2);</span><br></pre></td></tr></table></figure><p>好啦，今天我们就先聊这么多～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Stream 流式 API 也是 JDK8 开始引入的 API，用过的小伙伴都说爽，没用过的小伙伴则感到一脸懵逼。现在 JDK 已经到 16 了，可能很多人还不熟悉 Stream 流操作，这次趁着讲 WebFlux，松哥也来和大家一起回顾一下 Stream 流操作。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 前置知识（二）</title>
    <link href="http://www.javaboy.org/2021/0525/method-reference.html"/>
    <id>http://www.javaboy.org/2021/0525/method-reference.html</id>
    <published>2021-05-25T10:04:30.000Z</published>
    <updated>2021-05-25T10:07:32.857Z</updated>
    
    <content type="html"><![CDATA[<p>先来说说上周送书的事。小伙伴们太热情了，留言有 300 多条，但是受微信限制，只能精选100条，所以还有很多小伙伴的留言没有精选，但是松哥都认真看了，还请小伙伴们理解。每次留言送书都会选择困难，不知道书送给谁，每个人我都想送，但是只有六本。。。不停的纠结，每次选幸运小伙伴都要花费一小时以上，下次送书还是考虑抽奖吧，省事哈哈。</p><a id="more"></a><p>上篇文章和小伙伴们聊了 Lambda 表达式和函数接口，今天我们一起来看下 方法引用、变量引用、类型推断以及级联表达式四个点，也算是 WebFlux 的一个前置知识点。</p><p>废话不多说，开整。</p><h2 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1 方法引用"></a>1 方法引用</h2><p>到今天，方法引用估计很多小伙伴可能多多少少都见过，即使自己没写过，可能也看别人写过。用过的小伙伴可能会感觉这个用着真爽，cool！没用过的小伙伴可能就要吐槽这什么鬼代码。</p><p>不管怎么样，我们今天还是来看看方法引用，也算是我们学习 WebFlux 的一个前置知识。</p><h3 id="1-1-什么是方法引用"><a href="#1-1-什么是方法引用" class="headerlink" title="1.1 什么是方法引用"></a>1.1 什么是方法引用</h3><p>什么是方法引用？</p><p>简单说，方法引用就是一个 Lambda 表达式，操作符就是 <code>::</code>，有的小伙伴们可能会觉得所谓的 Lambda 就是 <code>-&gt;</code> 代替匿名内部类，其实不然！Lambda 中包含的东西还是蛮多的，方法引用就算是其中之一。</p><p>有的时候，我们使用 Lambda，需要自己写方法的实现，但是有的时候，我们可能不需要自己写方法的实现，就是单纯的调用一下方法，这种时候，通过方法名称来调用，会更加清晰，可读性更高，也更加简洁易懂。</p><p>方法引用不仅可以用来访问类或者实例中已经存在的方法，也可以用来访问构造方法。</p><h3 id="2-2-四种方法引用"><a href="#2-2-四种方法引用" class="headerlink" title="2.2 四种方法引用"></a>2.2 四种方法引用</h3><h4 id="2-2-1-静态方法引用"><a href="#2-2-1-静态方法引用" class="headerlink" title="2.2.1 静态方法引用"></a>2.2.1 静态方法引用</h4><p>例如我定义一个 Lambda，该 Lambda 中有一个方法可以完成对数字格式的转换，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo05</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;Integer, String&gt; func = a -&gt; String.valueOf(a);</span><br><span class="line">        String s = func.apply(<span class="hljs-number">99</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"s = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的这个 Function 中，我们将一个 Integer 类型数字转为了一个字符串，由于在 Lambda 中并没有其他代码，就是一个简单的类型转换，因为我们可以将之简写成如下方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo05</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Function&lt;Integer, String&gt; func = String::valueOf;</span><br><span class="line">        String s = func.apply(<span class="hljs-number">99</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"s = "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，比如我们有一个 Consumer，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span><br><span class="line">consumer.accept(<span class="hljs-string">"javaboy"</span>);</span><br></pre></td></tr></table></figure><p>Consumer 消费一个字符串，消费的方式就是控制台打印，这种时候我们可以简写成如下方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">consumer.accept(<span class="hljs-string">"javaboy"</span>);</span><br></pre></td></tr></table></figure><p>这就是静态方法引用。</p><p>再举个例子，用 Lambda 写一个给参数求次幂的函数，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;Integer, Integer, Double&gt; func = (a, b) -&gt; Math.pow(a, b);</span><br><span class="line">Double result = func.apply(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"result = "</span> + result);</span><br></pre></td></tr></table></figure><p>传入两个参数类型都是 Integer，返回的数据类型是 Double，调用 Math.pow 计算次幂。</p><p>上面这段代码我们也可以通过静态方法引用简化：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;Integer, Integer, Double&gt; func = Math::pow;</span><br><span class="line">Double result = func.apply(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"result = "</span> + result);</span><br></pre></td></tr></table></figure><h4 id="2-2-2-实例方法引用"><a href="#2-2-2-实例方法引用" class="headerlink" title="2.2.2 实例方法引用"></a>2.2.2 实例方法引用</h4><p>方法引用也可以用在实例方法上。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">IntUnaryOperator func = i -&gt; random.nextInt(i);</span><br><span class="line">Integer r = func.applyAsInt(<span class="hljs-number">10</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"r = "</span> + r);</span><br></pre></td></tr></table></figure><p>这段代码也可以使用方法引用，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">IntUnaryOperator func = random::nextInt;</span><br><span class="line">Integer r = func.applyAsInt(<span class="hljs-number">10</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"r = "</span> + r);</span><br></pre></td></tr></table></figure><p>就是把类换成实例而已，其他都是一样的。</p><p>不过需要注意的是，字符串的实例稍微特殊一些，如下一个字符串排序方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123;<span class="hljs-string">"Barbara"</span>, <span class="hljs-string">"Mary"</span>, <span class="hljs-string">"James"</span>&#125;;</span><br><span class="line">Arrays.sort(stringArray,String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">System.out.println(Arrays.toString(stringArray));</span><br></pre></td></tr></table></figure><p>如果使用方法引用，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123;<span class="hljs-string">"Barbara"</span>, <span class="hljs-string">"Mary"</span>, <span class="hljs-string">"James"</span>&#125;;</span><br><span class="line">Arrays.sort(stringArray, String::compareToIgnoreCase);</span><br><span class="line">System.out.println(Arrays.toString(stringArray));</span><br></pre></td></tr></table></figure><p>这个感觉有点像静态方法引用，其实不是的，Lambda 的第一个参数会成为调用实例方法的对象。</p><p>在实例方法引用中，如果需要指定泛型，泛型放在 <code>::</code> 后面。</p><h4 id="2-2-3-构造方法引用"><a href="#2-2-3-构造方法引用" class="headerlink" title="2.2.3 构造方法引用"></a>2.2.3 构造方法引用</h4><p>例如如下方法提供一个 Cat 实例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Cat&gt; supplier = () -&gt; <span class="hljs-keyword">new</span> Cat();</span><br><span class="line">Cat cat = supplier.get();</span><br></pre></td></tr></table></figure><p>通过方法引用，可以简写成如下形式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Cat&gt; supplier = Cat::<span class="hljs-keyword">new</span>;</span><br><span class="line">Cat cat = supplier.get();</span><br></pre></td></tr></table></figure><h4 id="2-2-4-数组构造方法引用"><a href="#2-2-4-数组构造方法引用" class="headerlink" title="2.2.4 数组构造方法引用"></a>2.2.4 数组构造方法引用</h4><p>例如创建一个长度为 10 的数组，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;<span class="hljs-keyword">int</span>[]&gt; func = (i) -&gt; <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[i];</span><br><span class="line"><span class="hljs-keyword">int</span>[] arr = func.apply(<span class="hljs-number">10</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"arr.length = "</span> + arr.length);</span><br></pre></td></tr></table></figure><p>使用构造方法引用，可以简写成如下方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntFunction&lt;<span class="hljs-keyword">int</span>[]&gt; func = <span class="hljs-keyword">int</span>[]::<span class="hljs-keyword">new</span>;</span><br><span class="line"><span class="hljs-keyword">int</span>[] arr = func.apply(<span class="hljs-number">10</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"arr.length = "</span> + arr.length);</span><br></pre></td></tr></table></figure><h2 id="3-变量引用"><a href="#3-变量引用" class="headerlink" title="3. 变量引用"></a>3. 变量引用</h2><p>内部类中使用外部定义的变量，需要这个变量是一个 final 类型的，如果用了 Lambda 表达式，这个规则依然适用。</p><p>如下；</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="hljs-string">"javaboy"</span>;</span><br><span class="line">Consumer&lt;String&gt; consumer = s1 -&gt; System.out.println(s1 + s);</span><br><span class="line">consumer.accept(<span class="hljs-string">"hello "</span>);</span><br></pre></td></tr></table></figure><p>此时虽然不用给 s 变量添加 final 标记，但是它实际上已经是 final 类型的了，如果强行修改，就会报错：</p><p><img src="http://img.itboyhub.com/2021/02/20210519232242.png" alt></p><h2 id="4-类型推断"><a href="#4-类型推断" class="headerlink" title="4. 类型推断"></a>4. 类型推断</h2><p>大部分情况下，Lambda 表达式都是可以推断出自己的类型的，个别情况下可能推断不出，比如出现方法重载的时候，这个时候可能就需要我们类型强转了，例如如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator2</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator3</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo06</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        calculator((ICalculator2) (a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculator</span><span class="hljs-params">(ICalculator2 iCalculator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">calculator</span><span class="hljs-params">(ICalculator3 iCalculator)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中定义了两个计算器 ICalculator2 和 ICalculator3，然后有一个重载的方法分别用到了 ICalculator2 和 ICalculator3，这就导致在使用 Lambda 表达式时无法推断出到底使用哪个对象，此时我们就需要显式的进行类型强转。</p><h2 id="5-级联表达式"><a href="#5-级联表达式" class="headerlink" title="5. 级联表达式"></a>5. 级联表达式</h2><p>Lambda 表达式也可以写成 N 多层，具体则看需求。</p><p>例如三个数相加，可以写成如下形式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Function&lt;Integer, IntFunction&lt;Integer&gt;&gt;&gt; func = x -&gt; y -&gt; z -&gt; x + y + z;</span><br><span class="line">Integer i = func.apply(<span class="hljs-number">3</span>).apply(<span class="hljs-number">4</span>).apply(<span class="hljs-number">5</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"i = "</span> + i);</span><br></pre></td></tr></table></figure><p>这个表达式从右往左看可能容易理解。</p><p><code>z-&gt;x+y+z</code> 对应的是 <code>IntFunction&lt;Integer&gt;</code>。</p><p><code>z-&gt;x+y+z</code> 整体作为返回，y 作为输入，对应的是 <code>Function&lt;Integer, IntFunction&lt;Integer&gt;&gt;</code>。</p><p><code>y -&gt; z -&gt; x + y + z</code> 整体作为返回，x 作为输入，对应的就是 <code>Function&lt;Integer, Function&lt;Integer, IntFunction&lt;Integer&gt;&gt;&gt;</code>。</p><p>that’s all。</p><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/sun_promise/article/details/51190256" target="_blank" rel="noopener">https://blog.csdn.net/sun_promise/article/details/51190256</a></li><li><a href="https://www.jianshu.com/p/4a3da6a11b58" target="_blank" rel="noopener">https://www.jianshu.com/p/4a3da6a11b58</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先来说说上周送书的事。小伙伴们太热情了，留言有 300 多条，但是受微信限制，只能精选100条，所以还有很多小伙伴的留言没有精选，但是松哥都认真看了，还请小伙伴们理解。每次留言送书都会选择困难，不知道书送给谁，每个人我都想送，但是只有六本。。。不停的纠结，每次选幸运小伙伴都要花费一小时以上，下次送书还是考虑抽奖吧，省事哈哈。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>WebFlux 前置知识（一）</title>
    <link href="http://www.javaboy.org/2021/0525/method-lambda.html"/>
    <id>http://www.javaboy.org/2021/0525/method-lambda.html</id>
    <published>2021-05-25T10:04:18.000Z</published>
    <updated>2021-05-25T10:07:09.128Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>最近太忙了，发文频率有点不稳定，理解万岁。前面和大家说了要更 WebFlux，学习 WebFlux 之前，我们先来学习一些前置知识。</p><a id="more"></a><blockquote><p>Rome was not built in a day。</p></blockquote><p>WebFlux 也不是一帮人拍脑门突然发明的，它是一个漫长的过程，WebFlux 本身在逐步完善，各种配套工具/理论也在逐步发展。</p><p>因此当松哥想写 WebFlux 的时候，发现没法直接从 WebFlux 本身开始写起，对于很多没有接触过函数式编程的人来说，上来就整 WebFlux 还是有一些挑战的，想来想去，我觉得还是先来和大家捋一捋 JDK8 中的一些旧玩意。</p><p>虽然 JDK8 发布距今已经七八年了，但是相信还是有相当多小伙伴用着 JDK8，写着 JDK6 的代码。所以我们有必要回顾一下 JDK8，也算是我们学习 WebFlux 的一些前置知识。</p><p>好啦，开整吧。</p><h2 id="1-Lambda-表达式的四种写法"><a href="#1-Lambda-表达式的四种写法" class="headerlink" title="1.Lambda 表达式的四种写法"></a>1.Lambda 表达式的四种写法</h2><p>JDK8 中引入了 Lambda，这个大家都知道，虽然现在 JDK 都出到 16 了，但是老实说，项目中的 Lambda 表达式似乎还是很少有人用。有的团队技术风格激进，可能会见到很多 Lambda，但是大部分技术团队还是比较保守的。今天为了学习 WebFlux，我们还是先来回顾一下 Lambda 表达式的几种写法。</p><p>先来说说，如果要用 Lambda，必须是只有一个需要强制实现方法的接口，我们可以使用 <code>@FunctionalInterface</code> 注解去标记该接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果该接口中有多个空方法，编译期间就会报错。</p><p>现在我们建议尽量将一个接口设计的小一些，这样也满足单一职责原则。</p><p>不过 JDK8 中引入了 default 方法，就是自带默认实现的那种，自带默认实现的方法可以有多个，这个并不影响 Lambda，并且 <code>@FunctionalInterface</code> 注解也不会去检查默认方法的数量。</p><h3 id="1-1-单个参数的"><a href="#1-1-单个参数的" class="headerlink" title="1.1 单个参数的"></a>1.1 单个参数的</h3><p>如果只是一个参数，那么直接写参数即可，例如如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ICalculator ic = i -&gt; i * i;</span><br><span class="line">        <span class="hljs-keyword">int</span> square = ic.square(<span class="hljs-number">5</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"square = "</span> + square);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数只有一个参数的时候，直接写即可，不需要添加 <code>()</code>。</p><h3 id="1-2-多个参数"><a href="#1-2-多个参数" class="headerlink" title="1.2 多个参数"></a>1.2 多个参数</h3><p>多个参数的话，就需要写上 <code>()</code> 了，以 Spring Security 中登录成功的回调为例（不了解 Spring Security 的小伙伴可在公号后台回复 ss）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    result.put(<span class="hljs-string">"status"</span>, <span class="hljs-number">200</span>);</span><br><span class="line">    result.put(<span class="hljs-string">"msg"</span>, <span class="hljs-string">"使用 logout1 注销成功!"</span>);</span><br><span class="line">    ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();</span><br><span class="line">    String s = om.writeValueAsString(result);</span><br><span class="line">    resp.getWriter().write(s);</span><br><span class="line">&#125;,<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/logout1"</span>,<span class="hljs-string">"GET"</span>))</span><br><span class="line">.defaultLogoutSuccessHandlerFor((req,resp,auth)-&gt;&#123;</span><br><span class="line">    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    result.put(<span class="hljs-string">"status"</span>, <span class="hljs-number">200</span>);</span><br><span class="line">    result.put(<span class="hljs-string">"msg"</span>, <span class="hljs-string">"使用 logout2 注销成功!"</span>);</span><br><span class="line">    ObjectMapper om = <span class="hljs-keyword">new</span> ObjectMapper();</span><br><span class="line">    String s = om.writeValueAsString(result);</span><br><span class="line">    resp.getWriter().write(s);</span><br><span class="line">&#125;,<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/logout2"</span>,<span class="hljs-string">"POST"</span>))</span><br><span class="line">.and()</span><br><span class="line">.csrf().disable();</span><br></pre></td></tr></table></figure><p>这种情况，方法有多个参数，此时使用 Lambda 表达式就需要加上 <code>()</code>。</p><h3 id="1-3-要写参数类型的"><a href="#1-3-要写参数类型的" class="headerlink" title="1.3 要写参数类型的"></a>1.3 要写参数类型的</h3><p>正常来说用 Lambda 时候不需要写上参数类型，但是如果你需要写，就要加上 <code>()</code>，还是上面那个例子，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculator</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo01</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ICalculator ic = (<span class="hljs-keyword">int</span> i) -&gt; i * i;</span><br><span class="line">        <span class="hljs-keyword">int</span> square = ic.square(<span class="hljs-number">5</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"square = "</span> + square);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-方法体不止一行的"><a href="#1-4-方法体不止一行的" class="headerlink" title="1.4 方法体不止一行的"></a>1.4 方法体不止一行的</h3><p>如果方法体不止一行，需要用上 <code>{}</code>，如果方法体只有一行，则不需要 <code>{}</code>，参考上面 2、3。</p><h2 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2.函数接口"></a>2.函数接口</h2><p>JDK8 中自带了函数式接口，使用起来也非常方便。</p><h3 id="2-1基本应用"><a href="#2-1基本应用" class="headerlink" title="2.1基本应用"></a>2.1基本应用</h3><p>我们先来看一个简单的例子。</p><p>假设我有一个打招呼的接口 SayHello，SayHello 接口中只有一个 sayHello 方法，然后在 User 类中调用该接口对应的方法，最终用法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SayHello</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(SayHello sayHello)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> sayHello.sayHello(<span class="hljs-keyword">this</span>.username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo02</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="hljs-keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        String say = user.say((username) -&gt; <span class="hljs-string">"hello "</span> + username);</span><br><span class="line">        System.out.println(<span class="hljs-string">"say = "</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析 main 方法中的调用过程之后，我们发现，在调用时最核心的是如下一行代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(username) -&gt; <span class="hljs-string">"hello "</span> + username</span><br></pre></td></tr></table></figure><p>在这段代码中，我们只关心方法的输入和输出，其他的都不是我所考虑的，为了一个简单的输入输出，我还要额外定义一个接口，这显然不太划算。</p><p>JDK8 中提供了函数接口，可以帮助我们简化上面的接口定义。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(Function&lt;String,String&gt; sayHello)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> sayHello.apply(<span class="hljs-keyword">this</span>.username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo03</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User2 user2 = <span class="hljs-keyword">new</span> User2();</span><br><span class="line">        user2.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        String say = user2.say((username) -&gt; <span class="hljs-string">"hello "</span> + username);</span><br><span class="line">        System.out.println(<span class="hljs-string">"say = "</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用 <code>Function&lt;String,String&gt;</code> 代替我们前面的接口定义，这里有两个泛型，第一个泛型表示接口输入的参数类型，第二个泛型表示接口输出的参数类型，而且大家注意，我们最终 main 方法中的调用方式是不变的。有了 Function 函数之后，以后我们就不需要定义一些简单的接口了。</p><p>而且 Function 函数还支持链式操作，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo03</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User2 user2 = <span class="hljs-keyword">new</span> User2();</span><br><span class="line">        user2.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        Function&lt;String, String&gt; func = (username) -&gt; <span class="hljs-string">"hello "</span> + username;</span><br><span class="line">        String say = user2.say(func.andThen(s -&gt; <span class="hljs-string">"你好 "</span> + s));</span><br><span class="line">        System.out.println(<span class="hljs-string">"say = "</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-其他函数接口"><a href="#2-2-其他函数接口" class="headerlink" title="2.2 其他函数接口"></a>2.2 其他函数接口</h3><table><thead><tr><th style="text-align:left">接口</th><th style="text-align:left">输入参数</th><th style="text-align:left">返回类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">UnaryOperator<t></t></td><td style="text-align:left">T</td><td style="text-align:left">T</td><td style="text-align:left">一元函数，输入输出类型相同</td></tr><tr><td style="text-align:left">Predicate<t></t></td><td style="text-align:left">T</td><td style="text-align:left">boolean</td><td style="text-align:left">断言</td></tr><tr><td style="text-align:left">Consumer<t></t></td><td style="text-align:left">T</td><td style="text-align:left">/</td><td style="text-align:left">消费一个数据，只有输入没有输出</td></tr><tr><td style="text-align:left">Function&lt;T,R&gt;</td><td style="text-align:left">T</td><td style="text-align:left">R</td><td style="text-align:left">输入 T 返回 R，有输入也有输出</td></tr><tr><td style="text-align:left">Supplier<t></t></td><td style="text-align:left">/</td><td style="text-align:left">T</td><td style="text-align:left">提供一个数据，没有输入只有输出</td></tr><tr><td style="text-align:left">BiFunction&lt;T,U,R&gt;</td><td style="text-align:left">(T,U)</td><td style="text-align:left">R</td><td style="text-align:left">两个输入参数</td></tr><tr><td style="text-align:left">BiPredicate&lt;L, R&gt;</td><td style="text-align:left">(L,R)</td><td style="text-align:left">boolean</td><td style="text-align:left">两个输入参数</td></tr><tr><td style="text-align:left">BiConsumer&lt;T, U&gt;</td><td style="text-align:left">(T,U)</td><td style="text-align:left">void</td><td style="text-align:left">两个输入参数</td></tr><tr><td style="text-align:left">BinaryOperator<t></t></td><td style="text-align:left">(T,T)</td><td style="text-align:left">T</td><td style="text-align:left">二元函数，输入输出类型相同</td></tr></tbody></table><p>接下来我们来看看这些函数接口。</p><h4 id="2-2-1-UnaryOperator"><a href="#2-2-1-UnaryOperator" class="headerlink" title="2.2.1 UnaryOperator"></a>2.2.1 UnaryOperator</h4><p>当输入输出类型相同时，可以使用 UnaryOperator 函数接口，例如我们上面的代码，修改之后如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">say</span><span class="hljs-params">(UnaryOperator&lt;String&gt; sayHello)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> sayHello.apply(<span class="hljs-keyword">this</span>.username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo03</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User2 user2 = <span class="hljs-keyword">new</span> User2();</span><br><span class="line">        user2.setUsername(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        UnaryOperator&lt;String&gt; func = (username) -&gt; <span class="hljs-string">"helloo "</span> + username;</span><br><span class="line">        String say = user2.say(func);</span><br><span class="line">        System.out.println(<span class="hljs-string">"say = "</span> + say);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-Predicate"><a href="#2-2-2-Predicate" class="headerlink" title="2.2.2 Predicate"></a>2.2.2 Predicate</h4><p>Predicate 输入一个 T 类型的参数，输出一个 boolean 类型的值。</p><p>举一个简单的例子，例如如下代码，我们定义一个 List 集合中存放着用户姓名，现在要过滤出所有姓张的用户，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo04</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"里斯"</span>, <span class="hljs-string">"张五"</span>);</span><br><span class="line">        List&lt;String&gt; list = names.stream().filter(s -&gt; s.startsWith(<span class="hljs-string">"张"</span>)).collect(Collectors.toList());</span><br><span class="line">        <span class="hljs-keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"s = "</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter 中传入的就是一个 Predicate 函数接口，这个接口接收 String 类型的数据，返回一个 boolean。</p><p><strong>注意</strong></p><p>一些常用类型的函数接口，JDK 中直接提供了相关的类供我们使用，例如 <code>Predicate&lt;Integer&gt;</code> 可以用 <code>IntPredicate</code> 代替；<code>Consumer&lt;Integer&gt;</code> 可以用 <code>IntConsumer</code> 代替。</p><h4 id="2-2-3-Consumer"><a href="#2-2-3-Consumer" class="headerlink" title="2.2.3 Consumer"></a>2.2.3 Consumer</h4><p>看名字就知道，这个是消费数据，只有输入没有输出。</p><p>例如集合的遍历就可以使用 Consumer 函数接口。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LambdaDemo04</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">"张三"</span>, <span class="hljs-string">"里斯"</span>, <span class="hljs-string">"张五"</span>);</span><br><span class="line">        names.stream().forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-Supplier"><a href="#2-2-4-Supplier" class="headerlink" title="2.2.4 Supplier"></a>2.2.4 Supplier</h4><p>Supplier 刚好和 Consumer 相反，它只有输出没有输入。有的时候我们的工厂方法没有输入只有输出，这个时候就可以考虑使用 Supplier（如果有输入参数，则可以考虑使用 Function 函数接口）。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Connection&gt; supplier = ()-&gt;&#123;</span><br><span class="line">    Connection con = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        con = DriverManager.getConnection(<span class="hljs-string">""</span>, <span class="hljs-string">""</span>, <span class="hljs-string">""</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> con;</span><br><span class="line">&#125;;</span><br><span class="line">Connection connection = supplier.get();</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>其实 WebFlux 前置知识还是蛮多的，今天先聊这些吧，我们后面继续。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;最近太忙了，发文频率有点不稳定，理解万岁。前面和大家说了要更 WebFlux，学习 WebFlux 之前，我们先来学习一些前置知识。&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>挖一个大坑，WebFlux 开搞！</title>
    <link href="http://www.javaboy.org/2021/0525/webflux-guide.html"/>
    <id>http://www.javaboy.org/2021/0525/webflux-guide.html</id>
    <published>2021-05-25T10:04:01.000Z</published>
    <updated>2021-05-25T10:06:48.272Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Spring5 的推出，WebFlux 被置于越来越重要的位置，无论是内在的学习驱动，还是公司的项目要求，很多小伙伴们都开始关注 WebFlux 了，也有很多小伙伴在微信上私我能不能整一套 WebFlux 教程？</p><a id="more"></a><p>整当然是能整，不过最近忙是真的忙，松哥最近开始带团队了，有很多需要和其他部门对接的事情，晚上十一点还在出方案。。。写公号的时间被严重压缩了，但是不管怎么样，该写还是要写，不仅仅是对小伙伴们的承诺，也是对自己的承诺。</p><p>想来想去，这次就整 WebFlux 吧，有小伙伴已经催了快一年了，该搞了。</p><p>今天我们就先来介绍下响应式系统，毕竟不了解响应式系统，那学习 WebFlux 干嘛？</p><h2 id="1-什么是响应式系统"><a href="#1-什么是响应式系统" class="headerlink" title="1.什么是响应式系统"></a>1.什么是响应式系统</h2><p>响应式系统的目标是灵敏度高，系统稳健一直有回复，松耦合和可扩展。<strong>响应式系统是一种架构</strong>，可以应用于任何地方，无论是一个小小的博客网页，还是复杂的网购系统，都可以使用响应式架构。</p><p>一般来说，响应式系统有四个显著的特点：</p><ul><li>即时响应（responsive）</li><li>回弹性（resilience）</li><li>弹性（elastic）</li><li>消息驱动（message driven）</li></ul><p>下面这张图很好的描述了这几者之间的关系：</p><p><img src="http://img.itboyhub.com/2021/02/20210420214856.png" alt></p><p>消息驱动是手段，弹性和回弹性是形式，最终的即时响应就是它的价值。</p><p>接下来我们来逐个介绍这四种特性。</p><h2 id="2-四大特点"><a href="#2-四大特点" class="headerlink" title="2.四大特点"></a>2.四大特点</h2><h3 id="2-1-即时响应（responsive）"><a href="#2-1-即时响应（responsive）" class="headerlink" title="2.1 即时响应（responsive）"></a>2.1 即时响应（responsive）</h3><p>即时响应的特点就是一个字，快！</p><p>现在 4G 的普及，百兆千兆带宽的使用，CPU 计算能力的提高，都在降低用户对于一个系统的耐心，一个网页，5s 没加载完，用户已经觉得体验很差了，30s 还没加载出来，那你可能失去这个用户。</p><p>所以我们需要构建一个健壮的、能够快速响应的即时响应系统，特别是在一些高并发的场景下，响应延迟还能保持在合理范围内，这才是最重要的。</p><p>要实现这一目标，要用到很多具体的技术，例如异步加载、预加载等。另外还涉及到弹性（elastic）与回弹性（resilience）这样一些原则性问题。</p><h3 id="2-2-弹性（elastic）"><a href="#2-2-弹性（elastic）" class="headerlink" title="2.2 弹性（elastic）"></a>2.2 弹性（elastic）</h3><p>弹性其实就是指系统随时可以动态扩展。</p><p>举个例子，一个电商网站，平时活跃用户有限，所需要的服务器数量足够支撑日常服务即可，没有必要多买，毕竟都是要花钱的。一旦遇上大促，系统的流量在短时间内爆发出来，这个时候就需要能够随时随地方便的为系统扩容，这就是系统的弹性。</p><p>松哥在之前的文章中和大家聊过 Nginx 负载均衡，这其实就是一种扩容的手段。现在很多中小公司可能回采用云服务，如果使用云服务，一般都可以非常方便的实现动态扩容。</p><h3 id="2-3-回弹性（resilience）"><a href="#2-3-回弹性（resilience）" class="headerlink" title="2.3 回弹性（resilience）"></a>2.3 回弹性（resilience）</h3><p>回弹性就是指当系统遭遇到失败时，依然能够对外提供服务。松哥在之前和大家分享 Spring Cloud 时，Hystrix 的功能之一就是容错，当一个服务崩掉的时候，不会拖累到其他服务。通过服务的降级、隔离等手段，可以保证回弹性。回弹性还会要求在系统出错的时候，能够自动进行重试。</p><p>其实大家看回弹性这个单词 resilience，不知道有没有想起来在 Spring Cloud 体系中，用来替代 Hystrix 的工具就叫做 resilience4j，所以如果你了解 Hystrix 的功能，大概就知道什么是回弹性。不了解 Spring Cloud 的话，可以看看这个网站：<a href="http://www.itboyhub.com。" target="_blank" rel="noopener">www.itboyhub.com。</a></p><h3 id="2-4-消息驱动（message-driven）"><a href="#2-4-消息驱动（message-driven）" class="headerlink" title="2.4 消息驱动（message driven）"></a>2.4 消息驱动（message driven）</h3><p>消息驱动是具体的实现手段。</p><p>在分布式系统中，我们要解耦、隔离服务、提高可伸缩性，为了达成这一目标，消息驱动是最佳选择。因为只有消息驱动能够同时满足即时响应、弹性以及回弹性这些要求。</p><p>有的小伙伴在学习微服务的时候，可能会看到一个名词，就叫做消息驱动的微服务。</p><p>在松哥的微人事中，有一个邮件发送的功能，就用到了消息驱动，发件人只需要把邮件内容扔到消息中间件中即可，剩余的事情都不用管了，邮件服务器会自动从消息中间件中读取邮件信息然后将邮件发送出去，发送失败的事务、回滚等等操作，都由邮件服务器自行处理，发送方只管把消息扔出去就行了，这就很好的实现了解耦。</p><p>这就是我们常说的响应式系统的四大特点。</p><h2 id="3-身边的响应式系统"><a href="#3-身边的响应式系统" class="headerlink" title="3.身边的响应式系统"></a>3.身边的响应式系统</h2><p>响应式系统其实离我们并不远，不是说用了 WebFlux、用了 Gateway、用了异步 Servlet 就是响应式系统，这其实没有必然联系，上面那些都是实现响应式系统的一个具体方案，具体技术而已。</p><p>举一个很简单的消息驱动微服务的案例，如下图：</p><p><img src="https://zsrimg.ikafan.com/file_images/article/201910/20191015105956901.png?201991511043" alt></p><p>引入了消息中间件 RabbitMQ/Kafka 之后，能够很好的实现 A 服务和 B 服务的解耦，同时利用 RabbitMQ/Kafka 自带的消息消费失败重试的功能也能很好的提高系统的容错性和可靠性。</p><p>松哥之前专门录过提高消息中间件可靠性的视频，感兴趣的小伙伴可以看看：</p><p>提高可靠性：<br><!--视频1--><br>处理幂等性：<br><!--视频2--></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>总之，响应式系统是一个架构层面的东西，它有四个基本特点，它还有很多具体的实现手段，这些具体的实现手段松哥将在未来的文章中和大家逐一进行介绍。好啦，本文作为一个引子，就先和大家聊这么多，关于响应式系统，如果大家有自己的理解或者实践经验，欢迎投稿哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Spring5 的推出，WebFlux 被置于越来越重要的位置，无论是内在的学习驱动，还是公司的项目要求，很多小伙伴们都开始关注 WebFlux 了，也有很多小伙伴在微信上私我能不能整一套 WebFlux 教程？&lt;/p&gt;
    
    </summary>
    
      <category term="WebFlux" scheme="http://www.javaboy.org/categories/WebFlux/"/>
    
    
      <category term="WebFlux" scheme="http://www.javaboy.org/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>世界有你，了不起！</title>
    <link href="http://www.javaboy.org/2021/0428/2021hdc.html"/>
    <id>http://www.javaboy.org/2021/0428/2021hdc.html</id>
    <published>2021-04-28T11:43:33.000Z</published>
    <updated>2021-04-28T11:44:37.074Z</updated>
    
    <content type="html"><![CDATA[<p>虽然也一把年纪了，但是看到余承东演讲最后这一句，还是有点热血。</p><p><img src="http://img.itboyhub.com//2020/04/vhr/c6131d55af30b6c36b1a148cf2029d8.jpg" alt></p><p>世界有你了不起！</p><a id="more"></a><p>2021 华为开发者大会 4 月 24 - 4 月 26 在深圳大学城举办，四年前我刚来深圳的时候，就住在大学城附近，周末有空了还会去学校里走走，哈工大（深圳）、清北的深圳研究生院都在这里，号称“深圳莱茵河”的大沙河从这里穿过，当时我每天晚上还沿大沙河跑步。大学城北靠西丽水库、南依塘朗山，实在是学习开会的好地方。开会，我最喜欢去的就是这种地方，可以让人很放松，特别是高校里边。</p><p>这届大会主题是#<strong>每一个开发者都了不起</strong>#！这句话是真的好听！</p><p><img src="http://img.itboyhub.com/2021/02/20210427194157.png" alt></p><p>这届大会一共是三天，不过 4 月 24 的活动主要是针对学生，我因为当天从广州赶回深圳，来不及就没去了。25、26 两天则有大量的主题峰会以及训练营，特别是余承东重磅发布了华为云 6 大创新产品及服务，这个就不能错过了。</p><p>25 号一大早 7 点 40 左右就从家里出发，计划 8 点半左右到会场，结果我还是错估了深圳地铁的实力，25 号因为刚好是五一假期补班，赶上早高峰，我到地铁口我就惊呆了，长不见尾的队伍。。。就这样计划稍微受到一点影响，到会场的时候差不多 9 点了。</p><p><img src="http://img.itboyhub.com/2021/02/稿定设计导出-20210427-195803.jpg" alt></p><p>因为这次大会是在大学城举办，不同会场距离较远，因此检票进入后，可以坐接驳的电瓶车去不同的会场。已经过了 9 点了，早上的峰会将在 9 点半开始，于是赶紧上车，go！</p><p>峰会在深圳大学城体育馆举行，这是会场门口：</p><p><img src="http://img.itboyhub.com/2021/02/20210427200523.png" alt></p><p>在华为手机芯片被限制的情况下，现在余承东也在管着华为云（华为云 CEO）和汽车等业务，所以峰会的第一场演讲就是余承东带来的，现场发布了华为云 6 大创新产品及服务，包括：</p><ul><li>华为云 CCE Turbo 云容器集群</li><li>CloudIDE 智能编程助手</li><li>GaussDB（for openGauss）数据库</li><li>可信智能计算服务 TICS</li><li>华为云盘古系列大模型</li><li>多样性计算基础软件</li></ul><p>无论是搞云原生、数据库、人工智能、数据分析还是其他，这些发布的产品或者服务，总有一个能让你提神。</p><p>特别是华为云盘古系列超大规模预训练模型，包括 30 亿参数的全球最大视觉(CV)预训练模型，以及与循环智能、鹏城实验室联合开发的千亿参数、40TB 训练数据的全球最大中文语言(NLP)预训练模型。</p><p>有点后悔的是女朋友没来，女朋友现在在腾讯游戏做大数据分析，现场发布的挺多产品跟她的工作关联性都挺大，不过她那天要上班，没来，我带了另外几个小伙伴一起过来。</p><p><img src="http://img.itboyhub.com/2021/02/20210427202406.png" alt><br><img src="http://img.itboyhub.com/2021/02/20210427202557.png" alt></p><p>我也是第一次近距离听余总演讲，还是挺开心的哈哈。</p><p>余承东演讲完后，接下来还有其他一些大佬上台，有小红书的技术负责人分享他们在华为云上的一些实践心得等等。</p><p><img src="http://img.itboyhub.com/2021/02/20210427202955.png" alt></p><p>早上的峰会时间挺长的，峰会结束后我们又坐电瓶车去了展岛。</p><p>在展岛总算找到组织啦，开发者社区！又见到了很多小伙伴，也认识很多新的小伙伴，太激动了，进去后忘了拍照。。。</p><p><img src="http://img.itboyhub.com/2021/02/20210427203343.png" alt></p><p>今年的开发者社区我们有一个解忧咖啡馆活动，还蛮有意思的，松哥还在现场录了一个 vlog，等弄好了拿出来给小伙伴们过目。</p><p>在展岛我们也看到了华为前段时间刚刚发布的赛力斯汽车（不是自动驾驶那个），近距离体验了一把：</p><p><img src="http://img.itboyhub.com/2021/02/20210427203801.png" alt></p><p><img src="http://img.itboyhub.com/2021/02/稿定设计导出-20210427-204154.jpg" alt></p><p>展岛有很多好玩的打卡活动，我下午去参加训练营和鲲鹏应用实践去了，等我回来的时候，三个小伙伴已经打了一遍卡了。</p><p><img src="http://img.itboyhub.com/2021/02/20210427204536.png" alt></p><p>这些打卡活动都还是挺好玩的，能让我们近距离体验一把华为云的技术，跑一把 ModelArts ，或者 DIY 一下硬件：</p><p><img src="http://img.itboyhub.com/2021/02/稿定设计导出-20210427-210948.jpg" alt></p><p>…</p><p>总之，这次活动还是蛮有意思的。</p><p>老实说，华为在手机芯片被制裁后，手机市场份额下滑厉害，华为云被寄予了厚望，这次大会也是余承东出任华为云 CEO 后的首次公开亮相，余承东回来带领华为云，对内鼓励人心，对外也给人很大期待。毕竟余承东曾经在无线和消费者业务上都有着非常亮眼的成绩。</p><p>不过困难也不小，从 IDC 的报告中我们也可以看出来，仅国内来说，公有云市场目前还是阿里云最强，也期待华为云能够早日走出 others。</p><p><img src="http://img.itboyhub.com/2021/02/20210427211817.png" alt></p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然也一把年纪了，但是看到余承东演讲最后这一句，还是有点热血。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.itboyhub.com//2020/04/vhr/c6131d55af30b6c36b1a148cf2029d8.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;世界有你了不起！&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot一键换肤，so easy！</title>
    <link href="http://www.javaboy.org/2021/0423/springmvc-theme.html"/>
    <id>http://www.javaboy.org/2021/0423/springmvc-theme.html</id>
    <published>2021-04-23T12:14:45.000Z</published>
    <updated>2021-04-23T12:15:40.007Z</updated>
    
    <content type="html"><![CDATA[<p>SpringMVC 源码分析系列最后一篇，和大家聊一聊 Theme。</p><a id="more"></a><p>Theme，就是主题，点一下就给网站更换一个主题，相信大家都用过类似功能，这个其实和前面所说的国际化功能很像，代码其实也很像，今天我们就来捋一捋。</p><p>考虑到有的小伙伴可能还没用过 Theme，所以这里松哥先来说下用法，然后我们再进行源码分析。</p><h2 id="1-一键换肤"><a href="#1-一键换肤" class="headerlink" title="1.一键换肤"></a>1.一键换肤</h2><p>来做一个简单的需求，假设我的页面上有三个按钮，点击之后就能一键换肤，像下面这样：</p><p><img src="http://img.itboyhub.com/2021/02/20210409191940.png" alt></p><p>我们来看下这个需求怎么实现。</p><p>首先三个按钮分别对应了三个不同的样式，我们先把这三个不同的样式定义出来，分别如下：</p><p>blue.css：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">body</span>&#123;</span><br><span class="line">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#05e1ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>green.css：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">body</span>&#123;</span><br><span class="line">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#aaff9c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>red.css：</p><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">body</span>&#123;</span><br><span class="line">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff0721</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主题的定义，往往是一组样式，因此我们一般都是在一个 properties 文件中将同一主题的样式配置在一起，这样方便后期加载。</p><p>所以接下来我们在 resources 目录下新建 theme 目录，然后在 theme 目录中创建三个文件，内容如下：</p><p>blue.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.body=/css/blue.css</span><br></pre></td></tr></table></figure><p>green.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.body=/css/green.css</span><br></pre></td></tr></table></figure><p>red.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.body=/css/red.css</span><br></pre></td></tr></table></figure><p>在不同的 properties 配置文件中引入不同的样式，但是样式定义的 key 都是 index.body，这样方便后期在页面中引入。</p><p>接下来在 SpringMVC 容器中配置三个 Bean，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.theme.ThemeChangeInterceptor"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"paramName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"theme"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"themeSource"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.ui.context.support.ResourceBundleThemeSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basenamePrefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"theme."</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"themeResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.theme.SessionThemeResolver"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultThemeName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"blue"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>首先配置拦截器 ThemeChangeInterceptor，这个拦截器用来解析主题参数，参数的 key 为 theme，例如请求地址是 <code>/index?theme=blue</code>，该拦截器就会自动设置系统主题为 blue。当然也可以不配置拦截器，如果不配置的话，就可以单独提供一个修改主题的接口，然后手动修改主题，类似下面这样：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line"><span class="hljs-keyword">private</span> ThemeResolver themeResolver;</span><br><span class="line"><span class="hljs-meta">@RequestMapping</span>(path = <span class="hljs-string">"/01/&#123;theme&#125;"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">theme1</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"theme"</span>)</span> String themeStr, HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line">    themeResolver.setThemeName(request,response, themeStr);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/01"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>themeStr 就是新的主题名称，将其配置给 themeResolver 即可。</p><ol start="2"><li>接下来配置 ResourceBundleThemeSource，这个 Bean 主要是为了加载主题文件，需要配置一个 basenamePrefix 属性，如果我们的主题文件放在文件夹中，这个 basenamePrefix 的值就是 <code>文件夹名称.</code>。</li><li>接下来配置主题解析器，主题解析器有三种，分别是 CookieThemeResolver、FixedThemeResolver、SessionThemeResolver，这里我们使用的是 SessionThemeResolver，主题信息将被保存在 Session 中，只要 Session 不变，主题就一直有效。这三个主题解析器松哥会在下一小节中和大家仔细分析。</li></ol><p>配置完成后，我们再来提供一个测试页面，如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="hljs-string">"spring"</span> uri=<span class="hljs-string">"http://www.springframework.org/tags"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="hljs-string">"text/html;charset=UTF-8"</span> language=<span class="hljs-string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"&lt;spring:theme code="</span>index.body<span class="hljs-string">" /&gt;"</span> &gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    一键切换主题：&lt;br/&gt;</span><br><span class="line">    &lt;a href="/index?theme=blue"&gt;托帕蓝&lt;/a&gt;</span><br><span class="line">    &lt;a href="/index?theme=red"&gt;多巴胺红&lt;/a&gt;</span><br><span class="line">    &lt;a href="/index?theme=green"&gt;石竹青&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>最关键的是：</p><figure class="highlight jsp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"&lt;spring:theme code="</span>index.body<span class="hljs-string">" /&gt;"</span> &gt;</span><br></pre></td></tr></table></figure><p>css 样式不直接写，而是引用我们在 properties 文件中定义的 index.body，这样将根据当前主题加载不同的 css 文件。</p><p>最后再提供一个处理器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(path = <span class="hljs-string">"/index"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span>  String <span class="hljs-title">getPage</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就很简单了，没啥好说的。</p><p>最后启动项目进行测试，大家就可以看到我们文章一开始给出的图片了，点击不同的按钮就可以实现背景的切换。</p><p>是不是非常 Easy！</p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2.原理分析"></a>2.原理分析</h2><p>主题这块涉及到的东西主要就是主题解析器，主题解析器和我们前面所说的国际化的解析器非常类似，但是比它更简单，我们一起来分析下。</p><p>先来看下 ThemeResolver 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ThemeResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">resolveThemeName</span><span class="hljs-params">(HttpServletRequest request)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setThemeName</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中就两个方法：</p><ol><li>resolveThemeName：从当前请求中解析出主题的名字。</li><li>setThemeName：设置当前主题。</li></ol><p>ThemeResolver 主要有三个实现类，继承关系如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210409203413.png" alt></p><p>接下来我们对这几个实现类来逐个分析。</p><h3 id="2-1-CookieThemeResolver"><a href="#2-1-CookieThemeResolver" class="headerlink" title="2.1 CookieThemeResolver"></a>2.1 CookieThemeResolver</h3><p>直接上源码吧：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">resolveThemeName</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String themeName = (String) request.getAttribute(THEME_REQUEST_ATTRIBUTE_NAME);</span><br><span class="line"><span class="hljs-keyword">if</span> (themeName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> themeName;</span><br><span class="line">&#125;</span><br><span class="line">String cookieName = getCookieName();</span><br><span class="line"><span class="hljs-keyword">if</span> (cookieName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Cookie cookie = WebUtils.getCookie(request, cookieName);</span><br><span class="line"><span class="hljs-keyword">if</span> (cookie != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String value = cookie.getValue();</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(value)) &#123;</span><br><span class="line">themeName = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (themeName == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">themeName = getDefaultThemeName();</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, themeName);</span><br><span class="line"><span class="hljs-keyword">return</span> themeName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThemeName</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (StringUtils.hasText(themeName)) &#123;</span><br><span class="line">request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, themeName);</span><br><span class="line">addCookie(response, themeName);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">request.setAttribute(THEME_REQUEST_ATTRIBUTE_NAME, getDefaultThemeName());</span><br><span class="line">removeCookie(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看 resolveThemeName 方法：</p><ol><li>首先会尝试直接从请求中获取主题名称，如果获取到了，就直接返回。</li><li>如果第一步没有获取到主题名称，接下来就尝试从 Cookie 中获取主题名称，Cookie 也是从当前请求中提取，利用 WebUtils 工具进行解析，如果解析到了主题名称，就赋值给 themeName 变量。</li><li>如果前面没有获取到主题名称，就使用默认的主题名称，开发者可以自行配置默认的主题名称，如果不配置，就是 theme。</li><li>将解析出来的 theme 保存到 request 中，以备后续使用。</li></ol><p>再来看 setThemeName 方法：</p><ol><li>如果存在 themeName 就进行设置，同时将 themeName 添加到 Cookie 中。</li><li>如果不存在 themeName，就设置一个默认的主题名，同时从 response 中移除 Cookie。</li></ol><p>可以看到，整个实现思路还是非常简单的。</p><h3 id="2-2-AbstractThemeResolver"><a href="#2-2-AbstractThemeResolver" class="headerlink" title="2.2 AbstractThemeResolver"></a>2.2 AbstractThemeResolver</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractThemeResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThemeResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ORIGINAL_DEFAULT_THEME_NAME = <span class="hljs-string">"theme"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> String defaultThemeName = ORIGINAL_DEFAULT_THEME_NAME;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDefaultThemeName</span><span class="hljs-params">(String defaultThemeName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.defaultThemeName = defaultThemeName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDefaultThemeName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultThemeName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractThemeResolver 主要提供了配置默认主题的能力。</p><h3 id="2-3-FixedThemeResolver"><a href="#2-3-FixedThemeResolver" class="headerlink" title="2.3 FixedThemeResolver"></a>2.3 FixedThemeResolver</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FixedThemeResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractThemeResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">resolveThemeName</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getDefaultThemeName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThemeName</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Cannot change theme - use a different theme resolution strategy"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThemeResolver 就是使用默认的主题名称，并且不允许修改主题。</p><h3 id="2-4-SessionThemeResolver"><a href="#2-4-SessionThemeResolver" class="headerlink" title="2.4 SessionThemeResolver"></a>2.4 SessionThemeResolver</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionThemeResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractThemeResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String THEME_SESSION_ATTRIBUTE_NAME = SessionThemeResolver.class.getName() + <span class="hljs-string">".THEME"</span>;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">resolveThemeName</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String themeName = (String) WebUtils.getSessionAttribute(request, THEME_SESSION_ATTRIBUTE_NAME);</span><br><span class="line"><span class="hljs-keyword">return</span> (themeName != <span class="hljs-keyword">null</span> ? themeName : getDefaultThemeName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThemeName</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable String themeName)</span> </span>&#123;</span><br><span class="line">WebUtils.setSessionAttribute(request, THEME_SESSION_ATTRIBUTE_NAME,</span><br><span class="line">(StringUtils.hasText(themeName) ? themeName : <span class="hljs-keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>resolveThemeName：从 session 中取出主题名称并返回，如果 session 中的主题名称为 null，就返回默认的主题名称。</li><li>setThemeName：将主题配置到请求中。</li></ul><p>不想多说，因为很简单。</p><h3 id="2-5-ThemeChangeInterceptor"><a href="#2-5-ThemeChangeInterceptor" class="headerlink" title="2.5 ThemeChangeInterceptor"></a>2.5 ThemeChangeInterceptor</h3><p>最后我们再来看一看 ThemeChangeInterceptor 拦截器，这个拦截器会自动从请求中提取出主题参数，并设置到请求中，核心部分在 preHandle 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">String newTheme = request.getParameter(<span class="hljs-keyword">this</span>.paramName);</span><br><span class="line"><span class="hljs-keyword">if</span> (newTheme != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">ThemeResolver themeResolver = RequestContextUtils.getThemeResolver(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (themeResolver == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No ThemeResolver found: not in a DispatcherServlet request?"</span>);</span><br><span class="line">&#125;</span><br><span class="line">themeResolver.setThemeName(request, response, newTheme);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从请求中提取出 theme 参数，并设置到 themeResolver 中。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，这就是今天和小伙伴们分享的一键换肤！无论是功能性还是源码，都和国际化非常类似，但是比国际化简单很多，不知道小伙伴们有没有 GET 到呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringMVC 源码分析系列最后一篇，和大家聊一聊 Theme。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>这篇文章让你搞懂 SpringMVC 国际化！</title>
    <link href="http://www.javaboy.org/2021/0420/springmvc-i18n.html"/>
    <id>http://www.javaboy.org/2021/0420/springmvc-i18n.html</id>
    <published>2021-04-20T12:54:49.000Z</published>
    <updated>2021-04-20T12:56:05.917Z</updated>
    
    <content type="html"><![CDATA[<p>松哥之前写过 Spring Boot 国际化的问题，不过那一次没讲源码，这次咱们整点源码来深入理解下这个问题。</p><a id="more"></a><p>国际化，也叫 i18n，为啥叫这个名字呢？因为国际化英文是 internationalization ，在 i 和 n 之间有 18 个字母，所以叫 i18n。我们的应用如果做了国际化就可以在不同的语言环境下，方便的进行切换，最常见的就是中文和英文之间的切换，国际化这个功能也是相当的常见。</p><h2 id="1-SpringMVC-国际化配置"><a href="#1-SpringMVC-国际化配置" class="headerlink" title="1.SpringMVC 国际化配置"></a>1.SpringMVC 国际化配置</h2><p>还是先来说说用法，再来说源码，这样大家不容易犯迷糊。我们先说在 SSM 中如何处理国际化问题。</p><p>首先国际化我们可能有两种需求：</p><ul><li>在页面渲染时实现国际化（这个借助于 Spring 标签实现）</li><li>在接口中获取国际化匹配后的消息</li></ul><p>大致上就是上面这两种场景。接下来松哥通过一个简单的用法来和大家演示下具体玩法。</p><p>首先我们在项目的 resources 目录下新建语言文件，language_en_US.properties 和 language_zh-CN.properties，如下图：</p><p><img src="http://img.itboyhub.com/2021/02/20210401204229.png" alt></p><p>内容分别如下：</p><p>language_en_US.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login.username=Username</span><br><span class="line">login.password=Password</span><br></pre></td></tr></table></figure><p>language_zh-CN.properties：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">login.username=用户名</span><br><span class="line">login.password=用户密码</span><br></pre></td></tr></table></figure><p>这两个分别对应英中文环境。配置文件写好之后，还需要在 SpringMVC 容器中提供一个 ResourceBundleMessageSource 实例去加载这两个实例，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.context.support.ResourceBundleMessageSource"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"messageSource"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"basename"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"language"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultEncoding"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"UTF-8"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里配置了文件名 language 和默认的编码格式。</p><p>接下来我们新建一个 login.jsp 文件，如下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="hljs-string">"spring"</span> uri=<span class="hljs-string">"http://www.springframework.org/tags"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="hljs-string">"text/html;charset=UTF-8"</span> language=<span class="hljs-string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;spring:message code=<span class="hljs-string">"login.username"</span>/&gt; &lt;input type=<span class="hljs-string">"text"</span>&gt; &lt;br&gt;</span><br><span class="line">&lt;spring:message code=<span class="hljs-string">"login.password"</span>/&gt; &lt;input type=<span class="hljs-string">"text"</span>&gt; &lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在这个文件中，我们通过 <code>spring:message</code> 标签来引用变量，该标签会根据当前的实际情况，选择合适的语言文件。</p><p>接下来我们为 login.jsp 提供一个控制器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        String username = messageSource.getMessage(<span class="hljs-string">"login.username"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">        String password = messageSource.getMessage(<span class="hljs-string">"login.password"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">        System.out.println(<span class="hljs-string">"username = "</span> + username);</span><br><span class="line">        System.out.println(<span class="hljs-string">"password = "</span> + password);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器中直接返回 login 视图即可。</p><p>另外我这还注入了 MessageSource 对象，主要是为了向大家展示如何在处理器中获取国际化后的语言文字。</p><p>配置完成后，启动项目进行测试。</p><p>默认情况下，系统是根据请求头的中 Accept-Language 字段来判断当前的语言环境的，该这个字段由浏览器自动发送，我们这里为了测试方便，可以使用 POSTMAN 进行测试，然后手动设置 Accept_Language 字段。</p><p>首先测试中文环境：</p><p><img src="http://img.itboyhub.com/2021/02/20210401205538.png" alt></p><p>然后测试英文环境：</p><p><img src="http://img.itboyhub.com/2021/02/20210401205612.png" alt></p><p>都没问题，完美！同时观察 IDEA 控制台，也能正确打印出语言文字。</p><p>上面这个是基于 AcceptHeaderLocaleResolver 来解析出当前的区域和语言的。</p><p>有的时候，我们希望语言环境直接通过请求参数来传递，而不是通过请求头来传递，这个需求我们通过 SessionLocaleResolver 或者 CookieLocaleResolver 都可以实现。</p><p>先来看 SessionLocaleResolver。</p><p>首先在 SpringMVC 配置文件中提供 SessionLocaleResolver 的实例，同时配置一个拦截器，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"paramName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"locale"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.SessionLocaleResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"localeResolver"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SessionLocaleResolver 是负责区域解析的，这个没啥好说的。拦截器 LocaleChangeInterceptor 则主要是负责参数解析的，我们在配置拦截器的时候，设置了参数名为 locale（默认即此），也就是说我们将来可以通过 locale 参数来传递当前的环境信息。</p><p>配置完成后，我们还是来访问刚才的 login 控制器，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210401210442.png" alt></p><p>此时我们可以直接通过 locale 参数来控制当前的语言环境，这个 locale 参数就是在前面所配置的 LocaleChangeInterceptor 拦截器中被自动解析的。</p><p>如果你不想配置 LocaleChangeInterceptor 拦截器也是可以的，直接自己手动解析 locale 参数然后设置 locale 也行，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String locale,HttpSession session)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"zh-CN"</span>.equals(locale)) &#123;</span><br><span class="line">            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">"zh"</span>, <span class="hljs-string">"CN"</span>));</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"en-US"</span>.equals(locale)) &#123;</span><br><span class="line">            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">"en"</span>, <span class="hljs-string">"US"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        String username = messageSource.getMessage(<span class="hljs-string">"login.username"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">        String password = messageSource.getMessage(<span class="hljs-string">"login.password"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">        System.out.println(<span class="hljs-string">"username = "</span> + username);</span><br><span class="line">        System.out.println(<span class="hljs-string">"password = "</span> + password);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SessionLocaleResolver 所实现的功能也可以通过 CookieLocaleResolver 来实现，不同的是前者将解析出来的区域信息保存在 session 中，而后者则保存在 Cookie 中。<strong>保存在 session 中，只要 session 没有发生变化，后续就不用再次传递区域语言参数了，保存在 Cookie 中，只要 Cookie 没变，后续也不用再次传递区域语言参数了</strong>。</p><p>使用 CookieLocaleResolver 的方式很简单，直接在 SpringMVC 中提供 CookieLocaleResolver 的实例即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"org.springframework.web.servlet.i18n.CookieLocaleResolver"</span> id=<span class="hljs-string">"localeResolver"</span>/&gt;</span><br></pre></td></tr></table></figure><p>注意这里也需要使用到 LocaleChangeInterceptor 拦截器，如果不使用该拦截器，则需要自己手动解析并配置语言环境，手动解析并配置的方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login3"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login3</span><span class="hljs-params">(String locale, HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">    CookieLocaleResolver resolver = <span class="hljs-keyword">new</span> CookieLocaleResolver();</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-string">"zh-CN"</span>.equals(locale)) &#123;</span><br><span class="line">        resolver.setLocale(req, resp, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">"zh"</span>, <span class="hljs-string">"CN"</span>));</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"en-US"</span>.equals(locale)) &#123;</span><br><span class="line">        resolver.setLocale(req, resp, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">"en"</span>, <span class="hljs-string">"US"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    String username = messageSource.getMessage(<span class="hljs-string">"login.username"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    String password = messageSource.getMessage(<span class="hljs-string">"login.password"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    System.out.println(<span class="hljs-string">"username = "</span> + username);</span><br><span class="line">    System.out.println(<span class="hljs-string">"password = "</span> + password);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，启动项目进行测试，这次测试的方式跟 SessionLocaleResolver 的测试方式一致，松哥就不再多说了。</p><p>除了前面介绍的这几种 LocaleResolver 之外，还有一个 FixedLocaleResolver，因为比较少见，松哥这里就不做过多介绍了。</p><h2 id="2-Spring-Boot-国际化配置"><a href="#2-Spring-Boot-国际化配置" class="headerlink" title="2.Spring Boot 国际化配置"></a>2.Spring Boot 国际化配置</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><p>Spring Boot 和 Spring 一脉相承，对于国际化的支持，默认是通过 AcceptHeaderLocaleResolver 解析器来完成的，这个解析器，默认是通过请求头的 Accept-Language 字段来判断当前请求所属的环境的，进而给出合适的响应。</p><p>所以在 Spring Boot 中做国际化，这一块我们可以不用配置，直接就开搞。</p><p>首先创建一个普通的 Spring Boot 项目，添加 web 依赖即可。项目创建成功后，默认的国际化配置文件放在 resources 目录下，所以我们直接在该目录下创建四个测试文件，如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-1.png" alt></p><ul><li>我们的 message 文件是直接创建在 resources 目录下的，IDEA 在展示的时候，会多出一个 Resource Bundle，这个大家不用管，千万别手动去创建这个目录。</li><li>messages.properties 这个是默认的配置，其他的则是不同语言环境下的配置，en_US 是英语(美国)，zh_CN 是中文简体，zh_TW 是中文繁体（文末附录里边有一个完整的语言简称表格）。</li></ul><p>四个文件创建好之后，第一个默认的我们可以先空着，另外三个分别填入以下内容：</p><p>messages_zh_CN.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=江南一点雨</span><br></pre></td></tr></table></figure><p>messages_zh_TW.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=江南壹點雨</span><br></pre></td></tr></table></figure><p>messages_en_US.properties</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.name=javaboy</span><br></pre></td></tr></table></figure><p>配置完成后，我们就可以直接开始使用了。在需要使用值的地方，直接注入 MessageSource 实例即可。</p><blockquote><p>在 Spring 中需要配置的 MessageSource 现在不用配置了，Spring Boot 会通过 <code>org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration</code> 自动帮我们配置一个 MessageSource 实例。</p></blockquote><p>创建一个 HelloController ，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    MessageSource messageSource;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageSource.getMessage(<span class="hljs-string">"user.name"</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HelloController 中我们可以直接注入 MessageSource 实例，然后调用该实例中的 getMessage 方法去获取变量的值，第一个参数是要获取变量的 key，第二个参数是如果 value 中有占位符，可以从这里传递参数进去，第三个参数传递一个 Locale 实例即可，这相当于当前的语言环境。</p><p>接下来我们就可以直接去调用这个接口了。</p><p>默认情况下，在接口调用时，通过请求头的 Accept-Language 来配置当前的环境，我这里通过 POSTMAN 来进行测试，结果如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-2.png" alt></p><p>小伙伴们看到，我在请求头中设置了 Accept-Language 为 zh-CN，所以拿到的就是简体中文；如果我设置了 zh-TW，就会拿到繁体中文：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-3.png" alt></p><p>是不是很 Easy？</p><h3 id="2-2-自定义切换"><a href="#2-2-自定义切换" class="headerlink" title="2.2 自定义切换"></a>2.2 自定义切换</h3><p>有的小伙伴觉得切换参数放在请求头里边好像不太方便，那么也可以自定义解析方式。例如参数可以当成普通参数放在地址栏上，通过如下配置可以实现我们的需求。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        LocaleChangeInterceptor interceptor = <span class="hljs-keyword">new</span> LocaleChangeInterceptor();</span><br><span class="line">        interceptor.setParamName(<span class="hljs-string">"lang"</span>);</span><br><span class="line">        registry.addInterceptor(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        SessionLocaleResolver localeResolver = <span class="hljs-keyword">new</span> SessionLocaleResolver();</span><br><span class="line">        localeResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);</span><br><span class="line">        <span class="hljs-keyword">return</span> localeResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段配置中，我们首先提供了一个 SessionLocaleResolver 实例，这个实例会替换掉默认的 AcceptHeaderLocaleResolver，不同于 AcceptHeaderLocaleResolver 通过请求头来判断当前的环境信息，SessionLocaleResolver 将客户端的 Locale 保存到 HttpSession 对象中，并且可以进行修改（这意味着当前环境信息，前端给浏览器发送一次即可记住，只要 session 有效，浏览器就不必再次告诉服务端当前的环境信息）。</p><p>另外我们还配置了一个拦截器，这个拦截器会拦截请求中 key 为 lang 的参数（不配置的话是 locale），这个参数则指定了当前的环境信息。</p><p>好了，配置完成后，启动项目，访问方式如下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-4.png?aa=123" alt></p><p>我们通过在请求中添加 lang 来指定当前环境信息。这个指定只需要一次即可，也就是说，在 session 不变的情况下，下次请求可以不必带上 lang 参数，服务端已经知道当前的环境信息了。</p><p>CookieLocaleResolver 也是类似用法，不再赘述。</p><h3 id="2-3-其他自定义"><a href="#2-3-其他自定义" class="headerlink" title="2.3 其他自定义"></a>2.3 其他自定义</h3><p>默认情况下，我们的配置文件放在 resources 目录下，如果大家想自定义，也是可以的，例如定义在 resources/i18n 目录下：</p><p><img src="http://img.itboyhub.com/2020/03/i18n-5.png" alt></p><p>但是这种定义方式系统就不知道去哪里加载配置文件了，此时还需要 application.properties 中进行额外配置(注意这是一个相对路径)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.basename=i18n/messages</span><br></pre></td></tr></table></figure><p>另外还有一些编码格式的配置等，内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.messages.cache-duration=3600</span><br><span class="line">spring.messages.encoding=UTF-8</span><br><span class="line">spring.messages.fallback-to-system-locale=true</span><br></pre></td></tr></table></figure><p>spring.messages.cache-duration 表示 messages 文件的缓存失效时间，如果不配置则缓存一直有效。</p><p>spring.messages.fallback-to-system-locale 属性则略显神奇，网上竟然看不到一个明确的答案，后来翻了一会源码才看出端倪。</p><p>这个属性的作用在 <code>org.springframework.context.support.AbstractResourceBasedMessageSource#getDefaultLocale</code> 方法中生效：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Locale <span class="hljs-title">getDefaultLocale</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaultLocale != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fallbackToSystemLocale) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> Locale.getDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码可以看出，在找不到当前系统对应的资源文件时，如果该属性为 true，则会默认查找当前系统对应的资源文件，否则就返回 null，返回 null 之后，最终又会调用到系统默认的 messages.properties 文件。</p><h2 id="3-LocaleResolver"><a href="#3-LocaleResolver" class="headerlink" title="3.LocaleResolver"></a>3.LocaleResolver</h2><p>国际化这块主要涉及到的组件是 LocaleResolver，这是一个开放的接口，官方默认提供了四个实现。当前该使用什么环境，主要是通过 LocaleResolver 来进行解析的。</p><p><strong>LocaleResolver</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LocaleResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLocale</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里两个方法：</p><ol><li>resolveLocale：根据当前请求解析器出 Locale 对象。</li><li>设置 Locale 对象。</li></ol><p>我们来看看 LocaleResolver 的继承关系：</p><p><img src="http://img.itboyhub.com/2021/02/20210401223028.png" alt></p><p>虽然中间有几个抽象类，不过最终负责实现的其实就四个：</p><ul><li>AcceptHeaderLocaleResolver：根据请求头中的 Accept-Language 字段来确定当前的区域语言等。</li><li>SessionLocaleResolver：根据请求参数来确定区域语言等，确定后会保存在 Session 中，只要 Session 不变，Locale 对象就一直有效。</li><li>CookieLocaleResolver：根据请求参数来确定区域语言等，确定后会保存在 Cookie 中，只要 Session 不变，Locale 对象就一直有效。</li><li>FixedLocaleResolver：配置时直接提供一个 Locale 对象，以后不能修改。</li></ul><p>接下来我们就对这几个类逐一进行分析。</p><h3 id="3-1-AcceptHeaderLocaleResolver"><a href="#3-1-AcceptHeaderLocaleResolver" class="headerlink" title="3.1 AcceptHeaderLocaleResolver"></a>3.1 AcceptHeaderLocaleResolver</h3><p>AcceptHeaderLocaleResolver 直接实现了 LocaleResolver 接口，我们来看它的 resolveLocale 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Locale defaultLocale = getDefaultLocale();</span><br><span class="line"><span class="hljs-keyword">if</span> (defaultLocale != <span class="hljs-keyword">null</span> &amp;&amp; request.getHeader(<span class="hljs-string">"Accept-Language"</span>) == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> defaultLocale;</span><br><span class="line">&#125;</span><br><span class="line">Locale requestLocale = request.getLocale();</span><br><span class="line">List&lt;Locale&gt; supportedLocales = getSupportedLocales();</span><br><span class="line"><span class="hljs-keyword">if</span> (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> requestLocale;</span><br><span class="line">&#125;</span><br><span class="line">Locale supportedLocale = findSupportedLocale(request, supportedLocales);</span><br><span class="line"><span class="hljs-keyword">if</span> (supportedLocale != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> supportedLocale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> (defaultLocale != <span class="hljs-keyword">null</span> ? defaultLocale : requestLocale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先去获取默认的 Locale 对象。</li><li>如果存在默认的 Locale 对象，并且请求头中没有设置 <code>Accept-Language</code> 字段，则直接返回默认的 Locale。</li><li>从 request 中取出当前的 Locale 对象，然后查询出支持的 supportedLocales，如果 supportedLocales 或者 supportedLocales 中包含 requestLocale，则直接返回 requestLocale。</li><li>如果前面还是没有匹配成功的，则从 request 中取出 locales 集合，然后再去和支持的 locale 进行比对，选择匹配成功的 locale 返回。</li><li>如果前面都没能返回，则判断 defaultLocale 是否为空，如果不为空，就返回 defaultLocale，否则返回 defaultLocale。</li></ol><p>再来看看它的 setLocale 方法，直接抛出异常，意味着通过请求头处理 Locale 是不允许修改的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocale</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(</span><br><span class="line"><span class="hljs-string">"Cannot change HTTP accept header - use a different locale resolution strategy"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-SessionLocaleResolver"><a href="#3-2-SessionLocaleResolver" class="headerlink" title="3.2 SessionLocaleResolver"></a>3.2 SessionLocaleResolver</h3><p>SessionLocaleResolver 的实现多了一个抽象类 AbstractLocaleContextResolver，AbstractLocaleContextResolver 中增加了对 TimeZone 的支持，我们先来看下 AbstractLocaleContextResolver：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractLocaleContextResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLocaleResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LocaleContextResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-keyword">private</span> TimeZone defaultTimeZone;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDefaultTimeZone</span><span class="hljs-params">(@Nullable TimeZone defaultTimeZone)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.defaultTimeZone = defaultTimeZone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> TimeZone <span class="hljs-title">getDefaultTimeZone</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultTimeZone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Locale locale = resolveLocaleContext(request).getLocale();</span><br><span class="line"><span class="hljs-keyword">return</span> (locale != <span class="hljs-keyword">null</span> ? locale : request.getLocale());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocale</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response, @Nullable Locale locale)</span> </span>&#123;</span><br><span class="line">setLocaleContext(request, response, (locale != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> SimpleLocaleContext(locale) : <span class="hljs-keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，多了一个 TimeZone 属性。从请求中解析出 Locale 还是调用了 resolveLocaleContext 方法，该方法在子类中被实现，另外调用 setLocaleContext 方法设置 Locale，该方法的实现也在子类中。</p><p>我们来看下它的子类 SessionLocaleResolver：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Locale locale = (Locale) WebUtils.getSessionAttribute(request, <span class="hljs-keyword">this</span>.localeAttributeName);</span><br><span class="line"><span class="hljs-keyword">if</span> (locale == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">locale = determineDefaultLocale(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> locale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接从 Session 中获取 Locale，默认的属性名是 <code>SessionLocaleResolver.class.getName() + &quot;.LOCALE&quot;</code>，如果 session 中不存在 Locale 信息，则调用 determineDefaultLocale 方法去加载 Locale，该方法会首先找到 defaultLocale，如果 defaultLocale 不为 null 就直接返回，否则就从 request 中获取 Locale 返回。</p><p>再来看 setLocaleContext 方法，就是将解析出来的 Locale 保存起来。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocaleContext</span><span class="hljs-params">(HttpServletRequest request, @Nullable HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable LocaleContext localeContext)</span> </span>&#123;</span><br><span class="line">Locale locale = <span class="hljs-keyword">null</span>;</span><br><span class="line">TimeZone timeZone = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (localeContext != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">locale = localeContext.getLocale();</span><br><span class="line"><span class="hljs-keyword">if</span> (localeContext <span class="hljs-keyword">instanceof</span> TimeZoneAwareLocaleContext) &#123;</span><br><span class="line">timeZone = ((TimeZoneAwareLocaleContext) localeContext).getTimeZone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">WebUtils.setSessionAttribute(request, <span class="hljs-keyword">this</span>.localeAttributeName, locale);</span><br><span class="line">WebUtils.setSessionAttribute(request, <span class="hljs-keyword">this</span>.timeZoneAttributeName, timeZone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存到 Session 中即可。大家可以看到，这种保存方式其实和我们前面演示的自己保存代码基本一致，殊途同归。</p><h3 id="3-3-FixedLocaleResolver"><a href="#3-3-FixedLocaleResolver" class="headerlink" title="3.3 FixedLocaleResolver"></a>3.3 FixedLocaleResolver</h3><p>FixedLocaleResolver 有三个构造方法，无论调用哪一个，都会配置默认的 Locale：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FixedLocaleResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">setDefaultLocale(Locale.getDefault());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FixedLocaleResolver</span><span class="hljs-params">(Locale locale)</span> </span>&#123;</span><br><span class="line">setDefaultLocale(locale);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FixedLocaleResolver</span><span class="hljs-params">(Locale locale, TimeZone timeZone)</span> </span>&#123;</span><br><span class="line">setDefaultLocale(locale);</span><br><span class="line">setDefaultTimeZone(timeZone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要么自己传 Locale 进来，要么调用 Locale.getDefault() 方法获取默认的 Locale。</p><p>再来看 resolveLocale 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">Locale locale = getDefaultLocale();</span><br><span class="line"><span class="hljs-keyword">if</span> (locale == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">locale = Locale.getDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> locale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应该就不用解释了吧。</p><p>需要注意的是它的 setLocaleContext 方法，直接抛异常出来，也就意味着 Locale 在后期不能被修改。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocaleContext</span><span class="hljs-params">( HttpServletRequest request, @Nullable HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable LocaleContext localeContext)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Cannot change fixed locale - use a different locale resolution strategy"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-CookieLocaleResolver"><a href="#3-4-CookieLocaleResolver" class="headerlink" title="3.4 CookieLocaleResolver"></a>3.4 CookieLocaleResolver</h3><p>CookieLocaleResolver 和 SessionLocaleResolver 比较类似，只不过存储介质变成了 Cookie，其他都差不多，松哥就不再重复介绍了。</p><h2 id="4-附录"><a href="#4-附录" class="headerlink" title="4.附录"></a>4.附录</h2><p>搜刮了一个语言简称表，分享给各位小伙伴：</p><table><thead><tr><th style="text-align:left">语言</th><th style="text-align:left">简称</th></tr></thead><tbody><tr><td style="text-align:left">简体中文(中国)</td><td style="text-align:left">zh_CN</td></tr><tr><td style="text-align:left">繁体中文(中国台湾)</td><td style="text-align:left">zh_TW</td></tr><tr><td style="text-align:left">繁体中文(中国香港)</td><td style="text-align:left">zh_HK</td></tr><tr><td style="text-align:left">英语(中国香港)</td><td style="text-align:left">en_HK</td></tr><tr><td style="text-align:left">英语(美国)</td><td style="text-align:left">en_US</td></tr><tr><td style="text-align:left">英语(英国)</td><td style="text-align:left">en_GB</td></tr><tr><td style="text-align:left">英语(全球)</td><td style="text-align:left">en_WW</td></tr><tr><td style="text-align:left">英语(加拿大)</td><td style="text-align:left">en_CA</td></tr><tr><td style="text-align:left">英语(澳大利亚)</td><td style="text-align:left">en_AU</td></tr><tr><td style="text-align:left">英语(爱尔兰)</td><td style="text-align:left">en_IE</td></tr><tr><td style="text-align:left">英语(芬兰)</td><td style="text-align:left">en_FI</td></tr><tr><td style="text-align:left">芬兰语(芬兰)</td><td style="text-align:left">fi_FI</td></tr><tr><td style="text-align:left">英语(丹麦)</td><td style="text-align:left">en_DK</td></tr><tr><td style="text-align:left">丹麦语(丹麦)</td><td style="text-align:left">da_DK</td></tr><tr><td style="text-align:left">英语(以色列)</td><td style="text-align:left">en_IL</td></tr><tr><td style="text-align:left">希伯来语(以色列)</td><td style="text-align:left">he_IL</td></tr><tr><td style="text-align:left">英语(南非)</td><td style="text-align:left">en_ZA</td></tr><tr><td style="text-align:left">英语(印度)</td><td style="text-align:left">en_IN</td></tr><tr><td style="text-align:left">英语(挪威)</td><td style="text-align:left">en_NO</td></tr><tr><td style="text-align:left">英语(新加坡)</td><td style="text-align:left">en_SG</td></tr><tr><td style="text-align:left">英语(新西兰)</td><td style="text-align:left">en_NZ</td></tr><tr><td style="text-align:left">英语(印度尼西亚)</td><td style="text-align:left">en_ID</td></tr><tr><td style="text-align:left">英语(菲律宾)</td><td style="text-align:left">en_PH</td></tr><tr><td style="text-align:left">英语(泰国)</td><td style="text-align:left">en_TH</td></tr><tr><td style="text-align:left">英语(马来西亚)</td><td style="text-align:left">en_MY</td></tr><tr><td style="text-align:left">英语(阿拉伯)</td><td style="text-align:left">en_XA</td></tr><tr><td style="text-align:left">韩文(韩国)</td><td style="text-align:left">ko_KR</td></tr><tr><td style="text-align:left">日语(日本)</td><td style="text-align:left">ja_JP</td></tr><tr><td style="text-align:left">荷兰语(荷兰)</td><td style="text-align:left">nl_NL</td></tr><tr><td style="text-align:left">荷兰语(比利时)</td><td style="text-align:left">nl_BE</td></tr><tr><td style="text-align:left">葡萄牙语(葡萄牙)</td><td style="text-align:left">pt_PT</td></tr><tr><td style="text-align:left">葡萄牙语(巴西)</td><td style="text-align:left">pt_BR</td></tr><tr><td style="text-align:left">法语(法国)</td><td style="text-align:left">fr_FR</td></tr><tr><td style="text-align:left">法语(卢森堡)</td><td style="text-align:left">fr_LU</td></tr><tr><td style="text-align:left">法语(瑞士)</td><td style="text-align:left">fr_CH</td></tr><tr><td style="text-align:left">法语(比利时)</td><td style="text-align:left">fr_BE</td></tr><tr><td style="text-align:left">法语(加拿大)</td><td style="text-align:left">fr_CA</td></tr><tr><td style="text-align:left">西班牙语(拉丁美洲)</td><td style="text-align:left">es_LA</td></tr><tr><td style="text-align:left">西班牙语(西班牙)</td><td style="text-align:left">es_ES</td></tr><tr><td style="text-align:left">西班牙语(阿根廷)</td><td style="text-align:left">es_AR</td></tr><tr><td style="text-align:left">西班牙语(美国)</td><td style="text-align:left">es_US</td></tr><tr><td style="text-align:left">西班牙语(墨西哥)</td><td style="text-align:left">es_MX</td></tr><tr><td style="text-align:left">西班牙语(哥伦比亚)</td><td style="text-align:left">es_CO</td></tr><tr><td style="text-align:left">西班牙语(波多黎各)</td><td style="text-align:left">es_PR</td></tr><tr><td style="text-align:left">德语(德国)</td><td style="text-align:left">de_DE</td></tr><tr><td style="text-align:left">德语(奥地利)</td><td style="text-align:left">de_AT</td></tr><tr><td style="text-align:left">德语(瑞士)</td><td style="text-align:left">de_CH</td></tr><tr><td style="text-align:left">俄语(俄罗斯)</td><td style="text-align:left">ru_RU</td></tr><tr><td style="text-align:left">意大利语(意大利)</td><td style="text-align:left">it_IT</td></tr><tr><td style="text-align:left">希腊语(希腊)</td><td style="text-align:left">el_GR</td></tr><tr><td style="text-align:left">挪威语(挪威)</td><td style="text-align:left">no_NO</td></tr><tr><td style="text-align:left">匈牙利语(匈牙利)</td><td style="text-align:left">hu_HU</td></tr><tr><td style="text-align:left">土耳其语(土耳其)</td><td style="text-align:left">tr_TR</td></tr><tr><td style="text-align:left">捷克语(捷克共和国)</td><td style="text-align:left">cs_CZ</td></tr><tr><td style="text-align:left">斯洛文尼亚语</td><td style="text-align:left">sl_SL</td></tr><tr><td style="text-align:left">波兰语(波兰)</td><td style="text-align:left">pl_PL</td></tr><tr><td style="text-align:left">瑞典语(瑞典)</td><td style="text-align:left">sv_SE</td></tr><tr><td style="text-align:left">西班牙语(智利)</td><td style="text-align:left">es_CL</td></tr></tbody></table><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天主要和小伙伴们聊了下 SpringMVC 中的国际化问题，以及 LocaleResolver 相关的源码，相信大家对 SpringMVC 的理解应该又更近一步了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥之前写过 Spring Boot 国际化的问题，不过那一次没讲源码，这次咱们整点源码来深入理解下这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
      <category term="I18N" scheme="http://www.javaboy.org/tags/I18N/"/>
    
  </entry>
  
  <entry>
    <title>什么年代了，你还不知道 Servlet3.0 中的文件上传方式？</title>
    <link href="http://www.javaboy.org/2021/0415/servlet3.0-fileupload.html"/>
    <id>http://www.javaboy.org/2021/0415/servlet3.0-fileupload.html</id>
    <published>2021-04-15T09:30:35.000Z</published>
    <updated>2021-04-15T09:31:39.747Z</updated>
    
    <content type="html"><![CDATA[<p>其实文件上传这块松哥之前和大家聊过很多次了，这次因为最近正在进行 SpringMVC 的源码分析，所以又再次把这个话题拉出来“鞭尸”，不过这次松哥想从源码角度来聊聊这个话题。</p><a id="more"></a><p>理解源码的前提是先会用，所以我们还是先来看看用法，然后再来分析源码。</p><h2 id="1-两种文件解析方案"><a href="#1-两种文件解析方案" class="headerlink" title="1.两种文件解析方案"></a>1.两种文件解析方案</h2><p>对于上传文件的请求，SpringMVC 中目前共有两种不同的解析方案：</p><ul><li>StandardServletMultipartResolver</li><li>CommonsMultipartResolver</li></ul><p>StandardServletMultipartResolver 支持 Servlet3.0 中标准的文件上传方案，使用非常简单；CommonsMultipartResolver 则需要结合 Apache Commons fileupload 组件一起使用，这种方式兼容低版本的 Servlet。</p><p><strong>StandardServletMultipartResolver</strong></p><p>先来回顾下 StandardServletMultipartResolver 的用法。</p><p>使用 StandardServletMultipartResolver，可以直接通过 HttpServletRequest 自带的 getPart 方法获取上传文件并保存，这是一种标准的操作方式，这种方式也不用添加任何额外的依赖，只需要确保 Servlet 的版本在 3.0 之上即可。</p><p>首先我们需要为 Servlet 配置 <code>multipart-config</code>，哪个 Servlet 负责处理上传文件，就为哪个 Servlet 配置 <code>multipart-config</code>。在 SpringMVC 中，我们的请求都是通过 DispatcherServlet 进行分发的，所以我们就为 DispatcherServlet 配置 <code>multipart-config</code>。</p><p>配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">serv</span></span></span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">multipart-config</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">max-file-size</span>&gt;</span>1024<span class="hljs-tag">&lt;/<span class="hljs-name">max-file-size</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">max-request-size</span>&gt;</span>10240<span class="hljs-tag">&lt;/<span class="hljs-name">max-request-size</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">multipart-config</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 SpringMVC 的配置文件中提供一个 StandardServletMultipartResolver 实例，注意该实例的 id 必须为 multipartResolver（具体原因参见：<a href="https://mp.weixin.qq.com/s/IeMOfnXhOX5RCf4i5Xsdzw" target="_blank" rel="noopener">SpringMVC 初始化流程分析</a>一文）。</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.multipart.support.StandardServletMultipartResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"multipartResolver"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完成后，我们就可以开发一个文件上传接口了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUploadController</span> </span>&#123;</span><br><span class="line">    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"/yyyy/MM/dd/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">        File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">            folder.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        String oldName = file.getOriginalFilename();</span><br><span class="line">        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));</span><br><span class="line">            <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload2</span><span class="hljs-params">(HttpServletRequest req)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        StandardServletMultipartResolver resolver = <span class="hljs-keyword">new</span> StandardServletMultipartResolver();</span><br><span class="line">        MultipartFile file = resolver.resolveMultipart(req).getFile(<span class="hljs-string">"file"</span>);</span><br><span class="line">        String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">        File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">            folder.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        String oldName = file.getOriginalFilename();</span><br><span class="line">        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));</span><br><span class="line">            <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload3"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload3</span><span class="hljs-params">(HttpServletRequest req)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String other_param = req.getParameter(<span class="hljs-string">"other_param"</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"other_param = "</span> + other_param);</span><br><span class="line">        String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">        File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">        <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">            folder.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        Part filePart = req.getPart(<span class="hljs-string">"file"</span>);</span><br><span class="line">        String oldName = filePart.getSubmittedFileName();</span><br><span class="line">        String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            filePart.write(realPath + newName);</span><br><span class="line">            <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里一共提供了三个文件上传接口，其实最终都是通过 StandardServletMultipartResolver 进行处理的。</p><ol><li>第一个接口是我们在 SpringMVC 框架中常见的一种文件上传处理方式，直接在参数中写上 MultipartFile，这个 MultipartFile 其实就是从当前请求中解析出来的，具体负责参数解析工作的就是 RequestParamMethodArgumentResolver。</li><li>第二个接口其实是一种古老的文件上传实现方案，参数就是普通的 HttpServletRequest，然后在参数里边，我们再手动利用 StandardServletMultipartResolver 实例进行解析（<strong>这种情况可以不用自己 new 一个 StandardServletMultipartResolver 实例，直接将 Spring 容器中的注入进来即可</strong>）。</li><li>第三个接口我们就利用了 Servlet3.0 的 API，调用 getPart 获取文件，然后再调用对象的 write 方法将文件写出去即可。</li></ol><p>大致上一看，感觉办法还挺多，其实仔细看，万变不离其宗，一会我们看完源码，相信小伙伴们还能变化出更多写法。</p><p><strong>CommonsMultipartResolver</strong></p><p>CommonsMultipartResolver 估计很多人都比较熟悉，这个兼容性很好，就是有点过时了。使用 CommonsMultipartResolver 需要我们首先引入 commons-fileupload 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 SpringMVC 的配置文件中提供 CommonsMultipartResolver 实例，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"multipartResolver"</span>&gt;</span>--&gt;</span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来开发文件上传接口就行了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">    File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String oldName = file.getOriginalFilename();</span><br><span class="line">    String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));</span><br><span class="line">        <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就没啥好说，比较容易。</p><p>文件上传这块松哥之前在视频中也和大家分享过，公号后台回复 ssm 可以查看视频详情。</p><p>用法掌握了，接下来我们来看原理。</p><h2 id="2-StandardServletMultipartResolver"><a href="#2-StandardServletMultipartResolver" class="headerlink" title="2.StandardServletMultipartResolver"></a>2.StandardServletMultipartResolver</h2><p>不废话，直接来看看源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardServletMultipartResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MultipartResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> resolveLazily = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResolveLazily</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> resolveLazily)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.resolveLazily = resolveLazily;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMultipart</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> StringUtils.startsWithIgnoreCase(request.getContentType(), <span class="hljs-string">"multipart/"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> MultipartHttpServletRequest <span class="hljs-title">resolveMultipart</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StandardMultipartHttpServletRequest(request, <span class="hljs-keyword">this</span>.resolveLazily);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanupMultipart</span><span class="hljs-params">(MultipartHttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!(request <span class="hljs-keyword">instanceof</span> AbstractMultipartHttpServletRequest) ||</span><br><span class="line">((AbstractMultipartHttpServletRequest) request).isResolved()) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : request.getParts()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (request.getFile(part.getName()) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">part.delete();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里满打满算就四个方法，其中一个还是 set 方法，我们来看另外三个功能性方法：</p><ol><li>isMultipart：这个方法主要是用来判断当前请求是不是文件上传请求，这里的判断思路很简单，就看请求的 content-type 是不是以 <code>multipart/</code> 开头，如果是，则这就是一个文件上传请求，否则就不是文件上传请求。</li><li>resolveMultipart：这个方法负责将当前请求封装一个 StandardMultipartHttpServletRequest 对象然后返回。</li><li>cleanupMultipart：这个方法负责善后，主要完成了缓存的清理工作。</li></ol><p>在这个过程中涉及到 StandardMultipartHttpServletRequest 对象，我们也来稍微说一下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StandardMultipartHttpServletRequest</span><span class="hljs-params">(HttpServletRequest request, <span class="hljs-keyword">boolean</span> lazyParsing)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (!lazyParsing) &#123;</span><br><span class="line">parseRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseRequest</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Collection&lt;Part&gt; parts = request.getParts();</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartParameterNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(parts.size());</span><br><span class="line">MultiValueMap&lt;String, MultipartFile&gt; files = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;(parts.size());</span><br><span class="line"><span class="hljs-keyword">for</span> (Part part : parts) &#123;</span><br><span class="line">String headerValue = part.getHeader(HttpHeaders.CONTENT_DISPOSITION);</span><br><span class="line">ContentDisposition disposition = ContentDisposition.parse(headerValue);</span><br><span class="line">String filename = disposition.getFilename();</span><br><span class="line"><span class="hljs-keyword">if</span> (filename != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (filename.startsWith(<span class="hljs-string">"=?"</span>) &amp;&amp; filename.endsWith(<span class="hljs-string">"?="</span>)) &#123;</span><br><span class="line">filename = MimeDelegate.decode(filename);</span><br><span class="line">&#125;</span><br><span class="line">files.add(part.getName(), <span class="hljs-keyword">new</span> StandardMultipartFile(part, filename));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.multipartParameterNames.add(part.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">setMultipartFiles(files);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleParseFailure(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StandardMultipartHttpServletRequest 对象在构建的过程中，会自动进行请求解析，调用 getParts 方法获取所有的项，然后进行判断，将文件和普通参数分别保存下来备用。</p><p>这块的逻辑比较简单。</p><h2 id="3-CommonsMultipartResolver"><a href="#3-CommonsMultipartResolver" class="headerlink" title="3.CommonsMultipartResolver"></a>3.CommonsMultipartResolver</h2><p>再来看 CommonsMultipartResolver。</p><p>先来看它的 isMultipart 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMultipart</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ServletFileUpload.isMultipartContent(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMultipartContent</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!POST_METHOD.equalsIgnoreCase(request.getMethod())) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> FileUploadBase.isMultipartContent(<span class="hljs-keyword">new</span> ServletRequestContext(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletFileUpload.isMultipartContent 方法其实就在我们引入的 <code>commons-fileupload</code> 包中。它的判断逻辑分两步：首先检查是不是 POST 请求，然后检查 content-type 是不是以 <code>multipart/</code> 开始。</p><p>再来看它的 resolveMultipart 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> MultipartHttpServletRequest <span class="hljs-title">resolveMultipart</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resolveLazily) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultMultipartHttpServletRequest(request) &#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeMultipart</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">MultipartParsingResult parsingResult = parseRequest(request);</span><br><span class="line">setMultipartFiles(parsingResult.getMultipartFiles());</span><br><span class="line">setMultipartParameters(parsingResult.getMultipartParameters());</span><br><span class="line">setMultipartParameterContentTypes(parsingResult.getMultipartParameterContentTypes());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">MultipartParsingResult parsingResult = parseRequest(request);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultMultipartHttpServletRequest(request, parsingResult.getMultipartFiles(),</span><br><span class="line">parsingResult.getMultipartParameters(), parsingResult.getMultipartParameterContentTypes());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 resolveLazily 属性值，选择两种不同的策略将当前对象重新构建成一个 DefaultMultipartHttpServletRequest 对象。如果 resolveLazily 为 true，则在 initializeMultipart 方法中进行请求解析，否则先解析，再构建 DefaultMultipartHttpServletRequest 对象。</p><p>具体的解析方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> MultipartParsingResult <span class="hljs-title">parseRequest</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line">String encoding = determineEncoding(request);</span><br><span class="line">FileUpload fileUpload = prepareFileUpload(encoding);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">List&lt;FileItem&gt; fileItems = ((ServletFileUpload) fileUpload).parseRequest(request);</span><br><span class="line"><span class="hljs-keyword">return</span> parseFileItems(fileItems, encoding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (FileUploadBase.SizeLimitExceededException ex) &#123;</span><br><span class="line"><span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> MultipartParsingResult <span class="hljs-title">parseFileItems</span><span class="hljs-params">(List&lt;FileItem&gt; fileItems, String encoding)</span> </span>&#123;</span><br><span class="line">MultiValueMap&lt;String, MultipartFile&gt; multipartFiles = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">Map&lt;String, String[]&gt; multipartParameters = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, String&gt; multipartParameterContentTypes = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (FileItem fileItem : fileItems) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (fileItem.isFormField()) &#123;</span><br><span class="line">String value;</span><br><span class="line">String partEncoding = determineEncoding(fileItem.getContentType(), encoding);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">value = fileItem.getString(partEncoding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (UnsupportedEncodingException ex) &#123;</span><br><span class="line">value = fileItem.getString();</span><br><span class="line">&#125;</span><br><span class="line">String[] curParam = multipartParameters.get(fileItem.getFieldName());</span><br><span class="line"><span class="hljs-keyword">if</span> (curParam == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">multipartParameters.put(fileItem.getFieldName(), <span class="hljs-keyword">new</span> String[] &#123;value&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">String[] newParam = StringUtils.addStringToArray(curParam, value);</span><br><span class="line">multipartParameters.put(fileItem.getFieldName(), newParam);</span><br><span class="line">&#125;</span><br><span class="line">multipartParameterContentTypes.put(fileItem.getFieldName(), fileItem.getContentType());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">CommonsMultipartFile file = createMultipartFile(fileItem);</span><br><span class="line">multipartFiles.add(file.getName(), file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MultipartParsingResult(multipartFiles, multipartParameters, multipartParameterContentTypes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的解析就是首先获取到 FileItem 集合，然后调用 parseFileItems 方法进行进一步的解析。在进一步的解析中，会首先判断这是文件还是普通参数，如果是普通参数，则保存到 multipartParameters 中，具体保存过程中还会判断是否为数组，然后再将参数的 ContentType 保存到 multipartParameterContentTypes 中，文件则保存到 multipartFiles 中，最后由三个 Map 构成一个 MultipartParsingResult 对象并返回。</p><p>至此，StandardServletMultipartResolver 和 CommonsMultipartResolver 源码就和大家说完了，可以看到，还是比较容易的。</p><h2 id="4-解析流程"><a href="#4-解析流程" class="headerlink" title="4.解析流程"></a>4.解析流程</h2><p>最后，我们再来梳理一下解析流程。</p><p>以如下接口为例（因为在实际开发中一般都是通过如下方式上传文件）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/upload"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">fileUpload</span><span class="hljs-params">(MultipartFile file, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">    String format = sdf.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">    String realPath = req.getServletContext().getRealPath(<span class="hljs-string">"/img"</span>) + format;</span><br><span class="line">    File folder = <span class="hljs-keyword">new</span> File(realPath);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    String oldName = file.getOriginalFilename();</span><br><span class="line">    String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(<span class="hljs-string">"."</span>));</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        file.transferTo(<span class="hljs-keyword">new</span> File(folder, newName));</span><br><span class="line">        <span class="hljs-keyword">return</span> req.getScheme() + <span class="hljs-string">"://"</span> + req.getRemoteHost() + <span class="hljs-string">":"</span> + req.getServerPort() + <span class="hljs-string">"/img"</span> + format + newName;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 MultipartFile 对象主要就是在参数解析器中获取的，关于参数解析器，大家可以参考：<a href="https://mp.weixin.qq.com/s/qsS6Dwr6eXx07i5dhn8FEA" target="_blank" rel="noopener">深入分析 SpringMVC 参数解析器</a> 一文，这里涉及到的参数解析器是 RequestParamMethodArgumentResolver。</p><p>在 RequestParamMethodArgumentResolver#resolveName 方法中有如下一行代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (servletRequest != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mpArg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会进行请求解析，返回 MultipartFile 对象或者 MultipartFile 数组。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">resolveMultipartArgument</span><span class="hljs-params">(String name, MethodParameter parameter, HttpServletRequest request)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">MultipartHttpServletRequest multipartRequest =</span><br><span class="line">WebUtils.getNativeRequest(request, MultipartHttpServletRequest.class);</span><br><span class="line"><span class="hljs-keyword">boolean</span> isMultipart = (multipartRequest != <span class="hljs-keyword">null</span> || isMultipartContent(request));</span><br><span class="line"><span class="hljs-keyword">if</span> (MultipartFile.class == parameter.getNestedParameterType()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequest == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">multipartRequest = <span class="hljs-keyword">new</span> StandardMultipartHttpServletRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> multipartRequest.getFile(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMultipartFileCollection(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequest == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">multipartRequest = <span class="hljs-keyword">new</span> StandardMultipartHttpServletRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line"><span class="hljs-keyword">return</span> (!files.isEmpty() ? files : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isMultipartFileArray(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (multipartRequest == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">multipartRequest = <span class="hljs-keyword">new</span> StandardMultipartHttpServletRequest(request);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);</span><br><span class="line"><span class="hljs-keyword">return</span> (!files.isEmpty() ? files.toArray(<span class="hljs-keyword">new</span> MultipartFile[<span class="hljs-number">0</span>]) : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Part.class == parameter.getNestedParameterType()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> request.getPart(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPartCollection(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Part&gt; parts = resolvePartList(request, name);</span><br><span class="line"><span class="hljs-keyword">return</span> (!parts.isEmpty() ? parts : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPartArray(parameter)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isMultipart) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Part&gt; parts = resolvePartList(request, name);</span><br><span class="line"><span class="hljs-keyword">return</span> (!parts.isEmpty() ? parts.toArray(<span class="hljs-keyword">new</span> Part[<span class="hljs-number">0</span>]) : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> UNRESOLVABLE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取 multipartRequest 对象，然后再从中获取文件或者文件数组。如果我们使用 StandardServletMultipartResolver 做文件上传，这里获取到的 multipartRequest 就是 StandardMultipartHttpServletRequest；如果我们使用 CommonsMultipartResolver 做文件上传，这里获取到的 multipartRequest 就是 DefaultMultipartHttpServletRequest。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天就和大家简单分析了下两个文件上传组件的源码，至此，SpringMVC 九大组件我们已经分析了 7 个啦，还剩两个，即将完结，完结后松哥会整理成 pdf 分享给大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实文件上传这块松哥之前和大家聊过很多次了，这次因为最近正在进行 SpringMVC 的源码分析，所以又再次把这个话题拉出来“鞭尸”，不过这次松哥想从源码角度来聊聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 项目总是创建失败，这几个备选方案一定要收藏</title>
    <link href="http://www.javaboy.org/2021/0414/spring-boot-starter.html"/>
    <id>http://www.javaboy.org/2021/0414/spring-boot-starter.html</id>
    <published>2021-04-14T09:08:56.000Z</published>
    <updated>2021-04-14T09:11:28.013Z</updated>
    
    <content type="html"><![CDATA[<p>松哥这两天老遇到一个问题，用 IDEA 创建 Spring Boot 项目总是失败，搞得我很郁闷，一气之下收集了几个可用的 Spring Boot 构建接口，妈妈再也不用担心我 Spring Boot 项目创建失败了！</p><a id="more"></a><h2 id="1-青铜"><a href="#1-青铜" class="headerlink" title="1.青铜"></a>1.青铜</h2><p>创建地址直接用默认的 <a href="https://start.spring.io，这个是最容易失败的了，失败最最主要的原因还是因为这是一个国外的网站，由于众所周知的原因，这些网站访问起来并不太稳定。" target="_blank" rel="noopener">https://start.spring.io，这个是最容易失败的了，失败最最主要的原因还是因为这是一个国外的网站，由于众所周知的原因，这些网站访问起来并不太稳定。</a></p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210413220924.png" alt></p><h2 id="2-白银"><a href="#2-白银" class="headerlink" title="2.白银"></a>2.白银</h2><p>那么国内有没有类似的网站呢？当然有！阿里巴巴就搞了一个：<a href="https://start.aliyun.com，我们在构建项目时可以直接填入" target="_blank" rel="noopener">https://start.aliyun.com，我们在构建项目时可以直接填入</a> <a href="https://start.aliyun.com" target="_blank" rel="noopener">https://start.aliyun.com</a> 即可，像下面这样：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210414083251.png" alt></p><p>但是在选择依赖的时候会有一点问题，如下图：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210414083333.png" alt></p><p>问题主要是两方面的：</p><ol><li>项目版本更新慢，目前 Spring Boot 最新稳定版是 2.4.4，但是这里只能选择到 2.4.1。</li><li>项目构建成功后，没有 parent，而是通过自定义 dependenceManagement 节点来统一处理版本问题，用惯了 parent 的小伙伴可能对此不太习惯，而且这种写法也需要开发者做一些修改。</li></ol><p>所以如果使用 <a href="https://start.aliyun.com" target="_blank" rel="noopener">https://start.aliyun.com</a> 创建项目的话，很多时候并不能一步到位，创建完了还要自己再手动调整下。</p><h2 id="3-黄金"><a href="#3-黄金" class="headerlink" title="3.黄金"></a>3.黄金</h2><p>那就没有跟 <a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a> 一模一样的国内站点吗？有！那就是 Spring Boot 中文社区搭建的 <a href="https://start.springboot.io，这个服务器架设在香港，大陆访问非常稳定，项目创建成功率很高。" target="_blank" rel="noopener">https://start.springboot.io，这个服务器架设在香港，大陆访问非常稳定，项目创建成功率很高。</a></p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210414083726.png" alt></p><p><a href="https://start.springboot.io" target="_blank" rel="noopener">https://start.springboot.io</a> 站点的使用体验就和 <a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a> 一模一样，我目前就主要使用这种方案。</p><h2 id="4-铂金"><a href="#4-铂金" class="headerlink" title="4.铂金"></a>4.铂金</h2><p>有的时候用 IDEA 会创建失败，但是直接打开网页可以创建，创建完成后，将创建好的项目下载下来，然后解压，再用 IDEA 打开。</p><p>这种方式比较麻烦，但是好处是比较可靠，有两个创建的网页可选：</p><ul><li><a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a></li><li><a href="https://start.springboot.io" target="_blank" rel="noopener">https://start.springboot.io</a></li></ul><h2 id="5-钻石"><a href="#5-钻石" class="headerlink" title="5.钻石"></a>5.钻石</h2><p>如果由于种种情况，上面的方案都用不了，那就只能使出撒手锏了。</p><p>Spring Boot 就是一个 Maven 功能而已，所以我们就手动创建 Maven 工程，手动添加依赖，添加项目启动类等等，这个操作也不难。</p><p>这是一个兜底的方案。</p><h2 id="6-王者"><a href="#6-王者" class="headerlink" title="6.王者"></a>6.王者</h2><p>这个留给小伙伴们，看看小伙伴们有没有“王者”方案！评论区见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥这两天老遇到一个问题，用 IDEA 创建 Spring Boot 项目总是失败，搞得我很郁闷，一气之下收集了几个可用的 Spring Boot 构建接口，妈妈再也不用担心我 Spring Boot 项目创建失败了！&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC 异常处理体系深入分析</title>
    <link href="http://www.javaboy.org/2021/0414/73d3fb01.html"/>
    <id>http://www.javaboy.org/2021/0414/73d3fb01.html</id>
    <published>2021-04-14T09:08:36.000Z</published>
    <updated>2021-04-14T09:12:27.534Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>SpringMVC 中针对异常问题有一套完整的处理体系，这套体系非常好用，今天松哥就花点时间来和大家聊一聊 SpringMVC 中的异常处理体系，我们把 SpringMVC 中的异常体系从头到尾梳理一下。</p><a id="more"></a><h2 id="1-异常解析器概览"><a href="#1-异常解析器概览" class="headerlink" title="1.异常解析器概览"></a>1.异常解析器概览</h2><p>在 SpringMVC 的异常体系中，处于最顶层的大 Boss 是 HandlerExceptionResolver，这是一个接口，里边只有一个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolveException 方法就用来解析请求处理过程中所产生的异常，并最终返回一个 ModelAndView。</p><p>我们来看下 HandlerExceptionResolver 的实现类：</p><p><img src="http://img.itboyhub.com/2021/02/20210325195747.png" alt></p><p>直接实现 HandlerExceptionResolver 接口的类有三个：</p><ul><li>HandlerExceptionResolverComposite：这个一看又是一个组合，在最近的源码分析中我们已经多次见到 xxxComposite 了，这里就不再赘述。</li><li>DefaultErrorAttributes：这个用来保存异常属性。</li><li><p>AbstractHandlerExceptionResolver：这个的子类比较多：</p><ul><li>SimpleMappingExceptionResolver：通过提前配置好的异常类和 View 之间的对应关系来解析异常。</li><li>AbstractHandlerMethodExceptionResolver：处理使用 <code>@ExceptionHandler</code> 注解自定义的异常类型。</li><li>DefaultHandlerExceptionResolver：按照不同类型来处理异常。</li><li>ResponseStatusExceptionResolver：处理含有 <code>@ResponseStatus</code> 注解的异常。</li></ul></li></ul><p>在 SpringMVC 中，大致的异常解析器就是这些，接下来我们来逐个学习这些异常解析器。</p><h2 id="2-AbstractHandlerExceptionResolver"><a href="#2-AbstractHandlerExceptionResolver" class="headerlink" title="2.AbstractHandlerExceptionResolver"></a>2.AbstractHandlerExceptionResolver</h2><p>AbstractHandlerExceptionResolver 是真正干活的异常解析器的父类，我们就先从他的 resolveException 方法开始看起。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (shouldApplyTo(request, handler)) &#123;</span><br><span class="line">prepareResponse(ex, response);</span><br><span class="line">ModelAndView result = doResolveException(request, response, handler, ex);</span><br><span class="line"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">logException(ex, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 shouldApplyTo 方法判断当前解析器是否可以处理传入的处理器所抛出的异常，如果不支持，则直接返回 null，这个异常将交给下一个 HandlerExceptionResolver 去处理。</li><li>调用 prepareResponse 方法处理 response。</li><li>调用 doResolveException 方法实际处理异常，这是一个模版方法，具体的实现在子类中。</li><li>调用 logException 方法记录异常日志信息。</li></ol><p>记录异常日志没啥好说的，doResolveException 则是一个空的模版方法，所以这里对我们来说主要就是两个方法：shouldApplyTo 和 prepareResponse，我们分别来看。</p><p><strong>shouldApplyTo</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldApplyTo</span><span class="hljs-params">(HttpServletRequest request, @Nullable Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mappedHandlers != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.mappedHandlers.contains(handler)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mappedHandlerClasses != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Class&lt;?&gt; handlerClass : <span class="hljs-keyword">this</span>.mappedHandlerClasses) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (handlerClass.isInstance(handler)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> !hasHandlerMappings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到了两个对象：mappedHandlers 和 mappedHandlerClasses：</p><ul><li>mappedHandlers：存储的是处理器对象（Controller 或者 Controller 中的方法）</li><li>mappedHandlerClasses：存储的是处理器的 Class。</li></ul><p>我们在配置异常解析器的时候可以配置这两个对象，进而实现该异常处理器只为某一个处理器服务，但是一般来说没这种需求，所以大家仅做了解即可。</p><p>如果开发者一开始配置了 mappedHandlers 或者 mappedHandlerClasses，则用这两个和处理器去比较，否则就直接返回 true，表示支持该异常处理。</p><p><strong>prepareResponse</strong></p><p>prepareResponse 方法比较简单，主要是处理一下响应头的缓存字段。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareResponse</span><span class="hljs-params">(Exception ex, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.preventResponseCaching) &#123;</span><br><span class="line">preventCaching(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preventCaching</span><span class="hljs-params">(HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">response.addHeader(HEADER_CACHE_CONTROL, <span class="hljs-string">"no-store"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 AbstractHandlerExceptionResolver 的大致内容，可以看到还是非常 easy 的，接下来我们来看它的实现类。</p><h3 id="2-1-AbstractHandlerMethodExceptionResolver"><a href="#2-1-AbstractHandlerMethodExceptionResolver" class="headerlink" title="2.1 AbstractHandlerMethodExceptionResolver"></a>2.1 AbstractHandlerMethodExceptionResolver</h3><p>AbstractHandlerMethodExceptionResolver 主要是重写了 shouldApplyTo 方法和 doResolveException 方法，一个一个来看。</p><p><strong>shouldApplyTo</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldApplyTo</span><span class="hljs-params">(HttpServletRequest request, @Nullable Object handler)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldApplyTo(request, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">handler = handlerMethod.getBean();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldApplyTo(request, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hasGlobalExceptionHandlers() &amp;&amp; hasHandlerMappings()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldApplyTo(request, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块感觉没啥好说的，判断逻辑基本上都还是调用父类的 shouldApplyTo 方法去处理。</p><p><strong>doResolveException</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ModelAndView <span class="hljs-title">doResolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">HandlerMethod handlerMethod = (handler <span class="hljs-keyword">instanceof</span> HandlerMethod ? (HandlerMethod) handler : <span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> doResolveHandlerMethodException(request, response, handlerMethod, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> ModelAndView <span class="hljs-title">doResolveHandlerMethodException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception ex)</span></span>;</span><br></pre></td></tr></table></figure><p>doResolveException 是具体的异常处理方法，但是它里边却没有实质性操作，具体的事情交给 doResolveHandlerMethodException 方法去做了，而该方法是一个抽象方法，具体的实现在子类中。</p><h4 id="2-1-1-ExceptionHandlerExceptionResolver"><a href="#2-1-1-ExceptionHandlerExceptionResolver" class="headerlink" title="2.1.1 ExceptionHandlerExceptionResolver"></a>2.1.1 ExceptionHandlerExceptionResolver</h4><p>AbstractHandlerMethodExceptionResolver 只有一个子类就是 ExceptionHandlerExceptionResolver，来看下它的 doResolveHandlerMethodException 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">doResolveHandlerMethodException</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception)</span> </span>&#123;</span><br><span class="line">ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception);</span><br><span class="line"><span class="hljs-keyword">if</span> (exceptionHandlerMethod == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.argumentResolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">exceptionHandlerMethod.setHandlerMethodArgumentResolvers(<span class="hljs-keyword">this</span>.argumentResolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.returnValueHandlers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(<span class="hljs-keyword">this</span>.returnValueHandlers);</span><br><span class="line">&#125;</span><br><span class="line">ServletWebRequest webRequest = <span class="hljs-keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">ModelAndViewContainer mavContainer = <span class="hljs-keyword">new</span> ModelAndViewContainer();</span><br><span class="line">ArrayList&lt;Throwable&gt; exceptions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Using @ExceptionHandler "</span> + exceptionHandlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Expose causes as provided arguments as well</span></span><br><span class="line">Throwable exToExpose = exception;</span><br><span class="line"><span class="hljs-keyword">while</span> (exToExpose != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">exceptions.add(exToExpose);</span><br><span class="line">Throwable cause = exToExpose.getCause();</span><br><span class="line">exToExpose = (cause != exToExpose ? cause : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">Object[] arguments = <span class="hljs-keyword">new</span> Object[exceptions.size() + <span class="hljs-number">1</span>];</span><br><span class="line">exceptions.toArray(arguments);  <span class="hljs-comment">// efficient arraycopy call in ArrayList</span></span><br><span class="line">arguments[arguments.length - <span class="hljs-number">1</span>] = handlerMethod;</span><br><span class="line">exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Throwable invocationEx) &#123;</span><br><span class="line"><span class="hljs-comment">// Any other than the original exception (or a cause) is unintended here,</span></span><br><span class="line"><span class="hljs-comment">// probably an accident (e.g. failed assertion or the like).</span></span><br><span class="line"><span class="hljs-keyword">if</span> (!exceptions.contains(invocationEx) &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="hljs-string">"Failure in @ExceptionHandler "</span> + exceptionHandlerMethod, invocationEx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Continue with default processing of the original exception...</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">ModelMap model = mavContainer.getModel();</span><br><span class="line">HttpStatus status = mavContainer.getStatus();</span><br><span class="line">ModelAndView mav = <span class="hljs-keyword">new</span> ModelAndView(mavContainer.getViewName(), model, status);</span><br><span class="line">mav.setViewName(mavContainer.getViewName());</span><br><span class="line"><span class="hljs-keyword">if</span> (!mavContainer.isViewReference()) &#123;</span><br><span class="line">mav.setView((View) mavContainer.getView());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (model <span class="hljs-keyword">instanceof</span> RedirectAttributes) &#123;</span><br><span class="line">Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法虽然比较长，但是很好理解：</p><ol><li>首先查找到带有 <code>@ExceptionHandler</code> 注解的方法，封装成一个 ServletInvocableHandlerMethod 对象（关于 ServletInvocableHandlerMethod 对象，松哥在之前的文章中已经介绍过了，具体参见：<a href="https://mp.weixin.qq.com/s/559UL_bcEKo9jNq85qmVMg" target="_blank" rel="noopener">Spring Boot 定义接口的方法是否可以声明为 private？</a>）。</li><li>如果找到了对应的方法，则为 exceptionHandlerMethod 配置参数解析器、视图解析器等，关于这些解析器，参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/4c-uV8f6x5UPvxec6Em79A" target="_blank" rel="noopener">SpringBoot 中如何自定义参数解析器？</a>、<a href="https://mp.weixin.qq.com/s/qsS6Dwr6eXx07i5dhn8FEA" target="_blank" rel="noopener">深入分析 SpringMVC 参数解析器</a>、<a href="https://mp.weixin.qq.com/s/8aMz07rOF5LuclnBaI_p5g" target="_blank" rel="noopener">Spring Boot 中如何统一 API 接口响应格式？</a>。</li><li>接下来定义一个 exceptions 数组，如果发生的异常存在异常链，则将整个异常链存入 exceptions 数组中。</li><li>exceptions 数组再加上 handlerMethod，共同组成方法参数，调用 <code>exceptionHandlerMethod.invokeAndHandle</code> 完成自定义异常方法的执行，执行结果被保存再 mavContainer 中。</li><li>如果请求到此结束，则直接构造一个 ModelAndView 返回。</li><li>否则从 mavContainer 中取出各项信息，构建新的 ModelAndView 返回。同时，如果存在重定向参数，也将之保存下来（关于重定向参数，参见：<a href="https://mp.weixin.qq.com/s/vwR0YRKVQQFN5B99NJKXYA" target="_blank" rel="noopener">SpringMVC 中的参数还能这么传递？涨姿势了！</a>）。</li></ol><p>这就是 ExceptionHandlerExceptionResolver 的大致工作流程，可以看到，还是非常 easy 的。</p><h3 id="2-2-DefaultHandlerExceptionResolver"><a href="#2-2-DefaultHandlerExceptionResolver" class="headerlink" title="2.2 DefaultHandlerExceptionResolver"></a>2.2 DefaultHandlerExceptionResolver</h3><p>这个看名字就知道是一个默认的异常处理器，用来处理一些常见的异常类型，我们来看一下它的 doResolveException 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">doResolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpRequestMethodNotSupportedException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpRequestMethodNotSupported(</span><br><span class="line">(HttpRequestMethodNotSupportedException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpMediaTypeNotSupportedException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpMediaTypeNotSupported(</span><br><span class="line">(HttpMediaTypeNotSupportedException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpMediaTypeNotAcceptableException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpMediaTypeNotAcceptable(</span><br><span class="line">(HttpMediaTypeNotAcceptableException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> MissingPathVariableException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleMissingPathVariable(</span><br><span class="line">(MissingPathVariableException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> MissingServletRequestParameterException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleMissingServletRequestParameter(</span><br><span class="line">(MissingServletRequestParameterException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> ServletRequestBindingException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleServletRequestBindingException(</span><br><span class="line">(ServletRequestBindingException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> ConversionNotSupportedException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleConversionNotSupported(</span><br><span class="line">(ConversionNotSupportedException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> TypeMismatchException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleTypeMismatch(</span><br><span class="line">(TypeMismatchException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpMessageNotReadableException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpMessageNotReadable(</span><br><span class="line">(HttpMessageNotReadableException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> HttpMessageNotWritableException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleHttpMessageNotWritable(</span><br><span class="line">(HttpMessageNotWritableException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleMethodArgumentNotValidException(</span><br><span class="line">(MethodArgumentNotValidException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> MissingServletRequestPartException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleMissingServletRequestPartException(</span><br><span class="line">(MissingServletRequestPartException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BindException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleBindException((BindException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> NoHandlerFoundException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleNoHandlerFoundException(</span><br><span class="line">(NoHandlerFoundException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> AsyncRequestTimeoutException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> handleAsyncRequestTimeoutException(</span><br><span class="line">(AsyncRequestTimeoutException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception handlerEx) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里实际上就是根据不同的异常类型，然后调用不同的类去处理该异常。这里相关的处理都比较容易，以 HttpRequestMethodNotSupportedException 为例，异常处理就是对 response 对象做一些配置，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">handleHttpRequestMethodNotSupported</span><span class="hljs-params">(HttpRequestMethodNotSupportedException ex,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String[] supportedMethods = ex.getSupportedMethods();</span><br><span class="line"><span class="hljs-keyword">if</span> (supportedMethods != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">response.setHeader(<span class="hljs-string">"Allow"</span>, StringUtils.arrayToDelimitedString(supportedMethods, <span class="hljs-string">", "</span>));</span><br><span class="line">&#125;</span><br><span class="line">response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, ex.getMessage());</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置响应头，然后 sendError，最后返回一个空的 ModelAndView 对象。</p><p>其实这里哥哥异常处理方法都大同小异，松哥就不再赘述啦。</p><h3 id="2-3-ResponseStatusExceptionResolver"><a href="#2-3-ResponseStatusExceptionResolver" class="headerlink" title="2.3 ResponseStatusExceptionResolver"></a>2.3 ResponseStatusExceptionResolver</h3><p>这个用来处理 ResponseStatusException 类型的异常，或者使用了 <code>@ResponseStatus</code> 注解标记的普通异常类。我们来看下它的 doResolveException 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">doResolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> ResponseStatusException) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> resolveResponseStatusException((ResponseStatusException) ex, request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line">ResponseStatus status = AnnotatedElementUtils.findMergedAnnotation(ex.getClass(), ResponseStatus.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (status != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> resolveResponseStatus(status, request, response, handler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (ex.getCause() <span class="hljs-keyword">instanceof</span> Exception) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> doResolveException(request, response, handler, (Exception) ex.getCause());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception resolveEx) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先判断异常类型是不是 ResponseStatusException，如果是，则直接调用 resolveResponseStatusException 方法进行异常信息处理，如果不是，则去查找到异常类上的 <code>@ResponseStatus</code> 注解，并从中查找出相关的异常信息，然后调用 resolveResponseStatus 方法进行处理。</p><p>可以看到，ResponseStatusExceptionResolver 处理的异常类型有两种：</p><ul><li>直接继承自 ResponseStatusException 的异常类，这种异常类可以直接从里边提取出来想要的信息。</li><li>通过 <code>@ResponseStatus</code> 注解的普通异常类，这种情况下异常信息从 <code>@ResponseStatus</code> 注解中提取出来。</li></ul><p>这个比较简单，没啥好说的。</p><h3 id="2-4-SimpleMappingExceptionResolver"><a href="#2-4-SimpleMappingExceptionResolver" class="headerlink" title="2.4 SimpleMappingExceptionResolver"></a>2.4 SimpleMappingExceptionResolver</h3><p>SimpleMappingExceptionResolver 则是根据不同的异常显示不同的 error 页面。可能有的小伙伴还没用过 SimpleMappingExceptionResolver，所以松哥这里先简单说一下用法。</p><p>SimpleMappingExceptionResolver 的配置非常简单，直接提供一个 SimpleMappingExceptionResolver 的实例即可，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">SimpleMappingExceptionResolver <span class="hljs-title">simpleMappingExceptionResolver</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    SimpleMappingExceptionResolver resolver = <span class="hljs-keyword">new</span> SimpleMappingExceptionResolver();</span><br><span class="line">    Properties mappings = <span class="hljs-keyword">new</span> Properties();</span><br><span class="line">    mappings.put(<span class="hljs-string">"java.lang.ArithmeticException"</span>, <span class="hljs-string">"11"</span>);</span><br><span class="line">    mappings.put(<span class="hljs-string">"java.lang.NullPointerException"</span>, <span class="hljs-string">"22"</span>);</span><br><span class="line">    resolver.setExceptionMappings(mappings);</span><br><span class="line">    Properties statusCodes = <span class="hljs-keyword">new</span> Properties();</span><br><span class="line">    statusCodes.put(<span class="hljs-string">"11"</span>, <span class="hljs-string">"500"</span>);</span><br><span class="line">    statusCodes.put(<span class="hljs-string">"22"</span>, <span class="hljs-string">"500"</span>);</span><br><span class="line">    resolver.setStatusCodes(statusCodes);</span><br><span class="line">    <span class="hljs-keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 mappings 中配置异常和 view 之间的对应关系，要写异常类的全路径，后面的 11、22 则表示视图名称；statusCodes 中配置了视图和响应状态码之间的映射关系。配置完成后，如果我们的项目在运行时抛出了 ArithmeticException 异常，则会展示出 11 视图，如果我们的项目在运行时抛出了 NullPointerException 异常，则会展示出 22 视图。</p><p>这是用法，了解了用法之后我们再来看源码，就容易理解了，我们直接来看 doResolveException 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">doResolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">String viewName = determineViewName(ex, request);</span><br><span class="line"><span class="hljs-keyword">if</span> (viewName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Integer statusCode = determineStatusCode(request, viewName);</span><br><span class="line"><span class="hljs-keyword">if</span> (statusCode != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">applyStatusCodeIfPossible(request, response, statusCode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> getModelAndView(viewName, ex, request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用 determineViewName 方法确定视图的名称。</li><li>接下来调用 determineStatusCode 查看视图是否有对应的 statusCode。</li><li>调用 applyStatusCodeIfPossible 方法将 statusCode 设置到 response 上，这个方法很简单，不多说。</li><li>调用 getModelAndView 方法构造一个 ModelAndView 对象返回，在构造时，同时设置异常参数，异常的信息的 key 默认就是 exception。</li></ol><p>在上面这个过程中，有两个比较长的方法，松哥这里需要和大家额外多说两句。</p><p><strong>determineViewName</strong></p><p>这个就是根据异常类型找到视图名，我们来看下具体的查找方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">determineViewName</span><span class="hljs-params">(Exception ex, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String viewName = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.excludedExceptions != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (Class&lt;?&gt; excludedEx : <span class="hljs-keyword">this</span>.excludedExceptions) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (excludedEx.equals(ex.getClass())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.exceptionMappings != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">viewName = findMatchingViewName(<span class="hljs-keyword">this</span>.exceptionMappings, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (viewName == <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.defaultErrorView != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">viewName = <span class="hljs-keyword">this</span>.defaultErrorView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> viewName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果当前异常包含在 excludedExceptions 中，则直接返回 null（意思是当前异常被忽略处理了，直接按照默认方式来）。</li><li>如果 exceptionMappings 不为 null，则直接调用 findMatchingViewName 方法查找异常对应的视图名（exceptionMappings 变量就是前面我们配置的映射关系），具体的查找方式就是遍历我们前面配置的映射表。</li><li>如果没找到对应的 viewName，并且用户配置了 defaultErrorView，则将 defaultErrorView 赋值给 viewName，并将 viewName 返回。</li></ol><p><strong>determineStatusCode</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title">determineStatusCode</span><span class="hljs-params">(HttpServletRequest request, String viewName)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.statusCodes.containsKey(viewName)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.statusCodes.get(viewName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultStatusCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就比较容易，直接去 statusCodes 中查看是否有视图对应的状态码，如果有则直接返回，如果没有，就返回一个默认的。</p><h2 id="3-HandlerExceptionResolverComposite"><a href="#3-HandlerExceptionResolverComposite" class="headerlink" title="3.HandlerExceptionResolverComposite"></a>3.HandlerExceptionResolverComposite</h2><p>最后，还有一个 HandlerExceptionResolverComposite 需要和大家介绍下，这是一个组合的异常处理器，用来代理哪些真正干活的异常处理器。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resolvers != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (HandlerExceptionResolver handlerExceptionResolver : <span class="hljs-keyword">this</span>.resolvers) &#123;</span><br><span class="line">ModelAndView mav = handlerExceptionResolver.resolveException(request, response, handler, ex);</span><br><span class="line"><span class="hljs-keyword">if</span> (mav != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的 resolveException 方法就比较简单了，这种写法我们已经见到过很多次了，不再赘述。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和大家简单聊一聊 SpringMVC 中的异常处理体系，整体来说并不难，小伙伴们可以仔细品一品。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;SpringMVC 中针对异常问题有一套完整的处理体系，这套体系非常好用，今天松哥就花点时间来和大家聊一聊 SpringMVC 中的异常处理体系，我们把 SpringMVC 中的异常体系从头到尾梳理一下。&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>对不起，我加入敌方战队了</title>
    <link href="http://www.javaboy.org/2021/0410/java-lombok.html"/>
    <id>http://www.javaboy.org/2021/0410/java-lombok.html</id>
    <published>2021-04-10T11:14:40.000Z</published>
    <updated>2021-04-10T11:15:37.126Z</updated>
    
    <content type="html"><![CDATA[<p>工作原因，最近我也用上了 Lombok（<strong>本文纯属技术探讨，不持任何立场，请轻喷</strong>）。</p><a id="more"></a><p>用 Lombok 要在 IDEA 上安装插件，忽然发现我的 IDEA 上不知道啥时候已经安装了这个插件了，仔细回忆，想起来是某一次从网上下载了一个开源项目，对方使用了 Lombok，导致我在本地不得不安装一个 Lombok 插件，这种感觉并不太爽，自那以后这个插件就在我的 IDEA 里躺尸了。</p><p>最近没办法，有一个项目一开始就用了 Lombok，我现在接手也不得不用，那么刚好趁此机会，松哥也来和大家聊一聊 Lombok 的使用吧。</p><h2 id="Lombok-简介"><a href="#Lombok-简介" class="headerlink" title="Lombok 简介"></a>Lombok 简介</h2><p>Lombok 是一个 Java 库，能自动插入编辑器并构建工具，简化 Java 开发。通过添加注解的方式，不需要为类编写 getter/setter/equals 等方法，同时可以自动化日志变量。简而言之：Lombok 能以简单的注解形式来简化 Java 代码，提高开发人员的开发效率。</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>由于 Lombok 会自动帮我们生成一些代码，这些代码在 source 阶段是没有的，编译之后才会用，为了避免开发工具如 IDEA 报错，一般在使用 Lombok 的时候还需要安装一个 IDEA 插件。</p><p>安装方式非常简单，直接在 IDEA 市场搜索 Lombok，点击 install 按钮即可，安装完成后，重启 IDEA。</p><p><img src="http://img.itboyhub.com/2021/02/20210407082544.png" alt></p><p>我这个因为安装的比较早，现在已经需要更新了。</p><h2 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h2><p>Lombok 的使用非常简单，在 Spring Boot 创建的时候，就可以添加 Lombok 依赖，如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210407082830.png" alt></p><p>创建成功后，项目中多了如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就可以了，接下来我们就可以在项目中使用 Lombok 了。</p><p>Lombok 主要包含如下一些内容：</p><ul><li>val：类似于前端 js 中的 var。</li><li>@NotNull：这个用于方法参数，可以自动校验方法参数是否为空。</li><li>@Cleanup：这个用在局部变量上，在变量使用结束时会自动调用 close 方法释放资源，典型用法就是 IO 流的相关操作中使用该注解。</li><li>@Getter 用在字段或者类上，当用在字段上时会自动生成字段的 getter；当用在类上时，会自动生成该类所有非静态字段的 getter，使用该注解还可以调整 getter 方法的访问级别。</li><li>@Setter：同上。</li><li>@ToString：这个注解用在类上，自动生成类的 toString 方法，可以做一些定制，比如不使用某个字段，不调用 getter 等。</li><li>@EqualsAndHashCode：这个注解用在类上，自动生成类中所有非静态非瞬时字段（添加了 <code>@Transient</code> 注解的字段为瞬时字段）的 equals 方法和 hashCode 方法。</li><li>@NoArgsConstructor：这个注解用在类上，会自动生成一个无参构造函数。</li><li>@AllArgsConstructor：这个注解用在类上，会自动生成一个包含所有参数的构造函数。</li><li>@RequiredArgsConstructor：这个注解也是作用在类上，它会为 final 字段和标记了 @NotNull 的字段生成构造函数。</li><li>@Data：这个注解也是用在类上，使用该注解相当于同时应用了 <code>@Getter</code>、<code>@Setter</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code>、<code>@RequiredArgsConstructor</code>。如果已经定义了一个构造方法，就不会再自动生成构造方法了。</li><li>@Value：这个注解用在类上，和 @Data 类似，但是用于不可变类型。生成的类和所有字段都设置为 final，所有字段都为 private，自动生成 Getter 但是没有 Setter，会生成初始化所有字段的构造函数。相当于同时应用了 <code>final @ToString</code>、 <code>@EqualsAndHashCode</code>、 <code>@AllArgsConstructor</code>、<code>@FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE)</code> 和 <code>@Getter</code>。</li><li>@CommonsLog：日志注解，相当于定义变量 <code>log = org.apache.commons.logging.LogFactory.getLog(LogExample.class)</code>。</li><li>@JBossLog：日志注解：相当于定义变量 <code>log = org.jboss.logging.Logger.getLogger(LogExample.class)</code>。</li><li>@Log：日志注解，相当于定义变量 <code>log = java.util.logging.Logger.getLogger(LogExample.class.getName())</code>。</li><li>@Log4j：日志注解，相当于定义变量 <code>log = org.apache.log4j.Logger.getLogger(LogExample.class)</code>。</li><li>@Log4j2：日志注解，相当于定义变量 <code>log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class)</code>。</li><li>@Slf4j：日志注解，相当于定义变量 <code>log = org.slf4j.LoggerFactory.getLogger(LogExample.class)</code>。</li><li>@XSlf4j：日志注解，相当于定义变量 <code>log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class)</code>。</li></ul><p>随便举几个例子大家来感受下。</p><p>如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Getter</span></span><br><span class="line"><span class="hljs-meta">@Setter</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><p><img src="http://img.itboyhub.com/2021/02/20210407095045.png" alt></p><p>如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> User)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            User other = (User)o;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!other.canEqual(<span class="hljs-keyword">this</span>)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                Object <span class="hljs-keyword">this</span>$id = <span class="hljs-keyword">this</span>.getId();</span><br><span class="line">                Object other$id = other.getId();</span><br><span class="line">                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>$id == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (other$id != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>$id.equals(other$id)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Object <span class="hljs-keyword">this</span>$name = <span class="hljs-keyword">this</span>.getName();</span><br><span class="line">                Object other$name = other.getName();</span><br><span class="line">                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>$name == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (other$name != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>$name.equals(other$name)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canEqual</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object other)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> other <span class="hljs-keyword">instanceof</span> User;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> PRIME = <span class="hljs-keyword">true</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;</span><br><span class="line">        Object $id = <span class="hljs-keyword">this</span>.getId();</span><br><span class="line">        <span class="hljs-keyword">int</span> result = result * <span class="hljs-number">59</span> + ($id == <span class="hljs-keyword">null</span> ? <span class="hljs-number">43</span> : $id.hashCode());</span><br><span class="line">        Object $name = <span class="hljs-keyword">this</span>.getName();</span><br><span class="line">        result = result * <span class="hljs-number">59</span> + ($name == <span class="hljs-keyword">null</span> ? <span class="hljs-number">43</span> : $name.hashCode());</span><br><span class="line">        <span class="hljs-keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"User(id="</span> + <span class="hljs-keyword">this</span>.getId() + <span class="hljs-string">", name="</span> + <span class="hljs-keyword">this</span>.getName() + <span class="hljs-string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUtils</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String source, String dest)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File sourceFile = <span class="hljs-keyword">new</span> File(source);</span><br><span class="line">        File destFile = <span class="hljs-keyword">new</span> File(dest);</span><br><span class="line">        <span class="hljs-meta">@Cleanup</span> InputStream in = <span class="hljs-keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line">        <span class="hljs-meta">@Cleanup</span> OutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(destFile);</span><br><span class="line">        <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> r = in.read(b);</span><br><span class="line">            <span class="hljs-keyword">if</span> (r == -<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;</span><br><span class="line">            out.write(b, <span class="hljs-number">0</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后生成的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileUtils</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileUtils</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(String source, String dest)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File sourceFile = <span class="hljs-keyword">new</span> File(source);</span><br><span class="line">        File destFile = <span class="hljs-keyword">new</span> File(dest);</span><br><span class="line">        FileInputStream in = <span class="hljs-keyword">new</span> FileInputStream(sourceFile);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream out = <span class="hljs-keyword">new</span> FileOutputStream(destFile);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">int</span> r = in.read(b);</span><br><span class="line">                    <span class="hljs-keyword">if</span> (r == -<span class="hljs-number">1</span>) &#123;</span><br><span class="line">                        <span class="hljs-keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    out.write(b, <span class="hljs-number">0</span>, r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (Collections.singletonList(out).get(<span class="hljs-number">0</span>) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (Collections.singletonList(in).get(<span class="hljs-number">0</span>) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我就不一一举例了，这个东西使用还是非常容易的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Lombok 这个插件还是比较好玩的，注意我用“好玩”来形容它，因为确实好玩，几个注解就可以帮我们生成一大堆代码，N 年前我搞 Android 开发那会，当时 Android 生态里边就有类似的框架，因为当时公司禁止使用该类框架，导致我一直对这种自动生成代码的框架敬而远之。后来搞 Java 了，偶尔也会有小伙伴问我用不用 Lombok，你说不用吧，被说人老古董，你说用吧，被人说是菜鸟，算了，还是沉默吧。</p><p>问一个 Java 程序员用不用 Lombok 就像问一个软件工程师哪种开发语言最好，这绝对是一个足够“燃”的话题。但是退一步想想，语言只是一个工具，利用这样一个工具帮助我们实现心中的一些想法才是最重要的，所以没有必要去争论语言的好坏，存在即合理，去争论语言的好坏格局就小了，更何况 Lombok 只是 Java 语言中一个小小的框架。</p><p>所以，以后大家见到有人用 Lombok，一定要凑上前说一句：牛逼！见到有人喷 Lombok，也要来一句：牛逼！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作原因，最近我也用上了 Lombok（&lt;strong&gt;本文纯属技术探讨，不持任何立场，请轻喷&lt;/strong&gt;）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
      <category term="Lombok" scheme="http://www.javaboy.org/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>其实我不仅会 Spring Security，Shiro 也略懂一二！</title>
    <link href="http://www.javaboy.org/2021/0408/shiro-guide.html"/>
    <id>http://www.javaboy.org/2021/0408/shiro-guide.html</id>
    <published>2021-04-08T07:20:07.000Z</published>
    <updated>2021-04-08T07:25:30.684Z</updated>
    
    <content type="html"><![CDATA[<p>和大家分享一个松哥原创的 Shiro 教程吧，还没写完，先整一部分，剩下的敬请期待。</p><h2 id="1-Shiro简介"><a href="#1-Shiro简介" class="headerlink" title="1.Shiro简介"></a>1.Shiro简介</h2><p>Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架具有直观、易用等特性，同时也能提供健壮的安全性，虽然它的功能不如SpringSecurity那么强大，但是在普通的项目中也够用了。</p><a id="more"></a><h3 id="1-1-由来"><a href="#1-1-由来" class="headerlink" title="1.1 由来"></a>1.1 由来</h3><p>Shiro的前身是JSecurity，2004年，Les Hazlewood和Jeremy Haile创办了Jsecurity。当时他们找不到适用于应用程序级别的合适Java安全框架，同时又对JAAS非常失望。2004年到2008年期间，JSecurity托管在SourceForge上，贡献者包括Peter Ledbrook、Alan Ditzel和Tim Veil。2008年，JSecurity项目贡献给了Apache软件基金会（ASF），并被接纳成为Apache Incubator项目，由导师管理，目标是成为一个顶级Apache项目。期间，Jsecurity曾短暂更名为Ki，随后因商标问题被社区更名为“Shiro”。随后项目持续在Apache Incubator中孵化，并增加了贡献者Kalle Korhonen。2010年7月，Shiro社区发布了1.0版，随后社区创建了其项目管理委员会，并选举Les Hazlewood为主席。2010年9月22日，Shrio成为Apache软件基金会的顶级项目（TLP）。</p><h3 id="1-2-有哪些功能"><a href="#1-2-有哪些功能" class="headerlink" title="1.2 有哪些功能"></a>1.2 有哪些功能</h3><p>Apache Shiro是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。Apache Shiro的首要目标是易于使用和理解。安全有时候是很复杂的，甚至是痛苦的，但它没有必要这样。框架应该尽可能掩盖复杂的地方，露出一个干净而直观的API，来简化开发人员在应用程序安全上所花费的时间。</p><p>以下是你可以用Apache Shiro 所做的事情：</p><ol><li>验证用户来核实他们的身份</li><li>对用户执行访问控制，如：判断用户是否被分配了一个确定的安全角色；判断用户是否被允许做某事</li><li>在任何环境下使用Session API，即使没有Web容器</li><li>在身份验证，访问控制期间或在会话的生命周期，对事件作出反应</li><li>聚集一个或多个用户安全数据的数据源，并作为一个单一的复合用户“视图”</li><li>单点登录（SSO）功能</li><li><p>为没有关联到登录的用户启用”Remember Me”服务</p><p> 等等</p></li></ol><p>Apache Shiro是一个拥有许多功能的综合性的程序安全框架。下面的图表展示了Shiro的重点：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a6a1cb5eb8a807afe4f4b2bd094a97ba.png" alt="p306"></p><p>Shiro中有四大基石——身份验证，授权，会话管理和加密。</p><ol><li>Authentication：有时也简称为“登录”，这是一个证明用户是谁的行为。</li><li>Authorization：访问控制的过程，也就是决定“谁”去访问“什么”。</li><li>Session Management：管理用户特定的会话，即使在非Web 或EJB 应用程序。</li><li>Cryptography：通过使用加密算法保持数据安全同时易于使用。</li></ol><p>除此之外，Shiro也提供了额外的功能来解决在不同环境下所面临的安全问题，尤其是以下这些：</p><ol><li>Web Support：Shiro的web支持的API能够轻松地帮助保护Web应用程序。</li><li>Caching：缓存是Apache Shiro中的第一层公民，来确保安全操作快速而又高效。</li><li>Concurrency：Apache Shiro利用它的并发特性来支持多线程应用程序。</li><li>Testing：测试支持的存在来帮助你编写单元测试和集成测试。</li><li>“Run As”：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。</li><li>“Remember Me”：在会话中记住用户的身份，这样用户只需要在强制登录时候登录。</li></ol><h2 id="2-从一个简单的案例开始身份认证"><a href="#2-从一个简单的案例开始身份认证" class="headerlink" title="2.从一个简单的案例开始身份认证"></a>2.从一个简单的案例开始身份认证</h2><h3 id="2-1-shiro下载"><a href="#2-1-shiro下载" class="headerlink" title="2.1 shiro下载"></a>2.1 shiro下载</h3><p>要学习shiro，我们首先需求去shiro官网下载shiro，官网地址地址<a href="https://shiro.apache.org/，截至本文写作时，shiro的最新稳定版本为1.7.1（Shiro" target="_blank" rel="noopener">https://shiro.apache.org/，截至本文写作时，shiro的最新稳定版本为1.7.1（Shiro</a> 在 2017-2019 曾经停更了两年，我一度以为以为这个项目 gg 了），本文将采用这个版本。当然，shiro我们也可以从github上下载到源码。两个源码下载地址如下：</p><p>1.<a href="http://shiro.apache.org/download.html#latest" target="_blank" rel="noopener">apache shiro</a><br>2.<a href="https://github.com/apache/shiro/archive/master.zip" target="_blank" rel="noopener">github-shiro</a></p><p>上面我主要是和小伙伴们介绍下源码的下载，并没有涉及到jar包的下载，jar包我们到时候直接使用maven即可。</p><h3 id="2-2-创建演示工程"><a href="#2-2-创建演示工程" class="headerlink" title="2.2 创建演示工程"></a>2.2 创建演示工程</h3><p>这里我们先不急着写代码，我们先打开刚刚下载到的源码，源码中有一个samples目录，如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/93c851b022e937eee84972116c10604f.png" alt="p307"></p><p>这个samples目录是官方给我们的一些演示案例，其中有一个quickstart项目，这个项目是一个maven项目，参考这个quickstart，我们来创建一个自己的演示工程。</p><p>1.首先使用maven创建一个JavaSE工程<br>工程创建成功后在pom文件中添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置用户</p><p>参考quickstart项目中的shiro.ini文件，我们来配置一个用户，配置方式如下：首先在resources目录下创建一个shiro.ini文件，文件内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[users]</span><br><span class="line">sang=123,admin</span><br><span class="line">[roles]</span><br><span class="line">admin=*</span><br></pre></td></tr></table></figure><p>以上配置表示我们创建了一个名为sang的用户，该用户的密码是123，该用户的角色是admin，而admin具有操作所有资源的权限。</p><p>3.执行登录</p><p>OK，做完上面几步之后，我们就可以来看看如何实现一次简单的登录操作了。这个登录操作我们依然是参考quickstart项目中的类来实现，首先我们要通过shiro.ini创建一个SecurityManager，再将这个SecurityManager设置为单例模式，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = <span class="hljs-keyword">new</span> IniSecurityManagerFactory(<span class="hljs-string">"classpath:shiro.ini"</span>);</span><br><span class="line">org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();</span><br><span class="line">SecurityUtils.setSecurityManager(securityManager);</span><br></pre></td></tr></table></figure><p>如此之后，我们就配置好了一个基本的Shiro环境，注意此时的用户和角色信息我们配置在shiro.ini这个配置文件中，接下来我们就可以获取一个Subject了，这个Subject就是我们当前的用户对象，获取方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure><p>拿到这个用户对象之后，接下来我们可以获取一个session了，这个session和我们web中的HttpSession的操作基本上是一致的，不同的是，这个session不依赖任何容器，可以随时随地获取，获取和操作方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//获取session</span></span><br><span class="line">Session session = currentUser.getSession();</span><br><span class="line"><span class="hljs-comment">//给session设置属性值</span></span><br><span class="line">session.setAttribute(<span class="hljs-string">"someKey"</span>, <span class="hljs-string">"aValue"</span>);</span><br><span class="line"><span class="hljs-comment">//获取session中的属性值</span></span><br><span class="line">String value = (String) session.getAttribute(<span class="hljs-string">"someKey"</span>);</span><br></pre></td></tr></table></figure><p>说了这么多，我们的用户到现在还没有登录呢，Subject中有一个isAuthenticated方法用来判断当前用户是否已经登录，如果isAuthenticated方法返回一个false，则表示当前用户未登录，那我们就可以执行登陆，登录方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">    UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(<span class="hljs-string">"sang"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        currentUser.login(token);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">        log.info(<span class="hljs-string">"There is no user with username of "</span> + token.getPrincipal());</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">        log.info(<span class="hljs-string">"Password for account "</span> + token.getPrincipal() + <span class="hljs-string">" was incorrect!"</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">        log.info(<span class="hljs-string">"The account for username "</span> + token.getPrincipal() + <span class="hljs-string">" is locked.  "</span> +</span><br><span class="line">                <span class="hljs-string">"Please contact your administrator to unlock it."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构造UsernamePasswordToken，两个参数就是我们的用户名和密码，然后调用Subject中的login方法执行登录，当用户名输错，密码输错、或者账户锁定等问题出现时，系统会通过抛异常告知调用者这些问题。</p><p>当登录成功之后，我们可以通过如下方式获取当前登陆用户的用户名：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="hljs-string">"User ["</span> + currentUser.getPrincipal() + <span class="hljs-string">"] logged in successfully."</span>);</span><br></pre></td></tr></table></figure><p>我们也可以通过调用Subject中的hasRole和isPermitted方法来判断当前用户是否具备某种角色或者某种权限，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (currentUser.hasRole(<span class="hljs-string">"admin"</span>)) &#123;</span><br><span class="line">    log.info(<span class="hljs-string">"May the Schwartz be with you!"</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="hljs-string">"Hello, mere mortal."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (currentUser.isPermitted(<span class="hljs-string">"lightsaber:wield"</span>)) &#123;</span><br><span class="line">    log.info(<span class="hljs-string">"You may use a lightsaber ring.  Use it wisely."</span>);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="hljs-string">"Sorry, lightsaber rings are for schwartz masters only."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们可以通过logout方法注销本次登录，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentUser.logout();</span><br></pre></td></tr></table></figure><p>OK，至此，我们通过官方案例给小伙伴们简单介绍了Shiro中的登录操作，完整案例大家可以参考官方的demo。</p><h2 id="3-聊一聊Shiro中的Realm"><a href="#3-聊一聊Shiro中的Realm" class="headerlink" title="3. 聊一聊Shiro中的Realm"></a>3. 聊一聊Shiro中的Realm</h2><h3 id="3-1-登录流程是什么样的"><a href="#3-1-登录流程是什么样的" class="headerlink" title="3.1 登录流程是什么样的"></a>3.1 登录流程是什么样的</h3><p>首先我们来看shiro官方文档中这样一张登录流程图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f8b6568be71a8cb15f49f862101dd661.png" alt="p308"></p><p>参照此图，我们的登录一共要经过如下几个步骤：</p><ol><li>应用程序代码调用Subject.login方法，传递创建好的包含终端用户的Principals(身份)和Credentials(凭证)的AuthenticationToken实例(即上文例子中的UsernamePasswordToken)。</li><li>Subject实例，通常是DelegatingSubject（或子类）委托应用程序的SecurityManager通过调用securityManager.login(token)开始真正的验证工作(在DelegatingSubject类的login方法中打断点即可看到)。</li><li>SubjectManager作为一个基本的“保护伞”的组成部分，接收token以及简单地委托给内部的Authenticator实例通过调用authenticator.authenticate(token)。这通常是一个ModularRealmAuthenticator实例，支持在身份验证中协调一个或多个Realm实例。ModularRealmAuthenticator本质上为Apache Shiro 提供了PAM-style 范式（其中在PAM 术语中每个Realm 都是一个’module’）。</li><li>如果应用程序中配置了一个以上的Realm，ModularRealmAuthenticator实例将利用配置好的AuthenticationStrategy来启动Multi-Realm认证尝试。在Realms 被身份验证调用之前，期间和以后，AuthenticationStrategy被调用使其能够对每个Realm的结果作出反应。如果只有一个单一的Realm 被配置，它将被直接调用，因为没有必要为一个单一Realm的应用使用AuthenticationStrategy。</li><li>每个配置的Realm用来帮助看它是否支持提交的AuthenticationToken。如果支持，那么支持Realm的getAuthenticationInfo方法将会伴随着提交的token被调用。</li></ol><p>OK，通过上面的介绍，相信小伙伴们对整个登录流程都有一定的理解了，小伙伴可以通过打断点来验证我们上文所说的五个步骤。那么在上面的五个步骤中，小伙伴们看到了有一个Realm承担了很重要的一部分工作，那么这个Realm到底是个什么东西，接下来我们就来仔细看一看。</p><h3 id="3-2-什么是Realm"><a href="#3-2-什么是Realm" class="headerlink" title="3.2 什么是Realm"></a>3.2 什么是Realm</h3><p>根据Realm文档上的解释，Realms担当Shiro和你的应用程序的安全数据之间的“桥梁”或“连接器”。当它实际上与安全相关的数据如用来执行身份验证（登录）及授权（访问控制）的用户帐户交互时，Shiro从一个或多个为应用程序配置的Realm 中寻找许多这样的东西。在这个意义上说，<strong>Realm 本质上是一个特定安全的DAO</strong>：它封装了数据源的连接详细信息，使Shiro 所需的相关的数据可用。当配置Shiro 时，你必须指定至少一个Realm 用来进行身份验证和/或授权。SecurityManager可能配置多个Realms，但至少有一个是必须的。Shiro 提供了立即可用的Realms 来连接一些安全数据源（即目录），如LDAP，关系数据库（JDBC），文本配置源，像INI 及属性文件，以及更多。你可以插入你自己的Realm 实现来代表自定义的数据源，如果默认地Realm不符合你的需求。</p><p>看了上面这一段解释，可能还有小伙伴云里雾里，那么接下来我们来通过一个简单的案例来看看Realm到底扮演了一个什么样的作用，注意，本文的案例在上文案例的基础上完成。首先自定义一个MyRealm，内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Realm</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyRealm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> token <span class="hljs-keyword">instanceof</span> UsernamePasswordToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationInfo <span class="hljs-title">getAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String password = <span class="hljs-keyword">new</span> String(((<span class="hljs-keyword">char</span>[]) token.getCredentials()));</span><br><span class="line">        String username = token.getPrincipal().toString();</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"sang"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(<span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"123"</span>.equals(password)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IncorrectCredentialsException(<span class="hljs-string">"密码不正确"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义Realm实现Realm接口，该接口中有三个方法，第一个getName方法用来获取当前Realm的名字，第二个supports方法用来判断这个realm所支持的token，这里我假设值只支持UsernamePasswordToken类型的token，第三个getAuthenticationInfo方法则进行了登陆逻辑判断，从token中取出用户的用户名密码等，进行判断，当然，我这里省略掉了数据库操作，当登录验证出现问题时，抛异常即可，这里抛出的异常，将在执行登录那里捕获到（注意，由于我这里定义的MyRealm是实现了Realm接口，所以这里的用户名和密码都需要我手动判断是否正确，后面的文章我会介绍其他写法）。</p><p>OK，创建好了MyRealm之后还不够，我们还需要做一个简单配置，让MyRealm生效，将shiro.ini文件中的所有东西都注释掉，添加如下两行：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyRealm= org.sang.MyRealm</span><br><span class="line">securityManager.realms=$MyRealm</span><br></pre></td></tr></table></figure><p>第一行表示定义了一个realm，第二行将这个定义好的交给securityManger，这里实际上会调用到RealmSecurityManager类的setRealms方法。OK，做好这些之后，小伙伴们可以在MyRealm类中的一些关键节点打上断点，再次执行main方法，看看整个的登录流程。 </p><h2 id="4-再来聊一聊Shiro中的Realm"><a href="#4-再来聊一聊Shiro中的Realm" class="headerlink" title="4. 再来聊一聊Shiro中的Realm"></a>4. 再来聊一聊Shiro中的Realm</h2><h3 id="4-1-Realm的继承关系"><a href="#4-1-Realm的继承关系" class="headerlink" title="4.1 Realm的继承关系"></a>4.1 Realm的继承关系</h3><p>通过查看类的继承关系，我们发现Realm的子类实际上有很多种，这里我们就来看看有代表性的几种：</p><ol><li>IniRealm </li></ol><p>可能我们并不知道，实际上这个类在我们第二篇文章中就已经用过了。这个类一开始就有如下两行定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String USERS_SECTION_NAME = <span class="hljs-string">"users"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ROLES_SECTION_NAME = <span class="hljs-string">"roles"</span>;</span><br></pre></td></tr></table></figure><p>这两行配置表示shiro.ini文件中，[users]下面的表示表用户名密码还有角色，[roles]下面的则是角色和权限的对应关系。</p><ol start="2"><li>PropertiesRealm</li></ol><p>PropertiesRealm则规定了另外一种用户、角色定义方式，如下：</p><p>user.user1=password,role1<br>role.role1=permission1</p><ol start="3"><li>JdbcRealm</li></ol><p>这个顾名思义，就是从数据库中查询用户的角色、权限等信息。打开JdbcRealm类，我们看到源码中有如下几行：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_AUTHENTICATION_QUERY = <span class="hljs-string">"select password from users where username = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SALTED_AUTHENTICATION_QUERY = <span class="hljs-string">"select password, password_salt from users where username = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_USER_ROLES_QUERY = <span class="hljs-string">"select role_name from user_roles where username = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_PERMISSIONS_QUERY = <span class="hljs-string">"select permission from roles_permissions where role_name = ?"</span>;</span><br></pre></td></tr></table></figure><p>根据这几行预设的SQL我们就可以大致推断出数据库中表的名称以及字段了，当然，我们也可以自定义SQL。JdbcRealm实际上是AuthenticatingRealm的子类，关于AuthenticatingRealm我们在后面还会详细说到，这里先不展开。接下来我们就来详细说说这个JdbcRealm。</p><h3 id="4-2-JdbcRealm"><a href="#4-2-JdbcRealm" class="headerlink" title="4.2 JdbcRealm"></a>4.2 JdbcRealm</h3><ol><li>准备工作</li></ol><p>使用JdbcRealm，涉及到数据库操作，要用到数据库连接池，这里我使用Druid数据库连接池，因此首先添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数据库创建</li></ol><p>想要使用JdbcRealm，那我首先要创建数据库，根据JdbcRealm中预设的SQL，我定义的数据库表结构如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1387c9ffa9e2e2e731c1ff4ba305fe64.png" alt="p309"></p><p>这里为了大家能够直观的看到表的关系，我使用了外键，实际工作中，视情况而定。然后向表中添加几条测试数据。数据库脚本小伙伴可以在github上下载到（<a href="https://github.com/lenve/shiroSamples/blob/v4/shiroDemo.sql）。" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/blob/v4/shiroDemo.sql）。</a></p><ol start="3"><li>配置文件处理</li></ol><p>然后将shiro.ini中的所有配置注释掉，添加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql://localhost:3306/shiroDemo</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123</span><br><span class="line">jdbcRealm.dataSource=$dataSource</span><br><span class="line">jdbcRealm.permissionsLookupEnabled=true</span><br><span class="line">securityManager.realms=$jdbcRealm</span><br></pre></td></tr></table></figure><p>这里的配置文件都很简单，不做过多赘述，小伙伴唯一需要注意的是permissionsLookupEnabled需要设置为true，否则一会JdbcRealm就不会去查询权限用户权限。</p><ol start="4"><li>测试</li></ol><p>OK，做完上面几步就可以测试了，测试方式和第二篇文章中一样，我们可以测试下用户登录，用户角色和用户权限。</p><ol start="5"><li>自定义查询SQL</li></ol><p>小伙伴们看懂了上文，对于自定义查询SQL就没什么问题了。我这里举一个简单的例子，比如我要自定义authenticationQuery对对应的SQL，查看JdbcRealm源码，我们发现authenticationQuery对应的SQL本来是<figure class="highlight plain hljs"><figcaption><span>password from users where username </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>jdbcRealm.authenticationQuery=select password from employee where username = ?<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">OK,这个小伙伴下来自己做尝试，我这里就不演示了。</span><br><span class="line"></span><br><span class="line">## 5. Shiro中多Realm的认证策略问题</span><br><span class="line"></span><br><span class="line">### 5.1 多Realm认证策略</span><br><span class="line"></span><br><span class="line">不知道小伙伴们是否还记得这张登录流程图：</span><br><span class="line"></span><br><span class="line">![p308](https://img-blog.csdnimg.cn/img_convert/f8b6568be71a8cb15f49f862101dd661.png)</span><br><span class="line"></span><br><span class="line">从这张图中我们可以清晰看到Realm是可以有多个的，不过到目前为止，我们所有的案例都还是单Realm，那么我们先来看一个简单的多Realm情况。</span><br><span class="line"></span><br><span class="line">前面的文章我们自己创建了一个MyRealm，也用过JdbcRealm，但都是单独使用的，现在我想将两个一起使用，只需要修改shiro.ini配置即可，如下：</span><br><span class="line"></span><br><span class="line">```properties</span><br><span class="line">MyRealm= org.sang.MyRealm</span><br><span class="line"></span><br><span class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql://localhost:3306/shiroDemo</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123</span><br><span class="line">jdbcRealm.dataSource=$dataSource</span><br><span class="line">jdbcRealm.permissionsLookupEnabled=true</span><br><span class="line">securityManager.realms=$jdbcRealm,$MyRealm</span><br></pre></td></tr></table></figure></p><p>但是此时我数据库中用户的信息是sang/123,MyRealm中配置的信息也是sang/123，我把MyRealm中的用户信息修改为<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">    String password = new String(((char[]) token.getCredentials()));</span><br><span class="line">    String username = token.getPrincipal().toString();</span><br><span class="line">    if (!&quot;江南一点雨&quot;.equals(username)) &#123;</span><br><span class="line">        throw new UnknownAccountException(&quot;用户不存在&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!&quot;456&quot;.equals(password)) &#123;</span><br><span class="line">        throw new IncorrectCredentialsException(&quot;密码不正确&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return new SimpleAuthenticationInfo(username, password, getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个时候我们就配置了两个Realm，还是使用我们一开始的测试代码进行登录测试，这个时候我们发现我既可以使用<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.2 原理追踪</span><br><span class="line"></span><br><span class="line">好了，有了上面的问题后，接下来我们在Subject的login方法上打断点，跟随程序的执行步骤，我们来到了ModularRealmAuthenticator类的doMultiRealmAuthentication方法中，如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">protected AuthenticationInfo doAuthenticate(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</span><br><span class="line">    this.assertRealmsConfigured();</span><br><span class="line">    Collection&lt;Realm&gt; realms = this.getRealms();</span><br><span class="line">    return realms.size() == 1?this.doSingleRealmAuthentication((Realm)realms.iterator().next(), authenticationToken):this.doMultiRealmAuthentication(realms, authenticationToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法中，首先会获取当前一共有多少个realm，如果只有一个则执行doSingleRealmAuthentication方法进行处理，如果有多个realm，则执行doMultiRealmAuthentication方法进行处理。doSingleRealmAuthentication方法部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doSingleRealmAuthentication</span><span class="hljs-params">(Realm realm, AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    AuthenticationInfo info = realm.getAuthenticationInfo(token);</span><br><span class="line">    <span class="hljs-keyword">if</span>(info == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        String msg = <span class="hljs-string">"Realm ["</span> + realm + <span class="hljs-string">"] was unable to find account data for the submitted AuthenticationToken ["</span> + token + <span class="hljs-string">"]."</span>;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(msg);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到这里就明白了，这里调用了realm的getAuthenticationInfo方法，这个方法实际上就是我们自己实现的MyRealm中的getAuthenticationInfo方法。</p><p>那如果有多个Realm呢？我们来看看doMultiRealmAuthentication方法的实现，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doMultiRealmAuthentication</span><span class="hljs-params">(Collection&lt;Realm&gt; realms, AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">    AuthenticationStrategy strategy = <span class="hljs-keyword">this</span>.getAuthenticationStrategy();</span><br><span class="line">    AuthenticationInfo aggregate = strategy.beforeAllAttempts(realms, token);</span><br><span class="line">    Iterator var5 = realms.iterator();</span><br><span class="line">    <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">        Realm realm = (Realm)var5.next();</span><br><span class="line">        aggregate = strategy.beforeAttempt(realm, token, aggregate);</span><br><span class="line">        <span class="hljs-keyword">if</span>(realm.supports(token)) &#123;</span><br><span class="line">            AuthenticationInfo info = <span class="hljs-keyword">null</span>;</span><br><span class="line">            Throwable t = <span class="hljs-keyword">null</span>;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                info = realm.getAuthenticationInfo(token);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            aggregate = strategy.afterAttempt(realm, token, info, aggregate, t);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="hljs-string">"Realm [&#123;&#125;] does not support token &#123;&#125;.  Skipping realm."</span>, realm, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    aggregate = strategy.afterAllAttempts(token, aggregate);</span><br><span class="line">    <span class="hljs-keyword">return</span> aggregate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里主要来说下这个方法的实现思路：</p><ol><li><p>首先获取多Realm认证策略</p></li><li><p>构建一个AuthenticationInfo用来存放一会认证成功之后返回的信息</p></li><li><p>遍历Realm，调用每个Realm中的getAuthenticationInfo方法，看是否能够认证成功</p></li><li><p>每次获取到AuthenticationInfo之后，都调用afterAttempt方法进行结果合并</p></li><li><p>遍历完所有的Realm之后，调用afterAllAttempts进行结果合并，这里主要判断下是否一个都没匹配上</p></li></ol><h3 id="5-3-自由配置认证策略"><a href="#5-3-自由配置认证策略" class="headerlink" title="5.3 自由配置认证策略"></a>5.3 自由配置认证策略</h3><p>OK，经过上面的简单解析，小伙伴们对认证策略应该有一个大致的认识了，那么在Shiro中，一共支持三种不同的认证策略，如下：</p><ol><li><p>AllSuccessfulStrategy，这个表示所有的Realm都认证成功才算认证成功</p></li><li><p>AtLeastOneSuccessfulStrategy，这个表示只要有一个Realm认证成功就算认证成功，默认即此策略</p></li><li><p>FirstSuccessfulStrategy，这个表示只要第一个Realm认证成功，就算认证成功</p></li></ol><p>配置方式也很简单，在shiro.ini中进行配置，在上面配置的基础上，增加如下配置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator</span><br><span class="line">securityManager.authenticator=$authenticator</span><br><span class="line">allSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy</span><br><span class="line">securityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy</span><br></pre></td></tr></table></figure><p>此时，我们再进行登录测试，则会要求每个Realm都认证通过才算认证通过。</p><h2 id="6-Shiro中密码加密"><a href="#6-Shiro中密码加密" class="headerlink" title="6. Shiro中密码加密"></a>6. Shiro中密码加密</h2><h3 id="6-1-密码为什么要加密"><a href="#6-1-密码为什么要加密" class="headerlink" title="6.1 密码为什么要加密"></a>6.1 密码为什么要加密</h3><p>2011年12月21日，有人在网络上公开了一个包含600万个CSDN用户资料的数据库，数据全部为明文储存，包含用户名、密码以及注册邮箱。事件发生后CSDN在微博、官方网站等渠道发出了声明，解释说此数据库系2009年备份所用，因不明原因泄露，已经向警方报案。后又在官网网站发出了公开道歉信。在接下来的十多天里，金山、网易、京东、当当、新浪等多家公司被卷入到这次事件中。整个事件中最触目惊心的莫过于CSDN把用户密码明文存储，由于很多用户是多个网站共用一个密码，因此一个网站密码泄露就会造成很大的安全隐患。由于有了这么多前车之鉴，我们现在做系统时，密码都要加密处理。</p><p>密码加密我们一般会用到散列函数，又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。我们常用的散列函数有如下几种：</p><ol><li>MD5消息摘要算法</li></ol><p>MD5消息摘要算法是一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值，用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321中被加以规范。将数据（如一段文字）运算变为另一固定长度值，是散列算法的基础原理。1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞，因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。</p><ol start="2"><li>安全散列算法</li></ol><p>安全散列算法（Secure Hash Algorithm）是一个密码散列函数家族，是FIPS所认证的安全散列算法。能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。且若输入的消息不同，它们对应到不同字符串的机率很高。SHA家族的算法，由美国国家安全局所设计，并由美国国家标准与技术研究院发布，是美国的政府标准，其分别是：SHA-0：1993年发布，是SHA-1的前身；SHA-1：1995年发布，SHA-1在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5的后继者。但SHA-1的安全性在2000年以后已经不被大多数的加密场景所接受。2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1；SHA-2：2001年发布，包括SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似；因此有些人开始发展其他替代的散列算法；SHA-3：2015年正式发布，SHA-3并不是要取代SHA-2，因为SHA-2目前并没有出现明显的弱点。由于对MD5出现成功的破解，以及对SHA-0和SHA-1出现理论上破解的方法，NIST感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的SHA-3。</p><h3 id="6-2-Shiro中如何加密"><a href="#6-2-Shiro中如何加密" class="headerlink" title="6.2 Shiro中如何加密"></a>6.2 Shiro中如何加密</h3><p>Shiro中对以上两种散列算法都提供了支持，对于MD5，Shiro中生成消息摘要的方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Md5Hash md5Hash = <span class="hljs-keyword">new</span> Md5Hash(<span class="hljs-string">"123"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1024</span>);</span><br></pre></td></tr></table></figure><p>第一个参数是要生成密码的明文，第二个参数密码的盐值，第三个参数是生成消息摘要的迭代次数。</p><p>Shiro中对于安全散列算法的支持如下(支持多种算法，这里我举一个例子)：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sha512Hash sha512Hash = <span class="hljs-keyword">new</span> Sha512Hash(<span class="hljs-string">"123"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1024</span>);</span><br></pre></td></tr></table></figure><p>这里三个参数含义与上文基本一致，不再赘述。shiro中也提供了通用的算法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleHash md5 = <span class="hljs-keyword">new</span> SimpleHash(<span class="hljs-string">"md5"</span>, <span class="hljs-string">"123"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1024</span>);</span><br><span class="line">SimpleHash sha512 = <span class="hljs-keyword">new</span> SimpleHash(<span class="hljs-string">"sha-512"</span>, <span class="hljs-string">"123"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1024</span>);</span><br></pre></td></tr></table></figure><p>当用户注册时，我们可以通过上面的方式对密码进行加密，将加密后的字符串存入数据库中。我这里为了简单，就不写注册功能了，就把昨天数据库中用户的密码123改成sha512所对应的字符串，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cb5143cfcf5791478e057be9689d2360005b3aac951f947af1e6e71e3661bf95a7d14183dadfb0967bd6338eb4eb2689e9c227761e1640e6a033b8725fabc783</span><br></pre></td></tr></table></figure><p>同时，为了避免其他Realm的干扰，数据库中我只配置一个JdbcRealm。</p><p>此时如果我不做其他修改的话，登录必然会失败，原因很简单：我登录时输入的密码是123，但是数据库中的密码是一个很长的字符串，所以登录肯定不会成功。通过打断点，我们发现最终的密码比对是在SimpleCredentialsMatcher类中的doCredentialsMatch方法中进行密码比对的，比对的方式也很简单，直接使用了对用户输入的密码和数据库中的密码生成byte数组然后进行比较，最终的比较在MessageDigest类的isEqual方法中。部分逻辑如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object tokenCredentials, Object accountCredentials)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="hljs-comment">//获取用户输入密码的byte数组</span></span><br><span class="line">        <span class="hljs-keyword">byte</span>[] tokenBytes = <span class="hljs-keyword">this</span>.toBytes(tokenCredentials);</span><br><span class="line">        <span class="hljs-comment">//获取数据库中密码的byte数组</span></span><br><span class="line">        <span class="hljs-keyword">byte</span>[] accountBytes = <span class="hljs-keyword">this</span>.toBytes(accountCredentials);</span><br><span class="line">        <span class="hljs-keyword">return</span> MessageDigest.isEqual(tokenBytes, accountBytes);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageDigest的isEqual方法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] digesta, <span class="hljs-keyword">byte</span>[] digestb)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (digesta == digestb) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (digesta == <span class="hljs-keyword">null</span> || digestb == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (digesta.length != digestb.length) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-comment">// time-constant comparison</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; digesta.length; i++) &#123;</span><br><span class="line">        result |= digesta[i] ^ digestb[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result == <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是很容易理解的比较代码，这里不赘述。我们现在之所以登录失败是因为没有对用户输入的密码进行加密，通过对源代码的分析，我们发现是因为在AuthenticatingRealm类的assertCredentialsMatch方法中获取了一个名为SimpleCredentialsMatcher的密码比对器，这个密码比对器中比对的方法就是简单的比较，因此如果我们能够将这个密码比对器换掉就好了。我们来看一下CredentialsMatcher的继承关系：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/28604409cf95b6f0cca824c7d20fdcc0.png" alt="p310"></p><p>我们发现这个刚好有一个Sha512CredentialsMatcher比对器，这个比对器的doCredentialsMatch方法在它的父类HashedCredentialsMatcher，方法内容如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doCredentialsMatch</span><span class="hljs-params">(AuthenticationToken token, AuthenticationInfo info)</span> </span>&#123;</span><br><span class="line">    Object tokenHashedCredentials = hashProvidedCredentials(token, info);</span><br><span class="line">    Object accountCredentials = getCredentials(info);</span><br><span class="line">    <span class="hljs-keyword">return</span> equals(tokenHashedCredentials, accountCredentials);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们发现获取tokenHashedCredentials的方式不像以前那样简单粗暴了，而是调用了hashProvidedCredentials方法，而hashProvidedCredentials方法最终会来到下面这个重载方法中：  </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Hash <span class="hljs-title">hashProvidedCredentials</span><span class="hljs-params">(Object credentials, Object salt, <span class="hljs-keyword">int</span> hashIterations)</span> </span>&#123;</span><br><span class="line">    String hashAlgorithmName = assertHashAlgorithmName();</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleHash(hashAlgorithmName, credentials, salt, hashIterations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码似曾相识，很明显，是系统帮我们对用户输入的密码进行了转换。了解了这些之后，那我只需要将shiro.ini修改成如下样子即可实现登录了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sha512=org.apache.shiro.authc.credential.Sha512CredentialsMatcher</span><br><span class="line"># 迭代次数</span><br><span class="line">sha512.hashIterations=1024</span><br><span class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</span><br><span class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">dataSource.url=jdbc:mysql://localhost:3306/shiroDemo</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=123</span><br><span class="line">jdbcRealm.dataSource=$dataSource</span><br><span class="line">jdbcRealm.permissionsLookupEnabled=true</span><br><span class="line"># 修改JdbcRealm中的credentialsMatcher属性</span><br><span class="line">jdbcRealm.credentialsMatcher=$sha512</span><br><span class="line">securityManager.realms=$jdbcRealm</span><br></pre></td></tr></table></figure><p>如此之后，我们再进行登录测试，就可以登录成功了。</p><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v6.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v6.zip</a></p><h2 id="7-Shiro中密码加盐"><a href="#7-Shiro中密码加盐" class="headerlink" title="7. Shiro中密码加盐"></a>7. Shiro中密码加盐</h2><h3 id="7-1-密码为什么要加盐"><a href="#7-1-密码为什么要加盐" class="headerlink" title="7.1 密码为什么要加盐"></a>7.1 密码为什么要加盐</h3><p>不管是消息摘要算法还是安全散列算法，如果原文一样，生成密文也是一样的，这样的话，如果两个用户的密码原文一样，存到数据库中密文也就一样了，还是不安全，我们需要做进一步处理，常见解决方案就是加盐。盐从那里来呢？我们可以使用用户id（因为一般情况下，用户id是唯一的），也可以使用一个随机字符，我这里采用第一种方案。</p><h3 id="7-2-Shiro中如何实现加盐"><a href="#7-2-Shiro中如何实现加盐" class="headerlink" title="7.2 Shiro中如何实现加盐"></a>7.2 Shiro中如何实现加盐</h3><p>shiro中加盐的方式很简单，在用户注册时生成密码密文时，就要加入盐，如下几种方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Md5Hash md5Hash = <span class="hljs-keyword">new</span> Md5Hash(<span class="hljs-string">"123"</span>, <span class="hljs-string">"sang"</span>, <span class="hljs-number">1024</span>);</span><br><span class="line">Sha512Hash sha512Hash = <span class="hljs-keyword">new</span> Sha512Hash(<span class="hljs-string">"123"</span>, <span class="hljs-string">"sang"</span>, <span class="hljs-number">1024</span>);</span><br><span class="line">SimpleHash md5 = <span class="hljs-keyword">new</span> SimpleHash(<span class="hljs-string">"md5"</span>, <span class="hljs-string">"123"</span>, <span class="hljs-string">"sang"</span>, <span class="hljs-number">1024</span>);</span><br><span class="line">SimpleHash sha512 = <span class="hljs-keyword">new</span> SimpleHash(<span class="hljs-string">"sha-512"</span>, <span class="hljs-string">"123"</span>, <span class="hljs-string">"sang"</span>, <span class="hljs-number">1024</span>)</span><br></pre></td></tr></table></figure><p>然后我们首先将sha512生成的字符串放入数据库中，接下来我要配置一下我的jdbcRealm，因为我要指定我的盐是什么。在这里我的盐就是我的用户名，每个用户的用户名是不一样的，因此这里没法写死，在JdbcRealm中，系统提供了四种不同的SaltStyle，如下：</p><table><thead><tr><th style="text-align:left">SaltStyle</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left">NO_SALT</td><td>默认，密码不加盐</td></tr><tr><td style="text-align:left">CRYPT</td><td>密码是以Unix加密方式储存的</td></tr><tr><td style="text-align:left">COLUMN</td><td>salt是单独的一列储存在数据库中</td></tr><tr><td style="text-align:left">EXTERNAL</td><td>salt没有储存在数据库中，需要通过JdbcRealm.getSaltForUser(String)函数获取</td></tr></tbody></table><p>四种不同的SaltStyle对应了四种不同的密码处理方式，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">switch</span> (saltStyle) &#123;</span><br><span class="line"><span class="hljs-keyword">case</span> NO_SALT:</span><br><span class="line">    password = getPasswordForUser(conn, username)[<span class="hljs-number">0</span>];</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line"><span class="hljs-keyword">case</span> CRYPT:</span><br><span class="line">    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> separate password and hash from getPasswordForUser[0]</span></span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConfigurationException(<span class="hljs-string">"Not implemented yet"</span>);</span><br><span class="line">    <span class="hljs-comment">//break;</span></span><br><span class="line"><span class="hljs-keyword">case</span> COLUMN:</span><br><span class="line">    String[] queryResults = getPasswordForUser(conn, username);</span><br><span class="line">    password = queryResults[<span class="hljs-number">0</span>];</span><br><span class="line">    salt = queryResults[<span class="hljs-number">1</span>];</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line"><span class="hljs-keyword">case</span> EXTERNAL:</span><br><span class="line">    password = getPasswordForUser(conn, username)[<span class="hljs-number">0</span>];</span><br><span class="line">    salt = getSaltForUser(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在COLUMN这种情况下，SQL查询结果应该包含两列，第一列是密码，第二列是盐，这里默认执行的SQL在JdbcRealm一开头就定义好了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_SALTED_AUTHENTICATION_QUERY = <span class="hljs-string">"select password, password_salt from users where username = ?"</span>;</span><br></pre></td></tr></table></figure><p>即系统默认的盐是数据表中的password_salt提供的，但是我这里是username字段提供的，所以这里我一会要自定义这条SQL。自定义方式很简单，修改shiro.ini文件，添加如下两行：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdbcRealm.saltStyle=COLUMN</span><br><span class="line">jdbcRealm.authenticationQuery=select password,username from users where username=?</span><br></pre></td></tr></table></figure><p>首先设置saltStyle为COLUMN，然后重新定义authenticationQuery对应的SQL。注意返回列的顺序很重要，不能随意调整。如此之后，系统就会自动把username字段作为盐了。</p><p>不过，由于ini文件中不支持枚举，saltStyle的值实际上是一个枚举类型，所以我们在测试的时候，需要增加一个枚举转换器在我们的main方法中，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BeanUtilsBean.getInstance().getConvertUtils().register(<span class="hljs-keyword">new</span> AbstractConverter() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">convertToString</span><span class="hljs-params">(Object value)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> ((Enum) value).name();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">convertToType</span><span class="hljs-params">(Class type, Object value)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Enum.valueOf(type, value.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> Class <span class="hljs-title">getDefaultType</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, JdbcRealm.SaltStyle.class);</span><br></pre></td></tr></table></figure><p>当然，以后当我们将shiro和web项目整合之后，就不需要这个转换器了。</p><p>如此之后，我们就可以再次进行登录测试了，会发现没什么问题了。</p><h3 id="7-3-非JdbcRealm如何配置盐"><a href="#7-3-非JdbcRealm如何配置盐" class="headerlink" title="7.3 非JdbcRealm如何配置盐"></a>7.3 非JdbcRealm如何配置盐</h3><p>OK，刚刚是在JdbcRealm中配置了盐，如果没用JdbcRealm，而是自己定义的普通Realm，要怎么解决配置盐的问题？</p><p>首先要说明一点是，我们前面的文章在自定义Realm时都是通过实现Realm接口实现的，这种方式有一个缺陷，就是密码比对需要我们自己完成，一般在项目中，我们自定义Realm都是通过继承AuthenticatingRealm或者AuthorizingRealm，因为这两个方法中都重写了getAuthenticationInfo方法，而在getAuthenticationInfo方法中，调用doGetAuthenticationInfo方法获取登录用户，获取到之后，会调用assertCredentialsMatch方法进行密码比对，而我们直接实现Realm接口则没有这一步，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AuthenticationInfo <span class="hljs-title">getAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    AuthenticationInfo info = getCachedAuthenticationInfo(token);</span><br><span class="line">    <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">//调用doGetAuthenticationInfo获取info，这个doGetAuthenticationInfo是我们在自定义Realm中自己实现的</span></span><br><span class="line">        info = doGetAuthenticationInfo(token);</span><br><span class="line">        log.debug(<span class="hljs-string">"Looked up AuthenticationInfo [&#123;&#125;] from doGetAuthenticationInfo"</span>, info);</span><br><span class="line">        <span class="hljs-keyword">if</span> (token != <span class="hljs-keyword">null</span> &amp;&amp; info != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            cacheAuthenticationInfoIfPossible(token, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="hljs-string">"Using cached authentication info [&#123;&#125;] to perform credentials matching."</span>, info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">//获取到info之后，进行密码比对</span></span><br><span class="line">        assertCredentialsMatch(token, info);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="hljs-string">"No AuthenticationInfo found for submitted AuthenticationToken [&#123;&#125;].  Returning null."</span>, token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于上面所述的原因，这里我先继承AuthenticatingRealm，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthenticatingRealm</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"MyRealm"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> token <span class="hljs-keyword">instanceof</span> UsernamePasswordToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = token.getPrincipal().toString();</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"sang"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(<span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String dbPassword = <span class="hljs-string">"a593ccad1351a26cf6d91d5f0f24234c6a4da5cb63208fae56fda809732dcd519129acd74046a1f9c5992db8903f50ebf3c1091b3aaf67a05c82b7ee470d9e58"</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username, dbPassword, ByteSource.Util.bytes(username), getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个类，我说如下几点：</p><ol><li><p>用户名我这里还是手动判断了下，实际上这个地方要从数据库查询用户信息，如果查不到用户信息，则直接抛UnknownAccountException</p></li><li><p>返回的SimpleAuthenticationInfo中，第二个参数是密码，正常情况下，这个密码是从数据库中查询出来的，我这里直接写死了</p></li><li><p>第三个参数是盐值，这样构造好SimpleAuthenticationInfo之后返回，shiro会去判断用户输入的密码是否正确</p></li></ol><p>上面的核心步骤是第三步，系统去自动比较密码输入是否正确，在比对的过程中，需要首先对用户输入的密码进行加盐加密，既然加盐加密，就会涉及到credentialsMatcher，这里我们要用的credentialsMatcher实际上和在JdbcRealm中用的credentialsMatcher一样，只需要在配置文件中增加如下一行即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyRealm.credentialsMatcher=$sha512</span><br></pre></td></tr></table></figure><p>sha512和我们上文定义的一致，这里就不再重复说了。</p><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v7.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v7.zip</a></p><h2 id="8-Shiro中自定义带角色和权限的Realm"><a href="#8-Shiro中自定义带角色和权限的Realm" class="headerlink" title="8. Shiro中自定义带角色和权限的Realm"></a>8. Shiro中自定义带角色和权限的Realm</h2><p>密码加密加盐小伙伴们应该没有问题了，但是前面几篇文章又给我们带来了一个新的问题：我们前面IniRealm、JdbcRealm以及自定义的MyRealm，其中前两个我们都能实现用户认证以及授权，即既能管理用户登录，又能管理用户角色，而我们自定义的MyRealm，目前还只能实现登录，不能实现授权，本文我们就来看看自定义Realm如何实现授权。</p><h3 id="8-1-问题追踪"><a href="#8-1-问题追踪" class="headerlink" title="8.1 问题追踪"></a>8.1 问题追踪</h3><p>上篇文章我们没有实现自定义Realm的授权操作，但是这个并不影响我们调用hasRole方法去获取用户的权限，我在上文测试代码上的currentUser.hasRole上面打断点，通过层层追踪，我们发现最终来到了ModularRealmAuthorizer类的hasRole方法中，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasRole</span><span class="hljs-params">(PrincipalCollection principals, String roleIdentifier)</span> </span>&#123;</span><br><span class="line">    assertRealmsConfigured();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Realm realm : getRealms()) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!(realm <span class="hljs-keyword">instanceof</span> Authorizer)) <span class="hljs-keyword">continue</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (((Authorizer) realm).hasRole(principals, roleIdentifier)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在这里会遍历所有的realm，如果这个realm是Authorizer的实例，则会进行进一步的授权操作，如果不是Authorizer的实例，则直接跳过，而我们只有一个自定义的MyRealm继承自AuthenticatingRealm，很明显不是Authorizer的实例，所以这里必然返回false，授权失败，所以要解决授权问题，第一步，得先让我们的MyRealm成为Authorizer的实例。</p><h3 id="8-2-解决方案"><a href="#8-2-解决方案" class="headerlink" title="8.2 解决方案"></a>8.2 解决方案</h3><p>如下图是Authorizer的继承关系：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6ba2ff376345402cd6f31fb39f83d6a4.png" alt="p311"></p><p>小伙伴们看到，在Authorizer的实现类中有一个AuthorizingRealm，打开这个类，我们发现它的继承关系如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizingRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthenticatingRealm</span></span></span><br><span class="line"><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">Authorizer</span>, <span class="hljs-title">Initializable</span>, <span class="hljs-title">PermissionResolverAware</span>, <span class="hljs-title">RolePermissionResolverAware</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>我们发现，这个AuthorizingRealm不仅是Authorizer的实现类，同时也是我们上文所用的AuthenticatingRealm的实现类，既然AuthorizingRealm同时是这两个类的实现类，那么我把MyRealm的继承关系由AuthenticatingRealm改为AuthorizingRealm，肯定不会影响我上文的功能，修改之后的MyRealm如下(部分关键代码)：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = token.getPrincipal().toString();</span><br><span class="line">        <span class="hljs-keyword">if</span> (!<span class="hljs-string">"sang"</span>.equals(username)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(<span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String dbPassword = <span class="hljs-string">"a593ccad1351a26cf6d91d5f0f24234c6a4da5cb63208fae56fda809732dcd519129acd74046a1f9c5992db8903f50ebf3c1091b3aaf67a05c82b7ee470d9e58"</span>;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username, dbPassword, ByteSource.Util.bytes(username), getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; roles = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-string">"sang"</span>.equals(principals.getPrimaryPrincipal().toString())) &#123;</span><br><span class="line">            roles.add(<span class="hljs-string">"普通用户"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthorizationInfo(roles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了AuthorizingRealm之后，需要我们实现doGetAuthorizationInfo方法。在这个方法中，我们配置用户的权限。这里我为了方便，直接添加了普通用户这个权限，实际上，这里应该根据用户名去数据库里查询权限，查询方式不赘述。</p><p>通过源码追踪，我们发现最终授权会来到AuthorizingRealm类的如下两个方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasRole</span><span class="hljs-params">(PrincipalCollection principal, String roleIdentifier)</span> </span>&#123;</span><br><span class="line">    AuthorizationInfo info = getAuthorizationInfo(principal);</span><br><span class="line">    <span class="hljs-keyword">return</span> hasRole(roleIdentifier, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasRole</span><span class="hljs-params">(String roleIdentifier, AuthorizationInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> info != <span class="hljs-keyword">null</span> &amp;&amp; info.getRoles() != <span class="hljs-keyword">null</span> &amp;&amp; info.getRoles().contains(roleIdentifier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法的逻辑很简单，第一个方法中调用的getAuthorizationInfo方法会最终调用到我们自定义的doGetAuthorizationInfo方法，第二个hasRole方法接收的两个参数，第一个是用户申请的角色，第二个是用户具备的角色集，一个简单的contains函数就判断出用户是否具备某个角色了。</p><p>但是这个时候，用户只有角色，没有权限，我们可以对doGetAuthorizationInfo方法做进一步的完善，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; roles = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    Set&lt;String&gt; permiss = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-string">"sang"</span>.equals(principals.getPrimaryPrincipal().toString())) &#123;</span><br><span class="line">        roles.add(<span class="hljs-string">"普通用户"</span>);</span><br><span class="line">        permiss.add(<span class="hljs-string">"book:update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo(roles);</span><br><span class="line">    info.setStringPermissions(permiss);</span><br><span class="line">    <span class="hljs-keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，正常情况下，权限也应当是从数据库中查询得到的，我这里简化下。</p><p>那么这个角色是怎么验证的呢？追踪源码我们来到了AuthorizingRealm类的如下两个方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPermitted</span><span class="hljs-params">(PrincipalCollection principals, Permission permission)</span> </span>&#123;</span><br><span class="line">    AuthorizationInfo info = getAuthorizationInfo(principals);</span><br><span class="line">    <span class="hljs-keyword">return</span> isPermitted(permission, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//visibility changed from private to protected per SHIRO-332</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPermitted</span><span class="hljs-params">(Permission permission, AuthorizationInfo info)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Permission&gt; perms = getPermissions(info);</span><br><span class="line">    <span class="hljs-keyword">if</span> (perms != <span class="hljs-keyword">null</span> &amp;&amp; !perms.isEmpty()) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (Permission perm : perms) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (perm.implies(permission)) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个isPermitted方法中调用了getAuthorizationInfo方法，而getAuthorizationInfo方法最终会调用到我们自己定义的doGetAuthorizationInfo方法，即获取到用户的角色权限信息，然后在第二个方法中进行遍历判断，查看是否具备相应的权限，第二个isPermitted方法的第一个参数就是用户要申请的权限。</p><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v8.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v8.zip</a></p><h2 id="9-Shiro整合Spring"><a href="#9-Shiro整合Spring" class="headerlink" title="9. Shiro整合Spring"></a>9. Shiro整合Spring</h2><h3 id="9-1-Spring-amp-SpringMVC环境搭建"><a href="#9-1-Spring-amp-SpringMVC环境搭建" class="headerlink" title="9.1 Spring&amp;SpringMVC环境搭建"></a>9.1 Spring&amp;SpringMVC环境搭建</h3><p>Spring和SpringMVC环境的搭建，整体上来说，还是比较容易的，因为这个不是本文的重点，因此这里我不做详细介绍，小伙伴可以在文末下载源码查看Spring+SpringMVC环境的搭建。同时，由于MyBatis的整合相对要容易很多，这里为了降低项目复杂度，我也就先不引入MyBatis。</p><p>对于项目依赖，除了Spring、SpringMVC、Shiro相关的依赖，还需要加入Shiro和Spring整合的jar，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-整合Shiro"><a href="#9-2-整合Shiro" class="headerlink" title="9.2 整合Shiro"></a>9.2 整合Shiro</h3><p>搭建好Spring+SpringMVC环境之后，整合Shiro我们主要配置两个地方：</p><ol><li>web.xml中配置代理过滤器，如下：</li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>targetFilterLifecycle<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>shiroFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样之后，当DelegatingFilterProxy拦截到所有请求之后，都会委托给shiroFilter来处理，shiroFilter是我们第二步在Spring容器中配置的一个实例。</p><ol start="2"><li>配置Spring容器</li></ol><p>在Spring容器中至少有两个Bean需要我们配置，一个就是第一步中的shiroFilter，还有一个就是SecurityManager，完整配置如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"securityManager"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/login.jsp"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"successUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/success.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"unauthorizedUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/unauthorized.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            /**=authc</span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一个非常简单的配置，我们在以后的文章中还会继续完善它，关于这个配置我说如下几点：</p><ol><li><p>首先我们需要配置一个securityManager，到时候我们的realm要配置在这里。</p></li><li><p>还要配置一个名为shiroFilter的bean，这个名字要和web.xml中代理过滤器的名字一致。</p></li><li><p>shiroFilter中，loginUrl表示登录页面地址。</p></li><li><p>successUrl表示登录成功地址。</p></li><li><p>unauthorizedUrl表示授权失败地址。</p></li><li><p>filterChainDefinitions中配置的<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. authc实际上是一个过滤器，这个我们在后文还会再详细说到。</span><br><span class="line"></span><br><span class="line">8. 匹配符遵循Ant风格路径表达式,这里可以配置多个，匹配顺序从上往下匹配到了就不再匹配了。比如下面这个写法：</span><br></pre></td></tr></table></figure></p></li></ol><p>/a/b/*=anon<br>/a/**=authc<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">假设我的路径是/a/b/c那么就会匹配到第一个过滤器anon，而不会匹配到authc，所以这里的顺序很重要。</span><br><span class="line"></span><br><span class="line">OK，这些配置写完后，在webpap目录下创建对应的jsp文件，如下：</span><br><span class="line"></span><br><span class="line">![p312](https://img-blog.csdnimg.cn/img_convert/881d145a378233fac5eb1fc00c6fe8a4.png)</span><br><span class="line"></span><br><span class="line">此时，启动项目去浏览器中访问，无论我们访问什么地址，最后都会回到login.jsp页面，因为所有的页面（即使不存在的地址）都需要认证后才可以访问。</span><br><span class="line"></span><br><span class="line">本小节案例：https://github.com/lenve/shiroSamples/archive/refs/tags/v9.zip</span><br><span class="line"></span><br><span class="line">## 10. Shiro处理登录的三种方式</span><br><span class="line"></span><br><span class="line">### 10.1 准备工作</span><br><span class="line"></span><br><span class="line">很明显，不管是那种登录，都离不开数据库，这里数据库我采用我们前面的数据库，这里不做赘述(文末可以下载数据库脚本)，但是我这里需要首先配置JdbcRealm，在applicationContext.xml中首先配置数据源，如下：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">&lt;bean class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; id=&quot;dataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;db.username&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;db.password&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;db.url&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>有了数据源之后，接下来配置JdbcRealm，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.realm.jdbc.JdbcRealm"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"jdbcRealm"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"credentialsMatcher"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.authc.credential.HashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hashAlgorithmName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"sha-512"</span>/&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hashIterations"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1024"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"saltStyle"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"COLUMN"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"authenticationQuery"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"select password, username from users where username = ?"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JdbcRealm中这几个属性和我们本系列第七篇文章基本是一致的，首先我们配置了密码比对器为HashedCredentialsMatcher，相应的算法为sha512，密码加密迭代次数为1024次，然后我们配置了密码的盐从数据表的列中来，username列就是我们的盐，这些配置和前文都是一致的，不清楚的小伙伴可以参考我们本系列第七篇文章。</p><h3 id="10-2-自定义登录逻辑"><a href="#10-2-自定义登录逻辑" class="headerlink" title="10.2 自定义登录逻辑"></a>10.2 自定义登录逻辑</h3><p>自定义登录逻辑比较简单，首先我们把login.jsp页面进行简单改造：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>密码：<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"登录"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后创建我们的登录处理Controller，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">    UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        currentUser.login(token);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录成功我们就去success页面，登录失败就回到登录页面。做完这两步之后，我们还要修改shiroFilter中的filterChainDefinitions属性，要设置<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">&lt;bean class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot; id=&quot;shiroFilter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;loginUrl&quot; value=&quot;/login.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;successUrl&quot; value=&quot;/success.jsp&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            /login=anon</span><br><span class="line">            /**=authc</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>做完这些之后，就可以去login.jsp页面测试登录了。</p><p>上面中方式是我们自己写登录逻辑，shiro也给我们提供了两种不用自己写登录逻辑的登录方式，请继续往下看。</p><h3 id="10-3-基于HTTP的认证"><a href="#10-3-基于HTTP的认证" class="headerlink" title="10.3 基于HTTP的认证"></a>10.3 基于HTTP的认证</h3><p>shiro中也提供了基于http协议的认证，当然，这种认证也得有数据库的辅助，数据配置和前文一样，我们只需要修改一个配置即可，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            /**=authcBasic</span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个表示所有的页面都要经过基于http的认证。此时我们打开任意一个页面，认证方式如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/44eacd352b9f3fcfa96cb9a4d7eeb88c.png" alt="p313"></p><h3 id="10-4-表单登录"><a href="#10-4-表单登录" class="headerlink" title="10.4 表单登录"></a>10.4 表单登录</h3><p>表单登录和基于HTTP的登录类似，都是不需要我们自己写登录逻辑的登录，但是出错的逻辑还是要稍微处理下，首先修改shiroFilter：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shiroFilter"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"securityManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"loginUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/login"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"successUrl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/success.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">            /**=authc</span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置登录页面，也配置登录成功后的跳转页面，同时设置所有页面都要登录后才能访问。</p><p>配置登录页面请求，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest req, Model model)</span> </span>&#123;</span><br><span class="line">    String shiroLoginFailure = (String) req.getAttribute(<span class="hljs-string">"shiroLoginFailure"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (UnknownAccountException.class.getName().equals(shiroLoginFailure)) &#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"error"</span>, <span class="hljs-string">"账户不存在!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (IncorrectCredentialsException.class.getName().equals(shiroLoginFailure)) &#123;</span><br><span class="line">        model.addAttribute(<span class="hljs-string">"error"</span>, <span class="hljs-string">"密码不正确!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"login"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果登录失败，那么在request中会有一个shiroLoginFailure的属性中保存了登录失败的异常类名，通过判断这个类名，我们就可以知道是什么原因导致了登录失败。</p><p>OK，配置好这两步之后，就可以去登录页面测试了。</p><h3 id="10-5-注销登录"><a href="#10-5-注销登录" class="headerlink" title="10.5 注销登录"></a>10.5 注销登录</h3><p>注销登录比较简单，就一个过滤器，按如下方式配置：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">        /logout=logout</span><br><span class="line">        /**=authc</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过get请求访问<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">本小节有三个案例，下载地址如下：</span><br><span class="line"></span><br><span class="line">- https://github.com/lenve/shiroSamples/archive/refs/tags/v10.1.zip</span><br><span class="line">- https://github.com/lenve/shiroSamples/archive/refs/tags/v10.2.zip</span><br><span class="line">- https://github.com/lenve/shiroSamples/archive/refs/tags/v10.3.zip</span><br><span class="line"></span><br><span class="line">## 11. Shiro中的授权问题</span><br><span class="line"></span><br><span class="line">### 11.1 配置角色</span><br><span class="line"></span><br><span class="line">本文的案例在上文的基础上完成，因此Realm这一块我依然采用JdbcRealm，相关的授权就不必配置了。但是这里的数据库脚本有更新，小伙伴需要下载重新执行（https://github.com/lenve/shiroSamples/blob/v11/shiroDemo.sql）。</span><br><span class="line"></span><br><span class="line">先来介绍下目前数据库中用户的情况，数据库中有两个用户，sang具有admin的角色，同时具有```book:*```和```author:create```两个权限，lisi具有user的角色，同时具有```user:info```和```user:delete```两个权限。修改shiroFilter，如下：</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;bean class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot; id=&quot;shiroFilter&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;loginUrl&quot; value=&quot;/login&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;successUrl&quot; value=&quot;/success.jsp&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauthorized.jsp&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            /admin.jsp=authc,roles[admin]</span><br><span class="line">            /user.jsp=authc,roles[user]</span><br><span class="line">            /logout=logout</span><br><span class="line">            /**=authc</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>关于这里的配置，我说如下几点：</p><ol><li>unauthorizedUrl表示授权失败时展示的页面 </li><li>filterChainDefinitions中我们配置了admin.jsp页面必须登录后才能访问，同时登录的用户必须具有admin角色，user.jsp也是必须登录后才能访问，同时登录的用户必须具有user角色</li></ol><h3 id="11-2-测试"><a href="#11-2-测试" class="headerlink" title="11.2 测试"></a>11.2 测试</h3><p>测试时我们分别用sang/123和lisi/123进行登录，登录成功后分别访问user.jsp和admin.jsp就能看到效果。</p><h3 id="11-3-配置权限"><a href="#11-3-配置权限" class="headerlink" title="11.3 配置权限"></a>11.3 配置权限</h3><p>上面的方式是配置角色，但是还没有配置权限，要配置权限，首先要在jdbcRealm中添加允许权限信息的查询：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"permissionsLookupEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后配置下shiroFilter：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">        /admin.jsp=authc,roles[admin]</span><br><span class="line">        /user.jsp=authc,roles[user]</span><br><span class="line">        /userinfo.jsp=authc,perms[user:info]</span><br><span class="line">        /bookinfo.jsp=authc,perms[book:info]</span><br><span class="line">        /logout=logout</span><br><span class="line">        /**=authc</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里假设访问userinfo.jsp需要user:info权限，访问bookinfo.jsp需要book:info权限。</p><p>OK，做完这些之后就可以测试了，分别用sang/123和lisi/123进行登录，登录成功后分别访问bookinfo.jsp和userinfo.jsp就可以看到不同效果了。</p><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v11.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v11.zip</a></p><h2 id="12-Shiro中的JSP标签"><a href="#12-Shiro中的JSP标签" class="headerlink" title="12. Shiro中的JSP标签"></a>12. Shiro中的JSP标签</h2><h3 id="12-1-缘起"><a href="#12-1-缘起" class="headerlink" title="12.1 缘起"></a>12.1 缘起</h3><p>上篇文章中，我们在success.jsp中写了很多像下面这种超链接：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>登录成功！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/logout"</span>&gt;</span>注销<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/admin.jsp"</span>&gt;</span>admin.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/user.jsp"</span>&gt;</span>user.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/bookinfo.jsp"</span>&gt;</span>bookinfo.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/userinfo.jsp"</span>&gt;</span>userinfo.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是对于不同身份的用户，并不是每一个链接都是有效的，点击无效的链接会进入到未授权的页面，这样用户体验并不好，最好能够把不可达的链接自动隐藏起来，同时，我也希望能够方便获取当前登录用户的信息等，考虑到这些需求，我们来聊聊shiro中的jsp标签。</p><h3 id="12-2-标签介绍"><a href="#12-2-标签介绍" class="headerlink" title="12.2 标签介绍"></a>12.2 标签介绍</h3><p>shiro中的标签并不多，主要有如下几种：</p><ol><li>shiro:guest</li></ol><p>shiro:guest标签只有在当前未登录时显示里边的内容，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:guest&gt;</span><br><span class="line">    欢迎【游客】访问!</span><br><span class="line">&lt;/shiro:guest&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>shiro:user</li></ol><p>shiro:user是在用户登录之后显示该标签中的内容，无论是通过正常的登录还是通过Remember Me登录，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:user&gt;</span><br><span class="line">    欢迎【&lt;shiro:principal/&gt;】访问!</span><br><span class="line">&lt;/shiro:user&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>shiro:principal</li></ol><p>shiro:principal用来获取当前登录用户的信息，显示效果如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/636d4969a4043f7047ff43b2f0ffb79f.png" alt="p314"></p><p>4.shiro:authenticated</p><p>和shiro:user相比，shiro:authenticated的范围变小，当用户认证成功且不是通过Remember Me认证成功，这个标签中的内容才会显示出来：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:authenticated&gt;</span><br><span class="line">    用户【&lt;shiro:principal/&gt;】身份认证通过，不是通过Remember Me认证!</span><br><span class="line">&lt;/shiro:authenticated&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>shiro:notAuthenticated</li></ol><p>shiro:notAuthenticated也是在用户未认证的情况下显示内容，和shiro:guest不同的是，对于通过Remember Me方式进行的认证，shiro:guest不会显示内容，而shiro:notAuthenticated会显示内容(因为此时并不是游客，但是又确实未认证)，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:notAuthenticated&gt;</span><br><span class="line">    用户未进行身份认证</span><br><span class="line">&lt;/shiro:notAuthenticated&gt;</span><br></pre></td></tr></table></figure><ol start="6"><li>shiro:lacksRole</li></ol><p>当用户不具备某个角色时候，显示内容，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:lacksRole name=&quot;admin&quot;&gt;</span><br><span class="line">    用户不具备admin角色</span><br><span class="line">&lt;/shiro:lacksRole&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>shiro:lacksPermission</li></ol><p>当用户不具备某个权限时显示内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:lacksPermission name=&quot;book:info&quot;&gt;</span><br><span class="line">    用户不具备book:info权限</span><br><span class="line">&lt;/shiro:lacksPermission&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li>shiro:hasRole</li></ol><p>当用户具备某个角色时显示的内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&lt;a href=&quot;/admin.jsp&quot;&gt;admin.jsp&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br></pre></td></tr></table></figure><ol start="9"><li>shiro:hasAnyRoles</li></ol><p>当用户具备多个角色中的某一个时显示的内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasAnyRoles name=&quot;user,aaa&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&lt;a href=&quot;/user.jsp&quot;&gt;user.jsp&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/shiro:hasAnyRoles&gt;</span><br></pre></td></tr></table></figure><ol start="10"><li>shiro:hasPermission</li></ol><p>当用户具备某一个权限时显示的内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasPermission name=&quot;book:info&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&lt;a href=&quot;/bookinfo.jsp&quot;&gt;bookinfo.jsp&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/shiro:hasPermission&gt;</span><br></pre></td></tr></table></figure><p>本小节案例下载：<a href="https://github.com/lenve/shiroSamples/archive/refs/tags/v12.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/refs/tags/v12.zip</a></p><h2 id="13-Shiro-中的缓存机制"><a href="#13-Shiro-中的缓存机制" class="headerlink" title="13.Shiro 中的缓存机制"></a>13.Shiro 中的缓存机制</h2><h3 id="13-1-添加依赖"><a href="#13-1-添加依赖" class="headerlink" title="13.1 添加依赖"></a>13.1 添加依赖</h3><p>使用缓存，首先需要添加相关依赖，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shiro<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shiro-ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="13-2-添加配置文件"><a href="#13-2-添加配置文件" class="headerlink" title="13.2 添加配置文件"></a>13.2 添加配置文件</h3><p>ehcache的配置文件主要参考官方的配置，在resources目录下创建ehcache.xml文件，内容如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">ehcache</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">diskStore</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"java.io.tmpdir/shiro-spring-sample"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">defaultCache</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">timeToIdleSeconds</span>=<span class="hljs-string">"120"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"120"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"120"</span></span></span><br><span class="line"><span class="hljs-tag">    /&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"shiro-activeSessionCache"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"10000"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">eternal</span>=<span class="hljs-string">"true"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"true"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">diskPersistent</span>=<span class="hljs-string">"true"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">diskExpiryThreadIntervalSeconds</span>=<span class="hljs-string">"600"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"org.apache.shiro.realm.SimpleAccountRealm.authorization"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">maxElementsInMemory</span>=<span class="hljs-string">"100"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">eternal</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">timeToLiveSeconds</span>=<span class="hljs-string">"600"</span></span></span><br><span class="line"><span class="hljs-tag">           <span class="hljs-attr">overflowToDisk</span>=<span class="hljs-string">"false"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些都是ehcache缓存中常规的配置，含义我就不一一解释了，文末下载源码有注释。</p><h3 id="13-3-缓存配置"><a href="#13-3-缓存配置" class="headerlink" title="13.3 缓存配置"></a>13.3 缓存配置</h3><p>接下来我们只需要在applicationContext中简单配置下缓存即可，配置方式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cacheManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheManagerConfigFile"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"classpath:ehcache.xml"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"securityManager"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"realm"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"jdbcRealm"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheManager"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"cacheManager"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先配置EhCacheManager类，指定缓存位置，然后在DefaultWebSecurityManager中引入cacheManager即可，如此之后，我们的缓存就应用上了。</p><h3 id="13-4-测试"><a href="#13-4-测试" class="headerlink" title="13.4 测试"></a>13.4 测试</h3><p>由于我这里使用了JdbcRealm，如果使用了自定义Realm那么可以通过打日志看是否使用了缓存，使用了JdbcRealm之后，我们可以通过打断点来查看是否应用了缓存，比如我执行如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subject.checkRole(<span class="hljs-string">"admin"</span>);</span><br><span class="line">subject.checkPermission(<span class="hljs-string">"book:info"</span>);</span><br></pre></td></tr></table></figure><p>通过断点跟踪，发现最终会来到AuthorizingRealm的getAuthorizationInfo方法中，在该方法中，首先会去缓存中检查数据，如果缓存中有数据，则不会执行doGetAuthorizationInfo方法（数据库操作就在doGetAuthorizationInfo方法中进行），如果缓存中没有数据，则会执行doGetAuthorizationInfo方法，并且在执行成功后将数据保存到缓存中（前提是配置了缓存，cache不为null），此时我们通过断点，发现执行了缓存而没有查询数据库中的数据，部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">getAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">    AuthorizationInfo info = <span class="hljs-keyword">null</span>;</span><br><span class="line">    Cache&lt;Object, AuthorizationInfo&gt; cache = getAvailableAuthorizationCache();</span><br><span class="line">    <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">        info = cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        info = doGetAuthorizationInfo(principals);</span><br><span class="line">        <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span> &amp;&amp; cache != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            Object key = getAuthorizationCacheKey(principals);</span><br><span class="line">            cache.put(key, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，整体来说shiro中的缓存配置还是非常简单的。</p><p>That’s all.</p><p>本小节案例下载地址：<a href="https://github.com/lenve/shiroSamples/archive/v13.zip" target="_blank" rel="noopener">https://github.com/lenve/shiroSamples/archive/v13.zip</a></p><p>待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和大家分享一个松哥原创的 Shiro 教程吧，还没写完，先整一部分，剩下的敬请期待。&lt;/p&gt;
&lt;h2 id=&quot;1-Shiro简介&quot;&gt;&lt;a href=&quot;#1-Shiro简介&quot; class=&quot;headerlink&quot; title=&quot;1.Shiro简介&quot;&gt;&lt;/a&gt;1.Shiro简介&lt;/h2&gt;&lt;p&gt;Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架具有直观、易用等特性，同时也能提供健壮的安全性，虽然它的功能不如SpringSecurity那么强大，但是在普通的项目中也够用了。&lt;/p&gt;
    
    </summary>
    
      <category term="Shiro" scheme="http://www.javaboy.org/categories/Shiro/"/>
    
    
      <category term="Shiro" scheme="http://www.javaboy.org/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中这个默认视图名有点意思，看懂直呼内行内行！</title>
    <link href="http://www.javaboy.org/2021/0407/springmvc-default-viewname.html"/>
    <id>http://www.javaboy.org/2021/0407/springmvc-default-viewname.html</id>
    <published>2021-04-07T08:20:37.000Z</published>
    <updated>2021-04-07T08:21:58.081Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>在 Spring Boot 项目中，有的时候我们想返回一段 JSON，结果却忘了写 <code>@ResponseBody</code> 注解，像下面这样：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/01"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"01"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候当项目跑起来，肯定会报错，具体报什么错，则要看用的什么视图解析器，如果用了 Freemarker，你可能会看到如下错误：</p><p><img src="http://img.itboyhub.com/2021/02/20210325111006.png" alt></p><p>这个错误是说陷入到循环调用中了。</p><p>如果用了 Thymeleaf，你可能会看到如下错误：</p><p><img src="http://img.itboyhub.com/2021/02/20210325111132.png" alt></p><p>这个是说一个名叫 01 的视图不存在。</p><p>我只是少加了一个 <code>@ResponseBody</code> 注解而已，为什么用不同的视图解析器会报不同的错误？并且这些错误实在看不出和 <code>@ResponseBody</code> 注解有什么关联。</p><p>松哥今天就通过源码分析，来和大家把这个问题讲清楚。</p><h2 id="1-方法入口"><a href="#1-方法入口" class="headerlink" title="1.方法入口"></a>1.方法入口</h2><p>前面松哥刚刚和大家分享了 DispatcherServlet 的源码，并且和大家细致分析了 doDispatch 方法的执行步骤，还没看的小伙伴可以先看看：</p><ul><li><a href="https://mp.weixin.qq.com/s/F0QZ-Ukgtn3oC6a4loM9Vg" target="_blank" rel="noopener">SpringMVC 源码分析之 DispatcherServlet</a></li></ul><p>在这篇文章中，有一个小小细节，就是在 doDispatch 方法中，有如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applyDefaultViewName(processedRequest, mv);</span><br></pre></td></tr></table></figure><p>当这段代码执行的时候，接口方法已经通过反射调用完成了，并且将返回值封装成了一个 ModelAndView 对象（如果接口方法用到了 <code>@ResponseBody</code> 注解，则此时拿到的 ModelAndView 对象为 null），但是这个时候的 ModelAndView 对象还没有渲染，此时会调用 applyDefaultViewName 方法去判断返回的 ModelAndView 对象中有没有 view，如果没有，则给出一个默认的视图名。</p><p>这行代码就是切入点，接下来我们就来分析一下 applyDefaultViewName 方法。</p><h2 id="2-applyDefaultViewName"><a href="#2-applyDefaultViewName" class="headerlink" title="2.applyDefaultViewName"></a>2.applyDefaultViewName</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyDefaultViewName</span><span class="hljs-params">(HttpServletRequest request, @Nullable ModelAndView mv)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (mv != <span class="hljs-keyword">null</span> &amp;&amp; !mv.hasView()) &#123;</span><br><span class="line">String defaultViewName = getDefaultViewName(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (defaultViewName != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">mv.setViewName(defaultViewName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里的判断逻辑很简单，首先检查 mv 是否为 null（如果用户添加了 <code>@ResponseBody</code> 注解，mv 就为 null），然后去判断 mv 中是否包含视图，如果不包含视图，则调用 getDefaultViewName 方法去获取默认的视图名，并将获取到的默认视图名交给 mv。</p><h2 id="3-getDefaultViewName"><a href="#3-getDefaultViewName" class="headerlink" title="3.getDefaultViewName"></a>3.getDefaultViewName</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">getDefaultViewName</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.viewNameTranslator != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">this</span>.viewNameTranslator.getViewName(request) : <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个新的组件 viewNameTranslator，如果 viewNameTranslator 不为 null，则调用其 getViewName 方法获取默认的视图名。</p><p>viewNameTranslator 其实就是 RequestToViewNameTranslator，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RequestToViewNameTranslator</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getViewName</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口很简单，里边就一个方法 getViewName 方法来返回视图名称。在 SpringMVC 中，RequestToViewNameTranslator 接口只有一个默认的实现类 DefaultRequestToViewNameTranslator，我们来看下实现类中的 getViewName 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getViewName</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String path = ServletRequestPathUtils.getCachedPathValue(request);</span><br><span class="line"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.prefix + transformPath(path) + <span class="hljs-keyword">this</span>.suffix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">transformPath</span><span class="hljs-params">(String lookupPath)</span> </span>&#123;</span><br><span class="line">String path = lookupPath;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stripLeadingSlash &amp;&amp; path.startsWith(SLASH)) &#123;</span><br><span class="line">path = path.substring(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stripTrailingSlash &amp;&amp; path.endsWith(SLASH)) &#123;</span><br><span class="line">path = path.substring(<span class="hljs-number">0</span>, path.length() - <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stripExtension) &#123;</span><br><span class="line">path = StringUtils.stripFilenameExtension(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!SLASH.equals(<span class="hljs-keyword">this</span>.separator)) &#123;</span><br><span class="line">path = StringUtils.replace(path, SLASH, <span class="hljs-keyword">this</span>.separator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getViewName 方法中，首先提取出来当前请求路径，如果请求地址是 <code>http://localhost:8080/01</code>，那么这里提取出来的路径就是 <code>/01</code>，然后通过 transformPath 方法对路径进行处理，再分别加上前后缀后返回，默认的前后缀都是空字符串（如有需要，也可以自行配置）。</p><p>transformPath 则主要干了如下几件事：</p><ol><li>去掉路径开始的 <code>/</code>。</li><li>去掉路径结尾的 <code>/</code>。</li><li>如果请求路径有扩展名，则去掉扩展名，例如请求路径是 <code>/01.txt</code>，经过这一步处理后，就变成了 <code>/01</code>。</li><li>如果 separator 与 SLASH 不同，则替换原来的分隔符（默认是相同的）。</li></ol><p>好了，经过这一波处理后，正常情况下，我们就拿到了一个新的视图名，这个新的视图名就是你的请求路径。</p><p>例如请求路径是 <code>http://localhost:8080/01</code>，那么获取到的默认视图名就是 <code>01</code>。</p><p>现在大家就知道了，在没有写 <code>@ResponseBody</code> 的情况下，SpringMVC 会自动提取出一个默认的视图名，并且根据这个视图名去查找视图。</p><h2 id="4-问题分析"><a href="#4-问题分析" class="headerlink" title="4.问题分析"></a>4.问题分析</h2><p>要搞清楚这个问题，需要大家对视图解析器有一定了解，如果还不了解，可以先看看松哥之前的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/rn-6QyuYIsM_P5b4B1OIrg" target="_blank" rel="noopener">SpringMVC 九大组件之 ViewResolver 深入分析</a></li><li><a href="https://mp.weixin.qq.com/s/jr6vXw48ackqoeF7FR5pcw" target="_blank" rel="noopener">SpringMVC 中如何同时存在多个视图解析器</a></li></ul><p>看完视图解析器的分析之后，接下来的内容就很好理解了。</p><h3 id="4-1-Freemarker"><a href="#4-1-Freemarker" class="headerlink" title="4.1 Freemarker"></a>4.1 Freemarker</h3><p>先来看使用了 Freemarker 后为什么报循环调用的错。</p><p>根据前面两篇文章的分析，现在我们在 Spring Boot 中默认使用的视图解析器是 ContentNegotiatingViewResolver，在这个视图解析器中会首先选出所有候选的 View，由于我们的代码中并不存在一个名为 01 的 Freemarker 视图（如果刚好存在一个名为 01 的 Freemarker 视图就不会报错了，就直接将该视图展示出来了），而 FreeMarkerViewResolver 的父类 UrlBasedViewResolver 中的 loadView 方法在加载视图的时候，会去检查视图是否存在，结果发现视图吧不存在，导致最终返回 null。所以当 01 这个视图不存在时，最终负责处理该视图的并不是 FreeMarkerViewResolver，而是否则兜底的 InternalResourceViewResolver，该视图解析器最终构建出来的视图就是 InternalResourceView。</p><p>InternalResourceView 在最终渲染之前，会有一个预处理，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">prepareForRendering</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">String path = getUrl();</span><br><span class="line">Assert.state(path != <span class="hljs-keyword">null</span>, <span class="hljs-string">"'url' not set"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.preventDispatchLoop) &#123;</span><br><span class="line">String uri = request.getRequestURI();</span><br><span class="line"><span class="hljs-keyword">if</span> (path.startsWith(<span class="hljs-string">"/"</span>) ? uri.equals(path) : uri.equals(StringUtils.applyRelativePath(uri, path))) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Circular view path ["</span> + path + <span class="hljs-string">"]: would dispatch back "</span> +</span><br><span class="line"><span class="hljs-string">"to the current handler URL ["</span> + uri + <span class="hljs-string">"] again. Check your ViewResolver setup! "</span> +</span><br><span class="line"><span class="hljs-string">"(Hint: This may be the result of an unspecified view, due to default view name generation.)"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方的 getUrl 参数是在 buildView 方法中设置的（具体参见：<a href="https://mp.weixin.qq.com/s/rn-6QyuYIsM_P5b4B1OIrg" target="_blank" rel="noopener">SpringMVC 九大组件之 ViewResolver 深入分析</a>），它返回的视图的完整路径名，也就是 <code>prefix + viewName + suffix</code>，如果这个路径和当前请求路径一致，就抛出异常，抛出的异常就是我们一开始截图中看到的异常（其实异常中也说了，这个问题可能是由于自动生成 viewName 导致的）。</p><p>这就是为什么当我们使用 Freemarker 依赖时报循环请求的异常。</p><h3 id="4-2-Thymeleaf"><a href="#4-2-Thymeleaf" class="headerlink" title="4.2 Thymeleaf"></a>4.2 Thymeleaf</h3><p>再来看 Thymeleaf，使用 Thymeleaf 时报的异常是模版不存在。</p><p>首先我们找到异常抛出的位置是在 TemplateManager#resolveTemplate 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TemplateResolution <span class="hljs-title">resolveTemplate</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> IEngineConfiguration configuration,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> String ownerTemplate,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> String template,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; templateResolutionAttributes,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> failIfNotExists)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ITemplateResolver templateResolver : configuration.getTemplateResolvers()) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> TemplateResolution templateResolution =</span><br><span class="line">                templateResolver.resolveTemplate(configuration, ownerTemplate, template, templateResolutionAttributes);</span><br><span class="line">        <span class="hljs-keyword">if</span> (templateResolution != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> templateResolution;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!failIfNotExists) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TemplateInputException(</span><br><span class="line">            <span class="hljs-string">"Error resolving template ["</span> + template + <span class="hljs-string">"], "</span> +</span><br><span class="line">            <span class="hljs-string">"template might not exist or might not be accessible by "</span> +</span><br><span class="line">            <span class="hljs-string">"any of the configured Template Resolvers"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法在执行的过程中如果没能提前返回，最终就会抛出异常，抛出的异常也就是我们在控制台所看到的异常。执行到这一步的原因是前面获取到的 templateResolution 为 null，并且 failIfNotExists 参数为 true，failIfNotExists 参数在调用的时候固定传入，这个没啥好说的，问题的核心在于获取到的 templateResolution 是否为 null。</p><p>templateResolution 则是在 AbstractTemplateResolver#resolveTemplate 方法中获取到的，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> TemplateResolution <span class="hljs-title">resolveTemplate</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> IEngineConfiguration configuration,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> String ownerTemplate, <span class="hljs-keyword">final</span> String template,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; templateResolutionAttributes)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!computeResolvable(configuration, ownerTemplate, template, templateResolutionAttributes)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">final</span> ITemplateResource templateResource = computeTemplateResource(configuration, ownerTemplate, template, templateResolutionAttributes);</span><br><span class="line">    <span class="hljs-keyword">if</span> (templateResource == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.checkExistence &amp;&amp; !templateResource.exists()) &#123; <span class="hljs-comment">// will only check if flag set to true</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TemplateResolution(</span><br><span class="line">            templateResource,</span><br><span class="line">            <span class="hljs-keyword">this</span>.checkExistence,</span><br><span class="line">            computeTemplateMode(configuration, ownerTemplate, template, templateResolutionAttributes),</span><br><span class="line">            <span class="hljs-keyword">this</span>.useDecoupledLogic,</span><br><span class="line">            computeValidity(configuration, ownerTemplate, template, templateResolutionAttributes));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在拿到 templateResource 之后，会调用 <code>templateResource.exists()</code> 方法判断资源是否存在，也就是相应的模版文件是否存在，如果不存在就会返回 null，进而导致上一个方法抛出异常。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天主要和小伙伴们分享了一下 SpringMVC 中默认视图名的问题，不知道大家有没有 GET 到呢～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在 Spring Boot 项目中，有的时候我们想返回一段 JSON，结果却忘了写 &lt;code&gt;@ResponseBody&lt;/code&gt; 注解，像下面这样：&lt;/p&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://www.javaboy.org/categories/SSM/"/>
    
    
      <category term="SpringMVC" scheme="http://www.javaboy.org/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="http://www.javaboy.org/tags/SSM/"/>
    
  </entry>
  
</feed>
