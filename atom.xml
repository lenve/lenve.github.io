<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2019-10-16T11:58:14.400Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微人事 star 数超 10k，如何打造一个 star 数超 10k 的开源项目</title>
    <link href="http://www.javaboy.org/2019/1016/vhr.html"/>
    <id>http://www.javaboy.org/2019/1016/vhr.html</id>
    <published>2019-10-16T11:51:55.000Z</published>
    <updated>2019-10-16T11:58:14.400Z</updated>
    
    <content type="html"><![CDATA[<p>看了下，微人事(<a href="https://github.com/lenve/vhr)项目" target="_blank" rel="noopener">https://github.com/lenve/vhr)项目</a> star 数超 10k 啦，松哥第一个 star 数过万的开源项目就这样诞生了。</p><a id="more"></a><p><img src="http://www.javaboy.org/images/other/76-1.png" alt></p><p>两年前差不多就是现在这个时候，松哥所在的公司业绩下滑严重，关门倒闭已成定局，很多同事在谋划的新的出路，松哥则被公司留下来善后，在一段并不太忙碌的日子里，做了两个 Spring Boot + Vue 的前后端分离开源项目，以期能给自己来年找工作增加一点筹码，没想到这两个项目后来受到很多关注，也帮助了很多人。有不少小伙伴在公司使用微人事项目做脚手架开发项目，也有国内 top20 的高校研究生借鉴微人事做毕设，我自己也因此收到一些大厂的橄榄枝，可以说还是收获满满。</p><p>关于这个项目诞生的故事，松哥之前写过一篇文章，感兴趣的小伙伴可以看看：</p><ul><li><a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a></li></ul><p>今天，我想和小伙伴们聊聊如何从零开始打造一个 star 数过万的开源项目。松哥把这些经验总结为三点：</p><ul><li>文档详细</li><li>项目有料</li><li>适当宣传</li></ul><p>这些经验不是什么惊世骇俗的大道理，都很普通，关键在于执行。</p><h2 id="1-文档详细"><a href="#1-文档详细" class="headerlink" title="1. 文档详细"></a>1. 文档详细</h2><p>其实在做微人事和 V 部落之前，松哥在 GitHub 上已经做过多个开源项目了，比较有意思的一个是一个 Android 上的自定义控件，我做了一个歌词展示的控件，这个控件引入到自己的项目中以后，可以根据当前歌曲的播放进度动态滚动歌词，效果如如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/GvtDGKK4uYlK2k39ibibZ1LEdWv7KAJHV6mHbEKMgFQTZ0qWEahmickvR3La2b8qUhiacm1PHnM301RIxw6oV307WQ/0?wx_fmt=gif" alt></p><p>还有一个比较好玩的就是 Android 上自动抢红包的 App。不过这些开源工具和项目最终都石沉大海了。</p><p>究其原因，我觉得是自己对待这些项目不够认真，项目开源之后基本上都没有再继续维护了，一个项目提交次数一般都是个位数，项目做完之后，写一篇博客介绍下就算完事了。一个自己都不怎么重视的项目，其实很难引起别人的重视。</p><p>所以在 V 部落和微人事中，我就吸取教训，尽量把项目的文档写的详细一些，让不懂前后端分离开发的小伙伴看到我写的开发文档后，就能够快速理清项目的思路。就这样，我每写一个功能点，就写一篇技术文档，微人事项目前前后后一共写了 30 多篇文档：</p><p><img src="http://www.javaboy.org/images/other/76-2.png" alt></p><p>同时我考虑到很多小伙伴第一次接触到这个项目，一个庞然大物不好处理，因此我在每一次项目提交之前，都会对项目打一个 tag，这样大家通过 <code>git clone</code> 命令获取到项目之后，就可以通过 tag 非常方便的定位到项目的任意时刻，例如只想看登录设计的，可以根据文档介绍回到 v20180107 这个版本：</p><p><img src="http://www.javaboy.org/images/other/76-3.png" alt></p><p>小伙伴也可以点击 GitHub 上的 release 下载不同时期的项目。我一开始担心有的小伙伴不熟悉 Git 上的 tag 操作，还针对此写了个教程，就是上面文档的第 17 篇。</p><p>可以说，这个项目我从头到尾考虑了很多小伙伴们可能遇到的问题，不是自嗨，确实是希望能够带着小伙伴们一起飞。</p><p>这么详细的文档当然也得到了小伙伴和一些平台的认可，项目刚刚发布的时候，也就是 2018 年年初的时候，慕课网在它的官方知乎账号、微博账号上都有推过我的介绍项目的文章，当时这个项目就受到了很多小伙伴的关注，收获了不少 star，小伙伴们的关注也鼓励我继续把这个项目向前推进。</p><p>这是我介绍的第一点经验，文档详细。</p><h2 id="2-项目有料"><a href="#2-项目有料" class="headerlink" title="2. 项目有料"></a>2. 项目有料</h2><p>项目有料，也就是这个项目对大家而言是有价值的，能够真正帮到大家。</p><p>很多小伙伴看到微人事会觉得奇怪，这个项目还有一些功能没有实现，怎么就有这么多人关注呢？其实原因很简单，这个项目的价值不在于它的业务，而在于它解决了很多小伙伴在前后端分离开发中遇到的问题，这也是我做这个项目的初衷之一。</p><p>作为一个 Java 攻城狮，我非常明白很多小伙伴去接触 Vue、接触 Nodejs、接触 SPA 以及接触前端工程化这些概念时所面临的困惑，因为这些困惑我也曾经遇到过。</p><p>例如前后端分离后，开发环境下前后端如何进行数据交互、权限管理怎么做、文件上传怎么做、项目怎么部署等等，事无巨细，我觉得小伙伴们可能会困惑的地方，我在微人事中直接用代码做出样例，然后再辅以详细的文字解释，这样对于大部分小伙伴而言，都能够快速理解这个项目了。</p><p>这个项目建立之初，一开始就定位是一个学习项目，目的就是帮助大家建立前后端分离开发知识体系，搞定前后端分离开发中常见的坑，<strong>因此，一旦将项目的框架搭建成功，大家理解了前后端分离架构中的各个细节，剩下的业务不过是堆代码，技术上已经没有挑战了，这也是这个项目最近一段时间更新慢的原因。</strong></p><p>这是我和大家分享的第二点经验，项目要有价值。</p><h2 id="3-适当宣传"><a href="#3-适当宣传" class="headerlink" title="3. 适当宣传"></a>3. 适当宣传</h2><p>微人事和 V 部落刚刚上线的时候，我的相关文章被慕课网猛推过几次，当时就让微人事受到了比较多的关注，印象中，大概不到一个月的时间，star 数就超过 1k 了。</p><p>由于文档比较详细，很多大佬在整理相关资料的时候都会加上微人事项目，很多小伙伴可能见过标题类似下面这样的文章：</p><ul><li>13个优秀的 Spring Boot 学习项目</li><li>开源的13个Spring Boot 优秀学习项目！</li><li>六月份 GitHub 上最受欢迎的开源项目</li><li>七月份 GitHub 上最受欢迎的开源项目</li></ul><p>….</p><p>这一类的文章大部分都会收录微人事项目，进而将微人事项目曝光给更多小伙伴去学习。</p><p>今年七月份，有感于 1 年前公司倒闭时的无助，松哥写了一篇文章介绍了微人事项目的诞生过程：</p><ul><li><a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a></li></ul><p>没想到这篇文章被很多大佬转发，单单在知乎上这篇文章的阅读量就超过 12w，那一段时间，微人事项目也被很多有需要的小伙伴关注到了。</p><p>宣传这一块，我的经验是如果项目确实帮助到了很多小伙伴，对很多人而言有价值，你会发现平台，一些有影响力的技术牛人会自然的帮你推。<strong>所以，我还是建议将重心放在项目上。所谓家有梧桐树，引得凤凰来。</strong></p><p>这是我介绍的第三点经验，适当宣传。</p><p>好了，一点点不太成熟的经验分享给小伙伴们，希望能帮到大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了下，微人事(&lt;a href=&quot;https://github.com/lenve/vhr)项目&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lenve/vhr)项目&lt;/a&gt; star 数超 10k 啦，松哥第一个 star 数过万的开源项目就这样诞生了。&lt;/p&gt;
    
    </summary>
    
      <category term="vhr" scheme="http://www.javaboy.org/categories/vhr/"/>
    
    
      <category term="微人事" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E4%BA%BA%E4%BA%8B/"/>
    
      <category term="vhr" scheme="http://www.javaboy.org/tags/vhr/"/>
    
  </entry>
  
  <entry>
    <title>原创的离线版 Redis 教程，给力！</title>
    <link href="http://www.javaboy.org/2019/1016/redis-guide.html"/>
    <id>http://www.javaboy.org/2019/1016/redis-guide.html</id>
    <published>2019-10-16T11:47:12.000Z</published>
    <updated>2019-10-16T12:04:41.959Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，你没看错，松哥又给大家送干货来了。这次是可以离线阅读的 PDF 版教程哦。</p><a id="more"></a><p>之前一直有小伙伴问我有没有 Redis 的电子书，老实说，有是有，但是公开给大家分享，其实有一点点风险，毕竟这都是有版权的东西，特别是松哥自己写书之后，深知作者的不易。</p><blockquote><p>一般情况下，出版社给作者的稿酬是 8%，一本售价 ￥70 的书，到作者手里就是 ￥5.6。</p></blockquote><p>不过松哥今天要分享的资源，不牵涉任何版权问题，因为是我一个字一个字码出来的，我要和大家堂堂正正的分享这个资源。</p><p>这个就是松哥自己码出来的 4w 余字的 Redis 教程。其实这个教程发布有一段时间了，只是一直没有电子版的，有不少小伙伴希望我能把这些教程整理成电子版的，包括以前写的 MongoDB、Git、Spring Cloud 以及今年一直在持续更新的 Spring Boot，大家有需求，松哥当然就要行动，于是前两天费了一番功夫，把 md 转成 word ，然后整理了下做成了 pdf，这样大家以后在没有网络的环境下也可以学习了。</p><p>先来看看目录吧：</p><p><img src="http://www.javaboy.org/images/other/73-1.png" alt><br><img src="http://www.javaboy.org/images/other/73-2.png" alt><br><img src="http://www.javaboy.org/images/other/73-3.png" alt><br><img src="http://www.javaboy.org/images/other/73-4.png" alt><br><img src="http://www.javaboy.org/images/other/73-5.png" alt></p><p>这个教程从 Redis 的安装开始，到基本数据类型操作、数据持久化、主从复制、集群搭建直到最后的用 Java 操作 Redis ，可以说覆盖到了 Redis 常见的各种用法，当然还有更多的实际项目中 Redis 的用法，大家可以留意公众号的内容，这些我还会继续更新。</p><p>好了，资源我已经上传到百度云盘了，大家在公众号后台回复 <code>redis</code> 就可以获取到下载链接。如果这个资料帮助到你了，也欢迎分享给更多的小伙伴哦。</p><p>未来，我还会整理更多的电子版出来，包括 Spring Boot 系列。请小伙伴们留意公众号消息哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，你没看错，松哥又给大家送干货来了。这次是可以离线阅读的 PDF 版教程哦。&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="http://www.javaboy.org/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.javaboy.org/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离开发中动态菜单的两种实现方案</title>
    <link href="http://www.javaboy.org/2019/1016/vue-router.html"/>
    <id>http://www.javaboy.org/2019/1016/vue-router.html</id>
    <published>2019-10-16T11:44:46.000Z</published>
    <updated>2019-10-16T12:05:54.798Z</updated>
    
    <content type="html"><![CDATA[<p>关于前后端分离开发中的权限处理问题，松哥之前写过一篇文章和大家聊这个问题：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/5GsOO4QK9AnR0K6FdZixOw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，权限管理的一点思路</a></li></ul><p>但是最近有小伙伴在学习微人事项目时，对动态菜单这一块还是有疑问（即不同用户登录成功后会看到不同的菜单项），因此松哥打算再来写一篇文章和大家聊一聊前后端分离开发中的动态菜单问题。</p><h2 id="1-一个原则"><a href="#1-一个原则" class="headerlink" title="1. 一个原则"></a>1. 一个原则</h2><p>做权限管理，一个核心思想就是后端做权限控制，前端做的所有工作都只是为了提高用户体验，我们不能依靠前端展示或者隐藏一个按钮来实现权限控制，这样肯定是不安全的。</p><p>就像用户注册时需要输入邮箱地址，前端校验之后，后端还是要校验，两个校验目的不同，前端校验是为了提高响应速度，优化用户体验，后端校验则是为了确保数据完整性。权限管理也是如此，前端按钮的<code>展示/隐藏</code>都只是为了提高用户体验，真正的权限管理需要后端来实现。</p><p>这是非常重要的一点，做前后端分离开发中的权限管理，我们首先要建立上面这样的思考框架，然后在这样的框架下，去考虑其他问题。</p><p>因此，下文我会和大家分享两种方式实现动态菜单，这两种方式仅仅只是探讨如何更好的给用户展示菜单，而不是探讨权限管理，因为权限管理是在后端完成的，也必须在后端完成。</p><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h2><p>一旦建立起这样的思考框架，你会发现动态菜单的实现办法太多了。</p><p>动态菜单就是用户登录之后看到的菜单，不用角色的用户登录成功之后，会看到不用的菜单项，这个动态菜单要怎么实现呢？整体来说，有两种不同的方案，松哥曾经做过的项目中，两种方案也都有用过，这里分别来和大家分享一下。</p><h3 id="2-1-后端动态返回"><a href="#2-1-后端动态返回" class="headerlink" title="2.1 后端动态返回"></a>2.1 后端动态返回</h3><p>后端动态返回，这是我在微人事中采用的方案。微人事中，权限管理相关的表一共有五张表，如下：</p><p><img src="http://www.javaboy.org/images/fe/9-1.png" alt></p><p>其中 <code>hr</code> 表就是用户表，用户登录成功之后，可以查询到用户的角色，再根据用户角色去查询出来用户可以操作的菜单（资源），然后把这些可以操作的资源，组织成一个 JSON 数据，返回给前端，前端再根据这个 JSON 渲染出相应的菜单。以微人事为例，我们返回的 JSON 数据格式如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"path"</span>:<span class="hljs-string">"/home"</span>,</span><br><span class="line">        <span class="hljs-attr">"component"</span>:<span class="hljs-string">"Home"</span>,</span><br><span class="line">        <span class="hljs-attr">"name"</span>:<span class="hljs-string">"员工资料"</span>,</span><br><span class="line">        <span class="hljs-attr">"iconCls"</span>:<span class="hljs-string">"fa fa-user-circle-o"</span>,</span><br><span class="line">        <span class="hljs-attr">"children"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-attr">"id"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">                <span class="hljs-attr">"path"</span>:<span class="hljs-string">"/emp/basic"</span>,</span><br><span class="line">                <span class="hljs-attr">"component"</span>:<span class="hljs-string">"EmpBasic"</span>,</span><br><span class="line">                <span class="hljs-attr">"name"</span>:<span class="hljs-string">"基本资料"</span>,</span><br><span class="line">                <span class="hljs-attr">"iconCls"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">                <span class="hljs-attr">"children"</span>:[</span><br><span class="line"></span><br><span class="line">                ],</span><br><span class="line">                <span class="hljs-attr">"meta"</span>:&#123;</span><br><span class="line">                    <span class="hljs-attr">"keepAlive"</span>:<span class="hljs-literal">false</span>,</span><br><span class="line">                    <span class="hljs-attr">"requireAuth"</span>:<span class="hljs-literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="hljs-attr">"meta"</span>:&#123;</span><br><span class="line">            <span class="hljs-attr">"keepAlive"</span>:<span class="hljs-literal">false</span>,</span><br><span class="line">            <span class="hljs-attr">"requireAuth"</span>:<span class="hljs-literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的 JSON 在前端中再进行二次处理之后，就可以使用了，前端的二次处理主要是把 component 属性的字符串值转为对象。这一块具体操作大家可以参考微人事项目（具体在：<code>https://github.com/lenve/vhr/blob/master/vuehr/src/utils/utils.js</code>），我就不再赘述了。</p><p>这种方式的一个好处是前端的判断逻辑少一些，后端也不算复杂，就是一个 SQL 操作，前端拿到后端的返回的菜单数据，稍微处理一下就可以直接使用了。另外这种方式还有一个优势就是可以动态配置<strong>资源-角色</strong>以及<strong>用户-角色</strong>之间的关系，进而调整用户可以操作的资源(菜单)。</p><h3 id="2-2-前端动态渲染"><a href="#2-2-前端动态渲染" class="headerlink" title="2.2 前端动态渲染"></a>2.2 前端动态渲染</h3><p>另一种方式就是前端动态渲染，这种方式后端的工作要轻松一些，前端处理起来麻烦一些，松哥去年年末帮一个律所做的一个管理系统，因为权限上比较容易，我就采用了这种方案。</p><p>这种方式就是我直接在前端把所有页面都在路由表里边定义好，然后在 meta 属性中定义每一个页面需要哪些角色才能访问，例如下面这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"path"</span>:<span class="hljs-string">"/home"</span>,</span><br><span class="line">        <span class="hljs-attr">"component"</span>:Home,</span><br><span class="line">        <span class="hljs-attr">"name"</span>:<span class="hljs-string">"员工资料"</span>,</span><br><span class="line">        <span class="hljs-attr">"iconCls"</span>:<span class="hljs-string">"fa fa-user-circle-o"</span>,</span><br><span class="line">        <span class="hljs-attr">"children"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-attr">"id"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">                <span class="hljs-attr">"path"</span>:<span class="hljs-string">"/emp/basic"</span>,</span><br><span class="line">                <span class="hljs-attr">"component"</span>:EmpBasic,</span><br><span class="line">                <span class="hljs-attr">"name"</span>:<span class="hljs-string">"基本资料"</span>,</span><br><span class="line">                <span class="hljs-attr">"iconCls"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">                <span class="hljs-attr">"children"</span>:[</span><br><span class="line"></span><br><span class="line">                ],</span><br><span class="line">                <span class="hljs-attr">"meta"</span>:&#123;</span><br><span class="line">                    <span class="hljs-attr">"keepAlive"</span>:<span class="hljs-literal">false</span>,</span><br><span class="line">                    <span class="hljs-attr">"requireAuth"</span>:<span class="hljs-literal">true</span>,</span><br><span class="line">                    <span class="hljs-attr">"roles"</span>:['admin','user']</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="hljs-attr">"meta"</span>:&#123;</span><br><span class="line">            <span class="hljs-attr">"keepAlive"</span>:<span class="hljs-literal">false</span>,</span><br><span class="line">            <span class="hljs-attr">"requireAuth"</span>:<span class="hljs-literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样定义表示当前登录用户需要具备 admin 或者 user 角色，才可以访问 EmpBasic 组件，当然这里不是说我这样定义了就行，这个定义只是一个标记，在项目首页中，我会遍历这个数组做菜单动态渲染，然后根据当前登录用户的角色，再结合当前组件需要的角色，来决定是否把当前组件所对应的菜单项渲染出来。</p><p>这样的话，后端只需要在登录成功后返回当前用户的角色就可以了，剩下的事情则交给前端来做。不过这种方式有一个弊端就是菜单和角色的关系在前端代码中写死了，以后如果想要动态调整会有一些不方便，可能需要改代码。特别是大项目，权限比较复杂的时候，调整就更麻烦了，所以这种方式我一般建议在一些简单的项目中使用。</p><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h2><p>虽然我在微人事中使用了第一种方式，不过如果小伙伴是一个新项目，并且权限问题不是很复杂的话，我还是建议尝试一下第二种方式，感觉要方便一些。</p><p>不过在公司中，动态菜单到底在前端做还是后端做，可能会有一个前后端团队沟（si）通（bi）的过程，赢了的一方就可以少写几行代码了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于前后端分离开发中的权限处理问题，松哥之前写过一篇文章和大家聊这个问题：&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://www.javaboy.org/categories/vue/"/>
    
    
      <category term="router" scheme="http://www.javaboy.org/tags/router/"/>
    
      <category term="vue" scheme="http://www.javaboy.org/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>使用 Nginx 部署前后端分离项目，解决跨域问题</title>
    <link href="http://www.javaboy.org/2019/1016/nginx.html"/>
    <id>http://www.javaboy.org/2019/1016/nginx.html</id>
    <published>2019-10-16T11:44:24.000Z</published>
    <updated>2019-10-16T11:59:40.387Z</updated>
    
    <content type="html"><![CDATA[<p>前后端分离这个问题其实松哥和大家聊过很多了，上周松哥把自己的两个开源项目部署在服务器上以帮助大家可以快速在线预览（<a href="https://mp.weixin.qq.com/s/GvqLzCZngQiMqVE_ZTafeA" target="_blank" rel="noopener">喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了</a>），然后群里就有小伙伴想让松哥来聊聊如何结合 Nginx 来部署前后端分离项目？今天我们就来聊一聊这个话题。</p><a id="more"></a><h2 id="不得不说的跨域"><a href="#不得不说的跨域" class="headerlink" title="不得不说的跨域"></a>不得不说的跨域</h2><p>很多人对前后端分离部署感到困惑，其实主要是困惑跨域问题怎么解决。因为前后端分离项目在开发的时候，前端通过 nodejs 来运行，需要一个单独的端口，后端通过 Tomcat 或者 Jetty 来运行，也需要端口，两个不同的端口，就造成了跨域。</p><p>但是松哥之前多次和大家聊过这个问题，这种跨域并不是我们传统开发中真正的跨域，这个所谓的跨域只在开发环境中存在，生产环境下就不存在这个跨域问题了。所以我们不能按照以往的通过 JSONP 或者 CORS 之类的手段来解决这个跨域问题。</p><p>前后端分离开发中，前端为了能够模拟出测试数据，并且模拟出请求，一般需要借助于 nodejs 来运行，这是开发时候的状态，开发时候的配置大家可以参考这篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/szgfT3tnYMCHSeiE3_QnpA" target="_blank" rel="noopener">前后端分离历险记</a></li></ul><p>等开发完成后，我们会对前端项目编译打包，编译打包完成之后，就只剩下一堆 js、css 以及 html 文件了，我们把这些编译打包后的文件拷贝到后端项目中，这样再去运行就不存在跨域问题了（例如将编译打包后的静态文件拷贝到 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下）。这种方式我就不再多说了，相信大家都会，今天咱们主要来看看如何结合 Nginx 来部署。</p><h2 id="Nginx-大杀器"><a href="#Nginx-大杀器" class="headerlink" title="Nginx 大杀器"></a>Nginx 大杀器</h2><p>结合 Nginx 来部署前后端分离项目算是目前的主流方案。一来部署方便，二来通过动静分离也可以有效提高项目的运行效率。</p><p>大家知道我们项目中的资源包含动态资源和静态资源两种，其中：</p><ul><li>动态资源就是那些需要经过容器处理的资源，例如 jsp、freemarker、各种接口等。</li><li>静态资源则是那些不需要经过容器处理，收到客户端请求就可以直接返回的资源，像 js、css、html 以及各种格式的图片，都属于静态资源。</li></ul><p>将动静资源分开部署，可以有效提高静态资源的加载速度以及整个系统的运行效率。</p><p>在前后端分离项目部署中，我们用 Nginx 来做一个反向代理服务器，它既可以代理动态请求，也可以直接提供静态资源访问。我们来一起看下。建议大家先阅读松哥以前关于 Nginx 的一篇旧文，可以有效帮助大家理解后面的配置：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></li></ul><h3 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h3><p>后端接口的部署，主要看项目的形式，如果就是普通的 SSM 项目，那就提前准备好 Tomcat ，在 Tomcat 中部署项目，如果是 Spring Boot 项目，可以通过命令直接启动 jar，如果是微服务项目，存在多个 jar 的话，可以结合 Docker 来部署（参考<a href="https://mp.weixin.qq.com/s/vSCQLvQBYMYoPhdlO2v3XA" target="_blank" rel="noopener">一键部署 Spring Boot 到远程 Docker 容器</a>），无论是那种形式，对于我们 Java 工程师来说，这都不是问题，我相信这一步大家都能搞定。</p><p>后端项目可以在一个非 80 端口上部署，部署成功之后，因为这个后端项目只是提供接口，所以我们并不会直接去访问他。而是通过 Nginx 请求转发来访问这个后端接口。</p><p>松哥这里以我去年为一个律所的小程序为例，后端是一个 Spring Boot 工程，那么我可以通过 Docker 部署，也可以直接通过命令来启动，这里简单点，直接通过命令来启动 jar ，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar jinlu.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><p>后端启动成功之后，我并不急着直接去访问后端，而是安装并且去配置一个 Nginx，通过 Nginx 来转发请求，Nginx 的基本介绍与安装，大家可以参考（<a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a>），我这里就直接来说相关的配置了。</p><p>这里我们在 nginx.conf 中做出如下配置：</p><p>首先配置上游服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">upstream zqq.com&#123;</span><br><span class="line">  server 127.0.0.1:9999 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里主要是配置服务端的地址，如果服务端是集群化部署，那么这里就会有多个服务端地址，然后可以通过权重或者 ip hash 等方式进行请求分发。</p><p>然后我们在 server 中配置转发规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /jinlu/ &#123;</span><br><span class="line">  proxy_pass http://zqq.com;</span><br><span class="line">  tcp_nodelay     on;</span><br><span class="line">  proxy_set_header Host            $host;</span><br><span class="line">  proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置完成后，假设我目前的域名是 javaboy.org，那么用户通过 <code>http://www.javaboy.org/jinlu/**</code> 格式的地址就可以访问到我服务端的接口。</p><h3 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h3><p>以 Vue 为例，如果是 SPA 应用，项目打包之后，就是一个 index.html 还有几个 js、css、images 以及 fonts ，这些都是静态文件，我们将静态文件首先上传到服务器，然后在 nginx.conf 中配置静态资源访问，具体配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|) &#123;</span><br><span class="line">   root /usr/local/nginx/html/;#所有静态文件直接读取硬盘</span><br><span class="line">   expires 30d; #缓存30天</span><br><span class="line">&#125; ​​​​</span><br></pre></td></tr></table></figure><p>当然我这里是按照资源类型来拦截的，即后缀为 js、css、ico 等的文件，统统都不进行请求分发，直接从本地的 /usr/local/nginx/html/ 目录下读取并返回到前端（我们需要将静态资源文件上传到 <code>/usr/local/nginx/html/</code> 目录下）。</p><p>如果我们的服务器上部署了多个项目，这种写法就不太合适，因为多个项目的前端静态文件肯定要分门别类，各自放好的，这个时候我们一样可以通过路径来拦截，配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /jinlu-admin/ &#123;</span><br><span class="line">   root /usr/local/nginx/html/jinlu-admin/;#所有静态文件直接读取硬盘</span><br><span class="line">   expires 30d; #缓存30天</span><br><span class="line">&#125; ​​​​</span><br></pre></td></tr></table></figure><p>这样，请求路径是 /jinlu-admin/ 格式的请求，则不会进行请求分发，而是直接从本机的 <code>/usr/local/nginx/html/jinlu-admin/</code> 目录下返回相关资源。采用这方方式配置静态资源，我们就可以部署多个项目了，多个项目的部署方式和上面的一样。</p><p>这样部署完成之后，假设我的域名是 javaboy.org ，那么用户通过 <code>http://www.javaboy.org/jinlu-admin/**</code><br>格式的请求就可以访问到前端资源了。</p><p>此时大家发现，前端的静态资源和后端的接口现在处于同一个域之中了，这样就不存在跨域问题，所以我一开始基说<strong>不</strong>必用 JSONP 或者 CORS 去解决跨域。特殊情况可能需要在 nginx 中配置跨域，这个松哥以后再和大家细聊~​</p><p>好了，不知道小伙伴有没有看懂呢？有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前后端分离这个问题其实松哥和大家聊过很多了，上周松哥把自己的两个开源项目部署在服务器上以帮助大家可以快速在线预览（&lt;a href=&quot;https://mp.weixin.qq.com/s/GvqLzCZngQiMqVE_ZTafeA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了&lt;/a&gt;），然后群里就有小伙伴想让松哥来聊聊如何结合 Nginx 来部署前后端分离项目？今天我们就来聊一聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://www.javaboy.org/categories/nginx/"/>
    
    
      <category term="前后端分离" scheme="http://www.javaboy.org/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
      <category term="nginx" scheme="http://www.javaboy.org/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 前后端分离登录，非法请求直接返回 JSON</title>
    <link href="http://www.javaboy.org/2019/1015/springsecurity.html"/>
    <id>http://www.javaboy.org/2019/1015/springsecurity.html</id>
    <published>2019-10-15T11:51:00.000Z</published>
    <updated>2019-10-16T12:06:33.614Z</updated>
    
    <content type="html"><![CDATA[<p>hello 各位小伙伴，国庆节终于过完啦，松哥也回来啦，今天开始咱们继续发干货！</p><p>关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用：</p><a id="more"></a><ol><li><a href="https://mp.weixin.qq.com/s/HKJOlatXDS8awBNyCe9JMg" target="_blank" rel="noopener">手把手带你入门 Spring Security！</a></li><li><a href="https://mp.weixin.qq.com/s/oDow2miLIst-R4NNzc_i4g" target="_blank" rel="noopener">Spring Security 登录添加验证码</a></li><li><a href="https://mp.weixin.qq.com/s/X1t-VCxzxIcQKOAu-pJrdw" target="_blank" rel="noopener">SpringSecurity 登录使用 JSON 格式数据</a></li><li><a href="https://mp.weixin.qq.com/s/7D0qJiEIzNuz8VAVvZsXCA" target="_blank" rel="noopener">Spring Security 中的角色继承问题</a></li><li><a href="https://mp.weixin.qq.com/s/riyFQSrkQBQBCyomE__fLA" target="_blank" rel="noopener">Spring Security 中使用 JWT!</a></li><li><a href="https://mp.weixin.qq.com/s/1rVPzJGCtDZKvMoA4BYzIA" target="_blank" rel="noopener">Spring Security 结合 OAuth2</a></li></ol><p>不过，今天要和小伙伴们聊一聊 Spring Security 中的另外一个问题，那就是在 Spring Security 中未获认证的请求默认会重定向到登录页，但是在前后端分离的登录中，这个默认行为则显得非常不合适，今天我们主要来看看如何实现未获认证的请求直接返回 JSON ，而不是重定向到登录页面。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这里关于 Spring Security 的基本用法我就不再赘述了，如果小伙伴们不了解，可以参考上面的 6 篇文章。</p><p>大家知道，在自定义 Spring Security 配置的时候，有这样几个属性：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login"</span>)</span><br><span class="line">            <span class="hljs-comment">//其他配置</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个比较重要的属性：</p><ul><li>loginProcessingUrl：这个表示配置处理登录请求的接口地址，例如你是表单登录，那么 form 表单中 action 的值就是这里填的值。</li><li>loginPage：这个表示登录页的地址，例如当你访问一个需要登录后才能访问的资源时，系统就会自动给你通过重定向跳转到这个页面上来。</li></ul><p>这种配置在前后端不分的登录中是没有问题的，在前后端分离的登录中，这种配置就有问题了。我举个简单的例子，例如我想访问 <code>/hello</code> 接口，但是这个接口需要登录之后才能访问，我现在没有登录就直接去访问这个接口了，那么系统会给我返回 302，让我去登录页面，在前后端分离中，我的后端一般是没有登录页面的，就是一个提示 JSON，例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">"尚未登录，请登录!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整代码大家可以参考我的微人事项目。</p></blockquote><p>也就是说，当我没有登录直接去访问 <code>/hello</code> 这个接口的时候，我会看到上面这段 JSON 字符串。在前后端分离开发中，这个看起来没问题（后端不再做页面跳转，无论发生什么都是返回 JSON）。但是问题就出在这里，系统默认的跳转是一个重定向，就是说当你访问 <code>/hello</code> 的时候，服务端会给浏览器返回 302，同时响应头中有一个 Location 字段，它的值为 <code>http://localhost:8081/login</code> ，也就是告诉浏览器你去访问 <code>http://localhost:8081/login</code> 地址吧。浏览器收到指令之后，就会直接去访问 <code>http://localhost:8081/login</code> 地址，如果此时是开发环境并且请求还是 Ajax 请求，就会发生跨域。因为前后端分离开发中，前端我们一般在 NodeJS 上启动，然后前端的所有请求通过 NodeJS 做请求转发，现在服务端直接把请求地址告诉浏览器了，浏览器就会直接去访问 <code>http://localhost:8081/login</code> 了，而不会做请求转发了，因此就发生了跨域问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>很明显，上面的问题我们不能用跨域的思路来解决，虽然这种方式看起来也能解决问题，但不是最佳方案。</p><p>如果我们的 Spring Security 在用户未获认证的时候去请求一个需要认证后才能请求的数据，此时不给用户重定向，而是直接就返回一个 JSON，告诉用户这个请求需要认证之后才能发起，就不会有上面的事情了。</p><p>这里就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Performs the redirect (or forward) to the login form URL.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationException authException)</span> </span>&#123;</span><br><span class="line">String redirectUrl = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (useForward) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (forceHttps &amp;&amp; <span class="hljs-string">"http"</span>.equals(request.getScheme())) &#123;</span><br><span class="line">redirectUrl = buildHttpsRedirectUrlForRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (redirectUrl == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String loginForm = determineUrlToUseForThisRequest(request, response,</span><br><span class="line">authException);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Server side forward to: "</span> + loginForm);</span><br><span class="line">&#125;</span><br><span class="line">RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);</span><br><span class="line">&#125;</span><br><span class="line">redirectStrategy.sendRedirect(request, response, redirectUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p><p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login"</span>)</span><br><span class="line">            <span class="hljs-comment">//其他配置</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable().exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(<span class="hljs-keyword">new</span> AuthenticationEntryPoint() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                PrintWriter out = resp.getWriter();</span><br><span class="line">                RespBean respBean = RespBean.error(<span class="hljs-string">"访问失败!"</span>);</span><br><span class="line">                <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;</span><br><span class="line">                    respBean.setMsg(<span class="hljs-string">"请求失败，请联系管理员!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，一个小小的重定向问题和小伙伴们分享下，不知道大家有没有看懂呢？这也是我最近在重构微人事的时候遇到的问题。预计 11 月份，微人事的 Spring Boot 版本会升级到目前最新版，请小伙伴们留意哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 各位小伙伴，国庆节终于过完啦，松哥也回来啦，今天开始咱们继续发干货！&lt;/p&gt;
&lt;p&gt;关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用：&lt;/p&gt;
    
    </summary>
    
      <category term="SpringSecurity" scheme="http://www.javaboy.org/categories/SpringSecurity/"/>
    
    
      <category term="SpringSecurity" scheme="http://www.javaboy.org/tags/SpringSecurity/"/>
    
      <category term="前后端分离" scheme="http://www.javaboy.org/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>微人事项目视频教程已经开始更新，国庆节有事情做啦！</title>
    <link href="http://www.javaboy.org/2019/1014/vhr-video.html"/>
    <id>http://www.javaboy.org/2019/1014/vhr-video.html</id>
    <published>2019-10-14T11:48:56.000Z</published>
    <updated>2019-10-16T12:02:27.485Z</updated>
    
    <content type="html"><![CDATA[<p>在正式介绍松哥最近在连载的微人事视频之前，我想要和大家先聊聊前后端分离到底难在哪里？</p><a id="more"></a><p><strong>老实说，前后端分离不难</strong>。</p><p>相反，前后端分离之后，对于后端工程师而言，事情反而变简单了。</p><p>在前后端不分的年代，很少有纯粹的后端工程师，一个 Java 工程师，多多少少得会一点 js、会一点 jQuery 吧？我相信大部分做过开发的小伙伴都有这样的经验。然而，当前后端分离之后，后端工程师的工作大大的减轻了，后端的工作也更加纯粹了，如果没有其他抱负，大概可以安安静静做一个接口仔了。</p><p>但是我相信，在程序员这个群体中，应该没有人愿意做一个安安静静的接口仔。想要提高自己的技能，全栈就是一个方向。然而前后端分离时代的全栈工程师，门槛可比从前的前后端不分时代的全栈工程师高多了。</p><p>为什么这么说呢？</p><p>前端经过这几年的发展，早已经变得非常强大，前端工程化、webpack、单页面应用/SPA，各种概念层出不穷。这种情况下，我们后端工程师想要去前端领域分一杯羹，进而提升自己的竞争力，着实得花点功夫。其实我一直觉得，目前前端的这些东西，对一个专业的前端工程师而言，其实应该都不算难，我们后端的 Spring Boot 这些，对一个专业的 Java 工程师也不算难，但是如果让一个人既写前端又写后端，多多少少有点难度，这些难度松哥从一个 Java 工程师的角度总结了，主要集中在以下几个方面：</p><ol><li>前后端分离开发，开发环境下前后端的通信到底是怎么进行的？因为前端在 nodejs 上启动，有自己的端口，后端在 Tomcat 或者 Jetty 上启动，也有自己的端口，这种看似跨域的问题要怎么解决？</li><li>权限管理要怎么做？以前大家做权限管理就是各种请求拦截，如果请求权限不足，则转发到某一个页面去，前后端分离之后，无论什么情况，后端都是只返回 JSON，那么此时权限管理要怎么做？</li><li>前端的单页面应用（SPA）到底是怎么回事？有哪些优势？</li><li>前端组件化又是什么鬼？</li><li>webpack 到底是什么？</li><li>前后端分离项目的部署</li></ol><p>这里的很多问题其实并不难，只是你缺乏一个令人恍然大悟的解释。且听松哥一一道来。</p><p>作为一个专业的后端工程师，当我们去学习很多前端概念的时候，如果能够把这些概念和我们 Java 中的某一个概念或者工具对应起来，你就会有一种恍然大悟的感觉，原来是这么回事！其实开发本语言和工具本来就是相似的，大部分语言不就是互相借鉴产生的么（例如 C#  和 Java），因此这些开发中的概念、工具等也都具有高度的相似性，如果能把前端的概念和 Java 中的一些概念对应起来理解，那就太棒啦！</p><p>然而我们在网上看到的大部分教程，前端就是专业的前端，后端就是专业的后端，很少有把这两个联合起来讲，不免有点遗憾。</p><p>松哥在 2018 年年初做微人事项目，就是考虑到这种前后端分离的案例太少了，我想打通前后端的任督二脉，很多小伙伴也亟需一个前后端分离的案例来练手，因此才有了后来的 V 部落和微人事项目。其中微人事项目我还写了一个非常详细的开发文档，当时心想着小伙伴们对照的开发文档应该就能搞出来微人事。</p><p><img src="http://www.javaboy.org/images/other/74-2.png" alt></p><p>但是事实证明，还是有点乐观了。有不少小伙伴通过微人事项目添加了我的微信，问了很多问题，其实大部分问题都不难，但是要给大家解释清楚又非三言两语能说清，因此，我才决定在 Spring Boot 系列完结之后，继续录制这一套微人事项目的手把手教程，到目前为止已经录制了接近 50 集了，以下是部分视频：</p><p><img src="http://www.javaboy.org/images/other/74-1.png" alt></p><p>在这套视频中，松哥从零开始，带领大家做一个和我的开源项目微人事一模一样的项目。我会从一个 Java 工程师的角度来和大家聊一聊全栈开发（Spring Boot + Vue）中的弯弯绕绕，很多前端的概念我会对照着 Java 中的一些工具来跟大家解释，这样可以帮助大家更好更快的理解并掌握前端的概念。我觉得这是非常难得的，你可以在网上找到专业的后端教程，也可以找到专业的前端教程，但是前后端结合的，老实说，并不多。</p><p>看过我博客的小伙伴都知道，松哥的博客力求简单易懂，让大家都看得明白，做得出效果，视频也是延续了这样的风格。无论是已经连载完毕的 Spring Boot 还是目前正在连载的微人事，都受到小伙伴的好评：</p><p><img src="http://www.javaboy.org/images/other/74-6.jpg" alt><br><img src="http://www.javaboy.org/images/other/74-3.jpg" alt><br><img src="http://www.javaboy.org/images/other/74-4.jpg" alt><br><img src="http://www.javaboy.org/images/other/74-5.jpg" alt></p><p>还有很多小伙伴把松哥视频教程推荐给他们身边的同事朋友，我想这足以说明松哥视频的质量了吧。（要是很坑的话，估计也没人推荐吧）</p><p><img src="http://www.javaboy.org/images/other/74-7.jpg" alt><br><img src="http://www.javaboy.org/images/other/74-8.jpg" alt></p><p>真的挺感动，这都是满满的信任。</p><p>当然视频的录制，还是和以前一样辛苦，早上六点起来录视频，录到八点半去上班，晚上回到家里，对视频进行二次处理，去噪，重新渲染，只是为了给小伙伴们一个更加清晰的视频教程：</p><p><img src="http://www.javaboy.org/images/other/74-9.png" alt></p><p>当然这些付出也决定了这是一套付费教程。</p><p>我自己还在网上搜集了很多别人录制的视频，这些视频对我来说没有多大成本，都是网络上找的，因此我都免费送给大家了，在我公众号底部菜单里有免费视频，这些免费视频大家都可以领取，我不会拿这些随处可见的视频来卖钱。</p><p>欢迎大家加入星球，一起学习进步！趁着国庆节弯道超车。现在直接扫码加入星球需要 199，这里我提供另外一个优惠的方式，大家可以加我微信，发红包只要 119，然后我手动拉你进星球。星球上每有一个课程完结的时候，就会提升一次价格，早点加入就是优势。<strong>同时为了保证加入星球的小伙伴的权益，我可以向大家保证，你在其他地方不会看到一模一样的免费的整套视频教程，因为这些视频都是我自己录制的，全部都是加密之后发布的，所以请大家放心。</strong></p><p><img src="http://www.javaboy.org/images/other/74-10.jpeg" alt></p><p>感谢大家信任。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在正式介绍松哥最近在连载的微人事视频之前，我想要和大家先聊聊前后端分离到底难在哪里？&lt;/p&gt;
    
    </summary>
    
      <category term="微人事" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E4%BA%BA%E4%BA%8B/"/>
    
    
      <category term="微人事" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E4%BA%BA%E4%BA%8B/"/>
    
      <category term="vhr" scheme="http://www.javaboy.org/tags/vhr/"/>
    
  </entry>
  
  <entry>
    <title>每次回西安，都会动摇我继续留在深圳的决心</title>
    <link href="http://www.javaboy.org/2019/1006/go-home.html"/>
    <id>http://www.javaboy.org/2019/1006/go-home.html</id>
    <published>2019-10-06T11:49:54.000Z</published>
    <updated>2019-10-16T12:03:42.749Z</updated>
    
    <content type="html"><![CDATA[<p>hello 小伙伴们国庆节快乐吖。</p><a id="more"></a><p>松哥国庆节回老家了，这两天一直忙哥没停。和女票在一起八年了，结婚的事情该慢慢准备了，国庆节趁机带女票家人来西安走走看看，好多近在眼前但是以前从来没有去过的景点如城墙、大唐不夜城等，这次都去走了走。不过老实说，西安的文化，单纯从一些典型的景点中其实不太容易体会到，西安的文化和历史沉淀在这个城市的每一个细节中，随便走两步，看见一个地名，这就是一个故事，这些以后松哥在再和大家细细聊。</p><p>回家呆这几天，真是感慨颇多，甚至又一次动摇了我继续留在深圳的决心。回家真是太舒服了，老家亲戚多朋友多，很多事情都可以热热闹闹的去做，村子里的晚上超级安静，只有远处村子的狗吠，没有了大城市的嘈杂，每天晚上都能安安稳稳的睡好久。这次回家，西安的房子也收拾好了可以住人了，小区旁边每逢 2/4/6 有集，今天去看了下，蘑菇十块钱一筐五块钱半框、提子一块五一斤十块八斤…等等，这价格真的太感人了，我心里思量着要是回西安生活，日子一定美滋滋（其实我也明白，要是真的回来了，日子也不见得就一定美滋滋。</p><p>在深圳就不一样了，完全是另外一种状态，周一到周五白天上班，晚上写公众号，周末录视频教程+写公众号，很少有自己的生活，甚至可以说只有工作没有生活。在深圳租的房子，我一般习惯称之为<strong>宿舍</strong>，我不太喜欢称之为<strong>家</strong>，因为我觉得那就是一个晚上睡觉的地方，而家，不仅仅指房子，也是心的寄托，将租的房子称之为家，我有点不太习惯，没有家，所以总有一种漂着的感觉。</p><p>每次过完年离家其实也是这样，刚走的时候，挺想家，感觉呆在西安真不错，时间久了，这种感觉就慢慢变淡了，开始谋划如何在广深两地立足，直到过年回到家，又开始思想上新一轮的轮回。</p><p>既然这样，那干嘛还要留在深圳或者广州呢？</p><p>对于一个农村出来的孩子，我有太多的不甘心，留在深圳，代表着奋斗，希望就有可能实现。而回老家，在我看来有一点点认命的感觉，就是不打算继续奋斗了，和一帮好朋友去吃吃喝喝了，生活乐悠悠，事业上能糊口就行了。</p><p>大学毕业后，我就羡慕两种人，一种人就是留在学校所在地工作的，可以随时见到老师同学，可以随时回学校看看，还有一种就是回老家工作的，虽然不知道他们真实的生活状态，不过我自己想象着应该是很美好的生活吧…</p><p>每次想到以后要不要回西安，就会很纠结，我想知道小伙伴们都在哪里工作呢？是老家还是一线城市？为什么作出这样的选择？欢迎大家来留言说说.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 小伙伴们国庆节快乐吖。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>给数据库减负的八个思路</title>
    <link href="http://www.javaboy.org/2019/0921/mysql.html"/>
    <id>http://www.javaboy.org/2019/0921/mysql.html</id>
    <published>2019-09-21T06:47:18.000Z</published>
    <updated>2019-09-21T06:48:59.572Z</updated>
    
    <content type="html"><![CDATA[<p>传统的企业级应用，其实很少会有海量应用，因为企业的规模本身就摆在那里，能有多少数据？高并发？海量数据？不存在的！</p><p>不过在互联网公司中，因为应用大多是面向广大人民群众，数据量动辄上千万上亿，那么这些海量数据要怎么存储？光靠数据库吗？肯定不是。</p><a id="more"></a><p>今天松哥和大家简单的聊一聊这个话题。</p><p>海量数据，光用数据库肯定是没法搞定的，即使不读松哥这篇文章，相信大家也能凝聚这样的共识，海量数据，不是说一种方案、两种方案就能搞定，它是一揽子方案。那么这一揽子方案都包含哪些东西呢？松哥从以下八个方面来和大家聊聊。</p><h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h1><p>首先第一种解决方案就是缓存了。</p><p>缓存，我们可以将数据直接缓存在内从中，例如 Map、也可以使用缓存框架如 Redis 等，将一些需要频繁使用的热点数据保存在缓存中，每当用户来访问的时候，就可以直接将缓存中的数据返回给用户，这样可以有效降低服务器的压力。</p><p>可以缓存起来使用的数据，一般都不能对实时性要求太高。</p><h1 id="2-页面静态化"><a href="#2-页面静态化" class="headerlink" title="2.页面静态化"></a>2.页面静态化</h1><p>页面静态化其实可以算作是缓存的另外一种形式，相当于直接将相关的页面渲染结果缓存起来。首先大家知道，在我们的 Web 项目中，资源分为两大类：</p><ul><li>静态资源</li><li>动态资源</li></ul><p>静态资源就是我们常见的 HTML、CSS、JavaScript、图片等资源，这些资源可以不经过服务端处理，就可以直接返回给前端浏览器，浏览器就可以直接显示出来。</p><p>动态资源则是指我们项目中的 Servlet 接口、Jsp 文件、Freemarker 等，这些需要经过服务端渲染之后，才可以返回前端的资源。</p><p>在实际项目中，静态资源的访问速度要远远高于动态资源，动态资源往往很容易遇到服务器瓶颈、数据库瓶颈，因此，对于一些不经常更新的页面，或者说更新比较缓慢的页面，我们可以通过页面静态化，将一个动态资源保存为静态资源，这样当服务端需要访问的时候，直接将静态资源返回，就可以避免去操作数据库了，降低数据库的压力。</p><p>例如松哥以前做过的一个电商项目，系统根据大数据统计，自动统计出用户当前搜索的热点商品，这些热点商品，10 分钟更新一次，也就是说，在十分钟内，用户登录上来看到的热点商品都是相同的。那么就没有必要每次都去查询数据库，而是将热点数据的页面，通过输出流自动写到服务器上，写成一个普通的 HTML 文件，下次用户来访问，在 10 分钟有效期内，直接将 HTML 页面返回给用户，就不必操作数据库了。</p><p>一般来说，Freemarker、Velocity 等都有相关的方法可以帮助我们快速将动态页面生成静态页面。</p><p>这就是页面静态化。</p><h1 id="3-数据库优化"><a href="#3-数据库优化" class="headerlink" title="3.数据库优化"></a>3.数据库优化</h1><p>很多时候程序跑得慢，不是因为设备落后，而是因为数据库 SQL 写的太差劲。</p><p>要解决海量数据的问题，数据库优化肯定也是不可避免的。一般来说，我们可以从 SQL 优化、表结构优化、以及数据库分区分表等多个方面来对数据库进行优化。数据库优化其实也是一门巨大的学问，松哥以后看有时间写个连载和大家仔细聊聊这个话题。</p><h1 id="4-热点数据分离"><a href="#4-热点数据分离" class="headerlink" title="4.热点数据分离"></a>4.热点数据分离</h1><p>数据库中的数据，虽然是海量数据，但是这些数据并不见得所有数据都是活跃数据，例如用户注册，有的用户注册完就消失的无影无踪了，而有的用户则在不停的登录，因此，对于这两种不同的用户，我们可以将活跃用户分离出来，在主要操作的数据表中只保存活跃用户数据。每次用户登录，先去主表中查看有没有记录，有的话，直接登录，没有的话，再去查看其他表。</p><p>通过判断用户在某一段时间内的登录次数，就可以很快分离出热点数据。</p><h1 id="5-合并数据库操作"><a href="#5-合并数据库操作" class="headerlink" title="5.合并数据库操作"></a>5.合并数据库操作</h1><p>这个方案的宗旨其实是减少数据库操作的次数，例如多次插入操作，我们可以合并成一条 SQL 搞定。多个不同条件的查询，如果条件允许的话，也可以合并成为一个查询，尽量减少数据库的操作，减少在网络上消耗，同时也降低数据库的压力。</p><h1 id="6-数据库读写分离"><a href="#6-数据库读写分离" class="headerlink" title="6.数据库读写分离"></a>6.数据库读写分离</h1><p>数据库的读写分离其实松哥在之前的 MyCat 中也和大伙聊过了（<a href="https://mp.weixin.qq.com/s/oNsTcrWCjntQefD2B0sq1A" target="_blank" rel="noopener">MyCat 系列</a>），读写分离之后，一方面可以提高数据库的操作效率，另一方面也算是对数据库的一个备份。这一块的具体操作大家可以参考松哥前面的文章。</p><h1 id="7-分布式数据库"><a href="#7-分布式数据库" class="headerlink" title="7.分布式数据库"></a>7.分布式数据库</h1><p>数据库读写分离之后，无形中增大了代码的复杂度，所以一般还需要借助分布式数据库中间件，这样可以有效提高数据库的弹性，可以方便的随时为数据库扩容，同时也降低代码的耦合度。</p><h1 id="8-NoSQL-和-Hadoop"><a href="#8-NoSQL-和-Hadoop" class="headerlink" title="8.NoSQL 和 Hadoop"></a>8.NoSQL 和 Hadoop</h1><p>另外，引入 NoSQL 和 Hadoop 也是解决方案之一。NoSQL 突破了关系型数据库中对表结构、字段等定义的条条框框，使用户可以非常灵活方便的操作，另外 NoSQL 通过多个存储块存储数据的特点，使得天然具备操作大数据的优势（快）。不过，老实说，NoSQL 目前还是在互联网项目中比较常见，在传统的企业级应用中还是比较少见。</p><p>Hadoop 就不必说了，大数据处理利器。</p><p>很多时候技术和架构只是一个工具，所有的东西都摆在你面前，关键是如何把这些东西组合在一起，使之产生最大化收益，这就需要大家慢慢琢磨，松哥后面也尽量和大家多分享一些这方面的经验。</p><p>好了，简单的从 8 个方面和大家聊一聊这个问题，大家在工作中有没有遇到类似问题呢？你都是怎么处理的？欢迎留言讨论。</p><p>参考资料：</p><p>[1] 韩路彪.看透Spring MVC：源代码分析与实践[M].北京：机械工业出版社，2015.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传统的企业级应用，其实很少会有海量应用，因为企业的规模本身就摆在那里，能有多少数据？高并发？海量数据？不存在的！&lt;/p&gt;
&lt;p&gt;不过在互联网公司中，因为应用大多是面向广大人民群众，数据量动辄上千万上亿，那么这些海量数据要怎么存储？光靠数据库吗？肯定不是。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了</title>
    <link href="http://www.javaboy.org/2019/0920/springboot-vue-online.html"/>
    <id>http://www.javaboy.org/2019/0920/springboot-vue-online.html</id>
    <published>2019-09-20T05:07:20.000Z</published>
    <updated>2019-09-21T06:05:01.688Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了一周的域名备案昨天终于搞定了。</p><p>松哥第一时间想到赶紧把<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>部署上去，我知道很多小伙伴已经等不及了。</p><a id="more"></a><h2 id="1-也曾经上过线"><a href="#1-也曾经上过线" class="headerlink" title="1. 也曾经上过线"></a>1. 也曾经上过线</h2><p>其实这两个项目当时刚做好的时候，我就把它们部署到服务器上了，以帮助小伙伴们更好的查看效果。但是那个是一台国外服务器，之所以购买国外服务器，主要是嫌国内备案麻烦，当然也有其他大家都懂的原因。</p><p>国外服务器有方便的地方，同时也有很多不便，例如网络不稳，随时有失联的风险。所以我在 2018 年年初，虽然把这两个项目都部署在服务器上，但是很多小伙伴的访问体验都不好，主要还是网络的问题。后来一段时间，经过几轮围剿与反围剿，这台服务器就彻底和松哥失联了。</p><p>失联之后，因为工作比较忙，我也就懒得去折腾了，所以导致<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>大家在很长一段时间内无法在线查看效果。</p><h2 id="2-重新上线"><a href="#2-重新上线" class="headerlink" title="2. 重新上线"></a>2. 重新上线</h2><p>最近因为有一些其他的计划，于是购买了阿里云服务，完事之后就是备案，所有东西都搞定之后，想着先把<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>部署起来，方便大家查看效果。</p><p>说干就干，我首先规划了两个二级域名：</p><ul><li><a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a></li><li><a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a></li></ul><p>这两个二级域名分别用来部署 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>和<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>。</p><p>大家可以通过这两个地址查看效果：</p><p><strong><a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a></strong></p><p><img src="http://www.javaboy.org/images/fronted-backend/70-1.png" alt></p><p><strong><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a></strong></p><p><img src="http://www.javaboy.org/images/fronted-backend/70-2.png" alt></p><p>为了确保每位小伙伴都能看到完整的演示效果，防止有的小伙伴不慎把所有数据清空了，导致其他小伙伴啥都看不到，我只开通了演示账户的查询和部分字段的更新权限，因此大家在查看演示效果时，可能会有一些涉及到增删改的操作会执行失败，请勿见怪，将项目部署到本地运行之后，就可以查看完整效果了。</p><h2 id="3-技能树"><a href="#3-技能树" class="headerlink" title="3. 技能树"></a>3. 技能树</h2><p>既然都写到这儿了，就和大家聊一聊这两个部署是怎么实现的。</p><h3 id="3-1-部署方案选择"><a href="#3-1-部署方案选择" class="headerlink" title="3.1 部署方案选择"></a>3.1 部署方案选择</h3><p>大家知道前后端分离部署的时候，我们有两种不同的方案：</p><ul><li>一种就是将前端项目打包编译之后，放到后端项目中（例如 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下）</li><li>另外一种则是将前端打包之后的静态资源用 Nginx 来部署，后端单独部署只需要单纯的提供接口即可。</li></ul><p>一般在公司项目中，我们更多的是采用后者。不过松哥这里部署为了省事，我采用了第一种方案。（以后抽空我会和大家聊聊第二种部署方案）</p><h3 id="3-2-域名映射"><a href="#3-2-域名映射" class="headerlink" title="3.2 域名映射"></a>3.2 域名映射</h3><p>域名映射这块简单，登录阿里云后台，添加两个 A 记录即可。</p><p><img src="http://www.javaboy.org/images/fronted-backend/70-3.png" alt></p><h3 id="3-3-启动-Spring-Boot"><a href="#3-3-启动-Spring-Boot" class="headerlink" title="3.3 启动 Spring Boot"></a>3.3 启动 Spring Boot</h3><p>将<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>分别打包上传到服务器，这个过程应该就不用我多说了吧，然后分别启动这两个项目，两个项目的默认端口分别是 8081 和 8082，命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar vblog.jar &gt; vblog.log &amp;</span><br><span class="line">nohup java -jar vhr.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><p>将两个项目的运行日志分别写入到 vblog.log 和 vhr.log 文件中。</p><p>启动成功之后，我们就可以通过 <code>itboyhub.com:8081</code> 和 <code>itboyhub.com:8082</code> 两个端口来分别访问这两个项目了。但是这还没达到松哥的目标，我想通过二级域名来访问，并且想通过 80 端口来访问，这就要借助 Nginx 了。</p><p><strong>注意</strong></p><p>启动完成后，大家需要登录阿里云后台，确认 8081 和 8082 端口已经开启。</p><h3 id="3-4-Nginx-配置"><a href="#3-4-Nginx-配置" class="headerlink" title="3.4 Nginx 配置"></a>3.4 Nginx 配置</h3><p>Nginx 的基本用法，大家可以参考松哥的这篇旧文：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></li></ul><p>这里我们主要来看看 Nginx 的配置。</p><p>由于有两个二级域名，而且未来服务器还要配置其他域名，因此域名要能够做到动态解析，因此在具体配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  *.itboyhub.com;</span><br><span class="line"></span><br><span class="line">    if ($http_host ~* &quot;^(.*?)\.itboyhub\.com$&quot;) &#123;</span><br><span class="line">            set $domain $1;</span><br><span class="line">    &#125;</span><br><span class="line">    # 其他配置...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先监听的端口为 80</li><li>二级域名则用一个通配符 <code>*</code> 代替</li><li>接下来在 if 语句用，通过正则表达式提取出二级域名的名字，交给变量 $domain，以备后用。</li></ul><p>接下来配置转发规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  if ($domain ~* &quot;vhr&quot;) &#123;</span><br><span class="line">    proxy_pass http://itboyhub.com:8082;</span><br><span class="line">  &#125;</span><br><span class="line">  if ($domain ~* &quot;vblog&quot;) &#123;</span><br><span class="line">    proxy_pass http://itboyhub.com:8081;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  tcp_nodelay     on;</span><br><span class="line">  proxy_set_header Host            $host;</span><br><span class="line">  proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当定义的 $domain 中包含 vhr 字符时，将请求转发到 <a href="http://itboyhub.com:8082" target="_blank" rel="noopener">http://itboyhub.com:8082</a></li><li>当定义的 $domain 中包含 vblog 字符时，将请求转发到 <a href="http://itboyhub.com:8081" target="_blank" rel="noopener">http://itboyhub.com:8081</a></li><li>最后再配置将代理服务器收到的用户的信息传到 real server 上</li></ul><p>另一方面，由于默认的后端首页是 <code>/index.html</code>，如果用户直接访问 <a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a> 或者 <a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a>，会被权限管理机制拦截（会自动重定向到 <code>/login_p</code>），因此，如果用户访问地址中没有 <code>/index.html</code> ，则自动添加上 <code>/index.html</code>，配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /login_p &#123;</span><br><span class="line">   if ($domain ~* &quot;vhr&quot;) &#123;</span><br><span class="line">     rewrite ^/(.*)$ http://vhr.itboyhub.com/index.html permanent;</span><br><span class="line">   &#125;</span><br><span class="line">   if ($domain ~* &quot;vblog&quot;) &#123;</span><br><span class="line">     rewrite ^/(.*)$ http://vblog.itboyhub.com/index.html permanent;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这行配置在 <code>location /</code> 之前进行配置，这里两个 if 的含义和前面的一样，不再赘述。</p><p>OK，如此之后我们的配置就算是完成了（上面 nginx 完整的配置文件小伙伴可以在公众号后台回复 nginx.conf 获取​）。</p><p>接下来我们就可以通过如下两个二级域名访问这两个开源项目了，小伙伴们赶紧试一把吧。</p><ul><li><a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a></li><li><a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a></li></ul><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>最后，再向小伙伴们安利一把这两个开源项目：</p><ul><li><a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li><li><a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>如果你要学习 Spring Boot + Vue 前后端分离项目，这两个是不可多得的好资料。 其中 V 部落无论是从技术点还是业务上来说，都要简单一些，所以如果你是新手，可以先看看 V 部落。微人事虽然稍微复杂一点，但好在松哥配有完整的开发文档，照着开发文档，相信大家也能理解大部分的功能。文档如下：</p><p><img src="http://www.javaboy.org/images/fronted-backend/70-4.png" alt></p><p>如果大家在部署的过程中遇到问题，也可以参考松哥手把手的部署视频：</p><ul><li><a href="https://mp.weixin.qq.com/s/qN01Le434FWom0c3jqiQmA" target="_blank" rel="noopener">微人事项目部署视频教程</a></li></ul><p>好了，本文说到这里，小伙伴们有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了一周的域名备案昨天终于搞定了。&lt;/p&gt;
&lt;p&gt;松哥第一时间想到赶紧把&lt;a href=&quot;https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微人事&lt;/a&gt;和 &lt;a href=&quot;https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;V 部落&lt;/a&gt;部署上去，我知道很多小伙伴已经等不及了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Java 操作 MongoDB</title>
    <link href="http://www.javaboy.org/2019/0919/mongodb-in-java.html"/>
    <id>http://www.javaboy.org/2019/0919/mongodb-in-java.html</id>
    <published>2019-09-19T02:17:28.000Z</published>
    <updated>2019-09-21T09:06:51.900Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们介绍的 MongoDB 的操作都是在 shell 命令中写的，在项目开发时我们当然都是用程序去操作 MongoDB 的，本文我们来看看如何用 Java 代码操作 MongoDB。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先我们需要驱动，MongoDB 的 Java 驱动我们可以直接在 Maven 中央仓库去下载，也可以创建 Maven 工程添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mongodb-driver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>建议通过 Maven 来添加依赖，如果自己下载 jar，需要下载如下三个 jar：</p><blockquote><ol><li>org.mongodb:bson:jar:3.5.0</li><li>org.mongodb:mongodb-driver-core:jar:3.5.0</li><li>org.mongodb:mongodb-driver:jar:3.5.0</li></ol></blockquote><p>另外，在使用 Java 操作 MongoDB 之前，记得启动 MongoDB 哦~</p><h2 id="获取集合"><a href="#获取集合" class="headerlink" title="获取集合"></a>获取集合</h2><p>所有准备工作完成之后，我们首先需要一个 MongoClient，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoClient client = <span class="hljs-keyword">new</span> MongoClient(<span class="hljs-string">"192.168.248.136"</span>, <span class="hljs-number">27017</span>);</span><br></pre></td></tr></table></figure><p>然后通过如下方式获取一个数据库，如果要获取的数据库本身就存在，直接获取到，不存在 MongoDB 会自动创建：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoDatabase sang = client.getDatabase(<span class="hljs-string">"sang"</span>);</span><br></pre></td></tr></table></figure><p>然后通过如下方式获取一个名为c1的集合，这个集合存在的话就直接获取到，不存在的话 MongoDB 会自动创建出来，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoCollection&lt;Document&gt; c = sang.getCollection(<span class="hljs-string">"c1"</span>);</span><br></pre></td></tr></table></figure><p>有了集合之后，我们就可以向集合中插入数据了。</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>和在 shell 中的操作一样，我们可以一条一条的添加数据，也可以批量添加，添加单条数据操作如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Document d1 = <span class="hljs-keyword">new</span> Document();</span><br><span class="line">d1.append(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义"</span>).append(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>);</span><br><span class="line">c.insertOne(d1);</span><br></pre></td></tr></table></figure><p>添加多条数据的操作如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Document&gt; collections = <span class="hljs-keyword">new</span> ArrayList&lt;Document&gt;();</span><br><span class="line">Document d1 = <span class="hljs-keyword">new</span> Document();</span><br><span class="line">d1.append(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义"</span>).append(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>);</span><br><span class="line">collections.add(d1);</span><br><span class="line">Document d2 = <span class="hljs-keyword">new</span> Document();</span><br><span class="line">d2.append(<span class="hljs-string">"name"</span>, <span class="hljs-string">"红楼梦"</span>).append(<span class="hljs-string">"author"</span>, <span class="hljs-string">"曹雪芹"</span>);</span><br><span class="line">collections.add(d2);</span><br><span class="line">c.insertMany(collections);</span><br></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>可以修改查到的第一条数据，操作如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.updateOne(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>), <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"$set"</span>, <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义123"</span>)));</span><br></pre></td></tr></table></figure><p>上例中小伙伴们也看到了修改器要如何使用，不管是 $set 还是 $inc，用法都一致，我这里不再一个一个演示。也可以修改查到的所有数据，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.updateMany(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>), <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"$set"</span>, <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义456"</span>)));</span><br></pre></td></tr></table></figure><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>可以删除查到的一条数据，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.deleteOne(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>));</span><br></pre></td></tr></table></figure><p>也可以删除查到的所有数据：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.deleteMany(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>));</span><br></pre></td></tr></table></figure><p>Filters 里边还有其他的查询条件，都是见名知意，不赘述。</p><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>可以直接查询所有文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FindIterable&lt;Document&gt; documents = c.find();</span><br><span class="line">MongoCursor&lt;Document&gt; iterator = documents.iterator();</span><br><span class="line"><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以按照条件查询：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FindIterable&lt;Document&gt; documents = c.find(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>));</span><br><span class="line">MongoCursor&lt;Document&gt; iterator = documents.iterator();</span><br><span class="line"><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的方法基本都是见名知意，这里不再赘述。</p><h2 id="验证问题"><a href="#验证问题" class="headerlink" title="验证问题"></a>验证问题</h2><p>上面我们演示的获取一个集合是不需要登录 MongoDB 数据库的，如果需要登录，我们获取集合的方式改为下面这种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServerAddress serverAddress = <span class="hljs-keyword">new</span> ServerAddress(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">27017</span>);</span><br><span class="line">List&lt;MongoCredential&gt; credentialsList = <span class="hljs-keyword">new</span> ArrayList&lt;MongoCredential&gt;();</span><br><span class="line">MongoCredential mc = MongoCredential.createScramSha1Credential(<span class="hljs-string">"readuser"</span>,<span class="hljs-string">"sang"</span>,<span class="hljs-string">"123"</span>.toCharArray());</span><br><span class="line">credentialsList.add(mc);</span><br><span class="line">MongoClient client = <span class="hljs-keyword">new</span> MongoClient(serverAddress,credentialsList);</span><br><span class="line">MongoDatabase sang = client.getDatabase(<span class="hljs-string">"sang"</span>);</span><br><span class="line">c = sang.getCollection(<span class="hljs-string">"c1"</span>);</span><br></pre></td></tr></table></figure><p>MongoCredential 是一个凭证，第一个参数为用户名，第二个参数是要在哪个数据库中验证，第三个参数是密码的 char 数组，然后将登录地址封装成一个 ServerAddress，最后将两个参数都传入 MongoClient 中实现登录功能。</p><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>在连接数据库的时候也可以设置连接超时等信息，在MongoClientOptions中设置即可，设置方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerAddress serverAddress = <span class="hljs-keyword">new</span> ServerAddress(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">27017</span>);</span><br><span class="line">List&lt;MongoCredential&gt; credentialsList = <span class="hljs-keyword">new</span> ArrayList&lt;MongoCredential&gt;();</span><br><span class="line">MongoCredential mc = MongoCredential.createScramSha1Credential(<span class="hljs-string">"rwuser"</span>,<span class="hljs-string">"sang"</span>,<span class="hljs-string">"123"</span>.toCharArray());</span><br><span class="line">credentialsList.add(mc);</span><br><span class="line">MongoClientOptions options = MongoClientOptions.builder()</span><br><span class="line">        <span class="hljs-comment">//设置连接超时时间为10s</span></span><br><span class="line">        .connectTimeout(<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>)</span><br><span class="line">        <span class="hljs-comment">//设置最长等待时间为10s</span></span><br><span class="line">        .maxWaitTime(<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>)</span><br><span class="line">        .build();</span><br><span class="line">MongoClient client = <span class="hljs-keyword">new</span> MongoClient(serverAddress,credentialsList,options);</span><br><span class="line">MongoDatabase sang = client.getDatabase(<span class="hljs-string">"sang"</span>);</span><br><span class="line">c = sang.getCollection(<span class="hljs-string">"c1"</span>);</span><br></pre></td></tr></table></figure><p>好了，Java 操作 MongoDB 我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们介绍的 MongoDB 的操作都是在 shell 命令中写的，在项目开发时我们当然都是用程序去操作 MongoDB 的，本文我们来看看如何用 Java 代码操作 MongoDB。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>初识 MongoDB 分片</title>
    <link href="http://www.javaboy.org/2019/0918/mongodb-shard.html"/>
    <id>http://www.javaboy.org/2019/0918/mongodb-shard.html</id>
    <published>2019-09-18T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:06.693Z</updated>
    
    <content type="html"><![CDATA[<p>分片是指将数据拆分，拆分后存放在不同的机器上的过程，以此来降低单个服务器的压力，同时也解决单个服务器硬盘空间不足的问题，让我们可以用廉价的机器实现高性能的数据架构。</p><a id="more"></a><p>有的小伙伴不理解分片和副本集的差异，一言以蔽之：副本集上每个备份节点存储的数据都是相同的，分片上存储的数据则是不同的。好了，本文我们就先来看看分片环境的搭建。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>准备三台已经装好了 MongoDB 的服务器，地址分别是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128</span><br><span class="line">192.168.248.135</span><br><span class="line">192.168.248.136</span><br></pre></td></tr></table></figure><p>本文使用的 MongoDB 版本为 3.4.9</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>首先我们需要三台配置服务器，配置服务器相当于集群的大脑，配置服务器中保存着集群和分片的元数据，即每个分片都包含了哪些数据信息，这些数据都是保存在配置服务器中的，我这里将开启三个配置服务器实例，这三个配置服务器将运行在三个 MongoDB 服务器上，地址分别如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128:20000</span><br><span class="line">192.168.248.135:20000</span><br><span class="line">192.168.248.136:20000</span><br></pre></td></tr></table></figure><p>接下来需要一个 Mongos 实例，Mongos 对请求进行路由，Mongos 扮演的角色有点类似于一个门面，我们以后访问的时候，直接访问 Mongos 即可，再由 Mongos 将请求路由到不同的分片上去，Mongos 在启动时会去访问配置服务器，它将从配置服务器中获取数据的存储信息，Mongos 我将启动在如下服务器上：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128:30000</span><br></pre></td></tr></table></figure><p>最后需要三个分片实例，三个分片依然运行在三台服务器上，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128:27017</span><br><span class="line">192.168.248.135:27017</span><br><span class="line">192.168.248.136:27017</span><br></pre></td></tr></table></figure><h2 id="搭建配置服务器"><a href="#搭建配置服务器" class="headerlink" title="搭建配置服务器"></a>搭建配置服务器</h2><p>配置服务器中不需要太多的空间和资源，因为配置服务器上保存的只是数据的分布表，不保存具体的数据，具体的数据都保存在分片上，配置服务器中 1KB 的空间约为 200MB 的真实数据。<strong>注意，从 MongoDB3.4 开始，配置服务器要做成集群的方式。</strong></p><p>由于配置服务器是独立的 mongod 进程，所以我们可以像启动普通的 MongoDB 服务一样启动配置服务器，只是这里的配置不同罢了。</p><p>我这里以 <code>192.168.248.128</code> 服务器为例来讲述配置服务器的配置启动，另外两台服务器如法炮制即可：</p><ol><li>在 mongodb 解压目录下创建 db20000 文件夹，用来存储配置服务器中的数据。</li><li>复制一份 mongodb.conf，命名为 mongodb20000.conf，修改文件内容如下：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/opt/mongodb/db20000</span><br><span class="line">logpath=/opt/mongodb/logs/mongodb20000.log</span><br><span class="line">port=20000</span><br><span class="line">fork=true</span><br><span class="line">configsvr=true</span><br><span class="line">replSet=rs</span><br></pre></td></tr></table></figure><p>注意 dbpath 改为我们第一步创建的目录，端口号改为 20000 （这个随意，只要该端口没被占用即可）， configsvr 表示这是一个配置服务器，另外由于我们的配置服务器要做成备份集，所以要设置 replSet。</p><p>3.做好前两步之后，执行如下命令启动配置服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /opt/mongodb/bin/mongodb20000.conf</span><br></pre></td></tr></table></figure><p>最后，在另外两台服务器上重复上面三个步骤。</p><p>三台服务器上都启动成功之后，参考我们之前的<a href>MongoDB 副本集搭建</a>一文，将这三台配置服务器配成一个副本集，副本集的配置我这里就不再赘述。</p><h2 id="搭建Mongos"><a href="#搭建Mongos" class="headerlink" title="搭建Mongos"></a>搭建Mongos</h2><p>Mongos 实例我们可以启动在任意一台服务器上，我这里就启动在 <code>192.168.248.128</code>上，Mongos 的配置步骤如下：</p><p>1.复制一份 mongodb.conf，命名为 mongos.conf，修改内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logpath=/opt/mongodb/logs/mongos.log</span><br><span class="line">port=30000</span><br><span class="line">fork=true</span><br><span class="line">configdb=rs/192.168.248.128:20000,192.168.248.135:20000,192.168.248.136:20000</span><br></pre></td></tr></table></figure><p>因为 mongos 中不需要保存数据，所以不需要 dbpath，端口号改为 30000，configdb 表示三个配置服务器的地址，注意最前面的 rs 表示配置服务器副本集的名称。</p><p>2.配置完成后，执行如下命令启动 mongos:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongos -f /opt/mongodb/bin/mongos.conf</span><br></pre></td></tr></table></figure><h2 id="搭建三个分片"><a href="#搭建三个分片" class="headerlink" title="搭建三个分片"></a>搭建三个分片</h2><p>三个分片实际上就是三个普通的 MongoDB 服务器，给大家看下我的配置文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/opt/mongodb/db</span><br><span class="line">logpath=/opt/mongodb/logs/mongodb.log</span><br><span class="line">port=27017</span><br><span class="line">fork=true</span><br><span class="line">shardsvr=true</span><br></pre></td></tr></table></figure><p>注意多了个 shardsvr 表示这是一个分片服务器。<br>然后在三台服务器上分别执行如下命令启动分片：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /opt/mongodb/bin/mongodb.conf</span><br></pre></td></tr></table></figure><h2 id="添加分片"><a href="#添加分片" class="headerlink" title="添加分片"></a>添加分片</h2><p>上面三个步骤完成之后，我们就进入到 mongos 的 shell 命令行了，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port=30000</span><br></pre></td></tr></table></figure><p>然后我们可以通过如下命令查看一下分片的当前状态：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.status()</span><br></pre></td></tr></table></figure><p>执行结果如下(部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">  databases:</span><br></pre></td></tr></table></figure><p>shards 表示分片服务器，目前还没有，databases 表示分片的库，目前也还没有，接下来我们通过如下命令添加分片服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh.addShard(&quot;192.168.248.128:27017&quot;)</span><br><span class="line">sh.addShard(&quot;192.168.248.135:27017&quot;)</span><br><span class="line">sh.addShard(&quot;192.168.248.136:27017&quot;)</span><br></pre></td></tr></table></figure><p>添加三个分片服务器，然后再执行 <code>sh.status()</code>,结果如下(部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;192.168.248.128:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;192.168.248.135:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0002&quot;,  &quot;host&quot; : &quot;192.168.248.136:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard0000&quot;,  &quot;partitioned&quot; : false &#125;</span><br></pre></td></tr></table></figure><h2 id="设置集合分片"><a href="#设置集合分片" class="headerlink" title="设置集合分片"></a>设置集合分片</h2><p>接下来我们来设置集合的分片，首先执行如下命令表示给某个数据库分片：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.enableSharding(&quot;sang&quot;)</span><br></pre></td></tr></table></figure><p>对集合分片时，需要选择一个片键，片键实际上就是集合中的一个键，MongoDB 将根据这个片键来拆分数据，我们需要先对片键建立索引，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.c1.ensureIndex(&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>然后以 x 为片键，对 c1 集合进行分片，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.shardCollection(&quot;sang.c1&quot;,&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>做完这些之后，再执行 <code>sh.status()</code> 命令，查看目前状态，结果如下(部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;192.168.248.128:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;192.168.248.135:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0002&quot;,  &quot;host&quot; : &quot;192.168.248.136:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard0000&quot;,  &quot;partitioned&quot; : false &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;sang&quot;,  &quot;primary&quot; : &quot;shard0001&quot;,  &quot;partitioned&quot; : true &#125;</span><br><span class="line">                sang.c1</span><br><span class="line">                        shard key: &#123; &quot;x&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard0001       1</span><br><span class="line">                        &#123; &quot;x&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;x&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard0001 Timestamp(1, 0)</span><br></pre></td></tr></table></figure><p>做完上面这些之后，我们再做两个操作：</p><p>1.设置自动分片：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.setBalancerState(true)</span><br></pre></td></tr></table></figure><p>2.设置 chunksize,chunksize 这一项是用来指定 chunk 的大小的，为了方便测试分片效果，我们把 chunksize 指定为 1MB，即当这个分片中插入的数据大于 1M 时开始进行数据分片</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.settings.save(&#123;_id:&quot;chunksize&quot;,value:1&#125;)</span><br></pre></td></tr></table></figure><p>OK，做好这些之后，大功告成。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试方式很简单，我们直接在 mongos 的命令行向 sang 的 c1 集合中插入 50000 条数据，然后再查看这些数据的分布，就知道分片有没有成功了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;50000;i++)&#123;db.c1.insert(&#123;x:Math.random()*1000000,name:&quot;hahah&quot;+i&#125;)&#125;</span><br></pre></td></tr></table></figure><p>然后执行 <code>db.c1.stats()</code> ,结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="hljs-attr">"sharded"</span> : <span class="hljs-literal">true</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">50000</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">2688890</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">1781760</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">1978368</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"nchunks"</span> : <span class="hljs-number">5</span>,</span><br><span class="line"><span class="hljs-attr">"shards"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"shard0000"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">926504</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">17229</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">462848</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">516096</span>,</span><br><span class="line"><span class="hljs-attr">"indexSizes"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"_id_"</span> : <span class="hljs-number">184320</span>,</span><br><span class="line"><span class="hljs-attr">"x_1"</span> : <span class="hljs-number">331776</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"ok"</span> : <span class="hljs-number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"shard0001"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">392593</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">7299</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">667648</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">737280</span>,</span><br><span class="line"><span class="hljs-attr">"indexSizes"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"_id_"</span> : <span class="hljs-number">253952</span>,</span><br><span class="line"><span class="hljs-attr">"x_1"</span> : <span class="hljs-number">483328</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"ok"</span> : <span class="hljs-number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"shard0002"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">1369793</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">25472</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">651264</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">724992</span>,</span><br><span class="line"><span class="hljs-attr">"indexSizes"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"_id_"</span> : <span class="hljs-number">237568</span>,</span><br><span class="line"><span class="hljs-attr">"x_1"</span> : <span class="hljs-number">487424</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"ok"</span> : <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，看到如上结果，说明我们的数据已经分布在三个分片服务器中了。</p><p>好了，MongoDB 中分片环境的搭建我们就先说到这里，小伙伴们有问题欢迎留言讨论。<br>参考资料：</p><ol><li>《MongoDB权威指南第2版》 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分片是指将数据拆分，拆分后存放在不同的机器上的过程，以此来降低单个服务器的压力，同时也解决单个服务器硬盘空间不足的问题，让我们可以用廉价的机器实现高性能的数据架构。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>一个小小的里程碑！啥也不说了，签名书奉上！</title>
    <link href="http://www.javaboy.org/2019/0917/official-accounts-20000.html"/>
    <id>http://www.javaboy.org/2019/0917/official-accounts-20000.html</id>
    <published>2019-09-17T05:06:41.000Z</published>
    <updated>2019-09-21T06:04:43.642Z</updated>
    
    <content type="html"><![CDATA[<p>就在昨天，松哥的公众号【江南一点雨】迎来了第 20000 个读者，算是一个小小的里程碑吧。</p><a id="more"></a><p>距离公众号读者到达 10000 差不多过去三个月了，3 个月时间，用户又增加了 10000，很多小伙伴可能不知道，我在今年 3 月份的时候，公众号的读者才只有 5200+，到现在差不多半年时间，用户增长了 15000，今天我想和大家聊聊我的运营故事。</p><p>故事很简单，无非就是<strong>死撑</strong>二字。</p><h3 id="漫不经心的开始"><a href="#漫不经心的开始" class="headerlink" title="漫不经心的开始"></a>漫不经心的开始</h3><p>我是在 2017 年 2 月 19 号申请的公众号，到 2019 年 1 月 31 号的时候，公众号的用户才终于突破 5000，这 5000+ 小伙伴基本上都是看了我的博客或者开源项目关注了我的公众号。我觉得早期关注我的小伙伴真的很不容易，因为那个时候，我公众号基本上都是连着更一两个月，然后又歇好几个月，歇几个月之后，又开始更，断断续续的，在这样的状态下还没有取关，真爱无疑。</p><p>这一段时间里，我没有专门去运营公众号，也是因为不懂公众号要怎么运营，公众号在我眼里就只是一个类似于 CSDN、sf 那样的博客发布平台而已，我甚至傻傻的想着通过公众号里边的阅读原文增加博客的访问量。不得不说，松哥在运营公众号这事上后知后觉没有一丁点的天赋。</p><p>基于这样不成熟的想法，这一段时间也谈不上坚持，就是顺其自然，心情好了发几篇，心情不好了就断更几个月。</p><h3 id="下定决心"><a href="#下定决心" class="headerlink" title="下定决心"></a>下定决心</h3><p>今年 3 月份，华为云组织了云享专家的线下活动，活动中认识了微笑哥（公众号：纯洁的微笑），活动结束后和微笑哥一起吃了个饭，听他讲做公众号的事，感觉很有意思，也极大的吸引到我。于是当天晚上回到家，我就下定决心今年要好好做我的公众号。</p><h3 id="小号的倔强"><a href="#小号的倔强" class="headerlink" title="小号的倔强"></a>小号的倔强</h3><p>下定决心后，真正要动手的时候，我却发现没有头绪。我只有 5000+ 读者，一篇原创技术干货只有 200 左右的阅读，怎么办？这时候是我最缺乏信心的时候，因为我也不知道我是否适合做这个事。虽然我从大学毕业那年就开始写博客，但是把公众号当成一件事认认真真去做，还是有些不够自信。</p><p>刚好那段时间，我写了一篇文章，回忆了一路坚持写博客，再到最后出书的历程(<a href="https://mp.weixin.qq.com/s/Lr5CwOSqYvx-JrFCSGf_Dw" target="_blank" rel="noopener">起早贪黑几个月，我写完了人生第一本书！</a>)，在写这篇文章的时候，我就在想，当初决定要写博客，其实也不知道写了之后有没有用，就是觉得时间不能浪费，于是就开干了，写博客这事是典型的坚持了之后才看到希望。那么做公众号是否也一样？把当初写博客的那股劲用到写公众号上，先坚持几个月，看看到底怎么样，就这样，我慢慢的说服了自己，不要怂，就是干。</p><p>做公众号虽然有很多运营技巧，但其实最关键的就是内容，没有内容，再多技巧都是白搭，对于像松哥这样的小号而言，内容就更显得重要了，所以我从一开始就下定决心，要坚持做原创，实际上从 2017 年到 2019 年 3 月份，我的公众号上基本都是原创技术干货，而且我几乎很少写零散的问题解决方案，基本上都是成体系的教程，例如：</p><ul><li><a href="https://mp.weixin.qq.com/s/RqGddTAfIxSZOhfkjqhMFg" target="_blank" rel="noopener">Spring Cloud 系列</a></li><li><a href="https://mp.weixin.qq.com/s/0Bukv4bFGMWosG8SWWoDDw" target="_blank" rel="noopener">Redis 系列</a></li><li><a href="https://mp.weixin.qq.com/s/WSloXbauYnecGTFWizH9HQ" target="_blank" rel="noopener">Git 系列</a></li><li><a href="https://mp.weixin.qq.com/s/8L-RMZorVAFVamzncVTQBw" target="_blank" rel="noopener">MongoDB 系列</a></li><li><a href="https://mp.weixin.qq.com/s/8d3OxnGX17ik1g7H_ocwIA" target="_blank" rel="noopener">Elasticsearch 系列</a></li><li><a href="https://mp.weixin.qq.com/s/bAL90MQvSM1SJsye_LQ5Nw" target="_blank" rel="noopener">Docker 系列</a></li></ul><p>这些系列教程都是我一个字一个字码出来的。于是我就想继续延续我公众号原创的这一优良传统。</p><p>于是，<strong>从今年 3 月份到现在，一共发了 106 篇原创</strong>，这些原创主要围绕 Spring Boot 和前后端分离来写的(例如 <a href="https://mp.weixin.qq.com/s/tm1IqiEvRZwDAb-F5yJ5Aw" target="_blank" rel="noopener">Spring Boot 系列</a>)，当然也有一个小小的 MyCat 系列，这些松哥以后都会给大家整理好。</p><p>由于一直坚持原创，公众号的阅读数也慢慢上来了，从 200 到 300、500、700、1000….直到现在的 2000 左右，不断增长的阅读给了我继续做下去的信心。</p><h3 id="全靠死撑"><a href="#全靠死撑" class="headerlink" title="全靠死撑"></a>全靠死撑</h3><p>然而写原创并不容易，特别是写出一篇皆大欢喜的原创更难。今天的文章发了，就得琢磨明天发啥，明天的准备好了，又得琢磨后天发发啥，每天晚上写到 12 点如同家常便饭，因为一篇文章不是把几百个字码出来就完事了，你要写案例，写 Demo，然后运行 Demo，截图保存，然后在文章中使用，这个过程费时费力，一篇原创干货往往要好几个小时才能出炉。</p><p>松哥写原创技术文最疯狂的时候，差不多连续两个月，篇篇原创，大家可以翻一下 4 月到 7 月的文章。那个时候我经常一坐好几个小时，坐久了腰疼屁股疼，最近买了个升降桌，情况才得以慢慢缓解。</p><p>松哥并不是全职做公众号，白天和大部分小伙伴一样，松哥也要上班，晚上回家后，除了写公众号上的技术文章之外，还有很多其他的事情要做。3-6 月份期间，应慕课网邀请，我和微笑哥一起在慕课网上出了一个 Spring Cloud 微服务开发实践 的专栏，那段时间，晚上除了写公众号，还要写专栏，周末也是一样。专栏在六月份完工之后，七月份松哥又开始录制 Spring Boot + 微人事 的视频教程，这个教程目前还在录制中，没有完工，所以我基本上没有什么业余活动，周末也是正常作息，时间都是一分一分抠出来的，除了偶尔去游个泳。</p><p>七月底的时候，实在是有点扛不住了，那段时间状态很差，做事效率也很低，但看着每天增长的数据，实在不忍心放弃，最终还是坚持了下来。</p><h3 id="不得不说的广告"><a href="#不得不说的广告" class="headerlink" title="不得不说的广告"></a>不得不说的广告</h3><p>做公众号这段时间，松哥前前后后算起来一共就接过 4 个商业广告，老实说，这个数字在我目前这个同量级的号主中算是很少了，很少的原因不是因为我接不到广告，相反，随着号越来越大，找上门的广告主其实挺多的，每天公众号后台都有很多广告主留言，只不过基本上都被我拒绝掉了。</p><p>但是有的时候松哥推荐其他号主，这个还是希望大家能理解，因为做公众号，或者说写一篇技术干货，从松哥的角度来说，当然是希望文章被越多的人看到越好，毕竟几个小时产出一篇技术干货，结果就十来个人看了，自己心里都凉透了，写作的动力也会减弱，而公众号本身是一个封闭的平台，通过其他号主的推荐，显然可以有效的将自己的文章曝光给更多的小伙伴，因此这个还是希望小伙伴们能多多理解。</p><h3 id="革命尚未成功，同志仍需努力"><a href="#革命尚未成功，同志仍需努力" class="headerlink" title="革命尚未成功，同志仍需努力"></a>革命尚未成功，同志仍需努力</h3><p>松哥经历过公司倒闭，技术栈也从当年如日中天的 Android 切换到如今的 JavaEE，深知这个行业虽然薪水高，但是高处不胜寒，技术之路不进则退，那些火爆一时的技术，让人眼花缭乱的薪水，极有可能冲昏你的头脑，当潮水退去，日子最难过的就是技术菜鸟了。所以，Coding 与学习之路不能停下来，这也是我一直坚持写博客的原因之一，写完一篇博客就会感觉到充实，要是长时间没写，会有很强烈的不安全感，似乎要被技术同行抛弃了。</p><p>自从松哥开始认真做公众号，也认识了很多同行，我最近发现 4 月份认识的公众号主有好几个人都停更了，说明做公众号这个事确实不易。很多时候你都不用拼智商、拼资源、拼人脉，靠死撑，就能够超过很多同行了。</p><p>当然我也希望自己能把做公众号这件事认真坚持下去。小伙伴平时看到了合胃口的文章，顺手点个在看我就很开心啦，如果还能转发一下，那松哥就要膨胀了。</p><p>好了，和大家又叨叨了这么多，最后，5 本松哥自己的签名书《Spring Boot + Vue 全栈开发实战》送给经常来公众号打卡的小伙伴。</p><p>送书规则：大家留言说说<strong>你坚持做的最久的一件事</strong>，我会挑选出 5 位幸运读者，签名版《Spring Boot + Vue 全栈开发实战》包邮到家。也欢迎各位小伙伴多来公众号打卡学习哦，可以有效提高送书时的获奖概率哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就在昨天，松哥的公众号【江南一点雨】迎来了第 20000 个读者，算是一个小小的里程碑吧。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB副本集其他细节</title>
    <link href="http://www.javaboy.org/2019/0917/mongodb-replicaset-details.html"/>
    <id>http://www.javaboy.org/2019/0917/mongodb-replicaset-details.html</id>
    <published>2019-09-17T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:13.050Z</updated>
    
    <content type="html"><![CDATA[<p>副本集环境的搭建以及一些基本的操作我们都了解了，本文我们来看看这个数据复制到底是怎么实现的。</p><a id="more"></a><h2 id="数据同步方式"><a href="#数据同步方式" class="headerlink" title="数据同步方式"></a>数据同步方式</h2><p>MongoDB 中的复制功能主要是使用操作日志 oplog.rs 来实现的，oplog.rs 包含了主节点的每一次写操作，oplog.rs 是主节点中 local 数据库的一个固定集合，我们可以通过如下命令查看到：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use local</span><br><span class="line">show tables</span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://www.javaboy.org/images/mongodb/17-1.png" alt="p254"></p><p>备份节点通过查询这个集合就知道要复制哪些数据，同时，每一个备份节点也都维护着自己的 oplog.rs，自己的 oplog.rs 则用来记录每一次从主节点复制数据的操作，如此，每一个备份节点都可以再作为数据源提供给其他成员使用，如果某一个备份节点在使用的过程中挂掉了，那么当它重启之后，会自动从 oplog.rs 的最后一个操作开始同步。</p><p>上文我们也已经说过 oplog.rs 是一个固定集合，我们可以通过 <code>db.getCollection(&#39;oplog.rs&#39;).stats()</code> 这个命令来查看这个固定集合的属性，包括集合大小等，执行部分结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"ns"</span> : <span class="hljs-string">"local.oplog.rs"</span>,</span><br><span class="line">    <span class="hljs-attr">"size"</span> : <span class="hljs-number">18170305</span>,</span><br><span class="line">    <span class="hljs-attr">"count"</span> : <span class="hljs-number">177443</span>,</span><br><span class="line">    <span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">102</span>,</span><br><span class="line">    <span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">5902336</span>,</span><br><span class="line">    <span class="hljs-attr">"capped"</span> : <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"max"</span> : <span class="hljs-number">-1</span>,</span><br><span class="line">    <span class="hljs-attr">"maxSize"</span> : <span class="hljs-number">1038090240</span>,</span><br><span class="line">    <span class="hljs-attr">"sleepCount"</span> : <span class="hljs-number">0</span>,</span><br><span class="line">    <span class="hljs-attr">"sleepMS"</span> : <span class="hljs-number">0</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是固定集合，它里边能够保存的数据大小就是有限的。通常，oplog.rs 使用空间的增长速度与系统处理处理写请求的速率近乎相同，比如主节点每分钟处理了 1KB 的写入请求，那么 oplog.rs 也可能会在一分钟内写入 1KB 条操作日志，但是如果主节点执行了批量删除的命令，比如下面这种：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.c1.deleteMany(&#123;x:&#123;$type:1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时每一个受影响的文档都会产生一条 oplog 中的日志，这个时候 oplog.rs 中的日志会快速增加。</p><h2 id="成员状态"><a href="#成员状态" class="headerlink" title="成员状态"></a>成员状态</h2><p>到目前为止我们了解到的成员状态有两种，一个是 PRIMARY ，还有一个是 SECONDDARY ，成员状态的获取需要靠心跳来维护，副本集中的每一个成员每隔两秒就会向其他成员发送一个心跳请求，用来检查成员的状态，成员的状态主要有如下几种：</p><h4 id="STARTUP"><a href="#STARTUP" class="headerlink" title="STARTUP"></a>STARTUP</h4><p>副本集中的成员刚刚启动时处于这个状态下，此时，MongoDB 会去加载成员的副本集配置，配置加载成功之后，就进入到 STARTUP2 的状态。</p><h4 id="STARTUP2"><a href="#STARTUP2" class="headerlink" title="STARTUP2"></a>STARTUP2</h4><p>整个初始化同步过程都处于这个状态。</p><h4 id="RECOVERING"><a href="#RECOVERING" class="headerlink" title="RECOVERING"></a>RECOVERING</h4><p>这个状态是由 STARTUP2 状态来的，此时成员运转正常，但是此时还不能处理读取请求。</p><h4 id="ARBITER"><a href="#ARBITER" class="headerlink" title="ARBITER"></a>ARBITER</h4><p>这是仲裁者所处的状态。</p><h4 id="DOWN"><a href="#DOWN" class="headerlink" title="DOWN"></a>DOWN</h4><p>当一个原本运行正常的成员无法访问到时，该成员就处于 DOWN 的状态。</p><h4 id="UNKNOWN"><a href="#UNKNOWN" class="headerlink" title="UNKNOWN"></a>UNKNOWN</h4><p>如果一个成员无法到达其他任何成员，该成员就处于 UNKNOWN 状态，比如我们利用 rs.add() 方法添加一个不存在的成员，这个成员的状态就是 UNKNOWN。</p><h4 id="REMOVED"><a href="#REMOVED" class="headerlink" title="REMOVED"></a>REMOVED</h4><p>成员被从副本集中移除时就变成这个状态。</p><h4 id="ROLLBACK"><a href="#ROLLBACK" class="headerlink" title="ROLLBACK"></a>ROLLBACK</h4><p>如果成员正在进行数据回滚，它就处于 ROLLBACK 状态，回滚结束后会转换为 RECOVERING 状态。</p><h4 id="FATAL"><a href="#FATAL" class="headerlink" title="FATAL"></a>FATAL</h4><p>当一个成员发生了不可挽回的错误时，且不再尝试恢复正常的话，就处于这个状态。</p><h2 id="主节点转备份节点"><a href="#主节点转备份节点" class="headerlink" title="主节点转备份节点"></a>主节点转备份节点</h2><p>通过如下命令可以让主节点转为备份节点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.stepDown()</span><br></pre></td></tr></table></figure><p>主节点转为备份节点之后会有新的主节点被选举出来，可以通过 rs.status() 来查看新的主节点。</p><h2 id="rs-status-方法"><a href="#rs-status-方法" class="headerlink" title="rs.status()方法"></a>rs.status()方法</h2><p>前面我们已经多次使用过 rs.status() 方法， rs.status() 方法会列出每个备份节点的含义，我们来看看这些参数的含义，先来列出一个 rs.status() 方法的返回值样例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;members&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;_id&quot; : 1,</span><br><span class="line">        &quot;name&quot; : &quot;192.168.248.135:27017&quot;,</span><br><span class="line">        &quot;health&quot; : 1,</span><br><span class="line">        &quot;state&quot; : 2,</span><br><span class="line">        &quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class="line">        &quot;uptime&quot; : 241,</span><br><span class="line">        &quot;optime&quot; : &#123;</span><br><span class="line">                &quot;ts&quot; : Timestamp(1509881297, 1),</span><br><span class="line">                &quot;t&quot; : NumberLong(16)</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;optimeDurable&quot; : &#123;</span><br><span class="line">                &quot;ts&quot; : Timestamp(1509881297, 1),</span><br><span class="line">                &quot;t&quot; : NumberLong(16)</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;optimeDate&quot; : ISODate(&quot;2017-11-05T11:28:17Z&quot;),</span><br><span class="line">        &quot;optimeDurableDate&quot; : ISODate(&quot;2017-11-05T11:28:17Z&quot;),</span><br><span class="line">        &quot;lastHeartbeat&quot; : ISODate(&quot;2017-11-05T11:28:18.073Z&quot;),</span><br><span class="line">        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-11-05T11:28:18.769Z&quot;),</span><br><span class="line">        &quot;pingMs&quot; : NumberLong(0),</span><br><span class="line">        &quot;syncingTo&quot; : &quot;192.168.248.136:27017&quot;,</span><br><span class="line">        &quot;configVersion&quot; : 15</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;_id&quot; : 3,</span><br><span class="line">        &quot;name&quot; : &quot;192.168.248.136:27017&quot;,</span><br><span class="line">        &quot;health&quot; : 1,</span><br><span class="line">        &quot;state&quot; : 1,</span><br><span class="line">        &quot;stateStr&quot; : &quot;PRIMARY&quot;,</span><br><span class="line">        &quot;uptime&quot; : 250,</span><br><span class="line">        &quot;optime&quot; : &#123;</span><br><span class="line">                &quot;ts&quot; : Timestamp(1509881297, 1),</span><br><span class="line">                &quot;t&quot; : NumberLong(16)</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;optimeDate&quot; : ISODate(&quot;2017-11-05T11:28:17Z&quot;),</span><br><span class="line">        &quot;electionTime&quot; : Timestamp(1509881276, 1),</span><br><span class="line">        &quot;electionDate&quot; : ISODate(&quot;2017-11-05T11:27:56Z&quot;),</span><br><span class="line">        &quot;configVersion&quot; : 15,</span><br><span class="line">        &quot;self&quot; : true</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>stateStr用来描述当前节点的状态。</li><li>uptime表示从成员可达到现在所经历的时间。</li><li>optimeDate表示每个成员的oplog中最后一个操作发生的时间。</li><li>lastHeartbeat表示当前服务器最后一次收到其他成员心跳的时间。</li><li>pingMs表示心跳从当前服务器到达某个成员所花费的平均时间。</li><li>syncingTo表示同步的数据源。</li><li>health表示该服务器是否可达，1表示可达，0表示不可达。</li></ol><h2 id="复制链问题"><a href="#复制链问题" class="headerlink" title="复制链问题"></a>复制链问题</h2><p>数据复制时可以从主节点直接复制，也可以从备份节点开始复制，从备份节点复制可以形成复制链，如果想禁止复制链，即所有的数据都从主节点复制，可以通过 chainingAllowed 属性来设置，具体步骤如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config=rs.config()</span><br><span class="line">config.settings.chainingAllowed=false</span><br><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><p>好了，MongoDB 中副本集的其他细节我们就先说到这里，小伙伴们有问题欢迎留言讨论。<br>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;副本集环境的搭建以及一些基本的操作我们都了解了，本文我们来看看这个数据复制到底是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 副本集配置</title>
    <link href="http://www.javaboy.org/2019/0916/mongodb-replicaset-settings.html"/>
    <id>http://www.javaboy.org/2019/0916/mongodb-replicaset-settings.html</id>
    <published>2019-09-16T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:18.751Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们搭建了 MongoDB 副本集的环境，验证了数据已经可以成功的复制，本文我们就来看看 MongoDB 副本集的其他操作。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>三台服务器，地址分别是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128</span><br><span class="line">192.168.248.135</span><br><span class="line">192.168.248.136</span><br></pre></td></tr></table></figure><p>按照上文介绍的步骤搭建副本集环境，这里不再赘述。</p><h2 id="副本集成员添加删除"><a href="#副本集成员添加删除" class="headerlink" title="副本集成员添加删除"></a>副本集成员添加删除</h2><p>在副本集环境搭建好之后，我们可以利用如下命令删除一个副本集成员：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.remove(&apos;192.168.248.128:27017&apos;)</span><br></pre></td></tr></table></figure><p>上面的命令执行完成后，我们可以通过 rs.status() 命令来查看是否删除成功，也可以通过如下命令来为副本集添加一个成员：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.add(&apos;192.168.248.128:27017&apos;)</span><br></pre></td></tr></table></figure><p>当然，副本集也是可以更新的，使用 reconfig 命令即可，如下：</p><p>首先定义 config，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config=&#123;_id:&quot;rs&quot;,members:[&#123;_id:3,host:&quot;192.168.248.128&quot;&#125;,&#123;_id:1,host:&quot;192.168.248.135&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>然后执行更新操作：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><p>我们也可以利用 config=rs.config() 获取原始的 config 文件，然后进行修改，修改之后再执行 rs.reconfig(config)，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config=rs.config()</span><br><span class="line">config.members[0].host=&quot;192.168.248.136&quot;</span><br><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><h2 id="选举仲裁者"><a href="#选举仲裁者" class="headerlink" title="选举仲裁者"></a>选举仲裁者</h2><p>在上文中给小伙伴们演示了主节点挂掉后的情况，和其他的(如 Redis )数据库主从复制不同，MongoDB 中主节点挂掉之后会自动从备份节点中选出一个新的主节点出来，这是一个选举的过程，投票选举，但是如果备份节点数为偶数的话，可能会出现两台服务器票数相等的情况，为了避免这种问题的出现，我们一般有两种解决方案：</p><blockquote><ol><li>数据节点为奇数个，这样就会避免上面描述的问题出现。</li><li>使用选举仲裁者，这是一种特殊的成员，仲裁者不保存数据，也不为客户端提供服务，只是在选举投票出现僵持时出来投个票，一个副本集中最多只能有一个仲裁者。</li></ol></blockquote><p>选举仲裁者占用的系统资源很小，因此对部署的服务器性能没多大要求，向副本集中添加仲裁者的方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.addArb(&apos;192.168.248.128:27017&apos;)</span><br></pre></td></tr></table></figure><p>也可以利用我们之前说的 reconfig 来操作：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config=rs.config()</span><br><span class="line">config.members[2]=&#123;_id:2,host:&apos;192.168.248.128&apos;,arbiterOnly:true&#125;</span><br><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><p>添加完成之后，我们可以通过 rs.status() 命令来查看是否添加成功，如果看到如下内容，表示添加成功：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="hljs-attr">"_id"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"name"</span> : <span class="hljs-string">"192.168.248.128:27017"</span>,</span><br><span class="line"><span class="hljs-attr">"health"</span> : <span class="hljs-number">1</span>,</span><br><span class="line"><span class="hljs-attr">"state"</span> : <span class="hljs-number">7</span>,</span><br><span class="line"><span class="hljs-attr">"stateStr"</span> : <span class="hljs-string">"ARBITER"</span>,</span><br><span class="line"><span class="hljs-attr">"uptime"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"lastHeartbeat"</span> : ISODate(<span class="hljs-string">"2017-11-03T08:56:12.406Z"</span>),</span><br><span class="line"><span class="hljs-attr">"lastHeartbeatRecv"</span> : ISODate(<span class="hljs-string">"2017-11-03T08:56:08.417Z"</span>),</span><br><span class="line"><span class="hljs-attr">"pingMs"</span> : NumberLong(<span class="hljs-number">1</span>),</span><br><span class="line"><span class="hljs-attr">"configVersion"</span> : <span class="hljs-number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仲裁者的移除和普通节点的移除是一样的，这里不再赘述。</p><h2 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h2><p>优先级用来描述一个备份节点成为主节点的优先性问题，优先级的取值范围为 [0-100]，默认为 1，数字越大优先级越高，越有可能成为主节点，0 表示该节点永远不能成为主节点。</p><p>我们可以在添加节点时指定优先级，如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.add(&#123;_id:0,host:&apos;192.168.248.128:27017&apos;,priority:2&#125;)</span><br></pre></td></tr></table></figure><p>也可以为已有的节点设置优先级：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config=rs.config()</span><br><span class="line">config.members[0].priority=99</span><br><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><p>好了，MongoDB 中副本集的配置我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们搭建了 MongoDB 副本集的环境，验证了数据已经可以成功的复制，本文我们就来看看 MongoDB 副本集的其他操作。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 副本集搭建</title>
    <link href="http://www.javaboy.org/2019/0915/mongodb-replicaset-install.html"/>
    <id>http://www.javaboy.org/2019/0915/mongodb-replicaset-install.html</id>
    <published>2019-09-15T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:29.385Z</updated>
    
    <content type="html"><![CDATA[<p>我们之前的案例都是在单个节点上实现的，在生产环境中这种做法是有风险的，如果服务宕机、崩溃或者硬盘坏了都会对公司业务造成损失，因此我们需要数据备份。</p><a id="more"></a><p>在 MongoDB 中我们可以通过副本集来实现这一需求，MongoDB 副本集 (Replica Set) 是有自动故障恢复功能的主从集群，有一个 Primary 节点和一个或多个 Secondary 节点组成，如果 Primary 崩溃了，会自动从 Secondary 中选择一个将其升级为新的主服务器，本文我们先来看看副本集环境的搭建。</p><h2 id="单台服务器模拟"><a href="#单台服务器模拟" class="headerlink" title="单台服务器模拟"></a>单台服务器模拟</h2><p>我们在实际的生产环境中肯定是多台服务器部署，但是在自己学习过程中，我们可以在一台服务器上来模拟这个环境，这样可以简化我们的操作，让小伙伴们快速上手。下一小节我会和大家分享如何在真实的生产环境中创建副本集。</p><p>好了，开始吧。</p><p>首先我们在 Linux 根目录下创建 /data/db 目录作为我们的数据保存目录，然后执行如下命令启动一个 mongo shell：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --nodb</span><br></pre></td></tr></table></figure><p>–nodb 表示启动时不连接任何数据库，然后通过如下命令创建一个副本集：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaSet=new ReplSetTest(&#123;nodes:3&#125;)</span><br></pre></td></tr></table></figure><p>在创建的日志中，我们可以看到三个实例的端口号，我这里分别是 20000、20001、20002，此时我们的副本集创建好了，但是并未启动，接下来执行如下命令启动三个 mongodb 实例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaSet.startSet()</span><br></pre></td></tr></table></figure><p>再执行如下命令配置复制功能：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaSet.initiate()</span><br></pre></td></tr></table></figure><p>这样环境基本就配好了，此时当前的 shell 不要关闭，我们重新打开一个 Linux 命令窗口，执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo 192.168.248.128:20000/sang_1</span><br></pre></td></tr></table></figure><p>表示连接端口为 20000 的那个实例中的 sang_1 数据库，连接成功后，我们可以执行如下命令查看当前实例的身份，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.isMaster()</span><br></pre></td></tr></table></figure><p>返回的数据很多，其中有一条是 <code>&quot;ismaster&quot; : true</code>，表示这是一个主节点，此时我们再分别打开两个 Linux 窗口，分别执行如下两条命令，进入另外两个节点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongo 192.168.248.128:20001/sang_1</span><br><span class="line">mongo 192.168.248.128:20002/sang_1</span><br></pre></td></tr></table></figure><p>连接成功之后，依然可以通过 <code>db.isMaster()</code> 命令来查看备份节点的身份，我们发现此时 <code>&quot;ismaster&quot; : false</code>，表示这是一个备份节点，此时我们可以先做个简单的测试了，此时我在主节点(端口为 20000)那个节点上写一个文档，写完之后，我们看看其他副本集成员上是否有我刚才的写的文档的副本，执行命令顺序如下：</p><p>主节点写入数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collect1.insert(&#123;x:&quot;hahaha&quot;&#125;)</span><br></pre></td></tr></table></figure><p>任意一个副本节点，先执行如下命令表示可以从备份节点读取数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.setSlaveOk()</span><br></pre></td></tr></table></figure><p>然后再在备份节点中执行如下命令读取数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collect1.find()</span><br></pre></td></tr></table></figure><p>此时，我们发现数据已经备份成功了。</p><p>如果此时我们尝试向备份节点中直接写入文档，会发现写入失败，这里需要注意备份节点中的数据都是备份来的，不可以直接写入，想写入，除非等它的身份转为主节点才可以。</p><p>此时，我们尝试通过如下命令关闭主节点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.shutdownServer()</span><br></pre></td></tr></table></figure><p>然后查看两个备份节点的 db.isMaster(),发现有一个备份节点自动上位成为了主节点。</p><p>最后如果想关闭副本集，可以回到第一个shell命令行中，输入如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaSet.stopSet()</span><br></pre></td></tr></table></figure><h2 id="多台服务器模拟"><a href="#多台服务器模拟" class="headerlink" title="多台服务器模拟"></a>多台服务器模拟</h2><p>OK，以上操作是我们单台服务器模拟搭建副本集，方便我们做实验，在生产环境中，我们可能有多个服务器，多台服务器又要如何搭建副本集呢？各位看官继续向下看。</p><p>首先准备好三台装好了MongoDB的服务器，地址分别如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128</span><br><span class="line">192.168.248.135</span><br><span class="line">192.168.248.136</span><br></pre></td></tr></table></figure><p>修改每台服务器的配置文件 mongodb.conf，添加 replSet=rs，表示副本集的名称，修改后的配置文件内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/opt/mongodb/db</span><br><span class="line">logpath=/opt/mongodb/logs/mongodb.log</span><br><span class="line">port=27017</span><br><span class="line">fork=true</span><br><span class="line">replSet=rs</span><br></pre></td></tr></table></figure><p>修改完成之后，分别启动三台服务器上的 MongoDB，启动成功之后，连接上任意一台的 shell，连接成功之后，先定义配置文件，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config=&#123;_id:&quot;rs&quot;,members:[&#123;_id:0,host:&quot;192.168.248.128:27017&quot;&#125;,&#123;_id:1,host:&quot;192.168.248.135:27017&quot;&#125;,&#123;_id:2,host:&quot;192.168.248.136:27017&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>id 后面跟着的是副本集的名称，也就是我们在 mongodb.conf 中定义的名称，后面三个是副本集的成员，定义好之后，再执行如下命令初始化副本集：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><p>初始化成功之后，我们就可以通过 rs.status() 来查看副本集的状态，也可以看到每个服务器的角色，部分日志内容如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="hljs-attr">"members"</span> : [</span><br><span class="line">&#123;</span><br><span class="line">        <span class="hljs-attr">"_id"</span> : <span class="hljs-number">0</span>,</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"192.168.248.128:27017"</span>,</span><br><span class="line">        <span class="hljs-attr">"health"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"state"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"stateStr"</span> : <span class="hljs-string">"PRIMARY"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">        <span class="hljs-attr">"_id"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"192.168.248.135:27017"</span>,</span><br><span class="line">        <span class="hljs-attr">"health"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"state"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"stateStr"</span> : <span class="hljs-string">"SECONDARY"</span>,</span><br><span class="line">        <span class="hljs-attr">"syncingTo"</span> : <span class="hljs-string">"192.168.248.128:27017"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">        <span class="hljs-attr">"_id"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"192.168.248.136:27017"</span>,</span><br><span class="line">        <span class="hljs-attr">"health"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"state"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"stateStr"</span> : <span class="hljs-string">"SECONDARY"</span>,</span><br><span class="line">        <span class="hljs-attr">"syncingTo"</span> : <span class="hljs-string">"192.168.248.128:27017"</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到每台服务器的角色，有 primary，也有 secondary，secondary 上还注明了从哪个服务器上同步数据。所有这些工作做好之后，我们就可以按照上文介绍的方式来测一下这里的副本集了，测试工作我就不再重复介绍了。</p><p>好了，MongoDB 中副本集的搭建我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们之前的案例都是在单个节点上实现的，在生产环境中这种做法是有风险的，如果服务宕机、崩溃或者硬盘坏了都会对公司业务造成损失，因此我们需要数据备份。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 中 MapReduce 使用</title>
    <link href="http://www.javaboy.org/2019/0914/mongodb-in-mapreduce.html"/>
    <id>http://www.javaboy.org/2019/0914/mongodb-in-mapreduce.html</id>
    <published>2019-09-14T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:40.159Z</updated>
    
    <content type="html"><![CDATA[<p>玩过 Hadoop 的小伙伴对 MapReduce 应该不陌生，MapReduce 的强大且灵活，它可以将一个大问题拆分为多个小问题，将各个小问题发送到不同的机器上去处理，所有的机器都完成计算后，再将计算结果合并为一个完整的解决方案，这就是所谓的分布式计算。本文我们就来看看 MongoDB 中 MapReduce 的使用。</p><a id="more"></a><h2 id="mapReduce"><a href="#mapReduce" class="headerlink" title="mapReduce"></a>mapReduce</h2><p>MongoDB 中的 MapReduce 可以用来实现更复杂的聚合命令，使用 MapReduce 主要实现两个函数：map 函数和 reduce 函数，map 函数用来生成键值对序列， map 函数的结果作为 reduce 函数的参数，reduce 函数中再做进一步的统计，比如我的数据集如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908d7"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"呐喊"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">38.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"人民文学出版社"</span>&#125;</span><br><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908d8"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"曹雪芹"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"红楼梦"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">22.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"人民文学出版社"</span>&#125;</span><br><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908d9"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"钱钟书"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"宋诗选注"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">99.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"人民文学出版社"</span>&#125;</span><br><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908da"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"钱钟书"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"谈艺录"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">66.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"三联书店"</span>&#125;</span><br><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908db"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"彷徨"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">55.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"花城出版社"</span>&#125;</span><br></pre></td></tr></table></figure><p>假如我想查询每位作者所出的书的总价，操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,this.price)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return Array.sum(value)&#125;</span><br><span class="line">var options=&#123;out:&quot;totalPrice&quot;&#125;</span><br><span class="line">db.sang_books.mapReduce(map,reduce,options);</span><br><span class="line">db.totalPrice.find()</span><br></pre></td></tr></table></figure><p>emit 函数主要用来实现分组，接收两个参数，第一个参数表示分组的字段，第二个参数表示要统计的数据，reduce 来做具体的数据处理操作，接收两个参数，对应 emit 方法的两个参数，这里使用了 Array 中的 sum 函数对 price 字段进行自加处理，options 中定义了将结果输出的集合，届时我们将在这个集合中去查询数据，默认情况下，这个集合即使在数据库重启后也会保留，并且保留集合中的数据。查询结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">22.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">165.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">93.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如我想查询每位作者出了几本书，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,1)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return Array.sum(value)&#125;</span><br><span class="line">var options=&#123;out:&quot;bookNum&quot;&#125;</span><br><span class="line">db.sang_books.mapReduce(map,reduce,options);</span><br><span class="line">db.bookNum.find()</span><br></pre></td></tr></table></figure><p>查询结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">2.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">2.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将每位作者的书列出来，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,&apos;)&#125;</span><br><span class="line">var options=&#123;out:&quot;books&quot;&#125;</span><br><span class="line">db.sang_books.mapReduce(map,reduce,options);</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"红楼梦"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"宋诗选注,谈艺录"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"呐喊,彷徨"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如查询每个人售价在 ￥40 以上的书：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,&apos;)&#125;</span><br><span class="line">var options=&#123;query:&#123;price:&#123;$gt:40&#125;&#125;,out:&quot;books&quot;&#125;</span><br><span class="line">db.sang_books.mapReduce(map,reduce,options);</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>query 表示对查到的集合再进行筛选。</p><p>结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"宋诗选注,谈艺录"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"彷徨"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="runCommand实现"><a href="#runCommand实现" class="headerlink" title="runCommand实现"></a>runCommand实现</h2><p>我们也可以利用 runCommand 命令来执行 MapReduce。格式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(</span><br><span class="line">               &#123;</span><br><span class="line">                 mapReduce: &lt;collection&gt;,</span><br><span class="line">                 map: &lt;function&gt;,</span><br><span class="line">                 reduce: &lt;function&gt;,</span><br><span class="line">                 finalize: &lt;function&gt;,</span><br><span class="line">                 out: &lt;output&gt;,</span><br><span class="line">                 query: &lt;document&gt;,</span><br><span class="line">                 sort: &lt;document&gt;,</span><br><span class="line">                 limit: &lt;number&gt;,</span><br><span class="line">                 scope: &lt;document&gt;,</span><br><span class="line">                 jsMode: &lt;boolean&gt;,</span><br><span class="line">                 verbose: &lt;boolean&gt;,</span><br><span class="line">                 bypassDocumentValidation: &lt;boolean&gt;,</span><br><span class="line">                 collation: &lt;document&gt;</span><br><span class="line">               &#125;</span><br><span class="line">             )</span><br></pre></td></tr></table></figure><p>含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">mapReduce</td><td style="text-align:left">表示要操作的集合</td></tr><tr><td style="text-align:left">map</td><td style="text-align:left">map函数</td></tr><tr><td style="text-align:left">reduce</td><td style="text-align:left">reduce函数</td></tr><tr><td style="text-align:left">finalize</td><td style="text-align:left">最终处理函数</td></tr><tr><td style="text-align:left">out</td><td style="text-align:left">输出的集合</td></tr><tr><td style="text-align:left">query</td><td style="text-align:left">对结果进行过滤</td></tr><tr><td style="text-align:left">sort</td><td style="text-align:left">对结果排序</td></tr><tr><td style="text-align:left">limit</td><td style="text-align:left">返回的结果数</td></tr><tr><td style="text-align:left">scope</td><td style="text-align:left">设置参数值，在这里设置的值在map、reduce、finalize函数中可见</td></tr><tr><td style="text-align:left">jsMode</td><td style="text-align:left">是否将map执行的中间数据由javascript对象转换成BSON对象，默认为false</td></tr><tr><td style="text-align:left">verbose</td><td style="text-align:left">是否显示详细的时间统计信息</td></tr><tr><td style="text-align:left">bypassDocumentValidation</td><td style="text-align:left">是否绕过文档验证</td></tr><tr><td style="text-align:left">collation</td><td style="text-align:left">其他一些校对</td></tr></tbody></table><p>如下操作，表示执行 MapReduce 操作并对统计的集合限制返回条数，限制返回条数之后再进行统计操作，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,&apos;)&#125;</span><br><span class="line">db.runCommand(&#123;mapreduce:&apos;sang_books&apos;,map,reduce,out:&quot;books&quot;,limit:4,verbose:true&#125;)</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"红楼梦"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"宋诗选注,谈艺录"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"呐喊"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，鲁迅有一本书不见了，就是因为 limit 是先限制集合返回条数，然后再执行统计操作。</p><p>finalize 操作表示最终处理函数，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function(key,reduceValue)&#123;var obj=&#123;&#125;;obj.author=key;obj.books=reduceValue; return obj&#125;</span><br><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,&apos;)&#125;</span><br><span class="line">db.runCommand(&#123;mapreduce:&apos;sang_books&apos;,map,reduce,out:&quot;books&quot;,finalize:f1&#125;)</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>f1 第一个参数 key 表示 emit 中的第一个参数，第二个参数表示 reduce 的执行结果，我们可以在 f1 中对这个结果进行再处理，结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"红楼梦"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"宋诗选注,谈艺录"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"呐喊,彷徨"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scope 则可以用来定义一个在 map、reduce 和 finalize 中都可见的变量，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function(key,reduceValue)&#123;var obj=&#123;&#125;;obj.author=key;obj.books=reduceValue;obj.sang=sang; return obj&#125;</span><br><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,--&apos;+sang+&apos;--,&apos;)&#125;</span><br><span class="line">db.runCommand(&#123;mapreduce:&apos;sang_books&apos;,map,reduce,out:&quot;books&quot;,finalize:f1,scope:&#123;sang:&quot;haha&quot;&#125;&#125;)</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"红楼梦"</span>,</span><br><span class="line">        <span class="hljs-attr">"sang"</span> : <span class="hljs-string">"haha"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"宋诗选注,--haha--,谈艺录"</span>,</span><br><span class="line">        <span class="hljs-attr">"sang"</span> : <span class="hljs-string">"haha"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"呐喊,--haha--,彷徨"</span>,</span><br><span class="line">        <span class="hljs-attr">"sang"</span> : <span class="hljs-string">"haha"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，MongoDB 中的 MapReduce 我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li><li><a href="http://www.cnblogs.com/xiazh/archive/2012/09/05/2671730.html" target="_blank" rel="noopener">mongodb mapreduce小试</a></li><li><a href="http://blog.csdn.net/gaopeng0071/article/details/42027745" target="_blank" rel="noopener">mongoDB–mapreduce用法详解(未找到原始出处)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;玩过 Hadoop 的小伙伴对 MapReduce 应该不陌生，MapReduce 的强大且灵活，它可以将一个大问题拆分为多个小问题，将各个小问题发送到不同的机器上去处理，所有的机器都完成计算后，再将计算结果合并为一个完整的解决方案，这就是所谓的分布式计算。本文我们就来看看 MongoDB 中 MapReduce 的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 管道操作符(二)</title>
    <link href="http://www.javaboy.org/2019/0913/mongodb-pipelines.html"/>
    <id>http://www.javaboy.org/2019/0913/mongodb-pipelines.html</id>
    <published>2019-09-13T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:45.538Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中我们已经学习了 MongoDB 中几个基本的管道操作符，本文我们再来看看其他的管道操作符。</p><a id="more"></a><h2 id="group"><a href="#group" class="headerlink" title="$group"></a>$group</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>$group 可以用来对文档进行分组，比如我想将订单按照城市进行分组，并统计出每个城市的订单数量：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,count:&#123;$sum:1&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>我们将要分组的字段传递给 $group 函数的 <code>_id</code> 字段，然后每当查到一个，就给 count 加 1，这样就可以统计出每个城市的订单数量。</p><h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>通过算术操作符我们可以对分组后的文档进行求和或者求平均数。比如我想计算每个城市订单运费总和，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,totalFreight:&#123;$sum:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>先按地址分组，再求和。这里贴出部分查询结果，如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"HaiKou"</span>,</span><br><span class="line">    <span class="hljs-attr">"totalFreight"</span> : <span class="hljs-number">20.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"HangZhou"</span>,</span><br><span class="line">    <span class="hljs-attr">"totalFreight"</span> : <span class="hljs-number">10.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以计算每个城市运费的平均数，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,avgFreight:&#123;$avg:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>先按地址分组，然后再计算平均数。</p><h3 id="极值操作符"><a href="#极值操作符" class="headerlink" title="极值操作符"></a>极值操作符</h3><p>极值操作符用来获取分组后数据集的边缘值，比如获取每个城市最贵的运费，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,maxFreight:&#123;$max:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>查询每个城市最便宜的运费：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,minFreight:&#123;$min:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>按城市分组之后，获取该城市第一个运费单：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,firstFreight:&#123;$first:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>获取分组后的最后一个运费单：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,lastFreight:&#123;$last:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据操作符"><a href="#数据操作符" class="headerlink" title="数据操作符"></a>数据操作符</h3><p>$addToSet 可以将分组后的某一个字段放到一个数组中，但是重复的元素将只出现一次，而且元素加入到数组中的顺序是无规律的，比如将分组后的每个城市的运费放到一个数组中，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,freights:&#123;$addToSet:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>重复的 freight 将不会被添加进来。</p><p>$push 则对重复的数据不做限制，都可以添加进来，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,freights:&#123;$push:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="unwind"><a href="#unwind" class="headerlink" title="$unwind"></a>$unwind</h2><p>$unwind 用来实现对文档的拆分,可以将文档中的值拆分为单独的文档，比如我的数据如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f93c8b8523cfae4cf4ba86"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"books"</span> : [ </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span> : <span class="hljs-string">"呐喊"</span>,</span><br><span class="line">            <span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"花城出版社"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span> : <span class="hljs-string">"彷徨"</span>,</span><br><span class="line">            <span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"南海出版出"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 $unwind 命令将其拆分为独立文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_books.aggregate(&#123;$unwind:&quot;$books&quot;&#125;)</span><br></pre></td></tr></table></figure><p>拆分结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f93c8b8523cfae4cf4ba86"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"books"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"呐喊"</span>,</span><br><span class="line">        <span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"花城出版社"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f93c8b8523cfae4cf4ba86"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"books"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"彷徨"</span>,</span><br><span class="line">        <span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"南海出版出"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h2><p>$sort 操作可以对文档进行排序，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$sort:&#123;orderAddressL:1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>用法和我们之前介绍普通搜索中的一致，可以按照存在的字段排序，也可以按照重命名的字段排序，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;oa:&quot;$orderAddressL&quot;&#125;&#125;,&#123;$sort:&#123;oa:-1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>1 表示升序、-1 表示降序。</p><p>$limit 返回结果中的前 n 个文档，如下表示返回结果中的前三个文档：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;oa:&quot;$orderAddressL&quot;&#125;&#125;,&#123;$limit:3&#125;)</span><br></pre></td></tr></table></figure><p>$skip 表示跳过前 n 个文档，比如跳过前 5 个文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;oa:&quot;$orderAddressL&quot;&#125;&#125;,&#123;$skip:5&#125;)</span><br></pre></td></tr></table></figure><p>$skip 的效率低，要慎用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在管道开始执行的阶段尽可能过滤掉足够多的数据，这样做有两个好处：</p><ol><li>只有从集合中直接查询时才会使用索引，尽早执行过滤可以让索引发挥作用；</li><li>该过滤的数据过滤掉之后，也可以降低后面管道的执行压力。另外，MongoDB 不允许一个聚合操作占用过多的内存，如果有一个聚合操作占用了超过 20% 的内存，则会直接报错。</li></ol><p>好了，MongoDB 中的管道操作符我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中我们已经学习了 MongoDB 中几个基本的管道操作符，本文我们再来看看其他的管道操作符。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 管道操作符(一)</title>
    <link href="http://www.javaboy.org/2019/0912/mongodb-pipelines.html"/>
    <id>http://www.javaboy.org/2019/0912/mongodb-pipelines.html</id>
    <published>2019-09-12T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:55.507Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉 Linux 操作系统的小伙伴们应该知道 Linux 中有管道的说法，可以用来方便的处理数据。</p><a id="more"></a><p>MongoDB2.2 版本也引入了新的数据聚合框架，一个文档可以经过多个节点组成的管道，每个节点都有自己特殊的功能，比如文档分组、文档过滤等，每一个节点都会接受一连串的文档，对这些文档做一些类型转换，然后将转换后的文档传递给下一个节点，最后一个节点则会将结果返回给客户端。本文我们就先来看几个基本的管道操作符。</p><h2 id="match"><a href="#match" class="headerlink" title="$match"></a>$match</h2><p>$match 可以用来对文档进行筛选，筛选完成之后我们就可以在筛选获得到的文档子集上来做数据聚合操作了，我们之前介绍的查询的操作符在 $match 中都可以使用，比如获取集合中所有 author 为”杜甫”的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$match:&#123;author:&quot;杜甫&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>我们在实际使用时最好将 $match 放在管道的前面，这样可以减少后面管道的工作量，同时，我们在投射和分组之前执行 $match 还可以用索引。</p><h2 id="project"><a href="#project" class="headerlink" title="$project"></a>$project</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>$project 可以用来 <strong> 提取想要的字段 </strong>，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;title:1,_id:0&#125;&#125;)</span><br></pre></td></tr></table></figure><p>1 表示要该字段，0 表示不要该字段，也可以对返回的字段进行 <strong> 重命名 </strong>，比如将 title 改为 articleTitle，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;&quot;articleTitle&quot;:&quot;$title&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>不过这里有一个问题需要注意，如果原字段上有索引，重命名之后的字段上就没有索引了，因此最好在重命名之前使用索引。</p><h3 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h3><p>数学表达式可以用来对一组数值进行加减乘除取模，比如我的数据结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;59f841f5b998d8acc7d08863&quot;),</span><br><span class="line">    &quot;orderAddressL&quot; : &quot;ShenZhen&quot;,</span><br><span class="line">    &quot;prodMoney&quot; : 45.0,</span><br><span class="line">    &quot;freight&quot; : 13.0,</span><br><span class="line">    &quot;discounts&quot; : 3.0,</span><br><span class="line">    &quot;orderDate&quot; : ISODate(&quot;2017-10-31T09:27:17.342Z&quot;),</span><br><span class="line">    &quot;prods&quot; : [ </span><br><span class="line">        &quot;可乐&quot;, </span><br><span class="line">        &quot;奶茶&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订单的总费用为商品费用加上运费，查询如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;totalMoney:&#123;$add:[&quot;$prodMoney&quot;,&quot;$freight&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>实际付款的费用是总费用减去折扣，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;totalPay:&#123;$subtract:[&#123;$add:[&quot;$prodMoney&quot;,&quot;$freight&quot;]&#125;,&quot;$discounts&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再来三个无厘头运算，比如计算 prodMoney 和 freight 和 discounts 的乘积：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test1:&#123;$multiply:[&quot;$prodMoney&quot;,&quot;$freight&quot;,&quot;$discounts&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再比如求 $prodMoney 和 $freight 的商，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test1:&#123;$divide:[&quot;$prodMoney&quot;,&quot;$freight&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再比如用 $freight 对 $prodMoney 取模，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test1:&#123;$mod:[&quot;$prodMoney&quot;,&quot;$freight&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>加法和乘法都可以接收多个参数，其余的都接收两个参数。</p><h3 id="日期表达式"><a href="#日期表达式" class="headerlink" title="日期表达式"></a>日期表达式</h3><p>日期表达式可以从一个日期类型中提取出年、月、日、星期、时、分、秒等信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;&quot;年份&quot;:&#123;$year:&quot;$orderDate&quot;&#125;,&quot;月份&quot;:&#123;$month:&quot;$orderDate&quot;&#125;,&quot;一年中第几周&quot;:&#123;$week:&quot;$orderDate&quot;&#125;,&quot;日期&quot;:&#123;$dayOfMonth:&quot;$orderDate&quot;&#125;,&quot;星期&quot;:&#123;$dayOfWeek:&quot;$orderDate&quot;&#125;,&quot;一年中第几天&quot;:&#123;$dayOfYear:&quot;$orderDate&quot;&#125;,&quot;时&quot;:&#123;$hour:&quot;$orderDate&quot;&#125;,&quot;分&quot;:&#123;$minute:&quot;$orderDate&quot;&#125;,&quot;秒&quot;:&#123;$second:&quot;$orderDate&quot;&#125;,&quot;毫秒&quot;:&#123;$millisecond:&quot;$orderDate&quot;&#125;,&quot;自定义格式化时间&quot;:&#123;$dateToString:&#123;format:&quot;%Y年%m月%d %H:%M:%S&quot;,date:&quot;$orderDate&quot;&#125;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f841f5b998d8acc7d08861"</span>),</span><br><span class="line">    <span class="hljs-attr">"年份"</span> : <span class="hljs-number">2017</span>,</span><br><span class="line">    <span class="hljs-attr">"月份"</span> : <span class="hljs-number">10</span>,</span><br><span class="line">    <span class="hljs-attr">"一年中第几周"</span> : <span class="hljs-number">44</span>,</span><br><span class="line">    <span class="hljs-attr">"日期"</span> : <span class="hljs-number">31</span>,</span><br><span class="line">    <span class="hljs-attr">"星期"</span> : <span class="hljs-number">3</span>,</span><br><span class="line">    <span class="hljs-attr">"一年中第几天"</span> : <span class="hljs-number">304</span>,</span><br><span class="line">    <span class="hljs-attr">"时"</span> : <span class="hljs-number">9</span>,</span><br><span class="line">    <span class="hljs-attr">"分"</span> : <span class="hljs-number">27</span>,</span><br><span class="line">    <span class="hljs-attr">"秒"</span> : <span class="hljs-number">17</span>,</span><br><span class="line">    <span class="hljs-attr">"毫秒"</span> : <span class="hljs-number">342</span>,</span><br><span class="line">    <span class="hljs-attr">"自定义格式化时间"</span> : <span class="hljs-string">"2017年10月31 09:27:17"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$dayOfWeek 返回的是星期，1 表示星期天，7 表示星期六，$week 表示本周是本年的第几周，从 0 开始计。$dateToString 是 MongoDB3.0+ 中的功能。格式化的字符还有以下几种：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">含义</th><th style="text-align:left">取值范围</th></tr></thead><tbody><tr><td style="text-align:left">%Y</td><td style="text-align:left">Year (4 digits, zero padded)</td><td style="text-align:left">0000-9999</td></tr><tr><td style="text-align:left">%m</td><td style="text-align:left">Month (2 digits, zero padded)</td><td style="text-align:left">01-12</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">Day of Month (2 digits, zero padded)</td><td style="text-align:left">01-31</td></tr><tr><td style="text-align:left">%H</td><td style="text-align:left">Hour (2 digits, zero padded, 24-hour clock)</td><td style="text-align:left">00-23</td></tr><tr><td style="text-align:left">%M</td><td style="text-align:left">Minute (2 digits, zero padded)</td><td style="text-align:left">00-59</td></tr><tr><td style="text-align:left">%S</td><td style="text-align:left">Second (2 digits, zero padded)</td><td style="text-align:left">00-60</td></tr><tr><td style="text-align:left">%L</td><td style="text-align:left">Millisecond (3 digits, zero padded)</td><td style="text-align:left">000-999</td></tr><tr><td style="text-align:left">%j</td><td style="text-align:left">Day of year (3 digits, zero padded)</td><td style="text-align:left">001-366</td></tr><tr><td style="text-align:left">%w</td><td style="text-align:left">Day of week (1-Sunday, 7-Saturday)</td><td style="text-align:left">1-7</td></tr><tr><td style="text-align:left">%U</td><td style="text-align:left">Week of year (2 digits, zero padded)</td><td style="text-align:left">00-53</td></tr></tbody></table><h3 id="字符串表达式"><a href="#字符串表达式" class="headerlink" title="字符串表达式"></a>字符串表达式</h3><p>字符串表达式中有字符串的截取、拼接、转大写、转小写等操作，比如我截取 orderAddressL 前两个字符返回，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;addr:&#123;$substr:[&quot;$orderAddressL&quot;,0,2]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再比如我将 orderAddressL 和 orderDate 拼接后返回：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;addr:&#123;$concat:[&quot;$orderAddressL&quot;,&#123;$dateToString:&#123;format:&quot;--%Y年%m月%d&quot;,date:&quot;$orderDate&quot;&#125;&#125;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f841f5b998d8acc7d08861"</span>),</span><br><span class="line">    <span class="hljs-attr">"addr"</span> : <span class="hljs-string">"NanJing--2017年10月31"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如我将 orderAddressL 全部转为小写返回：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;addr:&#123;$toLower:&quot;$orderAddressL&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再比如我将 orderAddressL 全部转为大写返回：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;addr:&#123;$toUpper:&quot;$orderAddressL&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>想要比较两个数字的大小，可以使用 $cmp 操作符，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$cmp:[&quot;$freight&quot;,&quot;$discounts&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果第一个参数大于第二个参数返回正数，第一个参数小于第二个则返回负数，也可以利用 $strcasecmp 来比较字符串（中文无效）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$strcasecmp:[&#123;$dateToString:&#123;format:&quot;..%Y年%m月%d&quot;,date:&quot;$orderDate&quot;&#125;&#125;,&quot;$orderAddressL&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>至于我们之前介绍的 $eq/$ne/$gt/$gte/$lt/$lte 等操作符在这里一样是适用的。另外还有 and、$or、$not 等表达式可用，以 $and 为例，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$and:[&#123;&quot;$eq&quot;:[&quot;$freight&quot;,&quot;$prodMoney&quot;]&#125;,&#123;&quot;$eq&quot;:[&quot;$freight&quot;,&quot;$discounts&quot;]&#125;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$and 中的每个参数都为 true 时返回 true，$or 则表示参数中有一个为 true 就返回 true，$not 则会对它的参数的值取反，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$not:&#123;&quot;$eq&quot;:[&quot;$freight&quot;,&quot;$prodMoney&quot;]&#125;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>另外还有两个流程控制语句，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$cond:[false,&quot;trueExpr&quot;,&quot;falseExpr&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$cond 第一个参数如果为 true，则返回 trueExpr，否则返回 falseExpr.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$ifNull:[null,&quot;replacementExpr&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$ifNull 第一个参数如果为 null，则返回 replacementExpr，否则就返回第一个参数。</p><p>好了，MongoDB 中的管道操作符我们就先说到这里，下篇文章继续，小伙伴们有问题欢迎留言讨论。<br>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li><li><a href="http://blog.csdn.net/u013066244/article/details/53842355" target="_blank" rel="noopener">mongodb聚合利用日期分组</a>  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟悉 Linux 操作系统的小伙伴们应该知道 Linux 中有管道的说法，可以用来方便的处理数据。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 固定集合</title>
    <link href="http://www.javaboy.org/2019/0911/mongodb-collections.html"/>
    <id>http://www.javaboy.org/2019/0911/mongodb-collections.html</id>
    <published>2019-09-11T02:17:28.000Z</published>
    <updated>2019-09-21T09:08:10.515Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下我们创建的集合是没有大小的，可以一直往里边添加文档，这种集合可以动态增长，MongoDB 中还有一种集合叫做固定集合，这种集合的大小是固定的，我可以在创建的时候设置该集合中文档的数目，假设为 100 条，当集合中的文档数目达到 100 条时，如果再向集合中插入文档，则只会保留最新的 100 个文档，之前的文档则会被删除。</p><a id="more"></a><p>一般像日志信息我们就可以使用固定集合，其他一些需要定期删除的数据也可以使用固定集合，本文我们就来看看这个固定集合的使用。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>固定集合的创建方式也比较简单，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&quot;my_collect&quot;,&#123;capped:true,size:10000,max:100&#125;)</span><br></pre></td></tr></table></figure><p>capped:true 参数表示该集合为一个固定大小集合，size 表示集合的大小，单位为 kb，max 则表示集合中文档的最大数量。我们这里相当于给了固定集合两个限制条件，只要有任意一个限制条件满足，集合都会开始将更古老的数据删除。固定集合一旦创建成功就不能再修改，想修改只能删除重来。此时我们可以尝试向集合中添加 120 条简单的数据，然后我们会发现最早的 20 条数据消失了。</p><p>除了直接创建一个固定集合外，我们也可以通过 convertToCapped 操作将一个普通集合转为一个固定集合，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123;convertToCapped:&quot;sang_collect&quot;,size:10&#125;)</span><br></pre></td></tr></table></figure><h2 id="自然排序问题"><a href="#自然排序问题" class="headerlink" title="自然排序问题"></a>自然排序问题</h2><p>自然排序就是按照文档在磁盘中的顺序来进行排列，在普通的集合中自然排序并没有多大的意义，因为文档的位置总是在变化，而固定集合中的文档是按照文档被插入的顺序保存的，自然顺序也就是文档的插入顺序，因此我们可以利用自然排序对文档从旧到新排序，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find().sort(&#123;$natural:1&#125;)</span><br></pre></td></tr></table></figure><p>也可以从新到旧排序：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find().sort(&#123;$natural:-1&#125;)</span><br></pre></td></tr></table></figure><p>固定集合中的其他操作和普通集合基本一致，这里就不再赘述。</p><p>好了，MongoDB 中的固定集合我们就说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下我们创建的集合是没有大小的，可以一直往里边添加文档，这种集合可以动态增长，MongoDB 中还有一种集合叫做固定集合，这种集合的大小是固定的，我可以在创建的时候设置该集合中文档的数目，假设为 100 条，当集合中的文档数目达到 100 条时，如果再向集合中插入文档，则只会保留最新的 100 个文档，之前的文档则会被删除。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 中各种类型的索引</title>
    <link href="http://www.javaboy.org/2019/0910/mongodb-index-types.html"/>
    <id>http://www.javaboy.org/2019/0910/mongodb-index-types.html</id>
    <published>2019-09-10T02:17:28.000Z</published>
    <updated>2019-09-21T09:05:21.741Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中我们介绍了 MongoDB 中索引的简单操作，创建、查看、删除等基本操作，不过上文我们只介绍了一种类型的索引，本文我们来看看其他类型的索引。</p><a id="more"></a><h2 id="id-索引"><a href="#id-索引" class="headerlink" title="_id 索引"></a>_id 索引</h2><p>我们在上文介绍过，我们往集合中添加文档时，默认情况下 MongoDB 都会帮助我们创建一个名为 <code>_id</code> 的字段，这个字段就是一个索引。默认情况下，一般的集合都会帮我们创建这个字段作为索引，但也有一些集合不会将 <code>_id</code> 默认作为索引，比如固定集合，这个我们后面的文章会详细说到这个问题。</p><h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>如果我们的查询条件有多个的话，我们可以对这多个查询条件都建立索引，比如我们可以对文档中的 x 和 y 字段都建立索引，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:1,y:-1&#125;)</span><br></pre></td></tr></table></figure><p>此时执行如下查询语句时就会用到这个复合索引：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:1,y:999&#125;)</span><br></pre></td></tr></table></figure><p>小伙伴们也可以通过查看查询计划来确定确实使用到了上文创建好的索引。</p><h2 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h2><p>顾名思义，过期索引就是一种会过期的索引，在索引过期之后，索引对应的数据会被删除，创建方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds:30&#125;)</span><br></pre></td></tr></table></figure><p>expireAfterSeconds 表示索引的过期时间，单位为秒。time 表示索引的字段，time 的数据类型必须是 ISODate 或者 ISODate 数组，否则的话，当索引过期之后，time 的数据就不会被删除。</p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>全文索引虽然好用，可惜不支持中文，我们这里就先做一个简单的了解。</p><p>比如，我的数据集如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a3da1f9e8e181ffc3189"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"Java C# Python PHP"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a3da1f9e8e181ffc318a"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"Java C#"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a3da1f9e8e181ffc318b"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"Java Python"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a3da1f9e8e181ffc318c"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"PHP Python"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a4541f9e8e181ffc318d"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"C C++"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以给 x 字段建立一个全文索引，创建方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:&quot;text&quot;&#125;)</span><br></pre></td></tr></table></figure><p>MongoDB 会自动对 x 字段的数据进行分词，然后我们就可以通过如下语句进行查询：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;Java&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时 x 中包含 Java 的文档都会被查询出来。如果想查询既包含 Java 又包含 C# 的文档，操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;\&quot;Java C#\&quot;&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>用一对双引号将查询条件括起来，如果想查询包含 PHP 或者 Python 的文档，操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;PHP Python&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果想查询既有 PHP，又有 Python，但是又不包括 Java 的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;PHP Python -Java&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>建立了全文索引之后，我们也可以查看查询结果的相似度，使用 $meta，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;PHP Python&quot;&#125;&#125;,&#123;score:&#123;$meta:&quot;textScore&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时查询结果中会多出一个 score 字段，该字段的值越大，表示相似度越高，我们可以根据 score 利用 sort 来对其进行排序，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;PHP Python&quot;&#125;&#125;,&#123;score:&#123;$meta:&quot;textScore&quot;&#125;&#125;).sort(&#123;score:&#123;$meta:&quot;textScore&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>全文索引目前看起来功能还是很强大，可惜暂时不支持中文，不过网上对此也有很多解决方案，小伙伴们可以自行搜索查看。</p><h2 id="地理空间索引"><a href="#地理空间索引" class="headerlink" title="地理空间索引"></a>地理空间索引</h2><h3 id="地理空间索引类型"><a href="#地理空间索引类型" class="headerlink" title="地理空间索引类型"></a>地理空间索引类型</h3><p>地理空间索引可以分为两类：</p><ol><li>2d 索引，可以用来存储和查找平面上的点。</li><li>2d sphere 索引，可以用来存储和查找球面上的点。</li></ol><h4 id="2d索引"><a href="#2d索引" class="headerlink" title="2d索引"></a>2d索引</h4><p>2d 索引一般我们可以用在游戏地图中。<br>向集合中插入一条记录点的数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.insert(&#123;x:[90,0]&#125;)</span><br></pre></td></tr></table></figure><p>插入数据的格式为[经度,纬度]，取值范围，经度 [-180,180]，纬度 [-90,90]。数据插入成功之后，我们先通过如下命令创建索引：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:&quot;2d&quot;&#125;)</span><br></pre></td></tr></table></figure><p>然后通过 $near 我们可以查询某一个点附近的点，如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$near:[90,0]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下返回该点附近 100 个点，我们可以通过 $maxDistance 来设置返回的最远距离：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$near:[90,0],$maxDistance:99&#125;&#125;)</span><br></pre></td></tr></table></figure><p>我们也可以通过 $geoWithin 查询某个形状内的点，比如查询矩形中的点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$box:[[0,0],[91,1]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>两个坐标点用来确定矩形的位置。</p><p>查询圆中的点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$center:[[0,0],90]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>参数分别表示圆的圆心和半径。</p><p>查询多边形中的点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$polygon:[[0,0],[100,0],[100,1],[0,1]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里可以填入任意多个点，表示多边形中的各个点。</p><h4 id="2d-sphere索引"><a href="#2d-sphere索引" class="headerlink" title="2d sphere索引"></a>2d sphere索引</h4><p>2dsphere 适用于球面类型的地图，它的数据类型是 GeoJSON 格式的，我们可以在 <a href="http://geojson.org/" target="_blank" rel="noopener">http://geojson.org/</a> 地址上查看 GeoJSON 格式的样式，比如我们描述一个点， GeoJSON 如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5e0571f9e8e181ffc3196"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"shenzhen"</span>,</span><br><span class="line">    <span class="hljs-attr">"location"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span> : <span class="hljs-string">"Point"</span>,</span><br><span class="line">        <span class="hljs-attr">"coordinates"</span> : [ </span><br><span class="line">            <span class="hljs-number">90.0</span>, </span><br><span class="line">            <span class="hljs-number">0.0</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述线，GeoJSON 格式如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5e0d01f9e8e181ffc3199"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"shenzhen"</span>,</span><br><span class="line">    <span class="hljs-attr">"location"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span> : <span class="hljs-string">"LineString"</span>,</span><br><span class="line">        <span class="hljs-attr">"coordinates"</span> : [ </span><br><span class="line">            [ </span><br><span class="line">                <span class="hljs-number">90.0</span>, </span><br><span class="line">                <span class="hljs-number">0.0</span></span><br><span class="line">            ], </span><br><span class="line">            [ </span><br><span class="line">                <span class="hljs-number">90.0</span>, </span><br><span class="line">                <span class="hljs-number">1.0</span></span><br><span class="line">            ], </span><br><span class="line">            [ </span><br><span class="line">                <span class="hljs-number">90.0</span>, </span><br><span class="line">                <span class="hljs-number">2.0</span></span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述多边形，GeoJSON 格式如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5e3f91f9e8e181ffc31d0"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"beijing"</span>,</span><br><span class="line">    <span class="hljs-attr">"location"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span> : <span class="hljs-string">"Polygon"</span>,</span><br><span class="line">        <span class="hljs-attr">"coordinates"</span> : [ </span><br><span class="line">            [ </span><br><span class="line">                [ </span><br><span class="line">                    <span class="hljs-number">0.0</span>, </span><br><span class="line">                    <span class="hljs-number">1.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="hljs-number">0.0</span>, </span><br><span class="line">                    <span class="hljs-number">2.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="hljs-number">1.0</span>, </span><br><span class="line">                    <span class="hljs-number">2.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="hljs-number">0.0</span>, </span><br><span class="line">                    <span class="hljs-number">1.0</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有其他的类型，具体小伙伴们可以参考 <a href="http://geojson.org/" target="_blank" rel="noopener">http://geojson.org/</a> 。有了数据之后，我们可以通过如下操作来创建地理空间索引了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;location:&quot;2dsphere&quot;&#125;)</span><br></pre></td></tr></table></figure><p>比如我想查询和深圳这个区域有交集的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var shenzhen = db.sang_collect.findOne(&#123;name:&quot;shenzhen&quot;&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$geoIntersects:&#123;$geometry:shenzhen.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里的查询结果是和深圳这个区域有交集的都会查到(比如经过深圳的高速公路、铁路等)，我们也可以只查询深圳市内的区域(比如深圳市内所有的学校)，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var shenzhen = db.sang_collect.findOne(&#123;name:&quot;shenzhen&quot;&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>也可以查询腾讯附近的其他位置，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var QQ = db.sang_collect.findOne(&#123;name:&quot;QQ&quot;&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$near:&#123;$geometry:QQ.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="复合地理空间索引"><a href="#复合地理空间索引" class="headerlink" title="复合地理空间索引"></a>复合地理空间索引</h3><p>位置往往只是我们查询的一个条件，比如我要查询深圳市内所有的学校，那我得再增加一个查询条件，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var shenzhen = db.sang_collect.findOne(&#123;name:&quot;shenzhen&quot;&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;,name:&quot;QQ&quot;&#125;)</span><br></pre></td></tr></table></figure><p>其他的查询条件跟在后面就行了。</p><p>好了，MongoDB 中的索引问题我们就说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中我们介绍了 MongoDB 中索引的简单操作，创建、查看、删除等基本操作，不过上文我们只介绍了一种类型的索引，本文我们来看看其他类型的索引。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
</feed>
