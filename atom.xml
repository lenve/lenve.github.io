<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="http://www.javaboy.org/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2024-12-20T02:56:47.773Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>几个必会的JDK性能监控和故障处理工具</title>
    <link href="http://www.javaboy.org/2024/1217/java-monitor-tools.html"/>
    <id>http://www.javaboy.org/2024/1217/java-monitor-tools.html</id>
    <published>2024-12-17T00:56:16.000Z</published>
    <updated>2024-12-20T02:56:47.773Z</updated>
    
    <content type="html"><![CDATA[<p>虽然阿里巴巴的 Arthas 这个工具很强大，不过如果你能够熟练使用 JDK 提供的工具，那么在不借助任何外力的情况下，就可以非常轻松的进行应用的性能监控和故障处理。</p><span id="more"></span><p>JDK 提供的工具，大家最熟悉的估计就是 java 和 javac 这两个了，然而 JDK 实际上提供了非常强大的性能监控和调试工具，今天松哥就来和大家一起捋一捋这些工具。</p><h1 id="一-jps"><a href="#一-jps" class="headerlink" title="一 jps"></a>一 jps</h1><p>这个应该是大家最为熟悉的工具了，使用这个命令可以快速列出来系统上正在运行的 Java 进程。</p><p>这个命令在执行的时候一般有四个参数：</p><ul><li>-q 表示只输出进程 ID，不输出主类名称，准确来说，这里输出的叫做本地虚拟机进程 ID（LVMID），不过对于本地虚拟机进程来说，LVMID 和操作系统的进程 ID 是一致的。</li><li>-l 表示输出主类的全名，如果进程执行的是 jar 包，那么就输出 jar 包的完整路径。</li><li>-m 表示输出进程启动时传递给 main() 函数的参数。</li><li>-v 表示输出进程启动时的 JVM 参数。</li></ul><p><img src="http://img.itboyhub.com/2024/mp/20241212193059.png"></p><h1 id="二-jstat"><a href="#二-jstat" class="headerlink" title="二 jstat"></a>二 jstat</h1><p>jstat 是用来监控虚拟机各种运行状态信息的命令行工具，这个工具可以用来查看本地或者远程虚拟机内存、垃圾收集、即时编译等等信息。</p><p>一般来说，这些数据我们可以借助可视化工具来查看，例如 JMC 或者 VisualVM 等等，但是有时候在服务器环境下，在命令行环境下没法运行 GUI 图形界面，那么此时 jstat 是一个不错的选择。</p><p>jstat 运行参数比较多，松哥这里列举几个比较常见的参数：</p><ul><li>-class 这个表示监视类加载、卸载数量、总空间以及类装载所耗费的时间。</li></ul><p><img src="http://img.itboyhub.com/2024/mp/20241212194029.png"></p><ul><li>-gc 这个表示监视 Java 堆状况，包括 Eden 区，两个 Survivor 区、老年代以及永久带的容量，已使用的空间以及垃圾收集时间合计等等信息。</li></ul><p><img src="http://img.itboyhub.com/2024/mp/20241213095014.png"></p><p>命令中的 <code>1s 8</code> 表示每秒打印一次，一共打印 8 次，如果不设置，则打印一次。</p><p>这里输出的各参数含义如下：</p><blockquote><p>S0C：Survivor0 的容量。<br>S1C：Survivor1 的容量。<br>S0U：Survivor0 已使用大小。<br>S1U：Survivor1 已使用大小。<br>EC：Eden 区容量。<br>EU：Eden 区已使用大小。<br>OC：老年代容量。<br>OU：老年代已使用大小。<br>MC：元数据区容量。<br>MU：元数据区已使用大小。<br>CCSC：压缩类空间容量。<br>CCSU：压缩类空间已使用大小。<br>YGC：年轻代垃圾回收次数。<br>YGCT：年轻代垃圾回收总耗时。<br>FGC：FullGC 次数。<br>FGCT：FullGC 总耗时。<br>CGC：GC STW 的次数。<br>CGCT：GC STW 的时间。<br>GCT：总 GC 时间。</p></blockquote><p>基本上我们想知道的关于 JVM 运行内存状态的信息，这里都有了。</p><ul><li>-gccapacity 这个监控内容与 -gc 类似，不过输出内容主要关注 Java 堆各个区域使用到的最大最小空间。</li></ul><p><img src="http://img.itboyhub.com/2024/mp/20241213102714.png"></p><p>这里涉及到的参数我也和大家稍微解释下：</p><blockquote><p>NGCMN：新生代最小容量。<br>NGCMX：新生代最大容量。<br>NGC：新生代当前容量。<br>OGCMN：老年代最小容量。<br>OGCMX：老年代最大容量。<br>OGC：老年代当前容量。<br>MCMN：元空间最小容量。<br>MCMX：元空间最大容量。<br>CCSMN：压缩类空间最小容量。<br>CCSMX：压缩类空间最大容量。<br>CCSC：压缩类空间当前容量。</p></blockquote><p>补充输出内容和前面一致的我就不重复解释了。</p><ul><li>-gcutil 这个和 -gc 类似，不过输出的内容主要关注已使用的空间占总空间的比例。</li></ul><p><img src="http://img.itboyhub.com/2024/mp/20241213144018.png"></p><blockquote><p>S0：Survivor0 区使用比例。<br>S1：Survivor1 区使用比例。<br>E：Eden 区使用比例。<br>O：老年代使用比例。<br>M：元空间使用比例。<br>CCS：压缩类空间使用比例。</p></blockquote><p>这块能加的参数实际上非常多，对于我们来说比较常用的主要就是上面这几个命令。</p><p>如果小伙伴们想要查看完整指令，可以参考官方文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html">https://docs.oracle.com/en/java/javase/11/tools/jstat.html</a></p><h1 id="三-jinfo"><a href="#三-jinfo" class="headerlink" title="三 jinfo"></a>三 jinfo</h1><p>jinfo 命令可以实时查看和<strong>修改</strong> JVM 各项参数。</p><p>能修改这就很牛了。</p><p>平时我们启动一个 Java 项目，一旦启动之后，如果想要知道项目启动时的各项 JVM 参数，那么就只能去查文档了。但是如果你能够熟练使用 jinfo，那么这个事情就容易很多了。</p><p><img src="http://img.itboyhub.com/2024/mp/20241213145547.png"></p><p>直接 <code>jinfo pid</code> 就会展示出来所有的 JVM 参数。</p><p>如果只想查看某一个 JVM 参数，那么可以使用如下命令：</p><p><code>jinfo -flag CICompilerCount 28893</code></p><p><img src="http://img.itboyhub.com/2024/mp/20241213145744.png"></p><p>也可以在不重启 JVM 参数的情况下，动态修改 JVM 参数。</p><p>例如松哥这里的案例，原本是没有开启 PrintClassHistogram 的，我现在动态开启：</p><p><img src="http://img.itboyhub.com/2024/mp/20241213150553.png"></p><p>PrintClassHistogram 前面没有符号，表示查看当前状态；PrintClassHistogram 前面有个 <code>+</code> 表示开启；PrintClassHistogram 前面有个 <code>-</code> 表示关闭。</p><p>这种方式是修改 value 为 boolean 的 JVM 参数，如果是 key-value 格式的 JVM 参数，那么可以按照下面这种方式修改：</p><p><img src="http://img.itboyhub.com/2024/mp/20241213151012.png"></p><p>当然这个修改并非所有的 JVM 参数都能改，至于哪些 JVM 参数能改，我们可以执行 <code>java -XX:+PrintFlagsInitial</code> 命令，找到标记为 manageable 的参数，这些参数是可以动态修改的。</p><p><img src="http://img.itboyhub.com/2024/mp/20241213151246.png"></p><p>另外我们在代码中通过 <code>System.getProperties()</code> 获取到的属性，也可以通过指令打印出来：</p><p><code>jinfo -sysprops 57002</code></p><p><img src="http://img.itboyhub.com/2024/mp/20241213151523.png"></p><h1 id="四-jmap"><a href="#四-jmap" class="headerlink" title="四 jmap"></a>四 jmap</h1><p>jmap 命令一般可以用来生成 heapdump。</p><p>这个命令在新版本 JDK 中运行的时候，前面要加上 jhsdb。</p><p><img src="http://img.itboyhub.com/2024/mp/20241213204434.png"></p><p>从这里我们可以解读出哪些信息呢？</p><ul><li>可以看到最大可分配的 Heap 大小（MaxHeapSize）</li><li>可以看到 JVM 启动时分配的新生代内存（NewSize）</li><li>可以看到可分配的最大新生代内存（MaxNewSize）</li><li>可以看到 JVM 启动时分配的老年代大小（OldSize）</li><li>可以看到老年代和新生代的内存比例（NewRatio），上面截图中表示 <code>老/新=2</code>，即老年代占 2&#x2F;3，新生代占 1&#x2F;3。</li><li>可以看到新生代中 Eden 区和一个 Survivor 区的比例（SurvivoRatio）</li><li>可以看到初始的 Metaspace 大小（MetaspaceSize）</li><li>可以看到最大的 Metaspace 大小（MaxMetaspaceSize）</li><li>可以看到在 G1 收集器下，每个 Region 的大小（G1HeapRegionSize）</li></ul><p>下面的这些就好理解了，分别是不同区域的 regions 数量、总空间、使用空间以及空闲空间。</p><p>也可以利用 jmap 查看 Heap 中对象的统计信息，比如对象的数量、占用内存的大小以及类的完整路径。</p><p><code>jmap -histo:live pid</code></p><p>加上 <code>:live</code> 表示查看活着的对象信息。</p><p><img src="http://img.itboyhub.com/2024/mp/20241213211442.png"></p><p>也可以查看 Heap 中元空间的类加载信息 <code>jmap -clstats 28893</code>。</p><p><img src="http://img.itboyhub.com/2024/mp/20241213211600.png"></p><p>这里可以看到有哪些类加载器，分别加载了哪些类。</p><p>当然，最重要的功能是生成 dump 文件了：</p><p><img src="http://img.itboyhub.com/2024/mp/20241213213358.png"></p><p>这里几个参数说明一下：</p><ul><li>live 表示只转存堆中活动对象，如果没有制定，则存所有对象。</li><li>format&#x3D;b 表示以 hprof 二进制格式转存。</li><li>file&#x3D;xxx 表示生成的文件名。</li></ul><p>生成的文件，可以使用 idea 打开查看。</p><blockquote><p>小技巧：获取 heapdump 还有哪些方式？</p><ol><li>使用 kill -3 吓一吓 JVM，就能拿到堆转储快照。</li><li>-XX:HeapDumpOnOutOfMemoryError 参数可以让虚拟机在内存溢出时自动生成堆转储快照。</li></ol></blockquote><h1 id="五-jhat"><a href="#五-jhat" class="headerlink" title="五 jhat"></a>五 jhat</h1><p>这个工具目前已经废弃了。</p><p>松哥这里就简单说下这个工具的作用以及替代品。</p><p>前面 jmap 会生成 heapdump 文件，这是一个二进制文件，那么我们通过什么工具去分析这个文件呢？比如可以使用 Eclipse 的 MAT，当然现在 IDEA 也可以直接打开这个文件分析，这块成熟的工具还是非常多的。</p><p>那么 jhat 其实也是一个这样的工具，jhat 内置了一个微型的 Web 服务器，让开发者可以在浏览器中查看相关数据。但是因为 jhat 功能比较简陋，所以目前已经废弃了。</p><h1 id="六-jstack"><a href="#六-jstack" class="headerlink" title="六 jstack"></a>六 jstack</h1><p>jstack 可以查看 JVM 当前时刻的线程快照。</p><p>如果某个线程执行比较耗时，或者发生死锁，发生死循环等，那么就可以通过这个指令来查看各个线程的调用堆栈，检查到底发生了什么问题。</p><p><img src="http://img.itboyhub.com/2024/mp/20241214200245.png"></p><p><code>-l</code> 表示出了堆栈之外，也把锁的相关信息显示出来。</p><p>不过这个命令松哥并不常用。因为 Thread 中有一个 getAllStackTraces 方法，我们通过 jstack 命令获取到的信息基本上通过这个方法都能获取到，所以可以自己结合这个方法写监控页面查看相关信息。</p><p>前面这个命令都是命令行工具，除了这些命令行工具之外，也有一些可视化工具，这个咱们下篇文章继续。</p><p>说到 JDK 工具，就不得不提这本 Java 虚拟机大作了《深入理解 Java 虚拟机》。</p><p>这本书的作者周志明博士是资深 Java 技术专家，对虚拟机技术有深入研究，这本《深入理解 Java 虚拟机》累计印刷超过 40 次，销量超过 30 万册，成为原创计算机专业图书领域的一个里程碑。</p><p>这本书将 Java 虚拟机（JVM）剖析得非常透彻，对于理解 JVM 的内存管理、垃圾收集、性能监控与故障排除等方面提供了清晰的指导。它不仅适合于面试准备，也能帮助解决工作中的实际问题。书中不仅讲解了理论知识，还通过大量实际案例分析，展示了如何解决各种 Java 技术难题。</p><p>全书一共分为五个部分，详细介绍了 Java 技术体系的发展、内存管理机制、虚拟机执行子系统、程序编译优化以及 Java 虚拟机对并发的支持。每一部分都与实际开发紧密相关，有助于读者将理论应用于实践。</p><p>无论是初学者还是有经验的开发者，都能从这本书中获得新的感悟和深入的理解。对于想要深入了解 JVM 的 Java 程序员来说，这本书被认为是“圣书”。</p><p><img src="http://img.itboyhub.com/2024/mp/20241217103837.png"></p><p>今天得到机械工业出版社的赞助，我们一共送出 5 本《深入理解 Java 虚拟机》，小伙伴们随便留言，我会选出来 5 位幸运小伙伴，这本书包邮到家！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然阿里巴巴的 Arthas 这个工具很强大，不过如果你能够熟练使用 JDK 提供的工具，那么在不借助任何外力的情况下，就可以非常轻松的进行应用的性能监控和故障处理。&lt;/p&gt;</summary>
    
    
    
    <category term="JDK" scheme="http://www.javaboy.org/categories/JDK/"/>
    
    
    <category term="JDK" scheme="http://www.javaboy.org/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>九道深信服面试题</title>
    <link href="http://www.javaboy.org/2024/1209/sangfor-interview.html"/>
    <id>http://www.javaboy.org/2024/1209/sangfor-interview.html</id>
    <published>2024-12-09T00:56:03.000Z</published>
    <updated>2024-12-20T02:58:16.323Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴反馈的最近面试深信服遇到的几个“棘手”问题，松哥来和大家简单聊一聊。</p><span id="more"></span><h2 id="一-MySQL-只有-CPU-高，怎么优化"><a href="#一-MySQL-只有-CPU-高，怎么优化" class="headerlink" title="一 MySQL 只有 CPU 高，怎么优化"></a>一 MySQL 只有 CPU 高，怎么优化</h2><p>这道问题是当发现 MySQL 的 CPU 飙高，该如何优化？从哪些方面思考入手。</p><p>数据库优化是个大学问，对症下药尤为重要。</p><p>如果是 CPU 飙高的话，我们首先可以通过 <code>SHOW PROCESSLIST;</code> 来查看正在运行的线程，类似下面这样：</p><p><img src="http://img.itboyhub.com/2024/mp/20241205181142.png"></p><p>接下来可以根据这个表格进行排查。</p><p>首先找到 Time 这列，找出来 Time 执行时间过长的 SQL。</p><p>接下来查看这条 SQL 的 State，根据 State 的提示我们可以做出不同的决策。</p><p>例如：</p><ul><li>State 为 Locked 就表示当前操作被其他查询锁住了。</li><li>State 为 Sending Data 就表示正在处理 SELECT 查询记录，同时正在把结果发送给客户端。</li><li>State 为 Sleeping 表示正在等待客户端发送新请求。</li><li>…</li></ul><p>还有很多状态，面试时候能回答常见的几个即可。</p><p>在这个检查中，我们可能会发现存在的一些死锁、或者是由于无索引&#x2F;索引不合理导致的搜索速度变慢，我们可以根据实际情况解决。</p><p>另外有时候我们在执行 <code>SHOW PROCESSLIST;</code> 之后，可能会发现 Command 中存在很多 Sleep，这就说明当前连接数过多，这也会影响到 MySQL 的执行效率。</p><p>那么对于这种问题，我们可以设置等待超时时间，超时之后自动断开，配置方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">wait_timeout=20 ## 大于20秒自动断开 (根据实际情况设置)</span><br></pre></td></tr></table></figure><p>配置完成后重启 MySQL。</p><p>如果不想重启 MySQL 解决这个问题，可以使用如下两条命令去解决：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置超时等待时间</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> wait_timeout<span class="operator">=</span><span class="number">60</span>;</span><br><span class="line"># 查看设置效果</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;wait_timeout&#x27;</span>;</span><br></pre></td></tr></table></figure><p>设置完成之后，再去检查 CPU 使用率是否有下降。</p><h2 id="二-MySQL-本身缓存怎么优化"><a href="#二-MySQL-本身缓存怎么优化" class="headerlink" title="二 MySQL 本身缓存怎么优化"></a>二 MySQL 本身缓存怎么优化</h2><p>这个题目据小伙伴描述，有一个限制条件就是 MySQL 自身的缓存如何优化，而不是问外部缓存（如 Redis）优化问题，并且面试官也强调了他们使用的是 MySQL5.7。</p><p>为什么强调是 MySQL5.7 呢？因为在最新版的 MySQL8 中，查询缓存已经不再支持了。</p><blockquote><p>查询缓存存储了 SELECT 语句的文本，以及发送给客户端的相应结果。如果后来收到一个相同的语句，服务器会从查询缓存中检索结果，而不是再次解析和执行该语句。查询缓存是在会话之间共享的，因此一个客户端产生的结果集可以被用来响应另一个客户端发出的相同查询。如果你有一些不经常变化的表，而服务器收到许多相同的查询，查询缓存在这样的环境中很有用。</p></blockquote><p>所以咱就说说 MySQL5.7 中的查询缓存吧。</p><p>首先要确认下查询缓存是否开启了，在 MySQL5.7.2 中，查询缓存默认是关闭状态，查询方式如下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241205194532.png"></p><p>如果是关闭状态，我们可以在配置文件中添加如下属性来开启：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type<span class="operator">=</span><span class="number">1</span></span><br><span class="line">query_cache_size<span class="operator">=</span><span class="number">16</span>M</span><br></pre></td></tr></table></figure><p>接下来执行 <code>show status like &#39;qcache%&#39;;</code> 命令来查看缓存相关信息：</p><p><img src="http://img.itboyhub.com/2024/mp/20241205194901.png"></p><p>那么这里有一个参数值得关注：</p><ul><li>Qcache_free_blocks：这个表示查询缓存中目前还有多少剩余的 blocks，如果该值显示较大，则说明查询缓存中的内存碎片过多了，可能需要对内存进行整理了，整理可以使用 <code>flush query cache</code> 指令。</li></ul><p>减少内存碎片的一个方案就是在 MySQL 的配置文件中设置合适的 <code>query_cache_min_res_unit</code>，这个就是最小的内存分配单元。一般来说，可以将其设置为缓存平均内存大小，缓存平均大小的计算方式是这样：</p><p>(<code>query_cache_size</code>-<code>Qcache_free_memory</code>)&#x2F;<code>Qcache_queries_in_cache</code></p><p>设置完成后可以再运行一段时间观察内存碎片是否有减少。</p><h2 id="三-类的加载过程"><a href="#三-类的加载过程" class="headerlink" title="三 类的加载过程"></a>三 类的加载过程</h2><p>这个前面文章讲过了，这里不再赘述。</p><ul><li><a href="https://mp.weixin.qq.com/s/73ehlcfUdpG27TLhYdnTpA">Java类是如何加载的？</a></li></ul><h2 id="四-硬件配置提升了，反而-OOM"><a href="#四-硬件配置提升了，反而-OOM" class="headerlink" title="四 硬件配置提升了，反而 OOM"></a>四 硬件配置提升了，反而 OOM</h2><p>具体问题是说硬件配置原本是 2C4G，后来升级为 8C16G，升级之后反而发生了 OOM，硬件升级前没问题。</p><p>老实说这个问题松哥还没想出来一个合理的解释，如果单是 8C16G 的硬件配置发生 OOM，这个简单，问题是 2C4G 可以正常运行，8C16G 却 OOM。。。</p><p>这道题欢迎小伙伴们在评论区给出自己的见解～</p><h2 id="五-JMeter-关注哪些信息"><a href="#五-JMeter-关注哪些信息" class="headerlink" title="五 JMeter 关注哪些信息"></a>五 JMeter 关注哪些信息</h2><p>JMeter 我们经常用它做压测，那么在压测结束后主要关注哪些指标信息呢？</p><ul><li>Samples&#x2F;样本：这个就是请求总数，比如并发是 100，循环次数是 100，那么样本数就是 <code>100*100</code>。</li><li>Average&#x2F;平均值：这个是平均响应时间。</li><li>Error&#x2F;异常：测试出现的错误请求数量百分比。</li><li>Throughput&#x2F;吞吐量：这个就是每秒处理的事务数，一般与具体的事务相关。如果这个值大于并发数，那么可以尝试增加并发数后再次测试，如果增加了并发数该值反而下降，那就说明并发数达到峰值了。</li></ul><p>一般主要关注这几个指标。</p><h2 id="六-线程池核心数怎么配置"><a href="#六-线程池核心数怎么配置" class="headerlink" title="六 线程池核心数怎么配置"></a>六 线程池核心数怎么配置</h2><p>通用公式是：</p><ul><li>CPU 密集型：N+1</li><li>IO 密集型：2N+1</li></ul><p>不过这种答案面试官一般不会满意。</p><p>一般线程池核心数我们可以根据实际情况进行计算后配置，例如我们可以统计一个完整的请求中，耗费 CPU 计算的过程占用了多少时间，等待的过程（例如读取缓存、读取 DB 等）占用了多少时间，假设我们的统计结果是 100ms 用来做 CPU 计算，900ms 都是 IO 相关不占 CPU 时间，那么我们就可以通过 <code>(100+900)/100</code> 的计算公式，得出，对于单核 CPU，设置线程数为 10 可以把 CPU 跑满，同理，如果是 8 核 CPU，那么就设置线程数为 80。</p><h2 id="七-无监控，不调优"><a href="#七-无监控，不调优" class="headerlink" title="七 无监控，不调优"></a>七 无监控，不调优</h2><p>这道问题是接着上面一道题问的，面试官表示线程池线程数的设置是个难题，他希望能够动态调整线程池线程数，并能够看到调整后的效果（线程利用率），问有无这样的工具能够实现这样的效果。</p><p>这个问题松哥在前面的文章中和大家聊过了，参见：</p><ul><li><a href="https://mp.weixin.qq.com/s/fJlXWsd5AThhxiMHTyzv5w">如何动态调试线程池？</a></li></ul><h2 id="八-有无具体用过-Arthas"><a href="#八-有无具体用过-Arthas" class="headerlink" title="八 有无具体用过 Arthas"></a>八 有无具体用过 Arthas</h2><p>这个问题其实很好回答，但是如果你从来没用过 Arthas，那么不妨看下松哥的这篇文章，虽然讲的是插件，但是插件生成的命令也和大家详细解释了：</p><ul><li><a href="https://mp.weixin.qq.com/s/PCJF22JR_AeKanDZUYXY4Q">Arthas命令太难记了？安利一个IDEA插件！</a></li></ul><h2 id="九-IP-配置问题"><a href="#九-IP-配置问题" class="headerlink" title="九 IP 配置问题"></a>九 IP 配置问题</h2><p>局域网内有两台设备，其中一个 IP 地址是 192.168.1.100，另一个 IP 地址是 192.168.2.100，如何让这两台设备在局域网通信？</p><p>这个问题在网络领域里边属于入门级问题，但是很多人长期做软件开发有可能忘记了网络知识，就导致回答不出来。</p><p>这个主要是配置一下子网掩码，设置子网掩码为 <code>255.255.0.0</code>，这样就能确保如上两个 IP 处于同一个网段中，就可以通信了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有小伙伴反馈的最近面试深信服遇到的几个“棘手”问题，松哥来和大家简单聊一聊。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="http://www.javaboy.org/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://www.javaboy.org/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何动态调试线程池？</title>
    <link href="http://www.javaboy.org/2024/1207/jmx-thread-pool.html"/>
    <id>http://www.javaboy.org/2024/1207/jmx-thread-pool.html</id>
    <published>2024-12-07T00:55:51.000Z</published>
    <updated>2024-12-20T02:58:13.051Z</updated>
    
    <content type="html"><![CDATA[<p>这是有小伙伴最近在面深信服的时候遇到的一个问题，感觉比较有意思，松哥和大伙来聊一聊。</p><span id="more"></span><blockquote><p>如何动态调试线程池？</p></blockquote><p>面试官表示设置线程池核心线程数是一个非常具有挑战性的事情，问有无办法能够动态的设置线程池核心数，并观察其执行效果？</p><p>这个问题的难点在于它涉及到的技术点不是特别常用，该小伙伴面试的技术团队刚好是做运维工具的，做一些监控软件，所以刚好就问到这里。</p><p>那么松哥和大家简单聊一聊这个话题。</p><p>其实这里主要是涉及到 Java 里边一个比较古老的工具，JMX。</p><h1 id="一-什么是-JMX"><a href="#一-什么是-JMX" class="headerlink" title="一 什么是 JMX"></a>一 什么是 JMX</h1><p>JMX（Java Management Extensions）是 Java 平台的一部分，它提供了一种管理和监控 Java 应用程序的标准方法。JMX 允许你监控和管理系统资源、应用程序和服务，以及获取关于这些实体的运行时信息。</p><blockquote><p>简单来说，就是通过 JMX 可以动态查看对象的运行信息，并且可以动态修改对象属性。</p></blockquote><p>JMX 架构如下图：</p><p><img src="http://img.itboyhub.com/2024/mp/20241206172116.png"></p><p>分析这张图我们可以发现，JMX 底层是由很多不同的 MBeans 组成的，MBeans 是 JMX 的核心，它们是实现了特定接口的 Java 对象，用于表示可以被监控和管理的资源。MBeans 可以分为四种不同的类型，分别是：</p><ul><li>Standard MBeans</li><li>Dynamic MBeans</li><li>Open MBeans</li><li>Model MBeans</li></ul><p>这些 MBeans 的作用就是获取对象的信息，或者是修改对象信息，都是通过 MBeans 来完成的。</p><p>所有的 MBeans 都需要注册到 MBeanServer 上，然后再通过一些外部工具如 JMX、Web 浏览器等等，就可以去获取或者修改 MBeans 的信息了。</p><p>这里的 MBean Server 是一个代理，它提供了一个注册、检索和操作 MBeans 的 API。它是 JMX 架构中的核心组件，负责管理所有 MBeans 的生命周期。</p><h1 id="二-代码实践"><a href="#二-代码实践" class="headerlink" title="二 代码实践"></a>二 代码实践</h1><p>接下来松哥通过一个简单的案例，来和大家演示一下如何通过 JMX + jconsole 工具实现动态修改线程池信息。</p><p>首先我们先来自定义一个动态线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">        threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">getThreadPoolExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCorePoolSize</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaximumPoolSize</span><span class="params">(<span class="type">int</span> maximumPoolSize)</span> &#123;</span><br><span class="line">        threadPoolExecutor.setMaximumPoolSize(maximumPoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个动态线程池实际上就是把我们传统的线程池对象 ThreadPoolExecutor 封装了一下，并且提供了两个方法 setCorePoolSize 和 setMaximumPoolSize，通过这两个方法我们可以动态设置线程池的线程数。</p><p>接下来我们自定义一个 MBean 接口，这个接口中提供四个方法，分别用来获取或者设置线程数的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DynamicThreadPoolMXBean</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCorePoolSize</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setCorePoolSize</span><span class="params">(<span class="type">int</span> corePoolSize)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getMaximumPoolSize</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setMaximumPoolSize</span><span class="params">(<span class="type">int</span> maximumPoolSize)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们自定义类实现 DynamicThreadPoolMXBean 接口，并继承 StandardMBean 类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicThreadPoolMBean</span> <span class="keyword">extends</span> <span class="title class_">StandardMBean</span> <span class="keyword">implements</span> <span class="title class_">DynamicThreadPoolMXBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DynamicThreadPool dynamicThreadPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicThreadPoolMBean</span><span class="params">(DynamicThreadPool dynamicThreadPool)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>(DynamicThreadPoolMXBean.class);</span><br><span class="line">        <span class="built_in">this</span>.dynamicThreadPool = dynamicThreadPool;</span><br><span class="line">        registerMBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerMBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MBeanServer</span> <span class="variable">mbs</span> <span class="operator">=</span> ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">            <span class="type">ObjectName</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectName</span>(<span class="string">&quot;org.javaboy:type=DynamicThreadPool&quot;</span>);</span><br><span class="line">            mbs.registerMBean(<span class="built_in">this</span>, name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCorePoolSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dynamicThreadPool.getThreadPoolExecutor().getCorePoolSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCorePoolSize</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        dynamicThreadPool.setCorePoolSize(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaximumPoolSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dynamicThreadPool.getThreadPoolExecutor().getMaximumPoolSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaximumPoolSize</span><span class="params">(<span class="type">int</span> maximumPoolSize)</span> &#123;</span><br><span class="line">        dynamicThreadPool.setMaximumPoolSize(maximumPoolSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类也没啥神奇的地方，唯一要注意的是，在构造器中，我们调用了 registerMBean 方法，这个方法用来将当前对象注册到 MBeanServer 上。</p><p>最后，我们就可以启动自己的这段代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DynamicThreadPool</span> <span class="variable">dynamicThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicThreadPool</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="type">DynamicThreadPoolMBean</span> <span class="variable">mBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicThreadPoolMBean</span>(dynamicThreadPool);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;CorePoolSize:&quot;</span> + dynamicThreadPool.getThreadPoolExecutor().getCorePoolSize());</span><br><span class="line">            System.out.println(<span class="string">&quot;MaximumPoolSize:&quot;</span> + dynamicThreadPool.getThreadPoolExecutor().getMaximumPoolSize());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了看到线程池的线程数量，我这里使用了一个死循环不停的打印线程数量信息，这样一会通过 jconsole 修改线程池信息的时候，我们就能看到修改的效果了。</p><p>程序启动之后，我们使用 jconsole 连接上当前应用程序，如下图：</p><p><img src="http://img.itboyhub.com/2024/mp/20241206181648.png"></p><p>在 MBeans 这个选项卡位置，我们可以看到刚刚配置的 MBean，右侧的 value 则可以直接修改，修改之后，回到应用程序控制台，我们会发现线程相关数据已经发生变化了。</p><p><img src="http://img.itboyhub.com/2024/mp/20241206181915.png"></p><p>可以看到，控制台信息已经发生变化。</p><p>上面完整的案例代码，可以在公众号后台回复 <code>dynamic_thread_pool</code> 获取。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是有小伙伴最近在面深信服的时候遇到的一个问题，感觉比较有意思，松哥和大伙来聊一聊。&lt;/p&gt;</summary>
    
    
    
    <category term="JMX" scheme="http://www.javaboy.org/categories/JMX/"/>
    
    
    <category term="线程池" scheme="http://www.javaboy.org/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    <category term="JMX" scheme="http://www.javaboy.org/tags/JMX/"/>
    
  </entry>
  
  <entry>
    <title>Java类是如何加载的？</title>
    <link href="http://www.javaboy.org/2024/1205/class-load.html"/>
    <id>http://www.javaboy.org/2024/1205/class-load.html</id>
    <published>2024-12-05T00:55:32.000Z</published>
    <updated>2024-12-20T02:58:19.384Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>有小伙伴最近在面试过程中遇到这样一个问题：</p><span id="more"></span><blockquote><p>Java 中的类是如何加载的？</p></blockquote><p>这个问题还是很有意思，今天松哥来尝试和大伙梳理一下。</p><h1 id="一-整体思路"><a href="#一-整体思路" class="headerlink" title="一 整体思路"></a>一 整体思路</h1><p>整体上来说，类的加载主要是下面这几个步骤：</p><p><img src="http://img.itboyhub.com/2024/mp/20241205085648.png"></p><p>上面这张图就是一个类的完整生命周期了，一共要经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）七个不同的步骤。</p><p>这七个步骤中，验证、准备和解析一般又统一称之为 Linking。</p><p>这是整体的流程，接下来，松哥就和大家来分析每一个具体的步骤都干了啥。</p><h1 id="二-Loading"><a href="#二-Loading" class="headerlink" title="二 Loading"></a>二 Loading</h1><p>首先第一步 Loading，也就是加载类。</p><p>这里如果被面试官细问，有两个方向：</p><ol><li>什么时候加载？</li><li>怎么加载？</li></ol><h2 id="2-1-类的加载时机"><a href="#2-1-类的加载时机" class="headerlink" title="2.1 类的加载时机"></a>2.1 类的加载时机</h2><p>先说类的加载时机。</p><p>如果需要一个权威的文档来说明问题，抱歉，官方没有任何文档来说明类在什么时候会被加载。但是，官方文档给出了六种类必须进行初始化的场景，毫无疑问，如果需要对类进行初始化，那么就必须先 Loading。</p><p>这六种场景分别是：</p><ol><li>new 一个类或者使用某一个类的静态属性&#x2F;静态方法，给某个类的静态属性赋值等等，不过对于被 final 修饰的的 static 变量除外。</li><li>通过反射调用某个类的时候。</li><li>当要初始化某个类，但是发现其父类尚未初始化，那么就要去初始化父类（如果一个接口在初始化的时候发现其父类未初始化，这个时候并不会初始化其父类，只有在真正用到了其父类的时候，才会初始化）。</li><li>main 方法所在的主类。</li><li>对于含有 default 方法的接口，如果该接口的实现类需要进行初始化，那么就会触发该类的加载。</li><li>最后一种情况和动态语言相关的，跟我们 Java 关系不大，这里就不讨论了（因为 Java 虚拟机不仅能跑 Java，也能跑 Groovy、Kotlin 等，所以虚拟机支持的内容会更加广泛一些）。</li></ol><p>只有这六种场景会触发类的初始化，凡是不符合这六种情况的，都不会触发类的初始化。</p><p>这是类的加载时机问题。</p><h2 id="2-2-类的加载步骤"><a href="#2-2-类的加载步骤" class="headerlink" title="2.2 类的加载步骤"></a>2.2 类的加载步骤</h2><p>那么怎么加载呢？这就涉及到类加载的双亲委派问题，这个问题网上有很多文章介绍，内容本身也不算难，这里松哥就不啰嗦了。</p><p>通过双亲委派找到具体的类加载器之后，接下来就要开始执行加载了。</p><p>加载主要干三件事。</p><ol><li>通过类的全限定名来获取定义该类的二进制字节流。</li></ol><blockquote><p>全限定名也就是类的全路径，例如 org.javaboy.HelloWorld 这种，通过这个名字去获取类的二进制字节流。去哪里获取呢？可以从磁盘上获取，这是我们最容易想到的，除了从磁盘上获取之外，也可以从网络获取，甚至可以在运行时通过动态计算生成，我们所熟知的 Java 动态代理就属于这种情况。</p></blockquote><ol start="2"><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p></li><li><p>在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。</p></li></ol><h1 id="三-Linking"><a href="#三-Linking" class="headerlink" title="三 Linking"></a>三 Linking</h1><p>Linking 这个环节分为三个步骤，分别是：</p><ol><li>Verification</li><li>Preparing</li><li>Resolution</li></ol><p>我们分别来看。</p><h2 id="3-1-Verification"><a href="#3-1-Verification" class="headerlink" title="3.1 Verification"></a>3.1 Verification</h2><p>验证这个环节就要就是检查输入的二进制字节流是否符合要求。</p><p>正常来说，我们的 Java 代码写完之后会进行编译，有问题的话，编译阶段就报错了，等不到类加载阶段。</p><p>不过由于 JVM 读取的二进制字节流不一定是通过 Java 源代码编译后获取到的，也有可能是其他语言编译得到的，甚至可能有某个大神直接用二进制编辑器 0、1、0、1 这样敲出来的，所以站在 JVM 的角度，必须要对输入的二进制流进行校验，确保读取的数据没有问题。</p><p>验证的内容主要有这些：</p><ol><li>魔数是否以 <code>0xCAFEBABE</code> 开始。</li></ol><blockquote><p>魔数是 Class 文件的开始标记，这个位置是一个固定的字符，CAFE BABE。</p></blockquote><p>松哥这里随便用二进制编辑器打开一个 Class 文件给大家看下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241205102404.png"></p><ol start="2"><li>主次版本号是否在当前 Java 虚拟机所能接受的范围内。</li></ol><blockquote><p>CAFEBABE 后面紧跟着的是次版本号，次版本号后面紧跟着的是主版本号。以上图为例，次版本号为 0，主版本号 3D 转为十进制是 61。高版本的 JDK 可以向下兼容以前旧版本的 Class 文件，但是无法运行以后版本的 Class 文件，Class 文件的主版本号和 JDK 的关系如下图。</p></blockquote><table><thead><tr><th align="left">JDK 版本号</th><th align="left">Class 主版本号</th></tr></thead><tbody><tr><td align="left">JDK 19</td><td align="left">63</td></tr><tr><td align="left">JDK 18</td><td align="left">62</td></tr><tr><td align="left">JDK 17</td><td align="left">61</td></tr><tr><td align="left">JDK 16</td><td align="left">60</td></tr><tr><td align="left">JDK 15</td><td align="left">59</td></tr><tr><td align="left">JDK 14</td><td align="left">58</td></tr><tr><td align="left">JDK 13</td><td align="left">57</td></tr><tr><td align="left">JDK 12</td><td align="left">56</td></tr><tr><td align="left">JDK 11</td><td align="left">55</td></tr><tr><td align="left">JDK 10</td><td align="left">54</td></tr><tr><td align="left">JDK 9</td><td align="left">53</td></tr><tr><td align="left">JDK 8</td><td align="left">52</td></tr><tr><td align="left">JDK 7</td><td align="left">51</td></tr><tr><td align="left">JDK 6.0</td><td align="left">50</td></tr><tr><td align="left">JDK 5.0</td><td align="left">49</td></tr><tr><td align="left">JDK 1.4</td><td align="left">48</td></tr><tr><td align="left">JDK 1.3</td><td align="left">47</td></tr><tr><td align="left">JDK 1.2</td><td align="left">46</td></tr><tr><td align="left">JDK 1.1</td><td align="left">45.0-45.6</td></tr></tbody></table><ol start="3"><li>常量池中是否有不被支持的常量类型</li><li>当前类是否存在父类（所有类都应当有父类）？当前类是否继承了 final 类（不应当继承 final 类）？如果当前类不是抽象类，是否实现了其父类或者接口中要求实现的方法等等。</li><li>对字节码进行校验。</li><li>符号引用能否找到对应的类，符号引用中涉及到的类、字段、方法等的访问性是否满足要求。</li></ol><blockquote><p>由于验证这块的环节非常复杂，流程也多，因此，如果自己有办法确认自己的代码是 OK 的，那么也可以使用 -Xverify:none 来关闭大部分的类验证，这样可以缩短虚拟机加载类的时间。</p></blockquote><p>这里检查的内容其实非常多，官方文档足足有 100 多页，松哥这里就不逐一列举了，小伙伴们主要是知道这里的核心目的是检查并确保读入到内存中的字节流是没有问题的。</p><h2 id="3-2-Preparing"><a href="#3-2-Preparing" class="headerlink" title="3.2 Preparing"></a>3.2 Preparing</h2><p>这一阶段主要是给类中的静态属性设置初始值。</p><p>例如定义了 <code>public static int a = 5;</code>，那么就会为该变量在内存中（堆）分配存储空间，并设置初始值（int 类型初始值是 0），注意这个时候并不会将 a 设置为 5，因为还没到最终的初始化阶段。</p><p>但是如果属性在定义的时候就已经定义为常量了，例如 <code>public final static int a = 5;</code>，则会直接给属性最终赋值。</p><h2 id="3-3-Resolution"><a href="#3-3-Resolution" class="headerlink" title="3.3 Resolution"></a>3.3 Resolution</h2><p>接下来是解析，解析主要是将常量池内的符号引用替换为直接引用的过程。</p><p>什么是符号引用呢？</p><blockquote><p>符号引用是以一组符号来描述引用的目标，因为在编译阶段，虚拟机并不知道所引用的类的具体位置，因此就使用符号引用来代替。符号可以是任何字面量，只要在使用时能够无歧义的定位到目标即可。</p></blockquote><p>什么是直接引用呢？</p><blockquote><p>直接引用就是一个可以直接指向目标的指针，相对偏移量等。</p></blockquote><p>所以，符号引用转为直接引用其实就是原本是通过字符去引用某个变量，现在直接改为通过内存地址来访问该变量了。</p><p>解析的符号主要有七种，分别是类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符。</p><p>松哥这里以一个类的解析为例，和小伙伴们简单说明一下这个解析过程。</p><p>假设当前类是 C1，当前类中存在一个符号引用 F，我们要将这个符号引用 F 解析为一个类 C2，那么流程是这样：</p><ol><li>如果 C2 是一个普通对象而不是接口，那么 JVM 会把代表 F 的全限定名传递给 C1 的类加载器去加载这个类，当然，这个加载过程又是一整套的类加载流程。</li><li>如果 C2 是一个对象数组，那么首先按照第一步的方式先去加载数组中的元素类型，然后由虚拟机去生成一个代表该数组的对象。</li></ol><p>就这样简单两个步骤，当然，在这个流程中，也会去检查 C1 是否具备对 C2 的访问权限，这个主要是检查 module 访问权限和类的访问权限。</p><h1 id="四-Initialization"><a href="#四-Initialization" class="headerlink" title="四 Initialization"></a>四 Initialization</h1><p>接下来就是类的初始化阶段了，如果想让这个阶段更加具象化，那么这个阶段实际上是调用类的 clinit 方法，这个方法并不是开发者写的，而是由 javac 编译器自动生成的。</p><p>javac 自动生成的 clinit 方法主要是将静态变量赋值和静态代码块的相关内容合并起来。在执行 clinit 方法的过程中，并不会显式的调用父类的 clinit 方法，而是由虚拟机去确保在执行子类的 clinit 方法之前，父类的 clinit 方法已经被执行过了。</p><p>例如为 static 类型的变量赋值，就是在这个环节完成的。</p><h1 id="五-Using-Unloading"><a href="#五-Using-Unloading" class="headerlink" title="五 Using&#x2F;Unloading"></a>五 Using&#x2F;Unloading</h1><p>最后就是 Using 和 Unloading 了，这块就简单了，不多说。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;有小伙伴最近在面试过程中遇到这样一个问题：&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
    <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring用到了哪些设计模式？</title>
    <link href="http://www.javaboy.org/2024/1119/spring-design-pattern.html"/>
    <id>http://www.javaboy.org/2024/1119/spring-design-pattern.html</id>
    <published>2024-11-19T00:55:20.000Z</published>
    <updated>2024-12-20T02:56:40.619Z</updated>
    
    <content type="html"><![CDATA[<p>松哥的 Spring 源码分析课程结束好久了，今天和大伙总结下 Spring 中都用到了哪些设计模式。</p><span id="more"></span><p>Spring 作为企业级应用开发中最受欢迎的框架之一，其内部广泛采用了多种设计模式，使得框架不仅功能强大，而且具有很高的可扩展性和灵活性。是我们学习设计模式不可多得的优质材料。</p><h1 id="一-单例模式-Singleton-Pattern"><a href="#一-单例模式-Singleton-Pattern" class="headerlink" title="一 单例模式 (Singleton Pattern)"></a>一 单例模式 (Singleton Pattern)</h1><p>在 Spring 框架中，单例模式被广泛应用于各种组件和工具类，以确保在整个应用程序生命周期中，这些对象只有一个实例，从而节省内存和提高性能。</p><p>松哥这里给大家举几个常见的 Spring 中单例的应用。</p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a><code>BeanFactory</code></h4><p><code>BeanFactory</code> 是 Spring 框架中的另一个核心接口，它负责创建和管理 bean。<code>BeanFactory</code> 的实现类（如 <code>DefaultListableBeanFactory</code>）也通常以单例模式存在。</p><p><strong>源码示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ConfigurableListableBeanFactory</span>, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">                singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    singletonObject = getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultListableBeanFactory 本身的初始化逻辑如下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241119084710.png"></p><p>可以看到，如果存在 BeanFactory，则先销毁，再创建新的 BeanFactory。</p><h1 id="二-工厂模式-Factory-Pattern"><a href="#二-工厂模式-Factory-Pattern" class="headerlink" title="二 工厂模式 (Factory Pattern)"></a>二 工厂模式 (Factory Pattern)</h1><p>工厂模式提供了一种创建对象的接口，但让子类决定实例化哪一个类。Spring 中的 <code>BeanFactory</code> 接口及其实现类（如 <code>DefaultListableBeanFactory</code>）就是工厂模式的应用。通过这些工厂，我们可以方便地管理和创建bean实例。</p><h2 id="Spring-源码案例"><a href="#Spring-源码案例" class="headerlink" title="Spring 源码案例"></a>Spring 源码案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ConfigurableListableBeanFactory</span>, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> doGetBean(name, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultListableBeanFactory</code> 是 <code>BeanFactory</code> 的一个实现，负责创建和管理 bean 的实例。</p><h1 id="三-原型模式-Prototype-Pattern"><a href="#三-原型模式-Prototype-Pattern" class="headerlink" title="三 原型模式 (Prototype Pattern)"></a>三 原型模式 (Prototype Pattern)</h1><p>原型模式通过复制现有对象来创建新对象，而无需知道任何创建细节。在 Spring 中，我们可以通过设置 bean 的 <code>scope</code> 属性为 <code>prototype</code> 来实现每次请求时都创建一个新的 bean 实例。</p><h2 id="Spring-源码案例-1"><a href="#Spring-源码案例-1" class="headerlink" title="Spring 源码案例"></a>Spring 源码案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.ExampleBean&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这个配置表示每次请求 <code>exampleBean</code> 时，都会创建一个新的实例。</p><h1 id="四-模板方法模式-Template-Method-Pattern"><a href="#四-模板方法模式-Template-Method-Pattern" class="headerlink" title="四 模板方法模式 (Template Method Pattern)"></a>四 模板方法模式 (Template Method Pattern)</h1><p>在 Spring 框架中，模板方法模式被广泛应用于多个模块，以提供灵活且可扩展的解决方案。模板方法模式的核心思想是定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。这样，子类可以不改变算法结构的情况下重新定义算法的某些特定步骤。</p><p>这里松哥和大家分享两个经典的模版方法模式：JdbcTemplate 和 PlatformTransactionManager。</p><h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a><code>JdbcTemplate</code></h4><p><code>JdbcTemplate</code> 是 Spring JDBC 模块中的一个核心类，它使用模板方法模式来简化数据库操作。</p><p><strong>模板方法</strong>:</p><ul><li><code>execute</code>：执行 SQL 语句的基本方法。</li><li><code>query</code>：查询数据库的基本方法。</li><li><code>update</code>：执行更新操作的基本方法。</li></ul><p><strong>具体实现</strong>:</p><ul><li><code>queryForObject</code>：查询单个对象。</li><li><code>queryForList</code>：查询列表。</li><li><code>batchUpdate</code>：批量更新。</li></ul><p><strong>源码示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JdbcOperations</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">queryForObject</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper, Object... args)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">        <span class="keyword">return</span> queryForObject(sql, args, getJdbcOperations().<span class="keyword">new</span> <span class="title class_">SingleColumnRowMapper</span>(rowMapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql, PreparedStatementSetter pss)</span> <span class="keyword">throws</span> DataAccessException &#123;</span><br><span class="line">        Assert.notNull(sql, <span class="string">&quot;SQL must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Executing SQL update [&quot;</span> + sql + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DataSourceUtils.getConnection(getDataSource());</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ps = con.prepareStatement(sql);</span><br><span class="line">            pss.setValues(ps);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(rows + <span class="string">&quot; rows affected&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rows;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// Handle exception</span></span><br><span class="line">            <span class="keyword">throw</span> translateException(<span class="string">&quot;PreparedStatement&quot;</span>, sql, ex);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.closeStatement(ps);</span><br><span class="line">            DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a><code>PlatformTransactionManager</code></h4><p><code>PlatformTransactionManager</code> 接口定义了事务管理的基本方法，具体的事务管理实现类（如 <code>DataSourceTransactionManager</code>）则提供了具体的实现。</p><p><strong>模板方法</strong>:</p><ul><li><code>getTransaction</code>：获取事务。</li><li><code>commit</code>：提交事务。</li><li><code>rollback</code>：回滚事务。</li></ul><p><strong>具体实现</strong>:</p><ul><li><code>DataSourceTransactionManager</code>：基于数据源的事务管理。</li><li><code>JtaTransactionManager</code>：基于JTA的事务管理。</li></ul><p><strong>源码示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlatformTransactionManager</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> TransactionStatus <span class="title function_">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取数据库连接</span></span><br><span class="line">        <span class="type">ConnectionHolder</span> <span class="variable">conHolder</span> <span class="operator">=</span> (ConnectionHolder) transaction;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> conHolder.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置事务隔离级别</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">previousIsolationLevel</span> <span class="operator">=</span> DataSourceUtils.storeIsolationLevelIfNotSet(con, definition.getIsolationLevel());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newTransaction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!con.getAutoCommit()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Not switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit because already manually committed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newTransaction = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回事务状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionObject</span>(conHolder, previousIsolationLevel, newTransaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-适配器模式-Adapter-Pattern"><a href="#五-适配器模式-Adapter-Pattern" class="headerlink" title="五 适配器模式 (Adapter Pattern)"></a>五 适配器模式 (Adapter Pattern)</h1><p>适配器模式将一个类的接口转换成客户希望的另一个接口。SpringMVC 中的 <code>HandlerAdapter</code> 接口及其多个实现类（如 <code>RequestMappingHandlerAdapter</code>）就是适配器模式的应用，它们负责处理不同类型的控制器方法。</p><h2 id="Spring-源码案例-2"><a href="#Spring-源码案例-2" class="headerlink" title="Spring 源码案例"></a>Spring 源码案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line">    ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> HandlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> ((HandlerMethod) handler).invokeAndHandle(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RequestMappingHandlerAdapter</code> 适配了 <code>HandlerMethod</code> 类型的控制器方法，使其能够处理HTTP请求。</p><h1 id="六-装饰者模式-Decorator-Pattern"><a href="#六-装饰者模式-Decorator-Pattern" class="headerlink" title="六 装饰者模式 (Decorator Pattern)"></a>六 装饰者模式 (Decorator Pattern)</h1><p>装饰者模式允许动态地给一个对象添加一些额外的职责。Spring AOP 中的切面实现可以看作是对原有对象的一种装饰。通过 <code>@Around</code> 注解定义的环绕通知可以在不改变原有业务逻辑的情况下增加额外的功能。</p><h2 id="Spring-源码案例-3"><a href="#Spring-源码案例-3" class="headerlink" title="Spring 源码案例"></a>Spring 源码案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 开始事务</span></span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TransactionInterceptor</code> 是一个典型的装饰者模式应用，它在方法调用前后添加了事务管理的逻辑。</p><h1 id="七-观察者模式-Observer-Pattern"><a href="#七-观察者模式-Observer-Pattern" class="headerlink" title="七 观察者模式 (Observer Pattern)"></a>七 观察者模式 (Observer Pattern)</h1><p>观察者模式定义了对象之间的一对多依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。Spring  中的 <code>ApplicationEvent</code> 和 <code>ApplicationListener</code> 接口共同实现了观察者模式。</p><h2 id="Spring-源码案例-4"><a href="#Spring-源码案例-4" class="headerlink" title="Spring 源码案例"></a>Spring 源码案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextRefreshedEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ContextRefreshedEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Context refreshed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyApplicationListener</code> 监听了 <code>ContextRefreshedEvent</code> 事件，当上下文刷新时，会输出一条消息。</p><h1 id="八-代理模式-Proxy-Pattern"><a href="#八-代理模式-Proxy-Pattern" class="headerlink" title="八 代理模式 (Proxy Pattern)"></a>八 代理模式 (Proxy Pattern)</h1><p>代理模式为其他对象提供一个代理以控制对这个对象的访问。Spring AOP 使用动态代理技术（JDK 动态代理或 CGLIB）来实现代理模式。例如，当你在方法上添加事务管理注解 <code>@Transactional</code> 时，Spring 会自动创建一个代理对象来管理事务的开始和结束。</p><h2 id="Spring-源码案例-5"><a href="#Spring-源码案例-5" class="headerlink" title="Spring 源码案例"></a>Spring 源码案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">AopProxyFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AopConfigException</span>(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ObjenesisCglibAopProxy</span>(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdkDynamicAopProxy</span>(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultAopProxyFactory</code> 根据配置选择使用 CGLIB 或 JDK 动态代理来创建代理对象。</p><h1 id="九-组合模式-Composite-Pattern"><a href="#九-组合模式-Composite-Pattern" class="headerlink" title="九 组合模式 (Composite Pattern)"></a>九 组合模式 (Composite Pattern)</h1><p>组合模式允许将对象组合成树形结构以表示“部分-整体”的层次结构。在 Spring 配置中，可以将多个 bean 组合在一起形成一个复杂的结构。</p><h2 id="Spring-源码案例-6"><a href="#Spring-源码案例-6" class="headerlink" title="Spring 源码案例"></a>Spring 源码案例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/testdb&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个配置文件中，<code>jdbcTemplate</code> 依赖于 <code>dataSource</code>，形成了一个简单的组合结构。</p><h1 id="十-策略模式-Strategy-Pattern"><a href="#十-策略模式-Strategy-Pattern" class="headerlink" title="十 策略模式 (Strategy Pattern)"></a>十 策略模式 (Strategy Pattern)</h1><p>策略模式定义了一系列算法，并将每一个算法封装起来，使它们可以互换。Spring 中的 <code>Resource</code> 接口及其多个实现类（如 <code>ClassPathResource</code>, <code>FileSystemResource</code>）就是策略模式的应用，可以根据需要选择不同的资源访问方式。</p><h2 id="Spring-源码案例-7"><a href="#Spring-源码案例-7" class="headerlink" title="Spring 源码案例"></a>Spring 源码案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line">    Resource <span class="title function_">getResource</span><span class="params">(String location)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resource <span class="title function_">getResource</span><span class="params">(String location)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (location.startsWith(<span class="string">&quot;classpath:&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(location.substring(<span class="string">&quot;classpath:&quot;</span>.length()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultResourceLoader</code> 根据资源路径的前缀选择合适的 <code>Resource</code> 实现类。</p><h1 id="十一-小结"><a href="#十一-小结" class="headerlink" title="十一 小结"></a>十一 小结</h1><p>通过上述案例，我们可以看到 Spring 框架巧妙地运用了多种设计模式，不仅提高了代码的复用性和可维护性，还增强了框架的灵活性和扩展性。希望这篇文章能帮助大家更好地理解和掌握 Spring 中的设计模式，如果有任何疑问或建议，欢迎在评论区留言交流。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;松哥的 Spring 源码分析课程结束好久了，今天和大伙总结下 Spring 中都用到了哪些设计模式。&lt;/p&gt;</summary>
    
    
    
    <category term="Design" scheme="http://www.javaboy.org/categories/Design/"/>
    
    
    <category term="Design" scheme="http://www.javaboy.org/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 3.3.5 试用CRaC，启动速度提升3到10倍</title>
    <link href="http://www.javaboy.org/2024/1113/crac.html"/>
    <id>http://www.javaboy.org/2024/1113/crac.html</id>
    <published>2024-11-13T00:54:49.000Z</published>
    <updated>2024-12-20T02:58:33.723Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>今天和小伙伴们来聊一个稍微新一点的技术话题—CRaC。</p><span id="more"></span><p>CRaC（Coordinated Restore at Checkpoint，检查点协调恢复）是一个 OpenJDK 项目，旨在解决 Java 应用程序启动和预热时间过长的问题。</p><p>Java 应用程序启动和预热时间过长是一个老大难的问题，目前来看各方也都提出了一些不同的解决思路，之前松哥和大家聊过的 AOT 也能从一定程度上解决启动慢的问题，今天的 CRaC 算是另外一种解决思路。</p><h1 id="一-CRaC是什么"><a href="#一-CRaC是什么" class="headerlink" title="一 CRaC是什么"></a>一 CRaC是什么</h1><p>CRaC 允许对运行中的 JVM 进行“快照”，并将其状态（包括应用）存储到磁盘中。</p><p>之后，在另一个时间点，可以将 JVM 从保存的检查点恢复到内存中。</p><p>这个功能意味着你可以启动应用程序、预热并创建检查点，然后从这个检查点快速恢复，从而显著减少启动时间。</p><h1 id="二-CRaC的原理"><a href="#二-CRaC的原理" class="headerlink" title="二 CRaC的原理"></a>二 CRaC的原理</h1><p>CRaC 的工作原理基于用户空间检查点和恢复（CRIU），这是一个为 Linux 实现检查点和恢复功能的项目。</p><p>CRIU 允许冻结容器或单个应用程序并从保存的检查点文件中恢复它。</p><p>CRaC 采用了 CRIU 的通用方法，并增加了一些增强和调整，使其适用于 Java 应用程序。</p><p>一般来说，CRaC 的执行步骤如下：</p><ol><li><strong>创建检查点</strong>：在应用程序运行并达到稳定状态后，可以创建一个检查点，这个检查点包含了 JVM 的状态和应用程序的数据。</li><li><strong>存储检查点</strong>：检查点数据被存储到磁盘上，以便之后可以从中恢复。</li><li><strong>恢复检查点</strong>：当需要启动应用程序时，可以直接从检查点恢复，而不是从头开始启动和预热 JVM。</li></ol><blockquote><p>这个感觉就有点类似于大伙平时使用的 VMWare 的快照功能，在某个时间点为系统拍摄一个快照，下次可以直接从快照启动，就比从头开始启动要快很多。CRaC 所拍快照中不仅包含 JVM，也可以包含你的应用信息。</p></blockquote><h1 id="三-CRaC-的应用场景"><a href="#三-CRaC-的应用场景" class="headerlink" title="三 CRaC 的应用场景"></a>三 CRaC 的应用场景</h1><p>CRaC 特别适用于需要快速启动和恢复的场景，比如：</p><ul><li><strong>云原生环境</strong>：在微服务和无服务器架构中，服务可能需要频繁地启动和停止，CRaC 可以显著减少服务的启动时间。</li><li><strong>开发和测试环境</strong>：开发者可以在开发和测试过程中快速恢复应用程序到某个已知状态，提高开发效率。</li><li><strong>灾难恢复</strong>：在系统发生故障时，可以快速从最近的检查点恢复服务，减少系统停机时间。</li></ul><h1 id="四-支持版本"><a href="#四-支持版本" class="headerlink" title="四 支持版本"></a>四 支持版本</h1><p>从 Spring Boot3.2&#x2F;Spring6.1 开始对 CRaC 的提供支持，所以如果大伙想体验 CRaC，需要选择合适的 SpringBoot 版本。</p><p>同时，由于前文提到的 CRaC 依赖于 Linux 特有的 CRIU，因此 CRaC 目前仅在Linux操作系统上支持。Windows 和 Mac 则不支持。</p><h1 id="五-实践"><a href="#五-实践" class="headerlink" title="五 实践"></a>五 实践</h1><p>首先我们需要安装支持 CRaC 的 JDK，目前主要有以下两种 JDK 支持 CRaC：</p><ol><li>Azul Zulu 21.0.1 + CRaC 版本支持 CRaC，适用于 x64 和 aarch64 CPU 架构，包括 JDK17 和 JDK21。</li></ol><p><img src="http://img.itboyhub.com/2024/mp/20241112145357.png" alt="选择支持 CRaC 的 JDK"></p><ol start="2"><li>Liberica JDK 17 和 Liberica JDK 21 提供了对 CRaC 的支持。</li></ol><p><img src="http://img.itboyhub.com/2024/mp/20241112144959.png"></p><p>接下来在项目中添加 CRaC 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.crac<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>crac<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>OK，如此之后，我们的准备工作就算完成了。</p><p>接下来我们需要在项目启动的时候，指定检查点的位置，并给出生成检查点的时机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dspring.context.checkpoint=onRefresh -XX:CRaCCheckpointTo=./tmp_checkpoint -jar javaboy-crac-3.3.5.jar</span><br></pre></td></tr></table></figure><p>在上面的启动脚本中，我们通过设置 JVM 系统属性 <code>-Dspring.context.checkpoint=onRefresh</code> 来启用自动检查点。这个属性会在 Spring 的 <code>LifecycleProcessor.onRefresh</code> 阶段自动创建检查点，这个阶段在所有非延迟初始化的 Singleton 实例化和 <code>InitializingBean#afterPropertiesSet</code> 回调调用之后，但在生命周期启动和 <code>ContextRefreshedEvent</code> 发布之前。也就是说在这个时机创建检查点（拍摄快照）。</p><p>当然，如果你想等应用程序完全启动之后再拍摄快照，也是可以的。</p><p>先用如下命令启动应用程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:CRaCCheckpointTo=./tmp_checkpoint -jar javaboy-crac-3.3.5.jar</span><br></pre></td></tr></table></figure><p>等待应用程序完全启动后，在另一个终端执行以下命令来手动触发检查点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid&gt; JDK.checkpoint</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;pid&gt;</code> 是应用程序的进程ID，这将创建检查点并关闭应用程序。检查点文件将存储在指定的文件夹中。</p><p>手动执行检查点生成的好处是，这个检查点包含了框架代码和应用程序代码，因此启动速度会更快，因为框架已经加载并启动了应用程序。</p><p>无论哪种方式生成检查点，只要有了检查点，最后一步就是使用这个检查点了。</p><p>我们可以利用检查点生成的文件来快速拉起应用程序，相关命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:CRaCRestoreFrom=./tmp_checkpoint</span><br></pre></td></tr></table></figure><p>总结下就是，自动检查点适合快速实现和无需代码更改的场景，而手动检查点提供了更大的灵活性，允许在应用程序完全预热后创建检查点，从而可能实现更快的启动时间。</p><p>好啦，感兴趣的小伙伴可以去尝试下，记得选择合适的操作系统、JDK 版本以及 Spring Boot 版本哦～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;今天和小伙伴们来聊一个稍微新一点的技术话题—CRaC。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
    <category term="CRaC" scheme="http://www.javaboy.org/tags/CRaC/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：文件上传之秒传、断点续传、分片上传</title>
    <link href="http://www.javaboy.org/2024/1112/file-upload.html"/>
    <id>http://www.javaboy.org/2024/1112/file-upload.html</id>
    <published>2024-11-12T00:54:37.000Z</published>
    <updated>2024-12-20T02:58:37.515Z</updated>
    
    <content type="html"><![CDATA[<p>文件上传功能几乎是每个 Web 应用不可或缺的一部分。无论是个人博客中的图片上传，还是企业级应用中的文档管理，文件上传都扮演着至关重要的角色。今天，松哥和大家来聊聊文件上传中的几个高级玩法——秒传、断点续传和分片上传。</p><span id="more"></span><h1 id="一-文件上传的常见场景"><a href="#一-文件上传的常见场景" class="headerlink" title="一 文件上传的常见场景"></a>一 文件上传的常见场景</h1><p>在日常开发中，文件上传的场景多种多样。比如，在线教育平台上的视频资源上传，社交平台上的图片分享，以及企业内部的知识文档管理等。这些场景对文件上传的要求也各不相同，有的追求速度，有的注重稳定性，还有的需要考虑文件大小和安全性。因此，针对不同需求，我们有了秒传、断点续传和分片上传等解决方案。</p><h1 id="二-秒传、断点上传与分片上传"><a href="#二-秒传、断点上传与分片上传" class="headerlink" title="二 秒传、断点上传与分片上传"></a>二 秒传、断点上传与分片上传</h1><h2 id="秒传"><a href="#秒传" class="headerlink" title="秒传"></a>秒传</h2><p>秒传，顾名思义，就是几乎瞬间完成文件上传的过程。其实现原理是通过计算文件的哈希值（如 MD5 或 SHA-1），然后将这个唯一的标识符发送给服务器。如果服务器上已经存在相同的文件，则直接返回成功信息，避免了重复上传。这种方式不仅节省了带宽，也大大提高了用户体验。</p><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p>断点续传是指在网络不稳定或者用户主动中断上传后，能够从上次中断的地方继续上传，而不需要重新开始整个过程。这对于大文件上传尤为重要，因为它可以有效防止因网络问题导致的上传失败，同时也能节约用户的流量和时间。</p><h2 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h2><p>分片上传则是将一个大文件分割成多个小块分别上传，最后再由服务器合并成完整的文件。这种做法的好处是可以并行处理多个小文件，提高上传效率；同时，如果某一部分上传失败，只需要重传这一部分，不影响其他部分。</p><h1 id="三-秒传实战"><a href="#三-秒传实战" class="headerlink" title="三 秒传实战"></a>三 秒传实战</h1><h2 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h2><p>在 SpringBoot 项目中，我们可以使用 <code>MessageDigest</code> 类来计算文件的 MD5 值，然后检查数据库中是否存在该文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/file&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FileService fileService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">secondUpload</span><span class="params">(<span class="meta">@RequestParam(value = &quot;file&quot;,required = false)</span> MultipartFile file,<span class="meta">@RequestParam(required = false,value = &quot;md5&quot;)</span> String md5)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查数据库中是否已存在该文件</span></span><br><span class="line">            <span class="keyword">if</span> (fileService.existsByMd5(md5)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;文件已存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存文件到服务器</span></span><br><span class="line">            file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/path/to/save/&quot;</span> + file.getOriginalFilename()));</span><br><span class="line">            <span class="comment">// 保存文件信息到数据库</span></span><br><span class="line">            fileService.save(<span class="keyword">new</span> <span class="title class_">FileInfo</span>(file.getOriginalFilename(), DigestUtils.md5DigestAsHex(file.getInputStream())));</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前端调用"><a href="#前端调用" class="headerlink" title="前端调用"></a>前端调用</h2><p>前端可以通过 JavaScript 的 FileReader API 读取文件内容，通过 spark-md5 计算 MD5 值，然后发送给后端进行校验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>秒传<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;spark-md5.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;startUpload()&quot;</span>&gt;</span>开始上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">startUpload</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (!file) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;请选择文件&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> md5 = <span class="keyword">await</span> <span class="title function_">calculateMd5</span>(file);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">        formData.<span class="title function_">append</span>(<span class="string">&#x27;md5&#x27;</span>, md5);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/file/upload1&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">body</span>: formData</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> result = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (result != <span class="string">&quot;文件已存在&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 开始上传文件</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;上传失败: &quot;</span> + result);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">calculateMd5</span>(<span class="params">file</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span></span><br><span class="line"><span class="language-javascript">            reader.<span class="property">onloadend</span> = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> spark = <span class="keyword">new</span> <span class="title class_">SparkMD5</span>.<span class="title class_">ArrayBuffer</span>();</span></span><br><span class="line"><span class="language-javascript">                spark.<span class="title function_">append</span>(reader.<span class="property">result</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">resolve</span>(spark.<span class="title function_">end</span>());</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">            reader.<span class="property">onerror</span> = <span class="function">() =&gt;</span> <span class="title function_">reject</span>(reader.<span class="property">error</span>);</span></span><br><span class="line"><span class="language-javascript">            reader.<span class="title function_">readAsArrayBuffer</span>(file);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前端分为两个步骤：</p><ol><li>计算文件的 MD5 值，计算之后发送给服务端确定文件是否存在。</li><li>如果文件已经存在，则不需要继续上传文件；如果文件不存在，则开始上传文件，上传文件和 MD5 校验请求类似，上面的案例代码中我就没有重复演示了，松哥在书里和之前的课程里都多次讲过文件上传，这里不再啰嗦。</li></ol><h1 id="四-分片上传实战"><a href="#四-分片上传实战" class="headerlink" title="四 分片上传实战"></a>四 分片上传实战</h1><p>分片上传关键是在前端对文件切片，比如一个 10MB 的文件切为 10 份，每份 1MB。每次上传的时候，需要多一个参数记录当前上传的文件切片的起始位置。</p><p>比如一个 10MB 的文件，切为 10 份，每份 1MB，那么：</p><ul><li>第 0 片，从 0 开始，一共是 <code>1024*1024</code> 个字节。</li><li>第 1 片，从 <code>1024*1024</code> 开始，一共是 <code>1024*1024</code> 个字节。</li><li>第 2 片…</li></ul><p>把这个搞懂，后面的代码就好理解了。</p><h2 id="后端实现-1"><a href="#后端实现-1" class="headerlink" title="后端实现"></a>后端实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>) + <span class="string">&quot;/uploads/&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传文件到指定位置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file 上传的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 文件开始上传的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ResponseEntity&lt;String&gt; 上传结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/upload2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">resumeUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, <span class="meta">@RequestParam(&quot;start&quot;)</span> <span class="type">long</span> start,<span class="meta">@RequestParam(&quot;fileName&quot;)</span> String fileName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">directory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR);</span><br><span class="line">        <span class="keyword">if</span> (!directory.exists()) &#123;</span><br><span class="line">            directory.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR + fileName);</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(targetFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> randomAccessFile.getChannel();</span><br><span class="line">        channel.position(start);</span><br><span class="line">        channel.transferFrom(file.getResource().readableChannel(), start, file.getSize());</span><br><span class="line">        channel.close();</span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上传失败: &quot;</span>+e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(<span class="number">500</span>).body(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端每次处理的时候，需要先设置文件的起始位置。</p><h2 id="前端调用-1"><a href="#前端调用-1" class="headerlink" title="前端调用"></a>前端调用</h2><p>前端需要将文件切分成多个小块，然后依次上传。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>分片示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;startUpload()&quot;</span>&gt;</span>开始上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">startUpload</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!file) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;请选择文件&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> filename = file.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> start = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">uploadFile</span>(file, start);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">uploadFile</span>(<span class="params">file, start</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> chunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 每个分片1MB</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> total = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(file.<span class="property">size</span> / chunkSize);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> chunkStart = start + i * chunkSize;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> chunkEnd = <span class="title class_">Math</span>.<span class="title function_">min</span>(chunkStart + chunkSize, file.<span class="property">size</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> chunk = file.<span class="title function_">slice</span>(chunkStart, chunkEnd);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">                formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, chunk);</span></span><br><span class="line"><span class="language-javascript">                formData.<span class="title function_">append</span>(<span class="string">&#x27;start&#x27;</span>, chunkStart);</span></span><br><span class="line"><span class="language-javascript">                formData.<span class="title function_">append</span>(<span class="string">&#x27;fileName&#x27;</span>, file.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/file/upload2&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">body</span>: formData</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">const</span> result = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`分片 <span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">$&#123;total&#125;</span> 上传成功`</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`分片 <span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">$&#123;total&#125;</span> 上传失败: <span class="subst">$&#123;result&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="五-断点续传实战"><a href="#五-断点续传实战" class="headerlink" title="五 断点续传实战"></a>五 断点续传实战</h1><p>断点续传的技术原理类似于分片上传。</p><p>当文件已经上传了一部分之后，断了需要重新开始上传。</p><p>那么我们的思路是这样的：</p><ol><li>前端先发送一个请求，检查要上传的文件在服务端是否已经存在，如果存在，目前大小是多少。</li><li>前端根据已经存在的大小，继续上传文件即可。</li></ol><h2 id="后端案例"><a href="#后端案例" class="headerlink" title="后端案例"></a>后端案例</h2><p>先来看后端检查的接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/check&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Long&gt; <span class="title function_">checkFile</span><span class="params">(<span class="meta">@RequestParam(&quot;filename&quot;)</span> String filename)</span> &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR + filename);</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(file.length());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果文件存在，则返回已经存在的文件大小。</p><p>如果文件不存在，则返回 0，表示前端从头开始上传该文件。</p><h2 id="前端调用-2"><a href="#前端调用-2" class="headerlink" title="前端调用"></a>前端调用</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>断点续传示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;startUpload()&quot;</span>&gt;</span>开始上传<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">startUpload</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> file = fileInput.<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (!file) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;请选择文件&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> filename = file.<span class="property">name</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> start = <span class="keyword">await</span> <span class="title function_">checkFile</span>(filename);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">uploadFile</span>(file, start);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">checkFile</span>(<span class="params">filename</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/file/check?filename=<span class="subst">$&#123;filename&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> start = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> start;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">uploadFile</span>(<span class="params">file, start</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> chunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 每个分片1MB</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> total = <span class="title class_">Math</span>.<span class="title function_">ceil</span>((file.<span class="property">size</span> - start) / chunkSize);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> chunkStart = start + i * chunkSize;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> chunkEnd = <span class="title class_">Math</span>.<span class="title function_">min</span>(chunkStart + chunkSize, file.<span class="property">size</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> chunk = file.<span class="title function_">slice</span>(chunkStart, chunkEnd);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">            formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, chunk);</span></span><br><span class="line"><span class="language-javascript">            formData.<span class="title function_">append</span>(<span class="string">&#x27;start&#x27;</span>, chunkStart);</span></span><br><span class="line"><span class="language-javascript">            formData.<span class="title function_">append</span>(<span class="string">&#x27;fileName&#x27;</span>, file.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/file/upload2&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">body</span>: formData</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> result = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`分片 <span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">$&#123;total&#125;</span> 上传成功`</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`分片 <span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>/<span class="subst">$&#123;total&#125;</span> 上传失败: <span class="subst">$&#123;result&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个案例实际上是一个断点续传+分片上传的案例，相关知识点并不难，小伙伴们可以自行体会下。</p><h1 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h1><p>好了，以上就是关于文件上传中秒传、断点续传和分片上传的实战分享。通过这些技术的应用，我们可以极大地提升文件上传的效率和稳定性，改善用户体验。希望各位小伙伴在自己的项目中也能灵活运用这些技巧，解决实际问题。</p><p>公众号后台回复 <strong>fileupload</strong>，可以下载本文完整案例。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件上传功能几乎是每个 Web 应用不可或缺的一部分。无论是个人博客中的图片上传，还是企业级应用中的文档管理，文件上传都扮演着至关重要的角色。今天，松哥和大家来聊聊文件上传中的几个高级玩法——秒传、断点续传和分片上传。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
    <category term="断点续传" scheme="http://www.javaboy.org/tags/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"/>
    
    <category term="分片上传" scheme="http://www.javaboy.org/tags/%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    
    <category term="秒传" scheme="http://www.javaboy.org/tags/%E7%A7%92%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 部署负载均衡服务全解析</title>
    <link href="http://www.javaboy.org/2024/1111/nginx-service.html"/>
    <id>http://www.javaboy.org/2024/1111/nginx-service.html</id>
    <published>2024-11-11T00:54:25.000Z</published>
    <updated>2024-12-20T02:57:25.897Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>关于 Nginx 的配置，松哥之前写过好几篇文章和小伙伴们分享了，不过大部分都是基于全局视角去配置的，今天我们就单纯来聊一聊用 Nginx 做负载均衡的配置。</p><span id="more"></span><h1 id="一-什么是负载均衡"><a href="#一-什么是负载均衡" class="headerlink" title="一 什么是负载均衡"></a>一 什么是负载均衡</h1><p>负载均衡（Load Balancing）是一种计算机网络技术，用于将网络流量或请求分发到多个服务器上，以优化资源使用、最大化吞吐量、最小化响应时间，并避免任何单一点过载。负载均衡的目的是确保我们的 Web 应用的高可用性和可靠性，同时提高用户体验。</p><p><img src="http://img.itboyhub.com/2024/mp/20241025213531.png"></p><p>一般来说，我们可能会在如下场景中用到负载均衡：</p><ol><li>服务器负载均衡：在多个服务器之间分配网络流量，以防止任何单个服务器因请求过多而性能下降。</li><li>数据中心负载均衡：在数据中心的不同位置或不同数据中心之间分配流量，以优化资源利用和提高可靠性。</li><li>云服务负载均衡：在云环境中，负载均衡可以跨多个虚拟机或容器服务分配流量。</li></ol><p>虽然我们平时做负载均衡基本上都是 Nginx，但是考虑到文章内容的完整性，松哥还是和大家说一说负载均衡这事可以在不同的网络层面实行，比如：</p><ul><li><strong>DNS 负载均衡</strong>：通过 DNS 服务将域名解析成不同的 IP 地址，将流量分散到不同的服务器上。</li><li><strong>硬件负载均衡</strong>：使用专门的硬件设备（如 F5 BIG-IP）来分配流量。</li><li><strong>软件负载均衡</strong>：使用软件解决方案（如 Nginx、HAProxy）来实现负载均衡。</li><li><strong>应用层负载均衡</strong>：在应用层（如 HTTP&#x2F;HTTPS）分配请求到不同的服务器。</li><li><strong>传输层负载均衡</strong>：在传输层（如 TCP&#x2F;UDP）分配连接到不同的服务器。</li></ul><h1 id="二-常见负载均衡算法"><a href="#二-常见负载均衡算法" class="headerlink" title="二 常见负载均衡算法"></a>二 常见负载均衡算法</h1><p>无论你使用哪种工具，在哪进行负载均衡，常见的负载均衡算法主要是下面这几种：</p><ul><li><strong>轮询（Round Robin）</strong>：将请求轮流分配给每台服务器。</li><li><strong>最少连接（Least Connections）</strong>：将请求分配给当前连接数最少的服务器。</li><li><strong>加权轮询（Weighted Round Robin）</strong>：根据服务器的性能权重来分配请求。</li><li><strong>加权最少连接（Weighted Least Connections）</strong>：根据服务器的性能权重和当前连接数来分配请求。</li><li><strong>IP 哈希（IP Hash）</strong>：根据客户端 IP 地址的哈希值来分配请求，以保证来自同一 IP 的请求总是被分配到同一台服务器上。</li></ul><h1 id="三-Nginx-配置"><a href="#三-Nginx-配置" class="headerlink" title="三 Nginx 配置"></a>三 Nginx 配置</h1><h2 id="3-1-轮询（Round-Robin）"><a href="#3-1-轮询（Round-Robin）" class="headerlink" title="3.1 轮询（Round Robin）"></a>3.1 轮询（Round Robin）</h2><p>轮询是 Nginx 默认的负载均衡策略，它将客户端的请求按顺序轮流分配到后端服务器上。如果后端服务器宕机，Nginx 会自动将其剔除出队列，直到该服务器恢复正常。</p><p><strong>举个栗子</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;  </span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;  </span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;  </span><br><span class="line">    <span class="attribute">server</span> backend3.example.com;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="section">location</span> / &#123;  </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的配置中，Nginx 会将请求依次分配给 backend1、backend2 和 backend3，循环往复。</p><h2 id="3-2-加权轮询"><a href="#3-2-加权轮询" class="headerlink" title="3.2 加权轮询"></a>3.2 加权轮询</h2><p>加权轮询策略允许你为后端服务器分配不同的权重，权重越高的服务器将接收更多的请求。这可以根据服务器的硬件配置、处理能力等因素进行灵活配置。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;  </span><br><span class="line">    <span class="section">upstream</span> myapp1 &#123;  <span class="comment"># 定义一个名为myapp1的服务器组  </span></span><br><span class="line">        <span class="attribute">server</span> backend1.example.com weight=<span class="number">5</span>;  <span class="comment"># 添加一个服务器，并设置权重为5  </span></span><br><span class="line">        <span class="attribute">server</span> backend2.example.com;  <span class="comment"># 添加另一个服务器，权重默认为1  </span></span><br><span class="line">        <span class="attribute">server</span> backend3.example.com down;  <span class="comment"># 将此服务器标记为down，不参与负载均衡  </span></span><br><span class="line">        <span class="attribute">server</span> backup1.example.com backup;  <span class="comment"># 将此服务器作为备份服务器  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="section">server</span> &#123;  </span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;  <span class="comment"># 监听80端口  </span></span><br><span class="line">  </span><br><span class="line">        <span class="section">location</span> / &#123;  <span class="comment"># 匹配所有请求  </span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://myapp1;  <span class="comment"># 将请求转发到myapp1服务器组  </span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;  <span class="comment"># 设置请求头中的Host字段为原始请求的Host  </span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;  <span class="comment"># 设置请求头中的X-Real-IP字段为客户端的真实IP地址  </span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;  <span class="comment"># 设置请求头中的X-Forwarded-For字段，以记录原始请求和代理链的IP地址  </span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;  <span class="comment"># 设置请求头中的X-Forwarded-Proto字段为原始请求的协议（http或https）  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的负载均衡策略是权重，除了权重之外，还有轮询以及 ip_hash 等。</p><h2 id="3-3-IP-哈希（IP-Hash）"><a href="#3-3-IP-哈希（IP-Hash）" class="headerlink" title="3.3 IP 哈希（IP Hash）"></a>3.3 IP 哈希（IP Hash）</h2><p>IP 哈希策略根据客户端的 IP 地址进行哈希运算，将相同的请求分配给同一个后端服务器。</p><p>这种策略适用于需要保持会话（Session）的场景，因为同一个客户端的请求会被发送到同一个服务器，从而避免了会话信息的丢失。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;  </span><br><span class="line">    ip_hash;  </span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;  </span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;  </span><br><span class="line">    <span class="attribute">server</span> backend3.example.com;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="section">location</span> / &#123;  </span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的配置中，Nginx 会根据客户端的 IP 地址进行哈希运算，然后将请求分配到对应的后端服务器。</p><h2 id="3-4-最少连接（Least-Connections）"><a href="#3-4-最少连接（Least-Connections）" class="headerlink" title="3.4 最少连接（Least Connections）"></a>3.4 最少连接（Least Connections）</h2><p>最少连接策略将新的请求分配给当前连接数最少的后端服务器。这种策略可以确保每个后端服务器的负载相对均衡，避免某个服务器过载而其他服务器空闲的情况。</p><blockquote><p>注意：Nginx 原生的 Stream 模块支持最少连接，但在 HTTP 模块中通常需要借助第三方插件或脚本实现。</p></blockquote><p>对于 HTTP 模块，可以通过第三方插件如 ngx_http_upstream_fair_module 或编写 Lua 脚本来实现类似的功能。</p><p>但在 Stream 模块中，可以直接配置，下面是一个 Stream 中配置的例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;  </span><br><span class="line">    least_conn;  </span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;  </span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;  </span><br><span class="line">    <span class="attribute">server</span> backend3.example.com;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="section">stream</span> &#123;  </span><br><span class="line">    <span class="section">server</span> &#123;  </span><br><span class="line">        <span class="attribute">listen</span> <span class="number">12345</span>;  </span><br><span class="line">        <span class="attribute">proxy_pass</span> backend;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-健康检查"><a href="#3-5-健康检查" class="headerlink" title="3.5 健康检查"></a>3.5 健康检查</h2><p>在 Nginx 中配置负载均衡的健康检查，可以通过主动健康检查（Active Health Checks）和被动健康检查（Passive Health Checks）两种方式来实现。</p><h3 id="主动健康检查"><a href="#主动健康检查" class="headerlink" title="主动健康检查"></a>主动健康检查</h3><p>主动健康检查是定期向上游服务器发送请求以检查其健康状况，如果上游服务器未能正确响应，Nginx 将认为该服务器不健康，并停止向其发送流量，直到服务器恢复健康。</p><p>配置方式如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">upstream</span> backend &#123;</span><br><span class="line">        <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">        <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">        <span class="attribute">check</span> interval=<span class="number">3000</span> rise=<span class="number">2</span> fall=<span class="number">5</span> timeout=<span class="number">1000</span> type=http;</span><br><span class="line">        <span class="attribute">check_http_send</span> <span class="string">&quot;HEAD /health HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n&quot;</span>;</span><br><span class="line">        <span class="attribute">check_http_expect_alive</span> http_2xx http_3xx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置中，Nginx 将每隔 3 秒（interval&#x3D;3000）向 <code>/health</code> 端点发送一个 HEAD 请求。如果服务器连续两次返回 2xx 或 3xx 的 HTTP 状态码（rise&#x3D;2），则认为服务器是健康的。如果服务器连续五次未能正确响应（fall&#x3D;5），则认为服务器不健康。</p><h3 id="被动健康检查"><a href="#被动健康检查" class="headerlink" title="被动健康检查"></a>被动健康检查</h3><p>被动健康检查基于实时流量分析，Nginx 根据后端服务器的响应来判断其健康状况。如果服务器返回特定的错误状态码，Nginx 将认为该服务器不健康，并在一段时间内不再将请求发送到该服务器。</p><p>配置方式如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">upstream</span> backend &#123;</span><br><span class="line">        <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">        <span class="attribute">server</span> backend2.example.com max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> backend;</span><br><span class="line">            <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout http_500 http_502 http_503 http_504;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置中，如果后端服务器在 30 秒内连续两次（max_fails&#x3D;2）未能正确响应，它将被临时从服务器池中移除。<code>proxy_next_upstream</code> 指令指定了哪些错误应该触发使用不同的服务器进行重试。</p><p>好啦，Nginx 负载均衡一般来说配置这些就够啦～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;关于 Nginx 的配置，松哥之前写过好几篇文章和小伙伴们分享了，不过大部分都是基于全局视角去配置的，今天我们就单纯来聊一聊用 Nginx 做负载均衡的配置。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://www.javaboy.org/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="http://www.javaboy.org/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>评论系统设计思路</title>
    <link href="http://www.javaboy.org/2024/1108/comment-design.html"/>
    <id>http://www.javaboy.org/2024/1108/comment-design.html</id>
    <published>2024-11-08T00:54:13.000Z</published>
    <updated>2024-12-20T02:57:27.904Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>无论我们是阅读公众号文章还是刷短视频，现在都有评论功能，而且这些评论基本上也都是支持“楼中楼”，也就是文章下面有评论，评论下面有回复，回复下面又有回复，回复还可以继续回复…</p><span id="more"></span><p><img src="http://img.itboyhub.com/2024/mp/20241020103255.png"></p><p>如果数据量不大的话，这个表其实很好设计，一张表就可以搞定，类似我们常见的省市县表结构：</p><p><img src="http://img.itboyhub.com/2024/mp/20241020100221.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> administrative_divisions (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  parent_id <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  level TINYINT <span class="keyword">NOT NULL</span>,</span><br><span class="line">  country_code <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">  created_at DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updated_at DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  INDEX idx_parent_id (parent_id),</span><br><span class="line">  INDEX idx_level (level)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对于这种结构的表，数据量不大的话没问题，数据量大的话，查询性能和维护都会成为问题。</p><p>今天我们就来讨论下这种评论表如何设计会好一些，也是松哥最近工作中的一点点经验，欢迎小伙伴们批评指正。</p><h1 id="一-表设计"><a href="#一-表设计" class="headerlink" title="一 表设计"></a>一 表设计</h1><p>因为现在无论是文章还是短视频，评论数动辄很大，所以系统在显示的时候，往往会先进行评论折叠，只显示一个总数，点击展开的时候，才会显示出来，以微信公众号为例，一般是这样：</p><p>首先在文章下方会先展示一个评论总数：</p><p><img src="http://img.itboyhub.com/2024/mp/20241020105303.png"></p><p>点开评论区之后，这里也有两个值得关注的信息：</p><ol><li>评论区上方会显示总的评论数</li><li>回复的评论不会一次性显示出来，但是会显示有多少条回复，需要用户点击之后才可以看到回复内容。</li></ol><p><img src="http://img.itboyhub.com/2024/mp/20241020105422.png"></p><blockquote><p>另外需要注意的是，如果回复数量特别多的话，也不会一次性全部展示出来。</p></blockquote><p>首先这样的设计是合理的，这个相信大家应该没什么异议，评论回复之所以不一次性全部展示，一方面是性能考虑，另一方面也是用户体验考虑。有的评论回复特别多，一次性全部展示出来，会影响查看一级评论。</p><p>那么我们就看下这样的评论功能，表该如何设计。</p><p>为了满足这些要求，我们将设计三个表：<code>Articles</code>（文章表），<code>Comments</code>（评论索引表），和 <code>CommentsContent</code>（评论内容表）。文章表将记录文章的根评论数，评论索引表将记录评论的层级关系、回复数量和点赞数量，评论内容表将存储实际的评论内容。</p><p>这种设计方式通过将评论内容和评论索引分开存储，提高了查询性能，同时也便于数据维护，并且通过文章表记录文章的根评论数，方便快速统计。</p><blockquote><p>以下设计主要提供思路，大家不必纠结于表名称。</p></blockquote><h3 id="Articles（文章表）"><a href="#Articles（文章表）" class="headerlink" title="Articles（文章表）"></a>Articles（文章表）</h3><table><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>article_id</td><td>BIGINT AUTO_INCREMENT</td><td>主键，自增</td></tr><tr><td>title</td><td>VARCHAR(255)</td><td>文章标题</td></tr><tr><td>root_comment_count</td><td>INT DEFAULT 0</td><td>文章的根评论数</td></tr><tr><td>created_at</td><td>DATETIME</td><td>创建时间</td></tr><tr><td>updated_at</td><td>DATETIME</td><td>更新时间</td></tr></tbody></table><h3 id="Comments（评论索引表）"><a href="#Comments（评论索引表）" class="headerlink" title="Comments（评论索引表）"></a>Comments（评论索引表）</h3><table><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>comment_id</td><td>BIGINT AUTO_INCREMENT</td><td>主键，自增</td></tr><tr><td>article_id</td><td>BIGINT</td><td>文章ID</td></tr><tr><td>parent_id</td><td>BIGINT DEFAULT 0</td><td>父评论ID，用于实现多级评论，顶级评论此字段为0</td></tr><tr><td>user_id</td><td>BIGINT</td><td>发表评论的用户ID</td></tr><tr><td>reply_count</td><td>INT DEFAULT 0</td><td>这条评论的回复数量</td></tr><tr><td>like_count</td><td>INT DEFAULT 0</td><td>这条评论的点赞数量</td></tr><tr><td>created_at</td><td>DATETIME</td><td>创建时间</td></tr><tr><td>updated_at</td><td>DATETIME</td><td>更新时间</td></tr></tbody></table><h3 id="CommentsContent（评论内容表）"><a href="#CommentsContent（评论内容表）" class="headerlink" title="CommentsContent（评论内容表）"></a>CommentsContent（评论内容表）</h3><table><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>comment_id</td><td>BIGINT</td><td>外键，关联评论索引表的comment_id</td></tr><tr><td>comment_text</td><td>TEXT</td><td>评论内容</td></tr><tr><td>comment_time</td><td>DATETIME</td><td>评论时间</td></tr></tbody></table><h3 id="SQL-创建表的语句"><a href="#SQL-创建表的语句" class="headerlink" title="SQL 创建表的语句"></a>SQL 创建表的语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建文章表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> articles (</span><br><span class="line">  article_id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  title <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  root_comment_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  created_at DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updated_at DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  INDEX idx_root_comment_count (root_comment_count)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建评论索引表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> comments (</span><br><span class="line">  comment_id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  article_id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  parent_id <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  user_id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  reply_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  like_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  created_at DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updated_at DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  INDEX idx_article_id (article_id),</span><br><span class="line">  INDEX idx_parent_id (parent_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建评论内容表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> comments_content (</span><br><span class="line">  comment_id <span class="type">BIGINT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">  comment_text TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">  comment_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">FOREIGN KEY</span> (comment_id) <span class="keyword">REFERENCES</span> comments(comment_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><blockquote><p>触发器主要用于更新文章的根评论数和评论的回复数量及点赞数量，不过这个并非必须，这个也可以通过业务逻辑去处理，松哥这里主要是给大家提供一个参考。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> after_comment_insert</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> comments</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  IF NEW.parent_id <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> articles <span class="keyword">SET</span> root_comment_count <span class="operator">=</span> root_comment_count <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> article_id <span class="operator">=</span> NEW.article_id;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>; <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> after_comment_like_insert</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> comments</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">UPDATE</span> comments <span class="keyword">SET</span> like_count <span class="operator">=</span> like_count <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> comment_id <span class="operator">=</span> NEW.comment_id;</span><br><span class="line"><span class="keyword">END</span>; <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> after_comment_reply_insert</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> comments</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">UPDATE</span> comments <span class="keyword">SET</span> reply_count <span class="operator">=</span> reply_count <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> comment_id <span class="operator">=</span> NEW.parent_id;</span><br><span class="line"><span class="keyword">END</span>; <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> after_comment_delete</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> comments</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  IF OLD.parent_id <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> articles <span class="keyword">SET</span> root_comment_count <span class="operator">=</span> root_comment_count <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> article_id <span class="operator">=</span> OLD.article_id;</span><br><span class="line">  <span class="keyword">ELSE</span></span><br><span class="line">    <span class="keyword">UPDATE</span> comments <span class="keyword">SET</span> reply_count <span class="operator">=</span> reply_count <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> comment_id <span class="operator">=</span> OLD.parent_id;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>; <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>在 <code>Comments</code> 表的 <code>article_id</code> 和 <code>parent_id</code> 字段上创建索引，可以提高查询特定文章的评论及其子评论的性能。</p><p>根据上面的设计，当我们想要获取评论总数、回复总数的时候，直接查询就可以了，就不需要统计了，非常方便。</p><h1 id="二-添加评论"><a href="#二-添加评论" class="headerlink" title="二 添加评论"></a>二 添加评论</h1><p>为了应对高并发，添加评论这块我们可以结合 MQ 去完成。</p><ol><li>首先前端发送评论到服务端。</li><li>服务端收到评论消息之后，将之发给 MQ 去处理。</li><li>消费者从 MQ 上消费消息，向数据添加评论。</li><li>添加完成后，将添加成功的消息发送给客户端。</li></ol><blockquote><p>以上步骤需要确保 MQ 消息可靠性，具体如何确保可靠性，松哥在之前的文章中和大家聊过了（<a href="https://mp.weixin.qq.com/s/hj8iqASSOk2AgdtkuLPCCQ">四种策略确保 RabbitMQ 消息发送可靠性！你用哪种？</a>），这里就不再赘述。</p></blockquote><p>另外还有一点就是如果需要对评论内容进行分析，那么在第 4 步完成之后，还是通过消费 MQ 消息将评论存入 ES；或者通过 Canal 之类的工具，将表中的数据同步到 ES。</p><h1 id="三-查询评论"><a href="#三-查询评论" class="headerlink" title="三 查询评论"></a>三 查询评论</h1><p>热门评论可以存入缓存中，避免每次查询数据库，这个松哥之前有过专门的文章，小伙伴们可以参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/py3RYDTzkJWDXGROwJoS6g">点赞收藏功能该如何设计？</a></li></ul><p>虽然当时写的是点赞收藏，但是和这里思路基本一致。</p><p>另一方面就是读写分离。</p><p>评论数据是非常典型的读多写少场景，因此我们可以从数据库层面进行读写分离，以提升性能。</p><p>好啦，目前的思路大致上就是这样，如果有不同看法，欢迎小伙伴们留言讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;无论我们是阅读公众号文章还是刷短视频，现在都有评论功能，而且这些评论基本上也都是支持“楼中楼”，也就是文章下面有评论，评论下面有回复，回复下面又有回复，回复还可以继续回复…&lt;/p&gt;</summary>
    
    
    
    <category term="Design" scheme="http://www.javaboy.org/categories/Design/"/>
    
    
    <category term="Design" scheme="http://www.javaboy.org/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>一个有争议的话题：客户端密码加密有必要吗？</title>
    <link href="http://www.javaboy.org/2024/1105/client-encrypt.html"/>
    <id>http://www.javaboy.org/2024/1105/client-encrypt.html</id>
    <published>2024-11-05T00:53:59.000Z</published>
    <updated>2024-12-20T03:00:39.159Z</updated>
    
    <content type="html"><![CDATA[<p>和小伙伴们讨论一个有争议的话题：</p><span id="more"></span><ul><li>密码加密需要在客户端进行吗？</li></ul><p>有的人觉得密码加密直接在服务端进行就可以了，没必要在客户端做；当然也有人觉得可以在客户端进行密码加密，降低服务器的压力。</p><p>你要问松哥项目中是怎么做的，我会告诉你我们在客户端就对密码加密了。</p><p>为什么这么做呢？</p><p>我来和大家聊聊我们是怎么考虑的。</p><h2 id="一-烫手山芋"><a href="#一-烫手山芋" class="headerlink" title="一 烫手山芋"></a>一 烫手山芋</h2><p>首先我们有一个共识，就是明文密码是一个烫手山芋，是一个定时炸弹，应该尽早处理。</p><p>把这样一个炸弹从前端运到后端再进行加密处理，似乎并非一个好的办法。应该尽早对炸弹进行处理，然后再进行运输。</p><p>那么在客户端就对密码进行加密的目的是什么？防止密码在传输过程中泄露吗？</p><p>显然不是！</p><p>对于重放攻击来说，人家压根不 care 你是否在客户端加密密码，对于重放攻击来说，密码是否在客户端进行加密，问题都不大。</p><blockquote><p>什么是重放攻击？<br>重放攻击（Replay Attack）是一种网络安全攻击，攻击者通过截获并重新发送之前捕获的数据包，以实现对系统的欺诈或破坏。这种攻击通常发生在没有正确实现消息认证和完整性保护的系统中。<br>一般来说，重放攻击有三个特点：</p><ol><li>无需破解加密：攻击者不需要知道加密算法或密钥，只需复制和重放数据包。</li><li>依赖于协议的缺陷：如果协议没有设计好，没有实现时间戳、序列号或一次性令牌等机制，就容易被重放攻击。</li><li>可重复性：攻击者可以多次重放相同的数据包，尝试获取相同的结果。</li></ol></blockquote><p>一般来说，解决重放攻击比较有效并且省事的办法就是上 HTTPS。</p><p><strong>客户端对密码进行加密的目的是为了防止明文密码在到达后端之后被滥用。这是最主要的目的。</strong></p><p>为了增加破解成本，在前端进行加密的时候，可以使用慢 hash 函数。</p><h2 id="二-什么是慢-hash"><a href="#二-什么是慢-hash" class="headerlink" title="二 什么是慢 hash"></a>二 什么是慢 hash</h2><p>慢哈希函数（Slow Hash Function）是一种密码学上的哈希函数，它被设计成故意减慢处理速度，以增加破解的难度。</p><p>这种函数通常用于密码存储、密钥派生和某些加密算法中，目的是提供额外的安全层，防止暴力破解攻击。</p><p>一般来说，慢哈希函数主要有下面一些特点：</p><ol><li><strong>计算成本高</strong>：故意设计成需要更多计算资源（CPU 时间或内存），使得暴力破解这种方式变得不切实际。</li><li><strong>内存密集型</strong>：许多慢哈希函数需要大量的内存，这增加了并行处理的难度，因为每个哈希计算实例都需要独立的内存空间。</li><li><strong>抵抗暴力破解</strong>：由于计算成本高，慢哈希函数使得暴力破解（尝试所有可能的密码直到找到匹配）变得非常困难。</li><li><strong>盐值（Salt）</strong>：慢哈希函数通常与盐值结合使用，盐值是随机生成的数据，用于与密码组合，确保即使两个用户使用相同的密码，他们的哈希值也会不同。</li><li><strong>密钥延展（Key Stretching）</strong>：通过多次迭代哈希过程，进一步增加破解难度。</li></ol><p>常见的慢哈希函数主要有如下几种，这几种也是我们在 Spring Security 中比较常见的：</p><ul><li><strong>PBKDF2（Password-Based Key Derivation Function 2）</strong>：使用 HMAC 作为伪随机函数，可以配置迭代次数来增加计算时间。</li><li><strong>BCrypt</strong>：专为密码存储设计，包含盐值和多轮哈希计算。</li><li><strong>scrypt</strong>：设计用于加密货币和密码存储，特别强调内存密集型，以抵抗 GPU 和 ASIC 硬件加速的暴力破解。</li><li><strong>Argon2</strong>：是当前最推荐使用的慢哈希函数之一，它赢得了密码哈希竞赛（Password Hashing Competition），并被设计为抵抗各种类型的攻击，包括定制硬件攻击。</li></ul><p>以 BCrypt 为例，如果我们控制 BCrypt 的执行时间大概是 0.1 秒完成一次哈希计算的话，按照 1 秒生成 10 个哈希值的速度，算完所有的 10 位大小写字母和数字组成的弱密码大概需要 P(62,10)&#x2F;(3600×24×365x10)&#x3D;1,237,204,169 年时间。</p><h2 id="三-一次用户注册"><a href="#三-一次用户注册" class="headerlink" title="三 一次用户注册"></a>三 一次用户注册</h2><p>了解了慢哈希之后，我们来看一次完整的用户注册应该是什么样子的。</p><p>首先，用户在客户端输入明文密码 123。</p><p>接下来，客户端对密码进行加密，可以使用 SHA256 散列函数，如果想要谨慎一些，也可以使用用户名等信息作为盐，以防止彩虹表的攻击。</p><p>现在就可以由客户端发送密码到服务端了。</p><p>服务端收到客户端发来的消息之后，在服务端眼里可以将客户端发来的密码就当成明文，按照明文的处理流程进行加密并存储，这块松哥在 Spring Security 中和大家讲过多次了，不赘述。</p><p>这就是用户注册的流程。</p><p>将来用户登录其实也是一样的。</p><p>用户在客户端输入密码之后，现在客户端进行加密，然后再上传到服务端，服务端再按照我们在 Spring Security 中讲的方式进行处理就可以了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;和小伙伴们讨论一个有争议的话题：&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
    <category term="客户端" scheme="http://www.javaboy.org/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
    <category term="加密" scheme="http://www.javaboy.org/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>京东二面：说说Java序列化和反序列化</title>
    <link href="http://www.javaboy.org/2024/1104/jd-interview.html"/>
    <id>http://www.javaboy.org/2024/1104/jd-interview.html</id>
    <published>2024-11-04T00:53:37.000Z</published>
    <updated>2024-12-20T02:58:09.579Z</updated>
    
    <content type="html"><![CDATA[<p>这是有小伙伴最近遇到的面试题。一起来看看。</p><h1 id="一-什么是序列化和反序列化"><a href="#一-什么是序列化和反序列化" class="headerlink" title="一 什么是序列化和反序列化"></a>一 什么是序列化和反序列化</h1><span id="more"></span><p>这是两个大家经常会接触的概念～</p><p>序列化是指将对象的状态信息转换为可以存储或传输的形式的过程。在Java中，这通常意味着将对象转换为字节序列。</p><p>反序列化则是序列化的逆过程，它将字节序列恢复为对象。</p><p>一个简单的例子，对象转为 JSON 字符串就是序列化，因为变为 JSON 字符串之后就可以传输了；JSON 字符串转为对象则是反序列化。</p><h1 id="二-序列化与反序列化的使用场景"><a href="#二-序列化与反序列化的使用场景" class="headerlink" title="二 序列化与反序列化的使用场景"></a>二 序列化与反序列化的使用场景</h1><p>我们日常开发中，序列化和反序列化其实还是挺常见的，只不过有时候我们忘记了自己所做的事情其实就是序列化和反序列化。</p><p>举几个常见的场景：</p><ol><li>网络传输：在分布式系统中，对象需要在网络上传输时，需要将对象序列化后发送，接收方再进行反序列化。</li><li>数据存储：将对象状态保存到文件或数据库中，以便后续恢复。</li><li>远程方法调用（RMI）：在 Java 的 RMI 中，对象需要在客户端和服务器之间传递。</li><li>对象克隆：通过序列化和反序列化实现对象的深拷贝。</li></ol><p>类似的场景其实很多。</p><p>不过就日常开发而言，可能大家在从 Redis 中存取对象、Dubbo 远程调用，这些场景可能会明确感知到序列化这件事，其他场景可能感受就不是特别明显。</p><h1 id="三-Java-中实现序列化与反序列化"><a href="#三-Java-中实现序列化与反序列化" class="headerlink" title="三 Java 中实现序列化与反序列化"></a>三 Java 中实现序列化与反序列化</h1><h2 id="3-1-实现-Serializable-接口"><a href="#3-1-实现-Serializable-接口" class="headerlink" title="3.1 实现 Serializable 接口"></a>3.1 实现 Serializable 接口</h2><p>假设有一个Student类，需要将其对象序列化到文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 用于版本控制  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构造函数、getter和setter省略  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>);  </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;student.ser&quot;</span>);  </span><br><span class="line">             <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos)) &#123;  </span><br><span class="line">            oos.writeObject(student);  </span><br><span class="line">            System.out.println(<span class="string">&quot;对象序列化成功！&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个案例中，Student 类通过实现 Serializable 接口来标记其可序列化。然后，使用 ObjectOutputStream 将 Student 对象写入到文件中。</p><h2 id="3-2-实现-Externalizable-接口"><a href="#3-2-实现-Externalizable-接口" class="headerlink" title="3.2 实现 Externalizable 接口"></a>3.2 实现 Externalizable 接口</h2><p>与 Serializable 接口类似，但 Externalizable 接口提供了更灵活的序列化控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Externalizable;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;  </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构造函数、getter和setter省略  </span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        out.writeObject(name);  </span><br><span class="line">        out.writeInt(age);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;  </span><br><span class="line">        name = (String) in.readObject();  </span><br><span class="line">        age = in.readInt();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// 序列化与反序列化逻辑与Serializable类似，但会调用writeExternal和readExternal方法  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个案例中，Employee 类通过实现 Externalizable 接口来提供自定义的序列化和反序列化逻辑。</p><p>相比于 Serializable，Externalizable 的灵活性主要体现在四点：</p><ol><li>Serializable 接口的序列化过程是由 JVM 自动完成的，不允许开发者对序列化过程进行自定义。Externalizable 接口要求开发者实现 writeExternal() 和 readExternal() 两个方法，从而完全控制序列化过程。这意味着开发者可以决定哪些字段需要序列化，哪些不需要，以及如何序列化这些字段。</li><li>Serializable 的自动序列化过程虽然方便，但可能不是最高效的。Externalizable 允许开发者自定义序列化过程，因此可以针对特定需求进行优化。例如，可以只序列化必要的字段，或者采用更高效的数据结构来存储序列化数据，从而提高性能。</li><li>Serializable 在默认情况下会序列化对象的所有非 transient 字段。如果对象的类结构发生变化如添加或删除字段，则可能会影响序列化和反序列化的兼容性。而对于 Externalizable 接口，开发者可以精确控制哪些字段被序列化，从而更容易地管理版本兼容性问题，甚至还可以在 writeExternal() 和 readExternal() 方法中添加逻辑来处理不同版本的序列化数据。</li><li>由于 Serializable 的序列化过程是自动的，因此可能会无意中序列化敏感信息（如密码、密钥等），此外，恶意用户还可能通过修改序列化数据来攻击系统。而 Externalizable 接口允许开发者明确控制哪些信息被序列化，从而可以减少敏感信息被泄露的风险，开发者甚至还可以在序列化过程中添加额外的安全措施（如加密、签名等）来提高系统的安全性。</li></ol><h2 id="3-3-使用-JSON-序列化库（如-Jackson、Gson）"><a href="#3-3-使用-JSON-序列化库（如-Jackson、Gson）" class="headerlink" title="3.3 使用 JSON 序列化库（如 Jackson、Gson）"></a>3.3 使用 JSON 序列化库（如 Jackson、Gson）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String username;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构造函数、getter和setter省略  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">30</span>);  </span><br><span class="line">            <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);  </span><br><span class="line">            System.out.println(json); <span class="comment">// 输出JSON字符串  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 反序列化  </span></span><br><span class="line">            <span class="type">User</span> <span class="variable">deserializedUser</span> <span class="operator">=</span> mapper.readValue(json, User.class);  </span><br><span class="line">            System.out.println(deserializedUser.getUsername()); <span class="comment">// 输出：李四  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个案例中，使用 Jackson 库将 User 对象序列化为 JSON 字符串，并反序列化为 User 对象。</p><h2 id="3-4-使用-XML-序列化库（如JAXB、XStream）"><a href="#3-4-使用-XML-序列化库（如JAXB、XStream）" class="headerlink" title="3.4 使用 XML 序列化库（如JAXB、XStream）"></a>3.4 使用 XML 序列化库（如JAXB、XStream）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.bind.JAXBContext;  </span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.Marshaller;  </span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.annotation.XmlRootElement;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@XmlRootElement</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String street;  </span><br><span class="line">    <span class="keyword">private</span> String city;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 构造函数、getter和setter省略  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;123 Main St&quot;</span>, <span class="string">&quot;Anytown&quot;</span>);  </span><br><span class="line">            <span class="type">JAXBContext</span> <span class="variable">jaxbContext</span> <span class="operator">=</span> JAXBContext.newInstance(Address.class);  </span><br><span class="line">            <span class="type">Marshaller</span> <span class="variable">marshaller</span> <span class="operator">=</span> jaxbContext.createMarshaller();  </span><br><span class="line">            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, <span class="literal">true</span>);  </span><br><span class="line">            marshaller.marshal(address, System.out); <span class="comment">// 输出到控制台  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 反序列化逻辑通常涉及解析XML字符串或文件  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个案例中，Address 类通过 @XmlRootElement 注解标记为可 XML 序列化。使用 JAXB 库将其序列化为 XML 格式并输出到控制台。</p><h2 id="3-5-使用二进制序列化库（如-protobuf、Avro）"><a href="#3-5-使用二进制序列化库（如-protobuf、Avro）" class="headerlink" title="3.5 使用二进制序列化库（如 protobuf、Avro）"></a>3.5 使用二进制序列化库（如 protobuf、Avro）</h2><p>由于 Protobuf 的使用涉及 .proto 文件的定义和编译，这里仅简要说明。首先定义一个 .proto文件，然后使用 Protobuf 编译器生成 Java 代码，最后使用生成的代码进行序列化和反序列化。</p><p>这个松哥之前在 gRPC 教程中详细介绍过，这里不多说了，公号后台回复 gRPC。</p><h1 id="四-static-和-transient"><a href="#四-static-和-transient" class="headerlink" title="四 static 和 transient"></a>四 static 和 transient</h1><p>static 和 transient 是序列化时两个比较特殊的字段。</p><ul><li><strong>static</strong>：<code>static</code> 字段是类级别的，不属于对象实例，因此在序列化时不会被包含。</li><li><strong>transient</strong>：<code>transient</code> 关键字修饰的字段在序列化过程中会被忽略，不会被序列化。</li></ul><h1 id="五-小结"><a href="#五-小结" class="headerlink" title="五 小结"></a>五 小结</h1><p>以上就是松哥和大家介绍的 Java 中的序列化问题。</p><p>另外有几个点大家在序列化时候需要注意：</p><ol><li>版本控制：通过 <code>serialVersionUID</code> 来确保序列化的兼容性。</li><li>性能考虑：序列化和反序列化是资源密集型操作，应考虑性能影响。</li><li>安全性：确保序列化数据的安全性，避免序列化过程中的数据泄露。</li><li>数据一致性：在反序列化时，确保数据的一致性和完整性。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是有小伙伴最近遇到的面试题。一起来看看。&lt;/p&gt;
&lt;h1 id=&quot;一-什么是序列化和反序列化&quot;&gt;&lt;a href=&quot;#一-什么是序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;一 什么是序列化和反序列化&quot;&gt;&lt;/a&gt;一 什么是序列化和反序列化&lt;/h1&gt;</summary>
    
    
    
    <category term="面试" scheme="http://www.javaboy.org/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="http://www.javaboy.org/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一款OCR神器，5.6K Star，支持20多种文档格式，一键转换成markdown</title>
    <link href="http://www.javaboy.org/2024/1103/java-ocr.html"/>
    <id>http://www.javaboy.org/2024/1103/java-ocr.html</id>
    <published>2024-11-03T00:53:16.000Z</published>
    <updated>2024-12-20T03:00:34.599Z</updated>
    
    <content type="html"><![CDATA[<p>不知道各位小伙伴平时工作中有没有一些将别的格式的文档转为 Markdown 的需求？</p><span id="more"></span><p>最近发现了一个好玩的开源项目，能够帮我们把二十多种不同格式的文章利用 AI 转为 markdown，非常好用。</p><h1 id="一-Zerox-OCR"><a href="#一-Zerox-OCR" class="headerlink" title="一 Zerox OCR"></a>一 Zerox OCR</h1><p><img src="http://img.itboyhub.com/2024/mp/20241101182618.png"></p><p>Zerox OCR 是一个基于 GPT 技术的 OCR 工具，它能够将 PDF、DOCX 等文件转换为 Markdown 格式。</p><p>相比于传统的 OCR 工具，Zerox OCR 有很多不一样的地方，具体体现在：</p><ol><li><strong>零配置</strong>：Zerox OCR 的一个显著特点是它的零配置特性，用户只需提供文件和 API token，即可轻松实现文本提取，省去了繁琐的参数设置。</li><li><strong>高精度识别</strong>：Zerox OCR 使用 GPT-4o-mini 模型进行文本识别，能够处理完全陌生的 PDF、图片等文档类型，不需要事先训练数据，即可提供高精度的 OCR 结果。</li><li><strong>Markdown 输出格式</strong>：在 OCR 转换过程中，Zerox 将每个识别的页面转化为简洁的 Markdown 格式，方便对文本进行后期处理和整理。</li><li><strong>支持复杂文档</strong>：Zerox 不仅可以处理简单的文本，还能够处理包含表格、图表等复杂布局的文件。无论是扫描版 PDF 还是其他格式，Zerox 都可以对它们进行 OCR 识别，生成准确的文本内容。</li><li><strong>本地运行与 API 支持</strong>：Zerox 支持本地运行，无需担心隐私泄露问题。此外，它还提供了 API 接口，方便集成到应用中，提升业务流程的自动化和效率。</li><li><strong>开源项目</strong>：Zerox 是一个开源项目，使用 MIT 许可证，用户可以免费使用其核心功能。</li></ol><p>Zerox OCR 以其高效准确、易用性和广泛的应用前景，成为了文档处理和数据提取领域的一个重要工具。开发者和用户可以通过访问 Zerox 的 GitHub 页面来体验这款 OCR 神器，开启高效文本提取之旅。</p><p>GitHub 地址：<a href="https://github.com/getomni-ai/zerox">https://github.com/getomni-ai/zerox</a></p><h1 id="二-支持的文档格式"><a href="#二-支持的文档格式" class="headerlink" title="二 支持的文档格式"></a>二 支持的文档格式</h1><p>那么这个开源工具到底都支持哪些不同格式的文档呢？</p><p>我们来看下官方给的这个支持的文档列表：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;pdf&quot;</span><span class="punctuation">,</span> <span class="comment">// Portable Document Format</span></span><br><span class="line">  <span class="string">&quot;doc&quot;</span><span class="punctuation">,</span> <span class="comment">// Microsoft Word 97-2003</span></span><br><span class="line">  <span class="string">&quot;docx&quot;</span><span class="punctuation">,</span> <span class="comment">// Microsoft Word 2007-2019</span></span><br><span class="line">  <span class="string">&quot;odt&quot;</span><span class="punctuation">,</span> <span class="comment">// OpenDocument Text</span></span><br><span class="line">  <span class="string">&quot;ott&quot;</span><span class="punctuation">,</span> <span class="comment">// OpenDocument Text Template</span></span><br><span class="line">  <span class="string">&quot;rtf&quot;</span><span class="punctuation">,</span> <span class="comment">// Rich Text Format</span></span><br><span class="line">  <span class="string">&quot;txt&quot;</span><span class="punctuation">,</span> <span class="comment">// Plain Text</span></span><br><span class="line">  <span class="string">&quot;html&quot;</span><span class="punctuation">,</span> <span class="comment">// HTML Document</span></span><br><span class="line">  <span class="string">&quot;htm&quot;</span><span class="punctuation">,</span> <span class="comment">// HTML Document (alternative extension)</span></span><br><span class="line">  <span class="string">&quot;xml&quot;</span><span class="punctuation">,</span> <span class="comment">// XML Document</span></span><br><span class="line">  <span class="string">&quot;wps&quot;</span><span class="punctuation">,</span> <span class="comment">// Microsoft Works Word Processor</span></span><br><span class="line">  <span class="string">&quot;wpd&quot;</span><span class="punctuation">,</span> <span class="comment">// WordPerfect Document</span></span><br><span class="line">  <span class="string">&quot;xls&quot;</span><span class="punctuation">,</span> <span class="comment">// Microsoft Excel 97-2003</span></span><br><span class="line">  <span class="string">&quot;xlsx&quot;</span><span class="punctuation">,</span> <span class="comment">// Microsoft Excel 2007-2019</span></span><br><span class="line">  <span class="string">&quot;ods&quot;</span><span class="punctuation">,</span> <span class="comment">// OpenDocument Spreadsheet</span></span><br><span class="line">  <span class="string">&quot;ots&quot;</span><span class="punctuation">,</span> <span class="comment">// OpenDocument Spreadsheet Template</span></span><br><span class="line">  <span class="string">&quot;csv&quot;</span><span class="punctuation">,</span> <span class="comment">// Comma-Separated Values</span></span><br><span class="line">  <span class="string">&quot;tsv&quot;</span><span class="punctuation">,</span> <span class="comment">// Tab-Separated Values</span></span><br><span class="line">  <span class="string">&quot;ppt&quot;</span><span class="punctuation">,</span> <span class="comment">// Microsoft PowerPoint 97-2003</span></span><br><span class="line">  <span class="string">&quot;pptx&quot;</span><span class="punctuation">,</span> <span class="comment">// Microsoft PowerPoint 2007-2019</span></span><br><span class="line">  <span class="string">&quot;odp&quot;</span><span class="punctuation">,</span> <span class="comment">// OpenDocument Presentation</span></span><br><span class="line">  <span class="string">&quot;otp&quot;</span><span class="punctuation">,</span> <span class="comment">// OpenDocument Presentation Template</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>可以看到，主流的文档格式都是支持的。</p><h1 id="三-实践"><a href="#三-实践" class="headerlink" title="三 实践"></a>三 实践</h1><p>最后我们再来看下这个工具该如何使用。</p><p>首先来安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install zerox</span><br></pre></td></tr></table></figure><p>Zerox 使用 graphicsmagick 和 ghostscript 进行 PDF 到图像的转换。这些工具应会自动下载，但有时需要手动安装。</p><p>手动安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y graphicsmagick</span><br></pre></td></tr></table></figure><p>装好之后就可以使用了，使用的时候可以使用一个在线的文件路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; zerox &#125; <span class="keyword">from</span> <span class="string">&quot;zerox&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">zerox</span>(&#123;</span><br><span class="line">  <span class="attr">filePath</span>: <span class="string">&quot;https://omni-demo-data.s3.amazonaws.com/test/cs101.pdf&quot;</span>,</span><br><span class="line">  <span class="attr">openaiAPIKey</span>: process.<span class="property">env</span>.<span class="property">OPENAI_API_KEY</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果是本地文件则通过如下方式来解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; zerox &#125; <span class="keyword">from</span> <span class="string">&quot;zerox&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">zerox</span>(&#123;</span><br><span class="line">  <span class="attr">filePath</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;./cs101.pdf&quot;</span>),</span><br><span class="line">  <span class="attr">openaiAPIKey</span>: process.<span class="property">env</span>.<span class="property">OPENAI_API_KEY</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最终解析结果类似下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  completionTime<span class="punctuation">:</span> <span class="number">10038</span><span class="punctuation">,</span></span><br><span class="line">  fileName<span class="punctuation">:</span> &#x27;invoice_36258&#x27;<span class="punctuation">,</span></span><br><span class="line">  inputTokens<span class="punctuation">:</span> <span class="number">25543</span><span class="punctuation">,</span></span><br><span class="line">  outputTokens<span class="punctuation">:</span> <span class="number">210</span><span class="punctuation">,</span></span><br><span class="line">  pages<span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      content<span class="punctuation">:</span> &#x27;# INVOICE # <span class="number">36258</span>\n&#x27; +</span><br><span class="line">        &#x27;**Date<span class="punctuation">:</span>** Mar <span class="number">06</span> <span class="number">2012</span>  \n&#x27; +</span><br><span class="line">        &#x27;**Ship Mode<span class="punctuation">:</span>** First Class  \n&#x27; +</span><br><span class="line">        &#x27;**Balance Due<span class="punctuation">:</span>** $<span class="number">50.10</span>  \n&#x27; +</span><br><span class="line">        &#x27;## Bill To<span class="punctuation">:</span>\n&#x27; +</span><br><span class="line">        &#x27;Aaron Bergman  \n&#x27; +</span><br><span class="line">        &#x27;<span class="number">98103</span><span class="punctuation">,</span> Seattle<span class="punctuation">,</span>  \n&#x27; +</span><br><span class="line">        &#x27;Washington<span class="punctuation">,</span> United States  \n&#x27; +</span><br><span class="line">        &#x27;## Ship To<span class="punctuation">:</span>\n&#x27; +</span><br><span class="line">        &#x27;Aaron Bergman  \n&#x27; +</span><br><span class="line">        &#x27;<span class="number">98103</span><span class="punctuation">,</span> Seattle<span class="punctuation">,</span>  \n&#x27; +</span><br><span class="line">        &#x27;Washington<span class="punctuation">,</span> United States  \n&#x27; +</span><br><span class="line">        &#x27;\n&#x27; +</span><br><span class="line">        &#x27;| Item                                       | Quantity | Rate   | Amount  |\n&#x27; +</span><br><span class="line">        &#x27;|--------------------------------------------|----------|--------|---------|\n&#x27; +</span><br><span class="line">        <span class="string">&quot;| Global Push Button Manager&#x27;s Chair, Indigo | 1        | $48.71 | $48.71  |\n&quot;</span> +</span><br><span class="line">        &#x27;| Chairs<span class="punctuation">,</span> Furniture<span class="punctuation">,</span> FUR-CH<span class="number">-4421</span>             |          |        |         |\n&#x27; +</span><br><span class="line">        &#x27;\n&#x27; +</span><br><span class="line">        &#x27;**Subtotal<span class="punctuation">:</span>** $<span class="number">48.71</span>  \n&#x27; +</span><br><span class="line">        &#x27;**Discount (<span class="number">20</span>%)<span class="punctuation">:</span>** $<span class="number">9.74</span>  \n&#x27; +</span><br><span class="line">        &#x27;**Shipping<span class="punctuation">:</span>** $<span class="number">11.13</span>  \n&#x27; +</span><br><span class="line">        &#x27;**Total<span class="punctuation">:</span>** $<span class="number">50.10</span>  \n&#x27; +</span><br><span class="line">        &#x27;---\n&#x27; +</span><br><span class="line">        &#x27;**Notes<span class="punctuation">:</span>**  \n&#x27; +</span><br><span class="line">        &#x27;Thanks for your business!  \n&#x27; +</span><br><span class="line">        &#x27;**Terms<span class="punctuation">:</span>**  \n&#x27; +</span><br><span class="line">        &#x27;Order ID <span class="punctuation">:</span> CA<span class="number">-2012</span>-AB10015140<span class="number">-40974</span>  &#x27;<span class="punctuation">,</span></span><br><span class="line">      page<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      contentLength<span class="punctuation">:</span> <span class="number">747</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这个用法是不是非常 Easy，如果小伙伴看过松哥的 vhr 或者 tienchin，对 Vue 的使用有基本的了解，那么上面这段代码可就太好明白了。</p><p>好啦，更多功能小伙伴们可以查看 Zerox 官方文档，松哥这里就不啰嗦了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知道各位小伙伴平时工作中有没有一些将别的格式的文档转为 Markdown 的需求？&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://www.javaboy.org/categories/Java/"/>
    
    
    <category term="OCR" scheme="http://www.javaboy.org/tags/OCR/"/>
    
  </entry>
  
  <entry>
    <title>确保数据安全！使用Spring Boot 实现强大的API参数验证</title>
    <link href="http://www.javaboy.org/2024/1101/springboot-api-arguments.html"/>
    <id>http://www.javaboy.org/2024/1101/springboot-api-arguments.html</id>
    <published>2024-11-01T00:52:57.000Z</published>
    <updated>2024-12-20T02:58:41.256Z</updated>
    
    <content type="html"><![CDATA[<p>我们在项目开发中，出于对数据完整性的考虑，基本上每个接口都需要参数校验，参数校验可以自己手动校验，也可以用工具校验，今天松哥和大家分享如何利用 Spring Boot 自带的工具实现参数校验。</p><span id="more"></span><h1 id="一-前端-or-后端？"><a href="#一-前端-or-后端？" class="headerlink" title="一 前端 or 后端？"></a>一 前端 or 后端？</h1><p>参数校验应该在前端完成还是后端完成？</p><p>正常来说，前后端都是需要校验的，但是前后端校验的目的各不相同。</p><p>一般来说，前端校验可以满足两个需求：</p><ol><li><strong>用户体验</strong>：前端校验可以即时反馈给用户，减少等待服务器响应的时间，提高用户体验。</li><li><strong>减轻服务器负担</strong>：通过前端校验可以过滤掉一些明显无效的请求，减少不必要的服务器负载。</li></ol><p>真正要确保数据完整性，还得要靠后端，后端校验可以起到如下作用：</p><ol><li><strong>安全性</strong>：由于前端代码可以被绕过或修改。后端校验是安全的必要保障，确保即使前端校验被绕过，数据的安全性和完整性也能得到保证。</li><li><strong>数据一致性</strong>：后端校验可以确保所有通过的请求都符合业务逻辑和数据模型的要求，保持数据的一致性。</li><li><strong>容错性</strong>：后端校验可以处理那些前端未能覆盖到的异常情况，作为最后一道防线。</li><li><strong>跨平台一致性</strong>：后端校验确保了无论用户通过何种客户端（Web、移动应用、第三方 API 等）访问服务，数据校验的标准都是一致的。</li><li><strong>维护和可扩展性</strong>：后端校验逻辑通常更容易维护和更新，因为它们集中在服务器端，而不是分散在多个客户端。</li><li><strong>日志和监控</strong>：后端可以记录校验失败的请求，这对于监控系统安全和进行问题诊断非常有用。</li></ol><p>因此，后端校验才能真正确保数据的完整性，今天松哥也是要和大家聊一聊后端数据校验。</p><h1 id="二-参数校验注解"><a href="#二-参数校验注解" class="headerlink" title="二 参数校验注解"></a>二 参数校验注解</h1><h2 id="2-1-参数校验依据"><a href="#2-1-参数校验依据" class="headerlink" title="2.1 参数校验依据"></a>2.1 参数校验依据</h2><p>在 Spring Boot 中，数据校验是通过 JSR303&#x2F;JSR380 规范的 Bean Validation 实现的。</p><p>这里涉及到两个概念，松哥和大家简单说下。</p><p>JSR303 是 Bean Validation 的 1.0 版本，正式名称为《Bean Validation》。它提供了一套注解和 API 来定义 Java 对象（Bean）的验证规则。这些注解可以直接用于 Bean 的属性上，以声明式的方式定义验证逻辑。JSR303 定义了一组标准的验证注解，如 <code>@NotNull</code>、<code>@Size</code>、<code>@Email</code> 等，用于校验对象的属性是否满足特定的条件。</p><p>而 JSR380 则是 Bean Validation 的 2.0 版本，也称为《Jakarta Bean Validation 2.0》。随着 JavaEE 向 JakartaEE 的迁移，JSR380 成为了新的规范。JSR380 在 JSR303 的基础上进行了扩展和改进，增加了新的注解、改进了 API，并提供了更好的集成方式。JSR380 的注解与 JSR303 兼容，但增加了一些新的注解，如 <code>@Email</code> 的 <code>message</code> 属性支持国际化，以及 <code>@PositiveOrZero</code>、<code>@NegativeOrZero</code> 等。</p><p>松哥下面案例主要和小伙伴们分享最新的 JSR380 规范中的参数校验注解。</p><h2 id="2-2-代码实践"><a href="#2-2-代码实践" class="headerlink" title="2.2 代码实践"></a>2.2 代码实践</h2><p>现在我们创建一个 Spring Boot 项目，使用当前最新版，并且引入参数校验依赖，最终创建好的工程依赖如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-validation&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">    testRuntimeOnly <span class="string">&#x27;org.junit.platform:junit-platform-launcher&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我现在有一个 UserDto 类，需要进行参数校验，那么我可以按照如下方式定义 UserDto：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span>：http://www.javaboy.org</span></span><br><span class="line"><span class="comment"> * @微信公众号：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span>：https://github.com/lenve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@gitee</span>：https://gitee.com/lenve</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDto</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;邮箱不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">//省略 getter/setter</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在 Controller 的方法参数前使用 @Validated 注解来开启校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span>：http://www.javaboy.org</span></span><br><span class="line"><span class="comment"> * @微信公众号：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span>：https://github.com/lenve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@gitee</span>：https://gitee.com/lenve</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@Validated</span> UserDto userDto, BindingResult bindingResult)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">            <span class="comment">// 处理校验失败情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;200&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当参数校验失败时，会抛出 <code>MethodArgumentNotValidException</code> 异常。可以在全局异常处理器中捕获该异常并进行统一处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span>：http://www.javaboy.org</span></span><br><span class="line"><span class="comment"> * @微信公众号：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span>：https://github.com/lenve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@gitee</span>：https://gitee.com/lenve</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalException</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleValidationExceptions</span><span class="params">(MethodArgumentNotValidException ex)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取校验结果的错误信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> ex.getBindingResult().getAllErrors().get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此就大功告成了～是不是非常 Easy？</p><h2 id="2-3-异常提示优化"><a href="#2-3-异常提示优化" class="headerlink" title="2.3 异常提示优化"></a>2.3 异常提示优化</h2><p>上面参数校验注解中的异常提示都是在 Java 代码里边硬编码的，我们也可以提前定义好异常提示文本，然后在代码里引用即可，这样更加方便，也好维护。</p><p>在 Spring Boot 项目中，可以通过在 <code>messages.properties</code> 文件中定义异常提示文本，并在代码中通过 <code>@Message</code> 注解引用这些文本来实现国际化和自定义错误消息。</p><p>具体步骤是这样的：</p><ol><li><strong>创建 <code>messages.properties</code> 文件</strong>：在 <code>src/main/resources</code> 目录下创建一个 <code>messages.properties</code> 文件（对于不同语言版本，可以创建如 <code>messages_en.properties</code>、<code>messages_fr.properties</code> 等文件）。</li><li><strong>定义异常提示文本</strong>：在 <code>messages.properties</code> 文件中定义键值对，键用于在代码中引用，值是实际的错误消息。</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">NotEmpty.username</span>=<span class="string">用户名不能为空</span></span><br><span class="line"><span class="attr">NotBlank.password</span>=<span class="string">密码不能为空</span></span><br><span class="line"><span class="attr">Email.email</span>=<span class="string">邮箱格式不正确</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>在实体类或 DTO 上使用校验注解</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotEmpty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDto</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;&#123;NotEmpty.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;&#123;NotBlank.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Email(message = &quot;&#123;Email.email&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>配置国际化</strong>：如果你的应用需要支持多语言，可以在 <code>application.properties</code> 或 <code>application.yml</code> 中配置消息源。</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.messages.basename</span>=<span class="string">messages</span></span><br><span class="line"><span class="attr">spring.messages.encoding</span>=<span class="string">UTF-8</span></span><br></pre></td></tr></table></figure><p>这样，当校验失败时，Spring 将自动从 <code>messages.properties</code> 文件中查找对应的错误消息，并将其返回给客户端。这种方法不仅可以使错误消息更加灵活和可维护，还可以方便地实现国际化。</p><h1 id="三-什么是分组校验"><a href="#三-什么是分组校验" class="headerlink" title="三 什么是分组校验"></a>三 什么是分组校验</h1><p>为什么需要分组校验呢？</p><blockquote><p>假设我们有一个用户实体 <code>User</code>，它包含用户名、密码和邮箱三个字段。在用户注册时，我们需要校验用户名和密码非空，邮箱格式正确。但在用户信息更新时，我们只需要校验用户名和邮箱，密码可能不会被修改，因此不需要校验。对于这种需求，我们可以使用分组校验来实现这一需求。</p></blockquote><p>松哥通过一个具体的案例来和小伙伴们演示下。</p><p>首先，我们定义两个校验分组，一个用于注册，一个用于更新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RegisterGroup</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UpdateGroup</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>分组其实就是两个空接口，用来做标记用。</p><p>然后，我们在 <code>User</code> 实体上应用这些分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.constraints.Email;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotBlank;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;, groups = &#123;RegisterGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;, groups = RegisterGroup.class)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;邮箱格式不正确&quot;, groups = &#123;RegisterGroup.class, UpdateGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，username 和 email 即属于注册分组也属于更新分组，而 password 则只属于注册分组。</p><p>接下来，在注册接口中，我们使用 <code>@Validated</code> 注解并指定 <code>RegisterGroup</code> 分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span>：http://www.javaboy.org</span></span><br><span class="line"><span class="comment"> * @微信公众号：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span>：https://github.com/lenve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@gitee</span>：https://gitee.com/lenve</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@Validated</span> UserDto userDto, BindingResult bindingResult)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">            <span class="comment">// 处理校验失败情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;200&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">(<span class="meta">@Validated(RegisterGroup.class)</span> <span class="meta">@RequestBody</span> UserDto user)</span> &#123;</span><br><span class="line">        <span class="comment">// 注册逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;注册成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(UpdateGroup.class)</span> <span class="meta">@RequestBody</span> UserDto user)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;更新成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当调用注册接口时，<code>User</code> 对象会根据 <code>RegisterGroup</code> 分组进行校验，而调用更新接口时，则会根据 <code>UpdateGroup</code> 分组进行校验。这样，我们就可以根据不同的业务需求来应用不同的校验规则了。</p><p>分组校验这种方式提供了一种灵活的方式来应对不同的校验场景，使得我们的代码更加清晰和易于维护。</p><h1 id="四-校验注解"><a href="#四-校验注解" class="headerlink" title="四 校验注解"></a>四 校验注解</h1><p>上面松哥和大家演示了几个常用的参数校验注解，完整的校验注解如下：</p><table><thead><tr><th>分类</th><th>注解</th><th>作用说明</th></tr></thead><tbody><tr><td>空值检查</td><td><code>@Null</code></td><td>验证对象必须为 <code>null</code></td></tr><tr><td></td><td><code>@NotNull</code></td><td>验证对象不能为 <code>null</code></td></tr><tr><td></td><td><code>@NotEmpty</code></td><td>验证对象非 <code>null</code>，且字符串和数组的 <code>length</code>、<code>Collection</code> 和 <code>Map</code> 的 <code>size</code> 大于 0</td></tr><tr><td></td><td><code>@NotBlank</code></td><td>字符串不能为 <code>null</code> 且至少有一个非空字符</td></tr><tr><td>Boolean 检查</td><td><code>@AssertTrue</code></td><td>验证 boolean 类型值为 <code>true</code></td></tr><tr><td></td><td><code>@AssertFalse</code></td><td>验证 boolean 类型值为 <code>false</code></td></tr><tr><td>长度检查</td><td><code>@Size(max, min)</code></td><td>验证对象（字符串、集合、数组）长度是否在指定范围之内</td></tr><tr><td>日期检查</td><td><code>@Past</code></td><td>验证日期必须是一个过去的日期</td></tr><tr><td></td><td><code>@Future</code></td><td>验证日期必须是一个将来的日期</td></tr><tr><td>数值检查</td><td><code>@Min(value)</code></td><td>验证数字的大小是否大于等于指定的值</td></tr><tr><td></td><td><code>@Max(value)</code></td><td>验证数字的大小是否小于等于指定的值</td></tr><tr><td></td><td><code>@DecimalMin(value)</code></td><td>验证数字的大小是否大于等于指定的值，小数存在精度</td></tr><tr><td></td><td><code>@DecimalMax(value)</code></td><td>验证数字的大小是否小于等于指定的值，小数存在精度</td></tr><tr><td></td><td><code>@Digits(integer, fraction)</code></td><td>验证数字是否符合指定格式，整数部分精度不能超过 <code>integer</code>，小数部分精度不能超过 <code>fraction</code></td></tr><tr><td></td><td><code>@Positive</code></td><td>验证数字必须为正数</td></tr><tr><td></td><td><code>@Negative</code></td><td>验证数字必须为负数</td></tr><tr><td></td><td><code>@PositiveOrZero</code></td><td>验证数字必须为正数或零</td></tr><tr><td></td><td><code>@NegativeOrZero</code></td><td>验证数字必须为负数或零</td></tr><tr><td>其它检查</td><td><code>@Email</code></td><td>验证字符串是否符合电子邮件地址的格式</td></tr><tr><td></td><td><code>@Pattern(regexp)</code></td><td>验证字符串是否符合正则表达式的规则</td></tr></tbody></table><p>好啦，这就是松哥和大家介绍的参数校验～公众号后台回复 20241101 可以获取本文完整案例。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在项目开发中，出于对数据完整性的考虑，基本上每个接口都需要参数校验，参数校验可以自己手动校验，也可以用工具校验，今天松哥和大家分享如何利用 Spring Boot 自带的工具实现参数校验。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Nginx性能优化的几个方法</title>
    <link href="http://www.javaboy.org/2024/1031/nginx-performance.html"/>
    <id>http://www.javaboy.org/2024/1031/nginx-performance.html</id>
    <published>2024-10-31T00:52:44.000Z</published>
    <updated>2024-12-20T02:57:23.823Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>小伙伴们平时使用 Nginx 是否有进行过性能优化呢？还是软件装好了就直接使用呢？</p><span id="more"></span><p>今天松哥和大伙分享几个常见的 Nginx 优化配置。</p><p>整体上来说，Nginx 的优化可以从多个层面进行：</p><ul><li>系统层面</li><li>配置层面</li><li>缓存利用</li><li>压缩策略</li><li>负载均衡策略</li></ul><p>接下来我们就来看看具体该如何做。</p><h1 id="一-Nginx-配置优化"><a href="#一-Nginx-配置优化" class="headerlink" title="一 Nginx 配置优化"></a>一 Nginx 配置优化</h1><ul><li>调整 <code>worker_processes</code> 参数，通常设置为等于服务器的 CPU 核心数。</li><li>调整 <code>worker_connections</code> 参数，以增加每个 Worker 进程可以打开的连接数。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br></pre></td></tr></table></figure><ul><li>使用 HTTP&#x2F;2 协议，利用多路复用和头部压缩等特性，提高页面加载速度。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl http2;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl http2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化 SSL&#x2F;TLS 配置，如关闭不安全的加密算法、使用 TLS 1.3 等，提高安全性和性能。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line"><span class="attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;</span><br></pre></td></tr></table></figure><h1 id="二-缓存利用"><a href="#二-缓存利用" class="headerlink" title="二 缓存利用"></a>二 缓存利用</h1><ul><li>启用文件缓存，减少磁盘 I&#x2F;O 操作。</li><li>使用代理缓存，缓存后端服务器的响应内容。</li><li>设置合理的缓存过期策略，通过 <code>Cache-Control</code> 和 <code>Expires</code> 头控制浏览器缓存的有效期，减少请求次数。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /data/nginx/cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span> inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_cache</span> my_cache;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段配置中，<code>proxy_cache_path</code> 指令用于配置一个缓存区域，该区域用于存储代理请求的响应内容。这个指令通常在 <code>http</code> 块中使用，并且是 <code>ngx_cache_purge</code> 模块和 <code>ngx_http_proxy_module</code> 模块的一部分。</p><p>这项配置中的各参数含义如下：</p><ul><li><code>/data/nginx/cache</code>：这是缓存文件存储的物理路径。Nginx 将在该目录下存储缓存数据。</li><li><code>levels=1:2</code>：这定义了缓存文件的目录结构。在这个例子中，<code>1:2</code> 意味着 Nginx 将缓存文件存储在 <code>/data/nginx/cache</code> 下的一级目录和二级目录中。<code>1</code> 代表第一级目录的数量（通常是 3 个，如 <code>data</code>、<code>tmp</code>、<code>html</code>），<code>2</code> 代表第二级目录的数量（通常是 64 个，基于 0 到 63 的数字或字母）。</li><li><code>keys_zone=my_cache:10m</code>：这定义了一个共享内存区域，用于存储缓存键和元数据。<code>my_cache</code> 是该区域的名称，<code>10m</code> 表示分配的共享内存大小为 10MB。这个区域用于存储缓存的键和相关信息，以便快速检索和验证缓存的有效性。</li><li><code>max_size=10g</code>：这指定了缓存区域的最大大小，单位是字节。在这个例子中，缓存区域的最大大小为 10GB。当缓存数据达到这个大小时，Nginx 将使用一种策略（通常是最近最少使用 LRU 算法）来移除旧的缓存数据，为新的缓存数据腾出空间。</li><li><code>inactive=60m</code>：这定义了缓存对象在多久没有被访问后会被认为“非活跃”并可能被移除。在这个例子中，如果一个缓存对象在 60 分钟内没有被访问，它将被认为是非活跃的。这个参数有助于控制缓存中旧数据的生命周期。</li><li><code>use_temp_path=off</code>：这指定了是否使用临时路径来存储缓存文件。<code>off</code> 表示不使用临时路径，所有的缓存文件都直接存储在指定的 <code>/data/nginx/cache</code> 路径下。如果设置为 <code>on</code>，则 Nginx 会使用一个临时目录来存储缓存文件，在文件被访问后，它们会被移动到永久的缓存目录中。</li></ul><h1 id="三-压缩策略"><a href="#三-压缩策略" class="headerlink" title="三 压缩策略"></a>三 压缩策略</h1><ul><li>启用 Gzip 压缩，减少数据传输量，提高响应速度。</li><li>根据服务器的 CPU 能力和网络条件平衡压缩级别和最小压缩大小，以达到最佳的性能。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span> any;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">5</span>;</span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">256</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> text/plain application/xml application/json application/javascript text/css;</span><br></pre></td></tr></table></figure><p>各项配置的含义分别如下：</p><ul><li><code>gzip on;</code>：启用 Gzip 压缩。当这个指令被设置为 <code>on</code> 时，Nginx 会尝试压缩响应体并发送给客户端。</li><li><code>gzip_vary on;</code>：这个指令告诉 Nginx 在响应头中添加<code>Vary: Accept-Encoding</code>。这允许缓存系统（如代理或 CDN）根据客户端是否支持压缩来存储不同的响应版本。</li><li><code>gzip_proxied any;</code>：这个指令允许 Nginx 对从任何代理服务器接收的响应进行压缩，无论响应是否已经被压缩。<code>any</code> 表示无论原始响应是否被压缩，Nginx 都会尝试再次压缩它。其他选项包括 <code>off</code>（不压缩任何代理的响应）和 <code>expired</code>（只压缩那些已经过期的代理响应）。</li><li><code>gzip_comp_level 5;</code>：这个指令设置 Gzip 压缩级别。压缩级别范围从 1（最快，压缩比最低）到 9（最慢，压缩比最高）。5 是一个在速度和压缩比之间取得平衡的常用值。</li><li><code>gzip_min_length 256;</code>：这个指令设置响应体的最小长度，只有当响应体大于或等于这个值时，Nginx 才会对其进行压缩。这里设置为 256 字节，意味着只有当响应体大于或等于 256 字节时，才会进行压缩。</li><li><code>gzip_types text/plain application/xml application/json application/javascript text/css;</code>：这个指令指定了哪些 MIME 类型的响应应该被压缩。在这个例子中，文本、XML、JSON、JavaScript 和 CSS 类型的响应将被压缩。</li></ul><h1 id="四-安全性优化"><a href="#四-安全性优化" class="headerlink" title="四 安全性优化"></a>四 安全性优化</h1><ul><li>隐藏 Nginx 版本号信息，更改源码隐藏 Nginx 软件名及版本号。</li><li>修改 Nginx 服务的默认用户，提高安全性。</li><li>配置 OCSP stapling、ssl_stapling、ssl_stapling_verify 等以增强 SSL&#x2F;TLS 的安全性。</li></ul><p>隐藏版本信息可以提高服务器的安全性，使攻击者难以通过版本信息推断出服务器可能存在的安全漏洞。</p><p>要隐藏 Nginx 版本号，有三个办法，一般来说我们使用第一种方式就可以了。</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在 Nginx 的配置文件中，在 <code>http</code> 块中添加以下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br></pre></td></tr></table></figure><p>这样设置后，Nginx 将不会在错误页面上显示版本号。</p><p>配置完成之后，保存配置文件并重新加载 Nginx 以应用更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -t   # 测试配置文件是否正确</span><br><span class="line">nginx -s reload   # 重新加载Nginx配置</span><br></pre></td></tr></table></figure><p>这种方法可以隐藏错误页面上的版本信息，但可能无法完全隐藏所有响应头中的版本信息 。</p><h3 id="修改-Nginx-源码"><a href="#修改-Nginx-源码" class="headerlink" title="修改 Nginx 源码"></a>修改 Nginx 源码</h3><p>如果想要从根源上修改 Nginx 版本信息，需要重新编译 Nginx，步骤如下：</p><ul><li>修改 <code>src/core/nginx.h</code> 文件中的版本定义。</li><li>修改 <code>src/http/ngx_http_header_filter_module.c</code> 文件中的服务器字符串。</li><li>修改 <code>src/http/ngx_http_special_response.c</code> 文件中的错误页面底部信息。</li></ul><p>修改完这些文件后，需要重新编译 Nginx。这样编译安装后，Nginx 的版本信息将被彻底修改 。</p><h3 id="使用第三方模块"><a href="#使用第三方模块" class="headerlink" title="使用第三方模块"></a>使用第三方模块</h3><p>如果需要动态修改响应头中的版本信息，可以使用如 <code>headers-more-nginx-module</code> 模块。这个模块允许你动态地添加、修改或删除 Nginx 的响应头。通过这个模块，可以完全控制 <code>Server</code> 响应头的内容 。</p><p>选择哪种方法取决于你的具体需求和环境。</p><p>如果你只是想简单地隐藏版本信息，修改配置文件可能是最简单的方法。如果你需要更彻底地控制版本信息，可能需要考虑修改源码并重新编译 Nginx。</p><h1 id="五-监控和日志优化"><a href="#五-监控和日志优化" class="headerlink" title="五 监控和日志优化"></a>五 监控和日志优化</h1><ul><li>使用日志分析工具（如 ELK Stack、Graylog 等）来分析和可视化 Nginx 的日志数据。</li><li>定期维护策略，如更新 Nginx、审查配置文件、备份配置文件等。</li><li>使用定时任务工具（如 cron）定期清理缓存，使用 Nginx 的 <code>proxy_cache_path</code> 指令中的 <code>inactive</code> 参数设置缓存的过期时间。</li></ul><p>日志配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">access_log</span> /var/log/nginx/access.log;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br></pre></td></tr></table></figure><h1 id="六-系统层面优化"><a href="#六-系统层面优化" class="headerlink" title="六 系统层面优化"></a>六 系统层面优化</h1><ul><li>调整文件描述符限制（在 <code>/etc/sysctl.conf</code> 中设置）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max = 65535</span><br></pre></td></tr></table></figure><ul><li>调整 TCP 连接队列大小（在 <code>/etc/sysctl.conf</code> 中设置）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.somaxconn = 1024</span><br></pre></td></tr></table></figure><h1 id="七-故障转移优化"><a href="#七-故障转移优化" class="headerlink" title="七 故障转移优化"></a>七 故障转移优化</h1><ul><li>优化健康检查，调整健康检查的频率、超时时间、检查的内容等参数，以更准确地检测服务器的故障。</li><li>结合监控系统，实时监控服务器的健康状况、请求流量、响应时间等指标，及时发现潜在的问题，并进行预警和处理。</li></ul><p>配置健康检查（使用第三方模块 <code>nginx_upstream_check_module</code>）：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com check;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com check;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们还做过哪些 Nginx 性能优化配置呢？欢迎留言讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;小伙伴们平时使用 Nginx 是否有进行过性能优化呢？还是软件装好了就直接使用呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://www.javaboy.org/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="http://www.javaboy.org/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-安全加固/安全基线</title>
    <link href="http://www.javaboy.org/2024/1026/nginx-security.html"/>
    <id>http://www.javaboy.org/2024/1026/nginx-security.html</id>
    <published>2024-10-26T00:52:28.000Z</published>
    <updated>2024-12-20T03:00:31.442Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>网络安全的重要性不言而喻。</p><span id="more"></span><p>那么小伙伴们有没有在日常使用 Nginx 的时候，特意去关注下它的安全配置呢？</p><p>今天松哥和小伙伴们讨论一下如何安全的使用 Nginx，给大伙几个建议。</p><h1 id="一-使用最新版"><a href="#一-使用最新版" class="headerlink" title="一 使用最新版"></a>一 使用最新版</h1><p>建议使用最新版的 Nginx，对于已经部署的 Nginx，要及时更新到最新版本，以确保所有已知的安全漏洞都已修补。</p><blockquote><p>Nginx 下载地址：<a href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p></blockquote><h1 id="二-限制连接数量"><a href="#二-限制连接数量" class="headerlink" title="二 限制连接数量"></a>二 限制连接数量</h1><p>Nginx 可以通过 limit_conn_zone 和 limit_conn 两个组件来对客户端访问目录和文件的访问频率和次数进行限制，两个模块都能够对客户端访问进行限制，具体如何使用要结合公司业务环境进行配置。</p><p>举个简单的例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=ops:<span class="number">10m</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.javaboy.org;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">      <span class="attribute">limit_conn</span> ops <span class="number">1</span>;  <span class="comment">#这将指定一个地址只能同时存在一个连接。“one” 与上面的对应，也可以自定义命名</span></span><br><span class="line">      <span class="attribute">limit_rate</span> <span class="number">300k</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到三个配置项：</p><ul><li>limit_zone： 是针对每个 IP 定义一个存储 session 状态的容器，这个示例中定义了一个 10m 的容器，假设每个 session 的大小是 32bytes，那么可以处理 327680 个 session。</li><li>limit_conn ops 1：限制每个 IP 只能发起一个并发连接。</li><li>limit_rate 300k： 对每个连接限速 300k. 注意，这里是对连接限速，而不是对 IP 限速。如果一个 IP 允许两个并发连接，那么这个 IP 就是限速 <code>limit_rate × 2</code>。</li></ul><h1 id="三-限制请求频率"><a href="#三-限制请求频率" class="headerlink" title="三 限制请求频率"></a>三 限制请求频率</h1><p>Nginx 可以通过限制请求频率来防止服务器过载，最常见的场景就是登录请求，可以通过限制请求频率防止账号暴力破解。</p><p>Nginx 官方版本限制 IP 的连接和并发分别有两个模块：</p><ul><li>limit_req_zone：用来限制单位时间内的请求数，即速率限制,采用的漏桶算法 “leaky bucket”。</li><li>limit_req_conn 用来限制同一时间连接数，即并发限制。</li></ul><p><strong>举个栗子</strong>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=mylimit:<span class="number">10m</span> rate=1r/s;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">limit_req</span> zone=mylimit burst=<span class="number">5</span> nodelay;;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://javaboy.org;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>limit_req_zone $binary_remote_addr zone&#x3D;mylimit:10m rate&#x3D;1r&#x2F;s;</strong></p><ul><li>第一个参数：$binary_remote_addr 表示通过 remote_addr 这个标识来做限制，“binary_” 的目的是缩写内存占用量，是限制同一客户端 ip 地址。</li><li>第二个参数：zone&#x3D;mylimit:10m 表示生成一个大小为 10M，名字为 mylimit 的内存区域，用来存储访问的频次信息。</li><li>第三个参数：rate&#x3D;1r&#x2F;s 表示允许相同标识的客户端的访问频次，这里限制的是每秒 1 次，还可以有比如 30r&#x2F;m 的。</li></ul><p><strong>limit_req zone&#x3D;mylimit burst&#x3D;5 nodelay;</strong></p><ul><li>第一个参数：zone&#x3D;one 设置使用哪个配置区域来做限制，与上面 limit_req_zone 里的 name 对应。</li><li>第二个参数：burst&#x3D;5，重点说明一下这个配置，burst 爆发的意思，这个配置的意思是设置一个大小为 5 的缓冲区，当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内。</li><li>第三个参数：nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回 503，如果没有设置，则所有请求会等待排队。</li></ul><h1 id="四-防止目录遍历"><a href="#四-防止目录遍历" class="headerlink" title="四 防止目录遍历"></a>四 防止目录遍历</h1><p>在 Nginx 配置中设置 <code>autoindex off</code> 来防止目录遍历攻击。</p><p>这个一般是如果你要做文件服务器，根据自己的实际需求，有需要的话这个功能可以打开，否则将之关闭即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-隐藏-Nginx-版本号"><a href="#五-隐藏-Nginx-版本号" class="headerlink" title="五 隐藏 Nginx 版本号"></a>五 隐藏 Nginx 版本号</h1><p>攻击者如果能够确定服务器使用的 Nginx 版本，可能会利用这个信息来寻找和利用已知的漏洞进行攻击。因此，隐藏版本信息可以提高服务器的安全性，使攻击者难以通过版本信息推断出服务器可能存在的安全漏洞。</p><p>要隐藏 Nginx 版本号，有三个办法，一般来说我们使用第一种方式就可以了。</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在 Nginx 的配置文件中，在 <code>http</code> 块中添加以下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server_tokens</span> <span class="literal">off</span>;</span><br></pre></td></tr></table></figure><p>这样设置后，Nginx 将不会在错误页面上显示版本号。</p><p>配置完成之后，保存配置文件并重新加载 Nginx 以应用更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -t   # 测试配置文件是否正确</span><br><span class="line">nginx -s reload   # 重新加载Nginx配置</span><br></pre></td></tr></table></figure><p>这种方法可以隐藏错误页面上的版本信息，但可能无法完全隐藏所有响应头中的版本信息 。</p><h3 id="修改-Nginx-源码"><a href="#修改-Nginx-源码" class="headerlink" title="修改 Nginx 源码"></a>修改 Nginx 源码</h3><p>如果想要从根源上修改 Nginx 版本信息，需要重新编译 Nginx，步骤如下：</p><ul><li>修改 <code>src/core/nginx.h</code> 文件中的版本定义。</li><li>修改 <code>src/http/ngx_http_header_filter_module.c</code> 文件中的服务器字符串。</li><li>修改 <code>src/http/ngx_http_special_response.c</code> 文件中的错误页面底部信息。</li></ul><p>修改完这些文件后，需要重新编译 Nginx。这样编译安装后，Nginx 的版本信息将被彻底修改 。</p><h3 id="使用第三方模块"><a href="#使用第三方模块" class="headerlink" title="使用第三方模块"></a>使用第三方模块</h3><p>如果需要动态修改响应头中的版本信息，可以使用如 <code>headers-more-nginx-module</code> 模块。这个模块允许你动态地添加、修改或删除 Nginx 的响应头。通过这个模块，可以完全控制 <code>Server</code> 响应头的内容 。</p><p>选择哪种方法取决于你的具体需求和环境。</p><p>如果你只是想简单地隐藏版本信息，修改配置文件可能是最简单的方法。如果你需要更彻底地控制版本信息，可能需要考虑修改源码并重新编译 Nginx。</p><h1 id="六-设置超时时间"><a href="#六-设置超时时间" class="headerlink" title="六 设置超时时间"></a>六 设置超时时间</h1><p>设置 Nginx 的超时配置是非常重要的，因为它可以影响服务器的性能和资源的有效利用。</p><p>比较常见的超时配置有四个：</p><ol><li><strong>keepalive_timeout</strong>：这个指令设置了与客户端的 <code>keep-alive</code> 连接超时时间。如果连接在指定时间内没有数据传输，Nginx 将关闭该连接。默认值通常是 75 秒。这个设置对于频繁访问的站点尤其重要，因为它减少了连接建立和断开的开销。</li><li><strong>client_body_timeout</strong>：这个指令指定了客户端与服务端建立连接后发送 request body 的超时时间。如果客户端在指定时间内没有发送任何内容，Nginx 返回 HTTP 408（Request Timed Out）。默认值通常是 60 秒。</li><li><strong>client_header_timeout</strong>：这个指令指定了客户端向服务端发送一个完整的 request header 的超时时间。如果在指定时间内没有发送一个完整的 request header，Nginx 返回 HTTP 408（Request Timed Out）。默认值通常是 60 秒。</li><li><strong>send_timeout</strong>：这个指令设置了服务端向客户端传输数据的超时时间。如果在指定时间内客户端没有接收到任何数据，连接将被关闭。默认值通常是 60 秒。</li></ol><p>针对这四个比较常见的超时配置，松哥这里也给大家一个配置案例。</p><h3 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h3><p>这个指令控制了客户端与服务器之间的连接保持活动状态的时间。这对于减少 TCP 连接的开销非常有用，特别是在高流量的网站上。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">60s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> javaboy.org;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://javaboy.org;</span><br><span class="line">            <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置中，<code>keepalive_timeout</code> 被设置为 60 秒，意味着如果 60 秒内没有数据传输，连接将被关闭。</p><h3 id="client-body-timeout"><a href="#client-body-timeout" class="headerlink" title="client_body_timeout"></a>client_body_timeout</h3><p>这个指令设置了客户端发送请求体到服务器的超时时间。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">client_body_timeout</span> <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> javaboy.org;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /upload &#123;</span><br><span class="line">            <span class="attribute">client_max_body_size</span> <span class="number">100M</span>;</span><br><span class="line">            <span class="attribute">client_body_timeout</span> <span class="number">30s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置中，<code>client_body_timeout</code> 被设置为 10 秒，适用于上传大文件的场景，确保如果客户端在 30 秒内没有完成文件上传，请求将被终止。</p><h3 id="client-header-timeout"><a href="#client-header-timeout" class="headerlink" title="client_header_timeout"></a>client_header_timeout</h3><p>这个指令控制了客户端发送完整的 HTTP 请求头到服务器的超时时间。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">client_header_timeout</span> <span class="number">5s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> javaboy.org;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://javaboy.org;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置中，<code>client_header_timeout</code> 被设置为 5 秒，意味着如果客户端在 5 秒内没有发送完整的 HTTP 请求头，服务器将终止连接。</p><h3 id="send-timeout"><a href="#send-timeout" class="headerlink" title="send_timeout"></a>send_timeout</h3><p>这个指令设置了服务器发送响应到客户端的超时时间。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">send_timeout</span> <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> javaboy.org;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://javaboy.org;</span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">10s</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置中，<code>send_timeout</code> 被设置为 10 秒，适用于后端服务响应慢的场景，确保如果后端服务在 10 秒内没有发送数据，客户端将收到超时响应。</p><h1 id="七-仅允许域名访问"><a href="#七-仅允许域名访问" class="headerlink" title="七 仅允许域名访问"></a>七 仅允许域名访问</h1><p>限制仅允许域名访问可以防止未授权的 IP 直接访问服务器，减少未备案域名解析到服务器 IP 导致的安全风险。</p><p>这个也有三种不同的配置方式，我们逐一来看。</p><h3 id="使用两个-server-块"><a href="#使用两个-server-块" class="headerlink" title="使用两个 server 块"></a>使用两个 <code>server</code> 块</h3><p>在 Nginx 配置文件中，你可以设置一个默认的 server 块，它将捕获所有不明确的域名请求，并返回 403 错误。然后，为特定的域名设置 server 块。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.javaboy.org;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 你的配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置中，第一个 <code>server</code> 块会拦截所有不明确域名的请求，并返回 403 错误。第二个 <code>server</code> 块则是为特定域名 <code>www.javaboy.org</code> 提供服务的配置。</p><p>这个配置有两点需要注意：</p><ol><li>如果没有显式声明 default server 则第一个 server 会被隐式的设为 default server。</li><li>server_name 中的 <code>_;</code>，并不是重点 <code>__</code> 也可以， <code>___</code> 也可以。</li></ol><h3 id="使用-if-语句"><a href="#使用-if-语句" class="headerlink" title="使用 if 语句"></a>使用 <code>if</code> 语句</h3><p>还可以在特定的 <code>server</code> 块中使用 <code>if</code> 语句来检查 <code>$host</code> 变量，如果它不匹配你的域名，则返回 403 错误。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> javaboy.org;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$host</span> != <span class="string">&#x27;www.javaboy.org&#x27;</span>) &#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 你的配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法允许你在特定域名的 server 块中直接控制访问权限，只有当 <code>$host</code> 变量与你的域名匹配时，才会允许访问。</p><h3 id="直接禁止-IP"><a href="#直接禁止-IP" class="headerlink" title="直接禁止 IP"></a>直接禁止 IP</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.javaboy.org;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.itboyhub.com;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 直接指定 ip server_name</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> <span class="number">11.11.11.11</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>; <span class="comment"># 403 forbidden</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置后，只有通过指定的域名才能访问网站，直接通过 IP 地址访问将会受到限制。</p><h1 id="八-限制-Nginx-请求方法"><a href="#八-限制-Nginx-请求方法" class="headerlink" title="八 限制 Nginx 请求方法"></a>八 限制 Nginx 请求方法</h1><p>通过限制特定的 HTTP 请求方法，可以减少服务器受到自动化攻击的风险，并且可以防止某些类型的 Web 漏洞，如 SQL 注入或跨站脚本（XSS）攻击。</p><p>有两种配置方式，松哥来和大家逐一说明。</p><h3 id="只允许-GET-和-POST"><a href="#只允许-GET-和-POST" class="headerlink" title="只允许 GET 和 POST"></a>只允许 GET 和 POST</h3><p>在 <code>server</code> 或 <code>location</code> 块中，使用 <code>if</code> 语句来检查请求方法，并返回 403 错误码以拒绝其他方法。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> javaboy.org;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$request_method</span> !<span class="regexp">~* (GET|POST))</span> &#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 其他配置...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法会拒绝所有非 GET 和 POST 的请求方法。</p><h3 id="使用-map-模块"><a href="#使用-map-模块" class="headerlink" title="使用 map 模块"></a>使用 map 模块</h3><p>对于更复杂的限制逻辑，可以使用 Nginx 的 <code>map</code> 模块来动态设置请求方法的限制。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">map</span> <span class="variable">$request_method</span> <span class="variable">$block_request</span> &#123;</span><br><span class="line">        <span class="attribute">default</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">POST</span> <span class="number">1</span>;</span><br><span class="line">        <span class="attribute">PUT</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> javaboy.org;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">if</span> (<span class="variable">$block_request</span>) &#123;</span><br><span class="line">                <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment"># 其他配置...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，所有 POST 和 PUT 请求都会被拒绝。</p><h1 id="九-错误页面重定向"><a href="#九-错误页面重定向" class="headerlink" title="九 错误页面重定向"></a>九 错误页面重定向</h1><p>在 Nginx 中配置错误页面重定向，除了安全因素之外，还有很多好处，比如：</p><ol><li><strong>提升用户体验</strong>：通过提供更友好的错误页面，可以减少用户在遇到错误时的困惑和挫败感。</li><li><strong>增强 SEO 效果</strong>：自定义错误页面可以帮助搜索引擎更好地理解网站结构，避免因错误页面导致的 SEO 问题。</li><li><strong>维护品牌形象</strong>：错误页面是网站的一部分，通过自定义错误页面，可以保持品牌一致性，提升专业形象。</li><li><strong>提供错误信息</strong>：自定义错误页面可以提供有用的错误信息或解决方案，帮助用户理解问题所在。</li></ol><p>在 Nginx 配置文件中，可以使用 <code>error_page</code> 指令来定义特定错误代码的重定向页面。例如，将 404 错误重定向到自定义的 404 页面：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> javaboy.org;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">    <span class="section">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        <span class="attribute">root</span> /path/to/<span class="literal">error</span>/pages;</span><br><span class="line">        internal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置中，当 Nginx 返回 404 错误时，它会显示位于 <code>/path/to/error/pages/404.html</code> 的自定义错误页面，而不是默认的错误页面。<code>internal</code> 指令确保这个页面只对 Nginx 内部请求可见，不会被外部直接访问 。</p><p>当然，上面这个配置也可以同时枚举多个错误状态码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line"><span class="section">location</span> = /50x.html &#123;</span><br><span class="line">    <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置会将所有 500 系列错误重定向到 <code>/50x.html</code>，并显示位于 <code>/usr/share/nginx/html/50x.html</code> 的自定义错误页面 。</p><h1 id="十-日志保留半年"><a href="#十-日志保留半年" class="headerlink" title="十 日志保留半年"></a>十 日志保留半年</h1><p>保留 Nginx 日志半年的原因有很多，比如：</p><ol><li><strong>安全审计</strong>：日志文件可以用于安全审计，帮助分析和追踪潜在的攻击或异常行为。</li><li><strong>故障排查</strong>：在系统出现故障时，日志文件是诊断问题的重要工具，可以帮助快速定位问题原因。</li><li><strong>性能监控</strong>：通过分析日志，可以了解网站的访问情况和性能瓶颈，从而进行相应的优化。</li><li><strong>合规性要求</strong>：某些行业法规可能要求保留一定期限的日志记录，以满足合规性检查。</li></ol><p>要配置 Nginx 日志保留半年，通常需要使用 <code>logrotate</code> 工具来实现日志文件的定期轮换和压缩。</p><p>这个工具配置并不难，松哥给大家举个栗子。</p><p>在 <code>/etc/logrotate.d/</code> 目录下创建一个名为 <code>nginx</code> 的配置文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/var/log/nginx/*.log &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 180</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    sharedscripts</span><br><span class="line">    postrotate</span><br><span class="line">        [ -f /var/run/nginx.pid ] &amp;&amp; kill -USR1 `cat /var/run/nginx.pid`</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置会每天检查 Nginx 日志文件，并将它们保留 180 天（约 6 个月），然后自动压缩旧的日志文件。<code>postrotate</code> 部分的命令会在日志轮换后重新打开 Nginx 日志文件，以便继续记录新的日志信息。</p><p>通过这些配置，我们可以确保 Nginx 的日志文件被保留半年，同时旧的日志文件会被压缩以节省磁盘空间。</p><h1 id="十一-设置缓冲区"><a href="#十一-设置缓冲区" class="headerlink" title="十一 设置缓冲区"></a>十一 设置缓冲区</h1><p>Nginx 的缓冲区溢出攻击是一种常见的安全漏洞，它发生在程序试图向一个缓冲区写入超出其预分配大小的数据时。</p><p>这种攻击可能导致数据覆盖了相邻的内存区域，可能破坏程序的执行流程，甚至可以被恶意攻击者利用来执行恶意代码。</p><p>为了防止缓冲区溢出类攻击事件，可以设置客户端请求体、请求头和客户端最大请求体的缓冲区大小。</p><p>配置方式如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">client_body_buffer_size</span> <span class="number">1K</span>;</span><br><span class="line"><span class="attribute">client_header_buffer_size</span> <span class="number">1k</span>;</span><br><span class="line"><span class="attribute">client_max_body_size</span> <span class="number">1k</span>;</span><br><span class="line"><span class="attribute">large_client_header_buffers</span> <span class="number">2</span> <span class="number">1k</span>;</span><br></pre></td></tr></table></figure><p>这四行配置含义如下：</p><ul><li><code>client_body_buffer_size 1K;</code>：这条指令设置了 Nginx 用来读取客户端请求体（比如 POST 请求中的数据）的缓冲区大小。在这个例子中，缓冲区大小被设置为 1KB。如果请求体的大小超过了这个缓冲区的大小，Nginx 会使用磁盘来暂存超出部分的数据。</li><li><code>client_header_buffer_size 1k;</code>：这条指令定义了 Nginx 用来读取客户端 HTTP 请求头部的缓冲区大小。这里设置的大小是 1KB。如果请求头部的大小超过了这个缓冲区的大小，Nginx 会使用 <code>large_client_header_buffers</code> 定义的缓冲区。</li><li><code>client_max_body_size 1k;</code>：这条指令限制了 Nginx 服务器愿意接收的最大请求体大小。如果客户端发送的请求体超过了这个大小（在这个例子中是 1KB），Nginx 将返回一个 413（Request Entity Too Large）错误。</li><li><code>large_client_header_buffers 2 1k;</code>：这条指令定义了 Nginx 用于处理大于 <code>client_header_buffer_size</code> 指定大小的请求头的缓冲区数量和大小。这里配置了 2 个大小为 1KB 的缓冲区。当请求头的大小超过了 <code>client_header_buffer_size</code> 定义的缓冲区大小时，Nginx 会使用这两个额外的缓冲区来处理请求头。</li></ul><p>这些配置对于防止缓冲区溢出攻击和处理大请求都是非常重要的。</p><h1 id="十二-使用普通用户启动"><a href="#十二-使用普通用户启动" class="headerlink" title="十二 使用普通用户启动"></a>十二 使用普通用户启动</h1><p>在 Linux 系统中，只有 root 用户或者具有特定权限的用户才能绑定 1024 以下的端口，如 80 端口（HTTP）和 443 端口（HTTPS）。</p><p>如果 Nginx 以 root 用户运行，它将拥有过高的权限，这可能会带来安全风险。因此，为了最小化权限，通常会创建一个普通用户来运行 Nginx，以减少潜在的安全漏洞。</p><p>配置方式如下：</p><ol><li><strong>创建用户</strong></li></ol><p>首先，你需要创建一个普通用户和用户组，例如 <code>nginx</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd nginx</span><br><span class="line">useradd -g nginx -d /usr/local/nginx nginx</span><br></pre></td></tr></table></figure><p>这里创建了一个名为 <code>nginx</code> 的用户和组，并设置了用户的家目录。</p><ol start="2"><li><strong>授权访问</strong></li></ol><p>确保新用户有权访问 Nginx 的配置文件、日志文件和服务器文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R nginx:nginx /usr/local/nginx/</span><br></pre></td></tr></table></figure><p>这条命令将 Nginx 目录及其所有子目录和文件的所有权更改为新创建的 <code>nginx</code> 用户和组。</p><ol start="3"><li><strong>配置Nginx</strong></li></ol><p>编辑 Nginx 配置文件（通常位于 <code>/etc/nginx/nginx.conf</code>），设置 <code>user</code> 指令以指定 Nginx 工作进程的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user nginx;</span><br></pre></td></tr></table></figure><p>这行配置指定 Nginx 应该以 <code>nginx</code> 用户的身份运行。</p><ol start="4"><li><strong>设置权限</strong></li></ol><p>如果需要，可以使用 <code>setcap</code> 命令赋予 Nginx 监听 1024 以下端口的能力，而不需要以 root 用户运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcap cap_net_bind_service=+ep /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>这个命令允许 Nginx 以普通用户身份绑定到 80 和 443 端口。</p><ol start="5"><li><strong>启动Nginx</strong></li></ol><p>使用普通用户启动 Nginx。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - nginx</span><br><span class="line">/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>这里首先切换到 <code>nginx</code> 用户，然后启动 Nginx 服务。</p><ol start="6"><li><strong>验证</strong></li></ol><p>检查 Nginx 是否以普通用户启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>这条命令将显示 Nginx 的进程信息，你可以验证它是否以 <code>nginx</code> 用户运行。</p><p>好啦，小伙伴们还有哪些 Nginx 安全配置建议？欢迎留言讨论。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;网络安全的重要性不言而喻。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://www.javaboy.org/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="http://www.javaboy.org/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis对象共享池，性能优化小细节</title>
    <link href="http://www.javaboy.org/2024/1025/redis-object-share-pool.html"/>
    <id>http://www.javaboy.org/2024/1025/redis-object-share-pool.html</id>
    <published>2024-10-25T00:52:17.000Z</published>
    <updated>2024-12-20T02:57:20.678Z</updated>
    
    <content type="html"><![CDATA[<p>如果你仔细研究过 Redis 中各种实现细节，你会发现为了性能，Redis 真的是不遗余力。</p><span id="more"></span><p>作为一种高性能的键值存储系统，Redis 广泛用于缓存、会话管理、消息队列等多种场景。</p><p>为了提高 Redis 在处理大量数据时的性能和效率，Redis 设计并实现了对象共享池（Shared Object Pool）这一内部机制。</p><p>那么接下来松哥就和大家详细说一说 Redis 中的对象共享池。</p><h1 id="一-设计目的"><a href="#一-设计目的" class="headerlink" title="一 设计目的"></a>一 设计目的</h1><p>Redis 的对象共享池主要用于复用一些常用的数据对象，以减少内存的开销。</p><p>在 Redis 中，一些常用的数据对象，主要是小整数（如 0 到 9999）等，是不会被改变的，因此可以安全地共享使用而无需重复创建。</p><p>例如你设置 <code>set k1 99</code> 和 <code>set k2 99</code>，这时 k1 和 k2 其实指向的是同一个对象。</p><p>通过共享这些对象，Redis 能够显著降低内存的使用量，并减少对象的创建和销毁时间，从而提升整体性能。</p><h1 id="二-工作原理"><a href="#二-工作原理" class="headerlink" title="二 工作原理"></a>二 工作原理</h1><p>在 Redis 服务器启动时，会预先创建并存储一些常用的对象到一个全局的哈希表中，这个哈希表就是对象共享池。</p><p>当 Redis 需要处理一个键值对时，会首先检查这个键值对中的值是否已经在对象共享池中。如果已存在，Redis 将直接引用该对象，而不是创建一个新的对象。</p><h1 id="三-支持的对象类型"><a href="#三-支持的对象类型" class="headerlink" title="三 支持的对象类型"></a>三 支持的对象类型</h1><p>目前主要是支持小整型，也就是 0～9999 之间的整数，浮点型数据不支持。</p><h1 id="四-应用场景"><a href="#四-应用场景" class="headerlink" title="四 应用场景"></a>四 应用场景</h1><p>对象共享池在多种场景下都能显著提升 Redis 的性能和效率，特别是在处理大量重复数据时。例如，在 Web 应用中，许多缓存的键值对可能包含相同的值，通过对象共享池，这些值可以被多个键值对共享，从而节省大量内存。</p><p><strong>注意事项</strong></p><ul><li>只读性：对象共享池中的对象是只读的，不可修改。如果应用程序需要修改这些对象，Redis 会将其复制并创建一个新的对象进行操作。因此，在使用共享对象时，需要注意对象的可修改性。</li><li>内存策略：当 Redis 设置了最大内存值（maxmemory）并启用了 LRU（最近最少使用）等相关淘汰策略时，对象共享池可能会被禁用。这是因为在内存紧张的情况下，共享对象可能不再是最优选择。</li></ul><h1 id="五-实际案例"><a href="#五-实际案例" class="headerlink" title="五 实际案例"></a>五 实际案例</h1><p>为了通过实际案例证明 Redis 中对象共享池的存在，我们可以结合 Redis 的内部机制和一些实际操作来进行分析。虽然 Redis 的官方文档没有直接提及“对象共享池”这一术语，但我们可以从 Redis 如何处理整数对象的共享中看到其背后的共享机制。</p><p>假设我们有一个 Redis 服务器，它用于存储和访问大量的键值对。在这些键值对中，有一部分键对应的值是常见的小整数。</p><p>我们来执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET k1 1  </span><br><span class="line">OBJECT REFCOUNT k1  </span><br><span class="line">SET k2 1  </span><br><span class="line">OBJECT REFCOUNT k1</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2024/mp/20240908104302.png"></p><p>这里我要跟大家解释下。</p><p>OBJECT REFCOUNT 命令理论上可以查看某一个 key 对应的 value 被引用的次数。</p><p>所以我们期望第一次执行 <code>OBJECT REFCOUNT k1</code> 的时候返回 1，第二次执行 <code>OBJECT REFCOUNT k1</code> 的时候返回 2，但是实际上却并非如此，每次都是返回 2^31-1。</p><blockquote><p>虽然这里并没有返回我们想要的值，但是大家可以看到，<code>OBJECT REFCOUNT k1</code> 返回的值确实和 value 为字符串的 key 的返回值是不同的。</p></blockquote><p>松哥来解释下原因。</p><p>通过分析 Redis 源码，松哥发现新版本的 redis 中 OBJ_SHARED_INTEGERS 变量定义了共享整数 10000，并且定义不被销毁的全局对象的引用数量 OBJ_SHARED_REFCOUNT 为 INT_MAX，INT_MAX &#x3D; 2^31 - 1 &#x3D;2147483647。</p><p>源码位置在：<a href="https://github.com/redis/redis/blob/unstable/src/server.h#L903%E3%80%82">https://github.com/redis/redis/blob/unstable/src/server.h#L903。</a></p><p><img src="http://img.itboyhub.com/2024/mp/20240908105429.png"></p><p>并且从源码中可以看到当把一个对象设置为共享时候就会把 refcount 设置为 INT_MAX。</p><p>源码位置在：<a href="https://github.com/redis/redis/blob/unstable/src/object.c#L56%E3%80%82">https://github.com/redis/redis/blob/unstable/src/object.c#L56。</a></p><p><img src="http://img.itboyhub.com/2024/mp/20240908105557.png"></p><p>从这里就能看出，如果某个对象的引用次数是 2^31-1，那么就说明这个对象是一个引用对象。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你仔细研究过 Redis 中各种实现细节，你会发现为了性能，Redis 真的是不遗余力。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="http://www.javaboy.org/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://www.javaboy.org/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot集成iText实现电子签章</title>
    <link href="http://www.javaboy.org/2024/1023/springboot-itext-sign.html"/>
    <id>http://www.javaboy.org/2024/1023/springboot-itext-sign.html</id>
    <published>2024-10-23T00:52:05.000Z</published>
    <updated>2024-12-20T02:58:45.490Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一-电子签章"><a href="#一-电子签章" class="headerlink" title="一 电子签章"></a>一 电子签章</h1><h2 id="1-1-什么是电子签章"><a href="#1-1-什么是电子签章" class="headerlink" title="1.1 什么是电子签章"></a>1.1 什么是电子签章</h2><p>基于《中华人民共和国电子签名法》等相关法规和技术规范，具有法律效力的电子签章一定是需要使用 CA 数字证书进行对文件签名，并把 CA 数字证书存放在签名后文件中。</p><span id="more"></span><p>如果一份签名后的电子文件中无法查看到 CA 数字证书，仅存在一个公章图片，那么就不属于法律意义上的电子签名。电子签名法规定电子文件签署时一定要使用CA数字证书，并没有要求一定需要含有电子印章图片，理论上电子签章不需要到公安局进行备案。</p><p>实际上，电子签章是在电子签名技术的基础上添加了印章图像外观，沿袭了人们所习惯的传统盖章可视效果。电子签章使用电子签名技术来保障电子文件内容的防篡改性和签署者的不可否认性。因此，电子签章中，印章图片并不是唯一鉴别是否签章的条件，还要鉴别是否使用高级电子签名技术和 CA 数字证书。 </p><p>CA 数字证书是在互联网中用于识别身份的一种具有权威性的电子文档。CA 数字证书相当于现实中的身份证。 </p><p>现实中，如同个人需要去公安局申请办理身份证一样，CA 数字证书需要在“电子认证服务机构”（简称 CA 机构）进行申请办理。中国工业和信息化部、工信部授权 CA 机构来制作、签发数字证书，用非对称加密的方式，生成一对密码即私钥与公开密钥，并绑定了数字证书持有者的真实身份，人们可以在电子合同的缔约过程中用它来证明自己的身份和验证对方的身份。 </p><p>CA 机构颁发的数字证书为公钥证书和私钥证书：公钥证书是对外公开、任何人都可以使用的，而私钥是专属于签署人所有的。当需要签署文档时，签署人使用私钥证书对电子文件（文档哈希值）进行加密，形成电子签名。 (注：文档哈希值计算时包含待签 PDF 文档内容、印章图片和印章坐标位置信息)</p><p>哈希值是指将 PDF 文件按照一定的算法（目前主流是 SHA256 算法），形成一个唯一的文件代码，类似于人类的指纹，任何一个 PDF 文件只有一个哈希值，且不同 PDF 文件的哈希值不可能相同，而相同哈希值的 PDF 文件的内容肯定相同。哈希算法是不可逆的，从哈希值无法推导出 PDF 原文内容。 </p><p>经签署人的私钥证书加密之后的 PDF 原文哈希值就是电子签名，电子签名中有签署人的姓名、身份证号码、证书有效期、公钥等信息，电子签名放在 PDF 原文的签名域中，就形成了带有电子签名的 PDF 文件。</p><h2 id="1-2-签名流程"><a href="#1-2-签名流程" class="headerlink" title="1.2 签名流程"></a>1.2 签名流程</h2><p>文件电子签名过程，如下图：</p><p><img src="http://img.itboyhub.com/2024/mp/20241008175644.png"></p><p>其他人收到这个文件，即可使用PDF文件的签名域中存储的公钥证书对电子签名进行解密，解密出来的文件哈希值如果与原文的哈希值一致，则代表这个文件没有被篡改。 </p><p>电子签名文件验签过程，如下图：</p><p><img src="http://img.itboyhub.com/2024/mp/20241008175809.png"></p><h2 id="1-3-技术选型"><a href="#1-3-技术选型" class="headerlink" title="1.3 技术选型"></a>1.3 技术选型</h2><p>这块主要有两大技术体系：</p><ol><li>开源组织 Apache 的 PDFBox。</li><li>Adobe 的 iText，其中 iText 又分为 iText5 和 iText7。</li></ol><p>那么这两个该如何选择呢？</p><ul><li>PDFBox 的功能相对较弱，iText5 和 iText7 的功能非常强悍。</li><li>iText5 资料网上相对较多，如果出现问题容易找到解决方案。</li><li>PDFBox 和 iText7 的网上资料相对较少，如果出现问题不易找到相关解决方案。</li><li>PDFBox 目前提供的自定义签章接口不完整；而 iText5 和 iText7 提供了处理自定义签章的相关实现。</li><li>PDFBox 只能实现把签章图片加签到 PDF 文件；iText5 和 iText7 除了可以把签章图片加签到 PDF 文件，还可以实现直接对签章进行绘制，把文件绘制到签章上。</li><li>PDFBox 和 iText5&#x2F;iText7 使用的协议不一样。PDFBox 使用的是 APACHE LICENSE VERSION 2.0（Licenses）；iText5&#x2F;iText7 使用的是 AGPL（<a href="https://itextpdf.com/agpl%EF%BC%89%E3%80%82PDFBox">https://itextpdf.com/agpl）。PDFBox</a> 免费使用，AGPL 商用收费。</li></ul><p>因此这里松哥就以 iText5 为例来和小伙伴们演示如何给一个 PDF 文件签名。</p><h1 id="二-实战"><a href="#二-实战" class="headerlink" title="二 实战"></a>二 实战</h1><h2 id="2-1-生成数字证书"><a href="#2-1-生成数字证书" class="headerlink" title="2.1 生成数字证书"></a>2.1 生成数字证书</h2><p>首先我们需要生成一个数字证书。</p><p>这个数字证书我们可以利用 JDK 自带的工具生成，为了贴近实战，松哥这里使用 Java 代码生成，生成数字证书的方式如下。</p><p>首先引入 Bouncy Castle，Bouncy Castle 是一个广泛使用的开源加密库，它为 Java 平台提供了丰富的密码学算法实现，包括对称加密、非对称加密、哈希算法、数字签名等。这个库由于其广泛的算法支持和可靠性而备受信任，被许多安全应用和加密通信协议所采用<br>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.bouncycastle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bcpkix-jdk15on<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.bouncycastle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bcprov-ext-jdk15on<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.70<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们写一个生成数字证书的工具类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.bouncycastle.asn1.ASN1ObjectIdentifier;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.asn1.x500.X500Name;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.asn1.x509.*;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.cert.X509CertificateHolder;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.cert.X509v3CertificateBuilder;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.operator.ContentSigner;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.CertificateFactory;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@site</span>：http://www.javaboy.org</span></span><br><span class="line"><span class="comment"> * @微信公众号：江南一点雨</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span>：https://github.com/lenve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@gitee</span>：https://gitee.com/lenve</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PkcsUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成证书</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchAlgorithmException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> KeyPair <span class="title function_">getKey</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">        generator.initialize(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 证书中的密钥 公钥和私钥</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> generator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成证书</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> issuerStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subjectStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> certificateCRL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, <span class="type">byte</span>[]&gt; createCert(String password, String issuerStr, String subjectStr, String certificateCRL) &#123;</span><br><span class="line">        Map&lt;String, <span class="type">byte</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, <span class="type">byte</span>[]&gt;();</span><br><span class="line">        <span class="keyword">try</span>(ByteArrayOutputStream out= <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            <span class="comment">// 标志生成PKCS12证书</span></span><br><span class="line">            <span class="type">KeyStore</span> <span class="variable">keyStore</span> <span class="operator">=</span> KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>, <span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">            keyStore.load(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> getKey();</span><br><span class="line">            <span class="comment">// issuer与 subject相同的证书就是CA证书</span></span><br><span class="line">            <span class="type">X509Certificate</span> <span class="variable">cert</span> <span class="operator">=</span> generateCertificateV3(issuerStr, subjectStr,</span><br><span class="line">                    keyPair, result, certificateCRL);</span><br><span class="line">            <span class="comment">// 证书序列号</span></span><br><span class="line">            keyStore.setKeyEntry(<span class="string">&quot;cretkey&quot;</span>, keyPair.getPrivate(),</span><br><span class="line">                    password.toCharArray(), <span class="keyword">new</span> <span class="title class_">X509Certificate</span>[]&#123;cert&#125;);</span><br><span class="line">            cert.verify(keyPair.getPublic());</span><br><span class="line">            keyStore.store(out, password.toCharArray());</span><br><span class="line">            <span class="type">byte</span>[] keyStoreData = out.toByteArray();</span><br><span class="line">            result.put(<span class="string">&quot;keyStoreData&quot;</span>, keyStoreData);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成证书</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> issuerStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subjectStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> certificateCRL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> X509Certificate <span class="title function_">generateCertificateV3</span><span class="params">(String issuerStr,</span></span><br><span class="line"><span class="params">                                                        String subjectStr, KeyPair keyPair, Map&lt;String, <span class="type">byte</span>[]&gt; result,</span></span><br><span class="line"><span class="params">                                                        String certificateCRL)</span> &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bint</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">X509Certificate</span> <span class="variable">cert</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">PublicKey</span> <span class="variable">publicKey</span> <span class="operator">=</span> keyPair.getPublic();</span><br><span class="line">            <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyPair.getPrivate();</span><br><span class="line">            <span class="type">Date</span> <span class="variable">notBefore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">            <span class="type">Calendar</span> <span class="variable">rightNow</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">            rightNow.setTime(notBefore);</span><br><span class="line">            <span class="comment">// 日期加1年</span></span><br><span class="line">            rightNow.add(Calendar.YEAR, <span class="number">1</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">notAfter</span> <span class="operator">=</span> rightNow.getTime();</span><br><span class="line">            <span class="comment">// 证书序列号</span></span><br><span class="line">            <span class="type">BigInteger</span> <span class="variable">serial</span> <span class="operator">=</span> BigInteger.probablePrime(<span class="number">256</span>, <span class="keyword">new</span> <span class="title class_">Random</span>());</span><br><span class="line">            <span class="type">X509v3CertificateBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JcaX509v3CertificateBuilder</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">X500Name</span>(issuerStr), serial, notBefore, notAfter,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">X500Name</span>(subjectStr), publicKey);</span><br><span class="line">            <span class="type">JcaContentSignerBuilder</span> <span class="variable">jBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JcaContentSignerBuilder</span>(</span><br><span class="line">                    <span class="string">&quot;SHA1withRSA&quot;</span>);</span><br><span class="line">            <span class="type">SecureRandom</span> <span class="variable">secureRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">            jBuilder.setSecureRandom(secureRandom);</span><br><span class="line">            <span class="type">ContentSigner</span> <span class="variable">singer</span> <span class="operator">=</span> jBuilder.setProvider(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>()).build(privateKey);</span><br><span class="line">            <span class="comment">// 分发点</span></span><br><span class="line">            <span class="type">ASN1ObjectIdentifier</span> <span class="variable">cRLDistributionPoints</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASN1ObjectIdentifier</span>(</span><br><span class="line">                    <span class="string">&quot;2.5.29.31&quot;</span>);</span><br><span class="line">            <span class="type">GeneralName</span> <span class="variable">generalName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralName</span>(</span><br><span class="line">                    GeneralName.uniformResourceIdentifier, certificateCRL);</span><br><span class="line">            <span class="type">GeneralNames</span> <span class="variable">seneralNames</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralNames</span>(generalName);</span><br><span class="line">            <span class="type">DistributionPointName</span> <span class="variable">distributionPoint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributionPointName</span>(</span><br><span class="line">                    seneralNames);</span><br><span class="line">            DistributionPoint[] points = <span class="keyword">new</span> <span class="title class_">DistributionPoint</span>[<span class="number">1</span>];</span><br><span class="line">            points[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">DistributionPoint</span>(distributionPoint, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="type">CRLDistPoint</span> <span class="variable">cRLDistPoint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CRLDistPoint</span>(points);</span><br><span class="line">            builder.addExtension(cRLDistributionPoints, <span class="literal">true</span>, cRLDistPoint);</span><br><span class="line">            <span class="comment">// 用途</span></span><br><span class="line">            <span class="type">ASN1ObjectIdentifier</span> <span class="variable">keyUsage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASN1ObjectIdentifier</span>(</span><br><span class="line">                    <span class="string">&quot;2.5.29.15&quot;</span>);</span><br><span class="line">            <span class="comment">// | KeyUsage.nonRepudiation | KeyUsage.keyCertSign</span></span><br><span class="line">            builder.addExtension(keyUsage, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">KeyUsage</span>(</span><br><span class="line">                    KeyUsage.digitalSignature | KeyUsage.keyEncipherment));</span><br><span class="line">            <span class="comment">// 基本限制 X509Extension.java</span></span><br><span class="line">            <span class="type">ASN1ObjectIdentifier</span> <span class="variable">basicConstraints</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ASN1ObjectIdentifier</span>(</span><br><span class="line">                    <span class="string">&quot;2.5.29.19&quot;</span>);</span><br><span class="line">            builder.addExtension(basicConstraints, <span class="literal">true</span>, <span class="keyword">new</span> <span class="title class_">BasicConstraints</span>(</span><br><span class="line">                    <span class="literal">true</span>));</span><br><span class="line">            <span class="type">X509CertificateHolder</span> <span class="variable">holder</span> <span class="operator">=</span> builder.build(singer);</span><br><span class="line">            <span class="type">CertificateFactory</span> <span class="variable">cf</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X.509&quot;</span>);</span><br><span class="line">            bint = <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(holder.toASN1Structure()</span><br><span class="line">                    .getEncoded());</span><br><span class="line">            cert = (X509Certificate) cf.generateCertificate(bint);</span><br><span class="line">            <span class="type">byte</span>[] certBuf = holder.getEncoded();</span><br><span class="line">            <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">            <span class="comment">// 证书数据</span></span><br><span class="line">            result.put(<span class="string">&quot;certificateData&quot;</span>, certBuf);</span><br><span class="line">            <span class="comment">//公钥</span></span><br><span class="line">            result.put(<span class="string">&quot;publicKey&quot;</span>, publicKey.getEncoded());</span><br><span class="line">            <span class="comment">//私钥</span></span><br><span class="line">            result.put(<span class="string">&quot;privateKey&quot;</span>, privateKey.getEncoded());</span><br><span class="line">            <span class="comment">//证书有效开始时间</span></span><br><span class="line">            result.put(<span class="string">&quot;notBefore&quot;</span>, format.format(notBefore).getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="comment">//证书有效结束时间</span></span><br><span class="line">            result.put(<span class="string">&quot;notAfter&quot;</span>, format.format(notAfter).getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bint != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bint.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cert;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// CN: 名字与姓氏    OU : 组织单位名称</span></span><br><span class="line">        <span class="comment">// O ：组织名称  L : 城市或区域名称  E : 电子邮件</span></span><br><span class="line">        <span class="comment">// ST: 州或省份名称  C: 单位的两字母国家代码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">issuerStr</span> <span class="operator">=</span> <span class="string">&quot;CN=javaboy,OU=产品研发部,O=江南一点雨,C=CN,E=javaboy@gmail.com,L=华南,ST=深圳&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">subjectStr</span> <span class="operator">=</span> <span class="string">&quot;CN=javaboy,OU=产品研发部,O=江南一点雨,C=CN,E=javaboy@gmail.com,L=华南,ST=深圳&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">certificateCRL</span> <span class="operator">=</span> <span class="string">&quot;http://www.javaboy.org&quot;</span>;</span><br><span class="line">        Map&lt;String, <span class="type">byte</span>[]&gt; result = createCert(<span class="string">&quot;123456&quot;</span>, issuerStr, subjectStr, certificateCRL);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">outPutStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;keystore.p12&quot;</span>);</span><br><span class="line">        outPutStream.write(result.get(<span class="string">&quot;keyStoreData&quot;</span>));</span><br><span class="line">        outPutStream.close();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;keystore.cer&quot;</span>));</span><br><span class="line">        fos.write(result.get(<span class="string">&quot;certificateData&quot;</span>));</span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个工具代码，会在我们当前工程目录下生成 <code>keystore.p12</code> 和 <code>keystore.cer</code> 两个文件。</p><p>其中 <code>keystore.cer</code> 文件通常是一个以 DER 或 PEM 格式存储的 X.509 公钥证书，它包含了公钥以及证书所有者的信息，如姓名、组织、地理位置等。</p><p><code>keystore.p12</code> 文件是一个 PKCS#12 格式的文件，它是一个个人信息交换标准，用于存储一个或多个证书以及它们对应的私钥。<code>.p12</code> 文件是加密的，通常需要密码才能打开。这种文件格式便于将证书和私钥一起分发或存储，常用于需要在不同系统或设备间传输证书和私钥的场景。</p><p>总结下就是，<code>.cer</code> 文件通常只包含公钥证书，而 <code>.p12</code> 文件可以包含证书和私钥。</p><h2 id="2-2-生成印章图片"><a href="#2-2-生成印章图片" class="headerlink" title="2.2 生成印章图片"></a>2.2 生成印章图片</h2><p>接下来我们用 Java 代码绘制一个签章图片，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SealSample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Seal</span> <span class="variable">seal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Seal</span>();</span><br><span class="line">        seal.setSize(<span class="number">200</span>);</span><br><span class="line">        <span class="type">SealCircle</span> <span class="variable">sealCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SealCircle</span>();</span><br><span class="line">        sealCircle.setLine(<span class="number">4</span>);</span><br><span class="line">        sealCircle.setWidth(<span class="number">95</span>);</span><br><span class="line">        sealCircle.setHeight(<span class="number">95</span>);</span><br><span class="line">        seal.setBorderCircle(sealCircle);</span><br><span class="line">        <span class="type">SealFont</span> <span class="variable">mainFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SealFont</span>();</span><br><span class="line">        mainFont.setText(<span class="string">&quot;江南一点雨股份有限公司&quot;</span>);</span><br><span class="line">        mainFont.setSize(<span class="number">22</span>);</span><br><span class="line">        mainFont.setFamily(<span class="string">&quot;隶书&quot;</span>);</span><br><span class="line">        mainFont.setSpace(<span class="number">22.0</span>);</span><br><span class="line">        mainFont.setMargin(<span class="number">4</span>);</span><br><span class="line">        seal.setMainFont(mainFont);</span><br><span class="line">        <span class="type">SealFont</span> <span class="variable">centerFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SealFont</span>();</span><br><span class="line">        centerFont.setText(<span class="string">&quot;★&quot;</span>);</span><br><span class="line">        centerFont.setSize(<span class="number">60</span>);</span><br><span class="line">        seal.setCenterFont(centerFont);</span><br><span class="line">        <span class="type">SealFont</span> <span class="variable">titleFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SealFont</span>();</span><br><span class="line">        titleFont.setText(<span class="string">&quot;财务专用章&quot;</span>);</span><br><span class="line">        titleFont.setSize(<span class="number">16</span>);</span><br><span class="line">        titleFont.setSpace(<span class="number">8.0</span>);</span><br><span class="line">        titleFont.setMargin(<span class="number">54</span>);</span><br><span class="line">        seal.setTitleFont(titleFont);</span><br><span class="line">        seal.draw(<span class="string">&quot;公章1.png&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里涉及到的一些工具类文末可以下载。</p></blockquote><p>最终生成的签章图片类似下面这样：</p><p><img src="http://img.itboyhub.com/2024/mp/20241008220824.png"></p><p>现在万事具备，可以给 PDF 签名了。</p><h2 id="2-3-PDF-签名"><a href="#2-3-PDF-签名" class="headerlink" title="2.3 PDF 签名"></a>2.3 PDF 签名</h2><p>最后，我们可以通过如下代码为 PDF 进行签名。</p><p>这里我们通过 iText 来实现电子签章，因此需要先引入 iText：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itextpdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>html2pdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来对 PDF 文件进行签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignPdf2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password pkcs12证书密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyStorePath pkcs12证书路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signPdfSrc 签名pdf路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signImage 签名图片</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] sign(String password, String keyStorePath, String signPdfSrc, String signImage,</span><br><span class="line">                              <span class="type">float</span> x, <span class="type">float</span> y) &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">signPdfSrcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(signPdfSrc);</span><br><span class="line">        <span class="type">PdfReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">signPDFData</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PdfStamper</span> <span class="variable">stp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BouncyCastleProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>();</span><br><span class="line">            Security.addProvider(provider);</span><br><span class="line">            <span class="type">KeyStore</span> <span class="variable">ks</span> <span class="operator">=</span> KeyStore.getInstance(<span class="string">&quot;PKCS12&quot;</span>, <span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(keyStorePath);</span><br><span class="line">            <span class="comment">// 私钥密码 为Pkcs生成证书是的私钥密码 123456</span></span><br><span class="line">            ks.load(fos, password.toCharArray());</span><br><span class="line">            <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> (String) ks.aliases().nextElement();</span><br><span class="line">            <span class="type">PrivateKey</span> <span class="variable">key</span> <span class="operator">=</span> (PrivateKey) ks.getKey(alias, password.toCharArray());</span><br><span class="line">            Certificate[] chain = ks.getCertificateChain(alias);</span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">PdfReader</span>(signPdfSrc);</span><br><span class="line">            signPDFData = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="comment">// 临时pdf文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(signPdfSrcFile.getParent(), System.currentTimeMillis() + <span class="string">&quot;.pdf&quot;</span>);</span><br><span class="line">            stp = PdfStamper.createSignature(reader, signPDFData, <span class="string">&#x27;\0&#x27;</span>, temp, <span class="literal">true</span>);</span><br><span class="line">            stp.setFullCompression();</span><br><span class="line">            <span class="type">PdfSignatureAppearance</span> <span class="variable">sap</span> <span class="operator">=</span> stp.getSignatureAppearance();</span><br><span class="line">            sap.setReason(<span class="string">&quot;数字签名，不可改变&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用png格式透明图片</span></span><br><span class="line">            <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> Image.getInstance(signImage);</span><br><span class="line">            sap.setImageScale(<span class="number">0</span>);</span><br><span class="line">            sap.setSignatureGraphic(image);</span><br><span class="line">            sap.setRenderingMode(PdfSignatureAppearance.RenderingMode.GRAPHIC);</span><br><span class="line">            <span class="comment">// 是对应x轴和y轴坐标</span></span><br><span class="line">            sap.setVisibleSignature(<span class="keyword">new</span> <span class="title class_">Rectangle</span>(x, y, x + <span class="number">185</span>, y + <span class="number">68</span>), <span class="number">1</span>,</span><br><span class="line">                    UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">            stp.getWriter().setCompressionLevel(<span class="number">5</span>);</span><br><span class="line">            <span class="type">ExternalDigest</span> <span class="variable">digest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BouncyCastleDigest</span>();</span><br><span class="line">            <span class="type">ExternalSignature</span> <span class="variable">signature</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrivateKeySignature</span>(key, DigestAlgorithms.SHA512, provider.getName());</span><br><span class="line">            MakeSignature.signDetached(sap, digest, signature, chain, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, MakeSignature.CryptoStandard.CADES);</span><br><span class="line">            stp.close();</span><br><span class="line">            reader.close();</span><br><span class="line">            <span class="keyword">return</span> signPDFData.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (signPDFData != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    signPDFData.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] fileData = sign(<span class="string">&quot;123456&quot;</span>, <span class="string">&quot;keystore.p12&quot;</span>, </span><br><span class="line">                <span class="string">&quot;待签名.pdf&quot;</span>,<span class="comment">//</span></span><br><span class="line">                <span class="string">&quot;公章1.png&quot;</span>, <span class="number">100</span>, <span class="number">290</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;已签名.pdf&quot;</span>));</span><br><span class="line">        f.write(fileData);</span><br><span class="line">        f.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里所需要的参数基本上前文都提过了，不再多说。</p><p>从表面上看，签名结束之后，PDF 文件上多了一个印章，如下：</p><p><img src="http://img.itboyhub.com/2024/08/202410082239245.png"></p><p>本质上，则是该 PDF 文件多了一个签名信息，通过 Adobe 的 PDF 软件可以查看，如下：</p><p><img src="http://img.itboyhub.com/2024/08/202410082241246.png"></p><p>之所以显示签名有效性未知，是因为我们使用的是自己生成的数字证书，如果从权威机构申请的数字证书，就不会出现这个提示。</p><p>好啦，是不是很 easy？</p><p>小伙伴们在公众号后台回复 <strong>20241023</strong>，可以获取到本文完整案例。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一-电子签章&quot;&gt;&lt;a href=&quot;#一-电子签章&quot; class=&quot;headerlink&quot; title=&quot;一 电子签章&quot;&gt;&lt;/a&gt;一 电子签章&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是电子签章&quot;&gt;&lt;a href=&quot;#1-1-什么是电子签章&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是电子签章&quot;&gt;&lt;/a&gt;1.1 什么是电子签章&lt;/h2&gt;&lt;p&gt;基于《中华人民共和国电子签名法》等相关法规和技术规范，具有法律效力的电子签章一定是需要使用 CA 数字证书进行对文件签名，并把 CA 数字证书存放在签名后文件中。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
    <category term="iText" scheme="http://www.javaboy.org/tags/iText/"/>
    
  </entry>
  
  <entry>
    <title>接了个外快，赚了点小钱</title>
    <link href="http://www.javaboy.org/2024/1022/life.html"/>
    <id>http://www.javaboy.org/2024/1022/life.html</id>
    <published>2024-10-22T00:51:42.000Z</published>
    <updated>2024-12-20T03:00:26.777Z</updated>
    
    <content type="html"><![CDATA[<p>如题，确实是小钱。</p><p>很多小伙伴可能知道，松哥有一个 title 就是全国本科毕业论文(设计)抽检评审专家库专家，这个 title 可是要干活的，这不，组织最近又来活了。</p><span id="more"></span><p>松哥这两天连续收到两条评审通知：</p><p><img src="http://img.itboyhub.com/2024/mp/20241021084550.jpg"></p><p>这个评审按官方的话说，是为了提升论文质量，推进学术诚信制度建设等等，这个抽检工作今年是第三次，算是一个比较新的事情。</p><p>既然是抽检评审，所以系统每次发来的论文来源地都是随机的，松哥去年评审的论文来自重庆和湖南某高校的，今年目前收到的两篇，一篇是贵州某高校的另一个是福建某高校的。</p><p>论文专业则不会随机，毕竟不同人擅长领域不同。一般系统会根据你的专业能力为你匹配适合你的论文，大部分情况这个这个匹配都是没问题的，但是有时候也会有一些偏差，比如你是做软件，但是有的论文偏硬件，这种情况下如果感觉自己无法胜任，也可以选择拒绝评审。</p><p>松哥比较幸运的是，系统发来评审的论文和我专业高度相关，甚至论文使用的都是 Spring Boot + Vue 技术栈，这专业也太对口了，必须认真看一看给出评审意见。</p><p>评审过程就是根据系统列出来的几个考核相，先从不同维度给论文打分，比如专业度、创新性、逻辑能力、学术规范等等，然后再给出综合评审意见和论文改进建议就行了，这样一篇论文就算评审完了。评审过程看着简单，其实一点也不容易，综合评审意见和改进建议都是要求 500-5000 字，所以论文必须要认真看，否则就很难给出恰当的意见和建议。</p><p>有小伙伴说这个评审有劳务费吗？那必须有！不过钱不多，都是按评审论文数量结算的，结算估计到明年六七月了，因为我去年这时候评审的论文，就是今年六七月的时候拿到劳务费的。</p><p>下面这张图是松哥去年参与论文评审，今年拿到的劳务费。</p><p><img src="http://img.itboyhub.com/2024/mp/20240728100946.png"></p><p>工作之后日复一日在公司搬砖未免感到无趣，参与一点工作之外的事情，无论钱多钱少，重要的是让枯燥的搬砖生活又多了些乐趣。</p><p>下图是本年度论文评审的聘书。</p><p><img src="http://img.itboyhub.com/2024/mp/20241021095259.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题，确实是小钱。&lt;/p&gt;
&lt;p&gt;很多小伙伴可能知道，松哥有一个 title 就是全国本科毕业论文(设计)抽检评审专家库专家，这个 title 可是要干活的，这不，组织最近又来活了。&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>八大架构图全解析：打造高效系统的视觉指南</title>
    <link href="http://www.javaboy.org/2024/1020/system-design.html"/>
    <id>http://www.javaboy.org/2024/1020/system-design.html</id>
    <published>2024-10-20T00:51:26.000Z</published>
    <updated>2024-12-20T02:57:35.253Z</updated>
    
    <content type="html"><![CDATA[<p>今天和小伙伴们分享几种常见的架构图。</p><span id="more"></span><p>在软件工程中，架构图通常用来展示软件系统的高层设计，包括软件组件、它们之间的交互以及它们与外部系统的连接。架构图有助于团队成员理解系统的整体设计和各个部分如何协同工作。</p><p>架构图可以有不同的类型，具体取决于它们所展示的视图和细节级别。</p><h1 id="一-业务架构图"><a href="#一-业务架构图" class="headerlink" title="一 业务架构图"></a>一 业务架构图</h1><p>业务架构图是一种图形化工具，用于描述组织的结构、业务流程、工作角色、信息系统以及如何支持组织的战略目标。它提供了组织内部不同业务组件及其相互关系的高层次视图。业务架构图有助于理解组织的业务模式、流程、功能和数据需求，以及它们是如何协同工作的。</p><p>业务架构图通常包括以下元素：</p><ol><li><strong>业务单元</strong>：组织内负责特定业务活动或流程的部门或团队。</li><li><strong>业务流程</strong>：组织中执行的一系列活动，用于创造、交付和支持产品或服务。</li><li><strong>业务功能</strong>：组织提供的核心能力或服务，通常与特定的业务流程相关联。</li><li><strong>角色和职责</strong>：组织内各个角色的职责和它们在业务流程中的作用。</li><li><strong>信息系统</strong>：支持业务流程的应用程序、数据库和技术基础设施。</li><li><strong>数据流</strong>：信息在组织内部流动的路径，包括输入、处理和输出。</li><li><strong>外部实体</strong>：与组织交互的外部组织或系统，如供应商、客户、合作伙伴和监管机构。</li><li><strong>价值链</strong>：组织创造和交付价值给客户的一系列活动。</li></ol><p>业务架构图的目的是提供一个全面的视角，帮助组织理解其业务运作的全局视图，识别改进机会，确保业务战略与技术战略一致，并支持业务流程的优化和重组。</p><p>下面是一个业务架构图示例：</p><p><img src="http://img.itboyhub.com/2024/mp/20241008200642.png"></p><h1 id="二-功能架构图"><a href="#二-功能架构图" class="headerlink" title="二 功能架构图"></a>二 功能架构图</h1><p>功能架构图是描述软件系统各个功能模块及其相互关系的架构图。它通过将复杂的软件系统划分为相对独立、可管理的模块，使得开发人员能够更好地理解和管理系统的复杂性。功能架构图的目的是提高软件系统的可维护性、可扩展性和可重用性，以确保软件系统能够满足不断变化的需求和日益增长的业务规模。</p><p>功能架构图通常由系统架构师或产品经理负责设计，他们基于对系统功能需求的理解和分析，将系统划分为不同的功能模块，并定义这些模块之间的交互和依赖关系。这个过程有助于开发者理解每个功能模块的作用和实现逻辑。</p><p>功能架构图的使用场景包括但不限于：</p><ol><li><strong>需求分析阶段</strong>：帮助团队成员理解系统的功能需求，确保功能之间的协调一致。</li><li><strong>系统设计阶段</strong>：指导系统的设计和实现，确保系统的功能划分合理。</li><li><strong>开发阶段</strong>：为开发人员提供明确的功能模块划分，便于开发和测试。</li><li><strong>维护阶段</strong>：帮助维护人员理解系统的结构，便于进行系统的升级和维护。</li></ol><p>在设计功能架构图时，设计人员需要考虑系统的业务需求、技术约束和未来可能的扩展，以确保架构图能够满足系统当前和未来的需求。</p><p><img src="http://img.itboyhub.com/2024/mp/20241008193509.png"></p><h1 id="三-产品架构图"><a href="#三-产品架构图" class="headerlink" title="三 产品架构图"></a>三 产品架构图</h1><p>产品架构图是一种由产品经理用来抽象表达一款产品的服务和商业模式的可视化工具。它将产品功能抽象为模块化、层次清晰的架构，并通过不同分层的交互关系、功能模块的组合、数据和信息的流转，来传递产品的业务流程、商业模式和设计思路。</p><p>产品架构图是设计复杂产品时不可或缺的文档之一。</p><p><strong>使用场景：</strong></p><ol><li><strong>产品规划和汇报</strong>：产品人员可以用业务架构图来展现业务全局状态。</li><li><strong>技术团队沟通</strong>：帮助技术团队理解产品方向和需求。</li><li><strong>培训新员工</strong>：通过架构图快速让新员工了解产品结构和业务流程。</li><li><strong>商务推广</strong>：商务人员向客户介绍产品时，使用产品架构图可以更直观地展示产品特性和优势。</li></ol><p>产品架构图通常由产品经理设计。他们基于对业务需求、市场分析、用户研究和技术可行性的理解，将这些要素转化为产品架构图，以指导产品的开发和迭代。</p><p><img src="http://img.itboyhub.com/2024/mp/20241008200538.png"></p><h1 id="四-应用架构图"><a href="#四-应用架构图" class="headerlink" title="四 应用架构图"></a>四 应用架构图</h1><p>应用架构图是一种用来描述系统中特定应用程序的结构和组织方式的视图。它涵盖了应用程序的模块、组件、数据流和交互方式。应用架构关注特定应用程序的设计和实现，旨在满足系统的功能需求，其核心是通过系统拆分来平衡业务和技术复杂性，确保系统的有序性和高效性。</p><p><strong>使用场景：</strong></p><ol><li><strong>项目开发和测试</strong>：在项目开发初期，开发和测试团队需要理解系统由哪些应用组成，以及这些应用如何协同工作。</li><li><strong>运维部署和发布</strong>：运维团队需要了解应用程序的部署要求和发布流程。</li><li><strong>子域架构设计</strong>：在复杂的系统中，应用架构图可以帮助团队理解和设计不同业务子域的应用程序如何交互。</li></ol><p>应用架构图通常由架构师和技术经理设计，他们需要深入理解业务需求和系统技术细节，以确保应用架构图既能反映业务架构，又能支持技术架构的实现。</p><p><img src="http://img.itboyhub.com/2024/mp/20241008201100.png"></p><h1 id="五-系统架构图"><a href="#五-系统架构图" class="headerlink" title="五 系统架构图"></a>五 系统架构图</h1><p>系统架构图是一种图形表示，用于描述软件或系统的不同组件及其之间的关系。它涵盖了从硬件、软件到数据流等多个方面。系统架构图的主要目的是提供一个清晰、直观的大局观，使得各方参与者能够理解系统的主要构成元素及其相互作用。</p><p><strong>使用场景：</strong></p><ol><li><strong>沟通工具</strong>：架构图作为一个共享视图，能帮助团队成员、管理层和其他利益相关者理解系统的核心组件和交互。</li><li><strong>规划与设计</strong>：在项目的早期阶段，架构图可以作为一个参考模板，指导实际的开发工作。</li><li><strong>问题定位</strong>：当系统出现问题时，架构图能快速地帮助人们定位问题所在。</li></ol><p>系统架构图通常由架构师和技术经理设计，他们需要深入理解业务需求和系统技术细节，以确保系统架构图既能反映业务架构，又能支持技术架构的实现。</p><p><img src="http://img.itboyhub.com/2024/mp/20241008200433.png"></p><h1 id="六-技术架构图"><a href="#六-技术架构图" class="headerlink" title="六 技术架构图"></a>六 技术架构图</h1><p>技术架构图是从技术层面描述系统如何构建的蓝图，它包括系统的分层模型，如持久层、数据层、逻辑层、应用层、表现层等，以及每一层使用的技术框架和中间件。技术架构图展示了系统的主要技术实现，包括结构、功能、流程和逻辑等方面。</p><p><strong>使用场景：</strong></p><ol><li><strong>项目规划阶段</strong>：帮助团队理解系统如何落地的具体实现方案。</li><li><strong>技术选型</strong>：指导技术决策，包括选择适合项目需求的技术、框架和工具。</li><li><strong>系统设计和开发</strong>：为开发人员提供系统设计的指导和参考。</li><li><strong>系统维护和扩展</strong>：帮助维护人员理解系统的技术细节，便于进行系统的升级和扩展。</li></ol><p>技术架构图通常由架构师和技术经理设计，他们需要深入理解业务需求、技术细节和团队的技术能力，以确保技术架构图既能反映业务需求，又能支持技术实现的高效性和可维护性。</p><p><img src="http://img.itboyhub.com/2024/mp/20241008195451.png"></p><h1 id="七-信息架构图"><a href="#七-信息架构图" class="headerlink" title="七 信息架构图"></a>七 信息架构图</h1><p>信息架构图是用于展示信息组织结构的图，它帮助用户理解信息的层次和关系，以便更有效地找到和管理信息。这种图通常用于网站、软件、数据库和其他信息系统中，以提供清晰的导航和信息检索路径。</p><p><strong>使用场景：</strong></p><ol><li><strong>网站设计</strong>：展示网站内容的组织方式，帮助用户和设计师理解网站结构。</li><li><strong>软件和数据库</strong>：组织和展示软件功能模块或数据库记录，提高可用性和可寻性。</li><li><strong>信息系统</strong>：规划和设计大型信息系统的导航结构和信息流。</li></ol><p>信息架构图通常由信息架构师和交互设计师共同设计，他们需要深入理解用户需求、业务目标和技术平台，以确保信息架构图能够有效地支持用户的信息检索和导航需求。</p><p>信息架构图的设计旨在满足用户需求和产品目标，通过合理的信息组织和表达，使用户更容易获取和理解信息。</p><p><img src="http://img.itboyhub.com/2024/mp/20241008195834.png"></p><h1 id="八-数据架构图"><a href="#八-数据架构图" class="headerlink" title="八 数据架构图"></a>八 数据架构图</h1><p>数据架构图是一种图形表示方法，用于展示数据在系统或组织中的结构、流动和关系。通过使用各种符号、图形和箭头，数据架构图可以清晰地呈现数据元素之间的互动和依赖关系，帮助人们更好地理解和管理数据。</p><p><strong>使用场景：</strong></p><ol><li><strong>企业数据管理</strong>：企业可以使用数据架构图来管理和维护其数据资产。</li><li><strong>网络安全和隐私保护</strong>：帮助组织识别和保护敏感数据。</li><li><strong>大数据分析</strong>：在大数据时代，数据架构图对于大数据分析至关重要。</li></ol><p>数据架构图通常由数据架构师和数据工程师共同设计，他们需要深入理解业务需求、数据流动和技术平台，以确保数据架构图能够有效地支持数据管理和分析的需求。</p><p><img src="http://img.itboyhub.com/2024/mp/20241008200234.png"></p><p>小伙伴们画过哪些图呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天和小伙伴们分享几种常见的架构图。&lt;/p&gt;</summary>
    
    
    
    <category term="Design" scheme="http://www.javaboy.org/categories/Design/"/>
    
    
    <category term="Design" scheme="http://www.javaboy.org/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>MySQL8 窗口函数是真的省事！</title>
    <link href="http://www.javaboy.org/2024/1019/mysql-window-function.html"/>
    <id>http://www.javaboy.org/2024/1019/mysql-window-function.html</id>
    <published>2024-10-19T00:51:08.000Z</published>
    <updated>2024-12-20T03:00:23.962Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>MySQL9 已经出来了，MySQL8 相信也慢慢走进各位小伙伴的工作中了。</p><span id="more"></span><p>MySQL8 还是有很多重量级变化的，一些底层优化大家在使用中有时候不易察觉，但是有一些用法，还是带给我们耳目一新的感觉，今天松哥和大家分享一下 MySQL8 里边的窗口函数。</p><h1 id="一-什么是窗口函数"><a href="#一-什么是窗口函数" class="headerlink" title="一 什么是窗口函数"></a>一 什么是窗口函数</h1><p>在 MySQL 8 中，窗口函数（Window Functions）是一类强大的分析函数，允许你在查询结果集上执行计算，而无需将数据分组到多个输出行中。窗口函数通常与 OVER() 子句一起使用，以指定数据窗口，即窗口函数将要在其上执行计算的行集。</p><p>简单来说，窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p><p>窗口函数的格式类似下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>窗口函数<span class="operator">&gt;</span> <span class="keyword">OVER</span> ([<span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>分组列<span class="operator">&gt;</span> [, <span class="operator">&lt;</span>分组列<span class="operator">&gt;</span>...]]</span><br><span class="line">                     [<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>排序列<span class="operator">&gt;</span> [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>] [, <span class="operator">&lt;</span>排序列<span class="operator">&gt;</span> [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]]...]</span><br><span class="line">                     [<span class="operator">&lt;</span><span class="keyword">rows</span> <span class="keyword">or</span> <span class="keyword">range</span> clause<span class="operator">&gt;</span>])</span><br></pre></td></tr></table></figure><ul><li><code>&lt;窗口函数&gt;</code> : 定义要在窗口中计算的聚合函数或其它分析函数，如 <code>COUNT</code>、<code>RANK</code>、<code>SUM</code> 等。</li><li><code>OVER</code> : 窗口函数的核心关键字。</li><li><code>PARTITION BY</code> : 定义要用来分组的一组列名。</li><li><code>ORDER BY</code> : 定义用来排序的一组列名。</li><li><code>&lt;rows or range clause&gt;</code> : 定义窗口的行集合。默认为 <code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>，表示窗口包括从窗口开始到当前行的所有行。</li></ul><p>接下来我们通过一个实际案例来体会下窗口函数。</p><h1 id="二-窗口函数实践"><a href="#二-窗口函数实践" class="headerlink" title="二 窗口函数实践"></a>二 窗口函数实践</h1><h2 id="2-1-统计成绩和排名"><a href="#2-1-统计成绩和排名" class="headerlink" title="2.1 统计成绩和排名"></a>2.1 统计成绩和排名</h2><p>假设我有如下一张表：</p><p><img src="http://img.itboyhub.com/2024/mp/20241011151520.png"></p><p>我现在想要计算学生的考试总成绩以及单科成绩排名，利用窗口函数就能快速搞定，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,subject,score,</span><br><span class="line"><span class="built_in">SUM</span>(score) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">by</span> name) <span class="keyword">AS</span> <span class="string">&#x27;总分&#x27;</span>,</span><br><span class="line"><span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">by</span> subject <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>) <span class="keyword">AS</span> <span class="string">&#x27;学科排名&#x27;</span></span><br><span class="line"><span class="keyword">from</span> student</span><br></pre></td></tr></table></figure><p>和窗口函数相关的就两列：</p><ul><li>sum 求总分，over 中按照 name 进行分组，相当于就是计算每个人的总分。</li><li>dense_rank 是排序，这个函数会考虑并列的情况，但是并列并不影响排序，因为是计算每个人单科排名，所以就按照学科分组之后按照 score 排序。</li></ul><p>最终执行结果如下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241011151633.png"></p><h2 id="2-2-销售统计"><a href="#2-2-销售统计" class="headerlink" title="2.2 销售统计"></a>2.2 销售统计</h2><p>假设我有如下一张表：</p><p><img src="http://img.itboyhub.com/2024/mp/20241011153042.png"></p><p>这是一个名为 sales 的表，其中包含 id（销售记录 ID）、product_id（产品 ID）、sale_date（销售日期）和 amount（销售额）等字段。</p><p>现在有如下几个需求，大家把这几个需求搞懂了，基本上窗口函数就会用了。</p><h4 id="计算累计销售额"><a href="#计算累计销售额" class="headerlink" title="计算累计销售额"></a>计算累计销售额</h4><p>需求：按产品 ID 分组，计算每个产品的累计销售额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    id, </span><br><span class="line">    product_id, </span><br><span class="line">    sale_date, </span><br><span class="line">    amount, </span><br><span class="line">    <span class="built_in">SUM</span>(amount) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> product_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date) <span class="keyword">AS</span> <span class="string">&#x27;累计销售额&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    sales;</span><br></pre></td></tr></table></figure><blockquote><p><code>SUM(amount) OVER (PARTITION BY product_id ORDER BY sale_date) AS &#39;累计销售额&#39;</code> 表示按 product_id 分组，按 sale_date 排序，计算每个产品的累计销售额。</p></blockquote><p>最终查询结果如下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241011153754.png"></p><h4 id="计算移动平均值"><a href="#计算移动平均值" class="headerlink" title="计算移动平均值"></a>计算移动平均值</h4><p>需求：按产品 ID 分组，计算每个产品的最近 3 笔销售记录的移动平均销售额。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    id, </span><br><span class="line">    product_id, </span><br><span class="line">    sale_date, </span><br><span class="line">    amount, </span><br><span class="line">    <span class="built_in">AVG</span>(amount) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> product_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span>) <span class="keyword">AS</span> <span class="string">&#x27;移动平均销售额&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    sales;</span><br></pre></td></tr></table></figure><blockquote><p><code>AVG(amount) OVER (PARTITION BY product_id ORDER BY sale_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS &#39;移动平均销售额&#39;</code> 表示按 <code>product_id</code> 分组，按 <code>sale_date</code> 排序，计算当前行及前两行的平均销售额。</p></blockquote><p>最终查询结果如下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241011154246.png"></p><h4 id="计算排名"><a href="#计算排名" class="headerlink" title="计算排名"></a>计算排名</h4><p>需求：按产品 ID 分组，计算每个销售记录在该产品中的排名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    id, </span><br><span class="line">    product_id, </span><br><span class="line">    sale_date, </span><br><span class="line">    amount, </span><br><span class="line">    <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> product_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> amount <span class="keyword">DESC</span>) <span class="keyword">AS</span> <span class="string">&#x27;销售金额排名&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    sales;</span><br></pre></td></tr></table></figure><blockquote><p><code>RANK() OVER (PARTITION BY product_id ORDER BY amount DESC) AS &#39;销售金额排名&#39;</code> 表示按 product_id 分组，按 amount 降序排序，计算每个销售记录在该产品中的排名。</p></blockquote><p>最终查询结果如下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241011154552.png"></p><h4 id="计算百分比排名"><a href="#计算百分比排名" class="headerlink" title="计算百分比排名"></a>计算百分比排名</h4><p>需求：按产品 ID 分组，计算每个销售记录在该产品中的百分比排名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    id, </span><br><span class="line">    product_id, </span><br><span class="line">    sale_date, </span><br><span class="line">    amount, </span><br><span class="line">    <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> product_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> amount <span class="keyword">DESC</span>) <span class="keyword">AS</span> <span class="string">&#x27;百分比排名&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    sales;</span><br></pre></td></tr></table></figure><blockquote><p><code>PERCENT_RANK() OVER (PARTITION BY product_id ORDER BY amount DESC) AS &#39;百分比排名&#39;</code> 表示按 product_id 分组，按 amount 降序排序，计算每个销售记录在该产品中的百分比排名。</p></blockquote><p>最终查询结果如下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241011154940.png"></p><h4 id="计算前后行的差值"><a href="#计算前后行的差值" class="headerlink" title="计算前后行的差值"></a>计算前后行的差值</h4><p>需求：按产品 ID 分组，计算每个销售记录与上一个销售记录之间的销售额差值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    id, </span><br><span class="line">    product_id, </span><br><span class="line">    sale_date, </span><br><span class="line">    amount, </span><br><span class="line">    <span class="built_in">LAG</span>(amount, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> product_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date) <span class="keyword">AS</span> <span class="string">&#x27;上个销售记录&#x27;</span>,</span><br><span class="line">    amount <span class="operator">-</span> <span class="built_in">LAG</span>(amount, <span class="number">1</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> product_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> sale_date) <span class="keyword">AS</span> <span class="string">&#x27;差额&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    sales;</span><br></pre></td></tr></table></figure><blockquote><p><code>LAG(amount, 1) OVER (PARTITION BY product_id ORDER BY sale_date)</code>：按 product_id 分组，按 sale_date 排序，获取当前行的上一行的 amount 值。<br><code>amount - LAG(amount, 1) OVER (PARTITION BY product_id ORDER BY sale_date)</code>：计算当前行与上一行的销售额差值。</p></blockquote><p>最终查询结果如下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241011155327.png"></p><h4 id="计算第一个和最后一个值"><a href="#计算第一个和最后一个值" class="headerlink" title="计算第一个和最后一个值"></a>计算第一个和最后一个值</h4><p>需求：按产品 ID 分组，计算每个产品的第一个和最后一个销售日期。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    product_id, </span><br><span class="line">    <span class="built_in">MIN</span>(sale_date) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> product_id) <span class="keyword">AS</span> <span class="string">&#x27;第一个销售日期&#x27;</span>, </span><br><span class="line">    <span class="built_in">MAX</span>(sale_date) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> product_id) <span class="keyword">AS</span> <span class="string">&#x27;最后一个销售日期&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    sales;</span><br></pre></td></tr></table></figure><blockquote><p><code>MIN(sale_date) OVER (PARTITION BY product_id)</code>：按product_id分组，计算每个产品的第一个销售日期。<br><code>MAX(sale_date) OVER (PARTITION BY product_id)</code>：按product_id分组，计算每个产品的最后一个销售日期。</p></blockquote><p>最终查询结果如下：</p><p><img src="http://img.itboyhub.com/2024/mp/20241011155521.png"></p><p>好啦，通过这几个小小案例，小伙伴们明白窗口函数了吧～</p><p>公众号后台回复 <strong>20241019</strong>，可以获取本文案例 SQL。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;MySQL9 已经出来了，MySQL8 相信也慢慢走进各位小伙伴的工作中了。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
</feed>
