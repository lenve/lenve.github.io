<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="http://www.javaboy.org/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2024-05-10T11:12:12.369Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024 Java 进阶训练营来啦！</title>
    <link href="http://www.javaboy.org/2024/0216/java-2024-training.html"/>
    <id>http://www.javaboy.org/2024/0216/java-2024-training.html</id>
    <published>2024-02-16T10:57:31.000Z</published>
    <updated>2024-05-10T11:12:12.369Z</updated>
    
    <content type="html"><![CDATA[<p>我为什么想做这样一个训练营。</p><p>有人说网上资料那么多，你凭啥觉得这事情就能做？</p><span id="more"></span><p>的确，现在网上各种学习资料不管是免费的付费的，汗牛充栋，太多了，学不完，根本学不完！但是！遇到问题我们怎么解决？学完了我怎么知道自己对这个知识点掌握到什么程度？找工作简历该怎么写才能体现自己的优势？我想做个模拟面试以便发现技术上的不足，谁来帮我做？</p><p>这些实实在在的问题，如果一个人慢慢摸索会浪费掉很多时间，如果报个培训班，动辄都是 2W+ 的学费。但是不管怎么说，这个时候我们确实需要有人从旁指点，自己冥思苦想一个礼拜的问题，如果有人指点，可能一两句话就点透了，学习效果就会事半功倍。</p><p>基于这样一个帮助大家更好的去学习的出发点，我决定做一个 Java 进阶训练营，帮助小伙伴们做一些技术上的提升，我希望能够从<strong>课程</strong>和<strong>服务</strong>两个方面来解决大家在学习过程中遇到的一些问题。</p><h3 id="课程"><a href="#课程" class="headerlink" title="课程"></a>课程</h3><p>首先就是课程，这个 Java 训练营松哥将<strong>全程直播</strong>，注意，这次<strong>都是直播</strong>，不是录播。选择直播的原因呢也是因为松哥在过年期间在视频号尝试了一下直播，感觉直播有一个特别大的好处就是可以和大家更好的互动，大家在学习的过程中如果遇到问题，都可以随时提出来，我当场给出解答，这样学习效率就要高很多，所有的知识点都能够现场学懂学会。</p><p>这个直播从头到尾都是松哥一个人在讲，这样能够最大程度确保大家在不同知识点之间无缝衔接，学习也更加体系化。</p><p>直播课我主要从以下五个方面跟大家直播：</p><ol><li>经典框架，包含 Spring、SpringMVC、MyBatis、MyBatis-Plus、Shiro、Spring Boot、Spring Security、任务调度解决方案等。</li><li>常用中间件技术，包含 RabbitMQ、RocketMQ、Redis、Nginx 等。</li><li>分布式与微服务架构，包含 Zookeeper、ElasticSearch、Spring Cloud Alibaba 全家桶、微服务脚手架搭建、分布式事务、分布式 ID、分布式锁等等。</li><li>MySQL 高级进阶，包含 MySQL 查询优化、索引优化、锁机制、MVCC 等等。</li><li>面试辅导，包含简历辅导、简历优化、模拟面试、面试录音分析等等。</li></ol><p>因为是进阶训练营，所以我在讲解的时候不仅仅是讲用法，也会涉及到源码分析，源码分析主要会结合面试热点进行，比如 Spring 源码分析，我会主要讲 Bean 的生命周期、循环依赖、AOP 等相关的源码，SpringMVC 我就主要讲核心组件的源码，帮大家把 SpringMVC 的工作原理捋顺、Redis 我会跟大家重点讲它的使用场景，做限流工具、做分布式锁等等。</p><p>这五个方面总共包含 180 节<strong>直播课</strong>，每一场直播都会有回放，回放可以永久观看，方便小伙伴们复习。</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>训练营包含的第二项内容就是保姆式的学习服务了。</p><p>如我前面所说，很多小伙伴在学习的时候：</p><ol><li>学习缺乏牛人指导。</li><li>学完了缺乏反馈，不知道自己对该技术到底掌握了一个什么样的水平。</li><li>遇到问题不知道该如何解决，自己慢慢琢磨可能一两天就过去了。</li><li>简历写的不够出彩，投出去没有面试邀约等等。</li></ol><p>所以这次我会使用一种跟之前录播课完全不同的方式，我将给大家提供随时随地的答疑服务，大家在学习过程中遇到任何问题我都会提供远程指导包括远程调试、远程 DEBUG；在你跳槽的时候我会和你一起优化简历，提供模拟面试服务，并且和你一起分析面试录音，查找知识漏洞等等。真正的提供一种陪伴式的保姆级学习服务。</p><p>而且这些事情都是松哥亲自来做，不像培训班用名师做噱头，你报名了就不是该老师上课。松哥这里从头到尾都是我来为大家服务，确保大家得到最好的技术指导。</p><p>这个保姆式的学习服务有效期则长达两年，也就是在两年之内，我会一直为你提供技术指导、远程调试、面试辅导等等各种服务。</p><p>下图是最近几次给小伙伴一对一做模拟面试和简历上技能点辅导。</p><p><img src="http://img.itboyhub.com/2022/08/%E6%8B%BC%E5%9B%BE-1.jpg"></p><p>这次的 Java 进阶训练营就是这样的<strong>直播课+保姆式学习服务</strong>为主。</p><hr><p>最后我再稍微介绍下自己，虽然很多小伙伴已经了解我了：</p><ol><li>技术畅销书作者，出版过两本技术图书，《Spring Boot+Vue全栈开发实战》（清华大学出版社，2019）和《深入浅出 Spring Security》（清华大学出版社，2021）。</li><li>华为云最具价值专家、华为云杰出 MVP、华为开发者社区之星。</li><li>腾讯技术创作营特邀评委、腾讯云金牌讲师。</li><li>GitHub 26k star 项目作者。</li><li>多年一线 coding 经验，有丰富的项目经验和授课经验。</li></ol><p><img src="http://img.itboyhub.com/2022/08/%E7%A8%BF%E5%AE%9A%E8%AE%BE%E8%AE%A1%E5%AF%BC%E5%87%BA-20240215-213838.jpg"></p><p>小伙伴们看到，这次我会付出很大的时间成本，特别是这个保姆式的学习服务，随时随地为大家解决问题。所以这次的训练营定价 ¥5999，现在第一期会有 ¥1000 的优惠，所以现在只要 ¥4999，相比于培训班动辄 2W 起的学费，这个真的算是白菜价了。有需要的小伙伴可以微信私我，备注<strong>训练营</strong>。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我为什么想做这样一个训练营。&lt;/p&gt;
&lt;p&gt;有人说网上资料那么多，你凭啥觉得这事情就能做？&lt;/p&gt;</summary>
    
    
    
    <category term="训练营" scheme="http://www.javaboy.org/categories/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
    <category term="训练营" scheme="http://www.javaboy.org/tags/%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>我不能总是生活在舒适圈里</title>
    <link href="http://www.javaboy.org/2024/0201/come-on.html"/>
    <id>http://www.javaboy.org/2024/0201/come-on.html</id>
    <published>2024-02-01T10:57:16.000Z</published>
    <updated>2024-05-10T11:12:19.099Z</updated>
    
    <content type="html"><![CDATA[<p>对一个性格内向的人来说，想要出镜拍摄视频那可真是个超级大的挑战，但是总是生活在舒适圈子里，人就很难进步，于是松哥最近做了一个小小的尝试，拍摄了两个出镜视频。</p><span id="more"></span><!--两个出镜视频--><p>看别人的短视频看了好多年了，自己尝试出镜拍还是头一回，感觉还挺有意思的，很新鲜也很好玩。感兴趣的小伙伴也可以关注下哦，下一步挑战直播和大伙聊技术、简历修改、面试技巧等。</p><p>前两天看一个大佬的直播给了我很大的启发，他说他迄今为止一共出版了 10 本书了，他每年都会让自己掌握一门新技能，今年他出版了新书，又在努力学习直播技能，我看完之后特别感慨，40 岁左右的老程序猿了，却还像刚毕业的时候一样，保持着对新事物的热情，而我，感觉已经躺平快三年了。</p><p>从 2021 到现在，感觉自己主要是在技术上做一些纵向积累，每年会做一些技术调研，也会写一些成体系的技术教程，做一些源码分析的教程（<a href="https://mp.weixin.qq.com/s/9-DQdfN8GQ2cvGwy-T3DwA">Spring源码应该怎么学？</a>），但是基本上都是围绕技术方向，纵向积累技术，对于技术之外的东西就很少涉及到了，甚至会有意回避，写技术教程已经轻车熟路了，对我来说这算是一种躺平式的生活了。</p><p>但是我们想要进步就是要不断的突破自己，走出舒适圈。所以前几天腾讯云技术创作特训营找到我做演讲嘉宾的时候，我犹豫了一下，让我纯讲技术我可以滔滔不绝，但是让我线下演讲还是有点不太擅长，线下演讲会有点紧张，但是我很快想到这是一个不错的锻炼机会，我应该去积极尝试一些自己不擅长的东西，不能总是躺在舒适圈里，所以就答应了，没想到演讲效果还不错，腾讯云上面有当时的直播回放，感兴趣的小伙伴也可以看看。松哥自己回来之后，用当时的照片也堆了一个视频出来：</p><p>总是让自己“难受”一点，因为“难受”了才是在进步。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对一个性格内向的人来说，想要出镜拍摄视频那可真是个超级大的挑战，但是总是生活在舒适圈子里，人就很难进步，于是松哥最近做了一个小小的尝试，拍摄了两个出镜视频。&lt;/p&gt;</summary>
    
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot3，启动时间缩短 10 倍！</title>
    <link href="http://www.javaboy.org/2024/0129/spring-boot-aot.html"/>
    <id>http://www.javaboy.org/2024/0129/spring-boot-aot.html</id>
    <published>2024-01-29T10:57:04.000Z</published>
    <updated>2024-05-10T11:12:54.072Z</updated>
    
    <content type="html"><![CDATA[<p>前面松哥写了一篇文章和大家聊了 Spring6 中引入的新玩意 AOT（见<a href="https://mp.weixin.qq.com/s/WHZ18RRcNLAToKPqZomc-w">Spring Boot3 新玩法，AOT 优化！</a>）。</p><span id="more"></span><p>文章发出来之后，有小伙伴问松哥有没有做性能比较，老实说，这个给落下了，所以今天再来一篇文章，和小伙伴们梳理比较小当我们利用 Native Image 的时候，Spring Boot 启动性能从参数上来说，到底提升了多少。</p><blockquote><p>先告诉大家结论：启动速度提升 10 倍以上。</p></blockquote><h2 id="1-Native-Image"><a href="#1-Native-Image" class="headerlink" title="1. Native Image"></a>1. Native Image</h2><h3 id="1-1-GraalVM"><a href="#1-1-GraalVM" class="headerlink" title="1.1 GraalVM"></a>1.1 GraalVM</h3><p>不知道小伙伴们有没有注意到，现在当我们新建一个 Spring Boot 工程的时候，再添加依赖的时候有一个 <code>GraalVM Native Support</code>，这个就是指提供了 GraalVM 的支持。</p><p><img src="http://img.itboyhub.com/2022/08/20240115093822.png"></p><p>那么什么是 GraalVM 呢？</p><p>GraalVM 是一种高性能的通用虚拟机，它为 Java 应用提供 AOT 编译和二进制打包能力，基于 GraalVM 打出的二进制包可以实现快速启动、具有超高性能、无需预热时间、同时需要非常少的资源消耗，所以你把 GraalVM 当作 JVM 来用，是没有问题的。</p><p>在运行上，GraalVM 同时支持 JIT 和 AOT 两种模式：</p><ul><li><p>JIT 是即时编译（Just-In-Time Compilation）的缩写。它是一种在程序运行时将代码动态编译成机器码的技术。与传统的静态编译（Ahead-of-Time Compilation）不同，静态编译是在程序执行之前将代码编译成机器码，而 JIT 编译器在程序运行时根据需要将代码片段编译成机器码，然后再运行。所以 JIT 的启动会比较慢，因为编译需要占用运行时资源。我们平时使用 Oracle 提供的 Hotspot JVM 就属于这种。</p></li><li><p>AOT 是预先编译（Ahead-of-Time Compilation）的缩写。它是一种在程序执行之前将代码静态编译成机器码的技术。与即时编译（JIT）不同，即时编译是在程序运行时动态地将代码编译成机器码。AOT 编译器在程序构建或安装阶段将代码转换为机器码，然后在运行时直接执行机器码，而无需再进行编译过程。这种静态编译的方式可以提高程序的启动速度和执行效率，但也会增加构建和安装的时间和复杂性。AOT 编译器通常用于静态语言的编译过程，如 C、C++ 等。</p></li></ul><p>如果我们在 Java 应用程序中使用了 AOT 技术，那么我们的 Java 项目就会被直接编译为机器码可以脱离 JVM 运行，运行效率也会得到很大的提升。</p><p>那么什么又是 Native Image 呢？</p><h3 id="1-2-Native-Image"><a href="#1-2-Native-Image" class="headerlink" title="1.2 Native Image"></a>1.2 Native Image</h3><p>Native Image 则是 GraalVM 提供的一个非常具有特色的打包技术，这种打包方式可以将应用程序打包为一个可脱离 JVM 在本地操作系统上独立运行的二进制包，这样就省去了 JVM 加载和字节码运行期预热的时间，提升了程序的运行效率。</p><p>Native Image 具备以下特点：</p><ul><li>即时启动：由于不需要 JVM 启动和类加载过程，Native Image 可以实现快速启动和即时执行。</li><li>减少内存占用：编译成本地代码后，应用程序通常会有更低的运行时内存占用，因为它们不需要 JVM 的额外内存开销。</li><li>静态分析：在构建 Native Image 时，GraalVM 使用静态分析来确定应用程序的哪些部分是必需的，并且只包含这些部分，这有助于减小最终可执行文件的大小。</li><li>即时性能：虽然 JVM 可以通过JIT（Just-In-Time）编译在运行时优化代码，但 Native Image 提供了即时的、预先优化的性能，这对于需要快速响应的应用程序特别有用。</li><li>跨平台兼容性：Native Image 可以为不同的操作系统构建特定的可执行文件，包括 Linux、macOS 和 Windows，即在 Mac 和 Linux 上自动生成系统可以执行的二进制文件，在 Windows 上则自动生成 exe 文件。</li><li>安全性：由于 Native Image 不依赖于 JVM，因此减少了 JVM 可能存在的安全漏洞的攻击面。</li><li>与 C 语言互操作：Native Image 可以与本地 C 语言库更容易地集成，因为它们都是在同一环境中运行的本地代码。</li></ul><p>根据前面的介绍大家也能看到，GraalVM 所做的事情就是在程序运行之前，该编译的就编译好，这样当程序跑起来的时候，运行效率就会高，而这一切，就是利用 AOT 来实现的。</p><p>但是！对于一些涉及到动态访问的东西，GraalVM 似乎就有点力不从心了，原因很简单，GraalVM 在编译构建期间，会以 main 函数为入口，对我们的代码进行静态分析，静态分析的时候，一些无法触达的代码会被移除，而一些动态调用行为，例如反射、动态代理、动态属性、序列化、类延迟加载等，这些都需要程序真正跑起来才知道结果，这些就无法在编译构建期间被识别出来。</p><p>而反射、动态代理、序列化等恰恰是我们 Java 日常开发中最最重要的东西，不可能我们为了 Native Image 舍弃这些东西！因此，从 Spring6（Spring Boot3）开始支持 AOT Processing！AOT Processing 用来完成自动化的 Metadata 采集，这个采集主要就是解决<strong>反射、动态代理、动态属性、条件注解动态计算</strong>等问题，在编译构建期间自动采集相关的元数据信息并生成配置文件，然后将 Metadata 提供给 AOT 编译器使用。</p><p>道理搞明白之后，接下来通过一个案例来感受下 Native Image 的威力吧！</p><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2><p>首先需要我们安装 GraalVM。</p><p>GraalVM 下载地址：</p><ul><li><a href="https://www.graalvm.org/downloads/">https://www.graalvm.org/downloads/</a></li></ul><p>下载下来之后就是一个压缩文件，解压，然后配置一下环境变量就可以了，这个默认大家都会，我就不多说了。</p><p>GraalVM 配置好之后，还需要安装 Native Image 工具，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gu install native-image</span><br></pre></td></tr></table></figure><p>装好之后，可以通过如下命令检查安装结果：</p><p>另一方面，Native Image 在进行打包的时候，会用到一些 C&#x2F;C++ 相关的工具，所以还需要在电脑上安装 Visual Studio 2022，这个我们安装社区版就行了（<a href="https://visualstudio.microsoft.com/zh-hans/downloads/%EF%BC%89%EF%BC%9A">https://visualstudio.microsoft.com/zh-hans/downloads/）：</a></p><p><img src="http://img.itboyhub.com/2022/08/20240115220053.png"></p><p>下载后双击安装就行了，安装的时候选择 C++ 桌面应用开发。</p><p><img src="http://img.itboyhub.com/2022/08/20240115221241.png"></p><p>如此之后，准备工作就算完成了。</p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h2><p>接下来我们创建一个 Spring Boot 工程，并且引入如下两个依赖：</p><p><img src="http://img.itboyhub.com/2022/08/20240115093822.png"></p><p>然后我们开发一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello aot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很简单的接口，接下来我们分别打包成传统的 jar 和 Native Image。</p><p>传统 jar 包就不用我多说了，大家执行 mvn package 即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure><p>打包完成之后，我们看下耗时时间：</p><p><img src="http://img.itboyhub.com/2022/08/20240116104654.png"></p><p>耗时不算很久，差不多 3.7s 左右，算是比较快了，最终打成的 jar 包大小是 18.9MB。</p><p>再来看打成原生包，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean native:compile -Pnative</span><br></pre></td></tr></table></figure><p>这个打包时间就比较久了，需要耐心等待一会：</p><p><img src="http://img.itboyhub.com/2022/08/20240116105433.png"></p><p>可以看到，总共耗时 4 分 54 秒。</p><p>Native Image 打包的时候，如果我们是在 Windows 上，会自动打包成 exe 文件，如果是 Mac&#x2F;Linux，则生成对应系统的可执行文件。</p><p><img src="http://img.itboyhub.com/2022/08/20240116105652.png"></p><p>这里生成的 aot_demo.exe 文件大小是 82MB。</p><p>两种不同的打包方式，所耗费的时间完全不在一个量级。</p><p>再来看启动时间。</p><p>先看 jar 包启动时间：</p><p><img src="http://img.itboyhub.com/2022/08/20240116105841.png"></p><p>耗时约 1.326s。</p><p>再来看 exe 文件的启动时间：</p><p><img src="http://img.itboyhub.com/2022/08/20240116105953.png"></p><p>好家伙，只有 0.079s。</p><p>1.326&#x2F;0.079&#x3D;16.78</p><p>启动效率提升了 16.78 倍！</p><p>我画个表格对比一下这两种打包方式：</p><table><thead><tr><th align="left"></th><th align="left">jar</th><th align="left">Native Image</th></tr></thead><tbody><tr><td align="left">包大小</td><td align="left">18.9MB</td><td align="left">82MB</td></tr><tr><td align="left">编译时间</td><td align="left">3.7s</td><td align="left">4分54s</td></tr><tr><td align="left">启动时间</td><td align="left">1.326s</td><td align="left">0.079s</td></tr></tbody></table><p>从这张表格中我们可以看到，Native Image 在打包的时候比较费时间，但是一旦打包成功，项目运行效率是非常高的。Native Image 很好的解决了 Java 冷启动耗时长、Java 应用需要预热等问题。</p><p>最后大家可以自行查看打包成 Native Image 时候的编译结果，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20240115150608.png"><br><img src="http://img.itboyhub.com/2022/08/20240115150647.png"><br><img src="http://img.itboyhub.com/2022/08/20240115151005.png"></p><p>看过松哥之前将的 <a href="https://mp.weixin.qq.com/s/9-DQdfN8GQ2cvGwy-T3DwA">Spring 源码分析</a>的小伙伴，这块的代码应该都很好明白，这就是直接把 BeanDefinition 给解析出来了，不仅注册了当前 Bean，也把当前 Bean 所需要的依赖给注入了，将来 Spring 执行的时候就不用再去解析 BeanDefinition 了。</p><p>同时我们可以看到在 META-INF 中生成了 reflect、resource 等配置文件。这些是我们添加的 native-maven-plugin 插件所分析出来的反射以及资源等信息，也是 Spring AOT Processing 这个环节处理的结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面松哥写了一篇文章和大家聊了 Spring6 中引入的新玩意 AOT（见&lt;a href=&quot;https://mp.weixin.qq.com/s/WHZ18RRcNLAToKPqZomc-w&quot;&gt;Spring Boot3 新玩法，AOT 优化！&lt;/a&gt;）。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>一个特殊的 BeanPostProcessor</title>
    <link href="http://www.javaboy.org/2024/0117/spring-bean-post-processor.html"/>
    <id>http://www.javaboy.org/2024/0117/spring-bean-post-processor.html</id>
    <published>2024-01-17T10:56:52.000Z</published>
    <updated>2024-05-10T11:12:50.852Z</updated>
    
    <content type="html"><![CDATA[<p>关于 BeanPostProcessor 松哥之前已经写过好几篇文章和大家聊过了，不过之前聊的都是常规的 BeanPostProcessor 玩法，还有一个特殊的 BeanPostProcessor，今天松哥来和大家梳理一下。</p><span id="more"></span><h2 id="1-BeanPostProcessor"><a href="#1-BeanPostProcessor" class="headerlink" title="1. BeanPostProcessor"></a>1. BeanPostProcessor</h2><p>先来回顾一下 BeanPostProcessor 接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是两个方法，理解这两个方法有一个大的前提，就是此时 Spring 容器已经通过 Java 反射创建出来 Bean 对象了，只不过在初始化这个 Bean 对象的时候，又提供了一些配置接口：</p><ul><li>postProcessBeforeInitialization：这个是在 Bean 初始化之前触发，此时我们已经有一个 Bean 对象了，但是 Bean 中一些生命周期方法如 InitializingBean 接口的 afterPropertiesSet 方法、自定义的 init-method 方法等都尚未执行，在这些方法执行之前触发 postProcessBeforeInitialization 方法。</li><li>postProcessAfterInitialization：类似于上面，在 afterPropertiesSet 和自定义的 init-method 之后触发该方法。</li></ul><p>BeanPostProcessor 的应用非常广泛，在整个 Spring 体系中，也扮演了非常重要的角色，如 @Bean 注解的解析、AOP 动态代理的生成等等许多我们日常使用的功能，都是通过 BeanPostProcessor 来实现的。</p><h2 id="2-MergedBeanDefinitionPostProcessor"><a href="#2-MergedBeanDefinitionPostProcessor" class="headerlink" title="2. MergedBeanDefinitionPostProcessor"></a>2. MergedBeanDefinitionPostProcessor</h2><p>MergedBeanDefinitionPostProcessor 算是整个 BeanPostProcessor 家族中比较另类的一个接口了，它虽然是 BeanPostProcessor，但是却可以处理 BeanDefinition。MergedBeanDefinitionPostProcessor 介入的时机就是 Bean 创建成功之后，Bean 中各个属性填充之前。</p><p>MergedBeanDefinitionPostProcessor 用于在 Bean 定义合并之后对合并后的 Bean 进行后置处理。它的作用是允许开发者在 Bean 定义合并完成后，对合并后的 Bean 进行自定义的修改或扩展操作。通常情况下，这个接口用于处理带有注解的 Bean 定义，例如 @Autowired 或 @Value 等注解的处理。通过实现 MergedBeanDefinitionPostProcessor 接口，开发者可以在 Bean 定义合并后，对这些注解进行解析和处理，以实现自定义的逻辑。</p><p>来看下 MergedBeanDefinitionPostProcessor 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MergedBeanDefinitionPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">resetBeanDefinition</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就两个方法，一个是处理合并后的 BeanDefinition，还有一个是重置 Bean 的。</p><blockquote><p>关于 MergedBeanDefinitionPostProcessor 接口有一个误区，有的小伙伴看到 merge 这个单词，又联想到松哥之前讲的给 bean 设置 parent（<a href="https://mp.weixin.qq.com/s/C8EnAU4A-6bvgm5jr3AK4w">Spring BeanDefinition 也分父子？</a>），会误以为合并 parent 属性是在这里完成的，其实这两个东西八杆子打不着。这里的单词也不是 merge，而是 merged，意思是处理合并之后的 BeanDefinition，而不是去进行 BeanDefinition 的合并。所以 MergedBeanDefinitionPostProcessor 并非进行 BeanDefinition 的合并处理，而是在 BeanDefinition 合并完成之后，Bean 创建完毕之后，Bean 属性填充之前，做一些事情。</p></blockquote><h2 id="3-场景分析"><a href="#3-场景分析" class="headerlink" title="3. 场景分析"></a>3. 场景分析</h2><p>MergedBeanDefinitionPostProcessor 最为经典的使用场景是对于 @Autowired 注解的处理。</p><p>要理解这一点，小伙伴们先来看一下松哥画的这个 Spring 中 Bean 的创建流程图：</p><p><img src="http://img.itboyhub.com/2022/08/spring_bean_life_cycle_202310091233.png"></p><p>上图基本上涵盖了整个 Bean 的创建流程了，在 Bean 的创建流程中，有一个步骤是 populateBean，这个就是去填充 Bean 的，本质上就是给 Bean 的属性填充值。</p><p>小伙伴要问了，即然 populateBean 方法是给 Bean 的属性填充值的，那么通过 @Autowired 注解给 Bean 的属性注入值按理说也应该是在这个方法中完成的吧？为什么又要去到 MergedBeanDefinitionPostProcessor 中去完成呢？</p><p>其实这两个并不冲突。</p><p>在具体执行过程中，MergedBeanDefinitionPostProcessor 首先负责去将类中的各种被注解标记的方法和属性都找出来，然后进行处理，将处理结果封装为一个 InjectionMetadata 对象，然后缓存起来。</p><p>然后在 populateBean 为 Bean 填充属性的时候，直接去处理这些封装好的 InjectionMetadata。</p><p>以上就是大致逻辑。</p><p>我们再从源码角度来验证一下。</p><p>首先 Bean 的创建是在 AbstractAutowireCapableBeanFactory#doCreateBean 方法中进行的，我们来看下这个方法中几个关键步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line">mbd.markAsPostProcessed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 applyMergedBeanDefinitionPostProcessors 方法中就会触发 MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition 方法的执行。以处理 @Autowired 注解为例，在 AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition 方法中先进行属性的整理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> &#123;</span><br><span class="line">findInjectionMetadata(beanName, beanType, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">findInjectionMetadata</span><span class="params">(String beanName, Class&lt;?&gt; beanType, RootBeanDefinition beanDefinition)</span> &#123;</span><br><span class="line"><span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, beanType, <span class="literal">null</span>);</span><br><span class="line">metadata.checkConfigMembers(beanDefinition);</span><br><span class="line"><span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> PropertyValues pvs)</span> &#123;</span><br><span class="line"><span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line"><span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line"><span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">metadata = <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line"><span class="keyword">if</span> (metadata != <span class="literal">null</span>) &#123;</span><br><span class="line">metadata.clear(pvs);</span><br><span class="line">&#125;</span><br><span class="line">metadata = buildAutowiringMetadata(clazz);</span><br><span class="line"><span class="built_in">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，上面方法在执行的过程中会把查找到封装好的 InjectionMetadata 对象先给缓存起来。</p><p>接下来在 populateBean 方法中进行 Bean 的属性填充的时候，调用的 AutowiredAnnotationBeanPostProcessor#postProcessProperties 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">metadata.inject(bean, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再去调用 findAutowiringMetadata 方法的时候，就可以直接从缓存中获取 InjectionMetadata 了。</p><blockquote><p>对于 InjectionMetadata#inject 方法以及 findAutowiringMetadata 方法，松哥在之前的文章中都已经详细介绍过了，这里就不再赘述了，不了解的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw">@Autowired 到底是怎么把变量注入进来的？</a>。</p></blockquote><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好了，这就是松哥和大家分享的 Spring 中一个特殊的 BeanPostProcessor -&gt; MergedBeanDefinitionPostProcessor，特殊之处在于它和普通的 BeanPostProcessor 的执行时机不同。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于 BeanPostProcessor 松哥之前已经写过好几篇文章和大家聊过了，不过之前聊的都是常规的 BeanPostProcessor 玩法，还有一个特殊的 BeanPostProcessor，今天松哥来和大家梳理一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot3 新玩法，AOT 优化！</title>
    <link href="http://www.javaboy.org/2024/0115/spring-boot-aot.html"/>
    <id>http://www.javaboy.org/2024/0115/spring-boot-aot.html</id>
    <published>2024-01-15T10:56:36.000Z</published>
    <updated>2024-05-10T11:12:57.328Z</updated>
    
    <content type="html"><![CDATA[<p>今天和小伙伴们来聊一聊 Spring6 中的一个新特性 AOT（Ahead of Time），这也是目前在学习 Spring6 源码视频的小伙伴的一个提问，其实还是挺有代表意义的，因此松哥整理一篇文章来和大家聊一聊这个话题。</p><span id="more"></span><h2 id="1-JIT-VS-AOT"><a href="#1-JIT-VS-AOT" class="headerlink" title="1. JIT VS AOT"></a>1. JIT VS AOT</h2><h3 id="1-1-JIT"><a href="#1-1-JIT" class="headerlink" title="1.1 JIT"></a>1.1 JIT</h3><p>JIT 是即时编译（Just-In-Time Compilation）的缩写。它是一种在程序运行时将代码动态编译成机器码的技术。与传统的静态编译（Ahead-of-Time Compilation）不同，静态编译是在程序执行之前将代码编译成机器码。</p><p>JIT 编译器在程序运行时根据需要将代码片段编译成机器码，以提高程序的执行效率。JIT 编译器通常用于解释型语言或动态语言的执行环境中，可以在运行时将解释的代码转换为机器码，从而提高程序的执行速度。</p><p>所以 JIT 启动比较慢，因为编译需要占用运行时的资源。</p><h3 id="1-2-AOT"><a href="#1-2-AOT" class="headerlink" title="1.2 AOT"></a>1.2 AOT</h3><p>AOT 是预先编译（Ahead-of-Time Compilation）的缩写。它是一种在程序执行之前将代码静态编译成机器码的技术。与即时编译（JIT）不同，即时编译是在程序运行时动态地将代码编译成机器码。AOT 编译器在程序构建或安装阶段将代码转换为机器码，然后在运行时直接执行机器码，而无需再进行编译过程。这种静态编译的方式可以提高程序的启动速度和执行效率，但也会增加构建和安装的时间和复杂性。AOT 编译器通常用于静态语言的编译过程，如 C、C++ 等。</p><p>在 Spring 中应用 AOT 需要关注以下注意事项：</p><ol><li>类路径是固定的，并且在构建的时候定义好。</li><li>程序中定义的 Bean 不能在运行的时候修改，这意味着：<ol><li>@Profile 注解标记的环境需要在构建的时候就确定。</li><li>条件注解 @Conditional 中的限制条件仅在构建时候考虑。</li></ol></li><li>通过 supplier 提供的 Bean 无法提前进行类型转换（这种要在 Bean 创建的时候根据 supplier 去提供 Bean，具体可参考 <a href="https://mp.weixin.qq.com/s/9-DQdfN8GQ2cvGwy-T3DwA">Spring 源码视频</a>）。</li><li>确保 Bean 的类型足够精确。</li></ol><h2 id="2-AOT-工作流程"><a href="#2-AOT-工作流程" class="headerlink" title="2. AOT 工作流程"></a>2. AOT 工作流程</h2><p>Spring Framework 6 引入了AOT（Ahead-Of-Time）编译的概念，这是一种提前编译 Spring 应用程序的技术，以优化运行时性能，减少启动时间，并为创建 GraalVM 原生镜像提供支持。</p><p>AOT 的工作原理是在应用程序打包过程中提前执行那些通常在运行时进行的操作。包括生成 Bean 定义、解析配置和处理依赖注入等。通过这种方式，Spring 应用程序可以在启动时跳过这些步骤，从而加快启动速度，并减少 JVM 在运行时的计算负担。</p><p>AOT 的使用通常涉及以下几个步骤：</p><ol><li>使用 ApplicationContextAotGenerator：这是 AOT 引擎的入口点，它负责处理 ApplicationContext 的配置。它会创建 Bean 定义，但不会实例化 Bean。</li><li>刷新 ApplicationContext：为了 AOT 处理，需要刷新 ApplicationContext，但这个刷新过程与传统的不同，因为它不会创建 Bean 实例。</li><li>调用 BeanFactoryInitializationAotProcessor 实现：这些处理器会对 GenerationContext 进行操作，例如，生成代码来恢复 BeanFactory 的状态。</li><li>更新 GenerationContext：完成上述步骤后，GenerationContext 会包含生成的代码、资源和类，这些都是应用程序运行所必需的。</li><li>生成 GraalVM 原生镜像配置：使用 RuntimeHints 实例生成 GraalVM 原生镜像配置文件。</li><li>获取 ApplicationContextInitializer 的类名：ApplicationContextAotGenerator#processAheadOfTime 会返回一个类名，这个类允许应用程序以 AOT 优化的方式启动。</li></ol><p>乍一看，AOT 不错呀，还等什么，赶紧用 AOT 来跑我的项目吧！</p><p>别急！首先大家看到了 AOT 的有点，但是，这些优点中也隐藏着一些问题：</p><ul><li>反射：反射允许代码在编译时动态调用方法和访问未知的字段。AOT 编译器无法确定动态调用的类和方法。</li><li>属性文件：属性文件的内容可以在运行时更改。由于作用时机的问题，AOT 编译器无法确定动态使用的属性文件。</li><li>代理：代理可将方法调用动态重定向到其他对象，所以它会使 AOT 编译器难以确定在运行时调用哪些类和方法。</li><li>序列化：序列化将对象的状态转换为字节流，反之亦然，这会使 AOT 编译器难以确定将在运行时调用哪些类和方法。</li></ul><p>不过对于这些问题其实也都有办法处理，这就是 AOT 预处理了，这个咱们后文说。</p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h2><p>接下来我们就来通过一个案例体验下 AOT 具体应用吧。</p><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><p>Java 虚拟机通常是 JIT 形式，如果我们想要体验 AOT，那么就需要一个既支持 JIT 又支持 AOT 的工具了，这就是 GraalVM。</p><p>GraalVM 是一种高性能的通用虚拟机，它为 Java 应用提供 AOT 编译和二进制打包能力，基于 GraalVM 打出的二进制包可以实现快速启动、具有超高性能、无需预热时间、同时需要非常少的资源消耗。</p><p>GraalVM 非常有特色的一个功能是提供了 Native Image 打包技术，这种打包方式可以将应用程序打包为一个可脱离 JVM 独立运行的二进制包，这样就省去了 JVM 加载和字节码运行期预热的时间，提升了程序的运行效率。</p><p>和我们常用的 HotSpot JVM 相比主要有如下区别：</p><ol><li>编译器技术：HotSpot JVM 使用传统的即时编译器（JIT）技术，将字节码实时编译为本地机器码。而 GraalVM 使用了一种新的即时编译器技术，称为 Graal 编译器。Graal 编译器采用了基于图形的优化方法，可以更好地优化代码并提高执行性能。</li><li>多语言支持：HotSpot JVM 主要为 Java 语言提供运行时环境，而 GraalVM 支持多种编程语言，包括 Java、JavaScript、Python、Ruby 等。这使得 GraalVM 成为一个更加通用和灵活的虚拟机。</li><li>内存占用：GraalVM 在内存占用方面相对较低，这是由于其编译器技术和优化策略的改进。相比之下，HotSpot JVM 在某些情况下可能会占用更多的内存。</li><li>生态系统集成：HotSpot JVM 是 Java 开发生态系统中广泛使用的虚拟机，有大量的工具和框架与其集成。GraalVM 也可以与现有的 Java 生态系统集成，但由于其多语言支持和特殊的编译器技术，可能需要一些额外的配置和适配。</li></ol><p>当然，更重要的是，GraalVM 既支持 JIT 又支持 AOT。</p><p>所以，我们需要首先下载并安装 GraalVM。</p><p>下载地址：<a href="https://www.graalvm.org/downloads/%EF%BC%8C%E5%A4%A7%E5%AE%B6%E4%B8%8B%E8%BD%BD%E5%92%8C%E8%87%AA%E5%B7%B1">https://www.graalvm.org/downloads/，大家下载和自己</a> JDK 版本对应的 GraalVM。</p><p>这个下载之后直接解压就可以了，解压之后，将 GraalVM 配置到环境变量中就可以了。</p><p>最后，还需要安装一下 native-image，当然大家可以顺便用这个安装检验一下自己的 GraalVM 是否配置正确：</p><p><img src="http://img.itboyhub.com/2022/08/20240115103530.png"></p><h3 id="3-2-代码实践"><a href="#3-2-代码实践" class="headerlink" title="3.2 代码实践"></a>3.2 代码实践</h3><p>接下来我们创建一个 Spring Boot 工程，来体验一下 AOT 提前编译。</p><p>首先在创建工程的时候我们多添加一个依赖 <code>GraalVM Native Support</code>，如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20240115093822.png"></p><p>这是一个用来支持 AOT 的插件。</p><p>代码创建好之后，我们随便开发一个 <code>/hello</code> 接口，然后就来给项目打包。</p><h4 id="3-2-1-传统打包"><a href="#3-2-1-传统打包" class="headerlink" title="3.2.1 传统打包"></a>3.2.1 传统打包</h4><p>直接点击 package 进行打包：</p><p><img src="http://img.itboyhub.com/2022/08/20240115110148.png"></p><p>打包结果：</p><p><img src="http://img.itboyhub.com/2022/08/20240115110207.png"></p><p>这个就是我们传统的打包方式，没啥好说的。大家注意一下这种传统打包方式打包的时间是 4.86s。</p><h4 id="3-2-2-native-image-打包"><a href="#3-2-2-native-image-打包" class="headerlink" title="3.2.2 native image 打包"></a>3.2.2 native image 打包</h4><p>接下来我们来看下 native image 打包。</p><p>执行如下命令进行 native image 打包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean native:compile -Pnative</span><br></pre></td></tr></table></figure><p>打包结果如下图：</p><p><img src="http://img.itboyhub.com/2022/08/20240115123140.png"></p><p>大家看这个构建时间超级长。</p><p>再来看 native image 构建的结果：</p><p><img src="http://img.itboyhub.com/2022/08/20240115123237.png"></p><p>大家看到，除了我们所熟悉的 <code>xxx.jar</code>，还有一个可执行文件。</p><blockquote><p>因为我这里是 Mac，所以打包出来的可执行文件没有后缀，如果在 Windows 上测试的话，打包出来的就是 <code>aot_demo.exe</code> 了。</p></blockquote><p>现在这两个都可以直接运行。</p><p>jar 包就不用说了，大家都比较熟悉了。<code>aot_demo</code> 这个文件则是一个可以脱离 JVM 直接运行的二进制文件，启动效率会高很多。</p><p>根据第二小节的介绍，我们知道在打成原生包的时候，Spring AOT 会先进行 AOT 预处理，这个处理过程会创建 Bean 的定义，但是不会实例化 Bean，我们可以分析一下编译的结果就知道了。</p><p>首先我的源代码，除了启动类有两个类，分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello aot&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在打 native-image 的时候，我们看下结果：</p><p><img src="http://img.itboyhub.com/2022/08/20240115150608.png"><br><img src="http://img.itboyhub.com/2022/08/20240115150647.png"><br><img src="http://img.itboyhub.com/2022/08/20240115151005.png"></p><p>看过松哥之前将的 Spring 源码分析的小伙伴，这块的代码应该都很好明白，这就是直接把 BeanDefinition 给解析出来了，不仅注册了当前 Bean，也把当前 Bean 所需要的依赖给注入了，将来 Spring 执行的时候就不用再去解析 BeanDefinition 了。</p><p>同时我们可以看到在 META-INF 中生成了 reflect、resource 等配置文件。这些是我们添加的 native-maven-plugin 插件所分析出来的反射以及资源信息，将自动将这些作为配置文件生成的。</p><p>这块其实能聊的还蛮多，而且作为一个新支持的特性，Spring 对其功能也在不断完善，松哥后面会继续跟大家捋一捋这块的内容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天和小伙伴们来聊一聊 Spring6 中的一个新特性 AOT（Ahead of Time），这也是目前在学习 Spring6 源码视频的小伙伴的一个提问，其实还是挺有代表意义的，因此松哥整理一篇文章来和大家聊一聊这个话题。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot3+Vue3 版微人事来啦！</title>
    <link href="http://www.javaboy.org/2024/0111/spring-boot3-vue3-vhr2.html"/>
    <id>http://www.javaboy.org/2024/0111/spring-boot3-vue3-vhr2.html</id>
    <published>2024-01-11T10:56:23.000Z</published>
    <updated>2024-05-10T11:12:08.680Z</updated>
    
    <content type="html"><![CDATA[<p>无论是 Spring Boot3 还是 Vue3，都推出来很长时间了，是时候去拥抱了。</p><span id="more"></span><p>Spring Boot 在从 2 升级到 3 的时候，有诸多变化，包括对 JDK 版本的硬性限制。但是升级的过程中也有诸多坑要踩，但是无论怎样，事情总是在向前发展，总是要拥抱变化。</p><p>我从去年到今年的项目基本上都是 Spring Boot3+Vue3，给我的感受是无论是 Spring Boot 还是 Vue，都在往更好用、更易用的方向去发展。现在使用 Spring Boot3+Vue3，以前一些奇奇怪怪的写法，对于初学者来说不容易理解的写法都在慢慢消失，事情在往好的方向去发展。</p><p>因此我一直想用 Spring Boot3+Vue3 搞一个项目给小伙伴们参考。去年的 TienChin 项目是 Spring Boot2+Vue3（<a href="https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ">TienChin 项目配套视频来啦</a>），在 TienChin 项目里其实我对 Vue2 和 Vue3 之间的差异已经做了大量的分析和讲解了。</p><p><img src="http://img.itboyhub.com/2022/08/20240111100833.png"></p><p>对 TienChin 项目感兴趣的小伙伴可以戳这里：<a href="https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ">TienChin 项目配套视频来啦</a>。</p><p>不过 Spring Boot3 一直没有机会跟小伙伴们展示一下具体的玩法，现在年前刚好有空，干脆把 vhr 这个脚手架用 Spring Boot3+Vue3 重构了一下，对于 Spring Boot3+Vue3 玩法感兴趣的小伙伴可以参考这个项目了，地址是：</p><ul><li><a href="https://github.com/lenve/vhr2.0">https://github.com/lenve/vhr2.0</a></li><li><a href="https://gitee.com/lenve/vhr2.0">https://gitee.com/lenve/vhr2.0</a></li></ul><p>为了让小伙伴们更好的理解 Spring Boot3+Vue3 一整套的玩法，这个脚手架的开发过程我也录制了视频教程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">├── 001.开篇.mp4</span><br><span class="line">├── 002.服务端工程搭建.mp4</span><br><span class="line">├── 003.服务端HelloWorld.mp4</span><br><span class="line">├── 004.引入MyBatisPlus.mp4</span><br><span class="line">├── 005.代码自动生成.mp4</span><br><span class="line">├── 006.对接登录用户表.mp4</span><br><span class="line">├── 007.前后端分离登录接口.mp4</span><br><span class="line">├── 008.登录接口支持JSON.mp4</span><br><span class="line">├── 009.新版登录数据存储方案.mp4</span><br><span class="line">├── 010.前端Vue3工程创建.mp4</span><br><span class="line">├── 011.Vue介绍.mp4</span><br><span class="line">├── 012.安装NodeJS.mp4</span><br><span class="line">├── 013.创建前端SPA应用.mp4</span><br><span class="line">├── 014.WebStorm打开并运行前端工程.mp4</span><br><span class="line">├── 015.Vue3项目目录.mp4</span><br><span class="line">├── 016.Vue3项目结构分析.mp4</span><br><span class="line">├── 017.引入ElementUI.mp4</span><br><span class="line">├── 018.开发前端登录页面.mp4</span><br><span class="line">├── 019.封装Axios.mp4</span><br><span class="line">├── 020.前端跨域问题分析.mp4</span><br><span class="line">├── 021.NodeJS请求转发.mp4</span><br><span class="line">├── 022.问题解决.mp4</span><br><span class="line">├── 023.服务端返回消息统一提示.mp4</span><br><span class="line">├── 024.前端跳转到项目首页.mp4</span><br><span class="line">├── 025.前端首页Header.mp4</span><br><span class="line">├── 026.服务端注销登录接口.mp4</span><br><span class="line">├── 027.前端注销登录.mp4</span><br><span class="line">├── 028.前端左侧菜单展示.mp4</span><br><span class="line">├── 029.前端左侧导航菜单点击事件.mp4</span><br><span class="line">├── 030.前端通过路由渲染左侧菜单数据.mp4</span><br><span class="line">├── 031.导航菜单的路由模式.mp4</span><br><span class="line">├── 032.服务端返回动态菜单数据.mp4</span><br><span class="line">├── 033.前端加载服务端菜单数据.mp4</span><br><span class="line">├── 034.准备前端页面.mp4</span><br><span class="line">├── 035.前端组件存储方案优化.mp4</span><br><span class="line">├── 036.动态加载服务端菜单.mp4</span><br><span class="line">├── 037.前端问题分析.mp4</span><br><span class="line">├── 038.前端路由导航守卫加载菜单.mp4</span><br><span class="line">├── 039.注销登录清空菜单数据.mp4</span><br><span class="line">├── 040.前端问题解决.mp4</span><br><span class="line">├── 041.前端自动跳转到登录页面.mp4</span><br><span class="line">├── 042.服务端会话失效前端自动重登.mp4</span><br><span class="line">├── 043.前端展示登录进度条.mp4</span><br><span class="line">├── 044.前端主页完善.mp4</span><br><span class="line">├── 045.服务端动态权限处理.mp4</span><br><span class="line">├── 046.服务端返回分页数据.mp4</span><br><span class="line">├── 047.前端选项卡.mp4</span><br><span class="line">├── 048.前端加载职位数据.mp4</span><br><span class="line">├── 049.前端分页展示.mp4</span><br><span class="line">├── 050.ElementUI国际化问题.mp4</span><br><span class="line">├── 051.服务端职位更新接口.mp4</span><br><span class="line">├── 052.修改职位状态.mp4</span><br><span class="line">├── 053.编辑职位.mp4</span><br><span class="line">├── 054.添加职位.mp4</span><br><span class="line">├── 055.删除职位.mp4</span><br><span class="line">└── 056.小结.mp4</span><br></pre></td></tr></table></figure><p>凡是在 2021 年 5 月份之后上车 vhr 视频的小伙伴，可以微信私我免费领取领取这套教程（不确定自己上车时间的小伙伴可以微信私我，我有记录）。</p><blockquote><p>为什么是 2021 年 5 月呢，因为录制时间的原因，vhr 视频我从 2021 年 5 月开始就没有主动宣传了，但是由于之前的文章的长尾流量，还是有不少小伙伴在 2021 年 5 月 之后上车，因此，这次的更新算是对这些小伙伴的一个补偿。</p></blockquote><p>2021 年 5 月份之前上车 vhr 的小伙伴，当时这套教程还是比较新的，因此如果大家想在之前旧版 vhr 的基础之上继续学习 Spring Boot3+Vue3 版本的用法，只需要 ¥30 即可上车。</p><p>感兴趣的小伙伴微信私我吧～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;无论是 Spring Boot3 还是 Vue3，都推出来很长时间了，是时候去拥抱了。&lt;/p&gt;</summary>
    
    
    
    <category term="SpringBoot" scheme="http://www.javaboy.org/categories/SpringBoot/"/>
    
    
    <category term="SpringBoot" scheme="http://www.javaboy.org/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>背八股文和 DEBUG 源码，差别在哪？</title>
    <link href="http://www.javaboy.org/2024/0110/spring-source-video.html"/>
    <id>http://www.javaboy.org/2024/0110/spring-source-video.html</id>
    <published>2024-01-10T10:56:10.000Z</published>
    <updated>2024-05-10T11:12:22.824Z</updated>
    
    <content type="html"><![CDATA[<p>很多小伙伴知道松哥最近在更 Spring 源码相关的文章和视频，视频现在已经全部录完了，公号后台回复 Spring 有视频详细介绍。</p><span id="more"></span><p>今天我想和大伙聊一些解决问题的思路，就像我在 Spring 视频中所讲，我不仅是想让小伙伴们理解 Spring 源码，看懂 Spring 源码，更是想让小伙伴们掌握 DEBUG 源码的思路和方法，相信各位在学习 Spring 源码视频的时候对此也会有所领悟。</p><p>这次刚好是有一个小伙伴在群里问了这样一个问题：</p><p><img src="http://img.itboyhub.com/2022/08/20240109204320.png"><br><img src="http://img.itboyhub.com/2022/08/20240109204437.png"></p><p>首先这个小伙伴提的这个问题很好懂：SpringMVC 工作流程是面试八股文中的经典，上面这一套流程看起来是前后端不分时候的工作流程（因为涉及到了页面渲染），现在都流行前后端分离架构，那么前后端分离之后，SpringMVC 工作流程还是这样吗？</p><p>如果你懂一点源码分析技巧，这个问题其实可以自己分析去解决，但是如果你只会背八股文，那这个问题就有点棘手了。</p><blockquote><p>可能有的小伙伴认为这个并无必要，工作中不会用到，面试直接背八股文就行。但是！！！我觉得这样的分析其实是很有必要的，我们工作不仅仅是要养家糊口，我们也需要获得成就感，很多小伙伴总是感觉自己在公司天天 CRUD，工作没有挑战，是一个不折不扣的 CV 战士，那么现在这样一个思考的机会摆在你面前，你冲不冲？如果通过自己分析源码解决了心中的疑惑，会不会自信心爆棚呢？所以，尝试自己去分析这个问题是有意义的。</p></blockquote><h2 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1. 知识储备"></a>1. 知识储备</h2><p>首先，想要自己 DEBUG 去解决问题，必须要有知识储备。不能啥都不懂，就掌握一点 IDEA 上的 DEBUG 技巧，上来就想解决问题，那无疑是天方夜谭。</p><p>对于上面这个问题，我们至少需要如下两个知识储备。</p><ol><li>HandlerAdapter</li></ol><p>首先我们需要明白 HandlerAdapter 的作用，是真真正正的了解，不是背诵八股文那种了解。HandlerAdapter 是一个接口，这个接口中最重要的方法就是 handle 方法。</p><p>为什么会有 HandlerAdapter 存在呢？这是因为我们在 SpringMVC 中定义接口的方式有很多种，大家日常开发用的最多的就是通过 <code>@Controller</code> 或者 <code>@RestController</code> 注解来标记接口，但是这并不是接口唯一的定义方式，我们也可以通过实现 Controller 接口、HttpRequestHandler 接口甚至实现 Servlet 接口来完成接口的定义。</p><p>这些不同的接口定义方式，自然就对应了不同的调用方式，所以需要一个适配器，对于框架来说，总是通过调用 HandlerAdapter#handle 方法来调用接口方法，而不同的接口定义方式则需要分别提供各自的 HandlerAdapter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到默认的 HandlerAdapter 有如下实现类，基本上每种实现类都对应了一个接口调用方式：</p><p><img src="http://img.itboyhub.com/2022/08/HandlerAdapter20240109.png"></p><p>HandlerAdapter#handle 方法的返回值是 ModelAndView，也就是按理说每个接口都应该返回一个 ModelAndView，但是有时候我们的接口并不是返回这个，最典型的就是如果我们通过实现 Servlet 接口来定义接口，Servlet 接口中的方法返回值是 void，显然就不是 ModelAndView，那么对于这种情况我们该怎么处理呢？我们不妨来看下 SimpleServletHandlerAdapter，这个适配器专门用来处理通过 Servlet 定义的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServletHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Servlet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">((Servlet) handler).service(request, response);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个源码可太简单了，直接把接口类强转为 Servlet 然后进行调用。至于 handle 方法的返回值，直接返回 null 算了。</p><p>这是我们需要的知识储备一，如果你懂得上面的内容，大概也就能猜出来，如果前后端分离中接口返回了 JSON，那么执行目标接口的 HandlerAdapter#handle 方法估计也是返回 null。</p><ol start="2"><li>HttpMessageConverter</li></ol><p>第二个知识储备就是需要明白在 SpringMVC 中 JSON 的生成、解析是谁来完成的。</p><p>SpringMVC 返回 JSON 参数特别方便，接口方法直接返回对象就可以了，系统会自动将之转为 JSON 字符串然后写回去；如果提交的参数是 JSON 字符串，我们也只需要在接口中添加 @RequestBody 注解，这样系统就会自动将 JSON 字符串转为 Java 对象了。</p><p>这一切的实现，离不开 HttpMessageConverter。我们先来看看 HttpMessageConverter 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpMessageConverter</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read an object of the given type from the given input message, and returns it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz the type of object to return. This type must have previously been passed to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #canRead canRead&#125; method of this interface, which must have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputMessage the HTTP input message to read from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the converted object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotReadableException in case of conversion errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">T <span class="title function_">read</span><span class="params">(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, HttpMessageNotReadableException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Write a given object to the given output message.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the object to write to the output message. The type of this object must have previously been</span></span><br><span class="line"><span class="comment"> * passed to the &#123;<span class="doctag">@link</span> #canWrite canWrite&#125; method of this interface, which must have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> contentType the content type to use when writing. May be &#123;<span class="doctag">@code</span> null&#125; to indicate that the</span></span><br><span class="line"><span class="comment"> * default content type of the converter must be used. If not &#123;<span class="doctag">@code</span> null&#125;, this media type must have</span></span><br><span class="line"><span class="comment"> * previously been passed to the &#123;<span class="doctag">@link</span> #canWrite canWrite&#125; method of this interface, which must have</span></span><br><span class="line"><span class="comment"> * returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outputMessage the message to write to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotWritableException in case of conversion errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(T t, <span class="meta">@Nullable</span> MediaType contentType, HttpOutputMessage outputMessage)</span></span><br><span class="line"><span class="keyword">throws</span> IOException, HttpMessageNotWritableException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口中最重要的就是 read 和 write 方法。其中 read 方法是将请求参数中的 JSON 字符串转为 Java 对象，write 方法是将请求响应中的 Java 对象转为 JSON 字符串。</p><p>每一个 JSON 处理工具都会提供自身的 HttpMessageConverter，以 Spring Boot 中的 jackson 为例，它的 HttpMessageConverter 是 MappingJackson2HttpMessageConverter。</p><p>好了，有了如上两点知识储备，接下来我们就可以结合 IDEA 中的 DEBUG 技能，快速梳理出问题的答案了。</p><h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h2><p>那么这个问题从哪里切入呢？</p><p>既然服务端要返回 JSON，就必然调用到 HttpMessageConverter#write 方法，那么我们就写一个返回 JSON 的接口，然后在 MappingJackson2HttpMessageConverter#write 方法上打断点，因为最终要生成 JSON 必然会经过该方法。然后结合 IDEA 中 DEBUG 的方法调用栈，就能大致分析出来。</p><p><img src="http://img.itboyhub.com/2022/08/20240110090726.png"></p><p>从这个方法调用栈我们可以看出来，确实是调用了 HandlerAdapter#handle 方法，从这个位置依次往上，我们就找到了触发 JSON 生成的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//省略。。。</span></span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺着这个方法的调用栈，我们发现 JSON 的生成是在 <code>invocableMethod.invokeAndHandle</code> 方法中被触发的，包括 JSON 的写出都是在这个方法中完成的，这块代码简单，我就不贴图了。</p><p>那问题来了，JSON 已经写回去了，现在 handle 方法需要返回 ModelAndView 该怎么办呢？这就是接下来 getModelAndView 方法的作用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> ModelAndView <span class="title function_">getModelAndView</span><span class="params">(ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">ModelFactory modelFactory, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line"><span class="keyword">if</span> (mavContainer.isRequestHandled()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有一句判断 <code>mavContainer.isRequestHandled()</code>，看方法名就知道表示检查请求是否已经被处理了，由于前面已经处理完 JSON 了，所以这个方法就返回 true，这就进而导致返回的 ModelAndView 是一个 null。</p><p>继续跟进方法调用栈的提示，看接下来的处理。</p><p><img src="http://img.itboyhub.com/2022/08/20240110092210.png"></p><p>在这个位置调用了 HandlerAdapter#handle 方法，该方法返回了 null，解下来该去找试图解析器进行视图渲染了，视图渲染则是在接下来的 processDispatchResult 方法上：</p><p><img src="http://img.itboyhub.com/2022/08/20240110092433.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//省略</span></span><br><span class="line"><span class="comment">// Did the handler return a view to render?</span></span><br><span class="line"><span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">render(mv, request, response);</span><br><span class="line"><span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，这里会判断这个 ModelAndView 是否为 null，不为 null 的话，会去调用 render 方法进行视图的渲染，这个时候就会去找到视图解析器，分析视图，渲染视图，这个松哥之前也都和大家聊过了。但我们这里由于 mv 是 null，所以这一步其实是跳过了，也就是没有去找试图解析器也没有去渲染视图了。</p><p>现在再回到本文一开始的问题，相信各位心中已经有答案了。</p><p>从这个问题的分析中大家也能看出来，单纯的背八股文真的不如自己去读一读源码理解一下，因为八股文只能解决面试问题，对于工作，对于自身技能的提升作用是有限的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多小伙伴知道松哥最近在更 Spring 源码相关的文章和视频，视频现在已经全部录完了，公号后台回复 Spring 有视频详细介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码这样学！</title>
    <link href="http://www.javaboy.org/2024/0102/spring-video.html"/>
    <id>http://www.javaboy.org/2024/0102/spring-video.html</id>
    <published>2024-01-02T10:55:58.000Z</published>
    <updated>2024-05-10T11:12:47.666Z</updated>
    
    <content type="html"><![CDATA[<p>经过差不多 5 个月的录制，Spring 源码视频教程终于杀青啦～</p><span id="more"></span><p>这套视频教程基于目前最新的 Spring6 录制，一共有 204 集约 40 个小时，从 Spring 基本用法讲起，一直讲到源码分析（文末有视频目录）。</p><p>Spring 算是我们 Java 开发领域中一个最最基本的框架了，像是开发领域的水电气一样，这个咱们做 Java 开发的小伙伴都懂，我也就不多说重要性了。</p><p>很多小伙伴调侃自己是 CV 战士，面向搜索引擎编程，其实我很理解这种状态，因为我刚毕业的时候在公司敲代码也是这种状态，遇到错误，网上搜一下，别人说怎么怎么弄，我就照着做，弄完一看，可以运行了，好了，这事就过了，至于为什么，不知道。后来当我慢慢自己去看一些源码的时候，掌握一些源码分析技巧的时候，再次遇到问题的时候，我尽量不去搜索，而是尝试自己分析，刚开始的时候这样解决问题虽然慢，但是解决问题之后充满了成就感，这种成就感会给我们信心，每次解决一个难点的时候，我就在想，这不得给我加薪。时间久了我会特别痴迷于这种成就感，搜索得来的答案，虽然问题解决了，但是感觉自己就像是一个木得感情的代码机器，通过自己思考解决的问题，则能让自己信心爆棚。</p><p>希望小伙伴们都能养成这样思考的习惯～</p><p>这次的 Spring 源码教程虽然杀青了，但这只是我想讲的讲完了，<strong>并不代表这个系列的结束</strong>！大家在学习的过程中，遇到任何不理解的地方都可以再次提出来，我会通过文章、视频或者直播的形式来继续讲解，继续补充完善这套教程，也欢迎各位小伙伴们关注我的视频号：</p><p>好啦，其他的就不多废话啦，最后再统一回答大家几个关于视频的问题。</p><p><strong>Q1：视频放在哪里，怎么播放？</strong></p><p>视频放在百度网盘上，下载后使用专用播放器授权播放，专用播放器一机一码一人一码。至于小伙伴们推荐的阿里网盘等，由于空间、分享文件类型等限制，并无法用在加密视频分发中。</p><p><strong>Q2：视频为什么不支持在线播放？</strong></p><p>在线播放的话，一般都是和平台合作，但是国内大家所熟知的平台如慕课网、csdn 学院等，平台抽成基本都是 4 成起，松哥之前还合作了一个平台拿 6 成（也就是假如 100 块钱的课，平台拿走 60）。这样的分成比例无形中会推高课程的价格，现在我自己分发，所以才能做到<strong>低价</strong>。同时为了防止视频泄露，松哥对视频做了加密处理，这样可以确保大家不会在其他地方看到一模一样的免费视频，加密后的视频只能使用专用播放器播放，因此不支持在线播放。</p><p><strong>Q3：视频可以试看吗？</strong></p><p>其实我最近在公号发的视频，大家都可以当作试看视频。</p><p><strong>Q4：可以砍价吗？</strong></p><p>不可以，这个价格已经很便宜了，没法砍了（悄悄告诉大家，从 vhr 到 tienchin，暂时没有人砍价成功过），另外就是松哥是没有客服运营这些的，你加的微信就是我，咱都是纯粹的技术人，老实说我并不懂砍价，但是我会用沉默代表拒绝。</p><p><strong>Q5：视频多久更新完毕？</strong></p><p>已经全部更新完毕。</p><p><strong>Q6：这套视频适合哪些人看？</strong></p><p>学习这套视频，有 Spring 基础更佳，没有也可以。对于有 Spring 基础的小伙伴来说，我会保证你学到一些之前从未了解到的 Spring 玩法，对于没有 Spring 基础的小伙伴来说，这套视频从 0 开始的，那一样也适合你。</p><p><strong>Q7：看视频有问题可以问吗？</strong></p><p>购买视频后我会统一拉一个微信群，视频有问题可以在群里交流。</p><p><strong>Q8：这套视频我能学到啥？</strong></p><p>从 Spring 基础用法到源码理解统统搞定。如果你还没接触过 Spring，这套视频从基础用法到源码分析，可以让大家一步到位掌握 Spring；如果已经有一些 Spring 使用经验了，那么这套视频可以帮你进一步提升，掌握 Spring 原理。不过需要提醒大家的是，这套视频不包括 SpringMVC 相关的内容。</p><hr><p><strong>好啦，5 折 199 抄底就在今天啦！</strong></p><p>P.s.：可能有小伙伴加了松哥多个微信，其实没有必要重复添加，任意一个都能找到我。当然，如果你还没有松哥微信，扫码加微信，<strong>备注 spring</strong>，发红包 199 上车吧（买过 vhr 或者 tienchin 的小伙伴可在此基础上再优惠 ¥30 哦）～</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p><p>以下是完整视频目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">├── <span class="number">01.</span>基础用法</span><br><span class="line">│   ├── <span class="number">01.</span>IoC基础</span><br><span class="line">│   │   ├── <span class="number">01.</span>Spring框架介绍-核心容器.mp4</span><br><span class="line">│   │   ├── <span class="number">02.</span>Spring框架介绍-数据访问和通信.mp4</span><br><span class="line">│   │   ├── <span class="number">03.</span>Spring框架介绍-Web模块.mp4</span><br><span class="line">│   │   ├── <span class="number">04.</span>Spring框架介绍-AOP和测试.mp4</span><br><span class="line">│   │   ├── <span class="number">05.</span>什么是IoC.mp4</span><br><span class="line">│   │   ├── <span class="number">06.</span>自定义一个简单的IoC.mp4</span><br><span class="line">│   │   ├── <span class="number">07.</span>向Spring容器注册Bean.mp4</span><br><span class="line">│   │   ├── <span class="number">08.</span>从Spring容器获取Bean.mp4</span><br><span class="line">│   │   ├── <span class="number">09.</span>id属性和name属性.mp4</span><br><span class="line">│   │   ├── <span class="number">10.</span>基本属性注入.mp4</span><br><span class="line">│   │   ├── <span class="number">11.</span>复杂属性注入.mp4</span><br><span class="line">│   │   ├── <span class="number">12.</span>构造器注入.mp4</span><br><span class="line">│   │   ├── <span class="number">13.</span>p名称空间注入.mp4</span><br><span class="line">│   │   ├── <span class="number">14.</span>属性自动注入.mp4</span><br><span class="line">│   │   ├── <span class="number">15.</span>配置文件加载.mp4</span><br><span class="line">│   │   ├── <span class="number">16.</span>Java代码配置IoC.mp4</span><br><span class="line">│   │   ├── <span class="number">17.</span>BeanName自动生成原理.mp4</span><br><span class="line">│   │   ├── <span class="number">18.</span>id和name属性处理原理.mp4</span><br><span class="line">│   │   ├── <span class="number">19.</span>Bean 的作用域.mp4</span><br><span class="line">│   │   ├── <span class="number">20.</span>singleton 和 prototype 的区别.mp4</span><br><span class="line">│   │   ├── <span class="number">21.</span>条件注解详解.mp4</span><br><span class="line">│   │   ├── <span class="number">22.</span>多环境切换.mp4</span><br><span class="line">│   │   ├── <span class="number">23.</span>Profile原理分析.mp4</span><br><span class="line">│   │   ├── <span class="number">24.</span>自定义Profile.mp4</span><br><span class="line">│   │   ├── <span class="number">25.</span>Bean的依赖关系.mp4</span><br><span class="line">│   │   ├── <span class="number">26.</span>FactoryBean用法.mp4</span><br><span class="line">│   │   ├── <span class="number">27.</span>抽取Bean的公共属性.mp4</span><br><span class="line">│   │   ├── <span class="number">28.</span>父子容器问题.mp4</span><br><span class="line">│   │   ├── <span class="number">29.</span><span class="meta">@Configuration</span>注解的作用.mp4</span><br><span class="line">│   │   ├── <span class="number">30.</span>Bean自动扫描.mp4</span><br><span class="line">│   │   └── <span class="number">31.</span>属性值注入.mp4</span><br><span class="line">│   ├── <span class="number">02.</span>AOP基础</span><br><span class="line">│   │   ├── <span class="number">01.</span>静态代理.mp4</span><br><span class="line">│   │   ├── <span class="number">02.</span>编译时增强和运行时增强.mp4</span><br><span class="line">│   │   ├── <span class="number">03.</span>编译时增强.mp4</span><br><span class="line">│   │   ├── <span class="number">04.</span>运行时增强-JDK.mp4</span><br><span class="line">│   │   ├── <span class="number">05.</span>运行时增强-CGLIB.mp4</span><br><span class="line">│   │   ├── <span class="number">06.</span>什么是Spring AOP.mp4</span><br><span class="line">│   │   ├── <span class="number">07.</span>SpringAOP和AspectJAOP.mp4</span><br><span class="line">│   │   ├── <span class="number">08.</span>Spring AOP核心概念.mp4</span><br><span class="line">│   │   ├── <span class="number">09.</span>Spring AOP入门用法.mp4</span><br><span class="line">│   │   ├── <span class="number">10.</span>五种通知.mp4</span><br><span class="line">│   │   ├── <span class="number">11.</span>Java代码配置AOP.mp4</span><br><span class="line">│   │   ├── <span class="number">12.</span>SpringAOP底层代理.mp4</span><br><span class="line">│   │   └── <span class="number">13.</span>通过注解定义AOP拦截规则.mp4</span><br><span class="line">│   ├── <span class="number">03.</span>JdbcTemplate</span><br><span class="line">│   │   ├── <span class="number">01.</span>JdbcTemplate基本操作.mp4</span><br><span class="line">│   │   ├── <span class="number">02.</span>增删改查.mp4</span><br><span class="line">│   │   └── <span class="number">03.</span>通过变量名传递参数.mp4</span><br><span class="line">│   └── <span class="number">04.</span>事务</span><br><span class="line">│       ├── <span class="number">01.</span>事务简介.mp4</span><br><span class="line">│       ├── <span class="number">02.</span>编程式事务.mp4</span><br><span class="line">│       ├── <span class="number">03.</span>XML配置声明式事务.mp4</span><br><span class="line">│       ├── <span class="number">04.</span>Java配置声明式事务.mp4</span><br><span class="line">│       ├── <span class="number">05.</span>Java+XML配置声明式事务.mp4</span><br><span class="line">│       ├── <span class="number">06.</span>自定义事务注解.mp4</span><br><span class="line">│       ├── <span class="number">07.</span>事务属性-隔离级别.mp4</span><br><span class="line">│       ├── <span class="number">08.</span>事务属性-传播性.mp4</span><br><span class="line">│       ├── <span class="number">09.</span>事务属性-传播性<span class="number">2.</span>mp4</span><br><span class="line">│       ├── <span class="number">10.</span>事务属性-回滚规则.mp4</span><br><span class="line">│       ├── <span class="number">11.</span>事务属性-只读事务.mp4</span><br><span class="line">│       ├── <span class="number">12.</span>事务属性-超时时间.mp4</span><br><span class="line">│       └── <span class="number">13.</span>事务失效的场景.mp4</span><br><span class="line">└── <span class="number">02.</span>进阶用法</span><br><span class="line">    ├── <span class="number">001.</span>通过name属性定义别名.mp4</span><br><span class="line">    ├── <span class="number">002.</span>通过alias标签定义别名.mp4</span><br><span class="line">    ├── <span class="number">003.</span>别名处理接口AliasRegistry.mp4</span><br><span class="line">    ├── <span class="number">004.</span>aliasMap变量.mp4</span><br><span class="line">    ├── <span class="number">005.</span>allowAliasOverriding.mp4</span><br><span class="line">    ├── <span class="number">006.</span>hasAlias.mp4</span><br><span class="line">    ├── <span class="number">007.</span>removeAlias和isAlias.mp4</span><br><span class="line">    ├── <span class="number">008.</span>getAliases.mp4</span><br><span class="line">    ├── <span class="number">009.</span>checkForAliasCircle.mp4</span><br><span class="line">    ├── <span class="number">010.</span>canonicalName.mp4</span><br><span class="line">    ├── <span class="number">011.</span>registerAlias.mp4</span><br><span class="line">    ├── <span class="number">012.</span>resolveAliases.mp4</span><br><span class="line">    ├── <span class="number">013.</span>name属性解析原理.mp4</span><br><span class="line">    ├── <span class="number">014.</span>alias标签解析.mp4</span><br><span class="line">    ├── <span class="number">015.</span>DefaultListableBeanFactory.mp4</span><br><span class="line">    ├── <span class="number">016.</span>StaticListableBeanFactory.mp4</span><br><span class="line">    ├── <span class="number">017.</span>SimpleJndiBeanFactory.mp4</span><br><span class="line">    ├── <span class="number">018.</span>ApplicationContext.mp4</span><br><span class="line">    ├── <span class="number">019.</span>FactoryBean&amp;SmartFactoryBean.mp4</span><br><span class="line">    ├── <span class="number">020.</span>FactoryBean处理思路.mp4</span><br><span class="line">    ├── <span class="number">021.</span>Bean提前加载流程分析.mp4</span><br><span class="line">    ├── <span class="number">022.</span>isFactoryBean方法分析.mp4</span><br><span class="line">    ├── <span class="number">023.</span>getBean中&amp;的处理逻辑.mp4</span><br><span class="line">    ├── <span class="number">024.</span>BeanDefinition简介.mp4</span><br><span class="line">    ├── <span class="number">025.</span>RootBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">026.</span>ChildBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">027.</span>GenericBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">028.</span>AnnotatedGenericBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">029.</span>ScannedGenericBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">030.</span>ConfigurationClassBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">031.</span>CreateFromClassBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">032.</span>ClassDerivedBeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">033.</span>加载XML配置的两种方式.mp4</span><br><span class="line">    ├── <span class="number">034.</span>BeanDefinitionReader.mp4</span><br><span class="line">    ├── <span class="number">035.</span>PropertiesBeanDefinitionReader.mp4</span><br><span class="line">    ├── <span class="number">036.</span>XmlBeanDefinitionReader.mp4</span><br><span class="line">    ├── <span class="number">037.</span>配置类解析为BeanDefinition.mp4</span><br><span class="line">    ├── <span class="number">038.</span><span class="meta">@Scope</span>注解高级用法.mp4</span><br><span class="line">    ├── <span class="number">039.</span>编程式AOP.mp4</span><br><span class="line">    ├── <span class="number">040.</span>编程式AOP之target方法分析.mp4</span><br><span class="line">    ├── <span class="number">041.</span>TargetSource体系结构.mp4</span><br><span class="line">    ├── <span class="number">042.</span>SimpleBeanTargetSource.mp4</span><br><span class="line">    ├── <span class="number">043.</span>自定义TargetSource.mp4</span><br><span class="line">    ├── <span class="number">044.</span>引介增强.mp4</span><br><span class="line">    ├── <span class="number">045.</span>启动类上的<span class="meta">@Scope</span>注解代理原理.mp4</span><br><span class="line">    ├── <span class="number">046.</span>常规类上的<span class="meta">@Scope</span>注解.mp4</span><br><span class="line">    ├── <span class="number">047.</span>Java配置中的<span class="meta">@Scope</span>代理.mp4</span><br><span class="line">    ├── <span class="number">048.</span>导入配置类上的<span class="meta">@Scope</span>注解.mp4</span><br><span class="line">    ├── <span class="number">049.</span><span class="meta">@Configuration</span>注解存在的意义是什么.mp4</span><br><span class="line">    ├── <span class="number">050.</span><span class="meta">@Configuration</span>-Vs-<span class="meta">@Component</span>.mp4</span><br><span class="line">    ├── <span class="number">051.</span><span class="meta">@Configuration</span>原理分析.mp4</span><br><span class="line">    ├── <span class="number">052.</span><span class="meta">@Configuration</span>的两种模式Full和Lite.mp4</span><br><span class="line">    ├── <span class="number">053.</span>详细演示Full和Lite模式.mp4</span><br><span class="line">    ├── <span class="number">054.</span>Full模式和Lite模式特点总结.mp4</span><br><span class="line">    ├── <span class="number">055.</span><span class="meta">@Configuration</span>注解解析源码分析.mp4</span><br><span class="line">    ├── <span class="number">056.</span><span class="meta">@Configuration</span>注解解析源码分析-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">057.</span>条件注解高级用法.mp4</span><br><span class="line">    ├── <span class="number">058.</span>条件注解高级用法补充.mp4</span><br><span class="line">    ├── <span class="number">059.</span>条件注解原理分析.mp4</span><br><span class="line">    ├── <span class="number">060.</span>beanName自动生成场景.mp4</span><br><span class="line">    ├── <span class="number">061.</span>beanName生成器分析.mp4</span><br><span class="line">    ├── <span class="number">062.</span>AnnotationBeanNameGenerator.mp4</span><br><span class="line">    ├── <span class="number">063.</span>BeanFactoryPostProcessor和BeanPostProcessor.mp4</span><br><span class="line">    ├── <span class="number">064.</span>BeanFactoryPostProcessor案例.mp4</span><br><span class="line">    ├── <span class="number">065.</span>BeanFactoryPostProcessor典型应用场景.mp4</span><br><span class="line">    ├── <span class="number">066.</span>Properties加载原理分析.mp4</span><br><span class="line">    ├── <span class="number">067.</span>BeanDefinitionRegistryPostProcessor.mp4</span><br><span class="line">    ├── <span class="number">068.</span>BeanFactoryPostProcessor作用时机分析.mp4</span><br><span class="line">    ├── <span class="number">069.</span>BeanPostProcessor接口分析.mp4</span><br><span class="line">    ├── <span class="number">070.</span>BeanPostProcessor实践.mp4</span><br><span class="line">    ├── <span class="number">071.</span>BeanPostProcessor实现AOP.mp4</span><br><span class="line">    ├── <span class="number">072.</span>MergedBeanDefinitionPostProcessor.mp4</span><br><span class="line">    ├── <span class="number">073.</span>BeanPostProcessor原理分析.mp4</span><br><span class="line">    ├── <span class="number">074.</span>合并BeanDefinition原理分析.mp4</span><br><span class="line">    ├── <span class="number">075.</span>合并BeanDefinition源码分析.mp4</span><br><span class="line">    ├── <span class="number">076.</span>父子容器原理分析.mp4</span><br><span class="line">    ├── <span class="number">077.</span>事件基本用法.mp4</span><br><span class="line">    ├── <span class="number">078.</span>事件是阻塞还是非阻塞.mp4</span><br><span class="line">    ├── <span class="number">079.</span>手动注册事件监听器.mp4</span><br><span class="line">    ├── <span class="number">080.</span>事件三大组件.mp4</span><br><span class="line">    ├── <span class="number">081.</span>Java类定义的事件监听器.mp4</span><br><span class="line">    ├── <span class="number">082.</span>Java类定义的事件监听器-补充.mp4</span><br><span class="line">    ├── <span class="number">083.</span>通过Java注解定义的事件监听器.mp4</span><br><span class="line">    ├── <span class="number">084.</span>ApplicationEventPublisher.mp4</span><br><span class="line">    ├── <span class="number">085.</span>ApplicationEventMulticaster.mp4</span><br><span class="line">    ├── <span class="number">086.</span>Spring事件补充.mp4</span><br><span class="line">    ├── <span class="number">087.</span>Java国际化.mp4</span><br><span class="line">    ├── <span class="number">088.</span>Spring国际化.mp4</span><br><span class="line">    ├── <span class="number">089.</span>MessageSource层级关系.mp4</span><br><span class="line">    ├── <span class="number">090.</span>getMessage方法原理分析.mp4</span><br><span class="line">    ├── <span class="number">091.</span>解析无参的key.mp4</span><br><span class="line">    ├── <span class="number">092.</span>解析有参key.mp4</span><br><span class="line">    ├── <span class="number">093.</span>Lifecycle基本用法.mp4</span><br><span class="line">    ├── <span class="number">094.</span>SmartLifecycle基本用法.mp4</span><br><span class="line">    ├── <span class="number">095.</span>Lifecycle中start方法执行原理.mp4</span><br><span class="line">    ├── <span class="number">096.</span>Lifecycle中stop方法执行原理.mp4</span><br><span class="line">    ├── <span class="number">097.</span>编程式AOP.mp4</span><br><span class="line">    ├── <span class="number">098.</span>动态代理对象创建流程.mp4</span><br><span class="line">    ├── <span class="number">099.</span>JDK和CGLIB动态代理分析.mp4</span><br><span class="line">    ├── <span class="number">100.</span>Advisor详解.mp4</span><br><span class="line">    ├── <span class="number">101.</span>自定义切面对象Advisor.mp4</span><br><span class="line">    ├── <span class="number">102.</span>重载方法拦截规则.mp4</span><br><span class="line">    ├── <span class="number">103.</span>拦截所有方法.mp4</span><br><span class="line">    ├── <span class="number">104.</span>默认配置的Pointcut对象.mp4</span><br><span class="line">    ├── <span class="number">105.</span>Pointcut经典写法.mp4</span><br><span class="line">    ├── <span class="number">106.</span>Pointcut分类.mp4</span><br><span class="line">    ├── <span class="number">107.</span>StaticMethodMatcherPointcut.mp4</span><br><span class="line">    ├── <span class="number">108.</span>StaticMethodMatcherPointcut-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">109.</span>DynamicMethodMatcherPointcut.mp4</span><br><span class="line">    ├── <span class="number">110.</span>AnnotationMatchingPointcut.mp4</span><br><span class="line">    ├── <span class="number">111.</span>ControlFlowPointcut.mp4</span><br><span class="line">    ├── <span class="number">112.</span>ComposablePointcut.mp4</span><br><span class="line">    ├── <span class="number">113.</span>提前返回Bean的机会.mp4</span><br><span class="line">    ├── <span class="number">114.</span>提前AOP的机会.mp4</span><br><span class="line">    ├── <span class="number">115.</span>理解两个关键变量.mp4</span><br><span class="line">    ├── <span class="number">116.</span>特殊的beanName.mp4</span><br><span class="line">    ├── <span class="number">117.</span>自定义TargetSourceCreator.mp4</span><br><span class="line">    ├── <span class="number">118.</span>提前AOP实践.mp4</span><br><span class="line">    ├── <span class="number">119.</span>AOP创建的契机.mp4</span><br><span class="line">    ├── <span class="number">120.</span>AOP对象生成整体思路.mp4</span><br><span class="line">    ├── <span class="number">121.</span>AOP对象创建详细流程分析.mp4</span><br><span class="line">    ├── <span class="number">122.</span>Bean的获取思路.mp4</span><br><span class="line">    ├── <span class="number">123.</span>getBean方法整体思路分析.mp4</span><br><span class="line">    ├── <span class="number">124.</span>从三级缓存中加载Bean.mp4</span><br><span class="line">    ├── <span class="number">125.</span>从parent中加载Bean.mp4</span><br><span class="line">    ├── <span class="number">126.</span>检查<span class="meta">@DependOn</span>注解.mp4</span><br><span class="line">    ├── <span class="number">127.</span>不同Scope获取Bean实例.mp4</span><br><span class="line">    ├── <span class="number">128.</span>生成的Bean类型检查.mp4</span><br><span class="line">    ├── <span class="number">129.</span>createBean方法分析.mp4</span><br><span class="line">    ├── <span class="number">130.</span>doCreateBean-<span class="number">1.</span>mp4</span><br><span class="line">    ├── <span class="number">131.</span>循环依赖-二级缓存.mp4</span><br><span class="line">    ├── <span class="number">132.</span>循环依赖-三级缓存.mp4</span><br><span class="line">    ├── <span class="number">133.</span>循环依赖-三级缓存-补充.mp4</span><br><span class="line">    ├── <span class="number">134.</span>循环依赖源码分析-<span class="number">1.</span>mp4</span><br><span class="line">    ├── <span class="number">135.</span>循环依赖源码分析-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">136.</span>循环依赖源码分析-<span class="number">3.</span>mp4</span><br><span class="line">    ├── <span class="number">137.</span>Bean的生命周期-<span class="number">1.</span>mp4</span><br><span class="line">    ├── <span class="number">138.</span>Bean的生命周期-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">139.</span>Bean的生命周期-<span class="number">3.</span>mp4</span><br><span class="line">    ├── <span class="number">140.</span>Bean的实例化-<span class="number">1.</span>mp4</span><br><span class="line">    ├── <span class="number">141.</span>Bean的实例化-<span class="number">2.</span>mp4</span><br><span class="line">    ├── <span class="number">142.</span>Bean的属性注入.mp4</span><br><span class="line">    ├── <span class="number">143.</span>getBean方法.mp4</span><br><span class="line">    └── <span class="number">144.</span>小结.mp4</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;经过差不多 5 个月的录制，Spring 源码视频教程终于杀青啦～&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>我的2023，如履薄冰，你说我能保住这份工吗</title>
    <link href="http://www.javaboy.org/2023/1231/life-2023.html"/>
    <id>http://www.javaboy.org/2023/1231/life-2023.html</id>
    <published>2023-12-31T10:55:47.000Z</published>
    <updated>2024-05-10T11:12:25.945Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷 B 站发现李连杰的投名状电影片段配合上 void 这首曲子，还挺魔性的，看了挺上头。</p><span id="more"></span><p><img src="http://img.itboyhub.com/2022/08/20231231094717.png"></p><p>也有不少据此二创的视频，都还挺好玩的。</p><p>感觉用这个来总结 2023 似乎也挺恰当。</p><p>我想从技术成长和生活两方面来聊一聊我的 2023。</p><p><strong>技术成长</strong></p><p>今年写的系列教程很少，总结起来就三个：</p><ol><li>年初完结了 gRPC 系列。</li><li>4、5 月份的时候完善了之前的 MySQL 系列。</li><li>7 月份开始连载 Spring 源码系列。</li></ol><p>相比于往年，今年的技术更新确实慢了很多，有大环境的原因，也有我自身的问题，今年确实是有一些懈怠了。</p><p>三月份的时候完结了 TienChin 项目，对应的视频教程也杀青了，这个松哥在之前的文章中已经多次介绍过了：<a href="https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ">TienChin 项目配套视频来啦</a>。</p><p>8 月份开始下定决心做 Spring 源码课程，现在也即将杀青。有小伙伴可能会说做课程也算是技术成长吗？对我来说当然算啦！以 Spring 源码为例，虽然我之前已经把 Spring 框架用的比较溜了，里边的原理大致上也都清楚，但是一直没有时间去深究源码细节，这次也是借着给小伙伴们分享 Spring 源码的机会，我自己也把 Spring 源码从头到尾认认真真过了一遍，很多以前没有注意到的细节问题，这次都 GET 到了。</p><p>结合我在 2021 年出的 SpringMVC 源码教程，我觉得将来有空可以写一本讲 Spring 源码的图书（希望不要打脸哈哈。</p><p>2023 很多人都焦虑，包括松哥也是一样，工作机会不再像以前那么多，薪水也没有以前那么夸张了，这场景让我想到我在 2017 年底公司倒闭那会，那时候真是感觉 IT 行业到头了，不过好在当时我自己静下心来认真去搞技术，还做了 vhr 这个开源项目，在人心浮动的时候没有忘记提升自己，当时间来到 2018 的时候，这些技术积累又带给了我新的机会。所以今年也是一样，虽然大环境不好，但是提升自己总是没有错的，我今年这几个课程也算是对自我的一个技术积累，也希望小伙伴们在这样一个浮躁的环境中能够静下心来去提升自己，这样机会来了才能抓得住。</p><p>上周应思否(sf.gg)的邀请我去北京参加了鸿蒙的实训营，活动中认识了不少优秀的小伙伴，能看出来很多人都很焦虑，但是没有人躺平，都在积极去寻找机会，探索一起合作的可能，有的人甚至在不同的赛道上正在赚着大钱，真的让我感触很多。有时候我们在自己的小圈子里呆的太久了就会处于一个信息茧房中，身边几个好朋友失业了&#x2F;降薪了就会以为天塌了，但是当我们走出自己的舒适圈子，去外面开开眼界，真的会有不一样的观感，会有一种：“<strong>沉舟侧畔千帆过，病树前头万木春</strong>”的感觉。这也是我为什么老爱去参加一些技术沙龙，就是我怕自己的圈子呆久了思想在无形中被束缚了。</p><p><img src="http://img.itboyhub.com/2022/08/20231231111341.png"></p><p>没有特别多机会的时候，就默默的积累吧，千万别浪费光阴，我是这样总结我的 2023 技术之路的。</p><p><strong>生活</strong></p><p>生活上值得开心的事情就是在 2023 年底我搬新家了。毕业八年，广深两地漂了八年，终于告别了租房，有了自己的小窝。毕业八年，没有父母的资助，事实上父母也没钱资助，和媳妇两个人靠敲代码在一线城市安家了。小伙伴们之前看到的松哥的很多文章和视频，都是我坐小板凳趴在床沿上写的&#x2F;录的，趴的时间久了腰疼，所以总是要录一会起来走走转转，不过这些都将是过去式了。</p><blockquote><p>我想起来以前读书时候看到的童话大王郑渊洁说自己早期铅笔稿纸躺在床上写童话文思泉涌，后来换了大书桌有了舒服的椅子，反而写不动了。</p></blockquote><p>希望自己改善条件后能够继续和小伙伴们分享更多的技术知识。</p><p><strong>2024 flag</strong></p><p>2024 我要立一个 Flag：通过直播和小伙伴们分享技术。</p><p>之前松哥给到大家的技术视频基本上都是录播，而且都是录屏，没有人出镜，一个重要的原因就是条件不允许，这个前面已经和大家说了。</p><p>其实我很早就想通过直播来和小伙伴们分享技术了，直播有一个好处就是有问题可以现场互动解决，听不明白的地方现场提出来现场解答，这种效果要好很多，但是直播需要较为安静的环境，而我从来没有这样的条件（录播我可以早上六点起床趁着安静去录，但是直播这个时间显然不行），因此这件事一直就被搁置了。</p><p>2024 这些制约条件都没有了，我会尽快开始直播，第一次直播话题可能是 Spring 源码相关的技术点，小伙伴们敬请期待哦～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近刷 B 站发现李连杰的投名状电影片段配合上 void 这首曲子，还挺魔性的，看了挺上头。&lt;/p&gt;</summary>
    
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊Spring Bean 的生命周期</title>
    <link href="http://www.javaboy.org/2023/1227/spring-bean-lifecycle.html"/>
    <id>http://www.javaboy.org/2023/1227/spring-bean-lifecycle.html</id>
    <published>2023-12-27T10:55:25.000Z</published>
    <updated>2024-05-10T11:35:30.545Z</updated>
    
    <content type="html"><![CDATA[<p>讲一讲 Spring Bean 的生命周期算是面试时候一道非常经典的问题了！</p><span id="more"></span><p>如果没有研究过 Spring 源码，单纯去背面试题，这个问题也是可以回答出来的，但是单纯的背缺乏理解，而且面试一紧张，就容易背岔了。但是如果你从头到尾看了松哥的 Spring 源码分析，那么这个问题就不需要背了，就根据自己对 Spring 源码的理解讲出来就行了。</p><p>在前面的文章中，松哥和大家分析了 Spring 中 Bean 的创建是在 createBean 方法中完成的，在该方法中，真正干活的实际上是 doCreateBean 方法，具体位置在 AbstractAutowireCapableBeanFactory#doCreateBean，小伙伴们在面试时候常被问到的 Spring Bean 的生命周期，实际上就是问 doCreateBean 方法的执行逻辑。</p><p>doCreateBean 方法整体上来说，干了四件事：</p><ol><li>Bean 的实例化。</li><li>Bean 属性填充。</li><li>Bean 初始化。</li><li>Bean 销毁方法注册。</li></ol><blockquote><p>这里大家注意区分实例化和初始化两个方法，实例化是指通过反射创建出来 Bean 实例的过程，而初始化则是调用一些回调函数进行 bean 的一些预处理。</p></blockquote><h2 id="1-实例化"><a href="#1-实例化" class="headerlink" title="1. 实例化"></a>1. 实例化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的最终目的是为了获取到一个 bean 实例。获取之前先去检查如果有该 bean 尚未完成的 factoryBean 实例就先移除掉。</p><p>createBeanInstance 方法就是大家闭着眼睛也能猜出来的通过反射创建 bean 实例过程，最后我们拿到的 bean 实例就是这个 bean。</p><p>实例化完成之后，还有两个小细节。</p><p>一个是预留了后置处理器修改 BeanDefinition 的接口，在这里可以对 BeanDefinition 进行修改，这块通常用来处理通过注解注入值的情况，这个松哥在之前的文章中也有详细介绍过，小伙伴们参见：<a href="">一个特殊的 BeanPostProcessor</a>。</p><p>另外一个则是对于循环依赖的处理。</p><p>松哥之前的文章中已经和小伙伴们详细分析了循环依赖的解决思路，参见：<a href="https://mp.weixin.qq.com/s/ig22T20Ie3jmTLhuPVPmdA">如何通过三级缓存解决 Spring 循环依赖</a>。</p><p>这里要做的工作就是根据当前 Bean 的情况，将 Bean 存入到三级缓存中（二级缓存中不存）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块代码的具体含义在之前的文章中松哥都和大家分析过了，这里就不再啰嗦了，感兴趣的小伙伴戳这里：<a href="https://mp.weixin.qq.com/s/YIokfCvLKLhcsEpO734Qtg">透过源码，捋清楚循环依赖到底是如何解决的！</a>。</p><h2 id="2-属性填充"><a href="#2-属性填充" class="headerlink" title="2. 属性填充"></a>2. 属性填充</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure><p>这一句就是属性填充的环节了。属性填充就是一个 Bean 中我们通过各种注解如 @Autowired 等注入的对象，@Value 注入的字符串，这些统一都在 populateBean 中进行处理。具体的代码细节松哥在之前的文章中也和大家讲过了：<a href="https://mp.weixin.qq.com/s/Ecs4MTjFpCa6Rz75buTSNw">@Autowired 到底是怎么把变量注入进来的？</a>。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br></pre></td></tr></table></figure><p>初始化主要是干这样四件事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">(mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>invokeAwareMethods：如果当前 bean 实现了 Aware 接口，那么 Aware 接口相关的方法就在 invokeAwareMethods 方法中被触发。</li><li>applyBeanPostProcessorsBeforeInitialization：这个是执行 BeanPostProcessor#postProcessBeforeInitialization 方法。</li><li>invokeInitMethods：这个里边是干两件事，如果我们的 Bean 实现了 InitializingBean 接口，那么该接口中的 afterPropertiesSet 方法就在这里被触发；另一方面就是如果我们通过配置文件 Bean 的初始化方法（XML 文件中的 init-method 属性），那么也会在这里被触发。</li><li>applyBeanPostProcessorsAfterInitialization：这个是执行 BeanPostProcessor#postProcessAfterInitialization 方法。</li></ol><blockquote><p>这里需要注意的一点是，通过在 XML 文件中配置的 init-method 属性，这个是在第 3 步被触发执行的；但是如果是通过 @PostConstruct 注解标记的 Bean 的初始化方法，则是通过 BeanPostProcessor 来处理的，具体是在 InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization 方法中处理的。这两种看起来作用类似的 Bean 初始化方法，底层处理逻辑并不相同。</p></blockquote><p>初始化完成之后，还有一个关于循环依赖的处理和判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要是防止 Spring 容器中创建出来的当前 Bean 和被其他 Bean 所依赖的 Bean 不是同一个。例如有 A 和 B 两个类，Spring 根据既有配置，给 A 生成了代理类，但是 B 引用的并不是 A 的代理对象，而是 A 的原始对象，此时就会有问题。所以这里主要是去判断，确保容器中和被使用的 A 是同一个。</p><p>检查的思路就是先去二级缓存中查找，二级缓存中如果存在，说明这个 Bean 因为循环依赖的原因已经被引用过了（被引用过的 Bean 会存入到二级缓存中），此时去判断 exposedObject 和 bean 是否为同一个 Bean，正常情况下，这两个当然是同一个 Bean，因为 exposedObject 和 bean 指向同一个内存地址。什么情况下，这两个 Bean 会不同呢？如果在 Bean 的后置处理器中，我们使用新的 Bean 替换了旧的 Bean，就会导致最终拿到的 exposedObject 和 bean 两个变量指向的地址不再相同。如果不相同，就要检查当前 Bean 是否有被容器中的其他 Bean 所依赖了，如果有，并且使用了当前 Bean 的 Bean 还正在创建中，那么就赶紧删除掉重新创建，如果使用了当前 Bean 的 Bean 已经创建完成了，那就没办法了，只能抛出异常了。</p><h2 id="4-销毁"><a href="#4-销毁" class="headerlink" title="4. 销毁"></a>4. 销毁</h2><p>销毁并不是说要立马把 Bean 给销毁掉，这 Bean 刚创建出来还没使用呢，怎么就给销毁了呢？</p><p>这里的销毁是说把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br></pre></td></tr></table></figure><p>Bean 的销毁方法我们可以通过注解或者是 XML 文件进行配置。使用注解的话就是 @PreDestroy 注解，被该注解标记的方法可以在 Bean 销毁之前执行，我们可以在该方法中释放资源；也可以使用 XML 文件进行配置 <code>destroy-method=&quot;&quot;</code>，通过该属性指定 Bean 销毁时候需要执行的方法。另外，当前 Bean 也可以通过实现 DisposableBean 接口，并重写该接口中的 destroy 方法，那么容器销毁的时候，这个方法会被自动调用以释放资源。</p><p>除了这三种常见的方法之外，还有一个办法就是如果当前 Bean 实现了 AutoCloseable 接口，那么当前类中如果存在名为 close 的方法或者名为 shutdown 的方法，那么对应的方法就会被自动调用。</p><p>好啦，大致的流程就是这样了，小伙伴们不妨据此画一个流程图看看。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;讲一讲 Spring Bean 的生命周期算是面试时候一道非常经典的问题了！&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring事件机制详解</title>
    <link href="http://www.javaboy.org/2023/1211/spring-events.html"/>
    <id>http://www.javaboy.org/2023/1211/spring-events.html</id>
    <published>2023-12-11T10:55:10.000Z</published>
    <updated>2024-05-10T11:12:40.902Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来聊一聊 Spring 中的事件机制，从用法到源码分析，我们挨个过一遍。</p><span id="more"></span><h2 id="1-Spring-事件机制"><a href="#1-Spring-事件机制" class="headerlink" title="1. Spring 事件机制"></a>1. Spring 事件机制</h2><p>有的小伙伴可能会觉得 Spring 中的事件机制很神奇，一个地方发消息，另一个地方收消息，跟 MQ 一样。其实，Spring 中的事件本质上就是观察者模式的应用。事件有其便利的一面，但是用多了也容易导致混乱，所以在实际项目中，我们还是要谨慎选择是否使用 Spring 事件。</p><h2 id="2-简单实践"><a href="#2-简单实践" class="headerlink" title="2. 简单实践"></a>2. 简单实践</h2><p>先用一个简单的案例，小伙伴们先了解一下 Spring 中事件的应用。</p><p>事件发布流程中，有三个核心概念，他们之间的关系如下图：</p><p><img src="http://img.itboyhub.com/2022/08/spring-event.png"></p><ul><li>事件源（ApplicationEvent）：这个就是你要发布的事件对象。</li><li>事件发布器（ApplicationEventPublisher）：这是事件的发布工具。</li><li>事件监听器（ApplicationListener）：这个相当于是事件的消费者。</li></ul><p>以上三个要素，事件源和事件监听器都可以有多个，事件发布器（通常是由容器来扮演）一般来说只有一个。</p><p>接下来松哥通过一个简单的案例来和小伙伴们演示一下 Spring 中事件的用法。</p><p>首先，我们需要自定义一个事件对象，自定义的事件继承自 ApplicationEvent 类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEvent</span><span class="params">(Object source, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyEvent&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;&#125; &quot;</span> + <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我只是额外定义了一个 name 属性，如果大家在事件发送的时候需要传递的数据比较多，那么就可以在这里定义更多的属性。</p><blockquote><p>在具体实践中，事件源并非一定要继承自 ApplicationEvent，事件源也可以是一个普通的 Java 类，如果是普通的 Java 类，系统会自动将之封装为一个 PayloadApplicationEvent 对象去发送。</p></blockquote><p>接下来通过事件发布器将事件发布出去。Spring 中事件发布器有专门的接口 ApplicationEventPublisher：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventPublisher</span> &#123;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">publishEvent((Object) event);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就两个方法，上面方法调用了下面方法，从这两个方法的参数中也可以看出来，发送时候的消息类型可以分为两种，一种是继承自 ApplicationEvent 类，另一种则是普通的 Java 对象。</p><p>AbstractApplicationContext 实现了该接口并重写了接口中的方法，所以我们平时使用的 AnnotationConfigApplicationContext 或者 ClassPathXmlApplicationContext，里边都是可以直接调用事件发布方法的。</p><p>事件发布方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JavaConfig.class);</span><br><span class="line">ctx.publishEvent(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>(), <span class="string">&quot;javaboy&quot;</span>));</span><br></pre></td></tr></table></figure><p>事件发布之后，我们还需要一个事件消费者去消费这个事件，或者也可以称之为事件监听器。</p><p>事件监听器有两种定义方式，第一种是自定义类实现 ApplicationListener 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MyEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;event = &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式则是通过注解去标记事件消费方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener02</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener(value = MyEvent.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;event02 = &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们一个简单的事件发布订阅就完成了，现在我们去发布事件，事件监听器中就可以接收到事件。</p><h2 id="3-原理分析"><a href="#3-原理分析" class="headerlink" title="3. 原理分析"></a>3. 原理分析</h2><p>Spring 事件单纯从用法上来说是非常容易的，上面松哥也都给大家演示了，原理即使我们不去看源码，大概也能猜出来个七七八八：<strong>当我们去发布一个事件的时候，系统就会去找到所有合适的事件消费者，然后去调用这些事件消费者，就是这么简单。</strong></p><h3 id="3-1-ApplicationEventMulticaster"><a href="#3-1-ApplicationEventMulticaster" class="headerlink" title="3.1 ApplicationEventMulticaster"></a>3.1 ApplicationEventMulticaster</h3><p>事件的这一切，我们得从 ApplicationEventMulticaster 开始说起，这是一个接口，从名字上可以看出来，这个叫做事件广播器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventMulticaster</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addApplicationListenerBean</span><span class="params">(String listenerBeanName)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeApplicationListener</span><span class="params">(ApplicationListener&lt;?&gt; listener)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeApplicationListenerBean</span><span class="params">(String listenerBeanName)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeApplicationListeners</span><span class="params">(Predicate&lt;ApplicationListener&lt;?&gt;&gt; predicate)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeApplicationListenerBeans</span><span class="params">(Predicate&lt;String&gt; predicate)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAllListeners</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>addApplicationListener：这个方法是添加一个事件消费者进来，这个方法参数就是一个 ApplicationListener，无论我们通过何种方式注册的事件消费者（继承类或者注解的方式），最终都是调用这个方法把事件消费者添加进来的。</li><li>addApplicationListenerBean：这个方法是添加事件消费者的 bean 进来，这个专门处理继承自 ApplicationListener 类的消费者，继承自 ApplicationListener 类的消费者也是要注册到 Spring 容器中去的，将来会通过这个方法记录这些 bean 的名字。</li><li>removeApplicationListener：移除一个 ApplicationListener 监听器。</li><li>removeApplicationListenerBean：根据 beanName 移除一个 ApplicationListener 监听器。</li><li>removeApplicationListeners：根据条件移除 ApplicationListener 监听器。</li><li>removeApplicationListenerBeans：根据条件移除 ApplicationListener 监听器。</li><li>removeAllListeners：移除所有 ApplicationListener。</li><li>multicastEvent：这个方法有两个重载的方法，这就是事件广播方法了，其中一个重载方法多了一个 ResolvableType，这个是描述泛型信息的。</li></ul><p>ApplicationEventMulticaster 的继承关系比较简单，它也只有一个实现类，所以分析起来相对要容易一些：</p><p><img src="http://img.itboyhub.com/2022/08/application_event_multicaster.png"></p><p>接下来我们的分析基本上都集中在 AbstractApplicationEventMulticaster 和 SimpleApplicationEventMulticaster 两个类中。</p><h3 id="3-2-收集监听器"><a href="#3-2-收集监听器" class="headerlink" title="3.2 收集监听器"></a>3.2 收集监听器</h3><p>前面松哥和大家说了，监听器的定义有两种方式，要么直接继承自 ApplicationListener，要么通过添加 @EventListener 注解，那么接下来我们就来看下这两种监听器是如何加载到 Spring 容器中的。</p><h4 id="3-2-1-类监听器"><a href="#3-2-1-类监听器" class="headerlink" title="3.2.1 类监听器"></a>3.2.1 类监听器</h4><p>类监听器相对来说好处理一些，直接去 Spring 容器中查找相关类型的 Bean 即可。</p><p>在初始化容器的 refresh 方法中，系统会调用到 registerListeners 方法，这个方法就是用来处理所有的类监听器的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里边干了三件事。</p><p>首先就是先处理所有的静态监听器，即不存在于 Spring 容器中的监听器，可以直接调用 getApplicationListeners() 方法去获取，对应的调用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        ctx.addApplicationListener(<span class="keyword">new</span> <span class="title class_">MyEventListener</span>());</span><br><span class="line">        ctx.register(JavaConfig.class);</span><br><span class="line">        ctx.refresh();</span><br><span class="line">        ctx.publishEvent(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>(), <span class="string">&quot;javaboy&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，这里我手动调用容器的 addApplicationListener 方法添加了一个监听器，这个手动加进来的监听器可以不必存在于 Spring 容器中。</p><blockquote><p>这种写法大家作为了解即可，因为一般我们不会这样做，比较麻烦且无必要。</p></blockquote><p>registerListeners 方法干的第二件事就是从 Spring 容器中查找所有的 ApplicationListener 类型的 beanName，并将查找的结果先存起来，将来广播事件的时候使用。有小伙伴可能会说为什么不直接到找到 ApplicationListener 对象存起来，一步到位多省事！注意，这个地方还拿不到对象，现在还是 Spring 容器的初始化阶段，此时对象都还没有初始化，要在 refresh 方法的倒数第二步进行 Bean 的初始化，所以现在只能先拿到 beanName 存起来。</p><p>registerListeners 方法干的第三件事是检查是否有需要提前发布的事件，如果有就先将之广播出去。</p><p>在具体的 addApplicationListener 方法中，会先检查当前对象是否是代理对象，如果是，则先把代理对象提取出来，然后从监听器集合中先移除再重新添加，防止一个监听器以代理对象的方式被添加一次，又以被代理对象被添加一次；addApplicationListenerBean 方法则没有这么麻烦，直接添加到 Set 集合中即可，可以自动去重。</p><p>对于第二件事，由于这里存的是 beanName，那么这个 beanName 什么时候会成为 bean 对象呢？有一个后置处理器 ApplicationListenerDetector，在该后置处理器的 postProcessAfterInitialization 方法中，会去挨个检查创建出来的 bean 是否为一个 ApplicationListener，如果是，则将之添加到事件监听器集合中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationListener&lt;?&gt; applicationListener) &#123;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonNames.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (Boolean.TRUE.equals(flag)) &#123;</span><br><span class="line"><span class="built_in">this</span>.applicationContext.addApplicationListener(applicationListener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Boolean.FALSE.equals(flag)) &#123;</span><br><span class="line"><span class="built_in">this</span>.singletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是监听器类的收集过程。</p><h4 id="3-2-2-注解监听器"><a href="#3-2-2-注解监听器" class="headerlink" title="3.2.2 注解监听器"></a>3.2.2 注解监听器</h4><p>通过注解定义的事件监听器则会比较特殊，因为注解标记的是方法，这些方法最终会被封装为 ApplicationListenerMethodAdapter，ApplicationListenerMethodAdapter 也是 ApplicationListener 的一种，将来在执行的时候，无论是通过类定义的事件监听器还是通过注解定义的事件监听器，都可以统一对待处理。</p><p>对于这一类监听器的处理是在 Spring 容器初始化的最后一步，即初始化各个 Bean，初始化完成之后，就会去处理这一类的 Bean，方法执行流程如下：</p><p><img src="http://img.itboyhub.com/2022/08/spring_graph_202310111448.png"></p><p>所以最终就是在 EventListenerMethodProcessor#processBean 方法中处理通过注解配置的监听器的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Class&lt;?&gt; targetType)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.nonAnnotatedClasses.contains(targetType) &amp;&amp;</span><br><span class="line">AnnotationUtils.isCandidateClass(targetType, EventListener.class) &amp;&amp;</span><br><span class="line">!isSpringContainerClass(targetType)) &#123;</span><br><span class="line">Map&lt;Method, EventListener&gt; annotatedMethods = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">annotatedMethods = MethodIntrospector.selectMethods(targetType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt;</span><br><span class="line">AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isEmpty(annotatedMethods)) &#123;</span><br><span class="line"><span class="built_in">this</span>.nonAnnotatedClasses.add(targetType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Non-empty set of methods</span></span><br><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.applicationContext;</span><br><span class="line">List&lt;EventListenerFactory&gt; factories = <span class="built_in">this</span>.eventListenerFactories;</span><br><span class="line"><span class="keyword">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class="line"><span class="keyword">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class="line"><span class="keyword">if</span> (factory.supportsMethod(method)) &#123;</span><br><span class="line"><span class="type">Method</span> <span class="variable">methodToUse</span> <span class="operator">=</span> AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">ApplicationListener&lt;?&gt; applicationListener =</span><br><span class="line">factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line"><span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter alma) &#123;</span><br><span class="line">alma.init(context, <span class="built_in">this</span>.evaluator);</span><br><span class="line">&#125;</span><br><span class="line">context.addApplicationListener(applicationListener);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码很好懂，首先调用 MethodIntrospector.selectMethods 方法，这个方法就是去查询当前 Class 中所有被 @EventListener 注解标记的方法，将查询的结果存入到 annotatedMethods 集合中。如果这个集合为空，那就意味着当前 Class 是没有注解标记的 Class。否则就去遍历 annotatedMethods 集合。</p><p>遍历的时候，通过 EventListenerFactory 来创建 ApplicationListener 对象，EventListenerFactory 是一个接口，这里说是在遍历 factories 集合，但是这个集合中只有一个有效对象 DefaultEventListenerFactory，所以实际上就是由 DefaultEventListenerFactory 来创建 ApplicationListener，创建出来的就是我们前面所说的 ApplicationListenerMethodAdapter，最后将创建结果调用 addApplicationListener 方法添加到事件监听器集合中（最后的 context 其实跟前面松哥案例中的 ctx 就是一个东西）。</p><p>对于监听器的收集，主要就是如上两种方式。</p><h3 id="3-3-事件发布"><a href="#3-3-事件发布" class="headerlink" title="3.3 事件发布"></a>3.3 事件发布</h3><p>Spring 中的事件发布接口是 ApplicationEventMulticaster，这个接口只有一个干活的类就是 SimpleApplicationEventMulticaster，在 Spring 容器初始化的 refresh 方法中，会调用到 initApplicationEventMulticaster 方法，这个方法就是用来初始化事件广播器的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="built_in">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>APPLICATION_EVENT_MULTICASTER_BEAN_NAME</code> 变量的名称是 applicationEventMulticaster，如果容器中存在名为 applicationEventMulticaster 的 bean，则直接获取，如果不存在，则直接 new 一个 SimpleApplicationEventMulticaster 并注册到 Spring 容器中。</p><p>这段代码给我们的启示是，如果想要自定义 ApplicationEventMulticaster，则自定义的 beanName 必须是 applicationEventMulticaster，否则自定义的 bean 不会生效。</p><p>接下来就是事件发布了，事件发布我们就从 publishEvent 方法开始看起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">publishEvent(event, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType typeHint)</span> &#123;</span><br><span class="line"><span class="type">ResolvableType</span> <span class="variable">eventType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">ApplicationEvent applicationEvent;</span><br><span class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent applEvent) &#123;</span><br><span class="line">applicationEvent = applEvent;</span><br><span class="line">eventType = typeHint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">ResolvableType</span> <span class="variable">payloadType</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (typeHint != <span class="literal">null</span> &amp;&amp; ApplicationEvent.class.isAssignableFrom(typeHint.toClass())) &#123;</span><br><span class="line">eventType = typeHint;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">payloadType = typeHint;</span><br><span class="line">&#125;</span><br><span class="line">applicationEvent = <span class="keyword">new</span> <span class="title class_">PayloadApplicationEvent</span>&lt;&gt;(<span class="built_in">this</span>, event, payloadType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Determine event type only once (for multicast and parent publish)</span></span><br><span class="line"><span class="keyword">if</span> (eventType == <span class="literal">null</span>) &#123;</span><br><span class="line">eventType = ResolvableType.forInstance(applicationEvent);</span><br><span class="line"><span class="keyword">if</span> (typeHint == <span class="literal">null</span>) &#123;</span><br><span class="line">typeHint = eventType;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationEvents != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Publish event via parent context as well...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext abstractApplicationContext) &#123;</span><br><span class="line">abstractApplicationContext.publishEvent(event, typeHint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的逻辑我们来看下：</p><ol><li>首先，如果传入的事件类型就是 ApplicationEvent 类型，则直接赋值给 applicationEvent。</li><li>否则就说明这个事件可能是一个普通的 Java 对象，那么就将这个 Java 对象封装成一个 PayloadApplicationEvent 对象并赋值给 applicationEvent。</li><li>如果 eventType 为 null（默认情况下，此时 eventType 就是 null），那么就从 applicationEvent 中提取出来要处理的事件对象：如果事件类型本身就是 ApplicationEvent，那么 eventType 就是具体的事件对象；如果事件类型本身是普通的 Java 对象，那么这里提取到的 eventType 就是一个 ResolvableType，这个 ResolvableType 中标记了具体的事件对象。</li><li>接下来就是调用广播器去广播事件了，即 multicastEvent，这也是核心步骤。</li><li>最后还会再去判断一下当前容器是否存在 parent，如果存在 parent，则在 parent 容器中也将当前事件广播出去，这就会导致凡是注册到 parent 容器中的监听器，也会收到子容器发布的事件。</li></ol><p>这段代码逻辑并不难，接下来我们来看下 multicastEvent 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line"><span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : ResolvableType.forInstance(event));</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里看到的就是 SimpleApplicationEventMulticaster 的 multicastEvent 方法。</p><p>这个方法首先去分析出来事件的类型 type，然后获取一个异步处理器，接下来就根据事件 event 和 type 去找到合适的事件监听器，然后遍历事件监听器，遍历的时候，如果异步处理器 executor 不为空，那么就在这里异步处理器中调用事件监听器，否则就直接在当前线程中调用事件监听器。</p><blockquote><p>从这里大家可以看出来，如果我们提供了异步处理器，那么可以实现 Spring 事件的异步处理，即非阻塞的效果，否则事件是阻塞的，即发布者将事件发布之后，必须等消费者将事件处理了，发布者的代码才会继续往下走。</p></blockquote><p>如果我们想在 Spring 实现非阻塞的事件，那么可以配置如下 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SimpleApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SimpleApplicationEventMulticaster</span> <span class="variable">multicaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    <span class="comment">//核心线程池数量</span></span><br><span class="line">    executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    <span class="comment">//最大线程数量</span></span><br><span class="line">    executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//线程池的队列容量</span></span><br><span class="line">    executor.setQueueCapacity(Runtime.getRuntime().availableProcessors() * <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//线程名称的前缀</span></span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">&quot;javaboy-async-executor-&quot;</span>);</span><br><span class="line">    executor.initialize();</span><br><span class="line">    multicaster.setTaskExecutor(executor);</span><br><span class="line">    <span class="keyword">return</span> multicaster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置这个 Bean 的时候，注意 beanName 必须是 applicationEventMulticaster。</strong></p><p>接下来再来看看 getApplicationListeners 方法是如何根据当前事件类型找到对应的事件处理器的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(</span><br><span class="line">ApplicationEvent event, ResolvableType eventType) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">source</span> <span class="operator">=</span> event.getSource();</span><br><span class="line">Class&lt;?&gt; sourceType = (source != <span class="literal">null</span> ? source.getClass() : <span class="literal">null</span>);</span><br><span class="line"><span class="type">ListenerCacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenerCacheKey</span>(eventType, sourceType);</span><br><span class="line"><span class="comment">// Potential new retriever to populate</span></span><br><span class="line"><span class="type">CachedListenerRetriever</span> <span class="variable">newRetriever</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Quick check for existing entry on ConcurrentHashMap</span></span><br><span class="line"><span class="type">CachedListenerRetriever</span> <span class="variable">existingRetriever</span> <span class="operator">=</span> <span class="built_in">this</span>.retrieverCache.get(cacheKey);</span><br><span class="line"><span class="keyword">if</span> (existingRetriever == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Caching a new ListenerRetriever if possible</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beanClassLoader == <span class="literal">null</span> ||</span><br><span class="line">(ClassUtils.isCacheSafe(event.getClass(), <span class="built_in">this</span>.beanClassLoader) &amp;&amp;</span><br><span class="line">(sourceType == <span class="literal">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="built_in">this</span>.beanClassLoader)))) &#123;</span><br><span class="line">newRetriever = <span class="keyword">new</span> <span class="title class_">CachedListenerRetriever</span>();</span><br><span class="line">existingRetriever = <span class="built_in">this</span>.retrieverCache.putIfAbsent(cacheKey, newRetriever);</span><br><span class="line"><span class="keyword">if</span> (existingRetriever != <span class="literal">null</span>) &#123;</span><br><span class="line">newRetriever = <span class="literal">null</span>;  <span class="comment">// no need to populate it in retrieveApplicationListeners</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (existingRetriever != <span class="literal">null</span>) &#123;</span><br><span class="line">Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners();</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If result is null, the existing retriever is not fully populated yet by another thread.</span></span><br><span class="line"><span class="comment">// Proceed like caching wasn&#x27;t possible for this current local attempt.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retrieveApplicationListeners(eventType, sourceType, newRetriever);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法中我们可以看到，这里根据 eventType 和 sourceType 构建了一个缓存的 key，也就是根据事件的类型和其所属的 source，将与其对应的事件监听器缓存起来，缓存的对象就是 CachedListenerRetriever，如果根据缓存 key 能找到缓存 value，那么就从缓存的 value 中提取出来监听器，否则就调用 retrieveApplicationListeners 方法去查找监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners(</span><br><span class="line">ResolvableType eventType, <span class="meta">@Nullable</span> Class&lt;?&gt; sourceType, <span class="meta">@Nullable</span> CachedListenerRetriever retriever) &#123;</span><br><span class="line">List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Set&lt;ApplicationListener&lt;?&gt;&gt; filteredListeners = (retriever != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;() : <span class="literal">null</span>);</span><br><span class="line">Set&lt;String&gt; filteredListenerBeans = (retriever != <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;() : <span class="literal">null</span>);</span><br><span class="line">Set&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br><span class="line">Set&lt;String&gt; listenerBeans;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.defaultRetriever) &#123;</span><br><span class="line">listeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListeners);</span><br><span class="line">listenerBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.defaultRetriever.applicationListenerBeans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add programmatically registered listeners, including ones coming</span></span><br><span class="line"><span class="comment">// from ApplicationListenerDetector (singleton beans and inner beans).</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : listeners) &#123;</span><br><span class="line"><span class="keyword">if</span> (supportsEvent(listener, eventType, sourceType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">filteredListeners.add(listener);</span><br><span class="line">&#125;</span><br><span class="line">allListeners.add(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add listeners by bean name, potentially overlapping with programmatically</span></span><br><span class="line"><span class="comment">// registered listeners above - but here potentially with additional metadata.</span></span><br><span class="line"><span class="keyword">if</span> (!listenerBeans.isEmpty()) &#123;</span><br><span class="line"><span class="type">ConfigurableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeans) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (supportsEvent(beanFactory, listenerBeanName, eventType)) &#123;</span><br><span class="line">ApplicationListener&lt;?&gt; listener =</span><br><span class="line">beanFactory.getBean(listenerBeanName, ApplicationListener.class);</span><br><span class="line"><span class="keyword">if</span> (!allListeners.contains(listener) &amp;&amp; supportsEvent(listener, eventType, sourceType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isSingleton(listenerBeanName)) &#123;</span><br><span class="line">filteredListeners.add(listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">filteredListenerBeans.add(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">allListeners.add(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Remove non-matching listeners that originally came from</span></span><br><span class="line"><span class="comment">// ApplicationListenerDetector, possibly ruled out by additional</span></span><br><span class="line"><span class="comment">// BeanDefinition metadata (e.g. factory method generics) above.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">listener</span> <span class="operator">=</span> beanFactory.getSingleton(listenerBeanName);</span><br><span class="line"><span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line">filteredListeners.remove(listener);</span><br><span class="line">&#125;</span><br><span class="line">allListeners.remove(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="comment">// Singleton listener instance (without backing bean definition) disappeared -</span></span><br><span class="line"><span class="comment">// probably in the middle of the destruction phase</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAwareOrderComparator.sort(allListeners);</span><br><span class="line"><span class="keyword">if</span> (retriever != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (filteredListenerBeans.isEmpty()) &#123;</span><br><span class="line">retriever.applicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(allListeners);</span><br><span class="line">retriever.applicationListenerBeans = filteredListenerBeans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">retriever.applicationListeners = filteredListeners;</span><br><span class="line">retriever.applicationListenerBeans = filteredListenerBeans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> allListeners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码比较长，但是逻辑比较简单。</p><p>首先遍历之前收集到的所有 listener，调用 supportsEvent 方法去判断该 listener 是否支持当前事件，如果支持，则将之存入到 allListeners 集合中，同时，如果缓存对象 retriever 不为空，则往 filteredListeners 中也存一份监听器。</p><p>接下来遍历 listenerBeans，遍历的时候根据 supportsEvent 方法去判断该 listener 是否支持当前事件，如果支持，那么就获取到对应的 bean，如果这个 bean 是单例的，并且在存在缓存对象的的情况下，那么就将之存入到 filteredListeners 集合中，如果这个 bean 不是单例的，那么就把 beanName 存入到 filteredListenerBeans 集合中。当然，最终拿到的监听器对象也要存入到 allListeners 集合中。</p><p>最后还会做一个判断，如果缓存的 value 不为空，那么当 filteredListenerBeans 为空就表示不存在非单例的监听器，所有的监听器都是单例的，即 allListeners 中不存在重复的 Bean，那么直接将 allListeners 转为 hashset 即可，否则说明有多例的监听器，那么就意味着 allListeners 集合中存在重复的 bean，此时就把 filteredListeners 集合赋值给缓存对象的 applicationListeners 属性即可。</p><p>这就是查找匹配的监听器的大致过程。这里还涉及到一个比较重要的方法 supportsEvent，这个是判断监听器是否匹配的具体方法，这有三个重载的方法，前两个重载方法都属于初步校验，如果校验通过，第三个重载方法做最终校验。</p><ol><li>supportsEvent(ConfigurableBeanFactory, String, ResolvableType)：这个方法是根据 beanName 判断某一个 bean 是否满足条件，这只是一个初步判断，并不是最终的判断，判断的逻辑就是如果当前 bean 是 GenericApplicationListener 或者 SmartApplicationListener 类型，就算是匹配的，否则就去判断当前的事件类型和事件处理器上的泛型是否匹配。</li><li>supportsEvent(Class&lt;?&gt;, ResolvableType)：这个方法是判断当前事件监听器类型是否和事件类型相匹配。</li><li>supportsEvent(ApplicationListener<?>, ResolvableType, Class<?>)：这个是做最终的评估，这里会把事件监听器转为 GenericApplicationListener 类型，然后分别判断事件类型和 source 类型，满足条件就是目标事件监听器了。</li></ol><blockquote><p>一般来说，通过继承类的方式开发的事件监听器，要走前两个方法，如果是通过注解定义的事件监听器，直接走第三个方法。</p></blockquote><p>好啦，这就是 Spring 中事件的玩法啦，感兴趣的小伙伴可以自行 DEBUG 看下哦～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天我们来聊一聊 Spring 中的事件机制，从用法到源码分析，我们挨个过一遍。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>搬家的时候，书可真是重资产呀</title>
    <link href="http://www.javaboy.org/2023/1206/banjia.html"/>
    <id>http://www.javaboy.org/2023/1206/banjia.html</id>
    <published>2023-12-06T10:54:57.000Z</published>
    <updated>2024-05-10T11:12:29.235Z</updated>
    
    <content type="html"><![CDATA[<p>最近文章发的少，因为最近事情比较多，松哥在忙着搬家。</p><span id="more"></span><p>现在租的房子住了三年多了，有不少东西需要清理，在清理的过程中发现还有不少书。有一部分是出版社当时寄给我做送书活动用的，但是因为我比较懒，至今还没送完，还有一部分是我自己买的，看完了就都摞在书架上了，几年下来攒了不少书。</p><p>其实在外租房我特别恐惧买书，因为这都是“重资产”，搬家的时候最沉的就是这些东西了。虽然我从小就希望能有自己的书架书桌，但是在外租房漂泊还是不做奢想了。</p><p>对于技术类图书，我一直是能看电子书就选择电子书，但是无奈有时候一些新出版的图书，微信读书上还没上线，自己又比较急，那就只能买实体书了。</p><p>所以想了想，想在搬家之前，把这些书送给小伙伴们吧！刚好最近 Spring 源码视频也已经接近杀青了，因此计划是这样，从今天到 12 月 8 号，凡是上车 Spring 源码视频或者 TienChin 项目视频的小伙伴，都可以参与松哥组织的一次抽奖活动，奖品是技术图书，中奖率为 50%（我会拉群以保证中奖率）。</p><p>关于 TienChin 项目的介绍，小伙伴们可以戳这里：<a href="https://mp.weixin.qq.com/s/iHjeDmQ4sKdL9Hx2FTvSeQ">TienChin 项目配套视频来啦</a>。</p><p>Spring 源码视频接近杀青了，视频介绍戳这里：<a href="https://mp.weixin.qq.com/s/mHizA4NQj1_94g8mMrAm4w">Spring源码应该怎么学？</a>。下面是已经更新的 Spring 源码视频目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">├── 01.基础用法</span><br><span class="line">│   ├── 01.IoC基础</span><br><span class="line">│   │   ├── 01.Spring框架介绍-核心容器.mp4</span><br><span class="line">│   │   ├── 02.Spring框架介绍-数据访问和通信.mp4</span><br><span class="line">│   │   ├── 03.Spring框架介绍-Web模块.mp4</span><br><span class="line">│   │   ├── 04.Spring框架介绍-AOP和测试.mp4</span><br><span class="line">│   │   ├── 05.什么是IoC.mp4</span><br><span class="line">│   │   ├── 06.自定义一个简单的IoC.mp4</span><br><span class="line">│   │   ├── 07.向Spring容器注册Bean.mp4</span><br><span class="line">│   │   ├── 08.从Spring容器获取Bean.mp4</span><br><span class="line">│   │   ├── 09.id属性和name属性.mp4</span><br><span class="line">│   │   ├── 10.基本属性注入.mp4</span><br><span class="line">│   │   ├── 11.复杂属性注入.mp4</span><br><span class="line">│   │   ├── 12.构造器注入.mp4</span><br><span class="line">│   │   ├── 13.p名称空间注入.mp4</span><br><span class="line">│   │   ├── 14.属性自动注入.mp4</span><br><span class="line">│   │   ├── 15.配置文件加载.mp4</span><br><span class="line">│   │   ├── 16.Java代码配置IoC.mp4</span><br><span class="line">│   │   ├── 17.BeanName自动生成原理.mp4</span><br><span class="line">│   │   ├── 18.id和name属性处理原理.mp4</span><br><span class="line">│   │   ├── 19.Bean 的作用域.mp4</span><br><span class="line">│   │   ├── 20.singleton 和 prototype 的区别.mp4</span><br><span class="line">│   │   ├── 21.条件注解详解.mp4</span><br><span class="line">│   │   ├── 22.多环境切换.mp4</span><br><span class="line">│   │   ├── 23.Profile原理分析.mp4</span><br><span class="line">│   │   ├── 24.自定义Profile.mp4</span><br><span class="line">│   │   ├── 25.Bean的依赖关系.mp4</span><br><span class="line">│   │   ├── 26.FactoryBean用法.mp4</span><br><span class="line">│   │   ├── 27.抽取Bean的公共属性.mp4</span><br><span class="line">│   │   ├── 28.父子容器问题.mp4</span><br><span class="line">│   │   ├── 29.@Configuration注解的作用.mp4</span><br><span class="line">│   │   ├── 30.Bean自动扫描.mp4</span><br><span class="line">│   │   └── 31.属性值注入.mp4</span><br><span class="line">│   ├── 02.AOP基础</span><br><span class="line">│   │   ├── 01.静态代理.mp4</span><br><span class="line">│   │   ├── 02.编译时增强和运行时增强.mp4</span><br><span class="line">│   │   ├── 03.编译时增强.mp4</span><br><span class="line">│   │   ├── 04.运行时增强-JDK.mp4</span><br><span class="line">│   │   ├── 05.运行时增强-CGLIB.mp4</span><br><span class="line">│   │   ├── 06.什么是Spring AOP.mp4</span><br><span class="line">│   │   ├── 07.SpringAOP和AspectJAOP.mp4</span><br><span class="line">│   │   ├── 08.Spring AOP核心概念.mp4</span><br><span class="line">│   │   ├── 09.Spring AOP入门用法.mp4</span><br><span class="line">│   │   ├── 10.五种通知.mp4</span><br><span class="line">│   │   ├── 11.Java代码配置AOP.mp4</span><br><span class="line">│   │   ├── 12.SpringAOP底层代理.mp4</span><br><span class="line">│   │   └── 13.通过注解定义AOP拦截规则.mp4</span><br><span class="line">│   ├── 03.JdbcTemplate</span><br><span class="line">│   │   ├── 01.JdbcTemplate基本操作.mp4</span><br><span class="line">│   │   ├── 02.增删改查.mp4</span><br><span class="line">│   │   └── 03.通过变量名传递参数.mp4</span><br><span class="line">│   └── 04.事务</span><br><span class="line">│       ├── 01.事务简介.mp4</span><br><span class="line">│       ├── 02.编程式事务.mp4</span><br><span class="line">│       ├── 03.XML配置声明式事务.mp4</span><br><span class="line">│       ├── 04.Java配置声明式事务.mp4</span><br><span class="line">│       ├── 05.Java+XML配置声明式事务.mp4</span><br><span class="line">│       ├── 06.自定义事务注解.mp4</span><br><span class="line">│       ├── 07.事务属性-隔离级别.mp4</span><br><span class="line">│       ├── 08.事务属性-传播性.mp4</span><br><span class="line">│       ├── 09.事务属性-传播性2.mp4</span><br><span class="line">│       ├── 10.事务属性-回滚规则.mp4</span><br><span class="line">│       ├── 11.事务属性-只读事务.mp4</span><br><span class="line">│       ├── 12.事务属性-超时时间.mp4</span><br><span class="line">│       └── 13.事务失效的场景.mp4</span><br><span class="line">└── 02.进阶用法</span><br><span class="line">    ├── 001.通过name属性定义别名.mp4</span><br><span class="line">    ├── 002.通过alias标签定义别名.mp4</span><br><span class="line">    ├── 003.别名处理接口AliasRegistry.mp4</span><br><span class="line">    ├── 004.aliasMap变量.mp4</span><br><span class="line">    ├── 005.allowAliasOverriding.mp4</span><br><span class="line">    ├── 006.hasAlias.mp4</span><br><span class="line">    ├── 007.removeAlias和isAlias.mp4</span><br><span class="line">    ├── 008.getAliases.mp4</span><br><span class="line">    ├── 009.checkForAliasCircle.mp4</span><br><span class="line">    ├── 010.canonicalName.mp4</span><br><span class="line">    ├── 011.registerAlias.mp4</span><br><span class="line">    ├── 012.resolveAliases.mp4</span><br><span class="line">    ├── 013.name属性解析原理.mp4</span><br><span class="line">    ├── 014.alias标签解析.mp4</span><br><span class="line">    ├── 015.DefaultListableBeanFactory.mp4</span><br><span class="line">    ├── 016.StaticListableBeanFactory.mp4</span><br><span class="line">    ├── 017.SimpleJndiBeanFactory.mp4</span><br><span class="line">    ├── 018.ApplicationContext.mp4</span><br><span class="line">    ├── 019.FactoryBean&amp;SmartFactoryBean.mp4</span><br><span class="line">    ├── 020.FactoryBean处理思路.mp4</span><br><span class="line">    ├── 021.Bean提前加载流程分析.mp4</span><br><span class="line">    ├── 022.isFactoryBean方法分析.mp4</span><br><span class="line">    ├── 023.getBean中&amp;的处理逻辑.mp4</span><br><span class="line">    ├── 024.BeanDefinition简介.mp4</span><br><span class="line">    ├── 025.RootBeanDefinition.mp4</span><br><span class="line">    ├── 026.ChildBeanDefinition.mp4</span><br><span class="line">    ├── 027.GenericBeanDefinition.mp4</span><br><span class="line">    ├── 028.AnnotatedGenericBeanDefinition.mp4</span><br><span class="line">    ├── 029.ScannedGenericBeanDefinition.mp4</span><br><span class="line">    ├── 030.ConfigurationClassBeanDefinition.mp4</span><br><span class="line">    ├── 031.CreateFromClassBeanDefinition.mp4</span><br><span class="line">    ├── 032.ClassDerivedBeanDefinition.mp4</span><br><span class="line">    ├── 033.加载XML配置的两种方式.mp4</span><br><span class="line">    ├── 034.BeanDefinitionReader.mp4</span><br><span class="line">    ├── 035.PropertiesBeanDefinitionReader.mp4</span><br><span class="line">    ├── 036.XmlBeanDefinitionReader.mp4</span><br><span class="line">    ├── 037.配置类解析为BeanDefinition.mp4</span><br><span class="line">    ├── 038.@Scope注解高级用法.mp4</span><br><span class="line">    ├── 039.编程式AOP.mp4</span><br><span class="line">    ├── 040.编程式AOP之target方法分析.mp4</span><br><span class="line">    ├── 041.TargetSource体系结构.mp4</span><br><span class="line">    ├── 042.SimpleBeanTargetSource.mp4</span><br><span class="line">    ├── 043.自定义TargetSource.mp4</span><br><span class="line">    ├── 044.引介增强.mp4</span><br><span class="line">    ├── 045.启动类上的@Scope注解代理原理.mp4</span><br><span class="line">    ├── 046.常规类上的@Scope注解.mp4</span><br><span class="line">    ├── 047.Java配置中的@Scope代理.mp4</span><br><span class="line">    ├── 048.导入配置类上的@Scope注解.mp4</span><br><span class="line">    ├── 049.@Configuration注解存在的意义是什么.mp4</span><br><span class="line">    ├── 050.@Configuration-Vs-@Component.mp4</span><br><span class="line">    ├── 051.@Configuration原理分析.mp4</span><br><span class="line">    ├── 052.@Configuration的两种模式Full和Lite.mp4</span><br><span class="line">    ├── 053.详细演示Full和Lite模式.mp4</span><br><span class="line">    ├── 054.Full模式和Lite模式特点总结.mp4</span><br><span class="line">    ├── 055.@Configuration注解解析源码分析.mp4</span><br><span class="line">    ├── 056.@Configuration注解解析源码分析-2.mp4</span><br><span class="line">    ├── 057.条件注解高级用法.mp4</span><br><span class="line">    ├── 058.条件注解高级用法补充.mp4</span><br><span class="line">    ├── 059.条件注解原理分析.mp4</span><br><span class="line">    ├── 060.beanName自动生成场景.mp4</span><br><span class="line">    ├── 061.beanName生成器分析.mp4</span><br><span class="line">    ├── 062.AnnotationBeanNameGenerator.mp4</span><br><span class="line">    ├── 063.BeanFactoryPostProcessor和BeanPostProcessor.mp4</span><br><span class="line">    ├── 064.BeanFactoryPostProcessor案例.mp4</span><br><span class="line">    ├── 065.BeanFactoryPostProcessor典型应用场景.mp4</span><br><span class="line">    ├── 066.Properties加载原理分析.mp4</span><br><span class="line">    ├── 067.BeanDefinitionRegistryPostProcessor.mp4</span><br><span class="line">    ├── 068.BeanFactoryPostProcessor作用时机分析.mp4</span><br><span class="line">    ├── 069.BeanPostProcessor接口分析.mp4</span><br><span class="line">    ├── 070.BeanPostProcessor实践.mp4</span><br><span class="line">    ├── 071.BeanPostProcessor实现AOP.mp4</span><br><span class="line">    ├── 072.MergedBeanDefinitionPostProcessor.mp4</span><br><span class="line">    ├── 073.BeanPostProcessor原理分析.mp4</span><br><span class="line">    ├── 074.合并BeanDefinition原理分析.mp4</span><br><span class="line">    ├── 075.合并BeanDefinition源码分析.mp4</span><br><span class="line">    ├── 076.父子容器原理分析.mp4</span><br><span class="line">    ├── 077.事件基本用法.mp4</span><br><span class="line">    ├── 078.事件是阻塞还是非阻塞.mp4</span><br><span class="line">    ├── 079.手动注册事件监听器.mp4</span><br><span class="line">    ├── 080.事件三大组件.mp4</span><br><span class="line">    ├── 081.Java类定义的事件监听器.mp4</span><br><span class="line">    ├── 082.Java类定义的事件监听器-补充.mp4</span><br><span class="line">    ├── 083.通过Java注解定义的事件监听器.mp4</span><br><span class="line">    ├── 084.ApplicationEventPublisher.mp4</span><br><span class="line">    ├── 085.ApplicationEventMulticaster.mp4</span><br><span class="line">    ├── 086.Spring事件补充.mp4</span><br><span class="line">    ├── 087.Java国际化.mp4</span><br><span class="line">    ├── 088.Spring国际化.mp4</span><br><span class="line">    ├── 089.MessageSource层级关系.mp4</span><br><span class="line">    ├── 090.getMessage方法原理分析.mp4</span><br><span class="line">    ├── 091.解析无参的key.mp4</span><br><span class="line">    ├── 092.解析有参key.mp4</span><br><span class="line">    ├── 093.Lifecycle基本用法.mp4</span><br><span class="line">    ├── 094.SmartLifecycle基本用法.mp4</span><br><span class="line">    ├── 095.Lifecycle中start方法执行原理.mp4</span><br><span class="line">    ├── 096.Lifecycle中stop方法执行原理.mp4</span><br><span class="line">    ├── 097.编程式AOP.mp4</span><br><span class="line">    ├── 098.动态代理对象创建流程.mp4</span><br><span class="line">    ├── 099.JDK和CGLIB动态代理分析.mp4</span><br><span class="line">    ├── 100.Advisor详解.mp4</span><br><span class="line">    ├── 101.自定义切面对象Advisor.mp4</span><br><span class="line">    ├── 102.重载方法拦截规则.mp4</span><br><span class="line">    ├── 103.拦截所有方法.mp4</span><br><span class="line">    ├── 104.默认配置的Pointcut对象.mp4</span><br><span class="line">    ├── 105.Pointcut经典写法.mp4</span><br><span class="line">    ├── 106.Pointcut分类.mp4</span><br><span class="line">    ├── 107.StaticMethodMatcherPointcut.mp4</span><br><span class="line">    ├── 108.StaticMethodMatcherPointcut-2.mp4</span><br><span class="line">    ├── 109.DynamicMethodMatcherPointcut.mp4</span><br><span class="line">    ├── 110.AnnotationMatchingPointcut.mp4</span><br><span class="line">    ├── 111.ControlFlowPointcut.mp4</span><br><span class="line">    ├── 112.ComposablePointcut.mp4</span><br><span class="line">    ├── 113.提前返回Bean的机会.mp4</span><br><span class="line">    ├── 114.提前AOP的机会.mp4</span><br><span class="line">    ├── 115.理解两个关键变量.mp4</span><br><span class="line">    ├── 116.特殊的beanName.mp4</span><br><span class="line">    ├── 117.自定义TargetSourceCreator.mp4</span><br><span class="line">    ├── 118.提前AOP实践.mp4</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近文章发的少，因为最近事情比较多，松哥在忙着搬家。&lt;/p&gt;</summary>
    
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
    <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>和小伙伴们仔细梳理一下 Spring 国际化吧！从用法到源码！</title>
    <link href="http://www.javaboy.org/2023/1121/spring-i18n.html"/>
    <id>http://www.javaboy.org/2023/1121/spring-i18n.html</id>
    <published>2023-11-21T10:54:41.000Z</published>
    <updated>2024-05-10T11:12:36.667Z</updated>
    
    <content type="html"><![CDATA[<p>国际化（Internationalization，简称 I18N）是指在 Java 应用程序中实现国际化的技术和方法。Java 提供了一套强大的国际化支持，使开发人员能够编写适应不同语言、地区和文化的应用程序。</p><span id="more"></span><p>Java 国际化的主要目标是使应用程序能够在不同语言环境下运行，并提供相应的本地化体验。以下是 Java 国际化的一些关键概念和组件：</p><ol><li>ResourceBundle：ResourceBundle 是 Java 国际化的核心组件之一，用于存储本地化的文本和其他资源。它根据当前的 Locale（区域设置）加载相应的资源文件，以提供与用户语言和地区相匹配的内容。</li><li>Locale：Locale 表示特定的语言和地区。Java 中的 Locale 对象包含了语言、国家&#x2F;地区和可选的变体信息。通过使用 Locale，可以确定应用程序应该使用哪种语言和地区的本地化资源。</li><li>MessageFormat：MessageFormat 是 Java 提供的一种格式化消息的工具类。它允许开发人员根据不同的语言和地区，将占位符替换为相应的值，并进行灵活的消息格式化。</li><li>DateFormat 和 NumberFormat：Java 提供了 DateFormat 和 NumberFormat 类，用于在不同的语言和地区格式化日期、时间和数字。这些类可以根据 Locale 的不同，自动适应不同的语言和地区的格式规则。</li><li>Properties 文件：Properties 文件是一种常见的配置文件格式，用于存储键值对。在 Java 国际化中，可以使用 Properties 文件来存储本地化文本和其他资源的键值对。</li></ol><p>通过使用 Java 国际化的技术和组件，开发人员可以轻松地为 Java 应用程序提供多语言支持。应用程序可以根据用户的 Locale 加载相应的资源，并根据不同的语言和地区提供本地化的用户界面、日期时间格式、数字格式等。这样，应用程序就能够更好地适应全球用户的需求，提供更好的用户体验。</p><h2 id="1-Java-国际化"><a href="#1-Java-国际化" class="headerlink" title="1. Java 国际化"></a>1. Java 国际化</h2><p>经过前面的介绍，小伙伴们已经了解到，Java 本身实际上已经提供了一整套的国际化方案，Spring 中当然也有国际化，Spring 中的国际化实际上就是对 Java 国际化的二次封装。</p><p>所以我们先来了解下 Java 中的国际化怎么玩。</p><h3 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h3><p>首先我们需要定义自己的资源文件，资源文件命名方式是：</p><ul><li><code>资源名_语言名称_国家/地区名称</code>.properties</li></ul><p>其中 <code>_语言名称_国家/地区名称</code> 可以省略，如果省略的话，这个文件将作为默认的资源文件。</p><p>现在假设我在 resources 目录下创建如下三个资源文件：</p><p><img src="http://img.itboyhub.com/2022/08/20230914170644.png"></p><p>三个资源文件的内容分别如下。</p><p>content.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hello</span>=<span class="string">默认内容</span></span><br></pre></td></tr></table></figure><p>content_en_US.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hello</span>=<span class="string">hello world</span></span><br></pre></td></tr></table></figure><p>content_zh_CN.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hello</span>=<span class="string">你好世界！</span></span><br></pre></td></tr></table></figure><p>接下来我们看下 Java 代码如何加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Locale</span> <span class="variable">localeEn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;en&quot;</span>, <span class="string">&quot;US&quot;</span>);</span><br><span class="line"><span class="type">Locale</span> <span class="variable">localeZh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;zh&quot;</span>, <span class="string">&quot;CN&quot;</span>);</span><br><span class="line"><span class="type">ResourceBundle</span> <span class="variable">res</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;content&quot;</span>, localeZh);</span><br><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> res.getString(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;hello = &quot;</span> + hello);</span><br></pre></td></tr></table></figure><p>首先我们先来定义 Locale 对象，这个 Locale 对象相当于定义本地环境，说明自己当前的语言环境和地区信息，然后调用 <code>ResourceBundle.getBundle</code> 方法去加载配置文件，该方法第一个参数就是资源的名称，第二个参数则是当前的环境，加载完成之后，就可以从 res 变量中提取出来数据了。而且这个提取是根据当前系统环境提取的。</p><p>在上面的案例中，如果配置的 locale 实际上并不存在，那么就会读取 content.properties 文件中的内容（相当于这就是默认的配置）。</p><h3 id="1-2-Format"><a href="#1-2-Format" class="headerlink" title="1.2 Format"></a>1.2 Format</h3><p>Java 中的国际化还提供了一些 Format 对象，用来格式化传入的资源。</p><p>Format 主要有三类，分别是：</p><ol><li>MessageFormat：这个是字符串格式化，可以在资源中配置一些占位符，在提取的时候再将这些占位符进行填充。</li><li>DateFormat：这个是日期的格式化。</li><li>NumberFormat：这个是数字的格式化。</li></ol><p>不过这三个完全可以单独当成工具类来使用，并非总是要结合 I18N 一起来用，实际上我们在日常的开发中，就会经常使用 DateFormat 的子类 SimpleDateFormat。</p><p>这里我把三个分别举个例子给大家演示下。</p><h4 id="MessageFormat"><a href="#MessageFormat" class="headerlink" title="MessageFormat"></a>MessageFormat</h4><p>对于这种，我们在定义资源的时候，可以使用占位符，例如下面这样：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hello</span>=<span class="string">你好世界！</span></span><br><span class="line"><span class="attr">name</span>=<span class="string">你好 &#123;0&#125;，欢迎来到 &#123;1&#125;</span></span><br></pre></td></tr></table></figure><p>那么这里 <code>&#123;0&#125;</code> 和 <code>&#123;1&#125;</code> 就是占位符，将来读取到这个字符串之后，可以给占位符的位置填充数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Locale</span> <span class="variable">localeEn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;en&quot;</span>, <span class="string">&quot;US&quot;</span>);</span><br><span class="line"><span class="type">Locale</span> <span class="variable">localeZh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;zh&quot;</span>, <span class="string">&quot;CN&quot;</span>);</span><br><span class="line"><span class="type">ResourceBundle</span> <span class="variable">res</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;content&quot;</span>, localeZh);</span><br><span class="line"><span class="type">MessageFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageFormat</span>(res.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">Object[] arguments = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;javaboy&quot;</span>, <span class="string">&quot;Spring源码学习课程&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> format.format(arguments);</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br></pre></td></tr></table></figure><p>那么最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230914201502.png"></p><h4 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h4><p>这个是根据当前环境信息对日期进行格式化，中文的就格式化为中文日期，英文就格式化为英文日期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.LONG, <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;zh&quot;</span>, <span class="string">&quot;CN&quot;</span>));</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df2</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.LONG, <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;en&quot;</span>, <span class="string">&quot;US&quot;</span>));</span><br><span class="line">System.out.println(df.format(date));</span><br><span class="line">System.out.println(df2.format(date));</span><br></pre></td></tr></table></figure><p>参数 LONG 表示演示完整的日期信息。</p><p>执行结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230914201834.png"></p><h4 id="NumberFormat"><a href="#NumberFormat" class="headerlink" title="NumberFormat"></a>NumberFormat</h4><p>数字格式化这块比较典型的就是关于货币的格式化了，我们来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Locale</span> <span class="variable">localeEn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;en&quot;</span>, <span class="string">&quot;US&quot;</span>);</span><br><span class="line"><span class="type">Locale</span> <span class="variable">localeZh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;zh&quot;</span>, <span class="string">&quot;CN&quot;</span>);</span><br><span class="line"><span class="type">NumberFormat</span> <span class="variable">formatZh</span> <span class="operator">=</span> NumberFormat.getCurrencyInstance(localeZh);</span><br><span class="line"><span class="type">NumberFormat</span> <span class="variable">formatEn</span> <span class="operator">=</span> NumberFormat.getCurrencyInstance(localeEn);</span><br><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">199.99</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;formatZh.format(num) = &quot;</span> + formatZh.format(num));</span><br><span class="line">System.out.println(<span class="string">&quot;formatEn.format(num) = &quot;</span> + formatEn.format(num));</span><br></pre></td></tr></table></figure><p>根据不同的 Locale 来获取不同的货币格式化实例。</p><p>最终打印结果如下：</p><p><img src="http://img.itboyhub.com/2022/08/20230914202702.png"></p><p>Java 中提供的国际化，差不多就这么玩！</p><h2 id="2-Spring-国际化"><a href="#2-Spring-国际化" class="headerlink" title="2. Spring 国际化"></a>2. Spring 国际化</h2><p>Spring 的国际化，实际上就是在 Java 国际化的基础之上做了一些封装，提供了一些新的能力。</p><h3 id="2-1-实践"><a href="#2-1-实践" class="headerlink" title="2.1 实践"></a>2.1 实践</h3><p>先来一个简单的案例来看看 Spring 中的国际化怎么使用。</p><p>首先我们的资源文件跟前面第一小节的一致，不再赘述。</p><p>Spring 中需要我们首先提供一个 MessageSource 实例，常用的 MessageSource 实例是 ReloadableResourceBundleMessageSource，这是一个具备自动刷新能力的 MessageSource，即，用户修改了配置文件之后，在项目不重启的情况下，新的配置就能生效。</p><p>配置方式很简答，我们只需要将这个 Bean 注册到 Spring 容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ReloadableResourceBundleMessageSource <span class="title function_">messageSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ReloadableResourceBundleMessageSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReloadableResourceBundleMessageSource</span>();</span><br><span class="line">    source.setBasenames(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Bean 在注册的时候，有一个固定要求：beanName 必须是 messageSource。为什么是这样，等松哥一会分析源码的时候大家就看明白了。为 bean 设置 basename，也就是配置文件的基础名称。</p><p>接下来我们就可以使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(JavaConfig.class);</span><br><span class="line"><span class="type">MessageSource</span> <span class="variable">source</span> <span class="operator">=</span> ctx.getBean(MessageSource.class);</span><br><span class="line"><span class="type">Locale</span> <span class="variable">localeZh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;zh&quot;</span>, <span class="string">&quot;CN&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> source.getMessage(<span class="string">&quot;hello&quot;</span>, <span class="literal">null</span>, localeZh);</span><br><span class="line">System.out.println(<span class="string">&quot;hello = &quot;</span> + hello);</span><br><span class="line">Object[] params = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;javaboy&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> source.getMessage(<span class="string">&quot;name&quot;</span>, params, localeZh);</span><br><span class="line">System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br></pre></td></tr></table></figure><p>当然，一般在应用中，我们会对获取资源文件内容的方法进行封装再用。</p><p>封装类似下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageUtils</span> <span class="keyword">implements</span> <span class="title class_">MessageSourceAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MessageSource messageSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Locale</span> <span class="variable">currentLocale</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Locale</span>(<span class="string">&quot;zh&quot;</span>,<span class="string">&quot;CN&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Locale <span class="title function_">getCurrentLocale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentLocale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentLocale</span><span class="params">(Locale currentLocale)</span> &#123;</span><br><span class="line">        MessageUtils.currentLocale = currentLocale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="literal">null</span>, key, currentLocale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key, Locale locale)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="literal">null</span>, key, locale == <span class="literal">null</span> ? currentLocale : locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key, String defaultMessage)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="literal">null</span>, defaultMessage == <span class="literal">null</span> ? key : defaultMessage, currentLocale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key, String defaultMessage, Locale locale)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, <span class="literal">null</span>, defaultMessage == <span class="literal">null</span> ? key : defaultMessage, locale == <span class="literal">null</span> ? currentLocale : locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key, Object[] placeHolders)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, placeHolders, key, currentLocale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key, Object[] placeHolders, String defaultMessage)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, placeHolders, defaultMessage == <span class="literal">null</span> ? key : defaultMessage, currentLocale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key, Object[] placeHolders, Locale locale)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, placeHolders, key, locale == <span class="literal">null</span> ? currentLocale : locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getMessage</span><span class="params">(String key, Object[] placeHolders, String defaultMessage, Locale locale)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(key, placeHolders, defaultMessage == <span class="literal">null</span> ? key : defaultMessage, locale == <span class="literal">null</span> ? currentLocale : locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageSource</span><span class="params">(MessageSource messageSource)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messageSource = messageSource;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工具类实现了 MessageSourceAware 接口，这样就可以拿到 messageSource 对象，然后将 getMessage 方法进行封装。</p><p>用法其实并不难。</p><h3 id="2-2-原理分析"><a href="#2-2-原理分析" class="headerlink" title="2.2 原理分析"></a>2.2 原理分析</h3><p>再来看原理分析。</p><p>首先，在之前的分析中，小伙伴们知道，Spring 容器在初始化的时候，都会调用到 AbstractApplicationContext#refresh 方法，这个方法内部又调用了 initMessageSource 方法，没错，这个方法就是用来初始化 MessageSource 的，我们来看下这个方法的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"><span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line"><span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource hms &amp;&amp;</span><br><span class="line">hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line"><span class="comment">// registered already.</span></span><br><span class="line">hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line"><span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line">dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line"><span class="built_in">this</span>.messageSource = dms;</span><br><span class="line">beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先判断容器中是否存在一个名为 messageSource 的 Bean（MESSAGE_SOURCE_BEAN_NAME 常量的实际值就是 messageSource），如果存在，则检查当前容器是否存在 parent，如果存在 parent 容器，那么 parent 容器可能也会有一个 messageSource 对象，就把 parent 容器的 messageSource 对象设置给当前的 messageSource 作为 parentMessageSource。如果当前容器中不存在一个名为 messageSource 的 bean，那么系统就会自动创建一个 DelegatingMessageSource 对象并注册到 Spring 容器中。</p><blockquote><p>从前面的介绍中大家就明白了为什么我们向 Spring 容器中注册 ReloadableResourceBundleMessageSource 的时候，beanName 必须是 messageSource，如果 beanName 不是 messageSource，那么 Spring 容器就会自动创建另外一个 MessageSource 对象了，这就导致最终在获取资源的时候出错。</p></blockquote><p>好啦，这是 MessageSource Bean 加载的方式。加载完成之后，这个 Bean 将来会被初始化，然后我们在需要的时候，调用这个 Bean 中的 getMessage 方法去获取资源，现在我们就去分析 getMessage 方法。</p><p>松哥这里的分析就以 ReloadableResourceBundleMessageSource 来展开，因为在整个 MessageSource 体系中，ReloadableResourceBundleMessageSource 是相对比较复杂的一个了，把这个搞懂了，剩下的几个其实都很好懂了。</p><p>这个 getMessage 方法实际上是在 ReloadableResourceBundleMessageSource 的父类 AbstractMessageSource 中，换句话说，不同类型的 MessageSource 调用的 getMessage 方法是同一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getMessage</span><span class="params">(String code, <span class="meta">@Nullable</span> Object[] args, <span class="meta">@Nullable</span> String defaultMessage, Locale locale)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> getMessageInternal(code, args, locale);</span><br><span class="line"><span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (defaultMessage == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getDefaultMessage(code);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> renderDefaultMessage(defaultMessage, args, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法分两步，首先调用 getMessageInternal 尝试去解析出来 key 对应的 value，如果没有找到合适的 value，那么就会使用默认值。</p><p>我们先来看 getMessageInternal 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">getMessageInternal</span><span class="params">(<span class="meta">@Nullable</span> String code, <span class="meta">@Nullable</span> Object[] args, <span class="meta">@Nullable</span> Locale locale)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (code == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (locale == <span class="literal">null</span>) &#123;</span><br><span class="line">locale = Locale.getDefault();</span><br><span class="line">&#125;</span><br><span class="line">Object[] argsToUse = args;</span><br><span class="line"><span class="keyword">if</span> (!isAlwaysUseMessageFormat() &amp;&amp; ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> resolveCodeWithoutArguments(code, locale);</span><br><span class="line"><span class="keyword">if</span> (message != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">argsToUse = resolveArguments(args, locale);</span><br><span class="line"><span class="type">MessageFormat</span> <span class="variable">messageFormat</span> <span class="operator">=</span> resolveCode(code, locale);</span><br><span class="line"><span class="keyword">if</span> (messageFormat != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (messageFormat) &#123;</span><br><span class="line"><span class="keyword">return</span> messageFormat.format(argsToUse);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">commonMessages</span> <span class="operator">=</span> getCommonMessages();</span><br><span class="line"><span class="keyword">if</span> (commonMessages != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">commonMessage</span> <span class="operator">=</span> commonMessages.getProperty(code);</span><br><span class="line"><span class="keyword">if</span> (commonMessage != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> formatMessage(commonMessage, args, locale);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getMessageFromParent(code, argsToUse, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的逻辑还是比较简单的，如果传入的 code 为空就直接返回 null，如果传入的 locale 为空，则获取一个默认的 locale，这个默认的 locale 是根据当前操作系统的信息获取到的一个环境。</p><p>接下来，如果不想使用 MessageFormat 并且也没有传入 MessageFormat 所需要的参数，那么就调用 resolveCodeWithoutArguments 方法去解析获取到 Message 对象。如果是需要用到 MessageFormat 对象，那么就调用 resolveCode 方法先去获取到一个 MessageFormat，然后格式化数据并返回。</p><p>如果前面两个都没能返回，那么就获取到一个公共的资源，然后尝试去解析 code，如果公共资源也还是没能解析到，那么就去 parent 中尝试解析。</p><p>这里涉及到的几个方法，我们分别来看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">resolveCodeWithoutArguments</span><span class="params">(String code, Locale locale)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (getCacheMillis() &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">PropertiesHolder</span> <span class="variable">propHolder</span> <span class="operator">=</span> getMergedProperties(locale);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> propHolder.getProperty(code);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (String basename : getBasenameSet()) &#123;</span><br><span class="line">List&lt;String&gt; filenames = calculateAllFilenames(basename, locale);</span><br><span class="line"><span class="keyword">for</span> (String filename : filenames) &#123;</span><br><span class="line"><span class="type">PropertiesHolder</span> <span class="variable">propHolder</span> <span class="operator">=</span> getProperties(filename);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> propHolder.getProperty(code);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolveCodeWithoutArguments 方法在 ReloadableResourceBundleMessageSource 类中被重写过了，所以这里我们直接看重写后的方法。</p><p>首先会去判断缓存时间是否小于 0，小于 0 表示不缓存，那么就去现场加载数据，否则就从缓存中读取数据。如果是现场加载数据的话，那么就是根据传入的 locale 对象调用 getMergedProperties 方法，获取到 PropertiesHolder 对象，这个对象中封装了读取到的资源文件以及资源文件的时间戳（通过这个时间戳可以判断资源文件是否被修改过）。</p><p>getMergedProperties 方法的源码我这里就不贴出来了，就大概和大家说一下大致的流程：首先会根据传入的 basename 和 locale 定位出文件名，会定义出来多种文件名，例如传入的 basename 是 content，locale 是 zh_CN，那么最终生成的可能文件名有五种，如下：</p><ul><li>content_zh_CN</li><li>content_zh</li><li>content_en_CN</li><li>content_en</li><li>content</li></ul><p>这五种，前两个是根据传入的参数生成的，接下来两个是根据当前系统信息生成的文件名，最后一个则是默认的文件名，接下来就会根据这五个不同的文件名尝试去加载配置文件的，加载配置文件的时候是倒着来的，就是先去查找 content.properties 文件，找到了，就把找到的数据存入到一个 Properties 中，然后继续找上一个，上一个文件要是存在，则将之也存入到 properties 配置文件中，这样，如果有重复的 key，后者就会覆盖掉前者，换言之，上面这个文件名列表中，第一个文件名的优先级是最高的，因为它里边的 key 如果跟前面的 key 重复了，会覆盖掉前面的 key。</p><p>这就是 getMergedProperties 方法的大致逻辑。最后就从这个方法的返回值中，找到我们需要的数据返回。</p><p>这是不缓存的情况，如果缓存的话，那么就去缓存中读取数据并返回。</p><p>大家看去缓存中读取数据的时候，首先也是调用 calculateAllFilenames 方法获取到所有可能的文件名（获取到的结果就是上面列出来的），然后根据文件名去获取数据，这次获取是顺序获取的，即先去查找 <code>content_zh_CN</code> 这个文件，存在的话就直接返回了，这也显示了上面的列表中，从上往下优先级依次降低。然后遍历文件名，调用 getProperties 方法获取对应的 properties 文件，这个获取的过程中，会去检查文件的时间戳，检查资源文件是否被修改过，如果被修改过就重新读取，否则就使用之前已经读取到的缓存数据。</p><p>以上就是 resolveCodeWithoutArguments 方法的大概逻辑。</p><p>resolveCode 方法的逻辑实际上和 resolveCodeWithoutArguments 类似，唯一的区别在于，resolveCodeWithoutArguments 方法中，存储数据的 Properties 实际上就是我们的资源文件，而在 resolveCode 方法中，存储数据的是一个双层 Map，外层 Map key 是 code，即传入的资源的 key，value 则是一个 Map，里边这个 Map 的 key 是 locale 对象，value 则是一个 MessageFormat 对象，查找的时候根据用户传入的 code 先找到一个 Map，然后再根据用户传入的 locale 找到 MessageFormat，然后返回。其他逻辑基本上都是一致的了。</p><h2 id="3-附录"><a href="#3-附录" class="headerlink" title="3.附录"></a>3.附录</h2><p>搜刮了一个语言简称表，分享给各位小伙伴：</p><table><thead><tr><th align="left">语言</th><th align="left">简称</th></tr></thead><tbody><tr><td align="left">简体中文(中国)</td><td align="left">zh_CN</td></tr><tr><td align="left">繁体中文(中国台湾)</td><td align="left">zh_TW</td></tr><tr><td align="left">繁体中文(中国香港)</td><td align="left">zh_HK</td></tr><tr><td align="left">英语(中国香港)</td><td align="left">en_HK</td></tr><tr><td align="left">英语(美国)</td><td align="left">en_US</td></tr><tr><td align="left">英语(英国)</td><td align="left">en_GB</td></tr><tr><td align="left">英语(全球)</td><td align="left">en_WW</td></tr><tr><td align="left">英语(加拿大)</td><td align="left">en_CA</td></tr><tr><td align="left">英语(澳大利亚)</td><td align="left">en_AU</td></tr><tr><td align="left">英语(爱尔兰)</td><td align="left">en_IE</td></tr><tr><td align="left">英语(芬兰)</td><td align="left">en_FI</td></tr><tr><td align="left">芬兰语(芬兰)</td><td align="left">fi_FI</td></tr><tr><td align="left">英语(丹麦)</td><td align="left">en_DK</td></tr><tr><td align="left">丹麦语(丹麦)</td><td align="left">da_DK</td></tr><tr><td align="left">英语(以色列)</td><td align="left">en_IL</td></tr><tr><td align="left">希伯来语(以色列)</td><td align="left">he_IL</td></tr><tr><td align="left">英语(南非)</td><td align="left">en_ZA</td></tr><tr><td align="left">英语(印度)</td><td align="left">en_IN</td></tr><tr><td align="left">英语(挪威)</td><td align="left">en_NO</td></tr><tr><td align="left">英语(新加坡)</td><td align="left">en_SG</td></tr><tr><td align="left">英语(新西兰)</td><td align="left">en_NZ</td></tr><tr><td align="left">英语(印度尼西亚)</td><td align="left">en_ID</td></tr><tr><td align="left">英语(菲律宾)</td><td align="left">en_PH</td></tr><tr><td align="left">英语(泰国)</td><td align="left">en_TH</td></tr><tr><td align="left">英语(马来西亚)</td><td align="left">en_MY</td></tr><tr><td align="left">英语(阿拉伯)</td><td align="left">en_XA</td></tr><tr><td align="left">韩文(韩国)</td><td align="left">ko_KR</td></tr><tr><td align="left">日语(日本)</td><td align="left">ja_JP</td></tr><tr><td align="left">荷兰语(荷兰)</td><td align="left">nl_NL</td></tr><tr><td align="left">荷兰语(比利时)</td><td align="left">nl_BE</td></tr><tr><td align="left">葡萄牙语(葡萄牙)</td><td align="left">pt_PT</td></tr><tr><td align="left">葡萄牙语(巴西)</td><td align="left">pt_BR</td></tr><tr><td align="left">法语(法国)</td><td align="left">fr_FR</td></tr><tr><td align="left">法语(卢森堡)</td><td align="left">fr_LU</td></tr><tr><td align="left">法语(瑞士)</td><td align="left">fr_CH</td></tr><tr><td align="left">法语(比利时)</td><td align="left">fr_BE</td></tr><tr><td align="left">法语(加拿大)</td><td align="left">fr_CA</td></tr><tr><td align="left">西班牙语(拉丁美洲)</td><td align="left">es_LA</td></tr><tr><td align="left">西班牙语(西班牙)</td><td align="left">es_ES</td></tr><tr><td align="left">西班牙语(阿根廷)</td><td align="left">es_AR</td></tr><tr><td align="left">西班牙语(美国)</td><td align="left">es_US</td></tr><tr><td align="left">西班牙语(墨西哥)</td><td align="left">es_MX</td></tr><tr><td align="left">西班牙语(哥伦比亚)</td><td align="left">es_CO</td></tr><tr><td align="left">西班牙语(波多黎各)</td><td align="left">es_PR</td></tr><tr><td align="left">德语(德国)</td><td align="left">de_DE</td></tr><tr><td align="left">德语(奥地利)</td><td align="left">de_AT</td></tr><tr><td align="left">德语(瑞士)</td><td align="left">de_CH</td></tr><tr><td align="left">俄语(俄罗斯)</td><td align="left">ru_RU</td></tr><tr><td align="left">意大利语(意大利)</td><td align="left">it_IT</td></tr><tr><td align="left">希腊语(希腊)</td><td align="left">el_GR</td></tr><tr><td align="left">挪威语(挪威)</td><td align="left">no_NO</td></tr><tr><td align="left">匈牙利语(匈牙利)</td><td align="left">hu_HU</td></tr><tr><td align="left">土耳其语(土耳其)</td><td align="left">tr_TR</td></tr><tr><td align="left">捷克语(捷克共和国)</td><td align="left">cs_CZ</td></tr><tr><td align="left">斯洛文尼亚语</td><td align="left">sl_SL</td></tr><tr><td align="left">波兰语(波兰)</td><td align="left">pl_PL</td></tr><tr><td align="left">瑞典语(瑞典)</td><td align="left">sv_SE</td></tr><tr><td align="left">西班牙语(智利)</td><td align="left">es_CL</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;国际化（Internationalization，简称 I18N）是指在 Java 应用程序中实现国际化的技术和方法。Java 提供了一套强大的国际化支持，使开发人员能够编写适应不同语言、地区和文化的应用程序。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>答读者问：关于隐式 id 重复的问题</title>
    <link href="http://www.javaboy.org/2023/1114/spring-bean-id.html"/>
    <id>http://www.javaboy.org/2023/1114/spring-bean-id.html</id>
    <published>2023-11-14T10:54:11.000Z</published>
    <updated>2024-05-10T11:12:32.125Z</updated>
    
    <content type="html"><![CDATA[<p>我自己天天跟大伙讲 Spring 源码，我基本都是分析源码来讲。小伙伴们学习了之后，经常会产生许多千奇百怪的想法，这些想法都很不错，往往这些想法还给了我很大的启发，让我发现原来这个问题还可以从这个角度来理解。</p><span id="more"></span><p>今天我们来看一个小伙伴的提问：</p><p><img src="http://img.itboyhub.com/2022/08/20231104104706.png"><br><img src="http://img.itboyhub.com/2022/08/20231104104731.png"></p><blockquote><p>首先我得先夸一句，这个问题真的非常好！问题非常详细，有源码有截图有版本号，该说的都说了，问题非常清晰，我一看就知道发生了什么事情，每天在微信上问松哥问题的人不少，能把问题说的这么清楚的人屈指可数。</p></blockquote><p>我跟大家讲一下这个问题的上下文：</p><p>Spring 中 beanName 是不能重复的，一般情况下，我们在定义 Bean 的时候，都要为其指定 beanName 属性，如果不指定，则会默认生成 beanName。在 XML 配置中，如果我们不指定 beanName 或者 id，那么默认生成的 beanName 就是类名的完整路径或者是 <code>类名完整路径+#+编号</code>。这个小伙伴就是在学习了上述内容之后，提出来这个问题。</p><p>关于 beanName 自动生成逻辑松哥在视频中都已经详细介绍过了，因此这里就简单和大家梳理一下思路，具体可以参考 Spring 源码视频。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>小伙伴一共提出两个问题，我们分别来看。</p><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>首先定义了一个 User 对象，但是并未指定 beanName，按照松哥之前在 Spring 源码视频中所讲的，此时会自动给这个 bean 生成 id 和别名，别名是类名的完整路径，即 <code>cn.junhaox.entity.User</code>，id 则是类名完整路径+编号，即 <code>cn.junhaox.entity.User#0</code>，即我们可以通过这两个任意一个名称来访问到第一个对象。</p><p>第二个 bean 在定义的时候，则指定了 id，而且指定的 id 恰好就是第一个 bean 自动生成的 id。</p><p>这个逻辑上显然是冲突了，导致最终访问的时候，通过 <code>cn.junhaox.entity.User#0</code> 或者 <code>cn.junhaox.entity.User</code> 访问到的是第二个 bean 而不是第一个 bean，这就给人一种第一个 bean 似乎注册失败了的感觉。</p><p>我们先来分析一下这个问题。</p><p>先来说 bean 的注册，当 bean 在注册的时候，首先会去检查当前 beanName 是否重复（具体在 org.springframework.beans.factory.xml.BeanDefinitionParserDelegate#parseBeanDefinitionElement(org.w3c.dom.Element, org.springframework.beans.factory.config.BeanDefinition) 方法中），但是这个检查主要是检查我们自己手动配置的 beanName 是否存在重复的情况，并不会去检查自动生成的 beanName 是否重复，这就导致了当第二个 bean 在注册的时候，检查 beanName 是否重复的时候，结果发现 beanName 并不重复，因此就导致了 <code>cn.junhaox.entity.User#0</code> beanName 重新指向了第二个 bean，那毫无疑问，<code>cn.junhaox.entity.User</code> 作为别名，也重新指向了第二个 bean。</p><p>这就是第一个问题产生的原因。</p><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>根据前面的分析，小伙伴们已经知道，对于第一个 bean，由于即没有配置 id，又没有配置 beanName，所以第一个 bean 在注册的时候，会自动生成 id <code>cn.junhaox.entity.User#0</code> 并且会自动生成 beanName <code>cn.junhaox.entity.User</code>。</p><p>现在第二个问题就是把第一个 bean 的别名作为第二个 bean 的 id 了，导致第二个 bean 似乎访问不到了。</p><p>松哥先来说结论，这个问题其实目前在最新版的 Spring 中已经不存在了，具体的处理是在 2022 年 2 月 5 号提交的代码中解决了问题，在当年 3 月份发布的 v6.0.0-M3 版本中这块的代码改过来了，我们来看下代码的变化大家就明白了：</p><p><img src="http://img.itboyhub.com/2022/08/20231107202633.png"></p><p>大家可以看到，变化发生在 DefaultListableBeanFactory#registerBeanDefinition 方法中，绿色的代码块就是新增的代码。</p><p>新增的代码主要是当我们向容器注册一个 BeanDefinition 的时候，首先会去检查这个 beanName 是否是一个别名，如果是，则检查别名是否允许覆盖，如果别名不允许覆盖，那么该抛异常就抛异常，如果别名允许覆盖，则调用 removeAlias 方法移除别名，这个移除相当于剪掉了别名之间的关系，<code>cn.junhaox.entity.User</code> 将不再作为别名指向 <code>cn.junhaox.entity.User#0</code> 了。</p><p>因此，对于第二个问题，从 Spring6.0.0-M3 开始，通过 <code>cn.junhaox.entity.User#0</code> 可以访问到第一个 bean，通过 <code>cn.junhaox.entity.User</code> 则可以访问到第二个 bean。</p><p>但是，在此版本之前，并未检查当前 beanName 是否是一个别名，而是直接使用该 beanName 进行注册。当我们去查询 bean 的时候，都是根据 beanName 去查找 bean 的，如果是根据类型，最终也会先根据类型找出 beanName，然后再去查找 bean。根据 beanName 去搜索 bean 的时候，会先根据别名链条确定出最终的 beanName，由于 <code>cn.junhaox.entity.User</code> 和 <code>cn.junhaox.entity.User#0</code> 之间还存在别名关系，因此当我们按照 beanName <code>cn.junhaox.entity.User</code> 去搜索 bean 的时候，系统会找到这是 <code>cn.junhaox.entity.User#0</code> 的别名，进而找出来 <code>cn.junhaox.entity.User#0</code> 所对应的 bean 并返回，这就导致第二个 bean 将来无法被查找到。</p><p>好啦，现在这两个问题都搞明白了吧～</p><p>以上内容松哥主要是和大家分享思路，技术细节包括涉及到的 Spring 源码细节在之前的 Spring 视频中都讲过，大家可以参考视频。</p><p>欢迎大家继续提问！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我自己天天跟大伙讲 Spring 源码，我基本都是分析源码来讲。小伙伴们学习了之后，经常会产生许多千奇百怪的想法，这些想法都很不错，往往这些想法还给了我很大的启发，让我发现原来这个问题还可以从这个角度来理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>答读者问：BeanFactoryPostProcessor 似乎失效了？</title>
    <link href="http://www.javaboy.org/2023/1106/spring-bean-factory-post-processor.html"/>
    <id>http://www.javaboy.org/2023/1106/spring-bean-factory-post-processor.html</id>
    <published>2023-11-06T10:02:33.000Z</published>
    <updated>2024-05-10T10:41:02.274Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴在学习 Spring 源码视频的时候，看了松哥讲的 BeanFactoryPostProcessor 的用法之后，提出了这样一个问题：</p><span id="more"></span><p><img src="http://img.itboyhub.com/2022/08/20231104083254.png"><br><img src="http://img.itboyhub.com/2022/08/20231104083321.png"></p><p>我来跟大家补充一下这个问题的上下文：</p><p>我讲了 BeanFactoryPostProcessor，分析了其原理，也讲了具体的使用场景，一个典型的使用场景是我们在 XML 中定义 Bean 的时候，如果 Bean 的属性是使用了 properties 文件占位符如 <code>$&#123;db.username&#125;</code> 这种，那么在 BeanFactoryPostProcessor 阶段，就会对这个占位符进行处理，将其替换成真正的 value。然后我还顺手给大家举了一个例子，我在 XML 文件中定义 Bean 的时候，给 Bean 的某一个属性设置 value 为 ^username，然后在 BeanFactoryPostProcessor 中，我将 ^username 改为某一个字符串。</p><p>小伙伴看了松哥讲的内容之后，也照着写了一个，就是上面图片中的代码，不同的是，他是将 XML 配置改为了 Java 代码配置，结果发现属性 <code>hok</code> 并未变为 <code>NB</code>，因此有了上述问题。</p><p>我觉得这个问题问的很好，给了小伙伴们一个从其他方面理解 Spring 的机会，这也是我前面一直强调的，这次的 Spring 视频需要各位小伙伴一起发力，大家有关于 Spring 的任何问题都可以提，我负责通过源码来回答你。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这个问题的分析，得先从 BeanDefinition 开始。在讲 BeanFactoryPostProcessor 之前，松哥已经和小伙伴们分析过 BeanDefinition 了，无论我们是通过 Java 代码还是通过 XML 文件定义的 Bean 对象，在解析称为 Bean 对象之前，得先解析成为 BeanDefinition，BeanDefinition 则有不同的分类，对于 XML 文件定义的 Bean，最终解析为 GenericBeanDefinition，而通过 @Bean 注解定义的 Bean 则解析为 ConfigurationClassBeanDefinition。</p><p>但是这两个的处理原理显然是有差异的。</p><p>对于 XML 定义的 Bean 来说，很明显 XML 中的所有属性都要先解析到 BeanDefinition 中，包括我们在 XML 中配置的 Bean 的各种属性，这一步是在 Spring 容器 refresh 方法中构建 BeanFactory 的时候完成的（obtainFreshBeanFactory 方法），这一步完成之后，在后面的步骤会去执行容器中所有的 BeanFactoryPostProcessor（invokeBeanFactoryPostProcessors），此时就会把前面解析出来的 BeanDefinition 中带有占位符的属性给替换过来，最后在 refresh 方法中执行 finishBeanFactoryInitialization 方法完成 Bean 的初始化。</p><p>按照上面这一套流程顺序，占位符被解析成为正常字符串没什么问题。</p><p>但是，如果是 @Bean 注解配置的 Bean，则会有所差异。</p><p>首先，@Bean 注解所标记的方法要被解析为一个 ConfigurationClassBeanDefinition，这个过程本身是通过 ConfigurationClassPostProcessor 来完成的，而 ConfigurationClassPostProcessor 本质上其实就是一个 BeanFactoryPostProcessor，换言之，@Bean 注解标记的方法是在 BeanFactoryPostProcessor 中被解析为 ConfigurationClassBeanDefinition 的。ConfigurationClassBeanDefinition 这个 BeanDefinition 主要用来记录 @Bean 注解所标记的方法所属的对象、方法的名称、方法对象、方法参数、注解的参数等等信息，把这些信息记录下来，将来在初始化 Bean 的时候，通过反射执行目标方法就可以了，即方法里边的内容是什么，ConfigurationClassBeanDefinition 其实并不关心。</p><p>最后则是和 XML 一样，在 finishBeanFactoryInitialization 方法中完成 Bean 的初始化。</p><p>经过上面分析，小伙伴们可以看到，通过 @Bean 注解定义的 Bean，我们为属性赋值是在方法内部完成的，这些方法内部的逻辑其实并未被解析到 BeanDefinition 中，显然也没有必要把方法内部的逻辑解析到 BeanDefinition 上去，因此，通过 @Bean 注解定义的 Bean，如果属性中使用了占位符，是无法通过 BeanFactoryPostProcessor 自动解析的。</p><p>好啦，现在小伙伴提出的问题大家伙都明白了吧？</p><blockquote><p>以上的分析中，方法的具体逻辑在 Spring 源码中都有详细讲解，<strong>所以这里我只是和大家梳理了思路</strong>，具体实现小伙伴可以参考我们的源码视频。</p></blockquote><p>欢迎各位小伙伴在学习过程中继续提出高质量问题，一起把这套 Spring 源码教程做扎实了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有小伙伴在学习 Spring 源码视频的时候，看了松哥讲的 BeanFactoryPostProcessor 的用法之后，提出了这样一个问题：&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何让 Bean 深度感知 Spring 容器</title>
    <link href="http://www.javaboy.org/2023/1103/spring-container.html"/>
    <id>http://www.javaboy.org/2023/1103/spring-container.html</id>
    <published>2023-11-03T10:02:08.000Z</published>
    <updated>2024-05-10T10:40:52.088Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 有一个特点，就是创建出来的 Bean 对容器是无感的，一个 Bean 是怎么样被容器从一个 Class 整成一个 Bean 的，对于 Bean 本身来说是不知道的，当然也不需要知道，也就是 Bean 对容器的存在是无感的。</p><span id="more"></span><p>但是有时候我们可能会遇到一些场景，这些场景让我们去感知容器的存在，松哥举几个例子：</p><ol><li>Spring 容器提供的功能不止 IoC、AOP 这些，常见的 I18N 也是 Spring 的能力之一，如果我们想要在自己的 Bean 中去使用 I18N，那就得去找 Spring，这样就感知到了 Spring 容器的存在了。</li><li>Spring 提供了资源加载器，如果我们想要使用这个资源加载器去加载配置，那就得去找 Spring 要，这样就感知到了 Spring 容器的存在了。</li><li>想根据 beanName 去 Spring 容器中查找 Bean，那不用多说，肯定得知道 Spring 容器的存在。</li><li>…</li></ol><p>也就是说，虽然 Spring 中的 Bean 可以不用去感知 Spring 容器的存在，但是在实际开发中，我们往往还是需要 Spring 容器提供的各种能力，这样就迫使我们的 Bean 不得不去感知到 Spring 容器的存在。</p><p>那么 Spring 中的 Bean 如何感知到 Spring 容器的存在呢？</p><h2 id="1-Aware"><a href="#1-Aware" class="headerlink" title="1. Aware"></a>1. Aware</h2><p>Aware 本身就有感知的意思。</p><p>Spring Aware 是 Spring 框架中的一个特性，它允许我们的应用程序或组件与 Spring 容器进行交互。当一个类实现了 Spring Aware 接口并注册到 Spring 容器中时，该类就能够感知到 Spring 容器的存在，并且可以获取容器的一些资源或进行一些特定的操作。</p><p>Spring Aware 接口包括了多个子接口，每个子接口对应于不同的 Spring 容器资源或功能。</p><p>Aware 的实现有很多，大的方向来说主要有如下一些：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220622075948.png"></p><p>每一个 Aware 的作用如下：</p><ul><li>ApplicationEventPublisherAware：实现该接口的对象可以获取事件发布的能力。</li><li>ServletContextAware：实现该接口的对象可以获取到 ServletContext 对象。</li><li>MessageSourceAware：实现该接口的对象可以获取到 MessageSource 对象，MessageSource 支持多消息源，主要用于主要用于国际化。</li><li>ResourceLoaderAware：实现该接口的对象可以获取到一个 ResourceLoader，Spring ResourceLoader 则为我们提供了一个统一的 getResource() 方法来通过资源路径检索外部资源，例如文本文件、XML 文件、属性文件或图像文件等。</li><li>ApplicationStartupAware：实现该接口的对象可以获取到一个 ApplicationStartup 对象，这个比较新，是 Spring 5.3 中新推出的，通过 ApplicationStartup 可以标记应用程序启动期间的步骤，并收集有关执行上下文或其处理时间的数据。</li><li>NotificationPublisherAware：实现该接的对象可以获取到一个 NotificationPublisher 对象，通过该对象可以实现通知的发送。</li><li>EnvironmentAware：实现该接口的对象可以获取到一个 Environment 对象，通过 Environment 可以获取到容器的环境信息。</li><li>BeanFactoryAware：实现该接口的对象可以获取到一个 BeanFactory 对象，通过 BeanFactory 可以完成 Bean 的查询等操作。</li><li>ImportAware：实现该接口的对象可以获取到一个 AnnotationMetadata 对象，ImportAware 接口是需要和 @Import 注解一起使用的。在 @Import 作为元注解使用时，通过 @Import 导入的配置类如果实现了 ImportAware 接口就可以获取到导入该配置类接口的数据配置。</li><li>EmbeddedValueResolverAware：实现该接口的对象可以获取到一个 StringValueResolver 对象，通过 StringValueResolver 对象，可以读取到 Spring 容器中的 properties 配置的值（YAML 配置也可以）。</li><li>ServletConfigAware：实现该接口的对象可以获取到一个 ServletConfig 对象，不过这个似乎没什么用，我们很少自己去配置 ServletConfig。</li><li>LoadTimeWeaverAware：实现该接口的对象可以获取到一个 LoadTimeWeaver 对象，通过该对象可以获取加载 Spring Bean 时织入的第三方模块，如 AspectJ 等。</li><li>BeanClassLoaderAware：实现该接口的对象可以获取到一个 ClassLoader 对象，ClassLoader 能干嘛不需要我多说了吧。</li><li>BeanNameAware：实现该接口的对象可以获取到一个当前 Bean 的名称。</li><li>ApplicationContextAware：实现该接口的对象可以获取到一个 ApplicationContext 对象，通过 ApplicationContext 可以获取容器中的 Bean、环境等信息。</li></ul><p>通过实现这些接口，我们可以在应用程序中获取 Spring 容器提供的各种资源，并与容器进行交互，以实现更灵活和可扩展的功能。</p><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p>举两个例子小伙伴们来感受下 Aware 的具体用法。</p><h3 id="2-1-案例"><a href="#2-1-案例" class="headerlink" title="2.1 案例"></a>2.1 案例</h3><p>例如我想在 Bean 中感知到当前 Bean 的名字，那么我们可以按照如下方式来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UserService&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;beanName=&#x27;&quot;</span> + beanName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让当前 bean 实现 BeanNameAware 接口，并重写 setBeanName 方法，这个方法会在 Spring 容器初始化 Bean 的时候自动被调用，我们就可以据此获取到 bean 的名称了。</p><p>再比如我想做一个工具 Bean，用来查找其他 Bean，那么我可以使用如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanUtils</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BeanFactory beanFactory;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) beanFactory.getBean(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让当前 Bean 实现 BeanFactoryAware 接口并重写 setBeanFactory 方法，在系统初始化当前 Bean 的时候，会自动调用 setBeanFactory 方法，进而将 beanFactory 变量传进来。</p><h3 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h3><p>当 Spring 容器创建一个 Bean 的时候，大致的流程是<code>创建实例对象</code> -&gt; <code>属性填充</code> -&gt; <code>Bean 初始化</code>。</p><p>最后这个 Bean 的初始化，就是调用 init 方法、afterPropertiesSet 方法以及 BeanPostProcessor 中的方法的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">(mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>), beanName, ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法一进来，首先有一个 invokeAwareMethods，这个就是用来触发 Aware 的，来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareMethods</span><span class="params">(String beanName, Object bean)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware beanNameAware) &#123;</span><br><span class="line">beanNameAware.setBeanName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware beanClassLoaderAware) &#123;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">bcl</span> <span class="operator">=</span> getBeanClassLoader();</span><br><span class="line"><span class="keyword">if</span> (bcl != <span class="literal">null</span>) &#123;</span><br><span class="line">beanClassLoaderAware.setBeanClassLoader(bcl);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware beanFactoryAware) &#123;</span><br><span class="line">beanFactoryAware.setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们可以看到，BeanNameAware、BeanClassLoaderAware 以及 BeanFactoryAware 这三种类型的 Aware 是在这里触发的。</p><p>每种 Aware 因为功能不同，因此作用的时机也不同。</p><p>invokeAwareMethods 方法执行完毕之后，接下来是执行 applyBeanPostProcessorsBeforeInitialization 方法，这个我们之前分析过，这个方法最终会触发 BeanPostProcessor#postProcessBeforeInitialization 方法的执行，而 BeanPostProcessor 有一个子类专门处理 Aware 的，就是 ApplicationContextAwareProcessor：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (!(bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware ||</span><br><span class="line">bean <span class="keyword">instanceof</span> ApplicationStartupAware)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">invokeAwareInterfaces(bean);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareInterfaces</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware environmentAware) &#123;</span><br><span class="line">environmentAware.setEnvironment(<span class="built_in">this</span>.applicationContext.getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware embeddedValueResolverAware) &#123;</span><br><span class="line">embeddedValueResolverAware.setEmbeddedValueResolver(<span class="built_in">this</span>.embeddedValueResolver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware resourceLoaderAware) &#123;</span><br><span class="line">resourceLoaderAware.setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware applicationEventPublisherAware) &#123;</span><br><span class="line">applicationEventPublisherAware.setApplicationEventPublisher(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware messageSourceAware) &#123;</span><br><span class="line">messageSourceAware.setMessageSource(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationStartupAware applicationStartupAware) &#123;</span><br><span class="line">applicationStartupAware.setApplicationStartup(<span class="built_in">this</span>.applicationContext.getApplicationStartup());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware applicationContextAware) &#123;</span><br><span class="line">applicationContextAware.setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看下，这七种类型的 Aware 是在这里被触发的。</p><p>另外像 ImportAware 是在 ImportAwareBeanPostProcessor#postProcessBeforeInitialization 方法中处理的；LoadTimeWeaverAware 是在 、LoadTimeWeaverAwareProcessor#postProcessBeforeInitialization 方法中处理的。</p><p>基本上，大部分的 Aware 接口都是在 BeanPostProcessor 中处理的。</p><p>好啦，现在小伙伴们理解 Aware 了吧～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring 有一个特点，就是创建出来的 Bean 对容器是无感的，一个 Bean 是怎么样被容器从一个 Class 整成一个 Bean 的，对于 Bean 本身来说是不知道的，当然也不需要知道，也就是 Bean 对容器的存在是无感的。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如果你正在纠结毕设，不妨看看这个！</title>
    <link href="http://www.javaboy.org/2023/1031/tienchin-video.html"/>
    <id>http://www.javaboy.org/2023/1031/tienchin-video.html</id>
    <published>2023-10-31T10:01:50.000Z</published>
    <updated>2024-05-10T10:41:05.349Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我得先声明一点，松哥教大家的是技术，面向企业开发的技术。这套技术用来应付毕设绰绰有余，掌握了技术，就可以自己去实现各种各样不同需求的毕设了。</strong></p><span id="more"></span><p><img src="http://img.itboyhub.com/2022/08/20231030194213.png"></p><p>又到了一年毕设选题的季节了，最近有不少小伙伴加松哥微信，想要 vhr 的完整代码，但是我对 vhr 的定位是一个脚手架，大家可以在 vhr 这个脚手架上自己去填充业务，对于一般的毕设项目来说，这个应该也是够用了。</p><p>毕竟毕设不可能所有人都做一模一样的东西，不同的系统，业务有差别，但是技术点基本上不会有大的差别，站在技术角度来看，不管你做什么样的系统，最终使用的技术栈其实都差不多。</p><p>当然，这并不是我今天要说的，我要说的是松哥的另外一个项目 TienChin。</p><p>vhr 是一个脚手架，而 TienChin 则是一个业务完成度超 90% 的项目，而且 TienChin 中除了常规的 Spring Boot、Vue3、MyBatisPlus、Flowable、Redis 等，还跟小伙伴们详细介绍了分布式事务解决方案、详细介绍了工作流解决方案（低代码平台常见方案）、多数据源方案等都作了详细介绍，相比于 vhr，TienChin 业务完成度更高，技术栈也更加丰富，可扩展性也更强。</p><blockquote><p>要提醒大家的是，vhr 只需要有 SSM+js 基础就可以学习，而 TienChin 需要有 Spring Boot+Vue 基础才可以学习。如果不懂 Spring Boot 和 Vue，那么看 TienChin 可能会有些吃力，对于这种情况，建议先通过 vhr 掌握 Spring Boot 和 Vue 的用法。</p></blockquote><p>其他的我就不多说了，无论你是找工作还是做毕设，都不妨看看 TienChin，相信对你一定会有启发：</p><ul><li><a href="https://mp.weixin.qq.com/s/WsSILBSUq7HROur105Hicg">TienChin 项目介绍</a></li><li><a href="https://mp.weixin.qq.com/s/3oeSrcrOhKPsCmmU8PvHzQ">TienChin 试看视频</a></li><li><a href="https://mp.weixin.qq.com/s/LAfLrEFw6lhVjcBp0EFKMA">TienChin 视频目录</a></li></ul><p>如果还有不清楚的地方，欢迎添加松哥咨询，备注 TienChin：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20220731113838.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;我得先声明一点，松哥教大家的是技术，面向企业开发的技术。这套技术用来应付毕设绰绰有余，掌握了技术，就可以自己去实现各种各样不同需求的毕设了。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="TienChin" scheme="http://www.javaboy.org/categories/TienChin/"/>
    
    
    <category term="TienChin" scheme="http://www.javaboy.org/tags/TienChin/"/>
    
  </entry>
  
  <entry>
    <title>Spring 冷知识：一个提前 AOP 的机会</title>
    <link href="http://www.javaboy.org/2023/1030/spring-early-aop.html"/>
    <id>http://www.javaboy.org/2023/1030/spring-early-aop.html</id>
    <published>2023-10-30T10:01:19.000Z</published>
    <updated>2024-05-10T10:40:48.670Z</updated>
    
    <content type="html"><![CDATA[<p>今天再来聊一个 Spring 中的冷门知识：Bean 的处理不走正常流程，而是提前进行 AOP。</p><span id="more"></span><p>本文算是前面文章（<a href="https://mp.weixin.qq.com/s/5111ksSFh6LuCr-8QmXoeg">Spring Bean 名称暗藏玄机，这样取名就不会被代理</a>）内容的一个补充，如果还没阅读前文，建议先阅读，这样有利于更好的理解本文。</p><h2 id="1-Bean-创建流程"><a href="#1-Bean-创建流程" class="headerlink" title="1. Bean 创建流程"></a>1. Bean 创建流程</h2><p><a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw">前面文章</a>中，松哥和大家梳理了，在 Bean 创建的过程中，会先给 BeanPostProcessor 一个返回代理对象的机会：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"><span class="comment">//省略。。。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看，这里的 resolveBeforeInstantiation 方法就是给 BeanPostProcessor 一个返回代理对象的机会，在这个方法中，最终就会触发到 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation 方法，而在 postProcessBeforeInstantiation 方法中，会先判断当前 bean 是否是 AOP 相关类等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面 if 分支中的内容，松哥在<a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw">前面的文章</a>中已经和大家分析过了，这里就不再赘述。</p><p>这里主要来说说 getCustomTargetSource 中的逻辑。</p><p>先来说什么情况下会走到 getCustomTargetSource 方法：当前 Bean 不是代理对象，也不是 AOP 相关的类，就是一个普普通通的常规类，那么就会走到 getCustomTargetSource 方法这里来，这里失去查找到一个 TargetSource 对象，然后根据该对象创建当前 bean 的代理对象并返回，如果返回了代理对象，那么后续的 bean 创建流程就不执行了。</p><p>我们来看下这个方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TargetSource <span class="title function_">getCustomTargetSource</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="comment">// We can&#x27;t create fancy target sources for directly registered singletons.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.customTargetSourceCreators != <span class="literal">null</span> &amp;&amp;</span><br><span class="line"><span class="built_in">this</span>.beanFactory != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.beanFactory.containsBean(beanName)) &#123;</span><br><span class="line"><span class="keyword">for</span> (TargetSourceCreator tsc : <span class="built_in">this</span>.customTargetSourceCreators) &#123;</span><br><span class="line"><span class="type">TargetSource</span> <span class="variable">ts</span> <span class="operator">=</span> tsc.getTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ts != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No custom TargetSource found.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就是当前类 AbstractAutoProxyCreator 中有一个 customTargetSourceCreators 变量，现在就是遍历该变量，通过这个集合中保存的 TargetSourceCreator 来创建 TargetSource 对象。</p><p>TargetSourceCreator 是一个接口，这个接口只有一个抽象类 AbstractBeanFactoryBasedTargetSourceCreator，我们来看下 AbstractBeanFactoryBasedTargetSourceCreator 中的 getTargetSource 方法是怎么执行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TargetSource <span class="title function_">getTargetSource</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="type">AbstractBeanFactoryBasedTargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span></span><br><span class="line">createBeanFactoryBasedTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">internalBeanFactory</span> <span class="operator">=</span> getInternalBeanFactoryForBean(beanName);</span><br><span class="line"><span class="comment">// We need to override just this bean definition, as it may reference other beans</span></span><br><span class="line"><span class="comment">// and we&#x27;re happy to take the parent&#x27;s definition for those.</span></span><br><span class="line"><span class="comment">// Always use prototype scope if demanded.</span></span><br><span class="line"><span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getConfigurableBeanFactory().getMergedBeanDefinition(beanName);</span><br><span class="line"><span class="type">GenericBeanDefinition</span> <span class="variable">bdCopy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>(bd);</span><br><span class="line"><span class="keyword">if</span> (isPrototypeBased()) &#123;</span><br><span class="line">bdCopy.setScope(BeanDefinition.SCOPE_PROTOTYPE);</span><br><span class="line">&#125;</span><br><span class="line">internalBeanFactory.registerBeanDefinition(beanName, bdCopy);</span><br><span class="line"><span class="comment">// Complete configuring the PrototypeTargetSource.</span></span><br><span class="line">targetSource.setTargetBeanName(beanName);</span><br><span class="line">targetSource.setBeanFactory(internalBeanFactory);</span><br><span class="line"><span class="keyword">return</span> targetSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，TargetSource 对象是通过 createBeanFactoryBasedTargetSource 方法来创建的，这个方法是一个抽象方法，将来在子类中被实现。</p><p>接下来会调用 getInternalBeanFactoryForBean 方法创建一个新的内部容器 internalBeanFactory，本质上这个 internalBeanFactory 其实是一个子容器，现有的容器将作为这个子容器的父容器。</p><p>接下来就是获取到当前 beanName 所对应的 BeanDefinition，然后进行属性配置，并注册到内部容器中，最后返回 targetSource 对象。</p><p>我们来看下这里的 getInternalBeanFactoryForBean 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title function_">getInternalBeanFactoryForBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.internalBeanFactories) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.internalBeanFactories.computeIfAbsent(beanName,</span><br><span class="line">name -&gt; buildInternalBeanFactory(getConfigurableBeanFactory()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title function_">buildInternalBeanFactory</span><span class="params">(ConfigurableBeanFactory containingFactory)</span> &#123;</span><br><span class="line"><span class="comment">// Set parent so that references (up container hierarchies) are correctly resolved.</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">internalBeanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>(containingFactory);</span><br><span class="line"><span class="comment">// Required so that all BeanPostProcessors, Scopes, etc become available.</span></span><br><span class="line">internalBeanFactory.copyConfigurationFrom(containingFactory);</span><br><span class="line"><span class="comment">// Filter out BeanPostProcessors that are part of the AOP infrastructure,</span></span><br><span class="line"><span class="comment">// since those are only meant to apply to beans defined in the original factory.</span></span><br><span class="line">internalBeanFactory.getBeanPostProcessors().removeIf(beanPostProcessor -&gt;</span><br><span class="line">beanPostProcessor <span class="keyword">instanceof</span> AopInfrastructureBean);</span><br><span class="line"><span class="keyword">return</span> internalBeanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个其实就是正常的容器创建，倒也没啥好说的，但是有几个需要注意的点：</p><ol><li>在调用 buildInternalBeanFactory 方法构建容器的时候，会先调用 getConfigurableBeanFactory 方法获取到当前容器作为父容器，如果当前容器不存在，那么就会抛出异常。这就意味着，当我们自己提供 TargetSourceCreator 实例的时候，一定要指定一个容器。</li><li>在创建了内部容器之后，会从内部容器中移除所有 AopInfrastructureBean 类型的 BeanPostProcessor，也就是内部容器将来创建出来的 bean，不再走 AopInfrastructureBean 类型后置处理器，因为这种类型的后置处理器主要是用来处理 AOP 的，现在，AOP 代理当场就生成了，就不再需要这些后置处理器了。</li></ol><p>好了，这就是大致的 AOP 提前生成原理，接下来松哥写一个案例我们一起来看下。</p><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><p>首先，我们先来自定义一个 TargetSource：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTargetSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryBasedTargetSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getTarget</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> getBeanFactory().getBean(getTargetBeanName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 TargetSource 本身，松哥在之前的 Spring 源码视频中已经和大家介绍过很多了，这里我就不再啰嗦了。</p><p>接下来自定义 TargetSourceCreator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomTargetSourceCreator</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryBasedTargetSourceCreator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AbstractBeanFactoryBasedTargetSource <span class="title function_">createBeanFactoryBasedTargetSource</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getBeanFactory() <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanClass.isAssignableFrom(UserService.class)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserServiceTargetSource</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要创建的 bean 是 UserService 的话，那么就给返回一个 UserServiceTargetSource 对象。</p><p>最后，也是最关键的一步，根据前面的分析，TargetSourceCreator 是存在于 AnnotationAwareAspectJAutoProxyCreator 这样一个 InstantiationAwareBeanPostProcessor 类型的后置处理器中的，因此，我们要想办法把自定义的 TargetSourceCreator 设置给 AnnotationAwareAspectJAutoProxyCreator，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetCustomTargetSourceCreator</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, PriorityOrdered, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> AnnotationAwareAspectJAutoProxyCreator) &#123;</span><br><span class="line">            <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">annotationAwareAspectJAutoProxyCreator</span> <span class="operator">=</span> (AnnotationAwareAspectJAutoProxyCreator)bean;</span><br><span class="line">            <span class="type">CustomTargetSourceCreator</span> <span class="variable">customTargetSourceCreator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomTargetSourceCreator</span>();</span><br><span class="line">            customTargetSourceCreator.setBeanFactory(beanFactory);</span><br><span class="line">            annotationAwareAspectJAutoProxyCreator.setCustomTargetSourceCreators(customTargetSourceCreator);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnnotationAwareAspectJAutoProxyCreator 本身就是一个 BeanPostProcessor，我们现在要做的就是修改这个 BeanPostProcessor，BeanPostProcessor 是在 Spring 容器启动时候的 refresh 方法中去初始化的，整个的初始化过程松哥在之前的<a href="https://mp.weixin.qq.com/s/ULpQBRGCqmtXapR3PGYBCA">BeanPostProcessor 是在何时介入 Bean 创建的？</a>一文中已经详细介绍过了。</p><p>BeanPostProcessor 初始化的时候，先初始化实现了 PriorityOrdered 接口的，再初始化实现了 Ordered 接口的，最后再去初始化那些没有实现任何排序接口的 BeanPostProcessor。</p><p>而我们这里 SetCustomTargetSourceCreator 一定要赶在 AnnotationAwareAspectJAutoProxyCreator 之前进行初始化，这样，当 AnnotationAwareAspectJAutoProxyCreator 进行初始化的时候，就会用到 SetCustomTargetSourceCreator 这样一个后置处理器，进而在该处理器中修改 AnnotationAwareAspectJAutoProxyCreator 的属性。</p><p>AnnotationAwareAspectJAutoProxyCreator 类间接实现了 Ordered 接口，默认优先级是最低，但是在 Spring 容器启动时，在处理 BeanFactoryPostProcessor 时（具体是 ConfigurationClassPostProcessor），将其优先级设置为最高。</p><p>所以，我们如果想要让自定义的 SetCustomTargetSourceCreator 抢在 AnnotationAwareAspectJAutoProxyCreator 之前执行，那么就只能让 SetCustomTargetSourceCreator 去实现 PriorityOrdered 接口了，实现 PriorityOrdered 接口之后，重写 getOrder 方法，这个方法返回值是什么无所谓，反正都会在实现了 Ordered 接口的 BeanPostProcessor 之前执行。</p><p>最后，我们再在启动类上开启自动代理即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成。</p><p>这样，当 Spring 容器创建一个 Bean 的时候，就会提前被 BeanPostProcessor 拦截，然后给出一个 TargetSource，进而据此创建代理对象，这样就不需要后续常规的 Bean 创建流程了。好啦，感兴趣的小伙伴可以自己去试一试哦～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天再来聊一个 Spring 中的冷门知识：Bean 的处理不走正常流程，而是提前进行 AOP。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>一个不太好用的 IDEA 代码生成插件</title>
    <link href="http://www.javaboy.org/2023/1026/idea-plugin.html"/>
    <id>http://www.javaboy.org/2023/1026/idea-plugin.html</id>
    <published>2023-10-26T10:01:05.000Z</published>
    <updated>2024-05-10T10:40:55.274Z</updated>
    
    <content type="html"><![CDATA[<p>之前松哥跟小伙伴们推荐了一个基于 ChatGPT-4 的 IDEA 智能助手，小伙伴们可以参考：</p><span id="more"></span><ul><li><a href="https://mp.weixin.qq.com/s/ZOsOa1arNo0WbQDQOrcEFg">手把手教大家玩一款基于 ChatGPT-4 的 IDEA 智能助手</a></li></ul><p>今天我们再给小伙伴们介绍另外一个免费的代码辅助插件 AWS Toolkit。从名字上可以看出来，这是一个方便大家在 IDEA 上使用 AWS 服务的插件，这个插件中有一个好玩的功能那就是 Amazon CodeWhisperer。</p><h2 id="1-安装与配置"><a href="#1-安装与配置" class="headerlink" title="1. 安装与配置"></a>1. 安装与配置</h2><p>插件安装好说，大家直接在 IDEA 插件商店搜索 AWS Toolkit，安装完成后重启 IDEA：</p><p><img src="http://img.itboyhub.com/2022/08/20231025115800.png"></p><p>安装完成之后，重启 IDEA，重启之后，就可以看到 AWS Toolkit 插件了：</p><p><img src="http://img.itboyhub.com/2022/08/20231025115917.png"></p><p>安装好之后，首次使用需要先配置一下，这个配置是比较容易的，我们点击 CodeWhisperer 下面的 Start 按钮，如下：</p><p><img src="http://img.itboyhub.com/2022/08/20231025120246.png"></p><p>这里只需要用邮箱简单注册一下，不需要额外费用，选择第一项，然后点击 connect 按钮，此时会自动在浏览器打开 AWS 登录页面（不需要魔法）：</p><p><img src="http://img.itboyhub.com/2022/08/20231025120541.png"></p><p>点击确认按钮即可，接下来，会需要一个邮箱地址注册一下即可，如果已经有 AWS 账号可以直接登录：</p><p><img src="http://img.itboyhub.com/2022/08/20231025121028.png"></p><p>输入验证码：</p><p><img src="http://img.itboyhub.com/2022/08/20231025121347.png"></p><p>最后再输入一下密码，然后点击 Allow 就可以了：</p><p><img src="http://img.itboyhub.com/2022/08/20231025123408.png"></p><p>再次回到 IDEA，就可以看到如下页面了：</p><p><img src="http://img.itboyhub.com/2022/08/20231025123520.png"></p><p>从这里可以看出来，CodeWhisperer 支持 15 种开发语言：</p><p><img src="http://img.itboyhub.com/2022/08/20231025124748.png"></p><p>好啦，准备工作妥当，接下来我们就来简单体验一把 CodeWhisperer 的用法吧。</p><h2 id="2-实践"><a href="#2-实践" class="headerlink" title="2. 实践"></a>2. 实践</h2><h3 id="2-1-根据注释生成代码"><a href="#2-1-根据注释生成代码" class="headerlink" title="2.1 根据注释生成代码"></a>2.1 根据注释生成代码</h3><p>先来看 CodeWhisperer 根据注释生成代码这个能力：</p><p><img src="http://img.itboyhub.com/2022/08/20231025125519.png"></p><p>进入后，我们直接写需求，写完需求之后，按回车，就会自动生成代码了，自动生成代码的过程中，一般会生成多个建议，可以按左右箭头去选择，选择完成后，按 tab 键进行代码插入：</p><p><img src="http://img.itboyhub.com/2022/08/20231025130044.png"></p><p>上图是官方已经写好的注释，我们自己也来写一个：</p><p><img src="http://img.itboyhub.com/2022/08/20231025130343.png"></p><p>啊。。这。。。</p><p>算了，试下一个功能吧。</p><h3 id="2-2-生成代码建议"><a href="#2-2-生成代码建议" class="headerlink" title="2.2 生成代码建议"></a>2.2 生成代码建议</h3><p>这个是自动分析上下文代码然后给出建议，这个功能要是做成了那真是牛！</p><p><img src="http://img.itboyhub.com/2022/08/20231025130651.png"></p><p>小伙伴们看提示，这段代码从 19 行开始是自动生成的，前面的代码写好之后，将光标放在 18 行，按回车，就会自动给出代码建议，觉得建议 OK，就按 tab 键插入代码。</p><blockquote><p>这个功能目前只能根据你的代码写出来类似代码，其他的还办不到。</p></blockquote><p>不过这个功能，相比于 IDEA 中自带的提示还是智能一些，当我们按回车之后，他会给出来一些代码建议，安装了该插件之后，这个功能我觉得是最有用的一个了。</p><h3 id="2-3-代码安全检查"><a href="#2-3-代码安全检查" class="headerlink" title="2.3 代码安全检查"></a>2.3 代码安全检查</h3><p>点击安全扫描，可以对当前项目中的类进行安全检查：</p><p><img src="http://img.itboyhub.com/2022/08/20231025132325.png"></p><p>假设我留一个资源不释放的漏洞，我们来看下检查结果：</p><p><img src="http://img.itboyhub.com/2022/08/20231025132533.png"></p><p>可以看到，ctx 没有关闭，存在资源泄漏的风险。</p><h3 id="2-4-推荐配置"><a href="#2-4-推荐配置" class="headerlink" title="2.4 推荐配置"></a>2.4 推荐配置</h3><p>建议关闭 CodeWhisperer 的代码导入功能，这个功能 IDEA 自己有，也挺好用，AI 推断的反而有时候不准确，并且关闭代码分享，这是为了安全：</p><p><img src="http://img.itboyhub.com/2022/08/20231025132813.png"></p><p>大致就这些吧。整体感受：一般般，不好用（估计就是生成 AWS 自家的代码好用）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前松哥跟小伙伴们推荐了一个基于 ChatGPT-4 的 IDEA 智能助手，小伙伴们可以参考：&lt;/p&gt;</summary>
    
    
    
    <category term="IDEA" scheme="http://www.javaboy.org/categories/IDEA/"/>
    
    
    <category term="IDEA" scheme="http://www.javaboy.org/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean 名称暗藏玄机，这样取名就不会被代理</title>
    <link href="http://www.javaboy.org/2023/1024/spring-bean-proxy-name.html"/>
    <id>http://www.javaboy.org/2023/1024/spring-bean-proxy-name.html</id>
    <published>2023-10-24T10:00:48.000Z</published>
    <updated>2024-05-10T10:40:45.011Z</updated>
    
    <content type="html"><![CDATA[<p>一些使用小细节就是在不断的源码探索中逐步发现的，今天就来和小伙伴们聊一下通过 beanName 的设置，可以让一个 bean 拒绝被代理！</p><span id="more"></span><h2 id="1-代码实践"><a href="#1-代码实践" class="headerlink" title="1. 代码实践"></a>1. 代码实践</h2><p>假设我有如下一个切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* org.javaboy.demo.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jp.getSignature().getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 方法开始执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个切面要拦截的方法是 <code>org.javaboy.demo.service</code> 包下的所有类的所有方法，现在，这个包下有一个 BookService 类，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;org.javaboy.demo.service.BookService.ORIGINAL&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello bs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 BookService 的 beanName 我没有使用默认的 beanName，而是自己配置了一个 beanName，这个 beanName 的配置方式是 <code>类名的完整路径+.ORIGINAL</code>。</p><p>当我们按照这样的规则给 bean 取名之后，那么即使当前 bean 已经包含在切点所定义的范围内，这个 bean 也不会被代理了。</p><p>这是 Spring5.1 开始的新玩法。</p><p>这种写法的原理是什么呢？</p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h2><p>在 Spring 创建 Bean 的时候，小伙伴们都知道，bean 创建完成之后会去各种后置处理器（BeanPostProcessor）中走一圈，所以一般我们认为 BeanPostProcessor 是在 bean 实例创建完成之后执行。但是，BeanPostProcessor 中有一个特例 InstantiationAwareBeanPostProcessor，这个接口继承自 BeanPostProcessor，但是在 BeanPostProcessor 的基础之上，增加了额外的能力：</p><ol><li>在 bean 实例化之前先做一些预处理，例如直接创建代理对象，代替后续的 bean 生成。</li><li>在 bean 实例化之后但是属性填充之前，可以自定义一些属性注入策略。</li></ol><p>大致上就是这两方面的能力。</p><p>具体到代码上，就是在创建 bean 的 createBean 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"><span class="comment">//省略。。。</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看，这里的 resolveBeforeInstantiation 方法就是给 BeanPostProcessor 一个返回代理对象的机会，在这个方法中，最终就会触发到 InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation 方法，我们来看看这里涉及到的跟 AOP 相关的 AbstractAutoProxyCreator#postProcessBeforeInstantiation 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Create proxy here if we have a custom TargetSource.</span></span><br><span class="line"><span class="comment">// Suppresses unnecessary default instantiation of the target bean:</span></span><br><span class="line"><span class="comment">// The TargetSource will handle target instances in a custom fashion.</span></span><br><span class="line"><span class="type">TargetSource</span> <span class="variable">targetSource</span> <span class="operator">=</span> getCustomTargetSource(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (targetSource != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="built_in">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line"><span class="built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法实际上干了两件事：</p><ol><li>检查当前 bean 是否需要代理，如果不需要代理，那么就存入到一个 map 集合 advisedBeans 中，key 是 bean 的名字，value 如果为 true 则表示这个 bean 是需要代理的，value 为 false，则表示这个 bean 是不需要代理的。</li><li>如果有我们有自定义的 TargetSource，则根据自定义的 TargetSource 去创建代理对象。</li></ol><p>这里我要和大家说的是第一点。</p><p>在判断一个 bean 是否需要代理的时候，主要依据两个方法：</p><ol><li>isInfrastructureClass：这个方法主要是检查当前 bean 是否是 Advice&#x2F;Advisor&#x2F;Pointcut 等类型，或者这个类上是否有 @Aspect 注解，这个松哥在之前的文章中其实和大家介绍过了：<a href="https://mp.weixin.qq.com/s/VtSHQXq1uFAMdDcRNF62Iw">听说 Spring Bean 的创建还有一条捷径？</a>。</li><li>shouldSkip：如果 isInfrastructureClass 方法返回 false，那么就要执行 shouldSkip 了，我们来仔细看下 shouldSkip 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Consider optimization by caching the list of the aspect names</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;</span><br><span class="line"><span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> AspectJPointcutAdvisor pointcutAdvisor &amp;&amp;</span><br><span class="line">pointcutAdvisor.getAspectName().equals(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.shouldSkip(beanClass, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先找到系统中所有的切面，找到之后挨个遍历，遍历的时候判断如果当前要创建的 bean 刚好就是切面，那切面肯定是不需要代理的，直接返回 true。否则就会去调用父类的 shouldSkip 方法，我们再来瞅一眼父类的 shouldSkip 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">shouldSkip</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> AutoProxyUtils.isOriginalInstance(beanName, beanClass);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOriginalInstance</span><span class="params">(String beanName, Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(beanName) || beanName.length() !=</span><br><span class="line">beanClass.getName().length() + AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX.length()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (beanName.startsWith(beanClass.getName()) &amp;&amp;</span><br><span class="line">beanName.endsWith(AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类 shouldSkip 方法主要是调用了一个静态工具方法 isOriginalInstance 来判断当前 bean 是否是一个不需要代理的 bean，这个具体的判断逻辑就是检查这个 beanName 是否按照 <code>类名的完整路径+.ORIGINAL</code> 的方式命名的，如果是则返回 true。</p><p>当 shouldSkip 方法返回 true 的时候，就会进入到 postProcessBeforeInstantiation 方法的 if 分支中，该分支将当前 beanName 存入到 advisedBeans 集合中，存储的 key 就是 beanName，value 则是 false，然后将方法 return。</p><p>当 bean 创建完成之后，再进入到 AbstractAutoProxyCreator#postProcessAfterInitialization 方法中处理的时候，就会发现这个 bean 已经存入到 advisedBeans 集合中，并且 value 是 false，这就意味着这个 bean 不需要代理，那么就针对该 bean 就不会进行 AOP 处理了，直接 return 即可。</p><p>好啦，一个小小细节，加深大家对 Spring AOP 的理解，感兴趣的小伙伴可以去试试哦～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些使用小细节就是在不断的源码探索中逐步发现的，今天就来和小伙伴们聊一下通过 beanName 的设置，可以让一个 bean 拒绝被代理！&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
  </entry>
  
</feed>
