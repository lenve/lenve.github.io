<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-08-04T13:56:44.359Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Security 初始化流程梳理</title>
    <link href="http://www.javaboy.org/2020/0803/springsecurity-start-analysis.html"/>
    <id>http://www.javaboy.org/2020/0803/springsecurity-start-analysis.html</id>
    <published>2020-08-03T13:29:10.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们对 Spring Security 源码的讲解都比较零散，今天松哥试着来和大家捋一遍 Spring Security 的初始化流程，顺便将前面的源码解析文章串起来。</p><a id="more"></a><p>Spring Security 启动流程并不难，但是由于涉及到的知识点非常庞杂，所以松哥在之前已经连载过好几篇源码解读的文章了，大家把这些源码解读的文章搞懂了，今天这篇文章就好理解了。</p><p>在 Spring Boot 中，Spring Security 的初始化，我们就从自动化配置开始分析吧！</p><h2 id="1-SecurityAutoConfiguration"><a href="#1-SecurityAutoConfiguration" class="headerlink" title="1.SecurityAutoConfiguration"></a>1.SecurityAutoConfiguration</h2><p>Spring Security 的自动化配置类是 SecurityAutoConfiguration，我们就从这个配置类开始分析。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnClass</span>(DefaultAuthenticationEventPublisher.class)</span><br><span class="line"><span class="hljs-meta">@EnableConfigurationProperties</span>(SecurityProperties.class)</span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; SpringBootWebSecurityConfiguration.class, WebSecurityEnablerConfiguration.class,</span><br><span class="line">SecurityDataConfiguration.class &#125;)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(AuthenticationEventPublisher.class)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> DefaultAuthenticationEventPublisher <span class="hljs-title">authenticationEventPublisher</span><span class="hljs-params">(ApplicationEventPublisher publisher)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultAuthenticationEventPublisher(publisher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Bean 中，定义了一个事件发布器。另外导入了三个配置：</p><ol><li>SpringBootWebSecurityConfiguration：这个配置的作用是在如果开发者没有自定义 WebSecurityConfigurerAdapter 的话，这里提供一个默认的实现。</li><li>WebSecurityEnablerConfiguration：这个配置是 Spring Security 的核心配置，也将是我们分析的重点。</li><li>SecurityDataConfiguration：提供了 Spring Security 整合 Spring Data 的支持，由于国内使用 MyBatis 较多，所以这个配置发光发热的场景有限。</li></ol><h2 id="2-WebSecurityEnablerConfiguration"><a href="#2-WebSecurityEnablerConfiguration" class="headerlink" title="2.WebSecurityEnablerConfiguration"></a>2.WebSecurityEnablerConfiguration</h2><p>接着来看上面出现的 WebSecurityEnablerConfiguration：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnBean</span>(WebSecurityConfigurerAdapter.class)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnMissingBean</span>(name = BeanIds.SPRING_SECURITY_FILTER_CHAIN)</span><br><span class="line"><span class="hljs-meta">@ConditionalOnWebApplication</span>(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="hljs-meta">@EnableWebSecurity</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityEnablerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置倒没啥可说的，给了一堆生效条件，最终给出了一个 @EnableWebSecurity 注解，看来初始化重任落在 @EnableWebSecurity 注解身上了。</p><h2 id="3-EnableWebSecurity"><a href="#3-EnableWebSecurity" class="headerlink" title="3.@EnableWebSecurity"></a>3.@EnableWebSecurity</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Import</span>(&#123; WebSecurityConfiguration.class,</span><br><span class="line">SpringWebMvcImportSelector.class,</span><br><span class="line">OAuth2ImportSelector.class &#125;)</span><br><span class="line"><span class="hljs-meta">@EnableGlobalAuthentication</span></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebSecurity &#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Controls debugging support for Spring Security. Default is false.</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> if true, enables debug support with Spring Security</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@EnableWebSecurity 所做的事情，有两件比较重要：</p><ol><li>导入 WebSecurityConfiguration 配置。</li><li>通过 @EnableGlobalAuthentication 注解引入全局配置。</li></ol><h3 id="3-1-WebSecurityConfiguration"><a href="#3-1-WebSecurityConfiguration" class="headerlink" title="3.1 WebSecurityConfiguration"></a>3.1 WebSecurityConfiguration</h3><p>WebSecurityConfiguration 类实现了两个接口，我们来分别看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportAware</span>, <span class="hljs-title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImportAware 接口和 @Import 注解一起使用的。实现了 ImportAware 接口的配置类可以方便的通过 setImportMetadata 方法获取到导入类中的数据配置。</p><p>可能有点绕，我再梳理下，就是 WebSecurityConfiguration 实现了 ImportAware 接口，使用 @Import 注解在 @EnableWebSecurity 上导入 WebSecurityConfiguration 之后，在 WebSecurityConfiguration 的 setImportMetadata 方法中可以方便的获取到 @EnableWebSecurity 中的属性值，这里主要是 debug 属性。</p><p>我们来看下 WebSecurityConfiguration#setImportMetadata 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setImportMetadata</span><span class="hljs-params">(AnnotationMetadata importMetadata)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; enableWebSecurityAttrMap = importMetadata</span><br><span class="line">.getAnnotationAttributes(EnableWebSecurity.class.getName());</span><br><span class="line">AnnotationAttributes enableWebSecurityAttrs = AnnotationAttributes</span><br><span class="line">.fromMap(enableWebSecurityAttrMap);</span><br><span class="line">debugEnabled = enableWebSecurityAttrs.getBoolean(<span class="hljs-string">"debug"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (webSecurity != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">webSecurity.debug(debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到 debug 属性赋值给 WebSecurity。</p><p>实现 BeanClassLoaderAware 接口则是为了方便的获取 ClassLoader。</p><p>这是 WebSecurityConfiguration 实现的两个接口。</p><p>在 WebSecurityConfiguration 内部定义的 Bean 中，最为重要的是两个方法：</p><ol><li>springSecurityFilterChain 该方法目的是为了获取过滤器链。</li><li>setFilterChainProxySecurityConfigurer 这个方法是为了收集配置类并创建 WebSecurity。</li></ol><p>这两个方法是核心，我们来逐一分析，先来看 setFilterChainProxySecurityConfigurer：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFilterChainProxySecurityConfigurer</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Value(<span class="hljs-string">"#&#123;@autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers()&#125;"</span>)</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers)</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">webSecurity = objectPostProcessor</span><br><span class="line">.postProcess(<span class="hljs-keyword">new</span> WebSecurity(objectPostProcessor));</span><br><span class="line"><span class="hljs-keyword">if</span> (debugEnabled != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">webSecurity.debug(debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line">webSecurityConfigurers.sort(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">Integer previousOrder = <span class="hljs-keyword">null</span>;</span><br><span class="line">Object previousConfig = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; config : webSecurityConfigurers) &#123;</span><br><span class="line">Integer order = AnnotationAwareOrderComparator.lookupOrder(config);</span><br><span class="line"><span class="hljs-keyword">if</span> (previousOrder != <span class="hljs-keyword">null</span> &amp;&amp; previousOrder.equals(order)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"@Order on WebSecurityConfigurers must be unique. Order of "</span></span><br><span class="line">+ order + <span class="hljs-string">" was already used on "</span> + previousConfig + <span class="hljs-string">", so it cannot be used on "</span></span><br><span class="line">+ config + <span class="hljs-string">" too."</span>);</span><br><span class="line">&#125;</span><br><span class="line">previousOrder = order;</span><br><span class="line">previousConfig = config;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;Filter, WebSecurity&gt; webSecurityConfigurer : webSecurityConfigurers) &#123;</span><br><span class="line">webSecurity.apply(webSecurityConfigurer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.webSecurityConfigurers = webSecurityConfigurers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个方法有两个参数，两个参数都会自动进行注入，第一个参数 ObjectPostProcessor 是一个后置处理器，默认的实现是 AutowireBeanFactoryObjectPostProcessor，主要是为了将 new 出来的对象注入到 Spring 容器中（参见<a href="https://mp.weixin.qq.com/s/PWIM9jgEB-F-m4Ove470wg" target="_blank" rel="noopener">深入理解 SecurityConfigurer 【源码篇】</a>）。</p><p>第二个参数 webSecurityConfigurers 是一个集合，这个集合里存放的都是 SecurityConfigurer，我们前面分析的过滤器链中过滤器的配置器，包括 WebSecurityConfigurerAdapter 的子类，都是 SecurityConfigurer 的实现类。根据 @Value 注解中的描述，我们可以知道，这个集合中的数据来自 autowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers() 方法。</p><p>在 WebSecurityConfiguration 中定义了该实例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AutowiredWebSecurityConfigurersIgnoreParents <span class="hljs-title">autowiredWebSecurityConfigurersIgnoreParents</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutowiredWebSecurityConfigurersIgnoreParents(beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的 getWebSecurityConfigurers 方法我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; getWebSecurityConfigurers() &#123;</span><br><span class="line">List&lt;SecurityConfigurer&lt;Filter, WebSecurity&gt;&gt; webSecurityConfigurers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String, WebSecurityConfigurer&gt; beansOfType = beanFactory</span><br><span class="line">.getBeansOfType(WebSecurityConfigurer.class);</span><br><span class="line"><span class="hljs-keyword">for</span> (Entry&lt;String, WebSecurityConfigurer&gt; entry : beansOfType.entrySet()) &#123;</span><br><span class="line">webSecurityConfigurers.add(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> webSecurityConfigurers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实就是从 beanFactory 工厂中查询到 WebSecurityConfigurer 的实例返回。</p><p>WebSecurityConfigurer 的实例其实就是 WebSecurityConfigurerAdapter，如果我们没有自定义 WebSecurityConfigurerAdapter，那么默认使用的是 SpringBootWebSecurityConfiguration 中自定义的 WebSecurityConfigurerAdapter。</p><p>当然我们也可能自定义了 WebSecurityConfigurerAdapter，而且如果我们配置了多个过滤器链（多个 HttpSecurity 配置），那么 WebSecurityConfigurerAdapter 的实例也将有多个。所以这里返回的是 List 集合。</p><p>至此，我们搞明白了了 setFilterChainProxySecurityConfigurer 方法的两个参数。回到该方法我们继续分析。</p><p>接下来创建了 webSecurity 对象，并且放到 ObjectPostProcessor 中处理了一下，也就是把 new 出来的对象存入 Spring 容器中。</p><p>调用 webSecurityConfigurers.sort 方法对 WebSecurityConfigurerAdapter 进行排序，如果我们配置了多个 WebSecurityConfigurerAdapter 实例（多个过滤器链，参见：<a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a>），那么我们肯定要通过 @Order 注解对其进行排序，以便分出一个优先级出来，而且这个优先级还不能相同。</p><p>所以接下来的 for 循环中就是判断这个优先级是否有相同的，要是有，直接抛出异常。</p><p>最后，遍历 webSecurityConfigurers，并将其数据挨个配置到 webSecurity 中。webSecurity.apply 方法会将这些配置存入 AbstractConfiguredSecurityBuilder.configurers 属性中（参见：<a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a>）。</p><p>这就是 setFilterChainProxySecurityConfigurer 方法的工作逻辑，大家看到，它主要是在构造 WebSecurity 对象。</p><p>WebSecurityConfiguration 中第二个比较关键的方法是 springSecurityFilterChain，该方法是在上个方法执行之后执行，方法的目的是构建过滤器链，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span>(name = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Filter <span class="hljs-title">springSecurityFilterChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> hasConfigurers = webSecurityConfigurers != <span class="hljs-keyword">null</span></span><br><span class="line">&amp;&amp; !webSecurityConfigurers.isEmpty();</span><br><span class="line"><span class="hljs-keyword">if</span> (!hasConfigurers) &#123;</span><br><span class="line">WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor</span><br><span class="line">.postProcess(<span class="hljs-keyword">new</span> WebSecurityConfigurerAdapter() &#123;</span><br><span class="line">&#125;);</span><br><span class="line">webSecurity.apply(adapter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> webSecurity.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先会判断有没有 webSecurityConfigurers 存在，一般来说都是有的，即使你没有配置，还有一个默认的。当然，如果不存在的话，这里会现场 new 一个出来，然后调用 apply 方法。</p><p>最最关键的就是最后的 webSecurity.build() 方法了，这个方法的调用就是去构建过滤器链了。</p><p>根据 <a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a> 一文的介绍，这个 build 方法最终是在 AbstractConfiguredSecurityBuilder#doBuild 方法中执行的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">doBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (configurers) &#123;</span><br><span class="line">buildState = BuildState.INITIALIZING;</span><br><span class="line">beforeInit();</span><br><span class="line">init();</span><br><span class="line">buildState = BuildState.CONFIGURING;</span><br><span class="line">beforeConfigure();</span><br><span class="line">configure();</span><br><span class="line">buildState = BuildState.BUILDING;</span><br><span class="line">O result = performBuild();</span><br><span class="line">buildState = BuildState.BUILT;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会记录下来整个项目的构建状态。三个比较关键的方法，一个是 init、一个 configure 还有一个 performBuild。</p><p>init 方法会遍历所有的 WebSecurityConfigurerAdapter ，并执行其 init 方法。WebSecurityConfigurerAdapter#init 方法主要是做 HttpSecurity 的初始化工作，具体参考：<a href>深入理解 WebSecurityConfigurerAdapter【源码篇】</a>。init 方法在执行时，会涉及到 HttpSecurity 的初始化，而 HttpSecurity 的初始化，需要配置 AuthenticationManager，所以这里最终还会涉及到一些全局的 AuthenticationManagerBuilder 及相关属性的初始化，具体参见：<a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a>，需要注意的是，AuthenticationManager 在初始化的过程中，也会来到这个 doBuild 方法中，具体参考松哥前面文章，这里就不再赘述。</p><p>configure 方法会遍历所有的 WebSecurityConfigurerAdapter ，并执行其 configure 方法。WebSecurityConfigurerAdapter#configure 方法默认是一个空方法，开发者可以自己重写该方法去定义自己的 WebSecurity，具体参考：<a href>深入理解 WebSecurityConfigurerAdapter【源码篇】</a>。</p><p>最后调用 performBuild 方法进行构建，这个最终执行的是 WebSecurity#performBuild 方法，该方法执行流程，参考松哥前面文章<a href>深入理解 WebSecurityConfigurerAdapter【源码篇】</a>。</p><p>performBuild 方法执行的过程，也是过滤器链构建的过程。里边会调用到过滤器链的构建方法，也就是默认的十多个过滤器会挨个构建，这个构建过程也会调用到这个 doBuild 方法。</p><p>performBuild 方法中将成功构建 FilterChainProxy，最终形成我们需要的过滤器链。</p><h3 id="3-2-EnableGlobalAuthentication"><a href="#3-2-EnableGlobalAuthentication" class="headerlink" title="3.2 @EnableGlobalAuthentication"></a>3.2 @EnableGlobalAuthentication</h3><p>@EnableWebSecurity 注解除了过滤器链的构建，还有一个注解就是 @EnableGlobalAuthentication。我们也顺便来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Retention</span>(value = java.lang.annotation.RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="hljs-meta">@Target</span>(value = &#123; java.lang.annotation.ElementType.TYPE &#125;)</span><br><span class="line"><span class="hljs-meta">@Documented</span></span><br><span class="line"><span class="hljs-meta">@Import</span>(AuthenticationConfiguration.class)</span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableGlobalAuthentication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该注解的作用主要是导入 AuthenticationConfiguration 配置，该配置前面已经介绍过了，参考：<a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a>一文。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>这便是 Spring Security 的一个大致的初始化流程。大部分的源码在前面的文章中都讲过了，本文主要是是一个梳理，如果小伙伴们还没看前面的文章，建议看过了再来学习本文哦。</p><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1NDY0MTkzNQ==&amp;action=getalbum&amp;album_id=1319828555819286528&amp;subscene=38&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI1NDY0MTkzNQ%3D%3D%26mid%3D2247489179%26idx%3D1%26sn%3D01aae04306638e68d9ea483e508d56ac%26chksm%3De9c344fbdeb4cded021f3e125f39cb4f5fb25ca5e903a621dbb5bd76264c76a1b90bbc7e6756%26scene%3D38%26key%3Dd7cd6cebe5b965e753315b8fba3c3785b8b3ed8da8440543110c60ab3a01fc0291bab2006360738c9faf88e3a0a5e2e2747427d90eaa778919bcd3c12bd32d84bacd1b7b197b7c133449c13e60589b5f%26ascene%3D0%26uin%3DMTQ5NzA1MzQwMw%253D%253D%26devicetype%3DiMac%2BMacBookPro15%252C1%2BOSX%2BOSX%2B10.13.6%2Bbuild(17G2208" target="_blank" rel="noopener">Spring Security 系列历史文章合集</a>%26version%3D12031f10%26nettype%3DWIFI%26lang%3Den%26fontScale%3D100%26exportkey%3DA3Wiahk84DJaxlesHRkR9Lo%253D%26pass_ticket%3DTw4Lf%252FDXMBnX6b1zckIiLAXh%252FIXYTPiEPUroWij5MLEcC%252BvlNTmlIjOKDAln3v39%26winzoom%3D1.000000&amp;uin=&amp;key=&amp;devicetype=iMac+MacBookPro15%2C1+OSX+OSX+10.13.6+build(17G2208)&amp;version=12031f10&amp;lang=en&amp;nettype=WIFI&amp;ascene=0&amp;fontScale=100&amp;winzoom=1.000000)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们对 Spring Security 源码的讲解都比较零散，今天松哥试着来和大家捋一遍 Spring Security 的初始化流程，顺便将前面的源码解析文章串起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>告别深圳，开启新的旅程</title>
    <link href="http://www.javaboy.org/2020/0731/goodbye.html"/>
    <id>http://www.javaboy.org/2020/0731/goodbye.html</id>
    <published>2020-07-31T13:28:38.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>松哥原创的 Spring Boot 视频教程已经杀青，感兴趣的小伙伴戳这里–&gt;<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot+Vue+微人事视频教程</a></p><a id="more"></a><p>深圳这座城市，有人来就有人走。上周小舅子和小表弟毕业后来深圳找工作，两人这周均已拿到 offer ，下周就可以去上班了，这是一个来深圳的故事，松哥以后抽空和大家聊聊~</p><p>今天想说的是一个离开深圳的故事，他来深圳三年了，不能说混不下去了，只是觉得这座城市不适合自己，因此选择了离开，松哥昨晚去给小伙伴饯行，感慨颇多。</p><h2 id="自学转行"><a href="#自学转行" class="headerlink" title="自学转行"></a>自学转行</h2><p>很早以前这个小伙伴的微信昵称是“全村的希望”，因此我们都叫他希望。第一次听这个绰号可能会觉得有点莫名其妙，听多了就好了。</p><p>希望是 96 年的，17 年大专毕业后从东北来到深圳，9 月份在在后海那里找到一份卖房子的工作，干了一个多月，成交了一单。感觉看不到未来，于是辞了工作，决定自学 Java 要搞 IT。</p><p>2018 年中的时候，终于成功上岸，在深圳找到了一份月薪 8.5K 的 Java 初级工程师岗位，公司是做短视频电商的，也算是一个比较有前途的行业。希望说他刚入职的时候，每天都搞到晚上两三点，十点多从公司下班后，回到家里继续撸代码，撸到凌晨两三点，才能把任务搞完，搞完之后他不敢提交代码，怕领导看到他的提交日志后觉得他水平不行，这么简单的功能搞这么久。他都是第二天早上早早去公司，把头一天的代码合并提交。这样的日子坚持了三四个月，总算慢慢感觉稳了。</p><p>然而 18 年底的时候遇到公司高层内斗，他所在的部门被从母公司划分出去了，成立了新的公司，他自己也成了新公司的技术负责人，负责新公司的整个技术栈，搭建私服、BUG 系统、代码仓库等等，所有东西都是他从头开始搞，他说那一段时间真的进步神速。</p><p>可惜好景不长，新公司成立后就一直财务困难，终于在被拖欠了三个月的薪水之后公司倒闭了，这个时候已经是 19 年 3 月份了。</p><p>希望和同事一起走上了维权之路，联合上公司的所有同事去集体仲裁，在经历了漫长的诉讼之后，他们赢得了官司，不过公司破产倒闭了，老板就是不给他们支付工资。希望说现在流程走完了，在等政府那边留档 3 个月后，资料才能给到他们去复印，跑勾后他们才能去拿政府的垫付，大概 10 月份可以拿到钱，到时候这件事就算了了。</p><h2 id="第二份工作"><a href="#第二份工作" class="headerlink" title="第二份工作"></a>第二份工作</h2><p>在第一家公司倒闭之后，希望又开始了漫长的找工作之路，他说自己对于面试吹牛信心十足，关键是想找到一个薪水还不错的 offer。于是在经历了接近两个月之后，在 19 年 5 月份再次上车，这次薪水涨到了 13k，公司依然还是做电商的，新公司也是考虑到他之前的电商行业经验，所以给了一个他很满意的薪水。</p><p>第二份工作底气就足了，他自己找工作之后，还内推了很多前同事一起来新的公司。他的领导都是一线大厂出来的，跟着学到了不少东西，不仅仅是技术上的，也包含很多电商业务上的。</p><p>由于两份工作都是电商，这两年电商比较火的就是社交电商，多级分销这种，希望在两家公司里把多级分销玩的是相当 6，每次聊天他跟我们讲他们公司的业务，一套一套的，他也经常调侃自己是老传，销了。</p><p>然而好景不长，因为多级分销这种实际上在打擦边球，他所在的公司去年遭遇了几起诉讼官司之后，公司的银行账户被法院冻结，工资都只能用支付宝发。于是公司一方面调整业务，另一方面裁员优化，不过在第一波裁员优化中他没被优化，留下来继续搬砖。</p><p>年后因为疫情原因，公司经营雪上加霜，他在老家还没来深圳，就收到了公司的裁员通知，拿了 N+1 补偿之后离职走人。被裁没多久，他听前同事说公司被阿里收购了。。。一声叹息，错失了一个曲线进大厂的机会。</p><p>被裁掉之后，他说不想干开发了，整天在公司 CURD 就像富士康代工一样，他想做苹果，去设计一个产品。于是在家几个月，自学产品，他要转行做产品经理。</p><h2 id="转行"><a href="#转行" class="headerlink" title="转行"></a>转行</h2><p>希望这个人，就是能说会道，他说想转产品，我一点都不奇怪，我一直觉得他更适合和人打交道的工作。</p><p>他说不想回东北，想把父母接到深圳来，但是深圳这边压力太大了。四个一线城市，只有广州目前的房价比较亲民，所以他想去广州发展，这样可以多做一些长远的打算。虽然有人说广州的工资比深圳低，但是他认为这还是分人分公司，不能一概而论，而他有信心拿到想要的薪水。</p><p>但是在去广州之前，他想在深圳先面一面产品经理，增长一些面试经验。在深圳投递简历，因为是转行，所以面试机会不算很多，但是每一个他都认真把握。没想到不到 1 周竟然还真拿到了 offer，老板给了他 15K+分红+大饼。他有点心动了，但是冷静下来分析之后，还是拒掉了 offer，决定去广州发展。</p><p>他雇了一辆货拉拉，深圳的家当连同他自己，一起被送到广州，今天就走。</p><p>希望来深圳三年，经历真的丰富多彩。不过以他的性格和能力，相信这次转行也是小 case。</p><hr><p>昨天是我第二次在深圳送人。</p><p>上一次送人还是 18 年年中的时候，我的领导要回老家发展了，他妻子在老家当公务员，孩子也快两岁了。那天他把我们几个小伙伴叫到一起，做了一顿拿手的麻辣小龙虾，吃完就散伙了，当然他回老家也发展的很好。</p><p>深圳这座城市，压力很大，机会很多。每年都有人离开，每年也都有新鲜血液注入这座城市。坚持留下来继续工作奋斗，还是切换个压力稍微小点的城市家庭+工作并重，老实说，我也一直在琢磨这个问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥原创的 Spring Boot 视频教程已经杀青，感兴趣的小伙伴戳这里–&amp;gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Boot+Vue+微人事视频教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://www.javaboy.org/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>盘点 Spring Security 框架中的八大经典设计模式</title>
    <link href="http://www.javaboy.org/2020/0730/springsecurity-pattern.html"/>
    <id>http://www.javaboy.org/2020/0730/springsecurity-pattern.html</id>
    <published>2020-07-30T13:28:23.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>上次有小伙伴建议，源码分析太枯燥了，要是能够结合设计模式一起来，这样更有助于大家理解 Spring Security 源码，同时还能复习一波设计模式。</p><a id="more"></a><p>因此松哥今天就试着整一篇，和大家来聊一聊 Spring Security 中涉及到的设计模式，不过 Spring Security 中涉及到的设计模式还是非常多的，松哥这里讲几个，剩下的欢迎小伙伴们留言补充。</p><h2 id="1-模板方法模式"><a href="#1-模板方法模式" class="headerlink" title="1.模板方法模式"></a>1.模板方法模式</h2><blockquote><p>Template Pattern(模板方法模式)是一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行，这是一种行为型模式。</p></blockquote><p>模板方法方式优点如下：</p><ul><li>在父类中提取了公共的部分代码，便于代码复用和扩展。</li><li>部分方法是由子类实现的，子类可以通过扩展方式增加相应的功能，符合开闭原则。</li></ul><p>缺点如下：</p><ul><li>对每个不同的实现都需要定义一个子类，导致类的个数增加，系统更加复杂，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，增加了代码理解难度。</li></ul><p>介绍完模板方法模式，大家可能大概猜到了 Spring Security 中哪些地方用到模板方法模式了。</p><p>我举几个简单的例子。</p><p>第一个例子是 AbstractUserDetailsAuthenticationProvider 类的设计。大家都知道这个类是用来做验证的，认证的逻辑在这个方法中都定义好了，但是该类却定义了两个抽象方法：</p><ul><li>retrieveUser 该方法用户从数据源中获取用户对象。</li><li>additionalAuthenticationChecks 该方法用来做额外的校验（登录凭证的校验）</li></ul><p>这两个抽象方法是在 DaoAuthenticationProvider 中实现的。DaoAuthenticationProvider 的实现就是从数据库中加载用户，默认检验登录凭证也都是验证密码。</p><p>如果你的数据源来自其他地方，或者登录凭证不是密码，那么自定义类继承自 AbstractUserDetailsAuthenticationProvider 并重写它里边的这两个方法即可。</p><h2 id="2-责任链模式"><a href="#2-责任链模式" class="headerlink" title="2.责任链模式"></a>2.责任链模式</h2><blockquote><p>Chain of Responsibility Pattern(责任链模式) ，在这种模式中，通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。在这个过程中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</p></blockquote><p>责任链模式优点如下：</p><ul><li>降低对象之间的耦合度。</li><li>增强了系统的可扩展性。</li><li>当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序。</li><li>简化了对象之间的连接，每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用。</li><li>责任分担，每个类只需要处理自己该处理的工作，符合类的单一职责原则。</li></ul><p>缺点如下：</p><ul><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性。</li></ul><p>很明显，Spring Security 中的过滤器链就是一种责任链模式。一个请求到达后，被过滤器链中的过滤器逐个进行处理，过滤器链中的过滤器每个都具有不同的职能并且互不相扰，我们还可以通过 HttpSecurity 来动态配置过滤器链中的过滤器（即添加/删除过滤器链中的过滤器）。</p><p>具体的代码在 FilterChainProxy$VirtualFilterChain 中，如下：</p><p>那么接下来我们就来看看 VirtualFilterChain：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterChain</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FilterChain originalChain;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Filter&gt; additionalFilters;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FirewalledRequest firewalledRequest;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentPosition = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">VirtualFilterChain</span><span class="hljs-params">(FirewalledRequest firewalledRequest,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">FilterChain chain, List&lt;Filter&gt; additionalFilters)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.originalChain = chain;</span><br><span class="line"><span class="hljs-keyword">this</span>.additionalFilters = additionalFilters;</span><br><span class="line"><span class="hljs-keyword">this</span>.size = additionalFilters.size();</span><br><span class="line"><span class="hljs-keyword">this</span>.firewalledRequest = firewalledRequest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (currentPosition == size) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)</span><br><span class="line">+ <span class="hljs-string">" reached end of additional filter chain; proceeding with original chain"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Deactivate path stripping as we exit the security filter chain</span></span><br><span class="line"><span class="hljs-keyword">this</span>.firewalledRequest.reset();</span><br><span class="line">originalChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">currentPosition++;</span><br><span class="line">Filter nextFilter = additionalFilters.get(currentPosition - <span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)</span><br><span class="line">+ <span class="hljs-string">" at position "</span> + currentPosition + <span class="hljs-string">" of "</span> + size</span><br><span class="line">+ <span class="hljs-string">" in additional filter chain; firing Filter: '"</span></span><br><span class="line">+ nextFilter.getClass().getSimpleName() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">nextFilter.doFilter(request, response, <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>VirtualFilterChain 类中首先声明了 5 个全局属性，originalChain 表示原生的过滤器链，也就是 Web Filter；additionalFilters 表示 Spring Security 中的过滤器链；firewalledRequest 表示当前请求；size 表示过滤器链中过滤器的个数；currentPosition 则是过滤器链遍历时候的下标。</li><li>doFilter 方法就是 Spring Security 中过滤器挨个执行的过程，如果 <code>currentPosition == size</code>，表示过滤器链已经执行完毕，此时通过调用 originalChain.doFilter 进入到原生过滤链方法中，同时也退出了 Spring Security 过滤器链。否则就从 additionalFilters 取出 Spring Security 过滤器链中的一个个过滤器，挨个调用 doFilter 方法。nextFilter.doFilter 就是过滤器链挨个往下走。</li></ol><p>关于 FilterChainProxy 的介绍，参见：<a href="https://mp.weixin.qq.com/s/EZsChg5YG0TBadU4q_CAnA" target="_blank" rel="noopener">深入理解 FilterChainProxy【源码篇】</a></p><h2 id="3-策略模式"><a href="#3-策略模式" class="headerlink" title="3.策略模式"></a>3.策略模式</h2><blockquote><p>Strategy Pattern(策略模式)，它定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p></blockquote><p>策略模式的优点：</p><ul><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择具体的策略，也可以灵活地扩展新的策略。</li><li>策略模式提供了管理相关的策略的方式。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。</li></ul><p>策略模式的缺点：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类（可以通过使用享元模式在一定程度上减少对象的数量）。</li></ul><p>Spring Security 中使用策略模式的地方也有好几个。</p><p>第一个就是用户登录信息存储。</p><p>在 SecurityContextHolder 中定义登录用户信息存储的方法，就定义了三种不同的策略：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityContextHolder</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">// ~ Static fields/initializers</span></span><br><span class="line"><span class="hljs-comment">// =====================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MODE_THREADLOCAL = <span class="hljs-string">"MODE_THREADLOCAL"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MODE_INHERITABLETHREADLOCAL = <span class="hljs-string">"MODE_INHERITABLETHREADLOCAL"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MODE_GLOBAL = <span class="hljs-string">"MODE_GLOBAL"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SYSTEM_PROPERTY = <span class="hljs-string">"spring.security.strategy"</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String strategyName = System.getProperty(SYSTEM_PROPERTY);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SecurityContextHolderStrategy strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户可以自行选择使用哪一种策略！具体参见：<a href="https://mp.weixin.qq.com/s/4dcQ6lohB3sEcnkAXxdZwg" target="_blank" rel="noopener">在 Spring Security 中，我就想从子线程获取用户登录信息，怎么办？</a></p><p>还有一个就是 session 并发管理。</p><p>在 AbstractAuthenticationProcessingFilter#doFilter 方法中，有如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一种策略模式。</p><p>Session 并发管理可以参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li></ul><p>当然，这样的例子还有很多，我就不一一列举了。</p><h2 id="4-代理模式"><a href="#4-代理模式" class="headerlink" title="4.代理模式"></a>4.代理模式</h2><blockquote><p>Proxy Pattern(代理模式) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用，它是一种对象结构型模式。</p></blockquote><p>代理模式的优点：</p><ul><li>一定程度上降低了系统的耦合度。</li><li>代理对象可以扩展目标对象的功能。</li><li>代理对象可以保护目标对象。</li></ul><p>缺点：</p><ul><li>在客户端和真实对象之间增加了代理，可能会导致请求的处理速度变慢。</li><li>增加了系统复杂度。</li></ul><p>代理模式在 Spring Security 中最重要的应用就是 Spring Security 过滤器链接入 Web Filter 的过程，使用了 Spring 提供的 DelegatingFilterProxy，这就是一个典型的代理模式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingFilterProxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Lazily initialize the delegate if necessary.</span></span><br><span class="line">Filter delegateToUse = <span class="hljs-keyword">this</span>.delegate;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegateToUse == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.delegateMonitor) &#123;</span><br><span class="line">delegateToUse = <span class="hljs-keyword">this</span>.delegate;</span><br><span class="line"><span class="hljs-keyword">if</span> (delegateToUse == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">WebApplicationContext wac = findWebApplicationContext();</span><br><span class="line"><span class="hljs-keyword">if</span> (wac == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No WebApplicationContext found: "</span> +</span><br><span class="line"><span class="hljs-string">"no ContextLoaderListener or DispatcherServlet registered?"</span>);</span><br><span class="line">&#125;</span><br><span class="line">delegateToUse = initDelegate(wac);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.delegate = delegateToUse;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Let the delegate perform the actual doFilter operation.</span></span><br><span class="line">invokeDelegate(delegateToUse, request, response, filterChain);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还有其他很多地方也用到代理模式，我就不一一列举了，欢迎小伙伴们留言补充。</p><h2 id="5-适配器模式"><a href="#5-适配器模式" class="headerlink" title="5.适配器模式"></a>5.适配器模式</h2><blockquote><p>Adapter Pattern(适配器模式)，大家平时用的手机充电器学名叫做电源适配器，它的作用是把 220V 的电压转为手机可用的 5V 电压。所以适配器模式其实也是类似作用，将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的类可以一起工作。适配器模式又分为类适配器模式、对象适配器模式以及接口适配器模式。</p></blockquote><p>适配器模式的优点：</p><ul><li>解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li><li>增加了类的透明性和复用性。</li><li>具有较好的灵活性和扩展性都。</li></ul><p>缺点：</p><ul><li>由于 Java 不支持多重继承，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性。</li></ul><p>Spring Security 中的适配器模式也是非常多的，例如我们最为常见的 WebSecurityConfigurerAdapter，该类让两个原本不相关的 WebSecurity 和 HttpSecurity 能够在一起工作。</p><p>具体参见：<a href>深入理解 WebSecurityConfigurerAdapter【源码篇】</a></p><h2 id="6-建造者模式"><a href="#6-建造者模式" class="headerlink" title="6.建造者模式"></a>6.建造者模式</h2><blockquote><p>Builder Pattern(建造者模式)是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象出来，用户只需要指定复杂对象的类型和内容就可以构建对象，而不需要知道内部的具体构建细节。</p></blockquote><p>建造者模式优点：</p><ul><li>将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，而客户端不需要知道产品内部细节。</li><li>每一个产品对应一个建造者，用户使用不同的建造者可以创建不同的产品，建造者本身可以轻松修改或者添加。</li><li>可以更加精细地控制产品的创建过程。</li></ul><p>缺点：</p><ul><li>创建的产品需要有一定的相似性，如果差异过大，则不适合建造者模式。</li><li>产品本身的复杂度会提高建造者的复杂度。</li></ul><p>Spring Security 中对于建造者模式的使用也是非常多，例如典型的 AuthenticationManagerBuilder，它想要建造的对象是 AuthenticationManager，对应的建造方法则是 build。一般建造者模式中建造者类命名以 builder 结尾，而建造方法命名为 build()。</p><p>关于 AuthenticationManagerBuilder，参见：<a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a> 一文。</p><h2 id="7-观察者模式"><a href="#7-观察者模式" class="headerlink" title="7.观察者模式"></a>7.观察者模式</h2><blockquote><p>Observer(观察者模式)指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新，观察者模式也称为发布-订阅模式、模型-视图模式，它是对象行为型模式。</p></blockquote><p>观察者模式优点：</p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li></ul><p>缺点：</p><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，程序执行效率降低。</li></ul><p>在 Spring 框架中，观察者模式用于实现 ApplicationContext 的事件处理功能。Spring 为我们提供了 ApplicationEvent 类和 ApplicationListener 接口来启用事件处理。Spring 应用程序中的任何 Bean 实现 ApplicationListener 接口，都会接收到 ApplicationEvent 作为事件发布者推送的消息。在这里，事件发布者是主题(Subject) 和实现 ApplicationListener 的 Bean 的观察者(Observer)。</p><p>具体到 Spring Security 中，如登录成功事件发布，session 销毁事件等等，都算是观察者模式。</p><p>例如 AbstractAuthenticationProcessingFilter#successfulAuthentication 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Authentication success. Updating SecurityContextHolder to contain: "</span></span><br><span class="line">+ authResult);</span><br><span class="line">&#125;</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authResult);</span><br><span class="line">rememberMeServices.loginSuccess(request, response, authResult);</span><br><span class="line"><span class="hljs-comment">// Fire event</span></span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(</span><br><span class="line">authResult, <span class="hljs-keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line">successHandler.onAuthenticationSuccess(request, response, authResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似还有很多，如 session 销毁事件等（参见<a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a>），我这里就不一一列举了。</p><h2 id="8-装饰模式"><a href="#8-装饰模式" class="headerlink" title="8.装饰模式"></a>8.装饰模式</h2><blockquote><p>Decorator(装饰模式)是指在不改变现有对象结构的情况下，动态地给该对象增加一些额外功能的模式。</p></blockquote><p>装饰模式的优点：</p><ul><li>可以灵活的扩展一个类的功能。</li></ul><p>缺点：</p><ul><li>增加了许多子类，使程序变得很复杂。</li></ul><p>Spring Security 中对于装饰模式也有许多应用。最典型的就是一个请求在通过过滤器链的时候会不停的变，会不停的调整它的功能，通过装饰模式设计出了请求的许多类，例如：</p><ul><li>HeaderWriterRequest</li><li>FirewalledRequest</li><li>StrictHttpFirewall</li><li>SaveToSessionRequestWrapper</li><li>…</li></ul><p>等等，类似的很多，我就不一一赘述了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>松哥的 Spring Security 还在持续连载中，未来连载完了还会总结出更多的设计模式，这里先列出来八个和小伙伴们分享，如果小伙伴们有自己的见解，也欢迎留言补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次有小伙伴建议，源码分析太枯燥了，要是能够结合设计模式一起来，这样更有助于大家理解 Spring Security 源码，同时还能复习一波设计模式。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 WebSecurityConfigurerAdapter【源码篇】</title>
    <link href="http://www.javaboy.org/2020/0729/springsecurity-websecurityconfigureradapter.html"/>
    <id>http://www.javaboy.org/2020/0729/springsecurity-websecurityconfigureradapter.html</id>
    <published>2020-07-29T13:28:12.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>我们继续来撸 Spring Security 源码，今天来撸一个非常重要的 WebSecurityConfigurerAdapter。</p><a id="more"></a><p>我们的自定义都是继承自 WebSecurityConfigurerAdapter 来实现的，但是对于 WebSecurityConfigurerAdapter 内部的工作原理，配置原理，很多小伙伴可能都还不太熟悉，因此我们今天就来捋一捋。</p><p>我们先来看一张 WebSecurityConfigurerAdapter 的继承关系图：</p><p><img src="http://img.itboyhub.com/2020/07/WebSecurityConfigurerAdapter.png" alt></p><p>在这层继承关系中，有两个非常重要的类：</p><ul><li>SecurityBuilder</li><li>SecurityConfigurer</li></ul><p>这两个类松哥在之前的文章中都和大家分享过了，具体参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a>(本文讲的是 SecurityBuilder 体系)</li><li><a href="https://mp.weixin.qq.com/s/PWIM9jgEB-F-m4Ove470wg" target="_blank" rel="noopener">深入理解 SecurityConfigurer 【源码篇】</a></li></ul><p>所以关于这两个类的介绍以及作用，松哥这里就不赘述了。咱们直接从 WebSecurityConfigurer 开始看起。</p><h2 id="1-WebSecurityConfigurer"><a href="#1-WebSecurityConfigurer" class="headerlink" title="1.WebSecurityConfigurer"></a>1.WebSecurityConfigurer</h2><p>WebSecurityConfigurer 其实是一个空接口，但是它里边约束了一些泛型，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WebSecurityConfigurer</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>&gt;&gt; <span class="hljs-keyword">extends</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">Filter</span>, <span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里边的泛型很关键，这关乎到 WebSecurityConfigurer 的目的是啥！</p><ol><li>SecurityBuilder 中的泛型 Filter，表示 SecurityBuilder 最终的目的是为了构建一个 Filter 对象出来。</li><li>SecurityConfigurer 中两个泛型，第一个表示的含义也是 SecurityBuilder 最终构建的对象。</li></ol><p>同时这里还定义了新的泛型 T，T 需要继承自 SecurityBuilder<filter>，根据 WebSecurityConfigurerAdapter 中的定义，我们可以知道，T 就是 WebSecurity，我们也大概能猜出 WebSecurity 就是 SecurityBuilder<filter> 的子类。</filter></filter></p><p>所以 WebSecurityConfigurer 的目的我们可以理解为就是为了配置 WebSecurity。</p><h2 id="2-WebSecurity"><a href="#2-WebSecurity" class="headerlink" title="2.WebSecurity"></a>2.WebSecurity</h2><p>我们来看下 WebSecurity 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurity</span> <span class="hljs-keyword">extends</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">AbstractConfiguredSecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>, <span class="hljs-title">WebSecurity</span>&gt; <span class="hljs-keyword">implements</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">Filter</span>&gt;, <span class="hljs-title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，确实是这样！WebSecurity 继承自 AbstractConfiguredSecurityBuilder&lt;Filter, WebSecurity&gt; 同时实现了 SecurityBuilder<filter> 接口。</filter></p><p>WebSecurity 的这些接口和继承类，松哥在前面的源码分析中都和大家介绍过了，可能有的小伙伴忘记了，我再来和大家复习一下。</p><p><strong>AbstractConfiguredSecurityBuilder</strong></p><p>首先 AbstractConfiguredSecurityBuilder 中定义了一个枚举类，将整个构建过程分为 5 种状态，也可以理解为构建过程生命周期的五个阶段，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> BuildState &#123;</span><br><span class="line">UNBUILT(<span class="hljs-number">0</span>),</span><br><span class="line">INITIALIZING(<span class="hljs-number">1</span>),</span><br><span class="line">CONFIGURING(<span class="hljs-number">2</span>),</span><br><span class="line">BUILDING(<span class="hljs-number">3</span>),</span><br><span class="line">BUILT(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> order;</span><br><span class="line">BuildState(<span class="hljs-keyword">int</span> order) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.order = order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInitializing</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> INITIALIZING.order == order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConfigured</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> order &gt;= CONFIGURING.order;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五种状态分别是 UNBUILT、INITIALIZING、CONFIGURING、BUILDING 以及 BUILT。另外还提供了两个判断方法，isInitializing 判断是否正在初始化，isConfigured 表示是否已经配置完毕。</p><p>AbstractConfiguredSecurityBuilder 中的方法比较多，松哥在这里列出来两个关键的方法和大家分析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> &lt;C extends SecurityConfigurer&lt;O, B&gt;&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(C configurer)</span> </span>&#123;</span><br><span class="line">Assert.notNull(configurer, <span class="hljs-string">"configurer cannot be null"</span>);</span><br><span class="line">Class&lt;? extends SecurityConfigurer&lt;O, B&gt;&gt; clazz = (Class&lt;? extends SecurityConfigurer&lt;O, B&gt;&gt;) configurer</span><br><span class="line">.getClass();</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (configurers) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (buildState.isConfigured()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot apply "</span> + configurer</span><br><span class="line">+ <span class="hljs-string">" to already built object"</span>);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs = allowConfigurersOfSameType ? <span class="hljs-keyword">this</span>.configurers</span><br><span class="line">.get(clazz) : <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (configs == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">configs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">configs.add(configurer);</span><br><span class="line"><span class="hljs-keyword">this</span>.configurers.put(clazz, configs);</span><br><span class="line"><span class="hljs-keyword">if</span> (buildState.isInitializing()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.configurersAddedInInitializing.add(configurer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; getConfigurers() &#123;</span><br><span class="line">List&lt;SecurityConfigurer&lt;O, B&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs : <span class="hljs-keyword">this</span>.configurers.values()) &#123;</span><br><span class="line">result.addAll(configs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个就是这个 add 方法，这相当于是在收集所有的配置类。将所有的 xxxConfigure 收集起来存储到 configurers 中，将来再统一初始化并配置，configurers 本身是一个 LinkedHashMap ，key 是配置类的 class，value 是一个集合，集合里边放着 xxxConfigure 配置类。当需要对这些配置类进行集中配置的时候，会通过 getConfigurers 方法获取配置类，这个获取过程就是把 LinkedHashMap 中的 value 拿出来，放到一个集合中返回。</p><p>另一个方法就是 doBuild 方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">doBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (configurers) &#123;</span><br><span class="line">buildState = BuildState.INITIALIZING;</span><br><span class="line">beforeInit();</span><br><span class="line">init();</span><br><span class="line">buildState = BuildState.CONFIGURING;</span><br><span class="line">beforeConfigure();</span><br><span class="line">configure();</span><br><span class="line">buildState = BuildState.BUILDING;</span><br><span class="line">O result = performBuild();</span><br><span class="line">buildState = BuildState.BUILT;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; configurers = getConfigurers();</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurers) &#123;</span><br><span class="line">configurer.init((B) <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurersAddedInInitializing) &#123;</span><br><span class="line">configurer.init((B) <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; configurers = getConfigurers();</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurers) &#123;</span><br><span class="line">configurer.configure((B) <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AbstractSecurityBuilder 类中，过滤器的构建被转移到 doBuild 方法上面了，不过在 AbstractSecurityBuilder 中只是定义了抽象的 doBuild 方法，具体的实现在 AbstractConfiguredSecurityBuilder。</p><p>doBuild 方法就是一边更新状态，进行进行初始化。</p><p>beforeInit 是一个预留方法，没有任何实现。</p><p>init 方法就是找到所有的 xxxConfigure，挨个调用其 init 方法进行初始化。</p><p>beforeConfigure 是一个预留方法，没有任何实现。</p><p>configure 方法就是找到所有的 xxxConfigure，挨个调用其 configure 方法进行配置。</p><p>最后则是 performBuild 方法，是真正的过滤器链构建方法，但是在 AbstractConfiguredSecurityBuilder 中 performBuild 方法只是一个抽象方法，具体的实现在它的子类中，也就是 WebSecurityConfigurer。</p><p><strong>SecurityBuilder<filter></filter></strong></p><p>SecurityBuilder 就是用来构建过滤器链的，在 HttpSecurity 实现 SecurityBuilder 时，传入的泛型就是 DefaultSecurityFilterChain，所以 SecurityBuilder#build 方法的功能很明确，就是用来构建一个过滤器链出来，但是那个过滤器链是 Spring Security 中的。在 WebSecurityConfigurerAdapter 中定义的泛型是 SecurityBuilder<filter>，所以最终构建的是一个普通 Filter，其实就是 FilterChainProxy，关于 FilterChainProxy ，大家可以参考<a href="https://mp.weixin.qq.com/s/EZsChg5YG0TBadU4q_CAnA" target="_blank" rel="noopener">深入理解 FilterChainProxy【源码篇】</a>。</filter></p><p><strong>WebSecurity</strong></p><p>WebSecurity 的核心逻辑集中在 performBuild 构建方法上，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Filter <span class="hljs-title">performBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Assert.state(</span><br><span class="line">!securityFilterChainBuilders.isEmpty(),</span><br><span class="line">() -&gt; <span class="hljs-string">"At least one SecurityBuilder&lt;? extends SecurityFilterChain&gt; needs to be specified. "</span></span><br><span class="line">+ <span class="hljs-string">"Typically this done by adding a @Configuration that extends WebSecurityConfigurerAdapter. "</span></span><br><span class="line">+ <span class="hljs-string">"More advanced users can invoke "</span></span><br><span class="line">+ WebSecurity.class.getSimpleName()</span><br><span class="line">+ <span class="hljs-string">".addSecurityFilterChainBuilder directly"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> chainSize = ignoredRequests.size() + securityFilterChainBuilders.size();</span><br><span class="line">List&lt;SecurityFilterChain&gt; securityFilterChains = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">chainSize);</span><br><span class="line"><span class="hljs-keyword">for</span> (RequestMatcher ignoredRequest : ignoredRequests) &#123;</span><br><span class="line">securityFilterChains.add(<span class="hljs-keyword">new</span> DefaultSecurityFilterChain(ignoredRequest));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityBuilder&lt;? extends SecurityFilterChain&gt; securityFilterChainBuilder : securityFilterChainBuilders) &#123;</span><br><span class="line">securityFilterChains.add(securityFilterChainBuilder.build());</span><br><span class="line">&#125;</span><br><span class="line">FilterChainProxy filterChainProxy = <span class="hljs-keyword">new</span> FilterChainProxy(securityFilterChains);</span><br><span class="line"><span class="hljs-keyword">if</span> (httpFirewall != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">filterChainProxy.setFirewall(httpFirewall);</span><br><span class="line">&#125;</span><br><span class="line">filterChainProxy.afterPropertiesSet();</span><br><span class="line">Filter result = filterChainProxy;</span><br><span class="line"><span class="hljs-keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.warn(<span class="hljs-string">"\n\n"</span></span><br><span class="line">+ <span class="hljs-string">"********************************************************************\n"</span></span><br><span class="line">+ <span class="hljs-string">"**********        Security debugging is enabled.       *************\n"</span></span><br><span class="line">+ <span class="hljs-string">"**********    This may include sensitive information.  *************\n"</span></span><br><span class="line">+ <span class="hljs-string">"**********      Do not use in a production system!     *************\n"</span></span><br><span class="line">+ <span class="hljs-string">"********************************************************************\n\n"</span>);</span><br><span class="line">result = <span class="hljs-keyword">new</span> DebugFilter(filterChainProxy);</span><br><span class="line">&#125;</span><br><span class="line">postBuildAction.run();</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来说一句，这里的 performBuild 方法只有一个功能，那就是构建 FilterChainProxy，如果你还不了解什么是 FilterChainProxy，可以参考松哥之前的介绍：<a href="https://mp.weixin.qq.com/s/EZsChg5YG0TBadU4q_CAnA" target="_blank" rel="noopener">深入理解 FilterChainProxy【源码篇】</a>。</p><p>把握住了这条主线，我们再来看方法的实现就很容易了。</p><ol><li>首先统计过滤器链的总条数，总条数包括两个方面，一个是 ignoredRequests，这是忽略的请求，通过 WebSecurity 配置的忽略请求，松哥之前介绍过，参见：<a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a>，另一个则是 securityFilterChainBuilders，也就是我们通过 HttpSecurity 配置的过滤器链，有几个就算几个。</li><li>创建 securityFilterChains 集合，并且遍历上面提到的两种类型的过滤器链，并将过滤器链放入 securityFilterChains 集合中。</li><li>我在<a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a>一文中介绍过，HttpSecurity 构建出来的过滤器链对象就是 DefaultSecurityFilterChain，所以可以直接将 build 结果放入 securityFilterChains 中，而 ignoredRequests 中保存的则需要重构一下才可以存入 securityFilterChains。</li><li>securityFilterChains 中有数据之后，接下来创建一个 FilterChainProxy。</li><li>给新建的 FilterChainProxy 配置上防火墙，防火墙的介绍参考松哥之前的：<a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a>。</li><li>最后我们返回的就是 FilterChainProxy 的实例。</li></ol><p>从这段分析中，我们可以看出来 WebSecurity 和 HttpSecurity 的区别：</p><ol><li>HttpSecurity 目的是构建过滤器链，一个 HttpSecurity 对象构建一条过滤器链，一个过滤器链中有 N 个过滤器，HttpSecurity 所做的事情实际上就是在配置这 N 个过滤器。</li><li>WebSecurity 目的是构建 FilterChainProxy，一个 FilterChainProxy 中包含有多个过滤器链和一个 Firewall。</li></ol><p>这就是 WebSecurity 的主要作用，核心方法是 performBuild，其他方法都比较简单，松哥就不一一解释了。</p><h2 id="3-WebSecurityConfigurerAdapter"><a href="#3-WebSecurityConfigurerAdapter" class="headerlink" title="3.WebSecurityConfigurerAdapter"></a>3.WebSecurityConfigurerAdapter</h2><p>最后我们再来看 WebSecurityConfigurerAdapter，由于 WebSecurityConfigurer 只是一个空接口，WebSecurityConfigurerAdapter 就是针对这个空接口提供一个具体的实现，最终目的还是为了方便你配置 WebSecurity。</p><p>WebSecurityConfigurerAdapter 中的方法比较多，但是根据我们前面的分析，提纲挈领的方法就两个，一个是 init，还有一个 configure(WebSecurity web)，其他方法都是为这两个方法服务的。那我们就来看下这两个方法：</p><p>先看 init 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">final</span> WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">final</span> HttpSecurity http = getHttp();</span><br><span class="line">web.addSecurityFilterChainBuilder(http).postBuildAction(() -&gt; &#123;</span><br><span class="line">FilterSecurityInterceptor securityInterceptor = http</span><br><span class="line">.getSharedObject(FilterSecurityInterceptor.class);</span><br><span class="line">web.securityInterceptor(securityInterceptor);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> HttpSecurity <span class="hljs-title">getHttp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (http != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> http;</span><br><span class="line">&#125;</span><br><span class="line">AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();</span><br><span class="line">localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class="line">AuthenticationManager authenticationManager = authenticationManager();</span><br><span class="line">authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class="line">Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects();</span><br><span class="line">http = <span class="hljs-keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class="line">sharedObjects);</span><br><span class="line"><span class="hljs-keyword">if</span> (!disableDefaults) &#123;</span><br><span class="line"><span class="hljs-comment">// @formatter:off</span></span><br><span class="line">http</span><br><span class="line">.csrf().and()</span><br><span class="line">.addFilter(<span class="hljs-keyword">new</span> WebAsyncManagerIntegrationFilter())</span><br><span class="line">.exceptionHandling().and()</span><br><span class="line">.headers().and()</span><br><span class="line">.sessionManagement().and()</span><br><span class="line">.securityContext().and()</span><br><span class="line">.requestCache().and()</span><br><span class="line">.anonymous().and()</span><br><span class="line">.servletApi().and()</span><br><span class="line">.apply(<span class="hljs-keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class="line">.logout();</span><br><span class="line"><span class="hljs-comment">// @formatter:on</span></span><br><span class="line">ClassLoader classLoader = <span class="hljs-keyword">this</span>.context.getClassLoader();</span><br><span class="line">List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =</span><br><span class="line">SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);</span><br><span class="line"><span class="hljs-keyword">for</span> (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;</span><br><span class="line">http.apply(configurer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">configure(http);</span><br><span class="line"><span class="hljs-keyword">return</span> http;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity)."</span>);</span><br><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.anyRequest().authenticated()</span><br><span class="line">.and()</span><br><span class="line">.formLogin().and()</span><br><span class="line">.httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init 方法可以算是这里的入口方法了：首先调用 getHttp 方法进行 HttpSecurity 的初始化。HttpSecurity 的初始化，实际上就是配置了一堆默认的过滤器，配置完成后，最终还调用了 configure(http) 方法，该方法又配置了一些拦截器，不过在实际开发中，我们经常会重写 configure(http) 方法，在松哥本系列前面的文章中，configure(http) 方法几乎都有重写。HttpSecurity 配置完成后，再将 HttpSecurity 放入 WebSecurity 中，保存在 WebSecurity 的 securityFilterChainBuilders 集合里，具体参见：<a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a>。</p><p>configure(WebSecurity web) 方法实际上是一个空方法，我们在实际开发中可能会重写该方法（参见 <a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a> 一文）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>这便是 WebSecurityConfigurerAdapter，整体上来说并不难，但是要和松哥前面几篇源码分析文章一起看，理解会更加深刻一些。</p><p>传送门：</p><ol><li><a href="https://mp.weixin.qq.com/s/EZsChg5YG0TBadU4q_CAnA" target="_blank" rel="noopener">深入理解 FilterChainProxy【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/PWIM9jgEB-F-m4Ove470wg" target="_blank" rel="noopener">深入理解 SecurityConfigurer 【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a></li></ol><p>好啦，小伙伴们要是有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们继续来撸 Spring Security 源码，今天来撸一个非常重要的 WebSecurityConfigurerAdapter。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>微人事被某培训机构盗去拉人头了，小伙伴们擦亮眼睛别上钩！</title>
    <link href="http://www.javaboy.org/2020/0728/vhr.html"/>
    <id>http://www.javaboy.org/2020/0728/vhr.html</id>
    <published>2020-07-28T13:28:00.000Z</published>
    <updated>2020-08-04T13:56:44.360Z</updated>
    
    <content type="html"><![CDATA[<p>国内的版权环境，真的一把心酸泪呀。</p><a id="more"></a><p>盗版软件、盗版书、盗版课程…层出不穷。而且侵权之后往往追责困难，受害者也是经常处于弱势，侵权者反而非常嚣张，例如松哥之前在知乎上看到的一个维权帖子，受害者韦东山费尽周折终于加上了侵权者的微信，结果对方上来就是一顿破口大骂：</p><p><img src="http://img.itboyhub.com/2020/07/20200723184239.png" alt></p><p>原帖参见：<a href="https://zhuanlan.zhihu.com/p/70704745" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/70704745</a></p><p>侵权者这么嚣张，这是因为侵权这事几乎就是一个零成本零风险的买卖，这和我们的大环境有很大关系。</p><p>我们时常会抱怨这个社会太浮躁，缺乏工匠精神，都想着赚快钱。但是你有没有想过，赚慢钱可能就饿死了。我举一个简单的例子，一个作者费时 5 年打磨了一本经典技术图书，结果图书上市一周，你就可以从国内一些盗版平台上下载 PDF 版本了，具体是哪些平台我不说大家也都知道。你可以跟平台举报，平台（可能）会封禁侵权资源，但是停一会，又会有另一个用户上传侵权资源到平台，你要不停的和平台去举报，对于普通人来说，这样的猫鼠游戏太累了。而如果你起诉，平台只需要协助你找到侵权者，其他的就跟平台没关系，这可能也是盗版泛滥的原因之一。</p><p>靠用户自发的支持正版显然是不现实的。长此以往，没人愿意花时间去打磨一本书了，所以你会看到市场上充斥了大量的快餐书。</p><p>松哥的《Spring Boot+Vue 全站开发实战》出版一周，网上就有了盗版的 PDF，更有甚者，有读者竟然把盗版的 PDF 发到松哥读者群里，我把他从群里移出来之后，他竟然告诉我他的 PDF 是自己买的，不是盗版：</p><p><img src="http://img.itboyhub.com/2020/07/20200723212020.png" alt></p><p>看到这个说辞我也是醉了，冰冻三尺非一日之寒，很多人都不知道什么是盗版，知识产权保护任重道远（这个老哥是从盗版者手上花钱买的）。</p><p>其实对于我的书的盗版，我一直是没太在意，因为大环境就是这样，我每天忙完后也没有时间去管，出版社可能会有一些维权操作，我就从来没管过，但是盗版发到我的读者群里这就非常过分了。</p><p>之前还有不知道什么培训机构，为了拉人头，拿慕课网的课程作诱饵：</p><p><img src="http://img.itboyhub.com/2020/07/20200723214334.png" alt><br><img src="http://img.itboyhub.com/2020/07/20200723213246.png" alt></p><blockquote><p>为什么我会在这个群里？他们拉人的广告发到我微信上了，我就潜伏进去看看他们到底多大胆。</p></blockquote><p>这样的事情真的太多了，可能有小伙伴都经历过。</p><p>之前，美国禁止哈尔滨工业大学等高校使用美国的工业软件 MATLAB，引发学术界和技术界的广泛讨论，很多人感叹为什么我们没有自己的 MATLAB，看到最多的回答，我们不缺研发的人才，但是缺乏这样的环境，环境当然是指多方面的，但是知识产权保护肯定是其中一方面。你总不能指望别人用爱发电吧！</p><p>老实说，盗版这个问题，如果你不是受害者，真的很难感受到受害者的心酸与无奈。</p><p>这不，最近有读者发消息告诉我有无良培训机构把松哥的资源拿去引流了：</p><p><img src="http://img.itboyhub.com/2020/07/20200723213845.png" alt></p><p>我看了一下，这是松哥开源的全套免费资料，都是我在公众号上公开的东西。但是在他这里领取变得非常麻烦，加好友后还要报名他的课程才能领取，这虽然对我不会造成物质上的损失，但是可能会败坏我的名声，因为松哥所有免费的资料，不管是电子书还是视频，只要是免费的，都没有任何套路，不用集赞也不用转发，直接领取即可。</p><p>所以今天要提醒大家，<strong>微人事的免费资料，在公众号【江南一点雨】后台回复回复 888 即可获取下载地址</strong>！</p><p>知识产权保护任重道远。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;国内的版权环境，真的一把心酸泪呀。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://www.javaboy.org/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>花式玩 Spring Security ，这样的用户定义方式你可能没见过！</title>
    <link href="http://www.javaboy.org/2020/0727/springsecurity-user-definition.html"/>
    <id>http://www.javaboy.org/2020/0727/springsecurity-user-definition.html</id>
    <published>2020-07-27T13:27:45.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候松哥会和大家分享一些 Spring Security 的冷门用法，不是为了显摆，只是希望大家能够从不同的角度加深对 Spring Security 的理解，这些冷门的用法非常有助于大家理解 Spring Security 的内部工作原理。我本来可以纯粹的去讲源码，讲原理，但是那样太枯燥了，所以我会尽量通过一些小的案例来帮助大家理解源码，这些案例的目的只是为了帮助大家理解 Spring Security 源码，仅此而已！所以请大家不要和我抬杠这些用户定义方式没用！</p><a id="more"></a><p>好啦，我今天要给大家表演一个绝活，就是花式定义用户对象。希望大家通过这几个案例，能够更好的理解 ProviderManager 的工作机制。</p><p>本文内容和上篇文章【<a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a>】内容强关联，所以强烈建议先学习下上篇文章内容，再来看本文，就会好理解很多。</p><h2 id="1-绝活一"><a href="#1-绝活一" class="headerlink" title="1.绝活一"></a>1.绝活一</h2><p>先来看如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">UserDetailsService <span class="hljs-title">us</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"sang"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Configuration</span></span><br><span class="line">    <span class="hljs-meta">@Order</span>(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="hljs-function">UserDetailsService <span class="hljs-title">us1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">            manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>, <span class="hljs-string">"aaa"</span>, <span class="hljs-string">"bbb"</span>).build());</span><br><span class="line">            <span class="hljs-keyword">return</span> manager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.antMatcher(<span class="hljs-string">"/foo/**"</span>)</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .anyRequest().hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(<span class="hljs-string">"/foo/login"</span>)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .userDetailsService(us1())</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Configuration</span></span><br><span class="line">    <span class="hljs-meta">@Order</span>(<span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="hljs-function">UserDetailsService <span class="hljs-title">us2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">            manager.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"user"</span>, <span class="hljs-string">"aaa"</span>, <span class="hljs-string">"bbb"</span>).build());</span><br><span class="line">            <span class="hljs-keyword">return</span> manager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.antMatcher(<span class="hljs-string">"/bar/**"</span>)</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .anyRequest().hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(<span class="hljs-string">"/bar/login"</span>)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable()</span><br><span class="line">                    .userDetailsService(us2());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过前面文章（<a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a>）的小伙伴应该明白，这里松哥定义了两个过滤器链，这个相信大家都能理解，不理解的话，参考<a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a>一文。</p><p>但是大家注意，在每一个过滤器链中，我都提供了一个 UserDetailsService 实例，然后在 configure(HttpSecurity http) 方法中，配置这个 UserDetailsService 实例。除了每一个过滤器链中都配置一个 UserDetailsService 之外，我还提供了一个 UserDetailsService 的 Bean，所以这里前前后后相当于一共有三个用户，那么我们登录时候，使用哪个用户可以登录成功呢？</p><p>先说结论：</p><ul><li>如果登录地址是 /foo/login，那么通过 sang 和 javaboy 两个用户可以登录成功。</li><li>如果登录地址是 /bar/login，那么通过 sang 和 江南一点雨 两个用户可以登录成功。</li></ul><p>也就是说，那个全局的，公共的 UserDetailsService 总是有效的，而针对不同过滤器链配置的 UserDetailsService 则只针对当前过滤器链生效。</p><blockquote><p>松哥这里为了方便，使用了基于内存的 UserDetailsService，当然你也可以替换为基于数据库的 UserDetailsService。</p></blockquote><p>那么接下来我们就来分析一下，为什么是这个样子？</p><h3 id="1-1-源码分析"><a href="#1-1-源码分析" class="headerlink" title="1.1 源码分析"></a>1.1 源码分析</h3><h4 id="1-1-1-全局-AuthenticationManager"><a href="#1-1-1-全局-AuthenticationManager" class="headerlink" title="1.1.1 全局 AuthenticationManager"></a>1.1.1 全局 AuthenticationManager</h4><p>首先大家注意，虽然我定义了两个过滤器链，但是在两个过滤器链的定义中，我都没有重写 configure(AuthenticationManagerBuilder auth) 方法，结合上篇文章，没有重写这个方法，就意味著 AuthenticationConfiguration 中提供的全局 AuthenticationManager 是有效的，也就是说，系统默认提供的 AuthenticationManager 将作为其他局部 AuthenticationManager 的 parent。</p><p>那么我们来看下全局的 AuthenticationManager 配置都配了啥？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">getAuthenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.authenticationManagerInitialized) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authenticationManager;</span><br><span class="line">&#125;</span><br><span class="line">AuthenticationManagerBuilder authBuilder = <span class="hljs-keyword">this</span>.applicationContext.getBean(AuthenticationManagerBuilder.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buildingAuthenticationManager.getAndSet(<span class="hljs-keyword">true</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthenticationManagerDelegator(authBuilder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (GlobalAuthenticationConfigurerAdapter config : globalAuthConfigurers) &#123;</span><br><span class="line">authBuilder.apply(config);</span><br><span class="line">&#125;</span><br><span class="line">authenticationManager = authBuilder.build();</span><br><span class="line"><span class="hljs-keyword">if</span> (authenticationManager == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">authenticationManager = getAuthenticationManagerBean();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.authenticationManagerInitialized = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> authenticationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局的配置中，有一步就是遍历 globalAuthConfigurers，遍历全局的 xxxConfigurer，并进行配置。全局的 xxxConfigurer 一共有三个，分别是：</p><ul><li>EnableGlobalAuthenticationAutowiredConfigurer</li><li>InitializeUserDetailsBeanManagerConfigurer</li><li>InitializeAuthenticationProviderBeanManagerConfigurer</li></ul><p>其中 InitializeUserDetailsBeanManagerConfigurer，看名字就是用来配置 UserDetailsService 的，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Order</span>(InitializeUserDetailsBeanManagerConfigurer.DEFAULT_ORDER)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitializeUserDetailsBeanManagerConfigurer</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">GlobalAuthenticationConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">auth.apply(<span class="hljs-keyword">new</span> InitializeUserDetailsManagerConfigurer());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitializeUserDetailsManagerConfigurer</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">GlobalAuthenticationConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (auth.isConfigured()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">UserDetailsService userDetailsService = getBeanOrNull(</span><br><span class="line">UserDetailsService.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (userDetailsService == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PasswordEncoder passwordEncoder = getBeanOrNull(PasswordEncoder.class);</span><br><span class="line">UserDetailsPasswordService passwordManager = getBeanOrNull(UserDetailsPasswordService.class);</span><br><span class="line">DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">provider.setUserDetailsService(userDetailsService);</span><br><span class="line"><span class="hljs-keyword">if</span> (passwordEncoder != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">provider.setPasswordEncoder(passwordEncoder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (passwordManager != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">provider.setUserDetailsPasswordService(passwordManager);</span><br><span class="line">&#125;</span><br><span class="line">provider.afterPropertiesSet();</span><br><span class="line">auth.authenticationProvider(provider);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，InitializeUserDetailsBeanManagerConfigurer 中定义了内部类，在其内部类的 configure 方法中，通过 getBeanOrNull 去从容器中查找 UserDetailsService 实例，查找到之后，创建 DaoAuthenticationProvider，并最终配置给 auth 对象。</p><p>这里的 getBeanOrNull 方法从容器中查找到的，实际上就是 Spring 容器中的 Bean，也就是我们一开始配置了 sang 用户的那个 Bean，这个 Bean 被交给了全局的 AuthenticationManager，也就是所有局部 AuthenticationManager 的 parent。</p><h4 id="1-1-2-局部-AuthenticationManager"><a href="#1-1-2-局部-AuthenticationManager" class="headerlink" title="1.1.2 局部 AuthenticationManager"></a>1.1.2 局部 AuthenticationManager</h4><p>通过上篇文章的学习，小伙伴们知道了所有 HttpSecurity 在构建的过程中，都会传递一个局部的 AuthenticationManagerBuilder 进来，这个局部的 AuthenticationManagerBuilder 一旦传进来就存入了共享对象中，以后需要用的时候再从共享对象中取出来，部分代码如下所示：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpSecurity</span><span class="hljs-params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationManagerBuilder authenticationBuilder,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(objectPostProcessor);</span><br><span class="line">Assert.notNull(authenticationBuilder, <span class="hljs-string">"authenticationBuilder cannot be null"</span>);</span><br><span class="line">setSharedObject(AuthenticationManagerBuilder.class, authenticationBuilder);</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> AuthenticationManagerBuilder <span class="hljs-title">getAuthenticationRegistry</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getSharedObject(AuthenticationManagerBuilder.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们在 HttpSecurity 中配置 UserDetailsService，实际上是给这个 AuthenticationManagerBuilder 配置的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpSecurity <span class="hljs-title">userDetailsService</span><span class="hljs-params">(UserDetailsService userDetailsService)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">getAuthenticationRegistry().userDetailsService(userDetailsService);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是局部 AuthenticationManager。</p><p>至此，整个流程就很清晰了。</p><p>松哥再结合下面这张图给大家解释下：</p><p><img src="http://img.itboyhub.com/2020/07/20200721164221.png" alt></p><p>每一个过滤器链都会绑定一个自己的 ProviderManager（即 AuthenticationManager 的实现），而每一个 ProviderManager 中都通过 DaoAuthenticationProvider 持有一个 UserDetailsService 对象，你可以简单理解为一个 ProviderManager 管理了一个 UserDetailsService，当我们开始认证的时候，首先由过滤器链所持有的局部 ProviderManager 去认证，要是认证失败了，则调用 ProviderManager 的 parent 再去认证，此时就会用到全局 AuthenticationManager 所持有的 UserDetailsService 对象了。</p><p>结合一开始的案例，例如你的登录地址是 <code>/foo/login</code>，如果你的登录用户是 sang/123，那么先去 HttpSecurity 的局部 ProviderManager 中去验证，结果验证失败（局部的 ProviderManager 中对应的用户是 javaboy），此时就会进入局部 ProviderManager 的 parent 中去认证，也就是全局认证，全局的 ProviderManager 中对应的用户就是 sang 了，此时就认证成功。</p><p>可能有点绕，这个过程大家结合上篇文章仔细品一品。</p><h2 id="2-绝活二"><a href="#2-绝活二" class="headerlink" title="2.绝活二"></a>2.绝活二</h2><p>再次修改 SecurityConfig 的定义，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">UserDetailsService <span class="hljs-title">us</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"sang"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Configuration</span></span><br><span class="line">    <span class="hljs-meta">@Order</span>(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="hljs-function">UserDetailsService <span class="hljs-title">us1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">            manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>, <span class="hljs-string">"aaa"</span>, <span class="hljs-string">"bbb"</span>).build());</span><br><span class="line">            <span class="hljs-keyword">return</span> manager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            auth.userDetailsService(us1());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.antMatcher(<span class="hljs-string">"/foo/**"</span>)</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .anyRequest().hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(<span class="hljs-string">"/foo/login"</span>)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Configuration</span></span><br><span class="line">    <span class="hljs-meta">@Order</span>(<span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="hljs-function">UserDetailsService <span class="hljs-title">us2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">            manager.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"user"</span>, <span class="hljs-string">"aaa"</span>, <span class="hljs-string">"bbb"</span>).build());</span><br><span class="line">            <span class="hljs-keyword">return</span> manager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            auth.userDetailsService(us2());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.antMatcher(<span class="hljs-string">"/bar/**"</span>)</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .anyRequest().hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .loginProcessingUrl(<span class="hljs-string">"/bar/login"</span>)</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面相比，这段代码的核心变化，就是我重写了 <code>configure(AuthenticationManagerBuilder auth)</code> 方法，根据上篇文章的介绍，重写了该方法之后，全局的 AuthenticationMananger 定义就失效了，也就意味着 sang 这个用户定义失效了，换言之，无论是 <code>/foo/login</code> 还是 <code>/bar/login</code>，使用 sang/123 现在都无法登录了。</p><p>在每一个 HttpSecurity 过滤器链中，我都重写了 <code>configure(AuthenticationManagerBuilder auth)</code> 方法，并且重新配置了 UserDetailsService，这个重写，相当于我在定义 parent 级别的 ProviderManager。而每一个 HttpSecurity 过滤器链则不再包含 UserDetailsService。</p><p>当用户登录时，先去找到 HttpSecurity 过滤器链中的 ProviderManager 去认证，结果认证失败，然后再找到 ProviderManager 的 parent 去认证，就成功了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>在实际开发中，这样配置你几乎不会见到，但是上面两个案例，可以让你更好的理解 Spring Security 的认证过程，小伙伴们可以仔细品一品～</p><p>好啦，本文就先说这么多，案例下载地址<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的时候松哥会和大家分享一些 Spring Security 的冷门用法，不是为了显摆，只是希望大家能够从不同的角度加深对 Spring Security 的理解，这些冷门的用法非常有助于大家理解 Spring Security 的内部工作原理。我本来可以纯粹的去讲源码，讲原理，但是那样太枯燥了，所以我会尽量通过一些小的案例来帮助大家理解源码，这些案例的目的只是为了帮助大家理解 Spring Security 源码，仅此而已！所以请大家不要和我抬杠这些用户定义方式没用！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>技术干货没人看，水文倒是火爆！</title>
    <link href="http://www.javaboy.org/2020/0724/tucao.html"/>
    <id>http://www.javaboy.org/2020/0724/tucao.html</id>
    <published>2020-07-24T13:27:29.000Z</published>
    <updated>2020-08-04T13:56:44.360Z</updated>
    
    <content type="html"><![CDATA[<p>这周松哥写了四篇源码解析文章，可能因为太干了，阅读量都不咋滴，周五就轻松一下，水一篇吧。水文一般阅读量都不错，不信大家比较下今天这篇文章和前面技术干货的阅读量～</p><a id="more"></a><p>松哥日常发原创技术，偶尔也会水一下，时间久了，我发现水文的阅读数普遍高于技术文章。</p><h2 id="1-看的人少为啥还要写"><a href="#1-看的人少为啥还要写" class="headerlink" title="1.看的人少为啥还要写"></a>1.看的人少为啥还要写</h2><p>为什么很多人喜欢看吹水的文章，我猜测可能是因为程序员工作本身已经比较累了，有的时候打开微信可能是想放松一下，学习干货太费脑子了，所以可能就想看篇水文休息一下，目前能想到的就是这个原因。</p><p>不过明知道技术文章写出来阅读量一般般，但是我还是会写。因为技术文章一方面给大家参考学习，另一方面也是我自己知识点的一个梳理总结，最坏的状态下，即使文章没人看，我自己还是有收获的，因为自己总结并且梳理了知识点，对自己的技术也是一个提升。<strong>一言以蔽之，即使小伙伴们不学，我自己也得学习呀</strong>。</p><p>自己日常学习，有心得一定要写下来，这样才会印象深刻，这是松哥这几年通过实践得出来的结论。</p><p>因为写的过程也是一个锻炼思维的过程。松哥之前面试过很多人，有的人逻辑思维很差，问他一个知识点，都是想到哪里说到哪里，毫无条理可言，这种情况要么就是他不懂这个知识点，要么就是从来没总结过。而有的人在回答的时候就显得思路非常清晰，一条一条，娓娓道来，这两种人高下立判。</p><p>当然，这是一个循序渐进的过程，写一篇文章你可能写不出这样的效果，但是坚持下去，不断总结提炼，慢慢就会形成自己的方法论。</p><p>很多小伙伴觉得我的视频讲的清晰，其实这都是平时写博客练出来的，我知道这个知识点要从哪个方面讲，大家更容易理解：</p><p><img src="http://img.itboyhub.com/2020/07/127-1.jpeg" alt></p><p>另外一个呢就是推销自己。</p><p>和在本地记笔记有一个很大的区别，写博客有一个推销自己的成分。推销自己的重要性，我想很多小伙伴都明白，你需要升职，需要加薪，那你得像别人证明自己，这个证明的过程其实就是一个推销的过程。而博客，就是你长期以来技术积累的一个证明，在自我推销的时候是一个非常有力的证据。</p><p>就像我，很多小伙伴在简单的看过几集试看视频甚至连试看视频都没看，就选择购买我录制的 <a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">Spring Boot + Vue 视频教程</a>，这就是因为我前期通过写博客推销自己，获得了小伙伴的认可，要是没有没有前面推销自己的这个过程，我现在说我录制了一套很棒的视频教程，估计也没有人买，为啥？第一，我说这句话估计都没几个人能听到，因为大家都不认识我；第二，即使你知道有这套视频，但是因为前期不了解，所以你可能对视频的质量将信将疑。</p><p>这就是自我推销的重要性，把自己推销出去后，很多事情做起来就都非常容易了，找工作只是一个小 case。</p><p>所以，技术干货虽然看的人不多，但是我还是会一直写下去，因为这也是给我自己的一个交代。</p><h2 id="2-整一个好看的技术干货不容易"><a href="#2-整一个好看的技术干货不容易" class="headerlink" title="2.整一个好看的技术干货不容易"></a>2.整一个好看的技术干货不容易</h2><p>不过话说回来，完全自己闷头写不关心阅读数也是不可能的，因为阅读数也在一定程度上体现了小伙伴们对你的认可，所以既要脚踏实地，也要抬头看路。</p><p>纯粹的技术干货，像源码解读这种，想要做的生动有趣，不是不可以，只是需要投入的精力太大了。松哥之前在 B 站上看到一个 up 主，用动画讲解 Java 基础理论，动画做的非常棒，一看就知道花费了巨大的时间精力。但是就发了两三个视频就断更了，虽然感到很遗憾，不过我也非常理解，毕竟投入太高，入不敷出。由个人做这种高投入低产出的事情是很难持久的，毕竟用爱发电是不现实的。</p><p>当然，这并不意味着写文章就是一件非常容易的事情。一篇技术文章，案例你要提前设计，要去想什么样的案例能让读者最大程度上理解这个知识点；什么样的顺序，能让读者循序渐进一步一步弄懂这个知识点，所以一篇技术干货，都得好几个小时才能产出，我一般周末两天都是花在码字上的，精力投入还是非常大的。</p><p>松哥和一些公众号大佬交流了一下，发现有不少号主都面临类似的问题。天天水，读者会说你这个号太水了，愤而取关；天天发干货，又没有人愿意点开看，所以很多公众号主左右为难，都希望在两者中寻找一个平衡，不过这个平衡并不容易把握。</p><h2 id="3-坚持走自己的路"><a href="#3-坚持走自己的路" class="headerlink" title="3.坚持走自己的路"></a>3.坚持走自己的路</h2><p>虽然阅读数多多少少会影响写作的激情，但是老实说我真不想追热点，我只想写电子书，赶紧把 Spring Security 系列连载完然后去整理成电子书，那才是有成就感的事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这周松哥写了四篇源码解析文章，可能因为太干了，阅读量都不咋滴，周五就轻松一下，水一篇吧。水文一般阅读量都不错，不信大家比较下今天这篇文章和前面技术干货的阅读量～&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://www.javaboy.org/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 AuthenticationManagerBuilder 【源码篇】</title>
    <link href="http://www.javaboy.org/2020/0723/springsecurity-authenticationmanagerbuilder.html"/>
    <id>http://www.javaboy.org/2020/0723/springsecurity-authenticationmanagerbuilder.html</id>
    <published>2020-07-23T13:27:01.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>咱们继续来撸 Spring Security 源码。</p><a id="more"></a><p>前面和大家分享了 SecurityBuilder 以及它的一个重要实现 HttpSecurity，在 SecurityBuilder 的实现类里边，还有一个重要的分支，那就是 AuthenticationManagerBuilder，AuthenticationManagerBuilder 看名字就知道是用来构建 AuthenticationManager 的，所以今天我们就来看一看 AuthenticationManager 到底是怎么构建的。</p><h2 id="1-初步理解"><a href="#1-初步理解" class="headerlink" title="1.初步理解"></a>1.初步理解</h2><p>在 Spring Security 中，用来处理身份认证的类是 AuthenticationManager，我们也称之为认证管理器。</p><p>AuthenticationManager 中规范了 Spring Security 的过滤器要如何执行身份认证，并在身份认证成功后返回一个经过认证的 Authentication 对象。AuthenticationManager 是一个接口，我们可以自定义它的实现，但是通常我们使用更多的是系统提供的 ProviderManager。</p><h3 id="1-1-ProviderManager"><a href="#1-1-ProviderManager" class="headerlink" title="1.1 ProviderManager"></a>1.1 ProviderManager</h3><p>ProviderManager 是的最常用的 AuthenticationManager 实现类。</p><p>ProviderManager 管理了一个 AuthenticationProvider 列表，每个 AuthenticationProvider 都是一个认证器，不同的 AuthenticationProvider 用来处理不同的 Authentication 对象的认证。一次完整的身份认证流程可能会经过多个 AuthenticationProvider。</p><p>ProviderManager 相当于代理了多个 AuthenticationProvider，他们的关系如下图：</p><p><img src="http://img.itboyhub.com/2020/07/20200709222237.png" alt></p><h3 id="1-2-AuthenticationProvider"><a href="#1-2-AuthenticationProvider" class="headerlink" title="1.2 AuthenticationProvider"></a>1.2 AuthenticationProvider</h3><p>AuthenticationProvider 定义了 Spring Security 中的验证逻辑，我们来看下 AuthenticationProvider 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，AuthenticationProvider 中就两个方法：</p><ul><li>authenticate 方法用来做验证，就是验证用户身份。</li><li>supports 则用来判断当前的 AuthenticationProvider 是否支持对应的 Authentication。</li></ul><p>在一次完整的认证中，可能包含多个 AuthenticationProvider，而这多个 AuthenticationProvider 则由 ProviderManager 进行统一管理，具体可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a>。</p><p>最常用的 AuthenticationProvider 实现类是 DaoAuthenticationProvider。</p><h3 id="1-3-Parent"><a href="#1-3-Parent" class="headerlink" title="1.3 Parent"></a>1.3 Parent</h3><p>每一个 ProviderManager 管理多个 AuthenticationProvider，同时每一个 ProviderManager 都可以配置一个 parent，如果当前的 ProviderManager 中认证失败了，还可以去它的 parent 中继续执行认证，所谓的 parent 实例，一般也是 ProviderManager，也就是 ProviderManager 的 parent 还是 ProviderManager。可以参考如下架构图：</p><p><img src="http://img.itboyhub.com/2020/07/20200721164221.png" alt></p><p><strong>从上面的分析中大家可以看出，AuthenticationManager 的初始化会分为两块，一个全局的 AuthenticationManager，也就是 parent，另一个则是局部的 AuthenticationManager。先给大家一个结论，一个系统中，我们可以配置多个 HttpSecurity（参见<a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a>），而每一个 HttpSecurity 都有一个对应的 AuthenticationManager 实例（局部 AuthenticationManager），这些局部的 AuthenticationManager 实例都有一个共同的 parent，那就是全局的 AuthenticationManager。</strong></p><p>接下来，我们通过源码分析来验证我们上面的结论。</p><p>本文内容和上篇文章紧密相关，如果大家还没看过上篇源码分析文章，一定点击超链接先看下。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><p>在上篇文章中，松哥已经和大家分析了 SecurityBuilder 的几个常见实现类 AbstractSecurityBuilder、AbstractConfiguredSecurityBuilder、HttpSecurityBuilder，本文关于这几个类我就不重复介绍了。</p><p>我们直接来看 AuthenticationManagerBuilder，先来看它的一个继承关系：</p><p><img src="http://img.itboyhub.com/2020/07/AuthenticationManagerBuilder.png" alt></p><p>可以看到，【<a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">上篇文章</a>】中介绍的全部都是 AuthenticationManagerBuilder 的父类，所以 AuthenticationManagerBuilder 已经自动具备了其父类的功能。</p><p>AuthenticationManagerBuilder 的源码比较长，我们来看几个关键的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationManagerBuilder</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">AbstractConfiguredSecurityBuilder</span>&lt;<span class="hljs-title">AuthenticationManager</span>, <span class="hljs-title">AuthenticationManagerBuilder</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">ProviderManagerBuilder</span>&lt;<span class="hljs-title">AuthenticationManagerBuilder</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AuthenticationManagerBuilder</span><span class="hljs-params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(objectPostProcessor, <span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManagerBuilder <span class="hljs-title">parentAuthenticationManager</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationManager authenticationManager)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authenticationManager <span class="hljs-keyword">instanceof</span> ProviderManager) &#123;</span><br><span class="line">eraseCredentials(((ProviderManager) authenticationManager)</span><br><span class="line">.isEraseCredentialsAfterAuthentication());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.parentAuthenticationManager = authenticationManager;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> InMemoryUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; <span class="hljs-title">inMemoryAuthentication</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> apply(<span class="hljs-keyword">new</span> InMemoryUserDetailsManagerConfigurer&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> JdbcUserDetailsManagerConfigurer&lt;AuthenticationManagerBuilder&gt; <span class="hljs-title">jdbcAuthentication</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> apply(<span class="hljs-keyword">new</span> JdbcUserDetailsManagerConfigurer&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T extends UserDetailsService&gt; <span class="hljs-function">DaoAuthenticationConfigurer&lt;AuthenticationManagerBuilder, T&gt; <span class="hljs-title">userDetailsService</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">T userDetailsService)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.defaultUserDetailsService = userDetailsService;</span><br><span class="line"><span class="hljs-keyword">return</span> apply(<span class="hljs-keyword">new</span> DaoAuthenticationConfigurer&lt;&gt;(</span><br><span class="line">userDetailsService));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> ProviderManager <span class="hljs-title">performBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isConfigured()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"No authenticationProviders and no parentAuthenticationManager defined. Returning null."</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">ProviderManager providerManager = <span class="hljs-keyword">new</span> ProviderManager(authenticationProviders,</span><br><span class="line">parentAuthenticationManager);</span><br><span class="line"><span class="hljs-keyword">if</span> (eraseCredentials != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">providerManager.setEraseCredentialsAfterAuthentication(eraseCredentials);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (eventPublisher != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">providerManager.setAuthenticationEventPublisher(eventPublisher);</span><br><span class="line">&#125;</span><br><span class="line">providerManager = postProcess(providerManager);</span><br><span class="line"><span class="hljs-keyword">return</span> providerManager;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，我们可以通过调用 parentAuthenticationManager 方法来给一个 AuthenticationManager 设置 parent。</li><li>inMemoryAuthentication、jdbcAuthentication 以及 userDetailsService 几个方法松哥在之前的文章中都已经介绍过了（<a href="https://mp.weixin.qq.com/s/PWIM9jgEB-F-m4Ove470wg" target="_blank" rel="noopener">深入理解 SecurityConfigurer 【源码篇】</a>），作用就是为了配置数据源，这里就不再赘述。</li><li>最后就是 performBuild 方法，这个方法的作用就是根据当前 AuthenticationManagerBuilder 来构建一个 AuthenticationManager 出来，AuthenticationManager 本身是一个接口，它的默认实现是 ProviderManager，所以这里构建的就是 ProviderManager。在构建 ProviderManager 时，一方面传入 authenticationProviders，就是该 ProviderManager 所管理的所有的 AuthenticationProvider，另一方面传入 ProviderManager 的 parent（其实也是一个 ProviderManager）。</li></ol><p>整体来说，这段代码还是很好理解的，松哥在之前的文章中和大家介绍过 Spring Security 整合多个数据源，那个时候我们自己配置 ProviderManager，跟这里的方式类似，具体可以参考：<a href="https://mp.weixin.qq.com/s/sF4vPZQv7rtBYhBhmONJ5w" target="_blank" rel="noopener">Spring Security 可以同时对接多个用户表？</a>。</p><p>不过自己配置有一个问题就是我们没有配置 ProviderManager 的 parent，没有配置的话，如果当前 ProviderManager 中认证失败的话，就直接抛出失败，而不会去 parent 中再次进行认证了（一般来说也不需要，如果系统比较复杂的话，可能需要）。</p><p>AuthenticationManagerBuilder 还有一个实现类叫做 DefaultPasswordEncoderAuthenticationManagerBuilder，作为内部类分别定义在 WebSecurityConfigurerAdapter 和 AuthenticationConfiguration 中，不过 DefaultPasswordEncoderAuthenticationManagerBuilder 的内容比较简单，重写了父类 AuthenticationManagerBuilder 的几个方法，配置了新的 PasswordEncoder，无他，所以这里我就不列出这个的源码了，感兴趣的小伙伴可以自行查看。但是这并不是说 DefaultPasswordEncoderAuthenticationManagerBuilder 就不重要了，因为在后面的使用中，基本上都是使用 DefaultPasswordEncoderAuthenticationManagerBuilder 来构建 AuthenticationManagerBuilder。</p><p>好啦，这就是 AuthenticationManagerBuilder。</p><p>那么是什么时候通过 AuthenticationManagerBuilder 来构建 AuthenticationManager 的呢？</p><p>这就涉及到我们的老熟人 WebSecurityConfigurerAdapter 了。当然，关于 WebSecurityConfigurerAdapter 本身的初始化过程，松哥在后面会专门写文章介绍，今天我们主要来看下如何在 WebSecurityConfigurerAdapter 中开启 AuthenticationManager 的初始化的。</p><h3 id="2-1-初始化流程"><a href="#2-1-初始化流程" class="headerlink" title="2.1 初始化流程"></a>2.1 初始化流程</h3><p>在初始化流程中，松哥得先和大家介绍一个 AuthenticationConfiguration 类。这个类大家可以当作是一个全局被配类来理解，里边都是一些全局属性的配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-meta">@Import</span>(ObjectPostProcessorConfiguration.class)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationConfiguration</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManagerBuilder <span class="hljs-title">authenticationManagerBuilder</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectPostProcessor&lt;Object&gt; objectPostProcessor, ApplicationContext context)</span> </span>&#123;</span><br><span class="line">LazyPasswordEncoder defaultPasswordEncoder = <span class="hljs-keyword">new</span> LazyPasswordEncoder(context);</span><br><span class="line">AuthenticationEventPublisher authenticationEventPublisher = getBeanOrNull(context, AuthenticationEventPublisher.class);</span><br><span class="line"></span><br><span class="line">DefaultPasswordEncoderAuthenticationManagerBuilder result = <span class="hljs-keyword">new</span> DefaultPasswordEncoderAuthenticationManagerBuilder(objectPostProcessor, defaultPasswordEncoder);</span><br><span class="line"><span class="hljs-keyword">if</span> (authenticationEventPublisher != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">result.authenticationEventPublisher(authenticationEventPublisher);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GlobalAuthenticationConfigurerAdapter <span class="hljs-title">enableGlobalAuthenticationAutowiredConfigurer</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EnableGlobalAuthenticationAutowiredConfigurer(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InitializeUserDetailsBeanManagerConfigurer <span class="hljs-title">initializeUserDetailsBeanManagerConfigurer</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InitializeUserDetailsBeanManagerConfigurer(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InitializeAuthenticationProviderBeanManagerConfigurer <span class="hljs-title">initializeAuthenticationProviderBeanManagerConfigurer</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InitializeAuthenticationProviderBeanManagerConfigurer(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">getAuthenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.authenticationManagerInitialized) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authenticationManager;</span><br><span class="line">&#125;</span><br><span class="line">AuthenticationManagerBuilder authBuilder = <span class="hljs-keyword">this</span>.applicationContext.getBean(AuthenticationManagerBuilder.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.buildingAuthenticationManager.getAndSet(<span class="hljs-keyword">true</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthenticationManagerDelegator(authBuilder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (GlobalAuthenticationConfigurerAdapter config : globalAuthConfigurers) &#123;</span><br><span class="line">authBuilder.apply(config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">authenticationManager = authBuilder.build();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (authenticationManager == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">authenticationManager = getAuthenticationManagerBean();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">this</span>.authenticationManagerInitialized = <span class="hljs-keyword">true</span>;</span><br><span class="line"><span class="hljs-keyword">return</span> authenticationManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObjectPostProcessor</span><span class="hljs-params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.objectPostProcessor = objectPostProcessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableGlobalAuthenticationAutowiredConfigurer</span> <span class="hljs-keyword">extends</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">GlobalAuthenticationConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ApplicationContext context;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Log logger = LogFactory</span><br><span class="line">.getLog(EnableGlobalAuthenticationAutowiredConfigurer.class);</span><br><span class="line"></span><br><span class="line">EnableGlobalAuthenticationAutowiredConfigurer(ApplicationContext context) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> </span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; beansWithAnnotation = context</span><br><span class="line">.getBeansWithAnnotation(EnableGlobalAuthentication.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Eagerly initializing "</span> + beansWithAnnotation);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这里首先构建了一个 AuthenticationManagerBuilder 实例，这个实例就是用来构建全局 AuthenticationManager 的 AuthenticationManagerBuilder，具体的构建过程在下面的 getAuthenticationManager 方法中。不过这里的这个全局的 AuthenticationManagerBuilder 并非总是有用，为什么这么说呢？且看松哥下面的的分析。</li><li>另外还有一些 initializeXXX 方法，用来构建全局的 UserDetailService 和 AuthenticationProvider，这些方法小伙伴可以作为一个了解，因为正常情况下是不会用到这几个 Bean 的，只有当 getAuthenticationManager 方法被调用时，这些默认的 Bean 才会被配置，而 getAuthenticationManager 方法被调用，意味着我们要使用系统默认配置的 AuthenticationManager 作为 parent，而在实际使用中，我们一般不会使用系统默认配置的 AuthenticationManager 作为 parent，我们自己多多少少都会重新定制一下。</li></ol><p><strong>这就是 AuthenticationConfiguration 的主要功能，它主要是提供了一些全局的 Bean，这些全局的 Bean 虽然一定会初始化，但是并非一定用到。</strong></p><p>那么到底什么时候用到，什么时候用不到，这就和 WebSecurityConfigurerAdapter 有关了，在 WebSecurityConfigurerAdapter 中有三个重要的方法涉及到 AuthenticationManager 的初始化问题，第一个是 setApplicationContext 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.context = context;</span><br><span class="line">ObjectPostProcessor&lt;Object&gt; objectPostProcessor = context.getBean(ObjectPostProcessor.class);</span><br><span class="line">LazyPasswordEncoder passwordEncoder = <span class="hljs-keyword">new</span> LazyPasswordEncoder(context);</span><br><span class="line">authenticationBuilder = <span class="hljs-keyword">new</span> DefaultPasswordEncoderAuthenticationManagerBuilder(objectPostProcessor, passwordEncoder);</span><br><span class="line">localConfigureAuthenticationBldr = <span class="hljs-keyword">new</span> DefaultPasswordEncoderAuthenticationManagerBuilder(objectPostProcessor, passwordEncoder) &#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManagerBuilder <span class="hljs-title">eraseCredentials</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> eraseCredentials)</span> </span>&#123;</span><br><span class="line">authenticationBuilder.eraseCredentials(eraseCredentials);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.eraseCredentials(eraseCredentials);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManagerBuilder <span class="hljs-title">authenticationEventPublisher</span><span class="hljs-params">(AuthenticationEventPublisher eventPublisher)</span> </span>&#123;</span><br><span class="line">authenticationBuilder.authenticationEventPublisher(eventPublisher);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationEventPublisher(eventPublisher);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，创建了两个几乎一摸一样的 AuthenticationManagerBuilder 实例，为什么会有两个呢？第一个 authenticationBuilder 是一个局部的 AuthenticationManagerBuilder，将来会传入 HttpSecurity 中去构建局部的 AuthenticationManager；第二个 localConfigureAuthenticationBldr 则是一个用来构建全局 AuthenticationManager 的 AuthenticationManagerBuilder。</p><p><strong>有小伙伴会问了，构建全局的 AuthenticationManager 不是一开始就在 AuthenticationConfiguration 中创建了吗？为什么这里还有一个？是的，当前这个 localConfigureAuthenticationBldr 是可以禁用的，如果禁用了，就会使用 AuthenticationConfiguration 中提供的 AuthenticationManagerBuilder，如果没禁用，就使用 localConfigureAuthenticationBldr 来构建全局的 AuthenticationManager。</strong></p><p>另一个方法则是 getHttp 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> HttpSecurity <span class="hljs-title">getHttp</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (http != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> http;</span><br><span class="line">&#125;</span><br><span class="line">AuthenticationEventPublisher eventPublisher = getAuthenticationEventPublisher();</span><br><span class="line">localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class="line">AuthenticationManager authenticationManager = authenticationManager();</span><br><span class="line">authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class="line">Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects = createSharedObjects();</span><br><span class="line">http = <span class="hljs-keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class="line">sharedObjects);</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line"><span class="hljs-keyword">return</span> http;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getHttp 方法中，会首先调用 authenticationManager 方法去获取一个全局的 AuthenticationManager，并设置给 authenticationBuilder 作为 parent，然后在构建 HttpSecurity 时将 authenticationBuilder 传入进去。</p><p>那么接下来就是 authenticationManager() 方法到底是怎么执行的了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!authenticationManagerInitialized) &#123;</span><br><span class="line">configure(localConfigureAuthenticationBldr);</span><br><span class="line"><span class="hljs-keyword">if</span> (disableLocalConfigureAuthenticationBldr) &#123;</span><br><span class="line">authenticationManager = authenticationConfiguration</span><br><span class="line">.getAuthenticationManager();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">authenticationManager = localConfigureAuthenticationBldr.build();</span><br><span class="line">&#125;</span><br><span class="line">authenticationManagerInitialized = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> authenticationManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.disableLocalConfigureAuthenticationBldr = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果 AuthenticationManager 还没初始化，那就先进行初始化。初始化首先调用 configure 方法，默认情况下，configure 方法里边会把 disableLocalConfigureAuthenticationBldr 变量设置为 true，这样接下来就会进入到 if 分支中了。这个 configure 方法不知道大家有没有觉得眼熟？我们在自定义的 SecurityConfig 配置类中，一般都是要重写该方法的，一旦重写了这个方法，那么 disableLocalConfigureAuthenticationBldr 变量就不会变为 true，依然是 false，这样在获取 authenticationManager 的时候就会进入到 else 分支中。</p><p>如果进入到 if 分支中，意味着开发者并没有重写 configure 方法，AuthenticationManagerBuilder 就使用默认的，大家可以看到，此时就是调用 authenticationConfiguration.getAuthenticationManager() 方法去获取 AuthenticationManager，也就是一开始我们说的那个全局的配置。</p><p>如果开发者重写了 configure 方法，意味着开发者对 AuthenticationManagerBuilder 进行了一些定制，此时就不能继续使用 AuthenticationConfiguration 中配置的默认的的 AuthenticationManager 了，而要根据开发者 的具体配置，调用 localConfigureAuthenticationBldr.build 方法去构建新的 AuthenticationManager。</p><p>一言以蔽之，AuthenticationConfiguration 中的配置有没有用上，全看开发者有没有重写 <code>configure(AuthenticationManagerBuilder auth)</code> 方法，重写了，就用 localConfigureAuthenticationBldr 来构建 parent 级别的 AuthenticationManager，没重写，就用 AuthenticationConfiguration 中的方法来构建。</p><p>这是扮演 parent 角色的 AuthenticationManager 的构建过程，当然，parent 并非必须，如果你没有这个需求的话，也可以不配置 parent。</p><p>最后我们再来看下局部的 AuthenticationManager 是如何构建的，也就是和 HttpSecurity 绑定的那个 AuthenticationManager。</p><p>根据前面的介绍，HttpSecurity 在构建的时候就会传入 AuthenticationManagerBuilder，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpSecurity</span><span class="hljs-params">(ObjectPostProcessor&lt;Object&gt; objectPostProcessor,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationManagerBuilder authenticationBuilder,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Map&lt;Class&lt;?&gt;, Object&gt; sharedObjects)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(objectPostProcessor);</span><br><span class="line">Assert.notNull(authenticationBuilder, <span class="hljs-string">"authenticationBuilder cannot be null"</span>);</span><br><span class="line">setSharedObject(AuthenticationManagerBuilder.class, authenticationBuilder);</span><br><span class="line"><span class="hljs-comment">//省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入进来的 AuthenticationManagerBuilder ，二话不说就存到 SharedObject 里边去了，这个根据官方的注释，说它是一个在不同 Configurer 中共享的对象的工具，其实你可以理解为一个缓存，现在存进去，需要的时候再取出来。</p><p>取出来的方法，在 HttpSecurity 中也定义好了，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> AuthenticationManagerBuilder <span class="hljs-title">getAuthenticationRegistry</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getSharedObject(AuthenticationManagerBuilder.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HttpSecurity 中，凡是涉及到 AuthenticationManager 配置的，都会调用到 getAuthenticationRegistry 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpSecurity <span class="hljs-title">userDetailsService</span><span class="hljs-params">(UserDetailsService userDetailsService)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">getAuthenticationRegistry().userDetailsService(userDetailsService);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpSecurity <span class="hljs-title">authenticationProvider</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationProvider authenticationProvider)</span> </span>&#123;</span><br><span class="line">getAuthenticationRegistry().authenticationProvider(authenticationProvider);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在 HttpSecurity 的 beforeConfigure 方法中完成构建：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeConfigure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">setSharedObject(AuthenticationManager.class, getAuthenticationRegistry().build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，无论是全局的 AuthenticationManager，还是局部的 AuthenticationManager，就都和大家捋一遍了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>有的小伙伴可能对这里的全局、局部不是特别理解，我再给大家稍微总结一下。</p><p>为什么每一个 HttpSecurity 都要绑定一个 AuthenticationManager？</p><p>因为在同一个系统中，我们可以回配置多个 HttpSecurity，也就是多个不同的过滤器链（参见<a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a>一文），既然有多个过滤器链，每一个请求到来的时候，它需要进入到某一个过滤器链中去处理，每一个过滤器链中又会涉及到 AuthenticationProvider 的管理，不同过滤器链中的 AuthenticationProvider 肯定是各自管理最为合适，也就是不同的过滤器链中都有一个绑定的 AuthenticationManager，即每一个 HttpSecurity 都要绑定一个 AuthenticationManager。</p><p>本文略有难度，可能有点绕，有没看懂的地方，欢迎大家留言讨论。</p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;咱们继续来撸 Spring Security 源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 HttpSecurity【源码篇】</title>
    <link href="http://www.javaboy.org/2020/0722/springsecurity-httpsecurity.html"/>
    <id>http://www.javaboy.org/2020/0722/springsecurity-httpsecurity.html</id>
    <published>2020-07-22T13:26:48.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>HttpSecurity 也是 Spring Security 中的重要一环。我们平时所做的大部分 Spring Security 配置也都是基于 HttpSecurity 来配置的。因此我们有必要从源码的角度来理解下 HttpSecurity 到底干了啥？</p><a id="more"></a><h2 id="1-抽丝剥茧"><a href="#1-抽丝剥茧" class="headerlink" title="1.抽丝剥茧"></a>1.抽丝剥茧</h2><p>首先我们来看下 HttpSecurity 的继承关系图：</p><p><img src="http://img.itboyhub.com/2020/07/HttpSecurity.png" alt></p><p>可以看到，HttpSecurity 继承自 AbstractConfiguredSecurityBuilder，同时实现了 SecurityBuilder 和 HttpSecurityBuilder 两个接口。</p><p>我们来看下 HttpSecurity 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpSecurity</span> <span class="hljs-keyword">extends</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">AbstractConfiguredSecurityBuilder</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">HttpSecurity</span>&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>&gt;,</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">HttpSecurity</span>&gt; </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里每一个类都带有泛型，看得人有点眼花缭乱。</p><p>我把这个泛型类拿出来和大家讲一下，小伙伴们就明白了。</p><p>泛型主要是两个，DefaultSecurityFilterChain 和 HttpSecurity，HttpSecurity 就不用说了，这是我们今天的主角，那么 DefaultSecurityFilterChain 是干嘛的？</p><p>这我们就得从 SecurityFilterChain 说起了。</p><h3 id="1-1-SecurityFilterChain"><a href="#1-1-SecurityFilterChain" class="headerlink" title="1.1 SecurityFilterChain"></a>1.1 SecurityFilterChain</h3><p>先来看定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityFilterChain</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(HttpServletRequest request)</span></span>;</span><br><span class="line"><span class="hljs-function">List&lt;Filter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityFilterChain 其实就是我们平时所说的 Spring Security 中的过滤器链，它里边定义了两个方法，一个是 matches 方法用来匹配请求，另外一个 getFilters 方法返回一个 List 集合，集合中放着 Filter 对象，当一个请求到来时，用 matches 方法去比较请求是否和当前链吻合，如果吻合，就返回 getFilters 方法中的过滤器，那么当前请求会逐个经过 List 集合中的过滤器。这一点，小伙伴们可以回忆前面【深入理解 FilterChainProxy【源码篇】】一文。</p><p>SecurityFilterChain 接口只有一个实现类，那就是 DefaultSecurityFilterChain：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSecurityFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityFilterChain</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Log logger = LogFactory.getLog(DefaultSecurityFilterChain.class);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RequestMatcher requestMatcher;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Filter&gt; filters;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultSecurityFilterChain</span><span class="hljs-params">(RequestMatcher requestMatcher, Filter... filters)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>(requestMatcher, Arrays.asList(filters));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultSecurityFilterChain</span><span class="hljs-params">(RequestMatcher requestMatcher, List&lt;Filter&gt; filters)</span> </span>&#123;</span><br><span class="line">logger.info(<span class="hljs-string">"Creating filter chain: "</span> + requestMatcher + <span class="hljs-string">", "</span> + filters);</span><br><span class="line"><span class="hljs-keyword">this</span>.requestMatcher = requestMatcher;</span><br><span class="line"><span class="hljs-keyword">this</span>.filters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(filters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RequestMatcher <span class="hljs-title">getRequestMatcher</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> requestMatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Filter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> filters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> requestMatcher.matches(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"[ "</span> + requestMatcher + <span class="hljs-string">", "</span> + filters + <span class="hljs-string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultSecurityFilterChain 只是对 SecurityFilterChain 中的方法进行了实现，并没有特别值得说的地方，松哥也就不啰嗦了。</p><p><strong>那么从上面的介绍中，大家可以看到，DefaultSecurityFilterChain 其实就相当于是 Spring Security 中的过滤器链，一个 DefaultSecurityFilterChain 代表一个过滤器链，如果系统中存在多个过滤器链，则会存在多个 DefaultSecurityFilterChain 对象。</strong></p><p>接下来我们把 HttpSecurity 的这几个父类捋一捋。</p><h3 id="1-2-SecurityBuilder"><a href="#1-2-SecurityBuilder" class="headerlink" title="1.2 SecurityBuilder"></a>1.2 SecurityBuilder</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-function">O <span class="hljs-title">build</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SecurityBuilder 就是用来构建过滤器链的，在 HttpSecurity 实现 SecurityBuilder 时，传入的泛型就是 DefaultSecurityFilterChain，所以 SecurityBuilder#build 方法的功能很明确，就是用来构建一个过滤器链出来。</p><h3 id="1-3-HttpSecurityBuilder"><a href="#1-3-HttpSecurityBuilder" class="headerlink" title="1.3 HttpSecurityBuilder"></a>1.3 HttpSecurityBuilder</h3><p>HttpSecurityBuilder 看名字就是用来构建 HttpSecurity 的。不过它也只是一个接口，具体的实现在 HttpSecurity 中，接口定义如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">H</span>&gt;&gt; <span class="hljs-keyword">extends</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>&gt; </span>&#123;</span><br><span class="line">&lt;C extends SecurityConfigurer&lt;DefaultSecurityFilterChain, H&gt;&gt; <span class="hljs-function">C <span class="hljs-title">getConfigurer</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Class&lt;C&gt; clazz)</span></span>;</span><br><span class="line">&lt;C extends SecurityConfigurer&lt;DefaultSecurityFilterChain, H&gt;&gt; <span class="hljs-function">C <span class="hljs-title">removeConfigurer</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Class&lt;C&gt; clazz)</span></span>;</span><br><span class="line">&lt;C&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setSharedObject</span><span class="hljs-params">(Class&lt;C&gt; sharedType, C object)</span></span>;</span><br><span class="line">&lt;C&gt; <span class="hljs-function">C <span class="hljs-title">getSharedObject</span><span class="hljs-params">(Class&lt;C&gt; sharedType)</span></span>;</span><br><span class="line"><span class="hljs-function">H <span class="hljs-title">authenticationProvider</span><span class="hljs-params">(AuthenticationProvider authenticationProvider)</span></span>;</span><br><span class="line"><span class="hljs-function">H <span class="hljs-title">userDetailsService</span><span class="hljs-params">(UserDetailsService userDetailsService)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="hljs-function">H <span class="hljs-title">addFilterAfter</span><span class="hljs-params">(Filter filter, Class&lt;? extends Filter&gt; afterFilter)</span></span>;</span><br><span class="line"><span class="hljs-function">H <span class="hljs-title">addFilterBefore</span><span class="hljs-params">(Filter filter, Class&lt;? extends Filter&gt; beforeFilter)</span></span>;</span><br><span class="line"><span class="hljs-function">H <span class="hljs-title">addFilter</span><span class="hljs-params">(Filter filter)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的方法比较简单：</p><ol><li>getConfigurer 获取一个配置对象。Spring Security 过滤器链中的所有过滤器对象都是由 xxxConfigure 来进行配置的，这里就是获取这个 xxxConfigure 对象。</li><li>removeConfigurer 移除一个配置对象。</li><li>setSharedObject/getSharedObject 配置/获取由多个 SecurityConfigurer 共享的对象。</li><li>authenticationProvider 方法表示配置验证器。</li><li>userDetailsService 配置数据源接口。</li><li>addFilterAfter 在某一个过滤器之前添加过滤器。</li><li>addFilterBefore 在某一个过滤器之后添加过滤器。</li><li>addFilter 添加一个过滤器，该过滤器必须是现有过滤器链中某一个过滤器或者其扩展。</li></ol><p>这便是 HttpSecurityBuilder 中的功能，这些接口在 HttpSecurity 中都将得到实现。</p><h3 id="1-4-AbstractSecurityBuilder"><a href="#1-4-AbstractSecurityBuilder" class="headerlink" title="1.4 AbstractSecurityBuilder"></a>1.4 AbstractSecurityBuilder</h3><p>AbstractSecurityBuilder 类实现了 SecurityBuilder 接口，该类中主要做了一件事，就是确保整个构建只被构建一次。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> AtomicBoolean building = <span class="hljs-keyword">new</span> AtomicBoolean();</span><br><span class="line"><span class="hljs-keyword">private</span> O object;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">build</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.building.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.object = doBuild();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AlreadyBuiltException(<span class="hljs-string">"This object has already been built"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.building.get()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"This object has not been built"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> O <span class="hljs-title">doBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里重新定义了 build 方法，并设置 build 方法为 final 类型，无法被重写，在 build 方法中，通过 AtomicBoolean 实现该方法只被调用一次。具体的构建逻辑则定义了新的抽象方法 doBuild，将来在实现类中通过 doBuild 方法定义构建逻辑。</p><h3 id="1-5-AbstractConfiguredSecurityBuilder"><a href="#1-5-AbstractConfiguredSecurityBuilder" class="headerlink" title="1.5 AbstractConfiguredSecurityBuilder"></a>1.5 AbstractConfiguredSecurityBuilder</h3><p>AbstractSecurityBuilder 方法的实现类就是 AbstractConfiguredSecurityBuilder。</p><p>AbstractConfiguredSecurityBuilder 中所做的事情就比较多了，我们分别来看。</p><p>首先 AbstractConfiguredSecurityBuilder 中定义了一个枚举类，将整个构建过程分为 5 种状态，也可以理解为构建过程生命周期的五个阶段，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> BuildState &#123;</span><br><span class="line">UNBUILT(<span class="hljs-number">0</span>),</span><br><span class="line">INITIALIZING(<span class="hljs-number">1</span>),</span><br><span class="line">CONFIGURING(<span class="hljs-number">2</span>),</span><br><span class="line">BUILDING(<span class="hljs-number">3</span>),</span><br><span class="line">BUILT(<span class="hljs-number">4</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> order;</span><br><span class="line">BuildState(<span class="hljs-keyword">int</span> order) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.order = order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isInitializing</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> INITIALIZING.order == order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConfigured</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> order &gt;= CONFIGURING.order;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五种状态分别是 UNBUILT、INITIALIZING、CONFIGURING、BUILDING 以及 BUILT。另外还提供了两个判断方法，isInitializing 判断是否正在初始化，isConfigured 表示是否已经配置完毕。</p><p>AbstractConfiguredSecurityBuilder 中的方法比较多，松哥在这里列出来两个关键的方法和大家分析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> &lt;C extends SecurityConfigurer&lt;O, B&gt;&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(C configurer)</span> </span>&#123;</span><br><span class="line">Assert.notNull(configurer, <span class="hljs-string">"configurer cannot be null"</span>);</span><br><span class="line">Class&lt;? extends SecurityConfigurer&lt;O, B&gt;&gt; clazz = (Class&lt;? extends SecurityConfigurer&lt;O, B&gt;&gt;) configurer</span><br><span class="line">.getClass();</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (configurers) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (buildState.isConfigured()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot apply "</span> + configurer</span><br><span class="line">+ <span class="hljs-string">" to already built object"</span>);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs = allowConfigurersOfSameType ? <span class="hljs-keyword">this</span>.configurers</span><br><span class="line">.get(clazz) : <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (configs == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">configs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">configs.add(configurer);</span><br><span class="line"><span class="hljs-keyword">this</span>.configurers.put(clazz, configs);</span><br><span class="line"><span class="hljs-keyword">if</span> (buildState.isInitializing()) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.configurersAddedInInitializing.add(configurer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; getConfigurers() &#123;</span><br><span class="line">List&lt;SecurityConfigurer&lt;O, B&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (List&lt;SecurityConfigurer&lt;O, B&gt;&gt; configs : <span class="hljs-keyword">this</span>.configurers.values()) &#123;</span><br><span class="line">result.addAll(configs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个就是这个 add 方法，这相当于是在收集所有的配置类。将所有的 xxxConfigure 收集起来存储到 configurers 中，将来再统一初始化并配置，configurers 本身是一个 LinkedHashMap ，key 是配置类的 class，value 是一个集合，集合里边放着 xxxConfigure 配置类。当需要对这些配置类进行集中配置的时候，会通过 getConfigurers 方法获取配置类，这个获取过程就是把 LinkedHashMap 中的 value 拿出来，放到一个集合中返回。</p><p>另一个方法就是 doBuild 方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> O <span class="hljs-title">doBuild</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">synchronized</span> (configurers) &#123;</span><br><span class="line">buildState = BuildState.INITIALIZING;</span><br><span class="line">beforeInit();</span><br><span class="line">init();</span><br><span class="line">buildState = BuildState.CONFIGURING;</span><br><span class="line">beforeConfigure();</span><br><span class="line">configure();</span><br><span class="line">buildState = BuildState.BUILDING;</span><br><span class="line">O result = performBuild();</span><br><span class="line">buildState = BuildState.BUILT;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; configurers = getConfigurers();</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurers) &#123;</span><br><span class="line">configurer.init((B) <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurersAddedInInitializing) &#123;</span><br><span class="line">configurer.init((B) <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Collection&lt;SecurityConfigurer&lt;O, B&gt;&gt; configurers = getConfigurers();</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityConfigurer&lt;O, B&gt; configurer : configurers) &#123;</span><br><span class="line">configurer.configure((B) <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AbstractSecurityBuilder 类中，过滤器的构建被转移到 doBuild 方法上面了，不过在 AbstractSecurityBuilder 中只是定义了抽象的 doBuild 方法，具体的实现在 AbstractConfiguredSecurityBuilder。</p><p>doBuild 方法就是一边更新状态，进行进行初始化。</p><p>beforeInit 是一个预留方法，没有任何实现。</p><p>init 方法就是找到所有的 xxxConfigure，挨个调用其 init 方法进行初始化。</p><p>beforeConfigure 是一个预留方法，没有任何实现。</p><p>configure 方法就是找到所有的 xxxConfigure，挨个调用其 configure 方法进行配置。</p><p>最后则是 performBuild 方法，是真正的过滤器链构建方法，但是在 AbstractConfiguredSecurityBuilder 中 performBuild 方法只是一个抽象方法，具体的实现在 HttpSecurity 中。</p><p>这便是 HttpSecurity 所有父类、父接口的功能。</p><p>看完了父辈，接下来回到我们今天文章的主题，HttpSecurity。</p><h2 id="2-HttpSecurity"><a href="#2-HttpSecurity" class="headerlink" title="2. HttpSecurity"></a>2. HttpSecurity</h2><p>HttpSecurity 做的事情，就是进行各种各样的 xxxConfigurer 配置。</p><p>随便举几例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> CorsConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">cors</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> CorsConfigurer&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> CsrfConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">csrf</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ApplicationContext context = getContext();</span><br><span class="line"><span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> CsrfConfigurer&lt;&gt;(context));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ExceptionHandlingConfigurer&lt;HttpSecurity&gt; <span class="hljs-title">exceptionHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getOrApply(<span class="hljs-keyword">new</span> ExceptionHandlingConfigurer&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpSecurity 中有大量类似的方法，过滤器链中的过滤器就是这样一个一个配置的。我就不一一介绍了。</p><p>每个配置方法的结尾都会来一句 getOrApply，这个是干嘛的？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> &lt;C extends SecurityConfigurerAdapter&lt;DefaultSecurityFilterChain, HttpSecurity&gt;&gt; <span class="hljs-function">C <span class="hljs-title">getOrApply</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">C configurer)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">C existingConfig = (C) getConfigurer(configurer.getClass());</span><br><span class="line"><span class="hljs-keyword">if</span> (existingConfig != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> existingConfig;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> apply(configurer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getConfigurer 方法是在它的父类 AbstractConfiguredSecurityBuilder 中定义的，目的就是去查看当前这个 xxxConfigurer 是否已经配置过了。</p><p>如果当前 xxxConfigurer 已经配置过了，则直接返回，否则调用 apply 方法，这个 apply 方法最终会调用到 AbstractConfiguredSecurityBuilder#add 方法，将当前配置 configurer 收集起来。</p><p>HttpSecurity 中还有一个 addFilter 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> HttpSecurity <span class="hljs-title">addFilter</span><span class="hljs-params">(Filter filter)</span> </span>&#123;</span><br><span class="line">Class&lt;? extends Filter&gt; filterClass = filter.getClass();</span><br><span class="line"><span class="hljs-keyword">if</span> (!comparator.isRegistered(filterClass)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="hljs-string">"The Filter class "</span></span><br><span class="line">+ filterClass.getName()</span><br><span class="line">+ <span class="hljs-string">" does not have a registered order and cannot be added without a specified order. Consider using addFilterBefore or addFilterAfter instead."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.filters.add(filter);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 addFilter 方法的作用，主要是在各个 xxxConfigurer 进行配置的时候，会调用到这个方法，（xxxConfigurer 就是用来配置过滤器的），把 Filter 都添加到 fitlers 变量中。</p><p>最终在 HttpSecurity 的 performBuild 方法中，构建出来一个过滤器链：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> DefaultSecurityFilterChain <span class="hljs-title">performBuild</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">filters.sort(comparator);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSecurityFilterChain(requestMatcher, filters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先给过滤器排序，然后构造 DefaultSecurityFilterChain 对象。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，这就是 HttpSecurity 的一个大致工作流程。把握住了这个工作流程，剩下的就只是一些简单的重复的 xxxConfigurer 配置了，松哥就不再啰嗦啦。</p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HttpSecurity 也是 Spring Security 中的重要一环。我们平时所做的大部分 Spring Security 配置也都是基于 HttpSecurity 来配置的。因此我们有必要从源码的角度来理解下 HttpSecurity 到底干了啥？&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 SecurityConfigurer 【源码篇】</title>
    <link href="http://www.javaboy.org/2020/0721/springsecurity-securityconfigurer.html"/>
    <id>http://www.javaboy.org/2020/0721/springsecurity-securityconfigurer.html</id>
    <published>2020-07-21T13:26:37.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>我们来继续撸 Spring Security 源码。</p><a id="more"></a><p>SecurityConfigurer 在 Spring Security 中是一个非常重要的角色。在前面的文章中，松哥曾经多次提到过，Spring Security 过滤器链中的每一个过滤器，都是通过 xxxConfigurer 来进行配置的，而这些 xxxConfigurer 实际上都是 SecurityConfigurer 的实现。</p><p>所以我们今天有必要来跟大家把 SecurityConfigurer 从头到尾捋一捋。</p><h2 id="1-SecurityConfigurer"><a href="#1-SecurityConfigurer" class="headerlink" title="1. SecurityConfigurer"></a>1. SecurityConfigurer</h2><p>SecurityConfigurer 本身是一个接口，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，SecurityConfigurer 中主要是两个方法，init 和 configure。</p><p>init 就是一个初始化方法。而 configure 则是一个配置方法。这里只是规范了方法的定义，具体的实现则在不同的实现类中。</p><p>需要注意的是这两个方法的参数类型都是一个泛型 B，也就是 SecurityBuilder 的子类，关于 SecurityBuilder ，它是用来构建过滤器链的，松哥将在下篇文章中和大家介绍。</p><p>SecurityConfigurer 有三个实现类：</p><ul><li>SecurityConfigurerAdapter</li><li>GlobalAuthenticationConfigurerAdapter</li><li>WebSecurityConfigurer</li></ul><p>我们分别来看。</p><h3 id="1-1-SecurityConfigurerAdapter"><a href="#1-1-SecurityConfigurerAdapter" class="headerlink" title="1.1 SecurityConfigurerAdapter"></a>1.1 SecurityConfigurerAdapter</h3><p>SecurityConfigurerAdapter 实现了 SecurityConfigurer 接口，我们所使用的大部分的 xxxConfigurer 也都是 SecurityConfigurerAdapter 的子类。</p><p>SecurityConfigurerAdapter 在 SecurityConfigurer 的基础上，还扩展出来了几个非常好用的方法，我们一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityBuilder</span>&lt;<span class="hljs-title">O</span>&gt;&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">O</span>, <span class="hljs-title">B</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> B securityBuilder;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">private</span> CompositeObjectPostProcessor objectPostProcessor = <span class="hljs-keyword">new</span> CompositeObjectPostProcessor();</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B builder)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">and</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> getBuilder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> B <span class="hljs-title">getBuilder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (securityBuilder == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"securityBuilder cannot be null"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> securityBuilder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">postProcess</span><span class="hljs-params">(T object)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>.objectPostProcessor.postProcess(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObjectPostProcessor</span><span class="hljs-params">(ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.objectPostProcessor.addObjectPostProcessor(objectPostProcessor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBuilder</span><span class="hljs-params">(B builder)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.securityBuilder = builder;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeObjectPostProcessor</span> <span class="hljs-keyword">implements</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">ObjectPostProcessor</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> List&lt;ObjectPostProcessor&lt;?&gt;&gt; postProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@SuppressWarnings</span>(&#123; <span class="hljs-string">"rawtypes"</span>, <span class="hljs-string">"unchecked"</span> &#125;)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcess</span><span class="hljs-params">(Object object)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (ObjectPostProcessor opp : postProcessors) &#123;</span><br><span class="line">Class&lt;?&gt; oppClass = opp.getClass();</span><br><span class="line">Class&lt;?&gt; oppType = GenericTypeResolver.resolveTypeArgument(oppClass,</span><br><span class="line">ObjectPostProcessor.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (oppType == <span class="hljs-keyword">null</span> || oppType.isAssignableFrom(object.getClass())) &#123;</span><br><span class="line">object = opp.postProcess(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addObjectPostProcessor</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">this</span>.postProcessors.add(objectPostProcessor);</span><br><span class="line">postProcessors.sort(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>CompositeObjectPostProcessor 首先一开始声明了一个 CompositeObjectPostProcessor 实例，CompositeObjectPostProcessor 是 ObjectPostProcessor 的一个实现，ObjectPostProcessor 本身是一个后置处理器，该后置处理器默认有两个实现，AutowireBeanFactoryObjectPostProcessor 和 CompositeObjectPostProcessor。其中 AutowireBeanFactoryObjectPostProcessor 主要是利用了 AutowireCapableBeanFactory 对 Bean 进行手动注册，因为在 Spring Security 中，很多对象都是手动 new 出来的，这些 new 出来的对象和容器没有任何关系，利用 AutowireCapableBeanFactory 可以将这些手动 new 出来的对象注入到容器中，而 AutowireBeanFactoryObjectPostProcessor 的主要作用就是完成这件事；CompositeObjectPostProcessor 则是一个复合的对象处理器，里边维护了一个 List 集合，这个 List 集合中，大部分情况下只存储一条数据，那就是 AutowireBeanFactoryObjectPostProcessor，用来完成对象注入到容器的操作，如果用户自己手动调用了 addObjectPostProcessor 方法，那么 CompositeObjectPostProcessor 集合中维护的数据就会多出来一条，在 CompositeObjectPostProcessor#postProcess 方法中，会遍历集合中的所有 ObjectPostProcessor，挨个调用其 postProcess 方法对对象进行后置处理。</li><li>and 方法，该方法返回值是一个 securityBuilder，securityBuilder 实际上就是 HttpSecurity，我们在 HttpSecurity 中去配置不同的过滤器时，可以使用 and 方法进行链式配置，就是因为这里定义了 and 方法并返回了 securityBuilder 实例。</li></ol><p>这便是 SecurityConfigurerAdapter 的主要功能，后面大部分的 xxxConfigurer 都是基于此类来实现的。</p><h3 id="1-2-GlobalAuthenticationConfigurerAdapter"><a href="#1-2-GlobalAuthenticationConfigurerAdapter" class="headerlink" title="1.2 GlobalAuthenticationConfigurerAdapter"></a>1.2 GlobalAuthenticationConfigurerAdapter</h3><p>GlobalAuthenticationConfigurerAdapter 看名字就知道是一个跟全局配置有关的东西，它本身实现了 SecurityConfigurerAdapter 接口，但是并未对方法做具体的实现，只是将泛型具体化了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Order</span>(<span class="hljs-number">100</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalAuthenticationConfigurerAdapter</span> <span class="hljs-keyword">implements</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">SecurityConfigurer</span>&lt;<span class="hljs-title">AuthenticationManager</span>, <span class="hljs-title">AuthenticationManagerBuilder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，SecurityConfigurer 中的泛型，现在明确成了 AuthenticationManager 和 AuthenticationManagerBuilder。所以 GlobalAuthenticationConfigurerAdapter 的实现类将来主要是和配置 AuthenticationManager 有关。当然也包括默认的用户名密码也是由它的实现类来进行配置的。</p><p><strong>我们在 Spring Security 中使用的 AuthenticationManager 其实可以分为两种，一种是局部的，另一种是全局的，这里主要是全局的配置。</strong></p><h3 id="1-3-WebSecurityConfigurer"><a href="#1-3-WebSecurityConfigurer" class="headerlink" title="1.3 WebSecurityConfigurer"></a>1.3 WebSecurityConfigurer</h3><p>还有一个实现类就是 WebSecurityConfigurer，这个可能有的小伙伴比较陌生，其实他就是我们天天用的 WebSecurityConfigurerAdapter 的父接口。</p><p>所以 WebSecurityConfigurer 的作用就很明确了，用户扩展用户自定义的配置。</p><p>SecurityConfigurer 默认主要是这三个实现，考虑到大多数的过滤器配置都是通过 SecurityConfigurerAdapter 进行扩展的，因此我们今天就通过这条线进行展开。另外两条线松哥也将撸两篇文章和大家介绍。</p><h2 id="2-SecurityConfigurerAdapter"><a href="#2-SecurityConfigurerAdapter" class="headerlink" title="2. SecurityConfigurerAdapter"></a>2. SecurityConfigurerAdapter</h2><p>SecurityConfigurerAdapter 的实现主要也是三大类：</p><ul><li>UserDetailsAwareConfigurer</li><li>AbstractHttpConfigurer</li><li>LdapAuthenticationProviderConfigurer</li></ul><p>考虑到 LDAP 现在使用很少，所以这里我来和大家重点介绍下前两个。</p><h3 id="2-1-UserDetailsAwareConfigurer"><a href="#2-1-UserDetailsAwareConfigurer" class="headerlink" title="2.1 UserDetailsAwareConfigurer"></a>2.1 UserDetailsAwareConfigurer</h3><p>这个配置类看名字大概就知道这是用来配置用户类的。</p><p><img src="http://img.itboyhub.com/2020/07/UserDetailsAwareConfigurer.png" alt></p><p><strong>AbstractDaoAuthenticationConfigurer</strong></p><p>AbstractDaoAuthenticationConfigurer 中所做的事情比较简单，主要是构造了一个默认的 DaoAuthenticationProvider，并为其配置 PasswordEncoder 和 UserDetailsService。</p><p><strong>UserDetailsServiceConfigurer</strong></p><p>UserDetailsServiceConfigurer 重写了 AbstractDaoAuthenticationConfigurer 中的 configure 方法，在 configure 方法执行之前加入了 initUserDetailsService 方法，以方便开发展按照自己的方式去初始化 UserDetailsService。不过这里的 initUserDetailsService 方法是空方法。</p><p><strong>UserDetailsManagerConfigurer</strong></p><p>UserDetailsManagerConfigurer 中实现了 UserDetailsServiceConfigurer 中定义的 initUserDetailsService 方法，具体的实现逻辑就是将 UserDetailsBuilder 所构建出来的 UserDetails 以及提前准备好的 UserDetails 中的用户存储到 UserDetailsService 中。</p><p>该类同时添加了 withUser 方法用来添加用户，同时还增加了一个 UserDetailsBuilder 用来构建用户，这些逻辑都比较简单，小伙伴们可以自行查看。</p><p><strong>JdbcUserDetailsManagerConfigurer</strong></p><p>JdbcUserDetailsManagerConfigurer 在父类的基础上补充了 DataSource 对象，同时还提供了相应的数据库查询方法。</p><p><strong>InMemoryUserDetailsManagerConfigurer</strong></p><p>InMemoryUserDetailsManagerConfigurer 在父类的基础上重写了构造方法，将父类中的 UserDetailsService 实例定义为 InMemoryUserDetailsManager。</p><p><strong>DaoAuthenticationConfigurer</strong></p><p>DaoAuthenticationConfigurer 继承自 AbstractDaoAuthenticationConfigurer，只是在构造方法中修改了一下 userDetailsService 而已。</p><p>有小伙伴可能要问了，JdbcUserDetailsManagerConfigurer 或者 InMemoryUserDetailsManagerConfigurer，到底在哪里可以用到呀？</p><p>松哥给大家举一个简单的例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication().withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .password(<span class="hljs-string">"&#123;noop&#125;123"</span>)</span><br><span class="line">                .roles(<span class="hljs-string">"admin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                <span class="hljs-comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你调用 auth.inMemoryAuthentication 进行配置时，实际上调用的就是 InMemoryUserDetailsManagerConfigurer。</p><p>这下明白了吧！</p><h3 id="2-2-AbstractHttpConfigurer"><a href="#2-2-AbstractHttpConfigurer" class="headerlink" title="2.2 AbstractHttpConfigurer"></a>2.2 AbstractHttpConfigurer</h3><p>AbstractHttpConfigurer 这一派中的东西非常多，我们所有的过滤器配置，都是它的子类，我们来看下都有哪些类？</p><p><img src="http://img.itboyhub.com/2020/07/20200720211931.png" alt></p><p>可以看到，它的实现类还是非常多的。</p><p>这么多实现类，松哥就不一一给大家介绍了，我挑一个常用的 FormLoginConfigurer 来给大家详细介绍，只要大家把这个理解了，其他的照猫画虎就很好理解了。</p><p>我们一个一个来看。</p><h4 id="2-2-1-AbstractHttpConfigurer"><a href="#2-2-1-AbstractHttpConfigurer" class="headerlink" title="2.2.1 AbstractHttpConfigurer"></a>2.2.1 AbstractHttpConfigurer</h4><p>AbstractHttpConfigurer 继承自 SecurityConfigurerAdapter，并增加了两个方法，disable 和 withObjectPostProcessor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractHttpConfigurer</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractHttpConfigurer</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">B</span>&gt;, <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpSecurityBuilder</span>&lt;<span class="hljs-title">B</span>&gt;&gt;</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">B</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Disables the &#123;<span class="hljs-doctag">@link</span> AbstractHttpConfigurer&#125; by removing it. After doing so a fresh</span></span><br><span class="line"><span class="hljs-comment"> * version of the configuration can be applied.</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the &#123;<span class="hljs-doctag">@link</span> HttpSecurityBuilder&#125; for additional customizations</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">disable</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">getBuilder().removeConfigurer(getClass());</span><br><span class="line"><span class="hljs-keyword">return</span> getBuilder();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">withObjectPostProcessor</span><span class="hljs-params">(ObjectPostProcessor&lt;?&gt; objectPostProcessor)</span> </span>&#123;</span><br><span class="line">addObjectPostProcessor(objectPostProcessor);</span><br><span class="line"><span class="hljs-keyword">return</span> (T) <span class="hljs-keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法松哥之前都有给大家介绍过，disable 基本上是大家的老熟人了，我们常用的 <code>.csrf().disable()</code> 就是出自这里，那么从这里我们也可以看到 disable 的实现原理，就是从 getBuilder 中移除相关的 xxxConfigurer，getBuilder 方法获取到的实际上就是 HttpSecurity，所以移除掉 xxxConfigurer 实际上就是从过滤器链中移除掉某一个过滤器，例如 <code>.csrf().disable()</code> 就是移除掉处理 csrf 的过滤器。</p><p>另一个增加的方法是 withObjectPostProcessor，这是为配置类添加手动添加后置处理器的。在 AbstractHttpConfigurer 的父类中其实有一个类似的方法就是 addObjectPostProcessor，但是 addObjectPostProcessor 只是一个添加方法，返回值为 void，而 withObjectPostProcessor 的返回值是当前配置类，也就是 xxxConfigurer，所以如果使用 withObjectPostProcessor 的话，可以使用链式配置，事实上，在松哥之前的文章，以及 vhr(<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>) 项目中，使用的也都是 withObjectPostProcessor 方法（当然，你也可以使用 addObjectPostProcessor，最终效果是一样的）。</p><h4 id="2-2-2-AbstractAuthenticationFilterConfigurer"><a href="#2-2-2-AbstractAuthenticationFilterConfigurer" class="headerlink" title="2.2.2 AbstractAuthenticationFilterConfigurer"></a>2.2.2 AbstractAuthenticationFilterConfigurer</h4><p>AbstractAuthenticationFilterConfigurer 类的功能比较多，源码也是相当相当长。不过我们只需要抓住两点即可，init 方法和 configure 方法，因为这两个方法是所有 xxxConfigurer 的灵魂。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(B http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">updateAuthenticationDefaults();</span><br><span class="line">updateAccessDefaults(http);</span><br><span class="line">registerDefaultAuthenticationEntryPoint(http);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init 方法主要干了三件事：</p><ol><li>updateAuthenticationDefaults 主要是配置了登录处理地址，失败跳转地址，注销成功跳转地址。</li><li>updateAccessDefaults 方法主要是对 loginPage、loginProcessingUrl、failureUrl 进行 permitAll 设置（如果用户配置了 permitAll 的话）。</li><li>registerDefaultAuthenticationEntryPoint 则是注册异常的处理器。</li></ol><p>再来看 configure 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(B http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">PortMapper portMapper = http.getSharedObject(PortMapper.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (portMapper != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">authenticationEntryPoint.setPortMapper(portMapper);</span><br><span class="line">&#125;</span><br><span class="line">RequestCache requestCache = http.getSharedObject(RequestCache.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (requestCache != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.defaultSuccessHandler.setRequestCache(requestCache);</span><br><span class="line">&#125;</span><br><span class="line">authFilter.setAuthenticationManager(http</span><br><span class="line">.getSharedObject(AuthenticationManager.class));</span><br><span class="line">authFilter.setAuthenticationSuccessHandler(successHandler);</span><br><span class="line">authFilter.setAuthenticationFailureHandler(failureHandler);</span><br><span class="line"><span class="hljs-keyword">if</span> (authenticationDetailsSource != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">authFilter.setAuthenticationDetailsSource(authenticationDetailsSource);</span><br><span class="line">&#125;</span><br><span class="line">SessionAuthenticationStrategy sessionAuthenticationStrategy = http</span><br><span class="line">.getSharedObject(SessionAuthenticationStrategy.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (sessionAuthenticationStrategy != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">authFilter.setSessionAuthenticationStrategy(sessionAuthenticationStrategy);</span><br><span class="line">&#125;</span><br><span class="line">RememberMeServices rememberMeServices = http</span><br><span class="line">.getSharedObject(RememberMeServices.class);</span><br><span class="line"><span class="hljs-keyword">if</span> (rememberMeServices != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">authFilter.setRememberMeServices(rememberMeServices);</span><br><span class="line">&#125;</span><br><span class="line">F filter = postProcess(authFilter);</span><br><span class="line">http.addFilter(filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configure 中的逻辑就很简答了，构建各种各样的回调函数设置给 authFilter，authFilter 再去 postProcess 中走一圈注册到 Spring 容器中，最后再把 authFilter 添加到过滤器链中。</p><p>这便是 AbstractAuthenticationFilterConfigurer 的主要功能。需要提醒大家的是，我们日常配置的，如：</p><ul><li>loginPage</li><li>loginProcessingUrl</li><li>permitAll</li><li>defaultSuccessUrl</li><li>failureUrl</li><li>…</li></ul><p>等方法都是在这里定义的。</p><p>最后我们再来看看 FormLoginConfigurer。</p><h4 id="2-2-3-FormLoginConfigurer"><a href="#2-2-3-FormLoginConfigurer" class="headerlink" title="2.2.3 FormLoginConfigurer"></a>2.2.3 FormLoginConfigurer</h4><p>FormLoginConfigurer 在定义是，明确了 AbstractAuthenticationFilterConfigurer 中的泛型是 UsernamePasswordAuthenticationFilter，也就是我们这里最终要配置的过滤是 UsernamePasswordAuthenticationFilter。</p><p>FormLoginConfigurer 重写了 init 方法，配置了一下默认的登录页面。其他的基本上都是从父类来的，未做太多改变。</p><p>另外我们日常配置的很多东西也是来自这里：</p><p><img src="http://img.itboyhub.com/2020/07/20200720222352.png" alt></p><p>好啦，这就是 FormLoginConfigurer 这个配置类，FormLoginConfigurer 对应的过滤器是 UsernamePasswordAuthenticationFilter，小伙伴们可以自行分析其他的 xxxConfigurer，每一个 xxxConfigurer 都对应了一个 不同的 Filter。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，今天就主要和大家分享一下 SecurityConfigurer 的源码，当然这里还有很多值得再次仔细讨论的东西，松哥将在后面的文章中继续和大家分享。</p><p>觉得有收获的小伙伴记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们来继续撸 Spring Security 源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 FilterChainProxy【源码篇】</title>
    <link href="http://www.javaboy.org/2020/0720/springsecurity-filterchainproxy.html"/>
    <id>http://www.javaboy.org/2020/0720/springsecurity-filterchainproxy.html</id>
    <published>2020-07-20T13:26:26.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>昨天有小伙伴加松哥微信，说他把松哥的 Spring Security 系列撸完了。。</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/07/20200717221215.png" alt></p><p>but 松哥这个系列还没发完呢，在我的计划中，Spring Security 系列目前应该能更新一半，还剩一半，虽然有的小伙伴可能觉得好像已经没啥了，其实还有很多东西。。。</p><p>松哥最近也是特别忙，Security 更新慢下来了，但是秉持前面说的，要学就成系列的学，要学就学透彻，这个系列我还会继续更下去。</p><p>今天我们就来聊一聊 Spring Security 系列中的 FilterChainProxy。</p><p>这是一个非常重要的代理对象。</p><h2 id="1-FilterChainProxy"><a href="#1-FilterChainProxy" class="headerlink" title="1. FilterChainProxy"></a>1. FilterChainProxy</h2><p>我们先来回顾一下前面文章讲的：</p><p>在一个 Web 项目中，请求流程大概如下图所示：</p><p><img src="http://img.itboyhub.com/2020/06/20200617100049.png" alt></p><p>请求从客户端发起（例如浏览器），然后穿过层层 Filter，最终来到 Servlet 上，被 Servlet 所处理。</p><p>上图中的 Filter 我们可以称之为 Web Filter，Spring Security 中的 Filter 我们可以称之为 Security Filter，它们之间的关系如下图：</p><p><img src="http://img.itboyhub.com/2020/06/20200617100950.png" alt></p><p>可以看到，Spring Security Filter 并不是直接嵌入到 Web Filter 中的，而是通过 FilterChainProxy 来统一管理 Spring Security Filter，FilterChainProxy 本身则通过 Spring 提供的 DelegatingFilterProxy 代理过滤器嵌入到 Web Filter 之中。</p><blockquote><p>DelegatingFilterProxy 很多小伙伴应该比较熟悉，在 Spring 中手工整合 Spring Session、Shiro 等工具时都离不开它，现在用了 Spring Boot，很多事情 Spring Boot 帮我们做了，所以有时候会感觉 DelegatingFilterProxy 的存在感有所降低，实际上它一直都在。</p></blockquote><p>FilterChainProxy 中可以存在多个过滤器链，如下图：</p><p><img src="http://img.itboyhub.com/2020/06/20200617104202.png" alt></p><p>可以看到，当请求到达 FilterChainProxy 之后，FilterChainProxy 会根据请求的路径，将请求转发到不同的 Spring Security Filters 上面去，不同的 Spring Security Filters 对应了不同的过滤器，也就是不同的请求将经过不同的过滤器。</p><p>这是 FilterChainProxy 的一个大致功能，今天我们就从源码上理解 FilterChainProxy 中这些功能到底是怎么实现的。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>先把 FilterChainProxy 源码亮出来，这个源码比较上，我们一部分一部分来，先从它声明的全局属性上开始：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String FILTER_APPLIED = FilterChainProxy.class.getName().concat(</span><br><span class="line"><span class="hljs-string">".APPLIED"</span>);</span><br><span class="line"><span class="hljs-keyword">private</span> List&lt;SecurityFilterChain&gt; filterChains;</span><br><span class="line"><span class="hljs-keyword">private</span> FilterChainValidator filterChainValidator = <span class="hljs-keyword">new</span> NullFilterChainValidator();</span><br><span class="line"><span class="hljs-keyword">private</span> HttpFirewall firewall = <span class="hljs-keyword">new</span> StrictHttpFirewall();</span><br></pre></td></tr></table></figure><ul><li>FILTER_APPLIED 变量是一个标记，用来标记过滤器是否已经执行过了。这个标记在 Spring Security 中很常见，松哥这里就不多说了。</li><li>filterChains 是过滤器链，注意，这个是过滤器链，而不是一个个的过滤器，在【<a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a>】一文中，松哥教过大家如何配置多个过滤器链，配置的多个过滤器链就保存在 filterChains 变量中，也就是，如果你有一个过滤器链，这个集合中就保存一条记录，你有两个过滤器链，这个记录中就保存两条记录，每一条记录又对应了过滤器链中的一个个过滤器。</li><li>filterChainValidator 是 FilterChainProxy 配置完成后的校验方法，默认使用的 NullFilterChainValidator 实际上对应了一个空方法，也就是不做任何校验。</li><li>firewall 我们在前面的文章中也介绍过(<a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a>)，这里就不再赘述。</li></ul><p>接下来我们来看一个过滤器中最重要的 doFilter 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">boolean</span> clearContext = request.getAttribute(FILTER_APPLIED) == <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (clearContext) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">request.setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">doFilterInternal(request, response, chain);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line">request.removeAttribute(FILTER_APPLIED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">doFilterInternal(request, response, chain);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 doFilter 方法中，正常来说，clearContext 参数每次都是 true，于是每次都先给 request 标记上 FILTER_APPLIED 属性，然后执行 doFilterInternal 方法去走过滤器，执行完毕后，最后在 finally 代码块中清除 SecurityContextHolder 中保存的用户信息，同时移除 request 中的标记。</p><p>按着这个顺序，我们来看 doFilterInternal 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">FirewalledRequest fwRequest = firewall</span><br><span class="line">.getFirewalledRequest((HttpServletRequest) request);</span><br><span class="line">HttpServletResponse fwResponse = firewall</span><br><span class="line">.getFirewalledResponse((HttpServletResponse) response);</span><br><span class="line">List&lt;Filter&gt; filters = getFilters(fwRequest);</span><br><span class="line"><span class="hljs-keyword">if</span> (filters == <span class="hljs-keyword">null</span> || filters.size() == <span class="hljs-number">0</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(UrlUtils.buildRequestUrl(fwRequest)</span><br><span class="line">+ (filters == <span class="hljs-keyword">null</span> ? <span class="hljs-string">" has no matching filters"</span></span><br><span class="line">: <span class="hljs-string">" has an empty filter list"</span>));</span><br><span class="line">&#125;</span><br><span class="line">fwRequest.reset();</span><br><span class="line">chain.doFilter(fwRequest, fwResponse);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">VirtualFilterChain vfc = <span class="hljs-keyword">new</span> VirtualFilterChain(fwRequest, chain, filters);</span><br><span class="line">vfc.doFilter(fwRequest, fwResponse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Filter&gt; <span class="hljs-title">getFilters</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (SecurityFilterChain chain : filterChains) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (chain.matches(request)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> chain.getFilters();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doFilterInternal 方法就比较重要了：</p><ol><li>首先将请求封装为一个 FirewalledRequest 对象，在这个封装的过程中，也会判断请求是否合法。具体参考松哥之前的 <a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a> 一文。</li><li>对响应进行封装。</li><li>调用 getFilters 方法找到过滤器链。该方法就是根据当前的请求，从 filterChains 中找到对应的过滤器链，然后由该过滤器链去处理请求，具体可以参考 <a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a> 一文。</li><li>如果找出来的 filters 为 null，或者集合中没有元素，那就是说明当前请求不需要经过过滤器。直接执行 chain.doFilter ，这个就又回到原生过滤器中去了。那么什么时候会发生这种情况呢？那就是针对项目中的静态资源，如果我们配置了资源放行，如 <code>web.ignoring().antMatchers(&quot;/hello&quot;);</code>，那么当你请求 /hello 接口时就会走到这里来，也就是说这个不经过 Spring Security Filter。这个松哥之前也专门写文章介绍过：<a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a>。</li><li>如果查询到的 filters 中是有值的，那么这个 filters 集合中存放的就是我们要经过的过滤器链了。此时它会构造出一个虚拟的过滤器链 VirtualFilterChain 出来，并执行其中的 doFilter 方法。</li></ol><p>那么接下来我们就来看看 VirtualFilterChain：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VirtualFilterChain</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterChain</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FilterChain originalChain;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Filter&gt; additionalFilters;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> FirewalledRequest firewalledRequest;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentPosition = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">VirtualFilterChain</span><span class="hljs-params">(FirewalledRequest firewalledRequest,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">FilterChain chain, List&lt;Filter&gt; additionalFilters)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.originalChain = chain;</span><br><span class="line"><span class="hljs-keyword">this</span>.additionalFilters = additionalFilters;</span><br><span class="line"><span class="hljs-keyword">this</span>.size = additionalFilters.size();</span><br><span class="line"><span class="hljs-keyword">this</span>.firewalledRequest = firewalledRequest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (currentPosition == size) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)</span><br><span class="line">+ <span class="hljs-string">" reached end of additional filter chain; proceeding with original chain"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Deactivate path stripping as we exit the security filter chain</span></span><br><span class="line"><span class="hljs-keyword">this</span>.firewalledRequest.reset();</span><br><span class="line">originalChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">currentPosition++;</span><br><span class="line">Filter nextFilter = additionalFilters.get(currentPosition - <span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(UrlUtils.buildRequestUrl(firewalledRequest)</span><br><span class="line">+ <span class="hljs-string">" at position "</span> + currentPosition + <span class="hljs-string">" of "</span> + size</span><br><span class="line">+ <span class="hljs-string">" in additional filter chain; firing Filter: '"</span></span><br><span class="line">+ nextFilter.getClass().getSimpleName() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">nextFilter.doFilter(request, response, <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>VirtualFilterChain 类中首先声明了 5 个全局属性，originalChain 表示原生的过滤器链，也就是 Web Filter；additionalFilters 表示 Spring Security 中的过滤器链；firewalledRequest 表示当前请求；size 表示过滤器链中过滤器的个数；currentPosition 则是过滤器链遍历时候的下标。</li><li>doFilter 方法就是 Spring Security 中过滤器挨个执行的过程，如果 <code>currentPosition == size</code>，表示过滤器链已经执行完毕，此时通过调用 originalChain.doFilter 进入到原生过滤链方法中，同时也退出了 Spring Security 过滤器链。否则就从 additionalFilters 取出 Spring Security 过滤器链中的一个个过滤器，挨个调用 doFilter 方法。</li></ol><p>最后，FilterChainProxy 中还定义了 FilterChainValidator 接口及其实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FilterChainValidator</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(FilterChainProxy filterChainProxy)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NullFilterChainValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FilterChainValidator</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(FilterChainProxy filterChainProxy)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个实现并未做任何事情。</p><p>这就是 FilterChainProxy 中的整个逻辑。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>其实本文中的很多知识点松哥在之前的文章中都和大家介绍过，例如配置多个过滤器链、StrictHttpFireWall、两种资源放行方式等等，但是之前主要是和大家分享用法，没有去细究他的原理，今天的文章，我们通过源码把这个问题捋了一遍，相信大家对于这些功能细节也更清晰了。</p><p>好啦，感兴趣的小伙伴记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天有小伙伴加松哥微信，说他把松哥的 Spring Security 系列撸完了。。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>跑着跑着就飘了</title>
    <link href="http://www.javaboy.org/2020/0719/run.html"/>
    <id>http://www.javaboy.org/2020/0719/run.html</id>
    <published>2020-07-19T13:26:13.000Z</published>
    <updated>2020-08-04T13:56:44.360Z</updated>
    
    <content type="html"><![CDATA[<p>这话咋说呢？</p><p>我一度觉得自己可以去跑个短程马拉松了。。。直到今天参加了一次户外跑活动，被现实按在地上狠狠摩擦，才发现自己膨胀了。</p><a id="more"></a><h2 id="1-学生时代的跑步"><a href="#1-学生时代的跑步" class="headerlink" title="1.学生时代的跑步"></a>1.学生时代的跑步</h2><p>以前上小学的时候，我家在岭上，学校在一个岭脚下，每天上学放学就是爬上爬下，单程 20 分钟左右，早上去中午回 ，下午去晚上回，天天这样跑，那个时候身体倍棒，一年到头也不生病。</p><p>后来上初中了，学校离家太远了，于是就在学校附近租的房子，逐渐疏于运动。</p><p>高中就更不用说了，学习压力大，锻炼的时间就更少了，高中期间体重也从 120 飙到了 160。</p><p>上大学后，我就要重新拾起已被遗弃六年之久的跑步了。大学时间充裕，只要坚持，这并非什么难事。于是大一一年，体重就从 160 降到 120，后来长期保持在 130-140 之间，我当时减肥并没有刻意的去节食，吃饭还是和日常一样，就是每天坚持锻炼，跑步+台阶跳，汗水淌一地就收工。</p><p><img src="http://img.itboyhub.com/2020/07/20200719164422.png" alt></p><p>这是大学时候拍的，当时体重在 130 左右。</p><p>跑步一直坚持到大四毕业。</p><h2 id="2-工作后的跑步"><a href="#2-工作后的跑步" class="headerlink" title="2.工作后的跑步"></a>2.工作后的跑步</h2><p>工作之后，先是在广州上班，第一家公司上班在花城汇那里，我住在猎德旁边的南国花园小区，出小区门大概 5 分钟就到珠江边上了，于是晚上沿着珠江边上跑（大概一周能出勤 4-5 次）。</p><p>后来换工作之后，也搬家了，新租的房子附近有一个广州 xxx 职业技术学校，具体名字太长了，记不清了，同事告诉我那个学校操场可以跑，于是那一年多都是在学校操场跑的。</p><p>再后来就到深圳了，一开始住在大沙河边上，沿着大沙河跑，再后来越住越远，干脆就报了健身房，于是一直在室内锻炼。</p><p>室内跑的话，每次大概都在 5 公里左右，我的出勤率比较高，所以每次跑的并不长。</p><p>从毕业到现在，跑步算是一直在坚持的事情，主要也是因为程序员工作太累了，经常加班、久坐。这个时候只有出去锻炼一下才会心安。但是工作后的跑步，虽然出勤率比较高，但是基本上都是养生跑，配速较低，主要是活动活动筋骨。</p><p>所以你会发现我一直在跑，但是工作后体重还是慢慢上升到 160 了，上次发了个票圈：</p><p><img src="http://img.itboyhub.com/2020/07/20200719172614.png" alt></p><p>评论区画风都是这样的：</p><p><img src="http://img.itboyhub.com/2020/07/20200719172635.png" alt></p><p>。。。</p><h2 id="3-膨胀了"><a href="#3-膨胀了" class="headerlink" title="3.膨胀了"></a>3.膨胀了</h2><p>跑的久了，就有点膨胀了，有时候就会想，啥时候去跑个短马。。。</p><p>这周日（今天）深圳有一个户外组织，我也是第一次听说的一个组织，在深圳湾公园组织了一场 6KM/10KM 的户外跑，因为最近压力太大了，于是就报名去了。</p><p>早上六点就起来，去了人还蛮多，有五六十人，松哥一开始信心满满，因为最近一直都有跑。结果跑完之后，累的上气不接下气，这日常养生跑和真正的户外跑差别还是相当大呀。一个人跑，速度快慢也没人在意，跑不动了就休息下，一群人跑，没到终点，跑不动了也得跑。</p><p>看来一直是高估了自己的长跑能力了，室内跑久了膨胀了。。。短期内短马应该是没戏了，没信心。</p><p><img src="http://img.itboyhub.com/2020/07/20200719175639.png" alt></p><p>看来以后还是要加强跑步强度了。</p><h2 id="4-坚持锻炼"><a href="#4-坚持锻炼" class="headerlink" title="4.坚持锻炼"></a>4.坚持锻炼</h2><p>前两天看有人总结大部分人一生中最后悔的五件事，有三件令我印象深刻，一个是后悔年轻时没好好努力，一个是后悔没有好好陪伴家人，还有一个就是没有善待自己的身体。</p><p>对于程序员小伙伴们来说，因为经常性的加班，后两个可能尤为扎心。然而身体是自己的，无论工作多忙，还是要坚持锻炼，这是对自己负责，也是对家人负责。</p><p>好啦，周末就随便水一水啦～小伙伴们周末愉快哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这话咋说呢？&lt;/p&gt;
&lt;p&gt;我一度觉得自己可以去跑个短程马拉松了。。。直到今天参加了一次户外跑活动，被现实按在地上狠狠摩擦，才发现自己膨胀了。&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://www.javaboy.org/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>在 Spring Security 中，我就想从子线程获取用户登录信息，怎么办？</title>
    <link href="http://www.javaboy.org/2020/0718/springsecurity-securitycontextholder.html"/>
    <id>http://www.javaboy.org/2020/0718/springsecurity-securitycontextholder.html</id>
    <published>2020-07-18T13:25:57.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>大家知道在 Spring Security 中想要获取登录用户信息，不能在子线程中获取，只能在当前线程中获取，其中一个重要的原因就是 SecurityContextHolder 默认将用户信息保存在 ThreadLocal 中。</p><a id="more"></a><p>但是实际上 SecurityContextHolder 一共定义了三种存储策略：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityContextHolder</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MODE_THREADLOCAL = <span class="hljs-string">"MODE_THREADLOCAL"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MODE_INHERITABLETHREADLOCAL = <span class="hljs-string">"MODE_INHERITABLETHREADLOCAL"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MODE_GLOBAL = <span class="hljs-string">"MODE_GLOBAL"</span>;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种存储策略 MODE_INHERITABLETHREADLOCAL 就支持在子线程中获取当前登录用户信息，而 MODE_INHERITABLETHREADLOCAL 的底层使用的就是 InheritableThreadLocal，那么 InheritableThreadLocal 和 ThreadLocal 有什么区别呢？为什么它就可以支持从子线程中获取数据呢？今天松哥就来和大家聊一聊这个话题。这个问题搞懂了，就理解了为什么在 Spring Security 中，只要我们稍加配置，就可以在子线程中获取到当前登录用户信息。</p><h2 id="1-抛出问题"><a href="#1-抛出问题" class="headerlink" title="1.抛出问题"></a>1.抛出问题</h2><p>先来看一个大家可能都见过的例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocal threadLocal = <span class="hljs-keyword">new</span> ThreadLocal();</span><br><span class="line">    threadLocal.set(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    System.out.println(<span class="hljs-string">"threadLocal.get() = "</span> + threadLocal.get());</span><br><span class="line">    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="hljs-string">"name+threadLocal.get() = "</span> + name + <span class="hljs-string">":"</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的打印结果，相信大家都很清楚：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.get() = javaboy</span><br><span class="line">name+threadLocal.get() = Thread-121:null</span><br></pre></td></tr></table></figure><p>数据在哪个线程存储，就要从哪个线程读取，子线程是读取不到的。如果我们把上面案例中的 ThreadLocal 修改为 InheritableThreadLocal，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocal threadLocal = <span class="hljs-keyword">new</span> InheritableThreadLocal();</span><br><span class="line">    threadLocal.set(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    System.out.println(<span class="hljs-string">"threadLocal.get() = "</span> + threadLocal.get());</span><br><span class="line">    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(<span class="hljs-string">"name+threadLocal.get() = "</span> + name + <span class="hljs-string">":"</span> + threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的运行结果就会发生变化，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.get() = javaboy</span><br><span class="line">name+threadLocal.get() = Thread-<span class="hljs-number">121</span>:javaboy</span><br></pre></td></tr></table></figure><p>可以看到，如果使用了 InheritableThreadLocal，即使在子线程中也能获取到父线程 ThreadLocal 中的数据。</p><p>那么这是怎么回事呢？我们一起来分析一下。</p><h2 id="2-ThreadLocal"><a href="#2-ThreadLocal" class="headerlink" title="2.ThreadLocal"></a>2.ThreadLocal</h2><p>我们先来分析一下 ThreadLocal。</p><p>不看源码，仅从使用的角度来分析 ThreadLocal，大家会发现一个 ThreadLocal 只能存储一个对象，如果你需要存储多个对象，就需要多个 ThreadLocal 。</p><p>我们通过 ThreadLocal 源码来分析下。</p><p>当我们想要去调用 set 方法存储一个对象时，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)</span><br><span class="line">        map.set(<span class="hljs-keyword">this</span>, value);</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，存储的时候会首先获取到一个 ThreadLocalMap 对象，获取的时候需要传入当前线程，看到这里大家可能就猜出来几分了，数据存储在一个类似于 Map 的 ThreadLocalMap 中，ThreadLocalMap 又和线程关联起来，怪不得每个线程只能获取到自己的数据。接下来我们来验证一下，继续看 getMap 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getMap 方法返回的是一个 threadLocals 变量，也就是说，<strong>数据是存在 threadLocals 中的</strong>。threadLocals 则就是一个 ThreadLocalMap。数据存入 ThreadLocalMap 实际上是保存在一个 Entry 数组中。在同一个线程中，一个 ThreadLocal 只能保存一个对象，如果需要保存多个对象，就需要多个 ThreadLocal，同一个线程中的多个 ThreadLocal 最终所保存的变量实际上在同一个 ThreadLocalMap 即同一个 Entry 数组之中。不同线程的 ThreadLocal 所保存的变量在不同的 Entry 数组中。Entry 数组中的 key 实际上就是 ThreadLocal 对象，value 则是 set 进来的数据。</p><p>我们再来看下数据读取：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="hljs-keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先根据当前线程获取到对应的 ThreadLocalMap，再传入当前对象获取到 Entry，然后将 Entry 对象中的 value 返回即可。有人可能会问，Entry 不是一个数组吗？为什么不传入一个数组下标去获取 Entry ，而是通过当前 ThreadLocal 对象去获取 Entry 呢？其实在 getEntry 方法中，就是根据当前对象计算出数组下标，然后将获取到的 Entry 返回。</p><h2 id="3-InheritableThreadLocal"><a href="#3-InheritableThreadLocal" class="headerlink" title="3.InheritableThreadLocal"></a>3.InheritableThreadLocal</h2><p>InheritableThreadLocal 实际上是 ThreadLocal 的子类，我们来看下 InheritableThreadLocal 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritableThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadLocal</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">childValue</span><span class="hljs-params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主要就是重写了三个方法。getMap 方法的返回值变成了 inheritableThreadLocals 对象，createMap 方法中，构建出来的 inheritableThreadLocals 还依然是 ThreadLocalMap 的对象。<strong>和 ThreadLocal 相比，主要是保存数据的对象从 threadLocals 变为 inheritableThreadLocals。</strong></p><p>这样的变化，对于前面的我们所说的 ThreadLocal 中的 get/set 并不影响，也就是 ThreadLocal 的特性依然不变。</p><p>变化发生在线程的初始化方法里，我们来看一下 Thread#init 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                  <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在创建子线程的时候，如果父线程存在 inheritableThreadLocals 变量且不为空，就调用 ThreadLocal.createInheritedMap 方法为子线程的 inheritableThreadLocals 变量赋值。ThreadLocal.createInheritedMap 方法所做的事情，其实就是将父线程的 inheritableThreadLocals 变量值赋值给子线程的 inheritableThreadLocals 变量。因此，在子线程中就可以访问到父线程 ThreadLocal 中的数据了。</p><p>需要注意的是，这种复制不是实时同步，有一个时间节点。在子线程创建的一瞬间，会将父线程 inheritableThreadLocals 变量的值赋值给子线程，一旦子线程创建成功了，如果用户再次去修改了父线程 inheritableThreadLocals 变量的值（即修改了父线程 ThreadLocal 中的数据），此时子线程是感知不到这个变化的。</p><p>好啦，经过上面的介绍相信大家就搞清楚 ThreadLocal 和 InheritableThreadLocal 的区别了。</p><h2 id="4-SpringSecurity"><a href="#4-SpringSecurity" class="headerlink" title="4.SpringSecurity"></a>4.SpringSecurity</h2><p>先来看一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userInfo</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">    String name = authentication.getName();</span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">    System.out.println(<span class="hljs-string">"name = "</span> + name);</span><br><span class="line">    System.out.println(<span class="hljs-string">"authorities = "</span> + authorities);</span><br><span class="line">    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">            String name = authentication.getName();</span><br><span class="line">            Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(threadName + <span class="hljs-string">":name = "</span> + name);</span><br><span class="line">            System.out.println(threadName + <span class="hljs-string">":authorities = "</span> + authorities);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，子线程中方法是无法获取到登录用户信息的。因为 SecurityContextHolder 中的数据保存在 ThreadLocal 中。</p><p>SecurityContextHolder 中通过 System.getProperty 来获取默认的数据存储策略，所以我们可以在项目启动时通过修改系统变量进而修改 SecurityContextHolder 的默认数据存储策略：</p><p><img src="http://img.itboyhub.com/2020/06/20200622123818.png" alt></p><p>修改完成后，再次启动项目，就可以在子线程中获取到登录用户数据了，至于原理，就是前面所讲的。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>好啦，今天就和小伙伴们分享一下 SecurityContextHolder 中数据的存储策略问题，感兴趣的小伙伴可以自己试一试～</p><p>如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家知道在 Spring Security 中想要获取登录用户信息，不能在子线程中获取，只能在当前线程中获取，其中一个重要的原因就是 SecurityContextHolder 默认将用户信息保存在 ThreadLocal 中。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>有没有必要报个培训班？</title>
    <link href="http://www.javaboy.org/2020/0717/peixunban.html"/>
    <id>http://www.javaboy.org/2020/0717/peixunban.html</id>
    <published>2020-07-17T13:25:44.000Z</published>
    <updated>2020-08-04T13:56:44.360Z</updated>
    
    <content type="html"><![CDATA[<p>可能是毕业季，最近收到好几位小伙伴的留言，大家都想知道有没有必要报个培训班？</p><a id="more"></a><p>其实对于培训这个事情，我的认知有过一次很大的转变，从不理解到理解。因为这两年做公众号接触到不少各行各业的人，也有一些是培训行业的，所以我想和大家说说我对培训的理解。</p><h2 id="1-谁去培训"><a href="#1-谁去培训" class="headerlink" title="1.谁去培训"></a>1.谁去培训</h2><p>在我工作之前，我一直都很奇怪为什么培训机构能够生存下来？</p><p>最早的优酷、土豆网上有培训机构大把的视频教程，后来百度网盘火起来之后，各种高清高质量的培训视频层出不穷，再到现在，培训机构攻占了 B 站，培训机构把视频都放在网上了，开发者想学习，他的选择更多了，那培训机构还拿什么赚钱？</p><p>这个问题我大学三年都没想通，因为从大二开始，我就在网上找免费的视频教程学习（并非盗版，都是各机构主动公开的视频），把培训机构的免费视频从头看到尾，大学白piao了三年，这个问题一直困扰着我，想不通到底有谁会去培训机构花钱学习呢？。</p><p>直到大学毕业了，工作了，认识到各种各样的程序员之后，我才慢慢想明白这个问题，所有能坚持看视频从头学到尾并且学会的人，都不是培训机构的目标客户。</p><blockquote><p>有时候我们想问题时总是不由自主的以自己为参照物，从而得出很多狭隘的结论，觉得自己是这样，所以大部分程序员都是这样；自己公司是这样，所以天下老板一般抠。。。这样的结论很明显是狭隘的。这个世界这么多人，这么多程序员，怎么可能人人都一模一样。在慢慢认识到人和人的差异之后，培训机构的业务模式就很好理解了。</p></blockquote><p>转行的人应该是培训机构最大的客户群体了。为什么转行的人不自学呢？其实这里有很多原因，最大的原因可能是时间成本。</p><p>如果你今年大二，想要转行，从大二到大四还有三年时间，三年里，慢慢悠悠的学，到大四找个工作都没啥问题；但是大部分转行的小伙伴都是毕业了，找不到工作才想到转行，或者工作了一两年之后，想要转行。这个时候年龄上来了，生活中的事情也多起来了，有的甚至已经结婚了，生活的压力也很大，很难再花一两年去慢慢琢磨技术了，而且自己一个人琢磨一年多，如果没能成功转行，损失更大。去报个培训班，按照学习大纲一群人一起学习，有问题老师还能帮忙解决，四五个月就可以出来找工作了，这样看起来似乎更划算一些。我相信参加培训的小伙伴有不少是抱着这样的心态去的。</p><p>这也是我目前能想到的培训的意义。</p><p>因为网上的资料，学习路线（公众号【江南一点雨】后台回复 <strong>进阶路线</strong> 获取松哥整理的 JavaEE 学习路线图），你要啥有啥。但是有的人缺自制力，有的人可能是遇到问题自己搞不定，有的人则是缺时间，想要尽快的学会，那么培训机构适合这些人。</p><p>然而培训也并非一个一本万利的投资。</p><h2 id="2-培训有风险"><a href="#2-培训有风险" class="headerlink" title="2.培训有风险"></a>2.培训有风险</h2><p>打开任何一个培训机构的官网，映入眼帘的都是各种各样的成功案例，各种各样的现身说法，如何如何逆袭，如何实现月入 xx 万。。。你要说这些都是找人演的，我不敢苟同。还是前面说的，世界那么大，程序员那么多，培训机构一年招那么多人，谁还没个成功案例呢？然而个别的成功案例并不能代表所有，大部分培训出来的程序员工作的第一站可能都是外包，不过外包也没有那么不堪，很多人去了外包还是有可能再成功上岸的。</p><p>可能还会有少量的失败案例，就是转行失败，培训结束后没找到工作，这种是既花了钱，又浪费了时间，对于成年人来说，花钱是小，浪费时间是大。</p><p>失败的案例肯定是存在的，培训机构肯定是不会说的。但是失败的案例肯定是少数，如果一个班 90% 的人都找不到工作，那它肯定得被找不到工作的学生搅得没法开门营业了，所以我说失败的案例是少数。</p><p>所以大家对于参加培训这事要理性看待。去培训机构到底能学成个啥样子，最终还是要看自己。<strong>毕竟无论什么事情，师傅领进门，修行在个人。</strong></p><h2 id="3-培训是魔鬼？"><a href="#3-培训是魔鬼？" class="headerlink" title="3.培训是魔鬼？"></a>3.培训是魔鬼？</h2><p>松哥刚毕业的时候差点被培训给忽悠了，所以一直心有芥蒂。那会大四，三月份吧，离毕业还有三个月，我要准备春招了，一开始是校招社招都投，后来发现对应届生来说社招太坑了，于是专心投校招。</p><p>不过在刚开始投社招的时候，有一家北京的中关村 xxx 公司，给我打电话，都没有技术面就说我被录用了。他说，因为我没有工作经验，所以他们会有人带我，刚工作的四个月是没有工资的，但是每个月会发千把块的补助，等我工作了，每个月再从我工资里扣多少钱，连着扣十二个月，巴拉巴拉。。。这一套说辞下来，对于一个还没走出大学校门的人来说，我还真以为自己走了狗屎运了，这么快就找到工作了。我把这事告诉了朋友，才发现自己被忽悠了，这就是个培训机构呀，不过这招生方式也太坑了！经过这事之后，我就把重点放在校招了，校招还是比较靠谱的，后来顺利拿了三个 offer。</p><p>后来听别人说，慢慢的就了解到这种培训机构的业务模式，他们会和一些金融公司或者城商银行合作，他们说前四个月不要钱，其实在你入职的第一天就会让你签一个贷款协议，从银行或者一些 p2p 机构把钱贷出来，贷出来的钱，你见不到，会直接进入培训机构的账户，这些钱一部分作为你的学费，另一部分作为你的生活费，每月给你发一些。等到你毕业找工作了，然后每月去还银行贷款就行了。培训机构不承担任何风险。</p><p>其实我觉得贷款学习这套业务模式没问题，但是你要明明白白的告诉学员，要是告诉你就是去上班，一开始没工资，有补助，工作了再每个月扣钱。。。换成这一套说辞就很恶心了。</p><p>我相信在看这篇文章的小伙伴，肯定有人遇到过这一类的公司。据说他们会在一些招聘网站去买用户数据，专门买那些刚毕业的、转行的求职者的信息，然后给他们挨个打电话，约面试。。。。。</p><p>所以，如果你真的需要找培训机构，还是要自己擦亮眼睛，找一些大机构还是靠谱一些，各方面也会多一些保证。像今年疫情原因，有好几位小伙伴微信告诉松哥自己报的培训班倒闭了，没有现金流，很多小公司都撑不了几天，大公司抗风险能力则要稍微强一些。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>总而言之，如果你自制力强，时间充裕，那么可以在 B 站找资料自学（至于学习路线，公众号后台回复 <strong>进阶路线</strong> 即可获取）；否则的话，还是建议报个培训班省事一些，不过报班要选一些大的培训机构，至于什么机构，网上自行搜索判断，别问我～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可能是毕业季，最近收到好几位小伙伴的留言，大家都想知道有没有必要报个培训班？&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://www.javaboy.org/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>松哥憋了个大招！一套免费的视频教程又出炉啦！</title>
    <link href="http://www.javaboy.org/2020/0716/coolmeeting.html"/>
    <id>http://www.javaboy.org/2020/0716/coolmeeting.html</id>
    <published>2020-07-16T13:25:32.000Z</published>
    <updated>2020-08-04T13:56:44.360Z</updated>
    
    <content type="html"><![CDATA[<p>这个视频松哥犹豫了好几个月，总算下定决心录了。</p><p>大家知道我的 GitHub 上有三个项目：</p><a id="more"></a><ul><li>vhr：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li><li>VBlog：<a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li><li>CoolMeeting：<a href="https://github.com/lenve/CoolMeeting" target="_blank" rel="noopener">https://github.com/lenve/CoolMeeting</a></li></ul><p>前两个项目应该不用我过多介绍了吧，我在公众号里边已经说过多次了，<a href="https://mp.weixin.qq.com/s/6GIZ6RmPWZzFe1jaroXcPQ" target="_blank" rel="noopener">项目视频</a>也都录了不少了，这两个技术栈都是 Spring Boot + Vue，业务略有差异，技术高度相似。</p><p>还有一个 CoolMeeting 项目，可能大家没怎么关注过，这是一个没有用 Maven，纯粹 JSP+Servlet+jQuery+Ajax 做的一个 JavaWeb 入门项目。</p><p>我一直想给这个入门项目也整一套视频教程，但是一直没有执行，主要有两方面的原因：</p><ul><li>没时间</li><li>太简单</li></ul><p>一直都比较忙，这个没啥好说。太简单，主要是指这个 CoolMeeting 项目太简单了，大家所热衷的高并发、前后端分离这里都没有，就这样一个项目，到底有没有必要给整一个视频呢？</p><p>最近发生的一件事情，让我想清楚了这个问题：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/65b480d57d29627bfbad01e5e6c4dd4.jpg" alt></p><blockquote><p>我们总是按照自己所处的环境来理解这个世界，来理解别人的技术，因为可能得出一些狭隘的结论。</p></blockquote><p>松哥的读者中，有不少是有开发经验的，但是也有不少是刚刚入行的小伙伴，思来想去，还是决定给这个项目整一个视频吧，能帮几个是几个。</p><p>于是乎，趁着上周末，在家宅了两天，然后这周内又录了几个晚上，总算整出来了，前前后后一共 26 集，四个小时左右：</p><p><img src="http://img.itboyhub.com/2020/07/20200715235250.png" alt></p><p>另外在视频录制中，我也把这个项目的技术栈稍微调整了一下，改成了 <strong>Spring + SpringMVC + MyBatis + Freemarker</strong>，这样对大家来说可能更有用一些。</p><p>有需要的小伙伴们可以看看 CoolMeeting 哦~有开发经验的小伙伴们，继续撸松哥每周的 Spring 源码就行了~</p><p>好啦，有需要的小伙伴公众号后台回复 <strong>coolmeeting</strong> 获取播放链接～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个视频松哥犹豫了好几个月，总算下定决心录了。&lt;/p&gt;
&lt;p&gt;大家知道我的 GitHub 上有三个项目：&lt;/p&gt;
    
    </summary>
    
      <category term="项目实战" scheme="http://www.javaboy.org/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="Freemarker" scheme="http://www.javaboy.org/tags/Freemarker/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 可以同时对接多个用户表？</title>
    <link href="http://www.javaboy.org/2020/0714/springsecurity-multi-users.html"/>
    <id>http://www.javaboy.org/2020/0714/springsecurity-multi-users.html</id>
    <published>2020-07-14T13:25:11.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>这个问题也是来自小伙伴的提问：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/07/20200709215745.png" alt></p><p>其实这个问题有好几位小伙伴问过我，但是这个需求比较冷门，我一直没写文章。</p><p>其实只要看懂了松哥前面的文章，这个需求是可以做出来的。因为一个核心点就是 ProviderManager，搞懂了这个，其他的就很容易了。</p><p>今天松哥花一点时间，来和大家分析一下这个问题的核心，同时通过一个小小案例来演示一下如何同时连接多个数据源。</p><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><h3 id="1-1-Authentication"><a href="#1-1-Authentication" class="headerlink" title="1.1 Authentication"></a>1.1 Authentication</h3><p>玩过 Spring Security 的小伙伴都知道，在 Spring Security 中有一个非常重要的对象叫做 Authentication，我们可以在任何地方注入 Authentication 进而获取到当前登录用户信息，Authentication 本身是一个接口，它实际上对 java.security.Principal 做的进一步封装，我们来看下 Authentication 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Authentication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Principal</span>, <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getDetails</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAuthenticated</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里接口中的方法也没几个，我来大概解释下：</p><ol><li>getAuthorities 方法用来获取用户的权限。</li><li>getCredentials 方法用来获取用户凭证，一般来说就是密码。</li><li>getDetails 方法用来获取用户携带的详细信息，可能是当前请求之类的东西。</li><li>getPrincipal 方法用来获取当前用户，可能是一个用户名，也可能是一个用户对象。</li><li>isAuthenticated 当前用户是否认证成功。</li></ol><p>Authentication 作为一个接口，它定义了用户，或者说 Principal 的一些基本行为，它有很多实现类：</p><p><img src="http://img.itboyhub.com/2020/03/authentication-1.png" alt></p><p>在这些实现类中，我们最常用的就是 UsernamePasswordAuthenticationToken 了，而每一个 Authentication 都有适合它的 AuthenticationProvider 去处理校验。例如处理 UsernamePasswordAuthenticationToken 的 AuthenticationProvider 是 DaoAuthenticationProvider。</p><h3 id="1-2-AuthenticationManager"><a href="#1-2-AuthenticationManager" class="headerlink" title="1.2 AuthenticationManager"></a>1.2 AuthenticationManager</h3><p>在 Spring Security 中，用来处理身份认证的类是 AuthenticationManager，我们也称之为认证管理器。</p><p>AuthenticationManager 中规范了 Spring Security 的过滤器要如何执行身份认证，并在身份认证成功后返回一个经过认证的 Authentication 对象。AuthenticationManager 是一个接口，我们可以自定义它的实现，但是通常我们使用更多的是系统提供的 ProviderManager。</p><h3 id="1-3-ProviderManager"><a href="#1-3-ProviderManager" class="headerlink" title="1.3 ProviderManager"></a>1.3 ProviderManager</h3><p>ProviderManager 是的最常用的 AuthenticationManager 实现类。</p><p>ProviderManager 管理了一个 AuthenticationProvider 列表，每个 AuthenticationProvider 都是一个认证器，不同的 AuthenticationProvider 用来处理不同的 Authentication 对象的认证。一次完整的身份认证流程可能会经过多个 AuthenticationProvider。</p><p>ProviderManager 相当于代理了多个 AuthenticationProvider，他们的关系如下图：</p><p><img src="http://img.itboyhub.com/2020/07/20200709222237.png" alt></p><h3 id="1-4-AuthenticationProvider"><a href="#1-4-AuthenticationProvider" class="headerlink" title="1.4 AuthenticationProvider"></a>1.4 AuthenticationProvider</h3><p>AuthenticationProvider 定义了 Spring Security 中的验证逻辑，我们来看下 AuthenticationProvider 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，AuthenticationProvider 中就两个方法：</p><ul><li>authenticate 方法用来做验证，就是验证用户身份。</li><li>supports 则用来判断当前的 AuthenticationProvider 是否支持对应的 Authentication。</li></ul><p>在一次完整的认证中，可能包含多个 AuthenticationProvider，而这多个 AuthenticationProvider 则由 ProviderManager 进行统一管理，具体可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a>。</p><p>这里我们来重点看一下 DaoAuthenticationProvider，因为这是我们最常用的一个，当我们使用用户名/密码登录的时候，用的就是它，DaoAuthenticationProvider 的父类是 AbstractUserDetailsAuthenticationProvider，我们就先从它的父类看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractUserDetailsAuthenticationProvider</span> <span class="hljs-keyword">implements</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">AuthenticationProvider</span>, <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">MessageSourceAware</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">String username = (authentication.getPrincipal() == <span class="hljs-keyword">null</span>) ? <span class="hljs-string">"NONE_PROVIDED"</span></span><br><span class="line">: authentication.getName();</span><br><span class="line"><span class="hljs-keyword">boolean</span> cacheWasUsed = <span class="hljs-keyword">true</span>;</span><br><span class="line">UserDetails user = <span class="hljs-keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"><span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">cacheWasUsed = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"User '"</span> + username + <span class="hljs-string">"' not found"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> notFound;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">cacheWasUsed = <span class="hljs-keyword">false</span>;</span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> exception;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">principalToReturn = user.getUsername();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (UsernamePasswordAuthenticationToken.class</span><br><span class="line">.isAssignableFrom(authentication));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractUserDetailsAuthenticationProvider 的代码还是挺长的，这里我们重点关注两个方法：authenticate 和 supports。</p><p>authenticate 方法就是用来做认证的方法，我们来简单看下方法流程：</p><ol><li>首先从 Authentication 提取出登录用户名。</li><li>然后通过拿着 username 去调用 retrieveUser 方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的 loadUserByUsername 方法，所以这里返回的 user 其实就是你的登录对象，可以参考微人事的 org/javaboy/vhr/service/HrService.java#L34，也可以参考本系列之前的文章：<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a>。</li><li>接下来调用 preAuthenticationChecks.check 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等。</li><li>additionalAuthenticationChecks 方法则是做密码比对的，好多小伙伴好奇 Spring Security 的密码加密之后，是如何进行比较的，看这里就懂了，因为比较的逻辑很简单，我这里就不贴代码出来了。但是注意，additionalAuthenticationChecks 方法是一个抽象方法，具体的实现是在 AbstractUserDetailsAuthenticationProvider 的子类中实现的，也就是 DaoAuthenticationProvider。这个其实很好理解，因为 AbstractUserDetailsAuthenticationProvider 作为一个较通用的父类，处理一些通用的行为，我们在登录的时候，有的登录方式并不需要密码，所以 additionalAuthenticationChecks 方法一般交给它的子类去实现，在 DaoAuthenticationProvider 类中，additionalAuthenticationChecks 方法就是做密码比对的，在其他的 AuthenticationProvider 中，additionalAuthenticationChecks 方法的作用就不一定了。</li><li>最后在 postAuthenticationChecks.check 方法中检查密码是否过期。</li><li>接下来有一个 forcePrincipalAsString 属性，这个是是否强制将 Authentication 中的 principal 属性设置为字符串，这个属性我们一开始在 UsernamePasswordAuthenticationFilter 类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多。</li><li>最后，通过 createSuccessAuthentication 方法构建一个新的 UsernamePasswordAuthenticationToken。</li></ol><p>supports 方法就比较简单了，主要用来判断当前的 Authentication 是否是 UsernamePasswordAuthenticationToken。</p><p>由于 AbstractUserDetailsAuthenticationProvider 已经把 authenticate 和 supports 方法实现了，所以在 DaoAuthenticationProvider 中，我们主要关注 additionalAuthenticationChecks 方法即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoAuthenticationProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractUserDetailsAuthenticationProvider</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"deprecation"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additionalAuthenticationChecks</span><span class="hljs-params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authentication.getCredentials() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"><span class="hljs-keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，additionalAuthenticationChecks 方法主要用来做密码比对的，逻辑也比较简单，就是调用 PasswordEncoder 的 matches 方法做比对，如果密码不对则直接抛出异常即可。</p><p><strong>正常情况下，我们使用用户名/密码登录，最终都会走到这一步。</strong></p><p>而 AuthenticationProvider 都是通过 ProviderManager#authenticate 方法来调用的。由于我们的一次认证可能会存在多个 AuthenticationProvider，所以，在 ProviderManager#authenticate 方法中会逐个遍历 AuthenticationProvider，并调用他们的 authenticate 方法做认证，我们来稍微瞅一眼 ProviderManager#authenticate 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">copyDetails(authentication, result);</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这个方法中，会遍历所有的 AuthenticationProvider，并调用它的 authenticate 方法进行认证。</p><p>好了，大致的认证流程说完之后，相信大家已经明白了我们要从哪里下手了。</p><h2 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h2><p>要想接入多个数据源，我们只需要提供多个自定义的 AuthenticationProvider，并交给 ProviderManager 进行管理，每一个 AuthenticationProvider 对应不同的数据源即可。</p><p>首先我们创建一个 Spring Boot 项目，引入 security 和 web 依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后创建一个测试 Controller，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后配置 SecurityConfig：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-meta">@Primary</span></span><br><span class="line">    <span class="hljs-function">UserDetailsService <span class="hljs-title">us1</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryUserDetailsManager(User.builder().username(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">UserDetailsService <span class="hljs-title">us2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryUserDetailsManager(User.builder().username(<span class="hljs-string">"sang"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"user"</span>).build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider dao1 = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        dao1.setUserDetailsService(us1());</span><br><span class="line"></span><br><span class="line">        DaoAuthenticationProvider dao2 = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        dao2.setUserDetailsService(us2());</span><br><span class="line"></span><br><span class="line">        ProviderManager manager = <span class="hljs-keyword">new</span> ProviderManager(dao1, dao2);</span><br><span class="line">        <span class="hljs-keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/hello"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先提供两个 UserDetailsService 实例，这里为了方便演示，我采用 InMemoryUserDetailsManager 来构建 UserDetailsService，在实际开发中，大家自行定义 UserDetailsService 即可，可以参考（<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a>）一文。</li><li>接下来自定义 AuthenticationManager，AuthenticationManager 的实例实际上就是 ProviderManager。先构造两个 DaoAuthenticationProvider 实例，每一个传入不同的 UserDetailsService 实例，相当于每一个 DaoAuthenticationProvider 代表了一个 UserDetailsService 实例。</li><li>最后配置 HttpSecurity，这个本系列前面文章讲过很多次了，这里就不再赘述。</li></ol><p><strong>根据第一小节中的原理，在用户身份认证时，两个 DaoAuthenticationProvider 会被依次执行，这样我们配置的两个数据源就生效了。</strong></p><p>配置完成后，启动项目。</p><p>在 postman 中进行测试，我们可以使用 javaboy 登录，登录成功后的用户具备 admin 角色，所以可以访问 <a href="http://localhost:8080/admin，也可以使用" target="_blank" rel="noopener">http://localhost:8080/admin，也可以使用</a> sang 登录，登录后的用户具备 user 角色，可以访问 <a href="http://localhost:8080/hello。" target="_blank" rel="noopener">http://localhost:8080/hello。</a></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，本文和小伙伴们分享了一下 Spring Security 中如何同时接入多个数据源的问题，感兴趣的小伙伴可以尝试一下哦～</p><p>微信公众号【江南一点雨】后台回复 <strong>multiusers</strong> 可以获取本文案例下载地址哦～</p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;这个问题也是来自小伙伴的提问：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码第六弹！松哥和大家聊聊容器的始祖 DefaultListableBeanFactory</title>
    <link href="http://www.javaboy.org/2020/0713/default-listable-beanfactory.html"/>
    <id>http://www.javaboy.org/2020/0713/default-listable-beanfactory.html</id>
    <published>2020-07-13T13:24:57.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 源码继续开整！</p><a id="more"></a><p><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">在 XML 文件解析流程一文</a>中，松哥和大家分享了 Spring 中配置文件的加载方式，如果小伙伴们还没看过，一定先看一下，这有助于更好的理解本文，传送门：<a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a>。</p><p>还记得该篇文章中的代码吗？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"beans.xml"</span>));</span><br><span class="line">User user = factory.getBean(User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>当 ClassPathResource 将文件以 IO 流的方式输出后，接下来就是构造 XmlBeanFactory ，XmlBeanFactory 功能有限，它的大部分功能都在它的父类 DefaultListableBeanFactory 中实现了，而 DefaultListableBeanFactory 也相当于是容器的始祖，为什么这么说呢？我们今天就来说一说这个话题。</p><p>本文是 Spring 源码解读第七篇，阅读本系列前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/1ImVkjdmcllArzPOSksNoA" target="_blank" rel="noopener">Spring 源码解读计划</a></li><li><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a></li><li><a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">Spring 源码第二弹！XML 文件解析流程</a></li><li><a href="https://mp.weixin.qq.com/s/vXD79ucsRjbQWbogrzdq9g" target="_blank" rel="noopener">Spring 源码第三弹！EntityResolver 是个什么鬼？</a></li><li><a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a></li><li><a href="https://mp.weixin.qq.com/s/8WnRZtHmstum23Ut5EXAug" target="_blank" rel="noopener">手把手教你搭建 Spring 源码分析环境</a></li></ol><h2 id="1-DefaultListableBeanFactory"><a href="#1-DefaultListableBeanFactory" class="headerlink" title="1.DefaultListableBeanFactory"></a>1.DefaultListableBeanFactory</h2><p>要说 XmlBeanFactory 就不得不先说它的父类 DefaultListableBeanFactory，因为 XmlBeanFactory 中的大部分功能实际上在 DefaultListableBeanFactory 中就已经提供好了，XmlBeanFactory 只是对 IO 流的读取做了一些定制而已。</p><p>DefaultListableBeanFactory 是一个完整的、功能成熟的 IoC 容器，如果你的需求很简单，甚至可以直接使用 DefaultListableBeanFactory，如果你的需求比较复杂，那么通过扩展 DefaultListableBeanFactory 的功能也可以达到，可以说 DefaultListableBeanFactory 是整个 Spring IoC 容器的始祖。</p><p>我们先来看一下 DefaultListableBeanFactory 的继承关系：</p><p><img src="http://img.itboyhub.com/2020/06/DefaultListableBeanFactory.png" alt></p><p>从这张类的关系图中可以看出，DefaultListableBeanFactory 实际上也是一个集大成者。在 Spring 中，针对 Bean 的不同操作都有不同的接口进行规范，每个接口都有自己对应的实现，最终在 DefaultListableBeanFactory 中将所有的实现汇聚到一起。从这张类的继承关系图中我们大概就能感受到 Spring 中关于类的设计是多么厉害，代码耦合度非常低。</p><p>这些类，在本系列后面的介绍中，大部分都会涉及到，现在我先大概介绍一下每个类的作用，大家先混个脸熟：</p><ol><li>BeanFactory：这个接口看名字就知道是一个 Bean 的工厂，BeanFactory 接口定义了各种获取 Bean 的方法、判断 Bean 是否存在、判断 Bean 是否单例等针对 Bean 的基础方法。</li><li>ListableBeanFactory：这个接口继承自 BeanFactory，在 BeanFactory 的基础上，扩展了 Bean 的查询方法，例如根据类型获取 BeanNames、根据注解获取 BeanNames、根据 Bean 获取注解等。</li><li>AutowireCapableBeanFactory：该接口继承自 BeanFactory，在 BeanFactory 的基础上，提供了 Bean 的创建、配置、注入、销毁等操作。有时候我们需要自己手动注入 Bean 的时候，可以考虑通过实现该接口来完成。AutowireCapableBeanFactory 在 Spring Security 中有一个重要的应用就是 ObjectPostProcessor，这个松哥将在 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI1NDY0MTkzNQ==&amp;action=getalbum&amp;album_id=1319828555819286528&amp;subscene=27&amp;scenenote=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI1NDY0MTkzNQ%3D%3D%26mid%3D2247488952%26idx%3D2%26sn%3Df5a16f45ef22ee28f37e41d08e6fecd5%26chksm%3De9c347d8deb4cecedc190b5476e35750e270754c978b818895923f9c69670ac01157d4b2181f%26scene%3D27%26key%3De9ffa206e9e5d4d764caa78c96fbb0af2b2ec333fbb15849ce59be3ff99e35264c2338acfb957131303cb8c8405e2541b4fd9212f4e5f733f79c719b68af9db0348c4d9b445173d1928e71008916f336%26ascene%3D0%26uin%3DMTQ5NzA1MzQwMw%253D%253D%26devicetype%3DiMac%2BMacBookPro15%252C1%2BOSX%2BOSX%2B10.13.6%2Bbuild(17G2208" target="_blank" rel="noopener">Spring Security 系列</a>%26version%3D12031f10%26nettype%3DWIFI%26lang%3Den%26fontScale%3D100%26exportkey%3DA7Vh2vnoyPfiNe4xJBp1Abg%253D%26pass_ticket%3DcsesYv%252BwBmhWaBHD26d%252FJ7tMkuXP0dO73h0sw2UG8l0e1hhkKGiIMjql0rJcXL0r%26winzoom%3D1.000000&amp;uin=&amp;key=&amp;devicetype=iMac+MacBookPro15%2C1+OSX+OSX+10.13.6+build(17G2208)&amp;version=12031f10&amp;lang=en&amp;nettype=WIFI&amp;ascene=0&amp;fontScale=100&amp;winzoom=1.000000)中和大家详细介绍。</li><li>HierarchicalBeanFactory：该接口继承自 BeanFactory，并在 BeanFactory 基础上添加了获取 parent beanfactory 的方法。</li><li>SingletonBeanRegistry：这个接口定义了对单例 Bean 的定义以及获取方法。</li><li>ConfigurableBeanFactory：这个接口主要定了针对 BeanFactory 的各种配置以及销毁的方法。</li><li>ConfigurableListableBeanFactory：这是 BeanFactory 的配置清单，这里定义了忽略的类型、接口，通过 Bean 的名称获取 BeanDefinition 、冻结 BeanDefinition 等。</li><li>AliasRegistry：这个接口定义了对 alias 的注册、移除、判断以及查询操作。</li><li>SimpleAliasRegistry：这个类实现了 AliasRegistry 接口并实现了它里边的方法，SimpleAliasRegistry 使用 ConcurrentHashMap 做载体，实现了对 alias 的注册、移除判断以及查询操作。</li><li>DefaultSingletonBeanRegistry：这个类基于 Java 中的集合，对 SingletonBeanRegistry 接口进行了实现。</li><li>FactoryBeanRegistrySupport：该类继承自 DefaultSingletonBeanRegistry，并在 DefaultSingletonBeanRegistry 的基础上，增加了获取 FactoryBean 类型、移除 FactoryBean 缓存的方法等等操作。</li><li>AbstractBeanFactory：实现了 ConfigurableBeanFactory 接口并继承自 FactoryBeanRegistrySupport，在 AbstractBeanFactory 中对 ConfigurableBeanFactory 中定义的方法进行了实现。</li><li>AbstractAutowireCapableBeanFactory：该类继承自 AbstractBeanFactory 并对 AutowireCapableBeanFactory 接口中定义的方法进行了落地实现。</li><li>BeanDefinitionRegistry：这个接口继承自 AliasRegistry 接口，并增加了一系列针对 BeanDefinition 的注册、移除、查询、判断等方法。</li><li>最后的 DefaultListableBeanFactory 自然就具备了上面所有的功能。</li></ol><p>上面的内容可能看的大家眼花缭乱，松哥这里通过几个简单实际的例子，来带大家使用一下 DefaultListableBeanFactory 的功能，可能大家的理解就比较清晰了。</p><p>DefaultListableBeanFactory 作为一个集大成者，提供了非常多的功能，我们一个一个来看。</p><h2 id="2-代码改造"><a href="#2-代码改造" class="headerlink" title="2.代码改造"></a>2.代码改造</h2><p>首先文章中一开始的三行代码我们可以对其略加改造，因为我们已经说了 XmlBeanFactory 中的大部分功能实际上在 DefaultListableBeanFactory 中就已经提供好了，XmlBeanFactory 只是对 IO 流的读取做了一些定制而已，文件的读取主要是通过 XmlBeanDefinitionReader 来完成的（本系列前面文章已经讲过），我们可以对文章一开始的三行代码进行改造，以便更好的体现“XmlBeanFactory 中的大部分功能实际上在 DefaultListableBeanFactory 中就已经提供好了”：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res=<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"beans.xml"</span>);</span><br><span class="line">DefaultListableBeanFactory factory=<span class="hljs-keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader=<span class="hljs-keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(res);</span><br><span class="line">User user = factory.getBean(User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>使用前四行代码代替 XmlBeanFactory，这样 XmlBeanFactory 的功能是不是就很明确了？就是前四行代码的功能。</p><h2 id="3-动态注册-Bean"><a href="#3-动态注册-Bean" class="headerlink" title="3.动态注册 Bean"></a>3.动态注册 Bean</h2><p>动态注册 Bean，这是 DefaultListableBeanFactory 的功能之一，不过准确来说应该是动态注册 BeanDefinition 。</p><p>我们先来看一个简单的例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory defaultListableBeanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">GenericBeanDefinition userBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">MutablePropertyValues pvs = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pvs.add(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">pvs.add(<span class="hljs-string">"address"</span>, <span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">userBeanDefinition.setPropertyValues(pvs);</span><br><span class="line">userBeanDefinition.setBeanClass(User.class);</span><br><span class="line">defaultListableBeanFactory.registerBeanDefinition(<span class="hljs-string">"user"</span>, userBeanDefinition);</span><br><span class="line">User user = defaultListableBeanFactory.getBean(User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>首先我们自己手动构建一个 DefaultListableBeanFactory 对象。当然也可以使用前面的 XmlBeanFactory。</p><p>然后再手动构建一个 GenericBeanDefinition。在前面的文章中，松哥和大家讲过，现在默认使用的 BeanDefinition 就是 GenericBeanDefinition，所以这里我们自己也手动构建一个 GenericBeanDefinition。有了 GenericBeanDefinition 之后，我们设置相关的类和属性。</p><p>接下来再将 userBeanDefinition 注册到 defaultListableBeanFactory。注册完成之后，我们就可以从 defaultListableBeanFactory 中获取相应的 Bean 了。</p><blockquote><p>这里说一句题外话，希望大家在阅读本系列每一篇文章的时候，能够将本系列前后文章联系起来一起理解，这样会有很多意料之外的收获。例如上面的，我们既可以声明一个 DefaultListableBeanFactory，也可以声明一个 XmlBeanFactory，那你大概就能据此推断出 XmlBeanFactory 的主要目的可能就是对资源文件进行读取和注册。</p></blockquote><p>那么到底是怎么注册的呢？我们来看一下 defaultListableBeanFactory.registerBeanDefinition 方法的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">Assert.hasText(beanName, <span class="hljs-string">"Bean name must not be empty"</span>);</span><br><span class="line">Assert.notNull(beanDefinition, <span class="hljs-string">"BeanDefinition must not be null"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (beanDefinition <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="hljs-string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BeanDefinition existingDefinition = <span class="hljs-keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line"><span class="hljs-comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="hljs-string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="hljs-string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">existingDefinition + <span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="hljs-string">"' with a different definition: replacing ["</span> + existingDefinition +</span><br><span class="line"><span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line"><span class="hljs-string">"' with an equivalent definition: replacing ["</span> + existingDefinition +</span><br><span class="line"><span class="hljs-string">"] with ["</span> + beanDefinition + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="hljs-comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line"><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames.size() + <span class="hljs-number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="hljs-keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="hljs-keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-comment">// Still in startup registration phase</span></span><br><span class="line"><span class="hljs-keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="hljs-keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">removeManualSingletonName(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.frozenBeanDefinitionNames = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (existingDefinition != <span class="hljs-keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">clearByTypeCache();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerBeanDefinition 方法是在 BeanDefinitionRegistry 接口中声明的，DefaultListableBeanFactory 类实现了 BeanDefinitionRegistry 接口，并实现了该方法，我们来看分析下该方法：</p><ol><li>首先对传入的 beanDefinition 对象进行校验，这也是注册前的最后一次校验，不过这个时候 BeanDefinition 对象已经到手了，所以这个校验并非 XML 文件校验，这里主要是对 methodOverrides 的校验。</li><li>接下来会根据 beanName 从 beanDefinitionMap 中获取 BeanDefinition，看看当前 Bean 是否已经定义过了。beanDefinitionMap 是一个 Map 集合，这个集合中 key 是 beanName，value 是 BeanDefinition 对象。</li><li>如果 BeanDefinition 已经存在了，那么接下来会判断是否允许 BeanDefinition 覆盖，如果不允许，就直接抛出异常（不知道小伙伴们有没有印象，在松哥前面的 OAuth2 系列教程中，经常需要配置允许 BeanDefinition 的覆盖，就是因为这个原因，公众号【江南一点雨】后台回复 OAuth2 获取该教程），如果允许 BeanDefinition 的覆盖，那就向 beanDefinitionMap 中再次存一次值，覆盖之前的值。</li><li>如果 BeanDefinition 不存在，那就直接注册。直接注册分两种情况：项目已经运行了和项目还没运行。</li><li>如果项目已经运行，由于 beanDefinitionMap 是一个全局变量，可能存在并发问题，所以要加锁处理。否则就直接注册，所谓的注册就是把对象存入 beanDefinitionMap 中，同时将 beanName 都存入 beanDefinitionNames 集合中。</li></ol><p>这便是 registerBeanDefinition 方法的工作流程。</p><p>有小伙伴会说，这个方法从头到尾都是 BeanDefinition，跟 Bean 有什么关系呢？</p><p>咋一看确实好像和 Bean 没有直接关系。</p><p>其实这涉及到另外一个问题，就是 Bean 的懒加载。这个时候先把 BeanDefinition 定义好，等到真正调用 Bean 的时候，才会去初始化 Bean。我们可以在 User 类的构造方法中打印日志看下，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"--------user init--------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"username='"</span> + username + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">", address='"</span> + address + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下图可以看到，当 BeanDefinition 注册完成后，User 并没有初始化，等到 getBean 方法被调用的时候，User 才初始化了。</p><p><img src="http://img.itboyhub.com/2020/07/20200711114815.png" alt></p><p><strong>需要注意的是，我们日常开发中使用的 ApplicationContext 并非懒加载，这个在松哥的 Spring 入门视频中可以看到效果【<a href="https://www.bilibili.com/video/BV1Wv41167TU" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Wv41167TU</a>】，具体原理松哥将在本系列后面的文章中和大家分享。</strong></p><p>那么如果不想懒加载该怎么办呢？当然有办法。</p><h2 id="4-提前注册-Bean"><a href="#4-提前注册-Bean" class="headerlink" title="4.提前注册 Bean"></a>4.提前注册 Bean</h2><p>在 DefaultListableBeanFactory 中还有一个 preInstantiateSingletons 方法可以提前注册 Bean，该方法是在 ConfigurableListableBeanFactory 接口中声明的，DefaultListableBeanFactory 类实现了 ConfigurableListableBeanFactory 接口并实现了接口中的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="hljs-string">"Pre-instantiating singletons in "</span> + <span class="hljs-keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line"><span class="hljs-comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-keyword">this</span>.beanDefinitionNames);</span><br><span class="line"><span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line"><span class="hljs-keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line"><span class="hljs-keyword">boolean</span> isEagerInit;</span><br><span class="line"><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="hljs-keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>preInstantiateSingletons 方法的整体逻辑比较简单，就是遍历 beanNames，对符合条件的 Bean 进行实例化，而且大家注意，这里所谓的提前初始化其实就是在我们调用 getBean 方法之前，它自己先调用了一下 getBean。</p><p>我们可以在案例中手动调用该方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory defaultListableBeanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">GenericBeanDefinition userBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">MutablePropertyValues pvs = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pvs.add(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">pvs.add(<span class="hljs-string">"address"</span>, <span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">userBeanDefinition.setPropertyValues(pvs);</span><br><span class="line">userBeanDefinition.setBeanClass(User.class);</span><br><span class="line">defaultListableBeanFactory.registerBeanDefinition(<span class="hljs-string">"user"</span>, userBeanDefinition);</span><br><span class="line">defaultListableBeanFactory.preInstantiateSingletons();</span><br><span class="line">User user = defaultListableBeanFactory.getBean(User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>此时在调用 getBean 方法之前，User 就已经初始化了，如下图：</p><p><img src="http://img.itboyhub.com/2020/07/20200711123035.png" alt></p><h2 id="5-getBean"><a href="#5-getBean" class="headerlink" title="5.getBean"></a>5.getBean</h2><p>DefaultListableBeanFactory 中另外一个重量级方法就是 getBean 了。不过 getBean 方法的真正实现是在 DefaultListableBeanFactory 的父类 AbstractBeanFactory 中，具体的实现方法是 doGetBean，本来想和大家子在这里聊一聊这个问题，但是发现这是一个非常庞大的问题，BeanFactory 和 FactoryBean 都还没和大家分享，所以这个话题我们还是暂且押后，一个点一个点来。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好啦，今天就先说这么多，每篇源码我都尽量配置套一些小案例来演示，这样避免大家看的太枯燥了，我们下周继续～</p><p>如果大家觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 源码继续开整！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解读" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 竟然可以同时存在多个过滤器链？</title>
    <link href="http://www.javaboy.org/2020/0710/springsecurity-multi-filterchain.html"/>
    <id>http://www.javaboy.org/2020/0710/springsecurity-multi-filterchain.html</id>
    <published>2020-07-10T13:24:38.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>这是来自一个小伙伴的提问，我觉得很有必要和大家聊一聊这个问题：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/06/20200617095053.png" alt></p><p>首先这个问题本身是有点问题的，因为 <code>http.authorizeRequests()</code> 并非总是第一个，虽然大部分情况下，我们看到的是第一个，但是也有很多情况 <code>http.authorizeRequests()</code> 不是首先出现。要搞明白这个问题，我们就要搞清楚 <code>http.authorizeRequests()</code> 到底是啥意思！</p><p>这就涉及到 Spring Security 中过滤器链的配置问题了，本文松哥就来和大家稍微聊一聊。</p><p>本文是 Spring Security 系列第 36 篇，阅读前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/uWib5RtH1aEC7p5VK4S1Ig" target="_blank" rel="noopener">Spring Boot+CAS 默认登录页面太丑了，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/LvMOKeX09liTvujZi6XO3Q" target="_blank" rel="noopener">用 Swagger 测试接口，怎么在请求头中携带 Token？</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li><li><a href="https://mp.weixin.qq.com/s/7T5XA1zxQkhMvffMxHKVvQ" target="_blank" rel="noopener">Spring Boot 中如何实现 HTTP 认证？</a></li><li><a href="https://mp.weixin.qq.com/s/7cm99q5ZM4qUkekx0Xa0YQ" target="_blank" rel="noopener">Spring Security 中的四种权限控制方式</a></li><li><a href="https://mp.weixin.qq.com/s/_iau1jsnc50vs794_ib0IA" target="_blank" rel="noopener">Spring Security 多种加密方案共存，老破旧系统整合利器！</a></li><li><a href="https://mp.weixin.qq.com/s/edtYkmgx_SnYoqsy-yFmsQ" target="_blank" rel="noopener">神奇！自己 new 出来的对象一样也可以被 Spring 容器管理！</a></li><li><a href="https://mp.weixin.qq.com/s/42-rjiZShvZXYM_ULQt0YQ" target="_blank" rel="noopener">Spring Security 配置中的 and 到底该怎么理解？</a></li><li><a href="https://mp.weixin.qq.com/s/f1teXTEuDR7S0j_Ml2qL8g" target="_blank" rel="noopener">一文搞定 Spring Security 异常处理机制！</a></li><li><a href="https://mp.weixin.qq.com/s/dm2SmUzb7vQZA3C0NFp86A" target="_blank" rel="noopener">写了这么多年代码，这样的登录方式还是头一回见！</a></li></ol><h2 id="1-从过滤器开始"><a href="#1-从过滤器开始" class="headerlink" title="1.从过滤器开始"></a>1.从过滤器开始</h2><p>即使大家没有仔细研究过 Spring Security 中认证、授权功能的实现机制，大概也都多多少少听说过 Spring Security 这些功能是通过过滤器来实现的。</p><p>是的，没错！Spring Security 中一共提供了 32 个过滤器，其中默认使用的有 15 个，这些过滤器松哥在以后的文章中再和大家细说，今天我们就先来看看过滤器的配置问题。</p><p>在一个 Web 项目中，请求流程大概如下图所示：</p><p><img src="http://img.itboyhub.com/2020/06/20200617100049.png" alt></p><p>请求从客户端发起（例如浏览器），然后穿过层层 Filter，最终来到 Servlet 上，被 Servlet 所处理。</p><p>那有小伙伴要问了，Spring Security 中默认的 15 个过滤器就是这样嵌套在 Client 和 Servlet 之间吗？</p><p>不是的！</p><p>上图中的 Filter 我们可以称之为 Web Filter，Spring Security 中的 Filter 我们可以称之为 Security Filter，它们之间的关系如下图：</p><p><img src="http://img.itboyhub.com/2020/06/20200617100950.png" alt></p><p>可以看到，Spring Security Filter 并不是直接嵌入到 Web Filter 中的，而是通过 FilterChainProxy 来统一管理 Spring Security Filter，FilterChainProxy 本身则通过 Spring 提供的 DelegatingFilterProxy 代理过滤器嵌入到 Web Filter 之中。</p><blockquote><p>DelegatingFilterProxy 很多小伙伴应该比较熟悉，在 Spring 中手工整合 Spring Session、Shiro 等工具时都离不开它，现在用了 Spring Boot，很多事情 Spring Boot 帮我们做了，所以有时候会感觉 DelegatingFilterProxy 的存在感有所降低，实际上它一直都在。</p></blockquote><h2 id="2-多个过滤器链"><a href="#2-多个过滤器链" class="headerlink" title="2.多个过滤器链"></a>2.多个过滤器链</h2><p>上面和大家介绍的是单个过滤器链，实际上，在 Spring Security 中，可能存在多个过滤器链。</p><p>在松哥前面讲 OAuth2 系列的时候，有涉及到多个过滤器链，但是一直没有拎出来单独讲过，今天就来和大家分享一下。</p><p>有人会问，下面这种配置是不是就是多个过滤器链？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            ...</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的配置相信大家都见过，但是这并不是多个过滤器链，这是一个过滤器链。因为不管是 <code>/admin/**</code> 还是 <code>/user/**</code> ，走过的过滤器都是一样的，只是不同的路径判断条件不一样而已。</p><p>如果系统存在多个过滤器链，多个过滤器链会在 FilterChainProxy 中进行划分，如下图：</p><p><img src="http://img.itboyhub.com/2020/06/20200617104202.png" alt></p><p>可以看到，当请求到达 FilterChainProxy 之后，FilterChainProxy 会根据请求的路径，将请求转发到不同的 Spring Security Filters 上面去，不同的 Spring Security Filters 对应了不同的过滤器，也就是不同的请求将经过不同的过滤器。</p><p>正常情况下，我们配置的都是一个过滤器链，多个过滤器链怎么配置呢？松哥给大家一个举一个简单的例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;bcrypt&#125;$2a$10$Sb1gAUH4wwazfNiqflKZve4Ubh.spJcxgHG8Cp29DeGya5zsHENqi"</span>).roles(<span class="hljs-string">"admin"</span>, <span class="hljs-string">"aaa"</span>, <span class="hljs-string">"bbb"</span>).build());</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"sang"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"江南一点雨"</span>).password(<span class="hljs-string">"&#123;MD5&#125;&#123;Wucj/L8wMTMzFi3oBKWsETNeXbMFaHZW9vCK9mahMHc=&#125;4d43db282b36d7f0421498fdc693f2a2"</span>).roles(<span class="hljs-string">"user"</span>, <span class="hljs-string">"aaa"</span>, <span class="hljs-string">"bbb"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Configuration</span></span><br><span class="line">    <span class="hljs-meta">@Order</span>(<span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.antMatcher(<span class="hljs-string">"/foo/**"</span>)</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .anyRequest().hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Configuration</span></span><br><span class="line">    <span class="hljs-meta">@Order</span>(<span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultWebSecurityConfig2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http.antMatcher(<span class="hljs-string">"/bar/**"</span>)</span><br><span class="line">                    .authorizeRequests()</span><br><span class="line">                    .anyRequest().hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">                    .and()</span><br><span class="line">                    .formLogin()</span><br><span class="line">                    .permitAll()</span><br><span class="line">                    .and()</span><br><span class="line">                    .csrf().disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，SecurityConfig 不再需要继承自 WebSecurityConfigurerAdapter 了，只是作为一个普通的配置类，加上 @Configuration 注解即可。</li><li>提供 UserDetailsService 实例，相当于是我们的数据源。</li><li>创建静态内部类继承 WebSecurityConfigurerAdapter 类，同时用 @Configuration 注解标记静态内部类是一个配置类，配置类里边的代码就和之前的一样了，无需赘述。</li><li>每一个静态内部类相当于就是一个过滤器链的配置。</li><li>注意在静态内部类里边，我没有使用 <code>http.authorizeRequests()</code> 开始，<code>http.authorizeRequests()</code> 配置表示该过滤器链过滤的路径是 <code>/**</code>。在静态内部类里边，我是用了 <code>http.antMatcher(&quot;/bar/**&quot;)</code> 开启配置，表示将当前过滤器链的拦截范围限定在 <code>/bar/**</code>。</li><li>当存在多个过滤器链的时候，必然会有一个优先级的问题，所以每一个过滤器链的配置类上通过 @Order(2) 注解来标记优先级。</li></ol><p>从上面这段代码中大家可以看到，configure(HttpSecurity http) 方法似乎就是在配置过滤器链？是的没错！我们在该方法中的配置，都是在添加/移除/修改 Spring Security 默认提供的过滤器，所以该方法就是在配置 Spring Security 中的过滤器链，至于是怎么配置的，松哥以后抽时间再来和大家细说。</p><h2 id="3-回到问题"><a href="#3-回到问题" class="headerlink" title="3.回到问题"></a>3.回到问题</h2><p>最后，我们在回到一开始小伙伴提的问题。</p><p>首先，<code>http.authorizeRequests()</code> 配置并非总在第一行出现，如果只有一个过滤器链，他总是在第一行出现，表示该过滤器链的拦截规则是 <code>/**</code>（<strong>请求只有先被过滤器链拦截下来，接下来才会进入到不同的 Security Filters 中进行处理</strong>），如果存在多个过滤器链，就不一定了。</p><p>仅仅从字面意思来理解，authorizeRequests() 方法的返回值是 ExpressionUrlAuthorizationConfigurer<httpsecurity>.ExpressionInterceptUrlRegistry，ExpressionUrlAuthorizationConfigurer 可以为多组不同的 RequestMatcher 配置不同的权限规则，就是大家看到的 <code>.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;admin&quot;).antMatchers(&quot;/user/**&quot;).hasRole(&quot;user&quot;)</code>。</httpsecurity></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和小伙伴们简单分享一下 Spring Security 中过滤器链的问题，后面松哥再抽时间和大家聊一聊过滤器链中每一个过滤器的配置以及含义～</p><p>如果小伙伴们觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是来自一个小伙伴的提问，我觉得很有必要和大家聊一聊这个问题：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你搭建 Spring 源码分析环境（昨天视频笔记）</title>
    <link href="http://www.javaboy.org/2020/0708/source-code.html"/>
    <id>http://www.javaboy.org/2020/0708/source-code.html</id>
    <published>2020-07-08T13:24:15.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>最近每周和小伙伴们分享一篇 Spring 源码文章，不知不觉已经连着发了 5 篇啦：</p><a id="more"></a><ol><li><a href="https://mp.weixin.qq.com/s/1ImVkjdmcllArzPOSksNoA" target="_blank" rel="noopener">Spring 源码解读计划</a></li><li><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a></li><li><a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">Spring 源码第二弹！XML 文件解析流程</a></li><li><a href="https://mp.weixin.qq.com/s/vXD79ucsRjbQWbogrzdq9g" target="_blank" rel="noopener">Spring 源码第三弹！EntityResolver 是个什么鬼？</a></li><li><a href="https://mp.weixin.qq.com/s/X36YBS9WRyScYO9ZtH5v_A" target="_blank" rel="noopener">Spring 源码第四弹！深入理解 BeanDefinition</a></li></ol><p>老实说，松哥写这五篇文章的时候，为了图方便，我就没在本地搭建 Spring 源码环境，因为在 IDEA 里边通过 Maven 依赖也可以方便的下载 Spring 源码，我就用了这种方式。</p><p>但是后来搞着搞着，有的时候想在源码上写点注释却写不了，因为通过 Maven 依赖的方式下载的 Spring 源码是只读的，没法修改，有的时候想自己修改一下看看效果也不方便。</p><p>所以想了想还是花点时间搭建一个 Spring 源码环境吧，也不费啥事。要做就做专业的，毕竟要做 Spring 源码分析系列文章，搭建一个 Spring 源码环境也是应该的。</p><p>那就搞起！</p><h2 id="1-源码获取"><a href="#1-源码获取" class="headerlink" title="1.源码获取"></a>1.源码获取</h2><p>Spring 源码仓库地址是：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework</a>。</p><p>大家可以直接下载 zip 压缩包，也可以 clone，建议通过 clone 的方式获取源码，这样方便切换到不同的分支查看不同时期的代码。</p><p>直接从 GitHub 上 clone 源码有点慢，所以我们可以先在自己的 Gitee 账户上新建一个仓库，新建的仓库选择从【从 GitHub/GitLab 导入仓库】，将 Spring 源码仓库导入到自己的 Gitee 上，然后再从 Gitee 上 clone，clone 速度提升十倍以上。</p><p>当然，如果小伙伴们懒得在 Gitee 上搞这一套，松哥现在已经弄好了，你也可以直接从下面这个地址 clone：</p><ul><li><a href="https://gitee.com/lenve/spring-framework" target="_blank" rel="noopener">https://gitee.com/lenve/spring-framework</a></li></ul><p>代码 clone 应该都会吧？算了本着手把手的原则，我还是说一下，执行如下命令 clone 代码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/lenve/spring-framework</span><br></pre></td></tr></table></figure><h2 id="2-Gradle-问题"><a href="#2-Gradle-问题" class="headerlink" title="2.Gradle 问题"></a>2.Gradle 问题</h2><p>最新版的 Spring 源码是基于 Gradle 来构建的，松哥 2016 年那会搞 Android 的时候，Gradle 经常使用，现在搞 Java 后，还是以 Maven 为主，Gradle 使用稍微少一些。这里我们先来解决 Gradle 的问题。</p><p>有两种办法：</p><ol><li>在电脑本地安装。</li><li>加载 Spring 源码时当场安装。</li></ol><p>无论哪种方式，建议都安装适合 Spring 源码的版本，避免后期一些不必要的问题。</p><p>Spring 源码 clone 下来之后，大家在 <code>spring-framework/gradle/wrapper/gradle-wrapper.properties</code> 文件中，我们可以看到当前源码使用的 Gradle 版本：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-6.5.1-bin.zip</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br></pre></td></tr></table></figure><p>distributionUrl 中就是你要下载的 Gradle 地址，从中就可以看出 Gradle 版本号。</p><p>如果你想采用第一种方式安装 Gradle，就使用 distributionUrl 给出的地址去下载对应的 Gradle，下载成功后，解压，配置环境变量即可。这个比较简单，我就不多说了。</p><p>如果你想采用第二种方式，那么现在什么都不用做，一会导入项目的时候会自动下载 Gradle（松哥这里图省事采用这种方式）。</p><h2 id="3-修改下载源"><a href="#3-修改下载源" class="headerlink" title="3.修改下载源"></a>3.修改下载源</h2><p>默认路径下载依赖构建项目比较慢，所以源码下载下来之后，我们首先进入到 build.gradle 文件中，添加下载源（原有的保留，添加 Alibaba 下载源）：</p><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">repositories</span> &#123;</span><br><span class="line">maven&#123; url <span class="hljs-string">'http://maven.aliyun.com/nexus/content/groups/public/'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-导入项目"><a href="#4-导入项目" class="headerlink" title="4.导入项目"></a>4.导入项目</h2><p>接下来打开 IDEA，导入 Spring 源码，注意选择 Import Project：</p><p><img src="http://img.itboyhub.com/2020/07/20200706154849.png" alt></p><p>注意各个选项不要选择错了：</p><p><img src="http://img.itboyhub.com/2020/07/20200706154943.png" alt></p><p>项目导入成功之后，接下来会去下载相关依赖，这个过程所耗费的时间视网络情况而定。</p><p>依赖都下载之后，接下来编译项目，在菜单栏选择 Build-&gt;Build Project，或者直接点击🔨图标进行编译，如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200706155435.png" alt></p><p>编译成功后，每个项目下都会多出一个 build 目录，相当于 Maven 里边的 target，如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200706155558.png" alt></p><h2 id="5-添加模块"><a href="#5-添加模块" class="headerlink" title="5.添加模块"></a>5.添加模块</h2><p>接下来我们来添加一个 module，来使用一下这些源码。</p><p>项目右键单击，选择 New-&gt;Module：</p><p><img src="http://img.itboyhub.com/2020/07/20200706155840.png" alt></p><p>选择 Gradle 创建一个 Java 项目：</p><p><img src="http://img.itboyhub.com/2020/07/20200706155957.png" alt></p><p>给 module 取一个名字：</p><p><img src="http://img.itboyhub.com/2020/07/20200706160047.png" alt></p><p>在新创建的 module 的 build.gradle 文件中，我们添加 spring-context 依赖，这个相当于 Maven 中的 pom.xml：</p><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">compile</span>(<span class="hljs-keyword">project</span>(<span class="hljs-string">":spring-context"</span>))</span><br><span class="line">    testCompile <span class="hljs-keyword">group</span>: <span class="hljs-string">'junit'</span>, name: <span class="hljs-string">'junit'</span>, version: <span class="hljs-string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们写一个简单的 spring-context 的测试看一下。</p><p>首先创建一个 User 类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> String username;</span><br><span class="line"><span class="hljs-keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +</span><br><span class="line"><span class="hljs-string">"username='"</span> + username + <span class="hljs-string">'\''</span> +</span><br><span class="line"><span class="hljs-string">", address='"</span> + address + <span class="hljs-string">'\''</span> +</span><br><span class="line"><span class="hljs-string">'&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建 resources/beans.xml 文件，配置该 Bean：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.test.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"javaboy"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"www.javaboy.org"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后创建测试方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:beans.xml"</span>);</span><br><span class="line">User user = ctx.getBean(User.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行该方法，结果如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200706161913.png" alt></p><p>如此，我们本地的 Spring 源码环境就算是搭建成功了。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>非常幸运，很多小伙伴反映的搭建 Spring 源码的问题我竟然一个都没遇到！</p><p>感兴趣的小伙伴可以试试松哥上面给出的方案。</p><p>好啦，小伙伴们要是觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近每周和小伙伴们分享一篇 Spring 源码文章，不知不觉已经连着发了 5 篇啦：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解读" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码第四弹！深入理解 BeanDefinition</title>
    <link href="http://www.javaboy.org/2020/0706/beandefinition.html"/>
    <id>http://www.javaboy.org/2020/0706/beandefinition.html</id>
    <published>2020-07-06T13:23:58.000Z</published>
    <updated>2020-08-04T13:56:44.359Z</updated>
    
    <content type="html"><![CDATA[<p>聚沙成塔！不知不觉 Spring 源码已经更到第五篇啦～</p><a id="more"></a><p>看源码之前，要先会用功能，这是最基本的，因为在源码讲解中，默认大家已经熟知 Spring 基本用法了，如果还不熟悉 Spring 的基本用法，可以看一下松哥发布在 B 站上的免费入门视频：<a href="https://www.bilibili.com/video/BV1Wv41167TU" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Wv41167TU</a>。</p><p>上篇文章和小伙伴们介绍了 Spring 源码中的 EntityResolver，这个是用来解决 XML 文件校验问题的。</p><p>接下来本来应该接着第二弹的 XML 文件解析流程继续往下走了，考虑到接下来我们会涉及到一个重要的概念 BeanDefinition，而有的小伙伴对此可能还不熟悉，因此本文松哥就先来和大家捋一捋 BeanDefinition 是什么东西！</p><p>本文是 Spring 源码解读第五篇，阅读本系列前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/1ImVkjdmcllArzPOSksNoA" target="_blank" rel="noopener">Spring 源码解读计划</a></li><li><a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a></li><li><a href="https://mp.weixin.qq.com/s/Rr7FBgau8hT0t4X9XtXdGQ" target="_blank" rel="noopener">Spring 源码第二弹！XML 文件解析流程</a></li><li><a href="https://mp.weixin.qq.com/s/vXD79ucsRjbQWbogrzdq9g" target="_blank" rel="noopener">Spring 源码第三弹！EntityResolver 是个什么鬼？</a></li></ol><h2 id="1-BeanDefinition"><a href="#1-BeanDefinition" class="headerlink" title="1.BeanDefinition"></a>1.BeanDefinition</h2><p>在 Spring 容器中，我们广泛使用的是一个一个的 Bean，BeanDefinition 从名字上就可以看出是关于 Bean 的定义。</p><p>事实上就是这样，我们在 XML 文件中配置的 Bean 的各种属性，这些属性不仅仅是和对象相关，Spring 容器还要解决 Bean 的生命周期、销毁、初始化等等各种操作，我们定义的关于 Bean 的生命周期、销毁、初始化等操作总得有一个对象来承载，那么这个对象就是 BeanDefinition。</p><p>XML 中定义的各种属性都会先加载到 BeanDefinition 上，然后通过 BeanDefinition 来生成一个 Bean，从这个角度来说，BeanDefinition 和 Bean 的关系有点类似于类和对象的关系。</p><p>要理解 BeanDefinition，我们从 BeanDefinition 的继承关系开始看起。</p><p><img src="http://img.itboyhub.com/2020/BeanDefinition.png" alt></p><p>BeanDefinition 是一个接口，继承自 BeanMetadataElement 和 AttributeAccessor 接口。</p><ul><li>BeanMetadataElement：该接口只有一个方法 getSource，该方法返回 Bean 的来源。</li><li>AttributeAccessor：该接口主要规范了问任意对象元数据的方法。</li></ul><p>我们来看下 AttributeAccessor：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AttributeAccessor</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(String name, @Nullable Object value)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getAttribute</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">removeAttribute</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAttribute</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">String[] attributeNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了元数据的访问接口，具体的实现则是 AttributeAccessorSupport，这些数据采用 LinkedHashMap 进行存储。</p><p>这是 BeanDefinition 所继承的两个接口。接下来我们来看下 BeanDefinition 接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AttributeAccessor</span>, <span class="hljs-title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line">String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"><span class="hljs-keyword">int</span> ROLE_APPLICATION = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ROLE_SUPPORT = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ROLE_INFRASTRUCTURE = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParentName</span><span class="hljs-params">(@Nullable String parentName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getParentName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setBeanClassName</span><span class="hljs-params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getBeanClassName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setScope</span><span class="hljs-params">(@Nullable String scope)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getScope</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setLazyInit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isLazyInit</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDependsOn</span><span class="hljs-params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">String[] getDependsOn();</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAutowireCandidate</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAutowireCandidate</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPrimary</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> primary)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrimary</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFactoryBeanName</span><span class="hljs-params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getFactoryBeanName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setFactoryMethodName</span><span class="hljs-params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getFactoryMethodName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">ConstructorArgumentValues <span class="hljs-title">getConstructorArgumentValues</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasConstructorArgumentValues</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function">MutablePropertyValues <span class="hljs-title">getPropertyValues</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPropertyValues</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setInitMethodName</span><span class="hljs-params">(@Nullable String initMethodName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getInitMethodName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDestroyMethodName</span><span class="hljs-params">(@Nullable String destroyMethodName)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getDestroyMethodName</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setRole</span><span class="hljs-params">(<span class="hljs-keyword">int</span> role)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRole</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setDescription</span><span class="hljs-params">(@Nullable String description)</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getDescription</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">ResolvableType <span class="hljs-title">getResolvableType</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAbstract</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">String <span class="hljs-title">getResourceDescription</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">BeanDefinition <span class="hljs-title">getOriginatingBeanDefinition</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinition 中的方法虽然多，但是结合我们平时在 XML 中的配置，这些方法其实都很好理解：</p><ol><li>首先一开始定义了两个变量用来描述 Bean 是不是单例的，后面的 setScope/getScope 方法可以用来修改/获取 scope 属性。</li><li>ROLE_xxx 用来描述一个 Bean 的角色，ROLE_APPLICATION 表示这个 Bean 是用户自己定义的 Bean；ROLE_SUPPORT 表示这个 Bean 是某些复杂配置的支撑部分；ROLE_INFRASTRUCTURE 表示这是一个 Spring 内部的 Bean，通过 setRole/getRole 可以修改。</li><li>setParentName/getParentName 用来配置 parent 的名称，这块可能有的小伙伴使用较少，这个对应着 XML 中的 <code>&lt;bean parent=&quot;&quot;&gt;</code> 配置。</li><li>setBeanClassName/getBeanClassName 这个就是配置 Bean 的 Class 全路径，对应 XML 中的 <code>&lt;bean class=&quot;&quot;&gt;</code> 配置。</li><li>setLazyInit/isLazyInit 配置/获取 Bean 是否懒加载，这个对应了 XML 中的 <code>&lt;bean lazy-init=&quot;&quot;&gt;</code> 配置。</li><li>setDependsOn/getDependsOn 配置/获取 Bean 的依赖对象，这个对应了 XML 中的 <code>&lt;bean depends-on=&quot;&quot;&gt;</code> 配置。</li><li>setAutowireCandidate/isAutowireCandidate 配置/获取 Bean 是否是自动装配，对应了 XML 中的 <code>&lt;bean autowire-candidate=&quot;&quot;&gt;</code> 配置。</li><li>setPrimary/isPrimary 配置/获取当前 Bean 是否为首选的 Bean，对应了 XML 中的 <code>&lt;bean primary=&quot;&quot;&gt;</code> 配置。</li><li>setFactoryBeanName/getFactoryBeanName 配置/获取 FactoryBean 的名字，对应了 XML 中的 <code>&lt;bean factory-bean=&quot;&quot;&gt;</code> 配置，factory-bean 松哥在之前的入门视频中讲过，小伙伴们可以参考这里:<a href="https://www.bilibili.com/video/BV1Wv41167TU" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Wv41167TU</a>。</li><li>setFactoryMethodName/getFactoryMethodName 和上一条成对出现的，对应了 XML 中的 <code>&lt;bean factory-method=&quot;&quot;&gt;</code> 配置，不再赘述。</li><li>getConstructorArgumentValues 返回该 Bean 构造方法的参数值。</li><li>hasConstructorArgumentValues 判断上一条是否是空对象。</li><li>getPropertyValues 这个是获取普通属性的集合。</li><li>hasPropertyValues 判断上一条是否为空对象。</li><li>setInitMethodName/setDestroyMethodName 配置 Bean 的初始化方法、销毁方法。</li><li>setDescription/getDescription 配置/返回 Bean 的描述。</li><li>isSingleton Bean 是否为单例。</li><li>isPrototype Bean 是否为原型。</li><li>isAbstract Bean 是否抽象。</li><li>getResourceDescription 返回定义 Bean 的资源描述。</li><li>getOriginatingBeanDefinition 如果当前 BeanDefinition 是一个代理对象，那么该方法可以用来返回原始的 BeanDefinition 。</li></ol><p>这个就是 BeanDefinition 的定义以及它里边方法的含义。</p><h2 id="2-BeanDefinition-实现类"><a href="#2-BeanDefinition-实现类" class="headerlink" title="2.BeanDefinition 实现类"></a>2.BeanDefinition 实现类</h2><p>上面只是 BeanDefinition 接口的定义，BeanDefinition 还拥有诸多实现类，我们也来大致了解下。</p><p>先来看一张继承关系图：</p><p><img src="http://img.itboyhub.com/2020/07/BeanDefinition.png" alt></p><p>这么多实现类看着有点眼花缭乱，不过搞清楚了每一个接口和类的作用，再看就很容易了。</p><h3 id="2-1-AbstractBeanDefinition"><a href="#2-1-AbstractBeanDefinition" class="headerlink" title="2.1 AbstractBeanDefinition"></a>2.1 AbstractBeanDefinition</h3><p>AbstractBeanDefinition 是一个抽象类，它根据 BeanDefinition 中定义的接口提供了相应的属性，并实现了 BeanDefinition 中定义的一部分方法。BeanDefinition 中原本只是定义了一系列的 get/set 方法，并没有提供对应的属性，在 AbstractBeanDefinition 中将所有的属性定义出来了。</p><p>后面其他的实现类也基本上都是在 AbstractBeanDefinition 的基础上完成的。</p><h3 id="2-2-RootBeanDefinition"><a href="#2-2-RootBeanDefinition" class="headerlink" title="2.2 RootBeanDefinition"></a>2.2 RootBeanDefinition</h3><p>这是一个比较常用的实现类，对应了一般的元素标签。</p><h3 id="2-3-ChildBeanDefinition"><a href="#2-3-ChildBeanDefinition" class="headerlink" title="2.3 ChildBeanDefinition"></a>2.3 ChildBeanDefinition</h3><p>可以让子 BeanDefinition 定义拥有从父 BeanDefinition 那里继承配置的能力。</p><h3 id="2-4-GenericBeanDefinition"><a href="#2-4-GenericBeanDefinition" class="headerlink" title="2.4 GenericBeanDefinition"></a>2.4 GenericBeanDefinition</h3><p>GenericBeanDefinition 是从 Spring2.5 以后新加入的 BeanDefinition 实现类。GenericBeanDefinition 可以动态设置父 Bean，同时兼具 RootBeanDefinition 和 ChildBeanDefinition 的功能。</p><h3 id="2-5-AnnotatedBeanDefinition"><a href="#2-5-AnnotatedBeanDefinition" class="headerlink" title="2.5 AnnotatedBeanDefinition"></a>2.5 AnnotatedBeanDefinition</h3><p>表示注解类型 BeanDefinition，拥有获取注解元数据和方法元数据的能力。</p><h3 id="2-6-AnnotatedGenericBeanDefinition"><a href="#2-6-AnnotatedGenericBeanDefinition" class="headerlink" title="2.6 AnnotatedGenericBeanDefinition"></a>2.6 AnnotatedGenericBeanDefinition</h3><p>使用了 @Configuration 注解标记配置类会解析为 AnnotatedGenericBeanDefinition。</p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3.实践"></a>3.实践</h2><p>理论讲了这么多，接下来我们通过几行代码来实践下，验证一下我们前面所说的对不对。</p><p>首先项目中添加 spring-context 依赖，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们来创建一个 User 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"username='"</span> + username + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">", address='"</span> + address + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们先来验证 RootBeanDefinition。我们自己纯手工定义一个 RootBeanDefinition，并且将之注册到 Spring 容器中去。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">MutablePropertyValues pvs = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pvs.add(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">pvs.add(<span class="hljs-string">"address"</span>, <span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">RootBeanDefinition rootBeanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition(User.class, <span class="hljs-keyword">null</span>, pvs);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"user"</span>,rootBeanDefinition);</span><br><span class="line">ctx.refresh();</span><br><span class="line">User bean = ctx.getBean(User.class);</span><br><span class="line">System.out.println(bean);</span><br></pre></td></tr></table></figure><p>MutablePropertyValues 是定义对象中的一个一个属性，构造 RootBeanDefinition 的时候，我们传入了类名称和属性集合，最终把 rootBeanDefinition 注册到容器中去。剩下的事情由容器完成，然后我们就可以从容器中获取到 User 对象了。</p><p>最终输出结果如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;username=<span class="hljs-string">'javaboy'</span>, address=<span class="hljs-string">'www.javaboy.org'</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>看了这个例子，小伙伴们应该能够大致明白，我们在 XML 中定义的各种属性，就是先被解析到 BeanDefinition 中，然后再注册到 Spring 容器中去，最后拿到我们需要的 Bean。</strong></p><p>ChildBeanDefinition 具有从父 Bean 继承数据的能力，我们来看下这个怎么用。</p><p>首先新建一个 Person 类，Person 类在 User 类的基础上增加一个 nickname 属性，这样 Person 就可以继承到 User 的 username 和 address 两个属性的值了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">    <span class="hljs-keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"Person&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"username='"</span> + username + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">", address='"</span> + address + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">", nickname='"</span> + nickname + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNickname</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNickname</span><span class="hljs-params">(String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来自定义 ChildBeanDefinition：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">MutablePropertyValues pvs = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pvs.add(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">pvs.add(<span class="hljs-string">"address"</span>, <span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">RootBeanDefinition rootBeanDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition(User.class, <span class="hljs-keyword">null</span>, pvs);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"user"</span>,rootBeanDefinition);</span><br><span class="line">ChildBeanDefinition childBeanDefinition = <span class="hljs-keyword">new</span> ChildBeanDefinition(<span class="hljs-string">"user"</span>);</span><br><span class="line">childBeanDefinition.setBeanClass(Person.class);</span><br><span class="line">childBeanDefinition.getPropertyValues().add(<span class="hljs-string">"nickname"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"person"</span>, childBeanDefinition);</span><br><span class="line">ctx.refresh();</span><br><span class="line">User user = ctx.getBean(User.class);</span><br><span class="line">Person person = ctx.getBean(Person.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">System.out.println(<span class="hljs-string">"person = "</span> + person);</span><br></pre></td></tr></table></figure><p>首先定义 RootBeanDefinition 并注册到 Spring 容器中，然后再定义 ChildBeanDefinition，ChildBeanDefinition 继承了 RootBeanDefinition 中现有的属性值。</p><p>最后我们从 Spring 容器中获取 User 和 Person，打印结果如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;username=<span class="hljs-string">'javaboy'</span>, address=<span class="hljs-string">'www.javaboy.org'</span>&#125;</span><br><span class="line">person = Person&#123;username=<span class="hljs-string">'javaboy'</span>, address=<span class="hljs-string">'www.javaboy.org'</span>, nickname=<span class="hljs-string">'江南一点雨'</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Person 确实继承了 User 的属性值。</p><p>RootBeanDefinition 和 ChildBeanDefinition 都可以被 GenericBeanDefinition 代替，效果一样，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">MutablePropertyValues pvs = <span class="hljs-keyword">new</span> MutablePropertyValues();</span><br><span class="line">pvs.add(<span class="hljs-string">"username"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">pvs.add(<span class="hljs-string">"address"</span>, <span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">GenericBeanDefinition rootBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">rootBeanDefinition.setBeanClass(User.class);</span><br><span class="line">rootBeanDefinition.setPropertyValues(pvs);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"user"</span>,rootBeanDefinition);</span><br><span class="line">GenericBeanDefinition childBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();</span><br><span class="line">childBeanDefinition.setParentName(<span class="hljs-string">"user"</span>);</span><br><span class="line">childBeanDefinition.setBeanClass(Person.class);</span><br><span class="line">childBeanDefinition.getPropertyValues().add(<span class="hljs-string">"nickname"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">ctx.registerBeanDefinition(<span class="hljs-string">"person"</span>, childBeanDefinition);</span><br><span class="line">ctx.refresh();</span><br><span class="line">User user = ctx.getBean(User.class);</span><br><span class="line">Person person = ctx.getBean(Person.class);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br><span class="line">System.out.println(<span class="hljs-string">"person = "</span> + person);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;username=<span class="hljs-string">'javaboy'</span>, address=<span class="hljs-string">'www.javaboy.org'</span>&#125;</span><br><span class="line">person = Person&#123;username=<span class="hljs-string">'javaboy'</span>, address=<span class="hljs-string">'www.javaboy.org'</span>, nickname=<span class="hljs-string">'江南一点雨'</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看到，和前面的运行效果一致。</p><p>在我们本系列前面文章（<a href="https://mp.weixin.qq.com/s/OVcBCs7rluNXdKI2bNshQw" target="_blank" rel="noopener">Spring 源码第一篇开整！配置文件是怎么加载的？</a>）的案例中，默认使用的也是 GenericBeanDefinition，如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200704202229.png" alt></p><p>现在 Spring Boot 广泛流行之后，Java 配置使用越来越多，以 @Configuration 注解标记配置类会被解析为 AnnotatedGenericBeanDefinition；以 @Bean 注解标记的 Bean 会被解析为 ConfigurationClassBeanDefinition。</p><p>我们新建一个 MyConfig 配置类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看获取到的 BeanDefinition 结果如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200704203640.png" alt></p><p>而其他 @Service、@Controller、@Repository 以及 @Component 等注解标记的 Bean 则会被识别为 ScannedGenericBeanDefinition。这个我就不一一演示了，小伙伴们可以自行测试哦。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天主要是和小伙伴们介绍一下 Spring 中的 BeanDefinition。通过上面的原理+案例，相信小伙伴们已经明白，我们通过 XML 或者 Java 注解配置的 Bean，我们定义的东西会先被解析成 BeanDefinition，然后再通过 BeanDefinition 来生成我们所需要的 Bean。</p><p>下篇文章我们就来看这个 BeanDefinition 到底是怎么从 XML 文件中生成的。</p><p>好啦，小伙伴们如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;聚沙成塔！不知不觉 Spring 源码已经更到第五篇啦～&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解读" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
</feed>
