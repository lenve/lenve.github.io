<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-05-10T12:59:39.853Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推荐三个 Vue 后台管理模版，配合 Spring Boot 使用真香！</title>
    <link href="http://www.javaboy.org/2020/0509/vue-template.html"/>
    <id>http://www.javaboy.org/2020/0509/vue-template.html</id>
    <published>2020-05-09T12:36:11.000Z</published>
    <updated>2020-05-10T12:59:39.853Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为因为项目的原因，一直在寻找一款合适的前端模版，之前的 Vue 前端页面都是自己写的，写多了就烦了，因为功能都差不多，写来写去就没意思了。</p><p>所以在新项目中想看看市面上的 Vue 后台管理模版，找个现成的，改一改基本就 OK 了，团队也省事一些。</p><a id="more"></a><p>老实说，Vue 的生态还是相当丰富的，经典的、新生的后台管理框架都有，我这里和大家分享我们这次重点比较的三个。</p><h2 id="vue-element-admin"><a href="#vue-element-admin" class="headerlink" title="vue-element-admin"></a>vue-element-admin</h2><ul><li>GitHub 地址：<a href="https://github.com/PanJiaChen/vue-element-admin" target="_blank" rel="noopener">https://github.com/PanJiaChen/vue-element-admin</a></li><li>演示地址：<a href="https://panjiachen.github.io/vue-element-admin" target="_blank" rel="noopener">https://panjiachen.github.io/vue-element-admin</a></li></ul><p>这个项目名气还是挺大的，在我刚开始做 vhr 的时候，就有了解过这个项目，那个时候这个项目才刚刚开发没多久，star 都没几个，现在已然混成一方霸主了。</p><p>vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui 实现。它使用了最新的前端技术栈，内置了 i18n 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件，它可以帮助你快速搭建企业级中后台产品原型。</p><p>可以说，这个项目的功能还是比较全的，它里边将一些常见的功能模块如权限管理等都做好了，有的时候，你甚至会觉得这个项目有些臃肿。</p><p>我们来看一张效果图：</p><p><img src="http://img.itboyhub.com/2020/04/20200508161409.png" alt></p><p>这个开源项目也是我们这里最终选定的方案，选定它有几方面的原因：</p><ol><li>这个项目的开发时间较早，目前相对来说可能 BUG 较少，比较稳定。</li><li>该项目目前依然非常活跃，作者还在不断的完善。</li><li>功能齐全，和其他项目相比，功能上基本没有劣势。</li><li>相对于其他 UI 框架，ElementUI 使用更多一些，这对于一个商用项目还是非常重要的。</li></ol><p>当然，使用开源项目肯定不可能完全契合自己的需求的，这种就要在开发中，再去慢慢克服了。</p><h2 id="ant-design-vue-pro"><a href="#ant-design-vue-pro" class="headerlink" title="ant-design-vue-pro"></a>ant-design-vue-pro</h2><ul><li>GitHub 地址：<a href="https://github.com/vueComponent/ant-design-vue-pro" target="_blank" rel="noopener">https://github.com/vueComponent/ant-design-vue-pro</a></li><li>演示地址：<a href="https://preview.pro.loacg.com" target="_blank" rel="noopener">https://preview.pro.loacg.com</a></li></ul><p>这个也是我们当时重点比较的项目之一。</p><p>Ant Design Pro 是一个企业级中后台前端/设计解决方案，秉承 Ant Design 的设计价值观，致力于在设计规范和基础组件的基础上，继续向上构建，提炼出典型模板/业务组件/配套设计资源，进一步提升企业级中后台产品设计研发过程中的『用户』和『设计者』的体验。随着『设计者』的不断反馈，持续迭代，逐步沉淀和总结出更多设计模式和相应的代码实现。</p><p>我们来看个效果图：</p><p><img src="http://img.itboyhub.com/2020/04/20200508162634.png" alt></p><p>这个项目也很优秀，但是最终却“落榜”了，主要是考虑到以下几个原因：</p><ol><li>这个项目看起来没有 vue-element-admin 那么“臃肿”，当然也意味着它的功能比较少。</li><li>ant design 本身发展时间挺久了，但是一直都是跟 React 玩，去年才开始支持 Vue，这也是这个 Ant Design Pro 看起来比较简单的原因。</li><li>这个项目权限部分的代码，和 vue-element-admin 具有高度相似性，如出一辙，所以还不如直接上 vue-element-admin。</li></ol><blockquote><p>话说回来，无论用哪个开源项目，想让项目契合自己的实际应用场景，都是需要大刀阔斧的修改的，开源项目拿来直接就能用的很少，从这个角度讲，其实用哪个都无所谓，反正自己都还要改不少东西。但是由于只能选择一个，我们还是选择了更懂 Vue 的 vue-element-admin。</p></blockquote><h2 id="iview-admin"><a href="#iview-admin" class="headerlink" title="iview-admin"></a>iview-admin</h2><ul><li>GitHub 地址：<a href="https://github.com/iview/iview-admin" target="_blank" rel="noopener">https://github.com/iview/iview-admin</a></li><li>演示地址：<a href="https://admin.iviewui.com" target="_blank" rel="noopener">https://admin.iviewui.com</a></li></ul><p>iView-admin 是 iView 生态中的成员之一，是一套采用前后端分离开发模式，基于 Vue 的后台管理系统前端解决方案。iView-admin2.0 脱离 1.x 版本进行重构，换用 Webpack4.0 + Vue-cli3.0 作为基本开发环境。内置了开发后台管理系统常用的逻辑功能，和开箱即用的业务组件，旨在让开发者能够以最小的成本开发后台管理系统，降低开发量。</p><p>看惯了 ElementUI ，偶尔看一看 iview 或者 ant design，感觉还蛮清新的。</p><p>来看一看它的效果图：<br><img src="http://img.itboyhub.com/2020/04/20200508174653.png" alt></p><blockquote><p>老实说，这些框架同质化太严重了，除了 UI 不一样，其他的基本上没啥区别，所以我们最终还是选择了更加经典的 vue-element-admin。</p></blockquote><p>我们主要是在这三款中进行比较的，所以这里主要和大家介绍这三个，小伙伴们要是用过其他好用的，欢迎留言区提出来哦～</p><h2 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h2><p>最后我再啰嗦一句，这种前端框架要如何学习的问题。</p><p>如果你是一个前端新手，刷过 Vue 官网但是还没做过 SPA 应用（甚至没听说过 SPA 应用），那么这三个框架对你来说还是蛮有挑战的，上手并不容易，我也不是特别建议使用这个来入门。</p><p>原因很简单，这三个前端框架都算是比较专业的前端框架，里边集成了很多东西，如果你是新手的话，很容易就搞懵了。</p><p>最好自己先做过一些 SPA 应用，对前端的整体流程有一个基本把握，再去学习这些框架，相对而言就会容易很多。说到这里，如果大家感兴趣，不妨看看松哥的：<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">微人事项目视频教程</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为因为项目的原因，一直在寻找一款合适的前端模版，之前的 Vue 前端页面都是自己写的，写多了就烦了，因为功能都差不多，写来写去就没意思了。&lt;/p&gt;
&lt;p&gt;所以在新项目中想看看市面上的 Vue 后台管理模版，找个现成的，改一改基本就 OK 了，团队也省事一些。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</title>
    <link href="http://www.javaboy.org/2020/0508/springboot-vue-session-management.html"/>
    <id>http://www.javaboy.org/2020/0508/springboot-vue-session-management.html</id>
    <published>2020-05-08T12:35:55.000Z</published>
    <updated>2020-05-10T12:58:57.163Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">上篇文章</a>中，我们讲了在 Spring Security 中如何踢掉前一个登录用户，或者禁止用户二次登录，通过一个简单的案例，实现了我们想要的效果。</p><p>但是有一个不太完美的地方，就是我们的用户是配置在内存中的用户，我们没有将用户放到数据库中去。正常情况下，松哥在 Spring Security 系列中讲的其他配置，大家只需要参考<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a>一文，将数据切换为数据库中的数据即可。</p><a id="more"></a><p>但是，在做 Spring Security 的 session 并发处理时，直接将内存中的用户切换为数据库中的用户会有问题，今天我们就来说说这个问题，顺便把这个功能应用到微人事中（<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>）。</p><p>本文是松哥最近在连载的 Spring Security 系列第 14 篇，阅读本系列前面的文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li></ol><p>本文的案例将基于<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a>一文来构建，所以重复的代码我就不写了，小伙伴们要是不熟悉可以参考该篇文章。</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h2><p>首先，我们打开<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a>一文中的案例，这个案例结合 Spring Data Jpa 将用户数据存储到数据库中去了。</p><p>然后我们将上篇文章中涉及到的登录页面拷贝到项目中（文末可以下载完整案例）：</p><p><img src="http://img.itboyhub.com/2020/04/20200506204420.png" alt></p><p>并在 SecurityConfig 中对登录页面稍作配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    web.ignoring().antMatchers(<span class="hljs-string">"/js/**"</span>, <span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"/images/**"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            ...</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            ...</span><br><span class="line">            .and()</span><br><span class="line">            .sessionManagement()</span><br><span class="line">            .maximumSessions(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里都是常规配置，我就不再多说。注意最后面我们将 session 数量设置为 1。</p><p>好了，配置完成后，我们启动项目，并行性多端登录测试。</p><p>打开多个浏览器，分别进行多端登录测试，我们惊讶的发现，每个浏览器都能登录成功，每次登录成功也不会踢掉已经登录的用户！</p><p>这是怎么回事？</p><h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h2><p>要搞清楚这个问题，我们就要先搞明白 Spring Security 是怎么保存用户对象和 session 的。</p><p>Spring Security 中通过 SessionRegistryImpl 类来实现对会话信息的统一管理，我们来看下这个类的源码（部分）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionRegistryImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SessionRegistry</span>,</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">SessionDestroyedEvent</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-comment">/** &lt;principal:Object,SessionIdSet&gt; */</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Object, Set&lt;String&gt;&gt; principals;</span><br><span class="line"><span class="hljs-comment">/** &lt;sessionId:Object,SessionInformation&gt; */</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, SessionInformation&gt; sessionIds;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerNewSession</span><span class="hljs-params">(String sessionId, Object principal)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (getSessionInformation(sessionId) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">removeSessionInformation(sessionId);</span><br><span class="line">&#125;</span><br><span class="line">sessionIds.put(sessionId,</span><br><span class="line"><span class="hljs-keyword">new</span> SessionInformation(principal, sessionId, <span class="hljs-keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">principals.compute(principal, (key, sessionsUsedByPrincipal) -&gt; &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (sessionsUsedByPrincipal == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">sessionsUsedByPrincipal = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">sessionsUsedByPrincipal.add(sessionId);</span><br><span class="line"><span class="hljs-keyword">return</span> sessionsUsedByPrincipal;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeSessionInformation</span><span class="hljs-params">(String sessionId)</span> </span>&#123;</span><br><span class="line">SessionInformation info = getSessionInformation(sessionId);</span><br><span class="line"><span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sessionIds.remove(sessionId);</span><br><span class="line">principals.computeIfPresent(info.getPrincipal(), (key, sessionsUsedByPrincipal) -&gt; &#123;</span><br><span class="line">sessionsUsedByPrincipal.remove(sessionId);</span><br><span class="line"><span class="hljs-keyword">if</span> (sessionsUsedByPrincipal.isEmpty()) &#123;</span><br><span class="line">sessionsUsedByPrincipal = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> sessionsUsedByPrincipal;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的源码还是比较长，我这里提取出来一些比较关键的部分：</p><ol><li>首先大家看到，一上来声明了一个 principals 对象，这是一个支持并发访问的 map 集合，集合的 key 就是用户的主体（principal），正常来说，用户的 principal 其实就是用户对象，松哥在之前的文章中也和大家讲过 principal 是怎么样存入到 Authentication 中的（参见：<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a>），而集合的 value 则是一个 set 集合，这个 set 集合中保存了这个用户对应的 sessionid。</li><li>如有新的 session 需要添加，就在 registerNewSession 方法中进行添加，具体是调用 principals.compute 方法进行添加，key 就是 principal。</li><li>如果用户注销登录，sessionid 需要移除，相关操作在 removeSessionInformation 方法中完成，具体也是调用 principals.computeIfPresent 方法，这些关于集合的基本操作我就不再赘述了。</li></ol><p>看到这里，大家发现一个问题，ConcurrentMap 集合的 key 是 principal 对象，用对象做 key，一定要重写 equals 方法和 hashCode 方法，否则第一次存完数据，下次就找不到了，这是 JavaSE 方面的知识，我就不用多说了。</p><p>如果我们使用了基于内存的用户，我们来看下 Spring Security 中的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span>, <span class="hljs-title">CredentialsContainer</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> String password;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String username;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accountNonExpired;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accountNonLocked;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> credentialsNonExpired;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> enabled;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object rhs)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (rhs <span class="hljs-keyword">instanceof</span> User) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> username.equals(((User) rhs).username);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> username.hashCode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，他自己实际上是重写了 equals 和 hashCode 方法了。</p><p>所以我们使用基于内存的用户时没有问题，而我们使用自定义的用户就有问题了。</p><p>找到了问题所在，那么解决问题就很容易了，重写 User 类的 equals 方法和 hashCode 方法即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Entity</span>(name = <span class="hljs-string">"t_user"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Id</span></span><br><span class="line">    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="hljs-keyword">private</span> Long id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> accountNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> accountNonLocked;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> credentialsNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> enabled;</span><br><span class="line">    <span class="hljs-meta">@ManyToMany</span>(fetch = FetchType.EAGER,cascade = CascadeType.PERSIST)</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="hljs-keyword">return</span> Objects.equals(username, user.username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Objects.hash(username);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，重启项目，再去进行多端登录测试，发现就可以成功踢掉已经登录的用户了。</p><p>如果你使用了 MyBatis 而不是 Jpa，也是一样的处理方案，只需要重写登录用户的 equals 方法和 hashCode 方法即可。</p><h2 id="3-微人事应用"><a href="#3-微人事应用" class="headerlink" title="3.微人事应用"></a>3.微人事应用</h2><h3 id="3-1-存在的问题"><a href="#3-1-存在的问题" class="headerlink" title="3.1 存在的问题"></a>3.1 存在的问题</h3><p>由于微人事目前是采用了 JSON 格式登录，所以如果项目控制 session 并发数，就会有一些额外的问题要处理。</p><p>最大的问题在于我们用自定义的过滤器代替了 UsernamePasswordAuthenticationFilter，进而导致前面所讲的关于 session 的配置，统统失效。所有相关的配置我们都要在新的过滤器 LoginFilter 中进行配置 ，包括 SessionAuthenticationStrategy 也需要我们自己手动配置了。</p><p>这虽然带来了一些工作量，但是做完之后，相信大家对于 Spring Security 的理解又会更上一层楼。</p><h3 id="3-2-具体应用"><a href="#3-2-具体应用" class="headerlink" title="3.2 具体应用"></a>3.2 具体应用</h3><p>我们来看下具体怎么实现，我这里主要列出来一些关键代码，<strong>完整代码大家可以从 GitHub 上下载</strong>：<a href="https://github.com/lenve/vhr。" target="_blank" rel="noopener">https://github.com/lenve/vhr。</a></p><p>首先第一步，我们重写 Hr 类的 equals 和 hashCode 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        Hr hr = (Hr) o;</span><br><span class="line">        <span class="hljs-keyword">return</span> Objects.equals(username, hr.username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> Objects.hash(username);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在 SecurityConfig 中进行配置。</p><p>这里我们要自己提供 SessionAuthenticationStrategy，而前面处理 session 并发的是 ConcurrentSessionControlAuthenticationStrategy，也就是说，我们需要自己提供一个 ConcurrentSessionControlAuthenticationStrategy 的实例，然后配置给 LoginFilter，但是在创建 ConcurrentSessionControlAuthenticationStrategy 实例的过程中，还需要有一个 SessionRegistryImpl 对象。</p><p>前面我们说过，SessionRegistryImpl 对象是用来维护会话信息的，现在这个东西也要我们自己来提供，SessionRegistryImpl 实例很好创建，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">SessionRegistryImpl <span class="hljs-title">sessionRegistry</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SessionRegistryImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 LoginFilter 中配置 SessionAuthenticationStrategy，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">LoginFilter <span class="hljs-title">loginFilter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LoginFilter loginFilter = <span class="hljs-keyword">new</span> LoginFilter();</span><br><span class="line">    loginFilter.setAuthenticationSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">                <span class="hljs-comment">//省略</span></span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    loginFilter.setAuthenticationFailureHandler((request, response, exception) -&gt; &#123;</span><br><span class="line">                <span class="hljs-comment">//省略</span></span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    loginFilter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">    loginFilter.setFilterProcessesUrl(<span class="hljs-string">"/doLogin"</span>);</span><br><span class="line">    ConcurrentSessionControlAuthenticationStrategy sessionStrategy = <span class="hljs-keyword">new</span> ConcurrentSessionControlAuthenticationStrategy(sessionRegistry());</span><br><span class="line">    sessionStrategy.setMaximumSessions(<span class="hljs-number">1</span>);</span><br><span class="line">    loginFilter.setSessionAuthenticationStrategy(sessionStrategy);</span><br><span class="line">    <span class="hljs-keyword">return</span> loginFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里自己手动构建 ConcurrentSessionControlAuthenticationStrategy 实例，构建时传递 SessionRegistryImpl 参数，然后设置 session 的并发数为 1，最后再将 sessionStrategy 配置给 LoginFilter。</p><blockquote><p>其实<a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">上篇文章</a>中，我们的配置方案，最终也是像上面这样，只不过现在我们自己把这个写出来了而已。</p></blockquote><p>这就配置完了吗？没有！session 处理还有一个关键的过滤器叫做 ConcurrentSessionFilter，本来这个过滤器是不需要我们管的，但是这个过滤器中也用到了 SessionRegistryImpl，而 SessionRegistryImpl 现在是由我们自己来定义的，所以，该过滤器我们也要重新配置一下，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            ...</span><br><span class="line">    http.addFilterAt(<span class="hljs-keyword">new</span> ConcurrentSessionFilter(sessionRegistry(), event -&gt; &#123;</span><br><span class="line">        HttpServletResponse resp = event.getResponse();</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        resp.setStatus(<span class="hljs-number">401</span>);</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.error(<span class="hljs-string">"您已在另一台设备登录，本次登录已下线!"</span>)));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;), ConcurrentSessionFilter.class);</span><br><span class="line">    http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们重新创建一个 ConcurrentSessionFilter 的实例，代替系统默认的即可。在创建新的 ConcurrentSessionFilter 实例时，需要两个参数：</p><ol><li>sessionRegistry 就是我们前面提供的 SessionRegistryImpl 实例。</li><li>第二个参数，是一个处理 session 过期后的回调函数，也就是说，当用户被另外一个登录踢下线之后，你要给什么样的下线提示，就在这里来完成。</li></ol><p>最后，我们还需要在处理完登录数据之后，手动向 SessionRegistryImpl 中添加一条记录：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    SessionRegistry sessionRegistry;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//省略</span></span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">                    username, password);</span><br><span class="line">            setDetails(request, authRequest);</span><br><span class="line">            Hr principal = <span class="hljs-keyword">new</span> Hr();</span><br><span class="line">            principal.setUsername(username);</span><br><span class="line">            sessionRegistry.registerNewSession(request.getSession(<span class="hljs-keyword">true</span>).getId(), principal);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们手动调用 sessionRegistry.registerNewSession 方法，向 SessionRegistryImpl 中添加一条 session 记录。</p><p>OK，如此之后，我们的项目就配置完成了。</p><p>接下来，重启 vhr 项目，进行多端登录测试，如果自己被人踢下线了，就会看到如下提示：</p><p><img src="http://img.itboyhub.com/2020/04/20200507231051.png" alt></p><p>完整的代码，我已经更新到 vhr 上了，大家可以下载学习。</p><p>如果小伙伴们对松哥录制的 vhr 项目视频感兴趣，不妨看看这里：<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">微人事项目视频教程</a></p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好了，本文主要和小伙伴们介绍了一个在 Spring Security 中处理 session 并发问题时，可能遇到的一个坑，以及在前后端分离情况下，如何处理 session 并发问题。不知道小伙伴们有没有 GET 到呢？</p><p>本文第二小节的案例大家可以从 GitHub 上下载：<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;中，我们讲了在 Spring Security 中如何踢掉前一个登录用户，或者禁止用户二次登录，通过一个简单的案例，实现了我们想要的效果。&lt;/p&gt;
&lt;p&gt;但是有一个不太完美的地方，就是我们的用户是配置在内存中的用户，我们没有将用户放到数据库中去。正常情况下，松哥在 Spring Security 系列中讲的其他配置，大家只需要参考&lt;a href=&quot;https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！&lt;/a&gt;一文，将数据切换为数据库中的数据即可。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 自动踢掉前一个登录用户，一个配置搞定！</title>
    <link href="http://www.javaboy.org/2020/0507/session-management.html"/>
    <id>http://www.javaboy.org/2020/0507/session-management.html</id>
    <published>2020-05-07T12:35:38.000Z</published>
    <updated>2020-05-10T12:58:51.166Z</updated>
    
    <content type="html"><![CDATA[<p>登录成功后，自动踢掉前一个登录用户，松哥第一次见到这个功能，就是在扣扣里边见到的，当时觉得挺好玩的。</p><p>自己做开发后，也遇到过一模一样的需求，正好最近的 Spring Security 系列正在连载，就结合 Spring Security 来和大家聊一聊这个功能如何实现。</p><a id="more"></a><p>本文是本系列的第十三篇，阅读前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li></ol><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><p>在同一个系统中，我们可能只允许一个用户在一个终端上登录，一般来说这可能是出于安全方面的考虑，但是也有一些情况是出于业务上的考虑，松哥之前遇到的需求就是业务原因要求一个用户只能在一个设备上登录。</p><p>要实现一个用户不可以同时在两台设备上登录，我们有两种思路：</p><ul><li>后来的登录自动踢掉前面的登录，就像大家在扣扣中看到的效果。</li><li>如果用户已经登录，则不允许后来者登录。</li></ul><p>这种思路都能实现这个功能，具体使用哪一个，还要看我们具体的需求。</p><p>在 Spring Security 中，这两种都很好实现，一个配置就可以搞定。</p><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="2-1-踢掉已经登录用户"><a href="#2-1-踢掉已经登录用户" class="headerlink" title="2.1 踢掉已经登录用户"></a>2.1 踢掉已经登录用户</h3><p>想要用新的登录踢掉旧的登录，我们只需要将最大会话数设置为 1 即可，配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .sessionManagement()</span><br><span class="line">            .maximumSessions(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>maximumSessions 表示配置最大会话数为 1，这样后面的登录就会自动踢掉前面的登录。这里其他的配置都是我们前面文章讲过的，我就不再重复介绍，文末可以下载案例完整代码。</p><p>配置完成后，分别用 Chrome 和 Firefox 两个浏览器进行测试（或者使用 Chrome 中的多用户功能）。</p><ol><li>Chrome 上登录成功后，访问 /hello 接口。</li><li>Firefox 上登录成功后，访问 /hello 接口。</li><li>在 Chrome 上再次访问 /hello 接口，此时会看到如下提示：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This session has been expired (possibly due to multiple concurrent logins being attempted as the same user).</span><br></pre></td></tr></table></figure><p>可以看到，这里说这个 session 已经过期，原因则是由于使用同一个用户进行并发登录。</p><h3 id="2-2-禁止新的登录"><a href="#2-2-禁止新的登录" class="headerlink" title="2.2 禁止新的登录"></a>2.2 禁止新的登录</h3><p>如果相同的用户已经登录了，你不想踢掉他，而是想禁止新的登录操作，那也好办，配置方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable()</span><br><span class="line">            .sessionManagement()</span><br><span class="line">            .maximumSessions(<span class="hljs-number">1</span>)</span><br><span class="line">            .maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 maxSessionsPreventsLogin 配置即可。此时一个浏览器登录成功后，另外一个浏览器就登录不了了。</p><p>是不是很简单？</p><p>不过还没完，我们还需要再提供一个 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">HttpSessionEventPublisher <span class="hljs-title">httpSessionEventPublisher</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpSessionEventPublisher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要加这个 Bean 呢？因为在 Spring Security 中，它是通过监听 session 的销毁事件，来及时的清理 session 的记录。用户从不同的浏览器登录后，都会有对应的 session，当用户注销登录之后，session 就会失效，但是默认的失效是通过调用 StandardSession#invalidate 方法来实现的，这一个失效事件无法被 Spring 容器感知到，进而导致当用户注销登录之后，Spring Security 没有及时清理会话信息表，以为用户还在线，进而导致用户无法重新登录进来（小伙伴们可以自行尝试不添加上面的 Bean，然后让用户注销登录之后再重新登录）。</p><p>为了解决这一问题，我们提供一个 HttpSessionEventPublisher ，这个类实现了 HttpSessionListener 接口，在该 Bean 中，可以将 session 创建以及销毁的事件及时感知到，并且调用 Spring 中的事件机制将相关的创建和销毁事件发布出去，进而被 Spring Security 感知到，该类部分源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionCreated</span><span class="hljs-params">(HttpSessionEvent event)</span> </span>&#123;</span><br><span class="line">HttpSessionCreatedEvent e = <span class="hljs-keyword">new</span> HttpSessionCreatedEvent(event.getSession());</span><br><span class="line">getContext(event.getSession().getServletContext()).publishEvent(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent event)</span> </span>&#123;</span><br><span class="line">HttpSessionDestroyedEvent e = <span class="hljs-keyword">new</span> HttpSessionDestroyedEvent(event.getSession());</span><br><span class="line">getContext(event.getSession().getServletContext()).publishEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，虽然多了一个配置，但是依然很简单！</p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3.实现原理"></a>3.实现原理</h2><p>上面这个功能，在 Spring Security 中是怎么实现的呢？我们来稍微分析一下源码。</p><p>首先我们知道，在用户登录的过程中，会经过 UsernamePasswordAuthenticationFilter（参考：<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a>），而 UsernamePasswordAuthenticationFilter 中过滤方法的调用是在 AbstractAuthenticationProcessingFilter 中触发的，我们来看下 AbstractAuthenticationProcessingFilter#doFilter 方法的调用：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line"><span class="hljs-keyword">if</span> (!requiresAuthentication(request, response)) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Authentication authResult;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">authResult = attemptAuthentication(request, response);</span><br><span class="line"><span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sessionStrategy.onAuthentication(authResult, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;</span><br><span class="line">unsuccessfulAuthentication(request, response, failed);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Authentication success</span></span><br><span class="line"><span class="hljs-keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">successfulAuthentication(request, response, chain, authResult);</span><br></pre></td></tr></table></figure><p>在这段代码中，我们可以看到，调用 attemptAuthentication 方法走完认证流程之后，回来之后，接下来就是调用 sessionStrategy.onAuthentication 方法，这个方法就是用来处理 session 的并发问题的。具体在：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentSessionControlAuthenticationStrategy</span> <span class="hljs-keyword">implements</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">MessageSourceAware</span>, <span class="hljs-title">SessionAuthenticationStrategy</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthentication</span><span class="hljs-params">(Authentication authentication,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">final</span> List&lt;SessionInformation&gt; sessions = sessionRegistry.getAllSessions(</span><br><span class="line">authentication.getPrincipal(), <span class="hljs-keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> sessionCount = sessions.size();</span><br><span class="line"><span class="hljs-keyword">int</span> allowedSessions = getMaximumSessionsForThisUser(authentication);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (sessionCount &lt; allowedSessions) &#123;</span><br><span class="line"><span class="hljs-comment">// They haven't got too many login sessions running at present</span></span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (allowedSessions == -<span class="hljs-number">1</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// We permit unlimited logins</span></span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (sessionCount == allowedSessions) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-comment">// Only permit it though if this request is associated with one of the</span></span><br><span class="line"><span class="hljs-comment">// already registered sessions</span></span><br><span class="line"><span class="hljs-keyword">for</span> (SessionInformation si : sessions) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (si.getSessionId().equals(session.getId())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// If the session is null, a new one will be created by the parent class,</span></span><br><span class="line"><span class="hljs-comment">// exceeding the allowed number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allowableSessionsExceeded(sessions, allowedSessions, sessionRegistry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allowableSessionsExceeded</span><span class="hljs-params">(List&lt;SessionInformation&gt; sessions,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span> allowableSessions, SessionRegistry registry)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> SessionAuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (exceptionIfMaximumExceeded || (sessions == <span class="hljs-keyword">null</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SessionAuthenticationException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed"</span>,</span><br><span class="line"><span class="hljs-keyword">new</span> Object[] &#123;allowableSessions&#125;,</span><br><span class="line"><span class="hljs-string">"Maximum sessions of &#123;0&#125; for this principal exceeded"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Determine least recently used sessions, and mark them for invalidation</span></span><br><span class="line">sessions.sort(Comparator.comparing(SessionInformation::getLastRequest));</span><br><span class="line"><span class="hljs-keyword">int</span> maximumSessionsExceededBy = sessions.size() - allowableSessions + <span class="hljs-number">1</span>;</span><br><span class="line">List&lt;SessionInformation&gt; sessionsToBeExpired = sessions.subList(<span class="hljs-number">0</span>, maximumSessionsExceededBy);</span><br><span class="line"><span class="hljs-keyword">for</span> (SessionInformation session: sessionsToBeExpired) &#123;</span><br><span class="line">session.expireNow();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段核心代码我来给大家稍微解释下：</p><ol><li>首先调用 sessionRegistry.getAllSessions 方法获取当前用户的所有 session，该方法在调用时，传递两个参数，一个是当前用户的 authentication，另一个参数 false 表示不包含已经过期的 session（在用户登录成功后，会将用户的 sessionid 存起来，其中 key 是用户的主体（principal），value 则是该主题对应的 sessionid 组成的一个集合）。</li><li>接下来计算出当前用户已经有几个有效 session 了，同时获取允许的 session 并发数。</li><li>如果当前 session 数（sessionCount）小于 session 并发数（allowedSessions），则不做任何处理；如果 allowedSessions 的值为 -1，表示对 session 数量不做任何限制。</li><li>如果当前 session 数（sessionCount）等于 session 并发数（allowedSessions），那就先看看当前 session 是否不为 null，并且已经存在于 sessions 中了，如果已经存在了，那都是自家人，不做任何处理；如果当前 session 为 null，那么意味着将有一个新的 session 被创建出来，届时当前 session 数（sessionCount）就会超过 session 并发数（allowedSessions）。</li><li>如果前面的代码中都没能 return 掉，那么将进入策略判断方法 allowableSessionsExceeded 中。</li><li>allowableSessionsExceeded 方法中，首先会有 exceptionIfMaximumExceeded 属性，这就是我们在 SecurityConfig 中配置的 maxSessionsPreventsLogin 的值，默认为 false，如果为 true，就直接抛出异常，那么这次登录就失败了（对应 2.2 小节的效果），如果为 false，则对 sessions 按照请求时间进行排序，然后再使多余的 session 过期即可（对应 2.1 小节的效果）。</li></ol><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>如此，两行简单的配置就实现了 Spring Security 中 session 的并发管理。是不是很简单？不过这里还有一个小小的坑，松哥将在下篇文章中继续和大家分析。</p><p>本文案例大家可以从 GitHub 上下载：<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>好了，不知道小伙伴们有没有 GET 到呢？如果 GET 到了记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;登录成功后，自动踢掉前一个登录用户，松哥第一次见到这个功能，就是在扣扣里边见到的，当时觉得挺好玩的。&lt;/p&gt;
&lt;p&gt;自己做开发后，也遇到过一模一样的需求，正好最近的 Spring Security 系列正在连载，就结合 Spring Security 来和大家聊一聊这个功能如何实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中如何快速查看登录用户 IP 地址等信息？</title>
    <link href="http://www.javaboy.org/2020/0506/details.html"/>
    <id>http://www.javaboy.org/2020/0506/details.html</id>
    <published>2020-05-06T12:35:21.000Z</published>
    <updated>2020-05-10T12:58:45.350Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">上篇文章</a>跟大家聊了如何使用更加优雅的方式自定义 Spring Security 登录逻辑，更加优雅的方式可以有效避免掉自定义过滤器带来的低效，建议大家一定阅读一下，也可以顺便理解 Spring Security 中的认证逻辑。</p><p>本文将在上文的基础上，继续和大家探讨如何存储登录用户详细信息的问题。</p><a id="more"></a><p>本文是本系列第 12 篇，阅读本系列前面文章可以更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li></ol><p>好了，不废话了，我们来看今天的文章。</p><h2 id="1-Authentication"><a href="#1-Authentication" class="headerlink" title="1.Authentication"></a>1.Authentication</h2><p>Authentication 这个接口前面和大家聊过多次，今天还要再来聊一聊。</p><p>Authentication 接口用来保存我们的登录用户信息，实际上，它是对主体（java.security.Principal）做了进一步的封装。</p><p>我们来看下 Authentication 的一个定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Authentication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Principal</span>, <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getDetails</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAuthenticated</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的解释如下：</p><ol><li>getAuthorities 方法用来获取用户的权限。</li><li>getCredentials 方法用来获取用户凭证，一般来说就是密码。</li><li>getDetails 方法用来获取用户携带的详细信息，可能是当前请求之类的东西。</li><li>getPrincipal 方法用来获取当前用户，可能是一个用户名，也可能是一个用户对象。</li><li>isAuthenticated 当前用户是否认证成功。</li></ol><p>这里有一个比较好玩的方法，叫做 getDetails。关于这个方法，源码的解释如下：</p><p>Stores additional details about the authentication request. These might be an IP address, certificate serial number etc.</p><p>从这段解释中，我们可以看出，该方法实际上就是用来存储有关身份认证的其他信息的，例如 IP 地址、证书信息等等。</p><p>实际上，在默认情况下，这里存储的就是用户登录的 IP 地址和 sessionId。我们从源码角度来看下。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><p>松哥的 SpringSecurity 系列已经写到第 12 篇了，看了前面的文章，相信大家已经明白用户登录必经的一个过滤器就是 UsernamePasswordAuthenticationFilter，在该类的 attemptAuthentication 方法中，对请求参数做提取，在 attemptAuthentication 方法中，会调用到一个方法，就是 setDetails。</p><p>我们一起来看下 setDetails 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;</span><br><span class="line">authRequest.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UsernamePasswordAuthenticationToken 是 Authentication 的具体实现，所以这里实际上就是在设置 details，至于 details 的值，则是通过 authenticationDetailsSource 来构建的，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>, <span class="hljs-title">WebAuthenticationDetails</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> WebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest context)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebAuthenticationDetails(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAuthenticationDetails</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String remoteAddress;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String sessionId;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.remoteAddress = request.getRemoteAddr();</span><br><span class="line"></span><br><span class="line">HttpSession session = request.getSession(<span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.sessionId = (session != <span class="hljs-keyword">null</span>) ? session.getId() : <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认通过 WebAuthenticationDetailsSource 来构建 WebAuthenticationDetails，并将结果设置到 Authentication 的 details 属性中去。而 WebAuthenticationDetails 中定义的属性，大家看一下基本上就明白，这就是保存了用户登录地址和 sessionId。</p><p>那么看到这里，大家基本上就明白了，用户登录的 IP 地址实际上我们可以直接从 WebAuthenticationDetails 中获取到。</p><p>我举一个简单例子，例如我们登录成功后，可以通过如下方式随时随地拿到用户 IP：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        WebAuthenticationDetails details = (WebAuthenticationDetails) authentication.getDetails();</span><br><span class="line">        System.out.println(details);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个获取过程之所以放在 service 来做，就是为了演示<strong>随时随地</strong>这个特性。然后我们在 controller 中调用该方法，当访问接口时，可以看到如下日志：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebAuthenticationDetails@fffc7f0c: RemoteIpAddress: 127.0.0.1; SessionId: 303C7F254DF8B86667A2B20AA0667160</span><br></pre></td></tr></table></figure><p>可以看到，用户的 IP 地址和 SessionId 都给出来了。这两个属性在 WebAuthenticationDetails 中都有对应的 get 方法，也可以单独获取属性值。</p><h2 id="3-定制"><a href="#3-定制" class="headerlink" title="3.定制"></a>3.定制</h2><p>当然，WebAuthenticationDetails 也可以自己定制，因为默认它只提供了 IP 和 sessionid 两个信息，如果我们想保存关于 Http 请求的更多信息，就可以通过自定义 WebAuthenticationDetails 来实现。</p><p>如果我们要定制 WebAuthenticationDetails，还要连同 WebAuthenticationDetailsSource 一起重新定义。</p><p>结合<a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">上篇文章</a>的验证码登录，我跟大家演示一个自定义 WebAuthenticationDetails 的例子。</p><p><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">上篇文章</a>我们是在 MyAuthenticationProvider 类中进行验证码判断的，回顾一下<a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">上篇文章</a>的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAuthenticationProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DaoAuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additionalAuthenticationChecks</span><span class="hljs-params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        HttpServletRequest req = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        String code = req.getParameter(<span class="hljs-string">"code"</span>);</span><br><span class="line">        String verify_code = (String) req.getSession().getAttribute(<span class="hljs-string">"verify_code"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (code == <span class="hljs-keyword">null</span> || verify_code == <span class="hljs-keyword">null</span> || !code.equals(verify_code)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"验证码错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">super</span>.additionalAuthenticationChecks(userDetails, authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个验证操作，我们也可以放在自定义的 WebAuthenticationDetails 中来做，我们定义如下两个类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAuthenticationDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebAuthenticationDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPassed;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyWebAuthenticationDetails</span><span class="hljs-params">(HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(req);</span><br><span class="line">        String code = req.getParameter(<span class="hljs-string">"code"</span>);</span><br><span class="line">        String verify_code = (String) req.getSession().getAttribute(<span class="hljs-string">"verify_code"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (code != <span class="hljs-keyword">null</span> &amp;&amp; verify_code != <span class="hljs-keyword">null</span> &amp;&amp; code.equals(verify_code)) &#123;</span><br><span class="line">            isPassed = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPassed</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> isPassed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebAuthenticationDetailsSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationDetailsSource</span>&lt;<span class="hljs-title">HttpServletRequest</span>,<span class="hljs-title">MyWebAuthenticationDetails</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> MyWebAuthenticationDetails <span class="hljs-title">buildDetails</span><span class="hljs-params">(HttpServletRequest context)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyWebAuthenticationDetails(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们定义 MyWebAuthenticationDetails，由于它的构造方法中，刚好就提供了 HttpServletRequest 对象，所以我们可以直接利用该对象进行验证码判断，并将判断结果交给 isPassed 变量保存。<strong>如果我们想扩展属性，只需要在 MyWebAuthenticationDetails 中再去定义更多属性，然后从 HttpServletRequest 中提取出来设置给对应的属性即可，这样，在登录成功后就可以随时随地获取这些属性了。</strong></p><p>最后在 MyWebAuthenticationDetailsSource 中构造 MyWebAuthenticationDetails 并返回。</p><p>定义完成后，接下来，我们就可以直接在 MyAuthenticationProvider 中进行调用了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAuthenticationProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DaoAuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additionalAuthenticationChecks</span><span class="hljs-params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!((MyWebAuthenticationDetails) authentication.getDetails()).isPassed()) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"验证码错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">super</span>.additionalAuthenticationChecks(userDetails, authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接从 authentication 中获取到 details 并调用 isPassed 方法，有问题就抛出异常即可。</p><p>最后的问题就是如何用自定义的 MyWebAuthenticationDetailsSource 代替系统默认的 WebAuthenticationDetailsSource，很简单，我们只需要在 SecurityConfig 中稍作定义即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">MyWebAuthenticationDetailsSource myWebAuthenticationDetailsSource;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            ...</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .authenticationDetailsSource(myWebAuthenticationDetailsSource)</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 MyWebAuthenticationDetailsSource 注入到 SecurityConfig 中，并在 formLogin 中配置 authenticationDetailsSource 即可成功使用我们自定义的 WebAuthenticationDetails。</p><p>这样自定义完成后，WebAuthenticationDetails 中原有的功能依然保留，也就是我们还可以利用老办法继续获取用户 IP 以及 sessionId 等信息，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        MyWebAuthenticationDetails details = (MyWebAuthenticationDetails) authentication.getDetails();</span><br><span class="line">        System.out.println(details);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里类型强转的时候，转为 MyWebAuthenticationDetails 即可。</p><p>本文案例大家可以从 GitHub 上下载：<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></p><p>好了，不知道小伙伴们有没有 GET 到呢？如果 GET 到了记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;跟大家聊了如何使用更加优雅的方式自定义 Spring Security 登录逻辑，更加优雅的方式可以有效避免掉自定义过滤器带来的低效，建议大家一定阅读一下，也可以顺便理解 Spring Security 中的认证逻辑。&lt;/p&gt;
&lt;p&gt;本文将在上文的基础上，继续和大家探讨如何存储登录用户详细信息的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Eureka 都挂了，微服务还能调通吗？</title>
    <link href="http://www.javaboy.org/2020/0505/eureka-interview.html"/>
    <id>http://www.javaboy.org/2020/0505/eureka-interview.html</id>
    <published>2020-05-05T12:35:07.000Z</published>
    <updated>2020-05-10T12:58:40.254Z</updated>
    
    <content type="html"><![CDATA[<p>这是一位公众号读者遇到的面试题。</p><p>老实说，这个问题并不难。</p><p>如果你做过微服务开发，这个面试题应该能够立马答出来，如果你没做过微服务开发，但是学过一些 Spring Cloud 组件的用法，这个问题可能要稍微想一下，但是也应该能够答出来。</p><a id="more"></a><p>今天就来和大家说说这个问题。</p><h2 id="1-实践一下"><a href="#1-实践一下" class="headerlink" title="1.实践一下"></a>1.实践一下</h2><p>这种问题，听别人讲 N 遍，不如自己手动实践一遍记得清楚。</p><p>大家可以快速搭建一个 Eureka 服务注册中心，然后搭建一个服务消费者和服务提供者，将两个服务注册到 Eureka 上去，最后在服务消费者上面简单的调用一下服务提供者。这个过程很简单，相信大家稍微学过 Spring Cloud 的小伙伴都能搞定，如果搞不定，可以参考松哥的视频（<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">Spring Boot + Vue + Spring Cloud 系列视频教程</a>））。</p><p>服务调通之后，接下来关闭 Eureka，注意不要关闭服务提供者和服务消费者，关闭之后，继续用服务消费者调用服务提供者，<strong>这个时候你会惊奇的发现，服务竟然还能调通！</strong></p><p>Demo 过于简单，我就不写了，如果小伙伴们自己懒得写，也可以直接下载松哥写好的直接运行：<a href="https://github.com/lenve/springcloud-video-samples" target="_blank" rel="noopener">https://github.com/lenve/springcloud-video-samples</a></p><h2 id="2-原因分析"><a href="#2-原因分析" class="headerlink" title="2.原因分析"></a>2.原因分析</h2><p>为什么 Eureka 关闭后服务还能调用呢？我们先来看一张简单的服务调用图：</p><p><img src="http://img.itboyhub.com/2020/04/20200504160930.png" alt></p><p>我来说一下这个流程：</p><ol><li>Eureka 作为一个服务注册中心启动。</li><li>Provider 和 Consumer 分别作为服务启动，并且注册到 Eureka 上面去，以 provider 为例，provider 注册时会告诉 eureka，我叫 provider，我的地址是 xx.xx.xx.xx，我的端口是 xx，我的 xx 是 xx，就是说，provider 会将自己的一些元数据信息告诉 eureka；同理，consumer 也是如此。</li><li>接下来，consumer 要调用 provider 的接口，但是它不知道 provider 的地址是什么，他只知道要调用的服务叫 provider，于是 consumer 找到 eureka，从 eureka 上查询出来 provider 的具体地址和端口，这个具体的地址和端口，可能是一个，也可能是多个（集群化部署）。</li><li>consumer 获取到 provider 的地址和端口之后，接下来就直接去调用 provider 了。</li></ol><p>从上面一个流程图中，大家可以看出来，一旦 consumer 获取到 provider 的具体地址，接下来的调用其实就没有 eureka 什么事了。</p><p>所以，我们说一旦 Eureka 挂了，微服务是可以调通的，<strong>但是是有前提的</strong>。</p><p>什么前提？就是 provider 的地址没变！如果 provider 换了一个 IP 地址或者端口，这个时候，consumer 就无法及时感知到这种变化，就会调不通。当 Eureka 没有挂掉的时候，provider 的 IP 变化这种事情，可以通过 Eureka 让 consumer 感知到，进而对调用地址作出调整，现在 Eureka 挂了，consumer 就无法感知了。</p><p>文章既然都写到这儿了，我们就来顺便说下 Spring Cloud 在这里涉及到的一些原理。</p><h2 id="3-相关原理"><a href="#3-相关原理" class="headerlink" title="3.相关原理"></a>3.相关原理</h2><p>Eureka 本身可以分为两大部分，Eureka Server 和 Eureka Client。</p><p>我们先来看 Eureka Server：</p><h3 id="3-1-Eureka-Server"><a href="#3-1-Eureka-Server" class="headerlink" title="3.1 Eureka Server"></a>3.1 Eureka Server</h3><p>Eureka Server 主要对外提供了三个功能：</p><ol><li>服务注册，所有的服务都注册到 Eureka Server 上面来，这是 Eureka 基本功能。</li><li>提供注册表，注册表就是所有注册上来服务的一个列表，Eureka 内部通过一个二层缓存机制来维护这个注册表。Eureka Client 在调用服务时，需要获取这个注册表，一般来说，这个注册表会缓存下来，如果缓存失效，则直接获取最新的注册表。</li><li>同步状态，Eureka Client 通过注册、心跳等机制，和 Eureka Server 同步当前客户端的状态，以便 Eureka Client 能够及时感知到变化。</li></ol><h3 id="3-2-Eureka-Client"><a href="#3-2-Eureka-Client" class="headerlink" title="3.2 Eureka Client"></a>3.2 Eureka Client</h3><p>服务要注册到 Eureka 上面去，这种注册本身就是一个 HTTP 请求，但是自己手写注册过程的话太过于繁琐，Eureka Client 可以帮助我们简化注册过程。</p><p>一般来说，Eureka Client 有这样一些功能：</p><h5 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h5><p>服务提供者将自己注册到服务注册中心（Eureka Server），需要注意，所谓的服务提供者，只是一个业务上的划分，本质上他就是一个 Eureka Client。当 Eureka Client 向 Eureka Server 注册时，他需要提供自身的一些元数据信息，例如 IP 地址、端口、名称、运行状态等等，将来服务消费者获取到的也是这些信息。</p><h5 id="获取注册信息"><a href="#获取注册信息" class="headerlink" title="获取注册信息"></a>获取注册信息</h5><p>Eureka Client 从 Eureka Server 上获取服务的注册信息，<strong>并将其缓存在本地</strong>，这句是关键。</p><p>当 Eureka Client 在需要调用远程服务时，会从该信息中查找远程服务所对应的 IP 地址、端口等信息。Eureka Client 上缓存的服务注册信息会定期更新(30 秒)，如果 Eureka Server 返回的注册表信息与本地缓存的注册表信息不同的话，Eureka Client 会自动处理。</p><p>这里，也涉及到两个属性：</p><ol><li>一个是是否允许获取注册表信息：<code>eureka.client.fetch-registry=true</code>。</li><li>另一个是 Eureka Client 上缓存的服务注册信息，定期更新的时间间隔，默认 30 秒，可以通过如下属性自行修改：<code>eureka.client.registry-fetch-interval-seconds=30</code>。</li></ol><h5 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h5><p>Eureka Client 注册到 Eureka Server 上之后，默认情况下，Eureka CLient 每隔 30 秒就要向 Eureka Server 发送一条心跳消息，来告诉 Eureka Server 我还在运行。</p><p>如果 Eureka Server 连续 90 秒都有没有收到 Eureka Client 的续约消息（连续三次没发送），它会认为 Eureka Client 已经掉线了，会将掉线的 Eureka Client 从当前的服务注册列表中剔除。</p><p>这里有两个相关的属性（一般不建议修改）：</p><ol><li><code>eureka.instance.lease-renewal-interval-in-seconds</code> 表示服务的续约时间，默认是 30 秒。</li><li><code>eureka.instance.lease-expiration-duration-in-seconds</code> 表示服务失效时间，默认是 90 秒。</li></ol><h5 id="服务下线"><a href="#服务下线" class="headerlink" title="服务下线"></a>服务下线</h5><p>服务下线当 Eureka Client 下线时，它会主动发送一条消息，告诉 Eureka Server ，我下线啦。</p><p>从上面的介绍可以看出，Eureka Client 会自动拉取、更新以及缓存 Eureka Server 中的信息，这样，即使 Eureka Server 所有节点都宕机，Eureka Client 依然能够获取到想要调用服务的地址（前提是服务地址没有发生变化）。</p><p>好了，本文就先说这么多，其实东西不难，感兴趣的小伙伴感觉去试试吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一位公众号读者遇到的面试题。&lt;/p&gt;
&lt;p&gt;老实说，这个问题并不难。&lt;/p&gt;
&lt;p&gt;如果你做过微服务开发，这个面试题应该能够立马答出来，如果你没做过微服务开发，但是学过一些 Spring Cloud 组件的用法，这个问题可能要稍微想一下，但是也应该能够答出来。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/tags/Spring-Cloud/"/>
    
      <category term="Eureka" scheme="http://www.javaboy.org/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>一台笔记本用多久就可以拿去换脸盆了？</title>
    <link href="http://www.javaboy.org/2020/0504/computer.html"/>
    <id>http://www.javaboy.org/2020/0504/computer.html</id>
    <published>2020-05-04T12:34:52.000Z</published>
    <updated>2020-05-10T12:58:36.113Z</updated>
    
    <content type="html"><![CDATA[<p>一台笔记本用多久就可以拿去换脸盆了？</p><p>我觉得这和你的使用习惯以及钱包厚度有很大关系。</p><p>松哥现在有两台电脑，一台 MacBook Pro 是 2018 年新书交稿之后买的，作为给自己的奖励；另一台索尼是大一的时候买的，现在是第九个年头了，这台索尼现在主要用来录视频（大家看到的视频就是松哥用这台设备录的），平时制作一些 PDF 文档啥的。</p><a id="more"></a><p>要说索尼的质量真不赖，九年了，没送去售后修过，只有在它服役满八年的时候，我自己手动维修过一次。</p><h3 id="1-小白时代"><a href="#1-小白时代" class="headerlink" title="1.小白时代"></a>1.小白时代</h3><p>这台索尼电脑买的时候 5200 块钱。当时我才上大一，家里给了 4000 块钱，我又加上自己家教赚的钱，买了这台电脑。电脑原装是 2G 内存，买的时候店家送了 2G 内存，就是 4G，刚开始也够用了。</p><p>这是我的第一台电脑，刚买的时候我自己对电脑一点都不懂，打字都不利索。卖电脑的小哥给我装了一堆 360 全家桶、扣扣全家桶啥的，我把电脑拿回学校宿舍之后，就是平时写写文档啥的，其他时候都不怎么开机，我也不玩游戏。</p><p>那时候我还是个小白用户，装一个软件，经常是装完之后，桌面一堆图标，各种大师、各种套壳浏览器都冒出来，我自己也是一脸懵逼，有时候把电脑整的非常卡，只好把各种杀毒软件打开扫描一面，结果越弄越卡。直到我自己后来开始做开发之后，才懂得如何去防范这些流氓软件。</p><h3 id="2-轻装简行"><a href="#2-轻装简行" class="headerlink" title="2.轻装简行"></a>2.轻装简行</h3><p>大二开始自学 Java 后，对计算机的原理也慢慢了解了，慢慢也懂得如何让自己的电脑更高效的工作，于是卸载了很多杂七杂八的软件，一切以简洁为主。</p><p>我记得当时戒了 360、鲁大师 这些软件，换上了一款非常简洁轻便的杀毒软件 Avast，再后来用上 Win10 之后，Avast 也不用安装了，系统自带的就够用了；也戒了各种国产浏览器，平时 Chrome+Firefox 就够用了…，一句话，能简则简。</p><p>轻装简行策略让我的电脑一直非常流畅，各种开发工具跑起来都非常爽，不卡。</p><h3 id="3-两次硬件升级"><a href="#3-两次硬件升级" class="headerlink" title="3.两次硬件升级"></a>3.两次硬件升级</h3><p>这台电脑在我手上有过两次硬件升级。</p><p>第一次是大三的时候，那个时候刚开始学习 Linux，装虚拟机，电脑 4G 内存明显很卡，没办法，我就买了新的内存条自己换上去了，加了内存之后，效果提示还是很明显，然后电脑一直以 8G 的内存运行到今天。</p><p>第二次是在 2016 年的时候，我当时特别想买一台新电脑（因为毕业一年工资翻了三倍，当时有点飘），但是最终还是控制住自己的欲望了。怎么控制住的呢？我当时给买了一个固态硬盘给电脑换上，然后把电脑自己的硬盘装到光驱上了，这样电脑开机可以秒开了，如此就把心里买新电脑的火苗给掐灭了。就这样，这台索尼笔记本又服役了两年多，到了 2018 年底，心里换电脑的这把火又燃烧起来，这次我没控制住，于是在 2018 年底入手了 mbp。</p><h3 id="4-唯一的问题"><a href="#4-唯一的问题" class="headerlink" title="4.唯一的问题"></a>4.唯一的问题</h3><p>这台索尼本的散热我一直非常满意，各种开发软件齐开都不烫，也很少听到呼呼的风扇声，这点比 Mac 强多了。所以我也在很长时间里都不使用散热板。</p><p>但是从 2018 年开始，电脑经常变得很烫，我推测可能是散热出问题了，但是懒得拆机，于是就买了个散热板，到了 2019 年底的时候，散热板也解决不了问题了，我就在淘宝上自己买了个风扇，然后把电脑拆开，把风扇换上去，现在又不需要散热板就能很好的运行了。</p><p>这也是这台电脑唯一的一次修理。</p><h3 id="5-年老体弱"><a href="#5-年老体弱" class="headerlink" title="5.年老体弱"></a>5.年老体弱</h3><p>可能因为这台电脑服役时间比较长了，最近几次写代码的时候，有时候打开 IDEA 会明显感觉比较卡，一开始没太细想，后来发现 Chrome 选项卡打开多的时候，再点回之前的选项卡，又会重新加载，遂意识到可能是内存不足。检查了一下，果然是的，两个 4G 的内存条，一个不工作了，现在只剩一个还在工作。但是我现在不想买新内存条了，毕竟这台电脑年事已高，未来可能还会有新的问题，现在 4G 也还勉强够用，毕竟目前 mbp 是主力机，那台索尼从 2019 年开始就慢慢退居二线了。</p><p>老实说，用了九年的笔记本还是充满感情的，换脸盆是不可能换脸盆的。索尼的质量还是杠杠滴，可惜它把笔记本业务卖了。</p><p>小伙伴们，你的笔记本最长用了多久呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一台笔记本用多久就可以拿去换脸盆了？&lt;/p&gt;
&lt;p&gt;我觉得这和你的使用习惯以及钱包厚度有很大关系。&lt;/p&gt;
&lt;p&gt;松哥现在有两台电脑，一台 MacBook Pro 是 2018 年新书交稿之后买的，作为给自己的奖励；另一台索尼是大一的时候买的，现在是第九个年头了，这台索尼现在主要用来录视频（大家看到的视频就是松哥用这台设备录的），平时制作一些 PDF 文档啥的。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>2020 原创视频+图文干货整理汇总（青年节版）</title>
    <link href="http://www.javaboy.org/2020/0504/springboot-vue.html"/>
    <id>http://www.javaboy.org/2020/0504/springboot-vue.html</id>
    <published>2020-05-04T12:34:38.000Z</published>
    <updated>2020-05-10T12:58:29.221Z</updated>
    
    <content type="html"><![CDATA[<p>以后我会定期更新这个索引，频率大概一周左右更新一次，该索引会列出 2020 年所有原创干货，方便大家查找之前的文章。小伙伴们在公众号后台回复 <strong>2020</strong> 可以及时获取最新版索引。</p><a id="more"></a><p>2019 年原创技术干货，小伙伴们可以参考：<a href="https://mp.weixin.qq.com/s/KApZpgmsx-ZsLOdcsvbm4g" target="_blank" rel="noopener">2019 ，117 篇原创技术干货整理</a>。</p><p><strong>注：加 * 的是【视频+图文】教程。</strong></p><h2 id="1-微人事相关"><a href="#1-微人事相关" class="headerlink" title="1.微人事相关"></a>1.微人事相关</h2><ol><li>*<a href="https://mp.weixin.qq.com/s/aMu1qi46FbzIe0amJ4XJ7w" target="_blank" rel="noopener">我是如何在微人事项目中提高RabbitMQ消息可靠性的？</a></li><li>*<a href="https://mp.weixin.qq.com/s/SMPyyZlRvvKM-kSMbOOQAw" target="_blank" rel="noopener">Spring Boot 整合 RabbitMQ，消息重复消费怎么办？</a></li><li>*<a href="https://mp.weixin.qq.com/s/dcJv6BIVFPnokI8nBf4IrQ" target="_blank" rel="noopener">前后端分离项目(微人事)常见部署问题汇总</a></li><li>*<a href="https://mp.weixin.qq.com/s/aaop_dS9UIOgTtQd0hl_tw" target="_blank" rel="noopener">Spring Security 如何添加登录验证码？松哥手把手教你给微人事添加登录验证码</a></li><li>*<a href="https://mp.weixin.qq.com/s/tIFyi2EiQRhdaOZi7bMoGw" target="_blank" rel="noopener">Spring Boot+Vue+FastDFS 实现前后端分离文件上传</a></li><li>*<a href="https://mp.weixin.qq.com/s/rXhXFXDhyYDP4F47Uat1DQ" target="_blank" rel="noopener">Spring Boot+Vue前后端分离，如何避免前端页面 404</a></li><li>*<a href="https://mp.weixin.qq.com/s/vIhnSwG06PRcU9-AhiI1Gg" target="_blank" rel="noopener">我是如何提高Spring Boot+Vue前后端分离项目首页加载速度的？</a></li><li>*<a href="https://mp.weixin.qq.com/s/NuTmEUQU5L69is53bCauKA" target="_blank" rel="noopener">Nginx 动态压缩与静态压缩，显著提高前后端分离项目响应速度！</a></li><li>*<a href="https://mp.weixin.qq.com/s/rzlALs0kW2PDzQ8OSPQMlA" target="_blank" rel="noopener">微人事首页加载速度提高了 5 倍，我都做了什么？</a></li><li>*<a href="https://mp.weixin.qq.com/s/RHoXwIn6J-O8tbVjsYIcBQ" target="_blank" rel="noopener">前后端分离中，使用 JSON 格式登录原来这么简单！</a></li><li>*<a href="https://mp.weixin.qq.com/s/VKtt9nC7PCHmiUI8oZ1CTw" target="_blank" rel="noopener">看懂这篇文章，前后端分离再和面试官扯皮就没问题了</a></li><li>*<a href="https://mp.weixin.qq.com/s/KWBtHi_au_1pH70OYptjfA" target="_blank" rel="noopener">手把手教你部署前后端分离项目，再也不用担心跨域问题了</a></li><li><a href="https://mp.weixin.qq.com/s/yabpyA90D1yUtWRNr330yA" target="_blank" rel="noopener">简化微人事部署，Flyway 搞起来</a></li></ol><h2 id="2-SpringBoot"><a href="#2-SpringBoot" class="headerlink" title="2.SpringBoot"></a>2.SpringBoot</h2><ol><li><a href="https://mp.weixin.qq.com/s/4RABulz1wDbLPjJSNgI0Qw" target="_blank" rel="noopener">Spring Boot 要怎么学？要学哪些东西？要不要先学 SSM？松哥说说看法</a></li><li><a href="https://mp.weixin.qq.com/s/x8-G789jiWo5MgGLoOmhbQ" target="_blank" rel="noopener">274 页 pdf 文档，Spring Boot 教程也有离线版了</a></li><li>*<a href="https://mp.weixin.qq.com/s/bDiPhqPjEyCbXhmAx1btpg" target="_blank" rel="noopener">Spring Boot 国际化踩坑指南</a></li></ol><h2 id="3-SpringSecurity-系列"><a href="#3-SpringSecurity-系列" class="headerlink" title="3.SpringSecurity 系列"></a>3.SpringSecurity 系列</h2><ol><li>*<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a></li><li>*<a href="https://mp.weixin.qq.com/s/jQZx4i4-vqjpBjpoJKJF4A" target="_blank" rel="noopener">Spring Security 如何动态更新已登录用户信息？</a></li><li>*<a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li>*<a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li>*<a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li>*<a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li>*<a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li>*<a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li>*<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li>*<a href="https://mp.weixin.qq.com/s/qUDZdTPc4-2UtmHtFI4v-g" target="_blank" rel="noopener">奇怪，Spring Security 登录成功后总是获取不到登录用户信息？</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li></ol><h2 id="4-OAuth2-系列"><a href="#4-OAuth2-系列" class="headerlink" title="4.OAuth2 系列"></a>4.OAuth2 系列</h2><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li><li><a href="https://mp.weixin.qq.com/s/aOXsHSPowmR2zLkF41wPlQ" target="_blank" rel="noopener">和大家分享一点微服务架构中的安全管理思路</a></li><li><a href="https://mp.weixin.qq.com/s/EyAMTbKPqNNnEtZACIsMVw" target="_blank" rel="noopener">Spring Boot+OAuth2，一个注解搞定单点登录！</a></li><li>*<a href="https://mp.weixin.qq.com/s/Zm-K7R1UGEaIKtwdnw6JuQ" target="_blank" rel="noopener">松哥手把手教你玩转 OAuth2 授权码模式|视频版</a></li><li><a href="https://mp.weixin.qq.com/s/tq4Q306J3hJFEtGL1EpOBA" target="_blank" rel="noopener">分分钟让自己的网站接入 GitHub 第三方登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/lnuAejqGqh_8W_-GHEq5gA" target="_blank" rel="noopener">Spring Boot+OAuth2，如何自定义返回的 Token 信息？</a></li></ol><h2 id="5-IntelliJ-IDEA-技巧系列"><a href="#5-IntelliJ-IDEA-技巧系列" class="headerlink" title="5.IntelliJ IDEA 技巧系列"></a>5.IntelliJ IDEA 技巧系列</h2><ol><li>*<a href="https://mp.weixin.qq.com/s/7lKrU8jcKRDpdxqm3EdBnw" target="_blank" rel="noopener">松哥再来传授两个IDEA技巧，让编码速度飞起来</a></li><li>*<a href="https://mp.weixin.qq.com/s/_ZL7q87PglBvnKiiWMuxaQ" target="_blank" rel="noopener">玩转 IDEA 之 Postfix Completion</a></li><li>*<a href="https://mp.weixin.qq.com/s/h-Up7RVAMkCxokG_ExZV2A" target="_blank" rel="noopener">玩转 IDEA 之 Maven 依赖自动提示</a></li><li>*<a href="https://mp.weixin.qq.com/s/tWexMGLnQ_riyvSPK8v3Rg" target="_blank" rel="noopener">玩转 IDEA 之快速定义单元测试方法</a></li><li>*<a href="https://mp.weixin.qq.com/s/L6ziJAqfXhrFjuZvRBNfJg" target="_blank" rel="noopener">玩转 IDEA 之 Inject Language</a></li><li>*<a href="https://mp.weixin.qq.com/s/S63uFEiVtE9T7oLUmx7ISg" target="_blank" rel="noopener">玩转 IDEA 之狂拽炫酷的列编辑</a></li><li><a href="https://mp.weixin.qq.com/s/ij3x3UyAamvvyb9VE4qz-A" target="_blank" rel="noopener">懒人必备，IntelliJ IDEA中代码一键生成</a></li></ol><h2 id="6-Spring-Cloud"><a href="#6-Spring-Cloud" class="headerlink" title="6.Spring Cloud"></a>6.Spring Cloud</h2><ol><li>*<a href="https://mp.weixin.qq.com/s/jjV4C6LgBMniGFDg2_0LnQ" target="_blank" rel="noopener">手把手讲解Spring中的Http请求神器RestTemplate</a></li><li>*<a href="https://mp.weixin.qq.com/s/o_M3IEC4ysOHPgUAfanswA" target="_blank" rel="noopener">松哥手把手教你入门 Spring Cloud Alibaba Nacos!</a></li></ol><h2 id="7-Redis"><a href="#7-Redis" class="headerlink" title="7.Redis"></a>7.Redis</h2><ol><li>*<a href="https://mp.weixin.qq.com/s/NKiLt2Ebofa1Wq1k5sFscA" target="_blank" rel="noopener">Redis 做分布式锁你会几种姿势？松哥来给大家介绍两种</a></li><li>*<a href="https://mp.weixin.qq.com/s/ej_9f4iBOAEPIXxxhFcm-A" target="_blank" rel="noopener">松哥手把手教你用 Redis 做延迟消息队列</a></li><li>*<a href="https://mp.weixin.qq.com/s/hAi6Na90hhH12tlrDsH-YA" target="_blank" rel="noopener">so easy！松哥手把手带你撸一个 Redis 的 Java 客户端</a></li></ol><h2 id="8-FastDFS"><a href="#8-FastDFS" class="headerlink" title="8.FastDFS"></a>8.FastDFS</h2><ol><li><a href="https://mp.weixin.qq.com/s/N20mYUnHPhdc76K5MayjFQ" target="_blank" rel="noopener">手把手教你用 FastDFS 构建分布式文件管理系统</a></li><li>*<a href="https://mp.weixin.qq.com/s/onZmdgi9kZw0JdAtrNYmow" target="_blank" rel="noopener">听说你 FastDFS 老安装失败，这能忍？松哥一定要帮你搞定！</a></li></ol><h2 id="9-学习资源"><a href="#9-学习资源" class="headerlink" title="9.学习资源"></a>9.学习资源</h2><ol><li><a href="https://mp.weixin.qq.com/s/zaiqCHNYwghatNd6tcrocg" target="_blank" rel="noopener">推荐七个略火的Spring Boot+Vue开源项目</a></li><li><a href="https://mp.weixin.qq.com/s/1KYqWOjsnoqhwj9KrM8GBg" target="_blank" rel="noopener">松哥搜刮了 2TB 免费 Java 学习资源，记得收藏哦</a></li><li><a href="https://mp.weixin.qq.com/s/CyMXvY-IzY-69Q_uYxxXMA" target="_blank" rel="noopener">Maven 入门，Maven + IDEA 创建多模块项目，松哥手敲了 30 多页教程给大家送来了</a></li><li><a href="https://mp.weixin.qq.com/s/4N0qWTHM2CuUFRoBIBUHwQ" target="_blank" rel="noopener">来了，松哥纯手工打造的超 50 页 Spring 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/4v7VPjSjf5DW86I3ecptFw" target="_blank" rel="noopener">松哥纯手工打造 80 多页的 SpringMVC 教程开放下载了</a></li><li><a href="https://mp.weixin.qq.com/s/sf_ZtaZllP4RdyftZghoHQ" target="_blank" rel="noopener">MyBatis 教程来啦，松哥手码的 SSM 教程总算齐活了，小伙伴们可以下载啦</a></li></ol><h2 id="10-其他"><a href="#10-其他" class="headerlink" title="10.其他"></a>10.其他</h2><ol><li><a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a></li><li><a href="https://mp.weixin.qq.com/s/LA8_FPp19MumWNdLg9ljtQ" target="_blank" rel="noopener">MacBook Pro 入手一年了，到底香不香？</a></li><li><a href="https://mp.weixin.qq.com/s/_W1Ism-pyarB1u2wX-gCFw" target="_blank" rel="noopener">不花一分钱，把自己零散的知识整理成体系，制作成在线电子书</a></li><li><a href="https://mp.weixin.qq.com/s/mo4IV1Q20x8H3zdNBcWi2Q" target="_blank" rel="noopener">视频教程最佳食用姿势，顺便说说前后端分离开发 Bug 解决思路</a></li><li><a href="https://mp.weixin.qq.com/s/70MR7N5e5hKzwM-qwm0XxQ" target="_blank" rel="noopener">分布式事务开局第一篇，从数据库事务隔离级别说起</a></li><li><a href="https://mp.weixin.qq.com/s/-JorqG-gPTEWZflCFywIrw" target="_blank" rel="noopener">分布式事务系列第二篇，回顾 Jdbc 事务</a></li><li><a href="https://mp.weixin.qq.com/s/XnIi5ylwTO0pkR-7WDBcAA" target="_blank" rel="noopener">分布式事务系列第三篇，Spring 事务概述</a></li><li><a href="https://mp.weixin.qq.com/s/yvJXiX70iNSdd2mbSQbUCQ" target="_blank" rel="noopener">GitHub 又掉链子，我给微人事 + Spring Boot + Spring Cloud 案例找了新家</a></li><li><a href="https://mp.weixin.qq.com/s/NfZNa1Zn7rSUGFO7by4i1A" target="_blank" rel="noopener">年后跳槽高峰季，关于简历制作，松哥有话说</a></li><li><a href="https://mp.weixin.qq.com/s/JKEo1WbJghm3PcK75guxzA" target="_blank" rel="noopener">如果你没写过博客，现在就是你写博客的最佳时机</a></li><li><a href="https://mp.weixin.qq.com/s/u1Wng-vJjzIrx0hb3gARsA" target="_blank" rel="noopener">新年新气象，接个私活赚点生活费？恐怕事情没有这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/k3GHndxqb7XexwVs_hs5mg" target="_blank" rel="noopener">写博客必备！手把手教大家搭建免费图床，真香！</a></li><li><a href="https://mp.weixin.qq.com/s/T31D4vI3alj9lnvouGQaXg" target="_blank" rel="noopener">程序员写书到底赚钱吗</a></li><li><a href="https://mp.weixin.qq.com/s/av3DADdBT8jXShccmicmIw" target="_blank" rel="noopener">前两天松哥收到了一份简历，10 年 Java 经验，期望薪资 25k</a></li><li><a href="https://mp.weixin.qq.com/s/sOMSATOaM-ltTUOWqcO_RQ" target="_blank" rel="noopener">今天我要给公众号新出的这个功能点赞！</a></li></ol><p><strong>如果这些教程对你有帮助，欢迎转发给更多需要的小伙伴哦～</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以后我会定期更新这个索引，频率大概一周左右更新一次，该索引会列出 2020 年所有原创干货，方便大家查找之前的文章。小伙伴们在公众号后台回复 &lt;strong&gt;2020&lt;/strong&gt; 可以及时获取最新版索引。&lt;/p&gt;
    
    </summary>
    
      <category term="学习资源" scheme="http://www.javaboy.org/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="学习资源" scheme="http://www.javaboy.org/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</title>
    <link href="http://www.javaboy.org/2020/0503/custom-authentication.html"/>
    <id>http://www.javaboy.org/2020/0503/custom-authentication.html</id>
    <published>2020-05-03T12:34:24.000Z</published>
    <updated>2020-05-10T12:58:23.760Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴会说，自定义认证逻辑还不简单？是的，没错，松哥之前也多次教过大家如何自定义认证逻辑，无论是添加登录验证码还是修改登录数据库格式，都需要对认证逻辑作出调整。</p><p>之前我们自定义的一个核心思路就是自定义过滤器，在过滤器中做各种各样我们想做的事：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/aaop_dS9UIOgTtQd0hl_tw" target="_blank" rel="noopener">Spring Security 如何添加登录验证码？松哥手把手教你给微人事添加登录验证码</a></li><li><a href="https://mp.weixin.qq.com/s/RHoXwIn6J-O8tbVjsYIcBQ" target="_blank" rel="noopener">前后端分离中，使用 JSON 格式登录原来这么简单！</a></li></ul><p>上面这两篇文章都是使用了自定义过滤器的思路，这算是一种入门级的自定义认证逻辑了，不知道大家有没有想过，这种方式其实是有一些问题的。</p><p>举一个简单的例子，在添加登录验证码中，我为了校验验证码就自定义了一个过滤器，并把这个自定义的过滤器放入 SpringSecurity 过滤器链中，每次请求都会通过该过滤器。但实际上，只需要登录请求经过该过滤器即可，其他请求是不需要经过该过滤器的，这个时候，大家是不是就发现弊端了。</p><p>当然，如果你对性能没有极致追求，这种写法其实也问题不大，毕竟功能已经实现了，但是抱着学习的态度，今天松哥要在前面文章的基础上给大家介绍一个更加优雅的写法。</p><p>本文是我们 SpringSecurity 系列的第 11 篇，阅读本系列前面文章有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li></ol><p>好了，不废话了，我们开始今天的文章。</p><h2 id="1-认证流程简析"><a href="#1-认证流程简析" class="headerlink" title="1.认证流程简析"></a>1.认证流程简析</h2><p>AuthenticationProvider 定义了 Spring Security 中的验证逻辑，我们来看下 AuthenticationProvider 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，AuthenticationProvider 中就两个方法：</p><ul><li>authenticate 方法用来做验证，就是验证用户身份。</li><li>supports 则用来判断当前的 AuthenticationProvider 是否支持对应的 Authentication。</li></ul><p>这里又涉及到一个东西，就是 Authentication。</p><p>玩过 Spring Security 的小伙伴都知道，在 Spring Security 中有一个非常重要的对象叫做 Authentication，我们可以在任何地方注入 Authentication 进而获取到当前登录用户信息，Authentication 本身是一个接口，它实际上对 java.security.Principal 做的进一步封装，我们来看下 Authentication 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Authentication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Principal</span>, <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getDetails</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAuthenticated</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里接口中的方法也没几个，我来大概解释下：</p><ol><li>getAuthorities 方法用来获取用户的权限。</li><li>getCredentials 方法用来获取用户凭证，一般来说就是密码。</li><li>getDetails 方法用来获取用户携带的详细信息，可能是当前请求之类的东西。</li><li>getPrincipal 方法用来获取当前用户，可能是一个用户名，也可能是一个用户对象。</li><li>isAuthenticated 当前用户是否认证成功。</li></ol><p>Authentication 作为一个接口，它定义了用户，或者说 Principal 的一些基本行为，它有很多实现类：</p><p><img src="http://img.itboyhub.com/2020/03/authentication-1.png" alt></p><p>在这些实现类中，我们最常用的就是 UsernamePasswordAuthenticationToken 了，而每一个 Authentication 都有适合它的 AuthenticationProvider 去处理校验。例如处理 UsernamePasswordAuthenticationToken 的 AuthenticationProvider 是 DaoAuthenticationProvider。</p><p>所以大家在 AuthenticationProvider 中看到一个 supports 方法，就是用来判断 AuthenticationProvider 是否支持当前 Authentication。</p><p>在一次完整的认证中，可能包含多个 AuthenticationProvider，而这多个 AuthenticationProvider 则由 ProviderManager 进行统一管理，具体可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a>。</p><p>这里我们来重点看一下 DaoAuthenticationProvider，因为这是我们最常用的一个，当我们使用用户名/密码登录的时候，用的就是它，DaoAuthenticationProvider 的父类是 AbstractUserDetailsAuthenticationProvider，我们就先从它的父类看起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractUserDetailsAuthenticationProvider</span> <span class="hljs-keyword">implements</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">AuthenticationProvider</span>, <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">MessageSourceAware</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">String username = (authentication.getPrincipal() == <span class="hljs-keyword">null</span>) ? <span class="hljs-string">"NONE_PROVIDED"</span></span><br><span class="line">: authentication.getName();</span><br><span class="line"><span class="hljs-keyword">boolean</span> cacheWasUsed = <span class="hljs-keyword">true</span>;</span><br><span class="line">UserDetails user = <span class="hljs-keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line"><span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">cacheWasUsed = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (UsernameNotFoundException notFound) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"User '"</span> + username + <span class="hljs-string">"' not found"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (hideUserNotFoundExceptions) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> notFound;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (AuthenticationException exception) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (cacheWasUsed) &#123;</span><br><span class="line">cacheWasUsed = <span class="hljs-keyword">false</span>;</span><br><span class="line">user = retrieveUser(username,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">preAuthenticationChecks.check(user);</span><br><span class="line">additionalAuthenticationChecks(user,</span><br><span class="line">(UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> exception;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postAuthenticationChecks.check(user);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.userCache.putUserInCache(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object principalToReturn = user;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (forcePrincipalAsString) &#123;</span><br><span class="line">principalToReturn = user.getUsername();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> (UsernamePasswordAuthenticationToken.class</span><br><span class="line">.isAssignableFrom(authentication));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractUserDetailsAuthenticationProvider 的代码还是挺长的，这里我们重点关注两个方法：authenticate 和 supports。</p><p>authenticate 方法就是用来做认证的方法，我们来简单看下方法流程：</p><ol><li>首先从 Authentication 提取出登录用户名。</li><li>然后通过拿着 username 去调用 retrieveUser 方法去获取当前用户对象，这一步会调用我们自己在登录时候的写的 loadUserByUsername 方法，所以这里返回的 user 其实就是你的登录对象，可以参考微人事的 org/javaboy/vhr/service/HrService.java#L34，也可以参考本系列之前的文章：<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a>。</li><li>接下来调用 preAuthenticationChecks.check 方法去检验 user 中的各个账户状态属性是否正常，例如账户是否被禁用、账户是否被锁定、账户是否过期等等。</li><li>additionalAuthenticationChecks 方法则是做密码比对的，好多小伙伴好奇 Spring Security 的密码加密之后，是如何进行比较的，看这里就懂了，因为比较的逻辑很简单，我这里就不贴代码出来了。但是注意，additionalAuthenticationChecks 方法是一个抽象方法，具体的实现是在 AbstractUserDetailsAuthenticationProvider 的子类中实现的，也就是 DaoAuthenticationProvider。这个其实很好理解，因为 AbstractUserDetailsAuthenticationProvider 作为一个较通用的父类，处理一些通用的行为，我们在登录的时候，有的登录方式并不需要密码，所以 additionalAuthenticationChecks 方法一般交给它的子类去实现，在 DaoAuthenticationProvider 类中，additionalAuthenticationChecks 方法就是做密码比对的，在其他的 AuthenticationProvider 中，additionalAuthenticationChecks 方法的作用就不一定了。</li><li>最后在 postAuthenticationChecks.check 方法中检查密码是否过期。</li><li>接下来有一个 forcePrincipalAsString 属性，这个是是否强制将 Authentication 中的 principal 属性设置为字符串，这个属性我们一开始在 UsernamePasswordAuthenticationFilter 类中其实就是设置为字符串的（即 username），但是默认情况下，当用户登录成功之后， 这个属性的值就变成当前用户这个对象了。之所以会这样，就是因为 forcePrincipalAsString 默认为 false，不过这块其实不用改，就用 false，这样在后期获取当前用户信息的时候反而方便很多。</li><li>最后，通过 createSuccessAuthentication 方法构建一个新的 UsernamePasswordAuthenticationToken。</li></ol><p>supports 方法就比较简单了，主要用来判断当前的 Authentication 是否是 UsernamePasswordAuthenticationToken。</p><p>由于 AbstractUserDetailsAuthenticationProvider 已经把 authenticate 和 supports 方法实现了，所以在 DaoAuthenticationProvider 中，我们主要关注 additionalAuthenticationChecks 方法即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DaoAuthenticationProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractUserDetailsAuthenticationProvider</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"deprecation"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additionalAuthenticationChecks</span><span class="hljs-params">(UserDetails userDetails,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authentication.getCredentials() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line"><span class="hljs-keyword">if</span> (!passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(</span><br><span class="line"><span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,</span><br><span class="line"><span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，additionalAuthenticationChecks 方法主要用来做密码比对的，逻辑也比较简单，就是调用 PasswordEncoder 的 matches 方法做比对，如果密码不对则直接抛出异常即可。</p><p><strong>正常情况下，我们使用用户名/密码登录，最终都会走到这一步。</strong></p><p>而 AuthenticationProvider 都是通过 ProviderManager#authenticate 方法来调用的。由于我们的一次认证可能会存在多个 AuthenticationProvider，所以，在 ProviderManager#authenticate 方法中会逐个遍历 AuthenticationProvider，并调用他们的 authenticate 方法做认证，我们来稍微瞅一眼 ProviderManager#authenticate 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">result = provider.authenticate(authentication);</span><br><span class="line"><span class="hljs-keyword">if</span> (result != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">copyDetails(authentication, result);</span><br><span class="line"><span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在这个方法中，会遍历所有的 AuthenticationProvider，并调用它的 authenticate 方法进行认证。</p><p>好了，大致的认证流程说完之后，相信大家已经明白了我们要从哪里下手了。</p><h2 id="2-自定义认证思路"><a href="#2-自定义认证思路" class="headerlink" title="2.自定义认证思路"></a>2.自定义认证思路</h2><p>之前我们通过自定义过滤器，将自定义的过滤器加入到 Spring Security 过滤器链中，进而实现了添加登录验证码功能，但是我们也说这种方式是有弊端的，就是破坏了原有的过滤器链，请求每次都要走一遍验证码过滤器，这样不合理。</p><p>我们改进的思路也很简单。</p><p>登录请求是调用 AbstractUserDetailsAuthenticationProvider#authenticate 方法进行认证的，在该方法中，又会调用到 DaoAuthenticationProvider#additionalAuthenticationChecks 方法做进一步的校验，去校验用户登录密码。我们可以自定义一个 AuthenticationProvider 代替 DaoAuthenticationProvider，并重写它里边的 additionalAuthenticationChecks 方法，在重写的过程中，加入验证码的校验逻辑即可。</p><p>这样既不破坏原有的过滤器链，又实现了自定义认证功能。<strong>常见的手机号码动态登录，也可以使用这种方式来认证。</strong></p><p>好了，不 bb 了，咱们上代码。</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h2><p>首先我们需要验证码，这次我就懒得自己去实现了，我们用网上一个现成的验证码库 kaptcha，首先我们添加该库的依赖，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.penggle<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kaptcha<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们提供一个实体类用来描述验证码的基本信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Producer <span class="hljs-title">verifyCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Properties properties = <span class="hljs-keyword">new</span> Properties();</span><br><span class="line">    properties.setProperty(<span class="hljs-string">"kaptcha.image.width"</span>, <span class="hljs-string">"150"</span>);</span><br><span class="line">    properties.setProperty(<span class="hljs-string">"kaptcha.image.height"</span>, <span class="hljs-string">"50"</span>);</span><br><span class="line">    properties.setProperty(<span class="hljs-string">"kaptcha.textproducer.char.string"</span>, <span class="hljs-string">"0123456789"</span>);</span><br><span class="line">    properties.setProperty(<span class="hljs-string">"kaptcha.textproducer.char.length"</span>, <span class="hljs-string">"4"</span>);</span><br><span class="line">    Config config = <span class="hljs-keyword">new</span> Config(properties);</span><br><span class="line">    DefaultKaptcha defaultKaptcha = <span class="hljs-keyword">new</span> DefaultKaptcha();</span><br><span class="line">    defaultKaptcha.setConfig(config);</span><br><span class="line">    <span class="hljs-keyword">return</span> defaultKaptcha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置很简单，我们就是提供了验证码图片的宽高、字符库以及生成的验证码字符长度。</p><p>接下来提供一个返回验证码图片的接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VerifyCodeController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    Producer producer;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/vc.jpg"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getVerifyCode</span><span class="hljs-params">(HttpServletResponse resp, HttpSession session)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="hljs-string">"image/jpeg"</span>);</span><br><span class="line">        String text = producer.createText();</span><br><span class="line">        session.setAttribute(<span class="hljs-string">"verify_code"</span>, text);</span><br><span class="line">        BufferedImage image = producer.createImage(text);</span><br><span class="line">        <span class="hljs-keyword">try</span>(ServletOutputStream out = resp.getOutputStream()) &#123;</span><br><span class="line">            ImageIO.write(image, <span class="hljs-string">"jpg"</span>, out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们生成验证码图片，并将生成的验证码字符存入 HttpSession 中。注意这里我用到了 try-with-resources ，可以自动关闭流，有的小伙伴可能不太清楚，可以自己搜索看下。</p><p>接下来我们来自定义一个 MyAuthenticationProvider 继承自 DaoAuthenticationProvider，并重写 additionalAuthenticationChecks 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAuthenticationProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DaoAuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additionalAuthenticationChecks</span><span class="hljs-params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        HttpServletRequest req = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();</span><br><span class="line">        String code = req.getParameter(<span class="hljs-string">"code"</span>);</span><br><span class="line">        String verify_code = (String) req.getSession().getAttribute(<span class="hljs-string">"verify_code"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (code == <span class="hljs-keyword">null</span> || verify_code == <span class="hljs-keyword">null</span> || !code.equals(verify_code)) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"验证码错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">super</span>.additionalAuthenticationChecks(userDetails, authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 additionalAuthenticationChecks 方法中：</p><ol><li>首先获取当前请求，注意这种获取方式，在基于 Spring 的 web 项目中，我们可以随时随地获取到当前请求，获取方式就是我上面给出的代码。</li><li>从当前请求中拿到 code 参数，也就是用户传来的验证码。</li><li>从 session 中获取生成的验证码字符串。</li><li>两者进行比较，如果验证码输入错误，则直接抛出异常。</li><li>最后通过 super 调用父类方法，也就是 DaoAuthenticationProvider 的 additionalAuthenticationChecks 方法，该方法中主要做密码的校验。</li></ol><p>MyAuthenticationProvider 定义好之后，接下来主要是如何让 MyAuthenticationProvider 代替 DaoAuthenticationProvider。</p><p>前面我们说，所有的 AuthenticationProvider 都是放在 ProviderManager 中统一管理的，所以接下来我们就要自己提供 ProviderManager，然后注入自定义的 MyAuthenticationProvider，这一切操作都在 SecurityConfig 中完成：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">MyAuthenticationProvider <span class="hljs-title">myAuthenticationProvider</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        MyAuthenticationProvider myAuthenticationProvider = <span class="hljs-keyword">new</span> MyAuthenticationProvider();</span><br><span class="line">        myAuthenticationProvider.setPasswordEncoder(passwordEncoder());</span><br><span class="line">        myAuthenticationProvider.setUserDetailsService(userDetailsService());</span><br><span class="line">        <span class="hljs-keyword">return</span> myAuthenticationProvider;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ProviderManager manager = <span class="hljs-keyword">new</span> ProviderManager(Arrays.asList(myAuthenticationProvider()));</span><br><span class="line">        <span class="hljs-keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetailsService <span class="hljs-title">userDetailsService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        <span class="hljs-keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/vc.jpg"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .successHandler((req, resp, auth) -&gt; &#123;</span><br><span class="line">                    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="hljs-string">"success"</span>, auth.getPrincipal())));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                .failureHandler((req, resp, e) -&gt; &#123;</span><br><span class="line">                    resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    PrintWriter out = resp.getWriter();</span><br><span class="line">                    out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(RespBean.error(e.getMessage())));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码我稍作解释：</p><ol><li>我们需要提供一个 MyAuthenticationProvider 的实例，创建该实例时，需要提供 UserDetailService 和 PasswordEncoder 实例。</li><li>通过重写 authenticationManager 方法来提供一个自己的 AuthenticationManager，实际上就是 ProviderManager，在创建 ProviderManager 时，加入自己的 myAuthenticationProvider。</li><li>这里为了简单，我将用户直接存在内存中，提供一个 UserDetailsService 实例即可。如果大家想将用户存在数据库中，可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a>。</li><li>最后就简单配置一下各种回调即可，另外记得设置 <code>/vc.jpg</code> 任何人都能访问。</li></ol><p>好了，如此之后，在不需要修改原生过滤器链的情况下，我们嵌入了自己的认证逻辑。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>好了，接下来，启动项目，我们开始测试。</p><p>为了方便，这里我就用 POSTMAN 来测试，首先可以给一个错误的验证码，如下：</p><p><img src="http://img.itboyhub.com/2020/04/20200502214324.png" alt></p><p>接下来，请求 /vc.jpg 获取验证码：</p><p><img src="http://img.itboyhub.com/2020/04/20200502214427.png" alt></p><p>输入正确的验证码和错误的密码，再进行登录：</p><p><img src="http://img.itboyhub.com/2020/04/20200502214513.png" alt></p><p>最后，所有的都输入正确，再来看下：</p><p><img src="http://img.itboyhub.com/2020/04/20200502214614.png" alt></p><p>登录成功！</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>上面的例子，我使用了添加登录验证码的案例，实际上，其他的登录场景也可以考虑这种方案，例如目前广为流行的手机号码动态登录，就可以使用这种方式认证。</p><p>当然，上文的案例还有完善的空间，松哥将在下篇文章继续和大家分享。</p><p>本文案例大家可以从 GitHub 上下载：<a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a>。</p><p>五一期间码字还是蛮辛苦的，小伙伴要是觉得有收获，记得给个在看鼓励下松哥哦～</p><p>大家五一快乐～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有小伙伴会说，自定义认证逻辑还不简单？是的，没错，松哥之前也多次教过大家如何自定义认证逻辑，无论是添加登录验证码还是修改登录数据库格式，都需要对认证逻辑作出调整。&lt;/p&gt;
&lt;p&gt;之前我们自定义的一个核心思路就是自定义过滤器，在过滤器中做各种各样我们想做的事：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>今天我要给公众号新出的这个功能点赞！</title>
    <link href="http://www.javaboy.org/2020/0502/weixin.html"/>
    <id>http://www.javaboy.org/2020/0502/weixin.html</id>
    <published>2020-05-02T12:34:09.000Z</published>
    <updated>2020-05-10T12:58:18.125Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家有没有注意到，最近打开松哥的文章，文章上面都会有这样的提示：</p><p><img src="http://img.itboyhub.com/2020/04/20200501-122926.jpg" alt></p><p>这就是微信公众号最新推出的专辑功能。</p><a id="more"></a><p>这个功能非常赞，为什么呢？</p><p>松哥从写公众号的第一天起，就很少发一些零散教程，主要都是成体系的系列教程，到目前为止也写了不少系列了，但是这些系列有一个问题，就是查找起来不方便。经常有一篇文章当时看了后，过了两天想再来看看这篇文章，却发现要在公众号里边翻半天才能找到。</p><p>现在好了，有了这个专辑的功能，大家只需要点一下专辑名称，就可以看到该系列的所有文章了，而且这个专辑功能只能添加原创文章，这非常符合松哥原创号的气质：</p><p><img src="http://img.itboyhub.com/2020/04/20200501-124831.jpg" alt></p><p>再也不用去浩如烟海的公众号上一篇一篇去翻了，松哥也会及时将原创文章同步进来。</p><p>我抽空把自己的文章整理了下，整理出来了不少系列（可以给喜欢的专辑点个在看哦）：</p><ol><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319853381099356160&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">SpringBoot 系列</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319870759258456064&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">SpringBoot+Vue 前后端分离</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319828555819286528&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">SpringSecurity 系列</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1319833457266163712&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">OAuth2 系列</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1320447559474774017&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">MySQL 进阶</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1320522554217496579&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Redis 系列</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1320487122733793281&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Coding之外</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1320464036546379777&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">MongoDB 系列</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1320462359864967171&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Git 系列</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1320467169657913345&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">Elasticsearch 系列</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1320477918031675394&amp;__biz=MzI1NDY0MTkzNQ==#wechat_redirect" target="_blank" rel="noopener">程序人生</a></li></ol><p>还有一个 Spring Cloud 系列，因为是基于 D 版写的，时间比较久远，我就没有专门做成专辑了，感兴趣的效果版可以在公众号底部菜单栏点击 <strong>学习资源-&gt;教程合集</strong> 能看到。</p><p>在微信这个专辑功能推出来之前，查找公众号查找历史文章这个问题，松哥其实折腾了很久了。</p><ol><li>文章里做索引</li></ol><p>松哥写系列文章的时候，一般都会在文章里列出来该系列的索引：</p><p><img src="http://img.itboyhub.com/2020/04/20200501130739.png" alt></p><p>这样可以方便大家找到前面的文章，但是也有问题。</p><p>因为文章的发布是有先后顺序的，后期的文章里有前面文章的索引，而前面文章里没有后期文章的索引，文章发布之后又无法做大规模的修改，这样如果你看了前面的文章，想找该系列后面的文章又得去公众号里翻了。</p><ol start="2"><li>公众号定期做索引</li></ol><p>基于第一点存在的问题，所以我后来又开始定期发布文章索引，例如上周刚刚了一篇：</p><ul><li><a href="https://mp.weixin.qq.com/s/cNBhVa3sLRPg6CQ_b6y_cw" target="_blank" rel="noopener">2020 原创视频+图文干货整理汇总</a></li></ul><p>这种索引式的文章要定期发布，方便大家查找。</p><p>但是这也有问题，就是索引文章本身也淹没在公众号文章里了，要找到也不容易。所以我又想了个办法，大家直接在公众号后台回复 <strong>2020</strong> ，就能找到索引文章。</p><p>这里顺便说一句，虽然公众号现在有了专辑功能，但是索引我还是会定期整理，大家只需要在公众号后台回复 <strong>2020</strong> ，就能获取原创文章的最新分类索引（大概一周同步一次）。</p><ol start="3"><li>页面模版</li></ol><p>为了整理我的系列文章，我也用过页面模版功能，大家在我公众号底部菜单点击 <strong>学习资源-&gt;教程合集</strong>，看到的就是页面模版功能，但是这个不怎么好用，作用也非常有限，感兴趣的小伙伴可以自己点击试一下。</p><ol start="4"><li>网站整理</li></ol><p>另一方面我也会定期把文章同步在个人网站 <a href="http://www.javaboy.org">www.javaboy.org</a> 上，但是这个网站是基于 GitHub Pages 搭建的(<a href="https://mp.weixin.qq.com/s/P_n-Vz3h3dZiZ1xNWKHeTg" target="_blank" rel="noopener">不用花一分线，松哥手把手教你上线个人博客</a>)，国内访问 GitHub 不是很稳定，进而带来松哥这个网站也不是很稳定。</p><p>有小伙伴说为什么不在国内买个云服务器搭建网站呢？这个就说来话长了，等我改天写个文章和大家专门介绍。</p><p>好了，这些都是过去式了，如今有了专辑功能，小伙伴们看系列文章也要方便很多了，不妨去试试吧～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道大家有没有注意到，最近打开松哥的文章，文章上面都会有这样的提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.itboyhub.com/2020/04/20200501-122926.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这就是微信公众号最新推出的专辑功能。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 打怪升级路线图，大佬是这样炼成的！一定要收藏</title>
    <link href="http://www.javaboy.org/2020/0501/java-guide.html"/>
    <id>http://www.javaboy.org/2020/0501/java-guide.html</id>
    <published>2020-05-01T12:33:55.000Z</published>
    <updated>2020-05-10T12:58:12.313Z</updated>
    
    <content type="html"><![CDATA[<p>技术日新月异，对于初入职场的同学来说，经常会困惑该往那个方向发展，这一点松哥是深有体会的。</p><p>网上的资料多如牛毛，但是很多时候我们缺的不是一个资料，而是一个学习规划！</p><a id="more"></a><p>就是说，做 Java 开发，我们应该从哪里开始学？应该学习哪些东西？应该按照什么样的顺序来学？</p><p>松哥大二刚开始自学 Java 那会，最大的问题就是不知道该学什么，以及学习的顺序，自己一个人摸索了很长时间，后来才逐步建立起自己的知识体系。</p><p>所以每次有小伙伴问我 Java 的学习规划时，我都能理解大家所处的困境。</p><p>Java 开发涉及到的领域非常多，对于开发者而言要掌握的东西也非常多，初入行的小伙伴甚至觉得这些要掌握的东西非常杂乱，其实不然！所有要学习的东西都是有内在关联的。</p><p>松哥今天就来和大家捋一捋 Java 学习路线图，一起来看看都有哪些东西需要掌握，以及要按照什么样的顺序来学习。</p><h2 id="1-整体规划"><a href="#1-整体规划" class="headerlink" title="1. 整体规划"></a>1. 整体规划</h2><p>Java 企业级开发涉及到的技能点实际上非常多，我将其大致归为以下五类（文末可以获取思维导图）：</p><p><img src="http://img.itboyhub.com/2020/04/20200430194747.png" alt></p><p>在这个技术栈的基础上，你可以继续选择走全栈道路或者走大数据方向。</p><p>有的小伙伴可能会纠结于要全面还是要精通某一方面，其实这个无所谓好坏，关键是要看你自己。你是想去大厂做一个某一领域的技术专家，还是想自己独当一面，自己喜欢的才是最好的。</p><p>话说回来，即使你想钻研某一方面，也不是说这些东西就不用学了，即使精通某一方面，也必然是先广泛涉猎，再慢慢确定自己的方向。</p><p>松哥大学自学 Java 的时候就是这样，当我不知道哪些东西重要哪些东西不重要的时候，我就都学，反正大学生有大把时间，我甚至连 Dreamweaver，Fireworks，Flash 三剑客都学了，甚至利用 Dreamweaver 上简陋的功能做了一个动态网站。</p><p>这些东西你说学了没用吗？其实不见得。当我学了很多之后，在未来某一天，突然就顿悟了，把这些学过的东西串起来了，有一种醍醐灌顶的感觉。</p><p>接下来，这里五大块松哥拆分开来分别给大家介绍。</p><h2 id="2-JavaSE"><a href="#2-JavaSE" class="headerlink" title="2. JavaSE"></a>2. JavaSE</h2><p>先来看我画的思维导图（文末可以获取思维导图）：</p><p><img src="http://img.itboyhub.com/2020/04/20200430200759.png" alt></p><p>JavaSE 这块其实没啥值得说的，基础的东西很多年都没有变化。而且 JavaSE 这块网上也有很多免费教程，<strong>大家在公众号【江南一点雨】后台回复 2TB，也有相关的免费视频教程</strong>。</p><p>很多公司，用的 Java8/9/10，实际上还是写的 JDK1.5 的代码，但是这并不意味着我们就不用学习了。Java8/9/10/11 中的一些新特性还是有必要去学习下，特别是现在 WebFlux 逐渐被人们重视，一些从 Java8 就开始萌芽的理念与技术还是很有必要掌握一下的。</p><h2 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h2><p>先来看我画的思维导图（文末可以获取思维导图）：</p><p><img src="http://img.itboyhub.com/2020/04/20200430201515.png" alt></p><p>作为一名 Java 工程师，数据库的重要性不言而喻，这算是基本功，我们不能老指望着 DBA，毕竟配有 DBA 的公司只是极少数。有句话叫做“SQL 写得好，下班下得早”。</p><p>当然数据库也有很多优化方面的问题，但是在大家刚刚开始学习的时候，我其实是不建议去学习数据库优化、主从、集群、读写分离这些东西的，这些可以等到后面学习微服务的时候再去学习比较合适，在刚学习 Java 没多久的情况下，就去学习数据库优化，极有可能让你对开发这条路打退堂鼓。</p><p><strong>数据库这块大家在公众号【江南一点雨】后台回复 2TB，也有相关的免费视频教程</strong></p><h2 id="4-Web-基础"><a href="#4-Web-基础" class="headerlink" title="4. Web 基础"></a>4. Web 基础</h2><p>先来看我画的思维导图（文末可以获取思维导图）：</p><p><img src="http://img.itboyhub.com/2020/04/20200430202517.png" alt></p><p>学习是给自己学的，不能偷懒，所以你看我这里列出来的知识点比较多，甚至又一些看起来好像过时的技术。</p><p>有人会纠结 EasyUI 要不要学，这个有点古老。我的意见是，如果你是在校大学生，那就学，反正有时间；如果你已经工作了，现在查漏补缺，那可以结合公司的技术栈决定要不要学。</p><p>其实 EasyUI 也不能算是边缘化的东西，如果你前端不用 Vue、React 或者 Angular，EasyUI 绝对是一个无法忽视的存在，学习一下 EasyUI ，也能让我们理解整个前端的一个发展过程。</p><p>一般来说，Web 基础学完其实是可以自己做一些简单的项目的巩固一下知识点，这块网上也有很多开源项目，松哥这里也给大家推荐一个 CoolMeeting：</p><ul><li><a href="https://github.com/lenve/CoolMeeting" target="_blank" rel="noopener">https://github.com/lenve/CoolMeeting</a></li></ul><p>至于这里列出来的其他技术点，都是常规技术，<strong>大家在公众号【江南一点雨】后台回复 2TB，也有对应的免费视频教程</strong>。</p><h2 id="5-经典框架"><a href="#5-经典框架" class="headerlink" title="5. 经典框架"></a>5. 经典框架</h2><p>先来看我画的思维导图（文末可以获取思维导图）：</p><p><img src="http://img.itboyhub.com/2020/04/20200430221723.png" alt></p><p>这里涉及到的东西就比较多了，也是学起来最最漫长的一部分。</p><p>这里我主要说说关注的几个问题。</p><ol><li>SSH 还要学吗</li></ol><p>我们说的 SSH 一般是指 Spring、Struts2 以及 Hibernate。这三个里边，可以确认不用学习的 Struts2，如果你大学刚毕业，进入到一家公司，用 Struts2 做开发，你进去干了三年，Struts2 用的滚瓜烂熟，出来跳槽却发现没有任何优势，所以我不建议大家在 Struts2 上花时间。</p><p>至于 Hibernate ，这个我持保留态度。为什么这么说呢？</p><p>因为 Hibernate 和 Jpa 之间有着千丝万缕的联系，Spring Data Jpa 结合 Spring Boot，还是有很多公司在用，而如果你掌握了 Hibernate，在后面使用 Jpa 的时候上手很快，关于 Hibernate 和 Jpa 之间的关系，松哥之前专门写过文章介绍：<a href="https://mp.weixin.qq.com/s/Fg5ssXuvabZwEfRMKfpY9Q" target="_blank" rel="noopener">干货|一文读懂 Spring Data Jpa！</a></p><ol start="2"><li>消息中间件学哪个？</li></ol><p>就我目前了解到的情况，JavaEE 项目中，RabbitMQ 和 RocketMQ 使用较多，大数据中 Kafka 用的较多，传统的满足 JMS 规范的 ActiveMQ 使用较少。因此小伙伴们可以结合这样一个实际情况选择合适的消息中间件学习顺序。</p><p>这个阶段的知识点都搞定了，做个毕设肯定是绰绰有余了，出了学校校门找个实习肯定也够用了。<strong>大家在公众号【江南一点雨】后台回复 2TB，也有对应的免费视频教程</strong>。</p><h2 id="6-分布式-微服务相关"><a href="#6-分布式-微服务相关" class="headerlink" title="6. 分布式/微服务相关"></a>6. 分布式/微服务相关</h2><p>先来看我画的思维导图（文末可以获取思维导图）：</p><p><img src="http://img.itboyhub.com/2020/04/20200430223642.png" alt></p><p>这一块，Spring Boot 和 Spring Cloud 是重点，这两个又分别涉及到诸多知识点：</p><p>SpringBoot：</p><p><img src="http://img.itboyhub.com/2020/04/20200430223957.png" alt></p><p>SpringCloud：</p><p><img src="http://img.itboyhub.com/2020/04/20200430224039.png" alt></p><p>学习 Spring Boot 的基础依然是 SSM，不建议跳过 SSM 直接学 Spring Boot，这个松哥之前也专门写文章讲过：<a href="https://mp.weixin.qq.com/s/4RABulz1wDbLPjJSNgI0Qw" target="_blank" rel="noopener">Spring Boot 要怎么学？要学哪些东西？要不要先学 SSM？</a>。</p><p>Spring Boot 学完之后，也可以做个项目巩固一下，推荐两个开源项目：</p><ul><li><a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li><li><a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>当你搞定了 SSM、搞定了 Redis、搞定了中间件，你再去学习 Spring Boot 就会发现他是如此简单！</p><p>至于 Spring Cloud，虽然 Netflix 公司的几个组件已经不打算继续开源了，但是对于大家而言，我觉得还是有必要去学习一下的，毕竟也不难，花不了多少时间，而且学习这些组件可以帮助大家快速建立一个 Spring Cloud 知识体系。</p><p>出了这两大块之外，剩下的就不用我多说了。MySQL 的进阶我是建议放在这个阶段学习的，像数据优化、主从搭建、读写分离等，我建议放在这个阶段。</p><p><strong>大家在公众号【江南一点雨】后台回复 2TB，也有对应的免费视频教程</strong>。</p><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a>7. 小结</h2><p>上面的都学完之后，你已经可以站在一个比较高的角度来看待 JavaEE 开发了。</p><p>这个时候，可以考虑自己是想走 “专” 的道路，当一个技术专家呢，还是想走全栈的道路，以后自己搞个工作室之类的，抑或是想往大数据的方向发展都是可以的。无论小伙伴想走哪个方向，都可以在公众号【江南一点雨】后台回复 2TB，有对应的免费视频教程。</p><p>好了，一点点经验和小伙伴们分享，文中涉及到的思维导图大家可以在公众号后台回复 <strong>规划</strong> 获取下载链接。</p><p>好啦，小伙伴们五一快乐哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;技术日新月异，对于初入职场的同学来说，经常会困惑该往那个方向发展，这一点松哥是深有体会的。&lt;/p&gt;
&lt;p&gt;网上的资料多如牛毛，但是很多时候我们缺的不是一个资料，而是一个学习规划！&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.javaboy.org/categories/java/"/>
    
    
      <category term="Java" scheme="http://www.javaboy.org/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>在微服务项目中，Spring Security 比 Shiro 强在哪？</title>
    <link href="http://www.javaboy.org/2020/0430/spring-security-vs-shiro.html"/>
    <id>http://www.javaboy.org/2020/0430/spring-security-vs-shiro.html</id>
    <published>2020-04-30T12:33:39.000Z</published>
    <updated>2020-05-10T12:58:06.919Z</updated>
    
    <content type="html"><![CDATA[<p>最近松哥一直在和大家介绍 Spring Security 以及 OAuth2 相关的技能点，连载的文章也写了好多篇了，大家在公众号后台回复 <strong>2020</strong> 可以获取原创文章索引。</p><a id="more"></a><p>虽然目前 Spring Security 一片火热，但是 Shiro 的市场依然存在，今天我就来稍微的说一说这两个框架的，方便大家在实际项目中选择适合自己的安全管理框架。</p><p>首先我要声明一点，框架无所谓好坏，关键是适合当前项目场景，作为一个年轻的程序员更不应该厚此薄彼，或者拒绝学习某一个框架。</p><p>小孩子才做选择题，成年人两个都要学！</p><p>所以接下来主要结合我自己的经验来说一说这两个框架的优缺点，没有提到的地方也欢迎大家留言补充。</p><h2 id="1-Spring-Security"><a href="#1-Spring-Security" class="headerlink" title="1. Spring Security"></a>1. Spring Security</h2><h3 id="1-1-因为-SpringBoot-而火"><a href="#1-1-因为-SpringBoot-而火" class="headerlink" title="1.1 因为 SpringBoot 而火"></a>1.1 因为 SpringBoot 而火</h3><p>Spring Security 并非一个新生的事物，它最早不叫 Spring Security ，叫 Acegi Security，叫 Acegi Security 并不是说它和 Spring 就没有关系了，它依然是为 Spring 框架提供安全支持的。事实上，Java 领域的框架，很少有框架能够脱离 Spring 框架独立存在。</p><p>当 Spring Security 还叫 Acegi Security 的时候，虽然功能也还可以，但是实际上这个东西并没有广泛流行开来。最重要的原因就是它的配置太过于繁琐，当时网上流传一句话：“每当有人要使用 Acegi Security，就会有一个精灵死去。” 足见 Acegi Security 的配置是多么可怕。直到今天，当人们谈起 Spring Security 的时候，依然在吐槽它的配置繁琐。</p><p>后来 Acegi Security 投入 Spring 的怀抱，改名叫 Spring Security，事情才慢慢开始发生变化。新的开发团队一直在尽力简化 Spring Security 的配置，Spring Security 的配置相比 Acegi Security 确实简化了很多。但是在最初的几年里，Spring Security 依然无法得到广泛的使用。</p><p>直到有一天 Spring Boot 像谜一般出现在江湖边缘，彻底颠覆了 JavaEE 的世界。一人得道鸡犬升天，自从 Spring Boot 火了之后，Spring 家族的产品都被带了一把，Spring Security 就是受益者之一，从此飞上枝头变凤凰。</p><p>Spring Boot/Spring Cloud 现在作为 Java 开发领域最最主流的技术栈，这一点大家应该都没有什么异议，而在 Spring Boot/Spring Cloud 中做安全管理，Spring Security 无疑是最方便的。</p><p>你想保护 Spring Boot 中的接口，添加一个 Spring Security 的依赖即可，事情就搞定了，所有接口就保护起来了，甚至不需要一行配置。</p><p>有小伙伴可能觉得这个太笼统了，我再举一个实际点的例子。</p><p>在微服务架构的项目中，我们可能使用 Eureka 做服务注册中心，默认情况下，Eureka 没有做安全管理，如果你想给 Eureka 添加安全管理，只需要添加 Spring Security 依赖，然后在 application.properties 中配置一下用户名密码即可，Eureka 就自动被保护起来了，别人无法轻易访问；然后各个微服务在注册的时候，只需要把注册地址改为 <a href="http://username:password@localhost:8080/eureka" target="_blank" rel="noopener">http://username:password@localhost:8080/eureka</a> 即可。类似的例子还有 Spring Cloud Config 中的安全管理。</p><p>在微服务这种场景下，如果你想用 Shiro 代替 Spring Security，那 Shiro 代码量绝对非常可观，Spring Security 则可以非常容易的集成到现在流行的 Spring Boot/Spring Cloud 技术栈中，可以和 Spring Boot、Spring Cloud、Spring Social、WebSocket 等非常方便的整合。</p><p>所以我说，因为 Spring Boot/Spring Cloud 火爆，让 Spring Security 跟着沾了一把光。</p><h3 id="1-2-配置臃肿吗？"><a href="#1-2-配置臃肿吗？" class="headerlink" title="1.2 配置臃肿吗？"></a>1.2 配置臃肿吗？</h3><p><strong>有的人觉得 Spring Security 配置臃肿。</strong></p><p>如果是 SSM + Spring Security 的话，我觉得这话有一定道理。</p><p>但是如果是 Spring Boot 项目的话，其实并不见得臃肿。Spring Boot 中，通过自动化配置 starter 已经极大的简化了 Spring Security 的配置，我们只需要做少量的定制的就可以实现认证和授权了，这一点，大家可以参考我之前连载的 Spring Security 系列文章基本就能感受到这种便利（公众号后台回复 2020 有文章索引）。</p><p><strong>有人觉得 Spring Security 中概念复杂。</strong></p><p>这个是这样的，没错。</p><p>Spring Security 由于功能比较多，支持 OAuth2 等原因，就显得比较重量级，不像 Shiro 那样轻便。</p><p>但是如果换一个角度，你可能会有不一样的感受。</p><p>在 Spring Security 中你会学习到许多安全管理相关的概念，以及常见的安全攻击。这些安全攻击，如果你不是 web 安全方面的专家，很多可能存在的 web 攻击和漏洞你可能很难想到，而 Spring Security 则把这些安全问题都给我们罗列出来并且给出了相应的解决方案。</p><p>所以我说，我们学习 Spring Security 的过程，也是在学习 web 安全，各种各样的安全攻击、各种各样的登录方式、各种各样你能想到或者想不到的安全问题，Spring Security 都给我们罗列出来了，并且给出了解决方案，从这个角度来看，你会发现 Spring Security 好像也不是那么让人讨厌。</p><h3 id="1-3-结合微服务的优势"><a href="#1-3-结合微服务的优势" class="headerlink" title="1.3 结合微服务的优势"></a>1.3 结合微服务的优势</h3><p>除了前面和大家介绍的 Spring Security 优势，在微服务中，Spring 官方推出了 Spring Cloud Security 和 Spring Cloud OAuth2，结合微服务这种分布式特性，可以让我们更加方便的在微服务中使用 Spring Security 和 OAuth2，松哥前面的 OAuth2 系列实际上都是基于 Spring Cloud Security 来做的。</p><p>可以看到，Spring 官方一直在积极进取，让 Spring Security 能够更好的集成进微服务中。</p><h2 id="2-Shiro"><a href="#2-Shiro" class="headerlink" title="2. Shiro"></a>2. Shiro</h2><p>接下来我们再说说 Apache Shiro。</p><p>Apache Shiro 是一个开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro 框架具有直观、易用等特性，同时也能提供健壮的安全性，虽然它的功能不如 Spring Security 那么强大，但是在常规的企业级应用中，其实也够用了。</p><h3 id="2-1-由来"><a href="#2-1-由来" class="headerlink" title="2.1 由来"></a>2.1 由来</h3><p>Shiro 的前身是 JSecurity，2004 年，Les Hazlewood 和 Jeremy Haile 创办了 Jsecurity。当时他们找不到适用于应用程序级别的合适 Java 安全框架，同时又对 JAAS 非常失望，于是就搞了这个东西。</p><p>2004 年到 2008 年期间，JSecurity 托管在 SourceForge 上，贡献者包括 Peter Ledbrook、Alan Ditzel 和 Tim Veil。</p><p>2008 年，JSecurity 项目贡献给了 Apache 软件基金会（ASF），并被接纳成为 Apache Incubator 项目，由导师管理，目标是成为一个顶级 Apache 项目。期间，Jsecurity 曾短暂更名为 Ki，随后因商标问题被社区更名为“Shiro”。随后项目持续在 Apache Incubator 中孵化，并增加了贡献者 Kalle Korhonen。</p><p>2010 年 7 月，Shiro 社区发布了 1.0 版，随后社区创建了其项目管理委员会，并选举 Les Hazlewood 为主席。2010 年 9 月 22 日，Shrio 成为 Apache 软件基金会的顶级项目（TLP）。</p><h3 id="2-2-有哪些功能"><a href="#2-2-有哪些功能" class="headerlink" title="2.2 有哪些功能"></a>2.2 有哪些功能</h3><p>Apache Shiro 是一个强大而灵活的开源安全框架，它干净利落地处理身份认证，授权，企业会话管理和加密。Apache Shiro 的首要目标是易于使用和理解。安全有时候是很复杂的，甚至是痛苦的，但它没有必要这样。框架应该尽可能掩盖复杂的地方，露出一个干净而直观的 API，来简化开发人员在应用程序安全上所花费的时间。  </p><p>以下是你可以用 Apache Shiro 所做的事情：</p><ol><li>验证用户来核实他们的身份</li><li>对用户执行访问控制，如：判断用户是否被分配了一个确定的安全角色；判断用户是否被允许做某事</li><li>在任何环境下使用Session API，即使没有Web容器</li><li>在身份验证，访问控制期间或在会话的生命周期，对事件作出反应</li><li>聚集一个或多个用户安全数据的数据源，并作为一个单一的复合用户“视图”  </li><li>单点登录（SSO）功能</li><li>为没有关联到登录的用户启用”Remember Me”服务</li><li>…</li></ol><p>Apache Shiro 是一个拥有许多功能的综合性的程序安全框架。下面的图表展示了 Shiro 的重点：  </p><p><img src="http://img.itboyhub.com/2020/04/20200429193053.png" alt></p><p>Shiro 中有四大基石——身份验证，授权，会话管理和加密。  </p><ol><li>Authentication：有时也简称为“登录”，这是一个证明用户是谁的行为。</li><li>Authorization：访问控制的过程，也就是决定“谁”去访问“什么”。</li><li>Session Management：管理用户特定的会话，即使在非 Web 或 EJB 应用程序。</li><li>Cryptography：通过使用加密算法保持数据安全同时易于使用。</li></ol><p>除此之外，Shiro 也提供了额外的功能来解决在不同环境下所面临的安全问题，尤其是以下这些：</p><ol><li>Web Support：Shiro 的 web 支持的 API 能够轻松地帮助保护 Web 应用程序。</li><li>Caching：缓存是 Apache Shiro 中的第一层公民，来确保安全操作快速而又高效。</li><li>Concurrency：Apache Shiro 利用它的并发特性来支持多线程应用程序。</li><li>Testing：测试支持的存在来帮助你编写单元测试和集成测试。</li><li>“Run As”：一个允许用户假设为另一个用户身份（如果允许）的功能，有时候在管理脚本很有用。</li><li>“Remember Me”：在会话中记住用户的身份，这样用户只需要在强制登录时候登录。</li></ol><h3 id="2-3-学习资料"><a href="#2-3-学习资料" class="headerlink" title="2.3 学习资料"></a>2.3 学习资料</h3><p>Shiro 的学习资料并不多，没看到有相关的书籍。张开涛的《跟我学Shiro》是一个非常不错的资料，小伙伴可以搜索了解下。也可以在公众号<strong>江南一点雨</strong>后台回复 2TB，有相关的视频教程。</p><h3 id="2-4-优势和劣势"><a href="#2-4-优势和劣势" class="headerlink" title="2.4 优势和劣势"></a>2.4 优势和劣势</h3><p>就目前而言，Shiro 最大的问题在于和 Spring 家族的产品进行整合的时候非常不便，在 Spring Boot 推出的很长一段时间里，Shiro 都没有提供相应的 starter，后来虽然有一个 <code>shiro-spring-boot-web-starter</code> 出来，但是其实配置并没有简化多少。所以在 Spring Boot/Spring Cloud 技术栈的微服务项目中，Shiro 几乎不存在优势。</p><p>但是如果你是传统的 SSM 项目，不是微服务项目，那么无疑使用 Shiro 是最方便省事的，因为它足够简单，足够轻量级。</p><h2 id="3-如何取舍"><a href="#3-如何取舍" class="headerlink" title="3. 如何取舍"></a>3. 如何取舍</h2><p>在公司里做开发，这两个要如何取舍，还是要考虑蛮多东西的。</p><p>首先，如果是基于 Spring Boot/Spring Cloud 的微服务项目，Spring Security 无疑是最方便的。</p><p>如果是就是普通的 SSM 项目，那么 Shiro 基本上也够用。</p><p>另外，选择技术栈的时候，我们可能也要考虑团队内工程师的技术栈，如果工程师更擅长 Shiro，那么无疑 Shiro 是合适的，毕竟让工程师去学习一门新的技术，一来可能影响项目进度，而来也可能给项目埋下许多未知的雷。</p><p>对于我们个人来说，小孩子才做选择题，成年人两个都要学。</p><p>最后，我再罗列一下最近的 Spring Security 系列文章，供大家参考（这个系列还在继续更新中）：</p><p><strong>Spring Security 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li></ol><p><strong>OAuth2 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li><li><a href="https://mp.weixin.qq.com/s/aOXsHSPowmR2zLkF41wPlQ" target="_blank" rel="noopener">最近在做 Spring Cloud 项目，松哥和大家分享一点微服务架构中的安全管理思路</a></li><li><a href="https://mp.weixin.qq.com/s/EyAMTbKPqNNnEtZACIsMVw" target="_blank" rel="noopener">Spring Boot+OAuth2，一个注解搞定单点登录！</a></li><li><a href="https://mp.weixin.qq.com/s/tq4Q306J3hJFEtGL1EpOBA" target="_blank" rel="noopener">分分钟让自己的网站接入 GitHub 第三方登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/lnuAejqGqh_8W_-GHEq5gA" target="_blank" rel="noopener">Spring Boot+OAuth2，如何自定义返回的 Token 信息？</a></li></ol><p>参考资料：  </p><ol><li>维基百科-Apache Shiro  </li><li>Shiro参考手册  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近松哥一直在和大家介绍 Spring Security 以及 OAuth2 相关的技能点，连载的文章也写了好多篇了，大家在公众号后台回复 &lt;strong&gt;2020&lt;/strong&gt; 可以获取原创文章索引。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 自动登录，安全风险要怎么控制？松哥教你两招</title>
    <link href="http://www.javaboy.org/2020/0429/rememberme-advance.html"/>
    <id>http://www.javaboy.org/2020/0429/rememberme-advance.html</id>
    <published>2020-04-29T12:33:25.000Z</published>
    <updated>2020-05-10T12:58:02.191Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">上篇文章</a>中，我们提到了 Spring Boot 自动登录存在的一些安全风险，在实际应用中，我们肯定要把这些安全风险降到最低，今天就来和大家聊一聊如何降低安全风险的问题。</p><a id="more"></a><p>降低安全风险，我主要从两个方面来给大家介绍：</p><ol><li>持久化令牌方案</li><li>二次校验</li></ol><p>当然，还是老规矩，阅读本文一定先阅读本系列前面的文章，这有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li></ol><p>好了，我们就不废话了，来看今天的文章。</p><h2 id="1-持久化令牌"><a href="#1-持久化令牌" class="headerlink" title="1.持久化令牌"></a>1.持久化令牌</h2><h3 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1 原理"></a>1.1 原理</h3><p>要理解持久化令牌，一定要先搞明白自动登录的基本玩法，参考（<a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a>）。</p><p>持久化令牌就是在基本的自动登录功能基础上，又增加了新的校验参数，来提高系统的安全性，这一些都是由开发者在后台完成的，对于用户来说，登录体验和普通的自动登录体验是一样的。</p><p>在持久化令牌中，新增了两个经过 MD5 散列函数计算的校验参数，一个是 series，另一个是 token。其中，series 只有当用户在使用用户名/密码登录时，才会生成或者更新，而 token 只要有新的会话，就会重新生成，这样就可以避免一个用户同时在多端登录，就像手机 QQ ，一个手机上登录了，就会踢掉另外一个手机的登录，这样用户就会很容易发现账户是否泄漏（之前看到松哥交流群里有小伙伴在讨论如何禁止多端登录，其实就可以借鉴这里的思路）。</p><p>持久化令牌的具体处理类在 PersistentTokenBasedRememberMeServices 中，<a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">上篇文章</a>我们讲到的自动化登录具体的处理类是在 TokenBasedRememberMeServices 中，它们有一个共同的父类：</p><p><img src="http://img.itboyhub.com/2020/04/RememberMeServices.png" alt></p><p>而用来保存令牌的处理类则是 PersistentRememberMeToken，该类的定义也很简洁命令：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersistentRememberMeToken</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String username;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String series;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String tokenValue;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Date date;</span><br><span class="line">    <span class="hljs-comment">//省略 getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 Date 表示上一次使用自动登录的时间。</p><h3 id="1-2-代码演示"><a href="#1-2-代码演示" class="headerlink" title="1.2 代码演示"></a>1.2 代码演示</h3><p>接下来，我通过代码来给大家演示一下持久化令牌的具体用法。</p><p>首先我们需要一张表来记录令牌信息，这张表我们可以完全自定义，也可以使用系统默认提供的 JDBC 来操作，如果使用默认的 JDBC，即 JdbcTokenRepositoryImpl，我们可以来分析一下该类的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTokenRepositoryImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JdbcDaoSupport</span> <span class="hljs-keyword">implements</span></span></span><br><span class="line"><span class="hljs-class"><span class="hljs-title">PersistentTokenRepository</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CREATE_TABLE_SQL = <span class="hljs-string">"create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, "</span></span><br><span class="line">+ <span class="hljs-string">"token varchar(64) not null, last_used timestamp not null)"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEF_TOKEN_BY_SERIES_SQL = <span class="hljs-string">"select username,series,token,last_used from persistent_logins where series = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEF_INSERT_TOKEN_SQL = <span class="hljs-string">"insert into persistent_logins (username, series, token, last_used) values(?,?,?,?)"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEF_UPDATE_TOKEN_SQL = <span class="hljs-string">"update persistent_logins set token = ?, last_used = ? where series = ?"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEF_REMOVE_USER_TOKENS_SQL = <span class="hljs-string">"delete from persistent_logins where username = ?"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这段 SQL 定义，我们就可以分析出来表的结构，松哥这里给出一段 SQL 脚本：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`persistent_logins`</span> (</span><br><span class="line">  <span class="hljs-string">`username`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`series`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`token`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`last_used`</span> <span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`series`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>首先我们在数据库中准备好这张表。</p><p>既然要连接数据库，我们还需要准备 jdbc 和 mysql 依赖，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后修改 application.properties ，配置数据库连接信息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:<span class="hljs-comment">///oauth2?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=<span class="hljs-number">123</span></span><br></pre></td></tr></table></figure><p>接下来，我们修改 SecurityConfig，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">DataSource dataSource;</span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">JdbcTokenRepositoryImpl <span class="hljs-title">jdbcTokenRepository</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="hljs-keyword">new</span> JdbcTokenRepositoryImpl();</span><br><span class="line">    jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">    <span class="hljs-keyword">return</span> jdbcTokenRepository;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .rememberMe()</span><br><span class="line">            .key(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .tokenRepository(jdbcTokenRepository())</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个 JdbcTokenRepositoryImpl 实例，并给其配置 DataSource 数据源，最后通过 tokenRepository 将 JdbcTokenRepositoryImpl 实例纳入配置中。</p><p>OK，做完这一切，我们就可以测试了。</p><h3 id="1-3-测试"><a href="#1-3-测试" class="headerlink" title="1.3 测试"></a>1.3 测试</h3><p>我们还是先去访问 <code>/hello</code> 接口，此时会自动跳转到登录页面，然后我们执行登录操作，记得勾选上“记住我”这个选项，登录成功后，我们可以重启服务器、然后关闭浏览器再打开，再去访问 /hello 接口，发现依然能够访问到，说明我们的持久化令牌配置已经生效。</p><p>查看 remember-me 的令牌，如下：</p><p><img src="http://img.itboyhub.com/2020/04/20200427102713.png" alt></p><p>这个令牌经过解析之后，格式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emhqATk3ZDBdR8862WP4Ig%3D%3D:ZAEv6EIWqA7CkGbYewCh8g%3D%3D</span><br></pre></td></tr></table></figure><p>这其中，%3D 表示 <code>=</code>，所以上面的字符实际上可以翻译成下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emhqATk3ZDBdR8862WP4Ig==:ZAEv6EIWqA7CkGbYewCh8g==</span><br></pre></td></tr></table></figure><p>此时，查看数据库，我们发现之前的表中生成了一条记录：</p><p><img src="http://img.itboyhub.com/2020/04/20200427102351.png" alt></p><p>数据库中的记录和我们看到的 remember-me 令牌解析后是一致的。</p><h3 id="1-4-源码分析"><a href="#1-4-源码分析" class="headerlink" title="1.4 源码分析"></a>1.4 源码分析</h3><p>这里的源码分析和<a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">上篇文章</a>的流程基本一致，只不过实现类变了，也就是生成令牌/解析令牌的实现变了，所以这里我主要和大家展示不一样的地方，流程问题，大家可以参考<a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">上篇文章</a>。</p><p>这次的实现类主要是：PersistentTokenBasedRememberMeServices，我们先来看里边几个和令牌生成相关的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoginSuccess</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, Authentication successfulAuthentication)</span> </span>&#123;</span><br><span class="line">String username = successfulAuthentication.getName();</span><br><span class="line">PersistentRememberMeToken persistentToken = <span class="hljs-keyword">new</span> PersistentRememberMeToken(</span><br><span class="line">username, generateSeriesData(), generateTokenData(), <span class="hljs-keyword">new</span> Date());</span><br><span class="line">tokenRepository.createNewToken(persistentToken);</span><br><span class="line">addCookie(persistentToken, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">generateSeriesData</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">byte</span>[] newSeries = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[seriesLength];</span><br><span class="line">random.nextBytes(newSeries);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(Base64.getEncoder().encode(newSeries));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">generateTokenData</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">byte</span>[] newToken = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[tokenLength];</span><br><span class="line">random.nextBytes(newToken);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(Base64.getEncoder().encode(newToken));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCookie</span><span class="hljs-params">(PersistentRememberMeToken token, HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">setCookie(<span class="hljs-keyword">new</span> String[] &#123; token.getSeries(), token.getTokenValue() &#125;,</span><br><span class="line">getTokenValiditySeconds(), request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>在登录成功后，首先还是获取到用户名，即 username。</li><li>接下来构造一个 PersistentRememberMeToken 实例，generateSeriesData 和 generateTokenData 方法分别用来获取 series 和 token，具体的生成过程实际上就是调用 SecureRandom 生成随机数再进行 Base64 编码，不同于我们以前用的 Math.random 或者 java.util.Random 这种伪随机数，SecureRandom 则采用的是类似于密码学的随机数生成规则，其输出结果较难预测，适合在登录这样的场景下使用。</li><li>调用 tokenRepository 实例中的 createNewToken 方法，tokenRepository 实际上就是我们一开始配置的 JdbcTokenRepositoryImpl，所以这行代码实际上就是将 PersistentRememberMeToken 存入数据库中。</li><li>最后 addCookie，大家可以看到，就是添加了 series 和 token。</li></ol><p>这是令牌生成的过程，还有令牌校验的过程，也在该类中，方法是：processAutoLoginCookie：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> UserDetails <span class="hljs-title">processAutoLoginCookie</span><span class="hljs-params">(String[] cookieTokens,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">final</span> String presentedSeries = cookieTokens[<span class="hljs-number">0</span>];</span><br><span class="line"><span class="hljs-keyword">final</span> String presentedToken = cookieTokens[<span class="hljs-number">1</span>];</span><br><span class="line">PersistentRememberMeToken token = tokenRepository</span><br><span class="line">.getTokenForSeries(presentedSeries);</span><br><span class="line"><span class="hljs-keyword">if</span> (!presentedToken.equals(token.getTokenValue())) &#123;</span><br><span class="line">tokenRepository.removeUserTokens(token.getUsername());</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CookieTheftException(</span><br><span class="line">messages.getMessage(</span><br><span class="line"><span class="hljs-string">"PersistentTokenBasedRememberMeServices.cookieStolen"</span>,</span><br><span class="line"><span class="hljs-string">"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack."</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (token.getDate().getTime() + getTokenValiditySeconds() * <span class="hljs-number">1000L</span> &lt; System</span><br><span class="line">.currentTimeMillis()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RememberMeAuthenticationException(<span class="hljs-string">"Remember-me login has expired"</span>);</span><br><span class="line">&#125;</span><br><span class="line">PersistentRememberMeToken newToken = <span class="hljs-keyword">new</span> PersistentRememberMeToken(</span><br><span class="line">token.getUsername(), token.getSeries(), generateTokenData(), <span class="hljs-keyword">new</span> Date());</span><br><span class="line">tokenRepository.updateToken(newToken.getSeries(), newToken.getTokenValue(),</span><br><span class="line">newToken.getDate());</span><br><span class="line">addCookie(newToken, request, response);</span><br><span class="line"><span class="hljs-keyword">return</span> getUserDetailsService().loadUserByUsername(token.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段逻辑也比较简单：</p><ol><li>首先从前端传来的 cookie 中解析出 series 和 token。</li><li>根据 series 从数据库中查询出一个 PersistentRememberMeToken 实例。</li><li>如果查出来的 token 和前端传来的 token 不相同，说明账号可能被人盗用（别人用你的令牌登录之后，token 会变）。此时根据用户名移除相关的 token，相当于必须要重新输入用户名密码登录才能获取新的自动登录权限。</li><li>接下来校验 token 是否过期。</li><li>构造新的 PersistentRememberMeToken 对象，并且更新数据库中的 token（这就是我们文章开头说的，新的会话都会对应一个新的 token）。</li><li>将新的令牌重新添加到 cookie 中返回。</li><li>根据用户名查询用户信息，再走一波登录流程。</li></ol><p>OK，这里和小伙伴们简单理了一下令牌生成和校验的过程，具体的流程，大家可以参考<a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">上篇文章</a>。</p><h2 id="2-二次校验"><a href="#2-二次校验" class="headerlink" title="2.二次校验"></a>2.二次校验</h2><p>相比于<a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">上篇文章</a>，持久化令牌的方式其实已经安全很多了，但是依然存在用户身份被盗用的问题，这个问题实际上很难完美解决，我们能做的，只能是当发生用户身份被盗用这样的事情时，将损失降低到最小。</p><p>因此，我们来看下另一种方案，就是二次校验。</p><p>二次校验这块，实现起来要稍微复杂一点，我先来和大家说说思路。</p><p>为了让用户使用方便，我们开通了自动登录功能，但是自动登录功能又带来了安全风险，一个规避的办法就是如果用户使用了自动登录功能，我们可以只让他做一些常规的不敏感操作，例如数据浏览、查看，但是不允许他做任何修改、删除操作，如果用户点击了修改、删除按钮，我们可以跳转回登录页面，让用户重新输入密码确认身份，然后再允许他执行敏感操作。</p><p>这个功能在 Shiro 中有一个比较方便的过滤器可以配置，Spring Security 当然也一样，例如我现在提供三个访问接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/rememberme"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">rememberme</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"rememberme"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一个 /hello 接口，只要认证后就可以访问，无论是通过用户名密码认证还是通过自动登录认证，只要认证了，就可以访问。</li><li>第二个 /admin 接口，必须要用户名密码认证之后才能访问，如果用户是通过自动登录认证的，则必须重新输入用户名密码才能访问该接口。</li><li>第三个 /rememberme 接口，必须是通过自动登录认证后才能访问，如果用户是通过用户名/密码认证的，则无法访问该接口。</li></ol><p>好了，我们来看下接口的访问要怎么配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/rememberme"</span>).rememberMe()</span><br><span class="line">            .antMatchers(<span class="hljs-string">"/admin"</span>).fullyAuthenticated()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .rememberMe()</span><br><span class="line">            .key(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .tokenRepository(jdbcTokenRepository())</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>/rememberme 接口是需要 rememberMe 才能访问。</li><li>/admin 是需要 fullyAuthenticated，fullyAuthenticated 不同于 authenticated，fullyAuthenticated 不包含自动登录的形式，而 authenticated 包含自动登录的形式。</li><li>最后剩余的接口（/hello）都是 authenticated 就能访问。</li></ol><p>OK，配置完成后，重启测试，测试过程我就不再赘述了。</p><p>好了，今天从两个方面和小伙伴们分享了在 Spring Boot 自动登录中，如何降低系统风险，感兴趣的小伙伴赶快试一把吧～记得给松哥点个在看鼓励下哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上篇文章&lt;/a&gt;中，我们提到了 Spring Boot 自动登录存在的一些安全风险，在实际应用中，我们肯定要把这些安全风险降到最低，今天就来和大家聊一聊如何降低安全风险的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot + Spring Security 实现自动登录功能</title>
    <link href="http://www.javaboy.org/2020/0428/rememberme.html"/>
    <id>http://www.javaboy.org/2020/0428/rememberme.html</id>
    <published>2020-04-28T12:33:11.000Z</published>
    <updated>2020-05-10T12:57:55.163Z</updated>
    
    <content type="html"><![CDATA[<p>自动登录是我们在软件开发时一个非常常见的功能，例如我们登录 QQ 邮箱：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/04/security-8-1.png" alt></p><p>很多网站我们在登录的时候都会看到类似的选项，毕竟总让用户输入用户名密码是一件很麻烦的事。</p><p>自动登录功能就是，用户在登录成功后，在某一段时间内，如果用户关闭了浏览器并重新打开，或者服务器重启了，都不需要用户重新登录了，用户依然可以直接访问接口数据。</p><p>作为一个常见的功能，我们的 Spring Security 肯定也提供了相应的支持，本文我们就来看下 Spring Security 中如何实现这个功能。</p><p>本文是松哥最近在连载的 Spring Security 系列第 8 篇，阅读本系列前面的文章可以更好的理解本文（如果大家对松哥录制的 Spring Security 视频感兴趣，也可以看看这里：<a href="https://mp.weixin.qq.com/s/1k4CZ6_re11fQM_6_00jCw" target="_blank" rel="noopener">SpringBoot+Vue+微人事视频教程</a>）：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li></ol><p>这个功能实现起来简单，但是还是会涉及到很多细节，所以我会分两篇文章来逐一介绍，本文是第一篇。</p><h2 id="1-实战代码"><a href="#1-实战代码" class="headerlink" title="1.实战代码"></a>1.实战代码</h2><p>首先，要实现记住我这个功能，其实只需要其实只需要在 Spring Security 的配置中，添加如下代码即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .rememberMe()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到，这里只需要添加一个 <code>.rememberMe()</code> 即可，自动登录功能就成功添加进来了。</p><p>接下来我们随意添加一个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目，我们访问 hello 接口，此时会自动跳转到登录页面：</p><p><img src="http://img.itboyhub.com/2020/04/security-8-2.png" alt></p><p>这个时候大家发现，默认的登录页面多了一个选项，就是记住我。我们输入用户名密码，并且勾选上记住我这个框，然后点击登录按钮执行登录操作：</p><p><img src="http://img.itboyhub.com/2020/04/20200426174808.png" alt></p><p>可以看到，登录数据中，除了 username 和 password 之外，还有一个 remember-me，之所以给大家看这个，是想告诉大家，如果你你需要自定义登录页面，RememberMe 这个选项的 key 该怎么写。</p><p>登录成功之后，就会自动跳转到 hello 接口了。我们注意，系统访问 hello 接口的时候，携带的 cookie：</p><p><img src="http://img.itboyhub.com/2020/04/20200426175634.png" alt></p><p>大家注意到，这里多了一个 remember-me，这就是这里实现的核心，关于这个 remember-me 我一会解释，我们先来测试效果。</p><p>接下来，我们关闭浏览器，再重新打开浏览器。正常情况下，浏览器关闭再重新打开，如果需要再次访问 hello 接口，就需要我们重新登录了。但是此时，我们再去访问 hello 接口，发现不用重新登录了，直接就能访问到，这就说明我们的 RememberMe 配置生效了（即下次自动登录功能生效了）。</p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2.原理分析"></a>2.原理分析</h2><p>按理说，浏览器关闭再重新打开，就要重新登录，现在竟然不用等了，那么这个功能到底是怎么实现的呢？</p><p>首先我们来分析一下 cookie 中多出来的这个 remember-me，这个值一看就是一个 Base64 转码后的字符串，我们可以使用网上的一些在线工具来解码，可以自己简单写两行代码来解码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    String s = <span class="hljs-keyword">new</span> String(Base64.getDecoder().decode(<span class="hljs-string">"amF2YWJveToxNTg5MTA0MDU1MzczOjI1NzhmZmJjMjY0ODVjNTM0YTJlZjkyOWFjMmVmYzQ3"</span>), <span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    System.out.println(<span class="hljs-string">"s = "</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这段代码，输出结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = javaboy:1589104055373:2578ffbc26485c534a2ef929ac2efc47</span><br></pre></td></tr></table></figure><p>可以看到，这段 Base64 字符串实际上用 <code>:</code> 隔开，分成了三部分：</p><ol><li>第一段是用户名，这个无需质疑。</li><li>第二段看起来是一个时间戳，我们通过在线工具或者 Java 代码解析后发现，这是一个两周后的数据。</li><li>第三段我就不卖关子了，这是使用 MD5 散列函数算出来的值，他的明文格式是 <code>username + &quot;:&quot; + tokenExpiryTime + &quot;:&quot; + password + &quot;:&quot; + key</code>，最后的 key 是一个散列盐值，可以用来防治令牌被修改。</li></ol><p>了解到 cookie 中 remember-me 的含义之后，那么我们对于记住我的登录流程也就很容易猜到了了。</p><p>在浏览器关闭后，并重新打开之后，用户再去访问 hello 接口，此时会携带着 cookie 中的 remember-me 到服务端，服务到拿到值之后，可以方便的计算出用户名和过期时间，再根据用户名查询到用户密码，然后通过 MD5 散列函数计算出散列值，再将计算出的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效。</p><p>流程就是这么个流程，接下来我们通过分析源码来验证一下这个流程对不对。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><p>接下来，我们通过源码来验证一下我们上面说的对不对。</p><p>这里主要从两个方面来介绍，一个是 remember-me 这个令牌生成的过程，另一个则是它解析的过程。</p><h3 id="3-1-生成"><a href="#3-1-生成" class="headerlink" title="3.1 生成"></a>3.1 生成</h3><p>生成的核心处理方法在：<code>TokenBasedRememberMeServices#onLoginSuccess</code>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoginSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Authentication successfulAuthentication)</span> </span>&#123;</span><br><span class="line">String username = retrieveUserName(successfulAuthentication);</span><br><span class="line">String password = retrievePassword(successfulAuthentication);</span><br><span class="line"><span class="hljs-keyword">if</span> (!StringUtils.hasLength(password)) &#123;</span><br><span class="line">UserDetails user = getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">password = user.getPassword();</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> tokenLifetime = calculateLoginLifetime(request, successfulAuthentication);</span><br><span class="line"><span class="hljs-keyword">long</span> expiryTime = System.currentTimeMillis();</span><br><span class="line">expiryTime += <span class="hljs-number">1000L</span> * (tokenLifetime &lt; <span class="hljs-number">0</span> ? TWO_WEEKS_S : tokenLifetime);</span><br><span class="line">String signatureValue = makeTokenSignature(expiryTime, username, password);</span><br><span class="line">setCookie(<span class="hljs-keyword">new</span> String[] &#123; username, Long.toString(expiryTime), signatureValue &#125;,</span><br><span class="line">tokenLifetime, request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">makeTokenSignature</span><span class="hljs-params">(<span class="hljs-keyword">long</span> tokenExpiryTime, String username,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">String password)</span> </span>&#123;</span><br><span class="line">String data = username + <span class="hljs-string">":"</span> + tokenExpiryTime + <span class="hljs-string">":"</span> + password + <span class="hljs-string">":"</span> + getKey();</span><br><span class="line">MessageDigest digest;</span><br><span class="line">digest = MessageDigest.getInstance(<span class="hljs-string">"MD5"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(Hex.encode(digest.digest(data.getBytes())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段方法的逻辑其实很好理解：</p><ol><li>首先从登录成功的 Authentication 中提取出用户名/密码。</li><li>由于登录成功之后，密码可能被擦除了，所以，如果一开始没有拿到密码，就再从 UserDetailsService 中重新加载用户并重新获取密码。</li><li>再接下来去获取令牌的有效期，令牌有效期默认就是两周。</li><li>再接下来调用 makeTokenSignature 方法去计算散列值，实际上就是根据 username、令牌有效期以及 password、key 一起计算一个散列值。如果我们没有自己去设置这个 key，默认是在 RememberMeConfigurer#getKey 方法中进行设置的，它的值是一个 UUID 字符串。</li><li>最后，将用户名、令牌有效期以及计算得到的散列值放入 Cookie 中。</li></ol><p>关于第四点，我这里再说一下。</p><p>由于我们自己没有设置 key，key 默认值是一个 UUID 字符串，这样会带来一个问题，就是如果服务端重启，这个 key 会变，这样就导致之前派发出去的所有 remember-me 自动登录令牌失效，所以，我们可以指定这个 key。指定方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .rememberMe()</span><br><span class="line">            .key(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果自己配置了 key，<strong>即使服务端重启，即使浏览器打开再关闭</strong>，也依然能够访问到 hello 接口。</p><p>这是 remember-me 令牌生成的过程。至于是如何走到 onLoginSuccess 方法的，大家可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/z6GeR5O-vBzY3SHehmccVA" target="_blank" rel="noopener">松哥手把手带你捋一遍 Spring Security 登录流程</a>。这里可以给大家稍微提醒一下思路：</p><p>AbstractAuthenticationProcessingFilter#doFilter -&gt; AbstractAuthenticationProcessingFilter#successfulAuthentication -&gt; AbstractRememberMeServices#loginSuccess -&gt; TokenBasedRememberMeServices#onLoginSuccess。</p><h3 id="3-2-解析"><a href="#3-2-解析" class="headerlink" title="3.2 解析"></a>3.2 解析</h3><p>那么当用户关掉并打开浏览器之后，重新访问 /hello 接口，此时的认证流程又是怎么样的呢？</p><p>我们之前说过，Spring Security 中的一系列功能都是通过一个过滤器链实现的，RememberMe 这个功能当然也不例外。</p><p>Spring Security 中提供了 RememberMeAuthenticationFilter 类专门用来做相关的事情，我们来看下 RememberMeAuthenticationFilter 的 doFilter 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line"><span class="hljs-keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">Authentication rememberMeAuth = rememberMeServices.autoLogin(request,</span><br><span class="line">response);</span><br><span class="line"><span class="hljs-keyword">if</span> (rememberMeAuth != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">rememberMeAuth = authenticationManager.authenticate(rememberMeAuth);</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(rememberMeAuth);</span><br><span class="line">onSuccessfulAuthentication(request, response, rememberMeAuth);</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">eventPublisher</span><br><span class="line">.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(</span><br><span class="line">SecurityContextHolder.getContext()</span><br><span class="line">.getAuthentication(), <span class="hljs-keyword">this</span>.getClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (successHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">successHandler.onAuthenticationSuccess(request, response,</span><br><span class="line">rememberMeAuth);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，就是在这里实现的。</p><p>这个方法最关键的地方在于，如果从 SecurityContextHolder 中无法获取到当前登录用户实例，那么就调用 rememberMeServices.autoLogin 逻辑进行登录，我们来看下这个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Authentication <span class="hljs-title">autoLogin</span><span class="hljs-params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">String rememberMeCookie = extractRememberMeCookie(request);</span><br><span class="line"><span class="hljs-keyword">if</span> (rememberMeCookie == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">logger.debug(<span class="hljs-string">"Remember-me cookie detected"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (rememberMeCookie.length() == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Cookie was empty"</span>);</span><br><span class="line">cancelCookie(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">UserDetails user = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">String[] cookieTokens = decodeCookie(rememberMeCookie);</span><br><span class="line">user = processAutoLoginCookie(cookieTokens, request, response);</span><br><span class="line">userDetailsChecker.check(user);</span><br><span class="line">logger.debug(<span class="hljs-string">"Remember-me cookie accepted"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> createSuccessfulAuthentication(request, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (CookieTheftException cte) &#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">throw</span> cte;</span><br><span class="line">&#125;</span><br><span class="line">cancelCookie(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里就是提取出 cookie 信息，并对 cookie 信息进行解码，解码之后，再调用 processAutoLoginCookie 方法去做校验，processAutoLoginCookie 方法的代码我就不贴了，核心流程就是首先获取用户名和过期时间，再根据用户名查询到用户密码，然后通过 MD5 散列函数计算出散列值，再将拿到的散列值和浏览器传递来的散列值进行对比，就能确认这个令牌是否有效，进而确认登录是否有效。</p><p>好了，这里的流程我也根据大家大致上梳理了一下。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>看了上面的文章，大家可能已经发现，如果我们开启了 RememberMe 功能，最最核心的东西就是放在 cookie 中的令牌了，这个令牌突破了 session 的限制，即使服务器重启、即使浏览器关闭又重新打开，只要这个令牌没有过期，就能访问到数据。</p><p>一旦令牌丢失，别人就可以拿着这个令牌随意登录我们的系统了，这是一个非常危险的操作。</p><p>但是实际上这是一段悖论，为了提高用户体验（少登录），我们的系统不可避免的引出了一些安全问题，不过我们可以通过技术将安全风险降低到最小。</p><p>那么如何让我们的 RememberMe 功能更加安全呢？松哥下篇文章来和大家继续分享–持久化令牌方案。</p><p>小伙伴们要是觉得看懂了，不妨点个在看鼓励下松哥～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动登录是我们在软件开发时一个非常常见的功能，例如我们登录 QQ 邮箱：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+OAuth2，如何自定义返回的 Token 信息？</title>
    <link href="http://www.javaboy.org/2020/0427/custom-token-info.html"/>
    <id>http://www.javaboy.org/2020/0427/custom-token-info.html</id>
    <published>2020-04-27T12:32:55.000Z</published>
    <updated>2020-05-10T12:57:50.279Z</updated>
    
    <content type="html"><![CDATA[<p>在本系列前面的文章中，正常情况下，OAuth2 返回的 access_token 信息一共包含五项：</p><p>分别是：</p><ul><li>access_token</li><li>token_type</li><li>refresh_token</li><li>expires_in</li><li>scope</li></ul><a id="more"></a><p>具体如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"b9c9e345-90c9-49f5-80ab-6ce5ed5a07c9"</span>,</span><br><span class="line">    <span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,</span><br><span class="line">    <span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string">"9f843e0e-1778-495d-859a-52a1a806c150"</span>,</span><br><span class="line">    <span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">7199</span>,</span><br><span class="line">    <span class="hljs-attr">"scope"</span>: <span class="hljs-string">"seller-auth"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在实际操作中，我们往往需要在这个基础上，定制自己的返回信息，这就需要我们对这个东西进行自定义。本文松哥就来和大家聊一聊这里要如何自定义。</p><p><strong>敲黑板划重点：</strong> 本文还是我们最近 OAuth2 系列的延续，如果没看过本系列之前的文章，一定先阅读一下，这有助于更好的理解本文：</p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li><li><a href="https://mp.weixin.qq.com/s/aOXsHSPowmR2zLkF41wPlQ" target="_blank" rel="noopener">最近在做 Spring Cloud 项目，松哥和大家分享一点微服务架构中的安全管理思路</a></li><li><a href="https://mp.weixin.qq.com/s/EyAMTbKPqNNnEtZACIsMVw" target="_blank" rel="noopener">Spring Boot+OAuth2，一个注解搞定单点登录！</a></li><li><a href="https://mp.weixin.qq.com/s/tq4Q306J3hJFEtGL1EpOBA" target="_blank" rel="noopener">分分钟让自己的网站接入 GitHub 第三方登录功能</a></li></ol><p>好了，不废话了，我们来看今天的内容。</p><h2 id="1-access-token-从哪里来"><a href="#1-access-token-从哪里来" class="headerlink" title="1.access_token 从哪里来"></a>1.access_token 从哪里来</h2><p>首先我们要搞清楚，access_token 从哪里来。</p><p>在前面的文章中，我们在生成 access_token 的时候，都配置了一个类，叫做 AuthorizationServerTokenServices，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">AuthorizationServerTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    DefaultTokenServices services = <span class="hljs-keyword">new</span> DefaultTokenServices();</span><br><span class="line">    services.setClientDetailsService(clientDetailsService());</span><br><span class="line">    services.setSupportRefreshToken(<span class="hljs-keyword">true</span>);</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    TokenEnhancerChain chain = <span class="hljs-keyword">new</span> TokenEnhancerChain();</span><br><span class="line">    chain.setTokenEnhancers(Arrays.asList(jwtAccessTokenConverter,externalAccessTokenInfo));</span><br><span class="line">    services.setTokenEnhancer(chain);</span><br><span class="line">    <span class="hljs-keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置中，我们提供了一个 DefaultTokenServices 实例，这个实例就是默认生成 access_token 的工具，我们进入到 DefaultTokenServices#createAccessToken 方法中，一路追踪，可以看到如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication, OAuth2RefreshToken refreshToken)</span> </span>&#123;</span><br><span class="line">DefaultOAuth2AccessToken token = <span class="hljs-keyword">new</span> DefaultOAuth2AccessToken(UUID.randomUUID().toString());</span><br><span class="line"><span class="hljs-keyword">int</span> validitySeconds = getAccessTokenValiditySeconds(authentication.getOAuth2Request());</span><br><span class="line"><span class="hljs-keyword">if</span> (validitySeconds &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">token.setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + (validitySeconds * <span class="hljs-number">1000L</span>)));</span><br><span class="line">&#125;</span><br><span class="line">token.setRefreshToken(refreshToken);</span><br><span class="line">token.setScope(authentication.getOAuth2Request().getScope());</span><br><span class="line"><span class="hljs-keyword">return</span> accessTokenEnhancer != <span class="hljs-keyword">null</span> ? accessTokenEnhancer.enhance(token, authentication) : token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，我们可以看到，用来保存 access_token 的实例，其实就是 DefaultOAuth2AccessToken，我们再来看看 DefaultOAuth2AccessToken 的定义：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultOAuth2AccessToken implements Serializable, OAuth2AccessToken &#123;</span><br><span class="line">private String value;</span><br><span class="line">private Date expiration;</span><br><span class="line">private String tokenType = BEARER_TYPE.toLowerCase();</span><br><span class="line">private OAuth2RefreshToken refreshToken;</span><br><span class="line">private Set&lt;String&gt; scope;</span><br><span class="line">private Map&lt;String, Object&gt; additionalInformation = Collections.emptyMap();</span><br><span class="line">    //省略其他</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段属性的声明中，我们就可以看出来，为什么默认返回的数据只有五项。</p><p>大家同时也发现，DefaultOAuth2AccessToken 中其实是提供了一个 additionalInformation 属性用来存储额外信息的，但是，我们在 DefaultTokenServices 类中并没有办法去自定义 DefaultOAuth2AccessToken 中的属性，也就是说，默认情况下，我们没有办法自己去给 additionalInformation 中添加值。</p><p>虽然默认情况下，无法添加，但是只要大家看了上面这段源码，就会明白，如果我们想要自定义返回的 access_token 信息，就要想办法自已去定义 DefaultOAuth2AccessToken 信息。</p><p>思路有了，接下来看操作。</p><h2 id="2-两种定制方案"><a href="#2-两种定制方案" class="headerlink" title="2.两种定制方案"></a>2.两种定制方案</h2><p>大家知道，我们在 OAuth2 中返回的令牌信息分为两大类：不透明令牌和透明令牌。</p><p>不透明令牌就是一种无可读性的令牌，一般来说就是一段普通的 UUID 字符串。不透明令牌的最大问题在于会降低系统性能和可用性，并且增加延迟（因为必须远程校验令牌）。</p><p>透明令牌的典型代表就是 JWT 了，用户信息都保存在 JWT 字符串中，关于 JWT 的信息，大家可以参考这篇文章：<a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a>。</p><p>在实际开发中，大部分情况下，我们的 OAuth2 都是搭配 JWT 一起来使用的，所以，这里我就主要讲一下在生成的 JWT 中如何定制返回信息。</p><p>如果我们使用了 OAuth2+JWT 的方案，那正常情况下，我们还需要配置一个 JwtAccessTokenConverter 的实例（参考：<a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a>），JWT 字符串将由 JwtAccessTokenConverter 实例负责生成。</p><p>JwtAccessTokenConverter 实例生成 JWT 的方法是在上文列出来的 DefaultTokenServices#createAccessToken 方法之后执行，该方法最后有一句：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accessTokenEnhancer != <span class="hljs-keyword">null</span> ? accessTokenEnhancer.enhance(token, authentication) : token;</span><br></pre></td></tr></table></figure><p>这就是说，如果提供了 accessTokenEnhancer ，就进入到 accessTokenEnhancer 的 enhance 方法中对 access_token 做二次处理，accessTokenEnhancer 则就是我们的 JwtAccessTokenConverter 实例。</p><p>从这里大家看到，想要自定义 Token 信息，我们有两个时机，第一个时机就是在 DefaultTokenServices#createAccessToken 方法中修改，但是工作量较大，不推荐；第二个时机是在进入到 JwtAccessTokenConverter#enhance 方法之后修改，这是目前比较可行的方法。</p><p>如果采用第二种方案，就需要我们自定义一个类继承自 JwtAccessTokenConverter，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyJwt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JwtAccessTokenConverter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">enhance</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; additionalInformation = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Object&gt; info = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        info.put(<span class="hljs-string">"author"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">        info.put(<span class="hljs-string">"email"</span>, <span class="hljs-string">"wangsong0210@gmail.com"</span>);</span><br><span class="line">        info.put(<span class="hljs-string">"site"</span>, <span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        info.put(<span class="hljs-string">"weixin"</span>, <span class="hljs-string">"a_java_boy2"</span>);</span><br><span class="line">        info.put(<span class="hljs-string">"WeChat Official Accounts"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">        info.put(<span class="hljs-string">"GitHub"</span>, <span class="hljs-string">"https://github.com/lenve"</span>);</span><br><span class="line">        info.put(<span class="hljs-string">"user"</span>, SecurityContextHolder.getContext().getAuthentication().getPrincipal());</span><br><span class="line">        additionalInformation.put(<span class="hljs-string">"info"</span>, info);</span><br><span class="line">        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInformation);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.enhance(accessToken, authentication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们自定义 MyJwt 继承自 JwtAccessTokenConverter 并重写 enhance 方法：</p><ol><li>首先我们构造自己的附加信息，如果如需要当前登录用户信息，可以从 SecurityContextHolder 中获取。</li><li>将附加信息放到 OAuth2AccessToken 的 additionalInformation 属性中去。</li></ol><p>这样相当于我们就修改了默认生成的 DefaultOAuth2AccessToken 了，然后再把修改后的 DefaultOAuth2AccessToken 实例调用 super.enhance 方法去生成 jwt 字符串，这样生成的 jwt 字符串就有我们的自定义信息了。</p><p>最后，在 TokenConfig 中配置 MyJwt 的实例，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = <span class="hljs-keyword">new</span> MyJwt();</span><br><span class="line">        converter.setSigningKey(<span class="hljs-string">"www.javaboy.org"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，其他地方的代码不变（参考：<a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a>），我们启动项目来生成登录的 access_token 信息。</p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3.测试"></a>3.测试</h2><p>接下来，我们启动项目进行测试：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-9-1.png" alt></p><p>可以看到，此时生成的 jwt 字符串就比较长了，我们将 access_token 拿到 /oauth/check_token 去校验一下就知道生成的具体信息了，如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-9-2.png" alt></p><p>可以看到，我们已经成功的将自定义信息存入 jwt 字符串中了。</p><p>当然，还有一种情况就是你可能只是想在调用 /oauth/token 接口的时候添加一些额外信息，并不想将额外信息添加到 jwt 中，就是下面这种效果：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-9-3.png" alt></p><p>这种效果，可以参考松哥之前文章的写法：<a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a>。</p><h2 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4.扩展"></a>4.扩展</h2><p>好了，前面虽然跟大家分享的是 OAuth2+JWT 如何生成自定义的 access_token 信息，但是相信大家看完之后，应该也会针对不透明令牌生成自定义信息。</p><p>我这里也和大家分享一下思路：</p><p>上面代码的核心思路，就是在从 DefaultTokenServices#createAccessToken 方法到 JwtAccessTokenConverter#enhance 方法的过程中，给 DefaultOAuth2AccessToken 对象的 additionalInformation 属性添加了附加信息。</p><p>而 JwtAccessTokenConverter 是 TokenEnhancer 的实例，所以如果我们想要定制不透明令牌的信息，只需要自己定义类实现 TokenEnhancer 接口，并且在 enhance 方法中添加附加信息即可。这个思路给大家，小伙伴们可以自行尝试一下。</p><p>好了，今天就和大家分享这么多。如果觉得有收获，记得点个在看鼓励下松哥哦～</p><p>最后再说一下，如果你觉得阅读本文有些吃力，一定阅读一下本系列前面的文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本系列前面的文章中，正常情况下，OAuth2 返回的 access_token 信息一共包含五项：&lt;/p&gt;
&lt;p&gt;分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;access_token&lt;/li&gt;
&lt;li&gt;token_type&lt;/li&gt;
&lt;li&gt;refresh_token&lt;/li&gt;
&lt;li&gt;expires_in&lt;/li&gt;
&lt;li&gt;scope&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>分分钟让自己的网站接入 GitHub 第三方登录功能</title>
    <link href="http://www.javaboy.org/2020/0424/github-oauth2.html"/>
    <id>http://www.javaboy.org/2020/0424/github-oauth2.html</id>
    <published>2020-04-24T12:32:32.000Z</published>
    <updated>2020-05-10T12:57:38.691Z</updated>
    
    <content type="html"><![CDATA[<p>OAuth2 和小伙伴们已经聊了很多了，咱们来一个实际点的案例练练手。</p><p>这里我才用 GitHub 来做第三方登录。</p><p>为什么是 GitHub 呢？有两方面考虑：</p><a id="more"></a><ol><li>程序员基本上都有 GitHub 账号，测试方便。</li><li>国内的无论 QQ、微信、微博等，都需要注册审核，很费时间。</li><li>流程都是一样的，会做 GitHub 第三方登录，就会做 QQ 第三方登录。</li></ol><p>当然，本系列前面几篇文章还是建议小伙伴们先看一下，这样可以更好的理解本文。</p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li><li><a href="https://mp.weixin.qq.com/s/aOXsHSPowmR2zLkF41wPlQ" target="_blank" rel="noopener">最近在做 Spring Cloud 项目，松哥和大家分享一点微服务架构中的安全管理思路</a></li><li><a href="https://mp.weixin.qq.com/s/EyAMTbKPqNNnEtZACIsMVw" target="_blank" rel="noopener">Spring Boot+OAuth2，一个注解搞定单点登录！</a></li></ol><p>好了，不废话，我们开始今天的案例。</p><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>首先登录自己的 GitHub 账户，右上角点击个人面板，选择 Settings：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-7-1.png" alt></p><p>然后点击左边菜单底部的 Developer settings：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-7-2.png" alt></p><p>然后选择 OAuth Apps，点击 Register a new application 按钮：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-7-3.png" alt></p><p>接下来注册你的应用信息</p><p><img src="http://img.itboyhub.com/2020/04/oauth-7-4-1.png" alt></p><p>从上往下，依次是你的项目名称、首页地址、项目描述、授权成功回调地址。信息填完之后，点击下方的 Register application 按钮完成注册。</p><p>注册完成之后，我们就可以获取到一个 Client ID 和一个 Client Secret，这就是我们登录时客户端的凭据。</p><p><img src="http://img.itboyhub.com/2020/04/oauth-7-5-1.png" alt></p><p>这两个信息保存好，不要外泄。</p><p>写到这里，松哥不由得感叹一句，还是国外的应用香啊，用 GitHub 做第三方登录，一分钟不到，准备工作就完成了，用 QQ 做，我的资料已经提交两天了，目前的状态还是审核中。。。不过我也理解腾讯所面临的监管问题。</p><h2 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2.创建应用"></a>2.创建应用</h2><p>接下来我们来简单创建一个自己的网站，我们依然使用 Spring Boot 项目，添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-7-6.png" alt></p><p>然后我们在 resources/templates 目录下创建一个简单的 index.html:</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello 欢迎来到江南一点雨的小站！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    社交账号登录：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://github.com/login/oauth/authorize?client_id=xxxxxx&amp;state=javaboy"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">t</span>=<span class="hljs-string">"1587352912571"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 1024 1024"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.1"</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span></span></span><br><span class="line"><span class="hljs-tag">             <span class="hljs-attr">p-id</span>=<span class="hljs-string">"2196"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"32"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"32"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">"M512 42.666667A464.64 464.64 0 0 0 42.666667 502.186667 460.373333 460.373333 0 0 0 363.52 938.666667c23.466667 4.266667 32-9.813333 32-22.186667v-78.08c-130.56 27.733333-158.293333-61.44-158.293333-61.44a122.026667 122.026667 0 0 0-52.053334-67.413333c-42.666667-28.16 3.413333-27.733333 3.413334-27.733334a98.56 98.56 0 0 1 71.68 47.36 101.12 101.12 0 0 0 136.533333 37.973334 99.413333 99.413333 0 0 1 29.866667-61.44c-104.106667-11.52-213.333333-50.773333-213.333334-226.986667a177.066667 177.066667 0 0 1 47.36-124.16 161.28 161.28 0 0 1 4.693334-121.173333s39.68-12.373333 128 46.933333a455.68 455.68 0 0 1 234.666666 0c89.6-59.306667 128-46.933333 128-46.933333a161.28 161.28 0 0 1 4.693334 121.173333A177.066667 177.066667 0 0 1 810.666667 477.866667c0 176.64-110.08 215.466667-213.333334 226.986666a106.666667 106.666667 0 0 1 32 85.333334v125.866666c0 14.933333 8.533333 26.88 32 22.186667A460.8 460.8 0 0 0 981.333333 502.186667 464.64 464.64 0 0 0 512 42.666667"</span></span></span><br><span class="line"><span class="hljs-tag">                  <span class="hljs-attr">fill</span>=<span class="hljs-string">"#2c2c2c"</span> <span class="hljs-attr">p-id</span>=<span class="hljs-string">"2197"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>国际站：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.javaboy.org"</span>&gt;</span>javaboy.org<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>国内站：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.itboyhub.com"</span>&gt;</span>itboyhub.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就是一个简单的 HTML 页面，页面上有一个 GitHub 的图标，点击这个图标，就可以去 GitHub 上完成授权操作，注意授权的链接如下：</p><ul><li><a href="https://github.com/login/oauth/authorize" target="_blank" rel="noopener">https://github.com/login/oauth/authorize</a></li></ul><p>这个授权需要携带一个 client_id 参数，这个 client_id 就是准备工作中获取到的 client_id，另外一个 state 则是用来防止跨站脚本攻击的，state 参数的值可以自己随意填写。</p><p>我们来看下页面的效果图：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-7-7.png" alt></p><p>当我们点击 GitHub 图标，完成授权操作之后，会自动跳转到我们在准备工作填的回调地址中，并且携带一个 code 参数，拿着这个 code 参数我们就可以去获取 access_token 了，有了 access_token 我们就可以获取到用户信息了。</p><p>因此，我们再来添加一个 /authorization_code 接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/authorization_code"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">authorization_code</span><span class="hljs-params">(String code)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"xxx"</span>);</span><br><span class="line">    map.put(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"xxxx"</span>);</span><br><span class="line">    map.put(<span class="hljs-string">"state"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    map.put(<span class="hljs-string">"code"</span>, code);</span><br><span class="line">    map.put(<span class="hljs-string">"redirect_uri"</span>, <span class="hljs-string">"http://localhost:8080/authorization_code"</span>);</span><br><span class="line">    Map&lt;String,String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"https://github.com/login/oauth/access_token"</span>, map, Map.class);</span><br><span class="line">    System.out.println(resp);</span><br><span class="line">    HttpHeaders httpheaders = <span class="hljs-keyword">new</span> HttpHeaders();</span><br><span class="line">    httpheaders.add(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"token "</span> + resp.get(<span class="hljs-string">"access_token"</span>));</span><br><span class="line">    HttpEntity&lt;?&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(httpheaders);</span><br><span class="line">    ResponseEntity&lt;Map&gt; exchange = restTemplate.exchange(<span class="hljs-string">"https://api.github.com/user"</span>, HttpMethod.GET, httpEntity, Map.class);</span><br><span class="line">    System.out.println(<span class="hljs-string">"exchange.getBody() = "</span> + exchange.getBody());</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/index.html"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 authorization_code 接口中，我们首先向 <a href="http://localhost:8080/authorization_code" target="_blank" rel="noopener">http://localhost:8080/authorization_code</a> 发起请求去获取 access_token，注意我们需要的参数，client_id 和 client_secret 使我们第一步准备工作申请到的。获取到 access_token 的数据格式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;access_token=9f33730ef09b74943a1cf7d8f9c0e567b9286829, token_type=bearer, scope=&#125;</span><br></pre></td></tr></table></figure><p>可以看到，有 access_token，有 token_type，也有 scope。</p><p>接下来，拿着 access_token ，将 access_token 放在请求头里边，我们就可以去调用 <a href="https://api.github.com/user" target="_blank" rel="noopener">https://api.github.com/user</a> 接口获取用户信息了，获取到的用户信息格式如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"login"</span>:<span class="hljs-string">"lenve"</span>,</span><br><span class="line">    <span class="hljs-attr">"id"</span>:<span class="hljs-number">35444368</span>,</span><br><span class="line">    <span class="hljs-attr">"node_id"</span>:<span class="hljs-string">"MDQ6VXNlcjM1NDQ0MzY4"</span>,</span><br><span class="line">    <span class="hljs-attr">"avatar_url"</span>:<span class="hljs-string">"https://avatars3.githubusercontent.com/u/35444368?v=4"</span>,</span><br><span class="line">    <span class="hljs-attr">"gravatar_id"</span>:<span class="hljs-string">""</span>,</span><br><span class="line">    <span class="hljs-attr">"url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve"</span>,</span><br><span class="line">    <span class="hljs-attr">"html_url"</span>:<span class="hljs-string">"https://github.com/lenve"</span>,</span><br><span class="line">    <span class="hljs-attr">"followers_url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve/followers"</span>,</span><br><span class="line">    <span class="hljs-attr">"following_url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve/following&#123;/other_user&#125;"</span>,</span><br><span class="line">    <span class="hljs-attr">"gists_url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">    <span class="hljs-attr">"starred_url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve/starred&#123;/owner&#125;&#123;/repo&#125;"</span>,</span><br><span class="line">    <span class="hljs-attr">"subscriptions_url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve/subscriptions"</span>,</span><br><span class="line">    <span class="hljs-attr">"organizations_url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve/orgs"</span>,</span><br><span class="line">    <span class="hljs-attr">"repos_url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve/repos"</span>,</span><br><span class="line">    <span class="hljs-attr">"events_url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve/events&#123;/privacy&#125;"</span>,</span><br><span class="line">    <span class="hljs-attr">"received_events_url"</span>:<span class="hljs-string">"https://api.github.com/users/lenve/received_events"</span>,</span><br><span class="line">    <span class="hljs-attr">"type"</span>:<span class="hljs-string">"User"</span>,</span><br><span class="line">    <span class="hljs-attr">"site_admin"</span>:<span class="hljs-literal">false</span>,</span><br><span class="line">    <span class="hljs-attr">"name"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">    <span class="hljs-attr">"company"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">    <span class="hljs-attr">"blog"</span>:<span class="hljs-string">""</span>,</span><br><span class="line">    <span class="hljs-attr">"location"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">    <span class="hljs-attr">"email"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">    <span class="hljs-attr">"hireable"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">    <span class="hljs-attr">"bio"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">    <span class="hljs-attr">"public_repos"</span>:<span class="hljs-number">2</span>,</span><br><span class="line">    <span class="hljs-attr">"public_gists"</span>:<span class="hljs-number">0</span>,</span><br><span class="line">    <span class="hljs-attr">"followers"</span>:<span class="hljs-number">1</span>,</span><br><span class="line">    <span class="hljs-attr">"following"</span>:<span class="hljs-number">1</span>,</span><br><span class="line">    <span class="hljs-attr">"created_at"</span>:<span class="hljs-string">"2018-01-15T06:05:04Z"</span>,</span><br><span class="line">    <span class="hljs-attr">"updated_at"</span>:<span class="hljs-string">"2020-04-20T03:00:49Z"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，用户的 GitHub 信息现在已经获取到了，接下来该存数据库就存数据库，该接入自己的登录流程就接入。</p><p>如此之后，我们就完成了第三方登录功能，其实还是非常 Easy 的，只要大家把这个流程走通，以后想接入微信登录、QQ 登录，都将是非常容易的事情。</p><p>本文案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>好了，本文就先说这么多，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OAuth2 和小伙伴们已经聊了很多了，咱们来一个实际点的案例练练手。&lt;/p&gt;
&lt;p&gt;这里我才用 GitHub 来做第三方登录。&lt;/p&gt;
&lt;p&gt;为什么是 GitHub 呢？有两方面考虑：&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+OAuth2，一个注解搞定单点登录！</title>
    <link href="http://www.javaboy.org/2020/0423/oauth2-sso.html"/>
    <id>http://www.javaboy.org/2020/0423/oauth2-sso.html</id>
    <published>2020-04-23T09:18:23.000Z</published>
    <updated>2020-04-23T09:30:34.752Z</updated>
    
    <content type="html"><![CDATA[<p>需要先说一下，松哥最近写的教程，都是成系列的，有一些重复的东西写来写去就没意思了，所以每一篇文章都默认大家已经懂了前面的内容了，因此下文有任何看不懂的地方，建议一定先看下相关系列：</p><a id="more"></a><p><strong>Spring Security 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li></ol><p><strong>OAuth2 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li><li><a href="https://mp.weixin.qq.com/s/aOXsHSPowmR2zLkF41wPlQ" target="_blank" rel="noopener">和大家分享一点微服务架构中的安全管理思路</a></li></ol><p>好了，开始今天的正文。</p><p>单点登录是我们在分布式系统中很常见的一个需求。</p><p>分布式系统由多个不同的子系统组成，而我们在使用系统的时候，只需要登录一次即可，这样其他系统都认为用户已经登录了，不用再去登录。前面和小伙伴们分享了 OAuth2+JWT 的登录方式，这种无状态登录实际上天然的满足单点登录的需求，可以参考：<a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a>。</p><p>当然大家也都知道，无状态登录也是有弊端的。</p><p>所以今天松哥想和大家说一说 Spring Boot+OAuth2 做单点登录，利用 @EnableOAuth2Sso 注解快速实现单点登录功能。</p><p>松哥依然建议大家在阅读本文时，先看看本系列前面的文章，这有助于更好的理解本文。</p><h2 id="1-项目创建"><a href="#1-项目创建" class="headerlink" title="1.项目创建"></a>1.项目创建</h2><p>前面的案例中，松哥一直都把授权服务器和资源服务器分开创建，今天这个案例，为了省事，我就把授权服务器和资源服务器搭建在一起（不过相信大家看了前面的文章，应该也能自己把这两个服务器拆分开）。</p><p>所以，今天我们一共需要三个服务：</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">端口</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">auth-server</td><td style="text-align:left">1111</td><td style="text-align:left">授权服务器+资源服务器</td></tr><tr><td style="text-align:left">client1</td><td style="text-align:left">1112</td><td style="text-align:left">子系统1</td></tr><tr><td style="text-align:left">client2</td><td style="text-align:left">1113</td><td style="text-align:left">子系统2</td></tr></tbody></table><p>auth-server 用来扮演授权服务器+资源服务器的角色，client1 和 client2 则分别扮演子系统的角色，将来等 client1 登录成功之后，我们也就能访问 client2 了，这样就能看出来单点登录的效果。</p><p>我们创建一个名为 oauth2-sso 的 Maven 项目作为父工程即可。</p><h2 id="2-统一认证中心"><a href="#2-统一认证中心" class="headerlink" title="2.统一认证中心"></a>2.统一认证中心</h2><p>接下来我们来搭建统一认证中心。</p><p>首先我们创建一个名为 auth-server 的 module，创建时添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-1.png" alt></p><p>项目创建成功之后，这个模块由于要扮演授权服务器+资源服务器的角色，所以我们先在这个项目的启动类上添加 @EnableResourceServer 注解，表示这是一个资源服务器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootApplication</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AuthServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们进行授权服务器的配置，由于资源服务器和授权服务器合并在一起，因此授权服务器的配置要省事很多：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .secret(passwordEncoder.encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .autoApprove(<span class="hljs-keyword">true</span>)</span><br><span class="line">                .redirectUris(<span class="hljs-string">"http://localhost:1112/login"</span>, <span class="hljs-string">"http://localhost:1113/login"</span>)</span><br><span class="line">                .scopes(<span class="hljs-string">"user"</span>)</span><br><span class="line">                .accessTokenValiditySeconds(<span class="hljs-number">7200</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们只需要简单配置一下客户端的信息即可，这里的配置很简单，前面的文章也讲过了，大家要是不懂，可以参考本系列前面的文章：<a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a>。</p><p>当然这里为了简便，客户端的信息配置是基于内存的，如果大家想将客户端信息存入数据库中，也是可以的，参考：<a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></p><p>接下来我们再来配置 Spring Security：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@Order</span>(<span class="hljs-number">1</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(WebSecurity web)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        web.ignoring().antMatchers(<span class="hljs-string">"/login.html"</span>, <span class="hljs-string">"/css/**"</span>, <span class="hljs-string">"/js/**"</span>, <span class="hljs-string">"/images/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.requestMatchers()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/login"</span>)</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/oauth/authorize"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests().anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginPage(<span class="hljs-string">"/login.html"</span>)</span><br><span class="line">                .loginProcessingUrl(<span class="hljs-string">"/login"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"admin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 Spring Security 的配置，如果小伙伴们不懂，可以看看松哥最近正在连载的 Spring Security 系列。</p><p>我这里来大致捋一下：</p><ol><li>首先提供一个 BCryptPasswordEncoder 的实例，用来做密码加解密用。</li><li>由于我自定义了登录页面，所以在 WebSecurity 中对这些静态资源方形。</li><li>HttpSecurity 中，我们对认证相关的端点放行，同时配置一下登录页面和登录接口。</li><li>AuthenticationManagerBuilder 中提供一个基于内存的用户（小伙伴们可以根据 Spring Security 系列第 7 篇文章自行调整为从数据库加载）。</li><li>另外还有一个比较关键的地方，因为资源服务器和授权服务器在一起，所以我们需要一个 @Order 注解来提升 Spring Security 配置的优先级。</li></ol><p>SecurityConfig 和 AuthServerConfig 都是授权服务器需要提供的东西（如果小伙伴们想将授权服务器和资源服务器拆分，请留意这句话），接下来，我们还需要提供一个暴露用户信息的接口（如果将授权服务器和资源服务器分开，这个接口将由资源服务器提供）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Principal <span class="hljs-title">getCurrentUser</span><span class="hljs-params">(Principal principal)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> principal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们在 application.properties 中配置一下项目端口：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=1111</span><br></pre></td></tr></table></figure><p>另外，松哥自己提前准备了一个登录页面，如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-4.png" alt></p><p>将登录页面相关的 html、css、js 等拷贝到 resources/static 目录下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-3.png" alt></p><p>这个页面很简单，就是一个登录表单而已，我把核心部分列出来：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/login"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"name"</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"name"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"pass"</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"pass"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spin"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button login"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa fa-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意一下 action 提交地址不要写错即可。</p><p><strong>文末可以下载源码。</strong></p><p>如此之后，我们的统一认证登录平台就算是 OK 了。</p><h2 id="3-客户端创建"><a href="#3-客户端创建" class="headerlink" title="3.客户端创建"></a>3.客户端创建</h2><p>接下来我们来创建一个客户端项目，创建一个名为 client1 的 Spring Boot 项目，添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-1.png" alt></p><p>项目创建成功之后，我们来配置一下 Spring Security：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableOAuth</span>2Sso</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated().and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置很简单，就是说我们 client1 中所有的接口都需要认证之后才能访问，另外添加一个 @EnableOAuth2Sso 注解来开启单点登录功能。</p><p>接下来我们在 client1 中再来提供一个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="hljs-keyword">return</span> authentication.getName() + Arrays.toString(authentication.getAuthorities().toArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个测试接口返回当前登录用户的姓名和角色信息。</p><p>接下来我们需要在 client1 的 application.properties 中配置 oauth2 的相关信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">security.oauth2.client.client-secret=123</span><br><span class="line">security.oauth2.client.client-id=javaboy</span><br><span class="line">security.oauth2.client.user-authorization-uri=http://localhost:1111/oauth/authorize</span><br><span class="line">security.oauth2.client.access-token-uri=http://localhost:1111/oauth/token</span><br><span class="line">security.oauth2.resource.user-info-uri=http://localhost:1111/user</span><br><span class="line"></span><br><span class="line">server.port=1112</span><br><span class="line"></span><br><span class="line">server.servlet.session.cookie.name=s1</span><br></pre></td></tr></table></figure><p>这里的配置也比较熟悉，我们来看一下：</p><ol><li>client-secret 是客户端密码。</li><li>client-id 是客户端 id。</li><li>user-authorization-uri 是用户授权的端点。</li><li>access-token-uri 是获取令牌的端点。</li><li>user-info-uri 是获取用户信息的接口（从资源服务器上获取）。</li><li>最后再配置一下端口，然后给 cookie 取一个名字。</li></ol><p>如此之后，我们的 client1 就算是配置完成了。</p><p>按照相同的方式，我们再来配置一个 client2，client2 和 client1 一模一样，就是 cookie 的名字不同（随意取，不相同即可）。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>接下来，我们分别启动 auth-server、client1 和 client2，首先我们尝试去方式 client1 中的 hello 接口，这个时候会自动跳转到统一认证中心：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-4.png" alt></p><p>然后输入用户名密码进行登录。</p><p>登录成功之后，会自动跳转回 client1 的 hello 接口，如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-7.png" alt></p><p>此时我们再去访问 client2 ，发现也不用登录了，直接就可以访问：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-6-8.png" alt></p><p>OK，如此之后，我们的单点登录就成功了。</p><h2 id="5-流程解析"><a href="#5-流程解析" class="headerlink" title="5.流程解析"></a>5.流程解析</h2><p>最后，我再来和小伙伴们把上面代码的一个执行流程捋一捋：</p><ol><li>首先我们去访问 client1 的 /hello 接口，但是这个接口是需要登录才能访问的，因此我们的请求被拦截下来，拦截下来之后，系统会给我们重定向到 client1 的 /login 接口，这是让我们去登录。</li></ol><p><img src="http://img.itboyhub.com/2020/04/oauth-6-9.png" alt></p><ol start="2"><li>当我们去访问 client1 的登录接口时，由于我们配置了 @EnableOAuth2Sso 注解，这个操作会再次被拦截下来，单点登录拦截器会根据我们在 application.properties 中的配置，自动发起请求去获取授权码：</li></ol><p><img src="http://img.itboyhub.com/2020/04/oauth-6-10.png" alt></p><ol start="3"><li>在第二步发送的请求是请求 auth-server 服务上的东西，这次请求当然也避免不了要先登录，所以再次重定向到 auth-server 的登录页面，也就是大家看到的统一认证中心。</li><li>在统一认真中心我们完成登录功能，登录完成之后，会继续执行第二步的请求，这个时候就可以成功获取到授权码了。</li></ol><p><img src="http://img.itboyhub.com/2020/04/oauth-6-11.png" alt></p><ol start="5"><li>获取到授权码之后，这个时候会重定向到我们 client1 的 login 页面，但是实际上我们的 client1 其实是没有登录页面的，所以这个操作依然会被拦截，此时拦截到的地址包含有授权码，拿着授权码，在 OAuth2ClientAuthenticationProcessingFilter 类中向 auth-server 发起请求，就能拿到 access_token 了（参考：<a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a>）。</li><li>在第五步拿到 access_token 之后，接下来在向我们配置的 user-info-uri 地址发送请求，获取登录用户信息，拿到用户信息之后，在 client1 上自己再走一遍 Spring Security 登录流程，这就 OK 了。</li></ol><p>OK，本文和小伙伴们聊了一些 SpringBoot +OAuth2 单点登录的问题，完整案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>如果小伙伴们觉得有用的话，记得点个在看鼓励下松哥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要先说一下，松哥最近写的教程，都是成系列的，有一些重复的东西写来写去就没意思了，所以每一篇文章都默认大家已经懂了前面的内容了，因此下文有任何看不懂的地方，建议一定先看下相关系列：&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>最近在做 Spring Cloud 项目，松哥和大家分享一点微服务架构中的安全管理思路</title>
    <link href="http://www.javaboy.org/2020/0422/spring-cloud-oauth2.html"/>
    <id>http://www.javaboy.org/2020/0422/spring-cloud-oauth2.html</id>
    <published>2020-04-22T09:18:08.000Z</published>
    <updated>2020-04-23T09:30:41.201Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间一直在发安全相关的 Spring Security 和 OAuth2，当然这两个系列还在继续，对 Spring Security 和 OAuth2 感兴趣的小伙伴，不要错过前面的文章哦，本文主要将一些理论上的东西，所以要是前面的 OAuth2 不懂，可能阅读起来有些吃力：</p><a id="more"></a><p><strong>Spring Security 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li></ol><p><strong>OAuth2 系列：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li></ol><p>这两个系列都还没完，还在继续更新，也会定期推出文章的配套视频，欢迎小伙伴们保持关注。</p><p>今天就不和大家聊代码了，我想结合自己目前的工作，和大家说一说 Spring Cloud 基础架构的安全管理问题，因为我最近一直在做这方面的工作，有一些心得，发出来和小伙伴们一起探讨。</p><p>这其实是一个挺复杂的问题，本文我尽量从一个容易理解的方面来和大家介绍，我们先把这个思想体系搭建起来，后面的文章，松哥会抽空给大家上代码。</p><h2 id="1-微服务架构"><a href="#1-微服务架构" class="headerlink" title="1.微服务架构"></a>1.微服务架构</h2><p>在微服务中，我们一般都会有一个网关，网关背后有很多个微服务，所有的请求都是首先到达网关，再由网关转发到不同的服务上去。另外我们可能会搭建一个统一认证中心，我画一个已经过简化的架构图大家来看下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-8-2.png" alt></p><p>可以看到，在这个微服务架构中，我们的鉴权流程是这样：</p><ol><li>客户端携带用户名密码发送登录请求到网关。</li><li>网关收到请求之后，将请求路由到统一认证中心。</li><li>统一认证中心确认用户的身份没有问题之后，将返回一个 access_token 给网关。</li><li>网关将 access_token 转发到客户端。</li><li>客户端将获取到的 access_token 放在请求头中去请求真正的微服务，当然这个操作依然会被网关拦下。</li><li>网关将客户端的请求路由到微服务上，接下来微服务需要根据 access_token 鉴定用户身份。</li><li>微服务可以调用统一认证中心去检验用户身份，如果我们采用了 JWT 的话，这一步实际上可以省略。</li><li>微服务确认了用户身份和权限之后，就可以根据实际情况返回数据给用户了。</li></ol><p>这是我们一个大致的认证流程。</p><p>流程清楚了之后，代码写起来就非常容易了。有小伙伴会说，既然流程都清楚了，那我是不是可以自定义认证的相关逻辑了？</p><p>这个想法没错，但是我并不建议。当大家看到这张简化版的架构图，应该很容易就想到 OAuth2 了，很明显，将 OAuth2 放在这里最恰当不过。使用 OAuth2 好处是它是一个经过市场验证的安全标准，使用 OAuth2 的话，你就不用担心可能存在的风险漏洞，如果是自己设计的话，要考虑的问题就比较多。</p><p>但是 OAuth2 中存在的一些角色问题在这里是如何划分呢？</p><p>首先大家明白，OAuth2 中的授权服务器在校验的时候，实际上是有两个方面的校验工作，一方面是校验客户端信息，另一方面是校验用户信息，微服务 A 和 微服务 B 都在处理业务上的事情，实际上没有必要和客户端关联起来，所以我们可以在网关上先初步校验客户端信息，然后在微服务上再去校验用户身份信息。</p><p>具体来说是这样：</p><p>在上面的架构图中，网关还有另外一个身份就是资源服务器，当请求到达网关之后，如果是去往统一认证中心的请求，则直接转发即可；如果请求是去往普通微服务的请求，网关可以先做初步校验，就是校验客户端身份，如果没有问题，则将请求路由到不同的微服务上，各个微服务再根据自身的业务和权限情况，进行响应。</p><p>为什么不把所有权限校验都在网关做了呢？</p><p>对于一个超大型的微服务项目而言，涉及到的子系统可能非常多，权限控制也是非常复杂，网关不可能了解所有业务系统的逻辑，如果把所有的鉴权操作都放在网关上做，很明显会加大网关的复杂度，让网关变得非常臃肿。另一方面，不同的微服务可能是由不同的团队开发的，如果把每个微服务的鉴权系统放在网关上做，又会增加开发的难度，所以，我们可以先在网关对用户身份做初步校验，没问题的话，再把请求路由到不同的微服务，做具体的校验。</p><p>在这个过程中，我们可以使用普通的 access_token，就是那种一个 UUID 字符串的，如果使用了这种格式的 access_token，我们可以通过调用授权服务器来确定用户身份，也就是上图中的第七步不可以省略，这对于分布式系统来说显然不是最佳方案。结合 JWT 就可以很好的解决这个问题，JWT 中保存了用户的所有信息，微服务拿到 JWT 字符串之后，就可以很好的解析出用户的信息了。</p><h2 id="2-为什么不建议-Cookie"><a href="#2-为什么不建议-Cookie" class="headerlink" title="2.为什么不建议 Cookie"></a>2.为什么不建议 Cookie</h2><p>微服务架构是一种分布式系统，在分布式系统中，我们经常需要将用户的信息从一个微服务传递到另外一个微服务中去，传统的 SecurityContext 这种基于 ThreadLocal 基于内存的方式显然就不太合适，因为这种方式无法灵活的在分布式系统之间传递用户信息，也无法很好的支持单点登录。具体可以参考：<a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a>。</p><p>另一方面，前端应用程序多样化，Android、iOS、各种平台的小程序、H5 页面等等，并非所有的前端应用都会对 Cookie 有友好的支持，后端使用 access_token 也可以避免前端将来面临的这些问题。</p><h2 id="3-内部调用鉴权"><a href="#3-内部调用鉴权" class="headerlink" title="3. 内部调用鉴权"></a>3. 内部调用鉴权</h2><p>微服务内部调用的鉴权也需要考虑。当然，如果系统对于安全性的要求不高的话，这一步其实可以省略。</p><p>如果不能省略，我也来说说思路。</p><p>现在的微服务之间调用，例如 A 调用 B，如果是基于 Spring Cloud 架构的话，可能以 Open Feign 调用为主，这种情况下，我们可以自定义一个请求拦截器，当请求要发出的时候，自动拦截请求，然后自动向请求头中添加认证信息。</p><p>然后可以定义一个公共的注解，这个注解专门用来做校验工作，该注解可以从从请求头中提取出 A 传递来的信息进行校验。</p><p>在 B 中使用这个公共的注解即可。</p><p>当然 B 中也可以不使用注解，而是通过路径来校验，但是在这个场景下，注解反而灵活一些。</p><h2 id="4-还要不要-Spring-Security"><a href="#4-还要不要-Spring-Security" class="headerlink" title="4. 还要不要 Spring Security"></a>4. 还要不要 Spring Security</h2><p>有小伙伴会问，在微服务上拿到 JWT 字符串之后，是不是可以自己解析？（JWT 解析参考：<a href="https://mp.weixin.qq.com/s/Sn59dxwtsEWoj2wdynQuRQ" target="_blank" rel="noopener">Spring Security 结合 Jwt 实现无状态登录</a>）这样就不需要 Spring Security 了？</p><p>虽然自己解析并不存在技术上的难点，但是我还是不建议自己解析，建议继续在 Spring Security 的基础上完成剩余操作。</p><p>我们拿到 JWT 之后，通过 Spring Cloud Security 来自动解析 JWT 字符串，获取用户信息，然后自动将用户信息注入 SecurityContext 中，相当于自动完成一次登录操作，然后继续后面的操作，这样自己要省事很多，而且 Spring Security 中的各种路径拦截规则我们都还可以继续使用。</p><p>好了，本文就是和大家聊一点思路，基于这个思路，松哥有一个 Spring Cloud 微服务脚手架代码正在完善，近期会和小伙伴们见面，请大家保持关注哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间一直在发安全相关的 Spring Security 和 OAuth2，当然这两个系列还在继续，对 Spring Security 和 OAuth2 感兴趣的小伙伴，不要错过前面的文章哦，本文主要将一些理论上的东西，所以要是前面的 OAuth2 不懂，可能阅读起来有些吃力：&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Cloud" scheme="http://www.javaboy.org/tags/Spring-Cloud/"/>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>274 页 pdf 文档，Spring Boot 教程也有离线版了</title>
    <link href="http://www.javaboy.org/2020/0422/spring-boot-guide.html"/>
    <id>http://www.javaboy.org/2020/0422/spring-boot-guide.html</id>
    <published>2020-04-22T09:17:53.000Z</published>
    <updated>2020-04-23T10:16:40.078Z</updated>
    
    <content type="html"><![CDATA[<p>上次发了篇文章说是 Spring Boot+Vue 视频杀青了，里边提到我有一个手敲 5W 余字的 SSM 教程，然后就有很多小伙伴不停在公众号后台追问 5W 余字的 SSM 教程在哪？看到这个问题我也挺郁闷的，看来前面的干货还是有很多小伙伴错过，因此今天就再说一下，大家在松哥公众号后台分别回复：<code>maven</code>、<code>spring</code>、<code>springmvc</code>、<code>mybatis</code> 可以获取松哥手敲的干货教程，当然也可以直接访问在线教程：</p><a id="more"></a><ul><li><a href="http://maven.javaboy.org" target="_blank" rel="noopener">http://maven.javaboy.org</a></li><li><a href="http://spring.javaboy.org" target="_blank" rel="noopener">http://spring.javaboy.org</a></li><li><a href="http://springmvc.javaboy.org" target="_blank" rel="noopener">http://springmvc.javaboy.org</a></li><li><a href="http://mybatis.javaboy.org" target="_blank" rel="noopener">http://mybatis.javaboy.org</a></li></ul><p><strong>不过，从今天开始，公众号后台干货喜迎新的关键字 <code>springboot</code>。</strong></p><p>很早就有小伙伴问松哥 Spring Boot 教程有没有电子版的，其实这个我一直在准备，迟迟没有发布的原因在于我一直觉得已有的教程还不够完善，还需要补充，而 pdf 一旦发布，传播开来后，再更新的话，大家不容易及时 GET 到。</p><p>所以，我一直做的是在线电子书，在线电子书的好处是可以及时更新，这样无论什么时候大家打开在线文档，看到的就是最新的教程。</p><p>不过由于电子文档托管在 GitHub 上，GitHub 近来访问速度越来越慢，图片也经常加载不出来。另一方面，昨天整理完了 15 道 Spring Boot 面试题，然后早期博客的排版问题我也逐一整理了一遍，这个教程也算是告一段落了，阶段性收尾，于是抽空做了这个离线的 pdf 文档。</p><p><img src="http://img.itboyhub.com/2020/04/spring-boot-51-1.png" alt><br><img src="http://img.itboyhub.com/2020/04/spring-boot-51-2.png" alt></p><p>还是老规矩，小伙伴们在公众号后台回复 springboot，可以获取该 pdf 文档。</p><p>如果不想看离线的 pdf ，也可以看在线的教程，内容基本是一样的：</p><ul><li><a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li></ul><p><img src="http://img.itboyhub.com/2020/04/spring-boot-51-3.png" alt></p><p>松哥最早开始写博客的时候，对于排版技巧啥的都不太懂，导致一开始的博客排版比较丑陋，最近我基本上都挨个重新排版了一遍，所以文章看起来会更加整齐一些了。</p><p>另外松哥每一次发布的 pdf 文档教程，都是有书签的，大家点击左边的书签可以快速导航到自己想看的知识点。不过由于国内的版权环境不佳，所以松哥发布的 pdf 教程都是经过我处理的，但是这个处理并不影响阅读，该怎么看还是怎么看（建议用 Adobe 官方的 pdf 阅读器）。</p><p>好了，废话就不多说了，Spring Boot 撸起来吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次发了篇文章说是 Spring Boot+Vue 视频杀青了，里边提到我有一个手敲 5W 余字的 SSM 教程，然后就有很多小伙伴不停在公众号后台追问 5W 余字的 SSM 教程在哪？看到这个问题我也挺郁闷的，看来前面的干货还是有很多小伙伴错过，因此今天就再说一下，大家在松哥公众号后台分别回复：&lt;code&gt;maven&lt;/code&gt;、&lt;code&gt;spring&lt;/code&gt;、&lt;code&gt;springmvc&lt;/code&gt;、&lt;code&gt;mybatis&lt;/code&gt; 可以获取松哥手敲的干货教程，当然也可以直接访问在线教程：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</title>
    <link href="http://www.javaboy.org/2020/0421/oauth2-jwt.html"/>
    <id>http://www.javaboy.org/2020/0421/oauth2-jwt.html</id>
    <published>2020-04-21T09:17:35.000Z</published>
    <updated>2020-04-23T09:30:52.337Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>本文是我们 OAuth2 系列的第五篇，通过前面四篇文章相信大家对于 OAuth2 中的各种授权登录流程已经轻车熟路了。</p><a id="more"></a><p>前面的文章松哥侧重于和大家理清楚 OAuth2 的登录流程，对于一些登录细节则没有去深究，接下来松哥会和大家把这些案例一一进行晚上。</p><p>本文依然是在前面案例的基础上完成，所以还是强烈建议小伙伴们阅读本系列前面的文章：</p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li></ol><p>今天松哥主要和大家分享如何把 OAuth2 和 JWT 套在一起玩！</p><p>传统的通过 session 来记录用户认证信息的方式我们可以理解为这是一种有状态登录，而 JWT 则代表了一种无状态登录。<strong>无状态登录天然的具备单点登录能力，所以这个技术组合小伙伴们还是很有必要认真学习下。</strong> 可能有小伙伴对这个概念还不太熟悉，我这里就先来科普一下有状态登录和无状态登录。</p><h2 id="1-无状态登录"><a href="#1-无状态登录" class="headerlink" title="1. 无状态登录"></a>1. 无状态登录</h2><h3 id="1-1-什么是有状态"><a href="#1-1-什么是有状态" class="headerlink" title="1.1 什么是有状态"></a>1.1 什么是有状态</h3><p>有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如 Tomcat 中的 Session。例如登录：用户登录后，我们把用户的信息保存在服务端 session 中，并且给用户一个 cookie 值，记录对应的 session，然后下次请求，用户携带 cookie 值来（这一步有浏览器自动完成），我们就能识别到对应 session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下：</p><ul><li>服务端保存大量数据，增加服务端压力</li><li>服务端保存用户状态，不支持集群化部署</li></ul><h3 id="1-2-什么是无状态"><a href="#1-2-什么是无状态" class="headerlink" title="1.2 什么是无状态"></a>1.2 什么是无状态</h3><p>微服务集群中的每个服务，对外提供的都使用 RESTful 风格的接口。而 RESTful 风格的一个最重要的规范就是：服务的无状态性，即：</p><ul><li>服务端不保存任何客户端请求者信息</li><li>客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份</li></ul><p>那么这种无状态性有哪些好处呢？</p><ul><li>客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器</li><li>服务端的集群和状态对客户端透明</li><li>服务端可以任意的迁移和伸缩（可以方便的进行集群化部署）</li><li>减小服务端存储压力</li></ul><h3 id="1-3-如何实现无状态"><a href="#1-3-如何实现无状态" class="headerlink" title="1.3 如何实现无状态"></a>1.3 如何实现无状态</h3><p>无状态登录的流程：</p><ul><li>首先客户端发送账户名/密码到服务端进行认证</li><li>认证通过后，服务端将用户信息加密并且编码成一个 token，返回给客户端</li><li>以后客户端每次发送请求，都需要携带认证的 token</li><li>服务端对客户端发送来的 token 进行解密，判断是否有效，并且获取用户登录信息</li></ul><h3 id="1-4-JWT"><a href="#1-4-JWT" class="headerlink" title="1.4 JWT"></a>1.4 JWT</h3><h4 id="1-4-1-简介"><a href="#1-4-1-简介" class="headerlink" title="1.4.1 简介"></a>1.4.1 简介</h4><p>JWT，全称是 Json Web Token ， 是一种 JSON 风格的轻量级的授权和身份认证规范，可实现无状态、分布式的 Web 应用授权：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-1.png" alt></p><p>JWT 作为一种规范，并没有和某一种语言绑定在一起，常用的 Java 实现是 GitHub 上的开源项目 jjwt，地址如下：<code>https://github.com/jwtk/jjwt</code></p><h4 id="1-4-2-JWT-数据格式"><a href="#1-4-2-JWT-数据格式" class="headerlink" title="1.4.2 JWT 数据格式"></a>1.4.2 JWT 数据格式</h4><p>JWT 包含三部分数据：</p><p>1.Header：头部，通常头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>加密算法，自定义</li></ul><p>我们会对头部进行 Base64Url 编码（可解码），得到第一部分数据。</p><p>2.Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了 7 个示例信息：</p><ul><li>iss (issuer)：表示签发人</li><li>exp (expiration time)：表示token过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>这部分也会采用 Base64Url 编码，得到第二部分数据。</p><p>3.Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥 secret（密钥保存在服务端，不能泄露给客户端），通过 Header 中配置的加密算法生成。用于验证整个数据完整和可靠性。</p><p>生成的数据格式如下图：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-2.png" alt></p><p>注意，这里的数据通过 <code>.</code> 隔开成了三部分，分别对应前面提到的三部分，另外，这里数据是不换行的，图片换行只是为了展示方便而已。</p><h4 id="1-4-3-JWT-交互流程"><a href="#1-4-3-JWT-交互流程" class="headerlink" title="1.4.3 JWT 交互流程"></a>1.4.3 JWT 交互流程</h4><p>流程图：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-3.png" alt></p><p>步骤翻译：</p><ol><li>应用程序或客户端向授权服务器请求授权</li><li>获取到授权后，授权服务器会向应用程序返回访问令牌</li><li>应用程序使用访问令牌来访问受保护资源（如API）</li></ol><p>因为 JWT 签发的 token 中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就符合了 RESTful 的无状态规范。</p><h3 id="1-5-JWT-存在的问题"><a href="#1-5-JWT-存在的问题" class="headerlink" title="1.5 JWT 存在的问题"></a>1.5 JWT 存在的问题</h3><p>说了这么多，JWT 也不是天衣无缝，由客户端维护登录状态带来的一些问题在这里依然存在，举例如下：</p><ol><li>续签问题，这是被很多人诟病的问题之一，传统的 cookie+session 的方案天然的支持续签，但是 jwt 由于服务端不保存用户状态，因此很难完美解决续签问题，如果引入 redis，虽然可以解决问题，但是 jwt 也变得不伦不类了。</li><li>注销问题，由于服务端不再保存用户信息，所以一般可以通过修改 secret 来实现注销，服务端 secret 修改后，已经颁发的未过期的 token 就会认证失败，进而实现注销，不过毕竟没有传统的注销方便。</li><li>密码重置，密码重置后，原本的 token 依然可以访问系统，这时候也需要强制修改 secret。</li><li>基于第 2 点和第 3 点，一般建议不同用户取不同 secret。</li></ol><h2 id="2-OAuth2-中的问题"><a href="#2-OAuth2-中的问题" class="headerlink" title="2.OAuth2 中的问题"></a>2.OAuth2 中的问题</h2><p>在<a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">前面的文章中</a>，授权服务器派发了 access_token 之后，客户端拿着 access_token 去请求资源服务器，资源服务器要去校验 access_token 的真伪，所以我们在资源服务器上配置了 RemoteTokenServices，让资源服务器做远程校验：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">RemoteTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RemoteTokenServices services = <span class="hljs-keyword">new</span> RemoteTokenServices();</span><br><span class="line">    services.setCheckTokenEndpointUrl(<span class="hljs-string">"http://localhost:8080/oauth/check_token"</span>);</span><br><span class="line">    services.setClientId(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">    services.setClientSecret(<span class="hljs-string">"123"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在高并发环境下这样的校验方式显然是有问题的，如果结合 JWT，用户的所有信息都保存在 JWT 中，这样就可以有效的解决上面的问题。</p><h2 id="3-改造方案"><a href="#3-改造方案" class="headerlink" title="3.改造方案"></a>3.改造方案</h2><h3 id="3-1-授权服务器改造"><a href="#3-1-授权服务器改造" class="headerlink" title="3.1 授权服务器改造"></a>3.1 授权服务器改造</h3><p>首先我们来看对授权服务器的改造，我们来修改 AccessTokenConfig 类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessTokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String SIGNING_KEY = <span class="hljs-string">"javaboy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        JwtAccessTokenConverter converter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="hljs-keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的改造主要是两方面：</p><ol><li>TokenStore 我们使用 JwtTokenStore 这个实例。之前我们将 access_token 无论是存储在内存中，还是存储在 Redis 中，都是要存下来的，客户端将 access_token 发来之后，我们还要校验看对不对。但是如果使用了 JWT，access_token 实际上就不用存储了（无状态登录，服务端不需要保存信息），因为用户的所有信息都在 jwt 里边，所以这里配置的 JwtTokenStore 本质上并不是做存储。</li><li>另外我们还提供了一个 JwtAccessTokenConverter，这个 JwtAccessTokenConverter 可以实现将用户信息和 JWT 进行转换（将用户信息转为 jwt 字符串，或者从 jwt 字符串提取出用户信息）。</li><li>另外，在 JWT 字符串生成的时候，我们需要一个签名，这个签名需要自己保存好。</li></ol><p>这里 JWT 默认生成的用户信息主要是用户角色、用户名等，如果我们希望在生成的 JWT 上面添加额外的信息，可以按照如下方式添加：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAdditionalInformation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenEnhancer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">enhance</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; info = accessToken.getAdditionalInformation();</span><br><span class="line">        info.put(<span class="hljs-string">"author"</span>, <span class="hljs-string">"江南一点雨"</span>);</span><br><span class="line">        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);</span><br><span class="line">        <span class="hljs-keyword">return</span> accessToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类 CustomAdditionalInformation 实现 TokenEnhancer 接口，并实现接口中的 enhance 方法。enhance 方法中的 OAuth2AccessToken 参数就是已经生成的 access_token 信息，我们可以从 OAuth2AccessToken 中取出已经生成的额外信息，然后在此基础上追加自己的信息。</p><p><strong>需要提醒一句，其实我们配置的 JwtAccessTokenConverter 也是 TokenEnhancer 的一个实例</strong></p><p>配置完成之后，我们还需要在 AuthorizationServer 中修改 AuthorizationServerTokenServices 实例，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JwtAccessTokenConverter jwtAccessTokenConverter;</span><br><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">CustomAdditionalInformation customAdditionalInformation;</span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">AuthorizationServerTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    DefaultTokenServices services = <span class="hljs-keyword">new</span> DefaultTokenServices();</span><br><span class="line">    services.setClientDetailsService(clientDetailsService());</span><br><span class="line">    services.setSupportRefreshToken(<span class="hljs-keyword">true</span>);</span><br><span class="line">    services.setTokenStore(tokenStore);</span><br><span class="line">    TokenEnhancerChain tokenEnhancerChain = <span class="hljs-keyword">new</span> TokenEnhancerChain();</span><br><span class="line">    tokenEnhancerChain.setTokenEnhancers(Arrays.asList(jwtAccessTokenConverter, customAdditionalInformation));</span><br><span class="line">    services.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line">    <span class="hljs-keyword">return</span> services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是是在 DefaultTokenServices 中配置 TokenEnhancer，将之前的 JwtAccessTokenConverter 和 CustomAdditionalInformation 两个实例注入进来即可。</p><p>如此之后，我们的 auth-server 就算是配置成功了。</p><h3 id="3-2-资源服务器改造"><a href="#3-2-资源服务器改造" class="headerlink" title="3.2 资源服务器改造"></a>3.2 资源服务器改造</h3><p>接下来我们还需要对资源服务器进行改造，也就是 user-server，我们将 auth-server 中的 AccessTokenConfig 类拷贝到 user-server 中，然后在资源服务器配置中不再配置远程校验地址，而是配置一个 TokenStore 即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(<span class="hljs-string">"res1"</span>).tokenStore(tokenStore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里配置好之后，会自动调用 JwtAccessTokenConverter 将 jwt 解析出来，jwt 里边就包含了用户的基本信息，所以就不用远程校验 access_token 了。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>OK，上面配置完成后，我们就可以启动 auth-server、user-server 进行测试，这里为了测试方便，我配置了 password 模式来测试（参考<a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a>）。</p><p>首先我们请求 auth-server 获取 token，如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-4.png" alt></p><p>可以看到，jwt 的字符串还是挺长的，另外返回的数据中也有我们自定义的信息。根据本文第一小节的介绍，小伙伴们可以使用一些在线的 Base64 工具自行解码 jwt 字符串的前两部分，当然也可以通过 check_token 接口来解析：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-5.png" alt></p><p>解析后就可以看到 jwt 中保存的用户详细信息了。</p><p>拿到 access_token 之后，我们就可以去访问 user-server 中的资源了，访问方式跟之前的一样，请求头中传入 access_token 即可：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-5-6.png" alt></p><p>如此之后，我们就成功的将 OAuth2 和 Jwt 结合起来了。</p><h2 id="5-原理"><a href="#5-原理" class="headerlink" title="5.原理"></a>5.原理</h2><p>那么普通的 access_token 到底是怎么变为 jwt 的？jwt 和认证信息又是如何自动转换的？松哥也来和大家扯一扯。</p><p>首先我们知道，access_token 的生成，默认是在 DefaultTokenServices#createAccessToken 方法中的，我们来看下 createAccessToken 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication, OAuth2RefreshToken refreshToken)</span> </span>&#123;</span><br><span class="line">DefaultOAuth2AccessToken token = <span class="hljs-keyword">new</span> DefaultOAuth2AccessToken(UUID.randomUUID().toString());</span><br><span class="line"><span class="hljs-keyword">int</span> validitySeconds = getAccessTokenValiditySeconds(authentication.getOAuth2Request());</span><br><span class="line"><span class="hljs-keyword">if</span> (validitySeconds &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">token.setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + (validitySeconds * <span class="hljs-number">1000L</span>)));</span><br><span class="line">&#125;</span><br><span class="line">token.setRefreshToken(refreshToken);</span><br><span class="line">token.setScope(authentication.getOAuth2Request().getScope());</span><br><span class="line"><span class="hljs-keyword">return</span> accessTokenEnhancer != <span class="hljs-keyword">null</span> ? accessTokenEnhancer.enhance(token, authentication) : token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码中我们可以看到：</p><ol><li>默认生成的 access_token 其实就是一个 UUID 字符串。</li><li>getAccessTokenValiditySeconds 方法用来获取 access_token 的有效期，点进去这个方法，我们发现这个数字是从数据库中查询出来的，其实就是我们配置的 access_token 的有效期，我们配置的有效期单位是秒。</li><li>如果设置的 access_token 有效期大于 0，则调用 setExpiration 方法设置过期时间，过期时间就是在当前时间基础上加上用户设置的过期时间，注意乘以 1000 将时间单位转为毫秒。</li><li>接下来设置刷新 token 和授权范围 scope（刷新 token 的生成过程在 createRefreshToken 方法中，其实和 access_token 的生成过程类似）。</li><li>最后面 return 比较关键，这里会判断有没有 accessTokenEnhancer，如果 accessTokenEnhancer 不为 null，则在 accessTokenEnhancer 中再处理一遍才返回，accessTokenEnhancer 中再处理一遍就比较关键了，就是 access_token 转为 jwt 字符串的过程。</li></ol><p>这里的 accessTokenEnhancer 实际上是一个 TokenEnhancerChain，这个链中有一个 delegates 变量保存了我们定义的两个 TokenEnhancer（auth-server 中定义的 JwtAccessTokenConverter 和 CustomAdditionalInformation），也就是说，我们的 access_token 信息将在这两个类中进行二次处理。<strong>处理的顺序是按照集合中保存的顺序，就是先在 JwtAccessTokenConverter 中处理，后在 CustomAdditionalInformation 中处理，顺序不能乱，也意味着我们在 auth-server 中定义的时候，JwtAccessTokenConverter 和 CustomAdditionalInformation 的顺序不能写错。</strong></p><p>无论是 JwtAccessTokenConverter 还是 CustomAdditionalInformation，它里边核心的方法都是 enhance，我们先来看 JwtAccessTokenConverter#enhance：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">enhance</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">DefaultOAuth2AccessToken result = <span class="hljs-keyword">new</span> DefaultOAuth2AccessToken(accessToken);</span><br><span class="line">Map&lt;String, Object&gt; info = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Object&gt;(accessToken.getAdditionalInformation());</span><br><span class="line">String tokenId = result.getValue();</span><br><span class="line"><span class="hljs-keyword">if</span> (!info.containsKey(TOKEN_ID)) &#123;</span><br><span class="line">info.put(TOKEN_ID, tokenId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">tokenId = (String) info.get(TOKEN_ID);</span><br><span class="line">&#125;</span><br><span class="line">result.setAdditionalInformation(info);</span><br><span class="line">result.setValue(encode(result, authentication));</span><br><span class="line">OAuth2RefreshToken refreshToken = result.getRefreshToken();</span><br><span class="line"><span class="hljs-keyword">if</span> (refreshToken != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">DefaultOAuth2AccessToken encodedRefreshToken = <span class="hljs-keyword">new</span> DefaultOAuth2AccessToken(accessToken);</span><br><span class="line">encodedRefreshToken.setValue(refreshToken.getValue());</span><br><span class="line"><span class="hljs-comment">// Refresh tokens do not expire unless explicitly of the right type</span></span><br><span class="line">encodedRefreshToken.setExpiration(<span class="hljs-keyword">null</span>);</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">Map&lt;String, Object&gt; claims = objectMapper</span><br><span class="line">.parseMap(JwtHelper.decode(refreshToken.getValue()).getClaims());</span><br><span class="line"><span class="hljs-keyword">if</span> (claims.containsKey(TOKEN_ID)) &#123;</span><br><span class="line">encodedRefreshToken.setValue(claims.get(TOKEN_ID).toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, Object&gt; refreshTokenInfo = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Object&gt;(</span><br><span class="line">accessToken.getAdditionalInformation());</span><br><span class="line">refreshTokenInfo.put(TOKEN_ID, encodedRefreshToken.getValue());</span><br><span class="line">refreshTokenInfo.put(ACCESS_TOKEN_ID, tokenId);</span><br><span class="line">encodedRefreshToken.setAdditionalInformation(refreshTokenInfo);</span><br><span class="line">DefaultOAuth2RefreshToken token = <span class="hljs-keyword">new</span> DefaultOAuth2RefreshToken(</span><br><span class="line">encode(encodedRefreshToken, authentication));</span><br><span class="line"><span class="hljs-keyword">if</span> (refreshToken <span class="hljs-keyword">instanceof</span> ExpiringOAuth2RefreshToken) &#123;</span><br><span class="line">Date expiration = ((ExpiringOAuth2RefreshToken) refreshToken).getExpiration();</span><br><span class="line">encodedRefreshToken.setExpiration(expiration);</span><br><span class="line">token = <span class="hljs-keyword">new</span> DefaultExpiringOAuth2RefreshToken(encode(encodedRefreshToken, authentication), expiration);</span><br><span class="line">&#125;</span><br><span class="line">result.setRefreshToken(token);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然比较长，但是却很好理解：</p><ol><li>首先构造一个 DefaultOAuth2AccessToken 对象。</li><li>将 accessToken 中的附加信息拿出来（此时默认没有附加信息）。</li><li>获取旧的 access_token（就是上一步 UUID 字符串），将之作为附加信息存入到 info 中（第四小节测试中，返回的 jwt 中有一个 jti，其实就是这里存入进来的）。</li><li>将附加信息存入 result 中。</li><li>对 result 进行编码，将编码结果作为新的 access_token，这个编码的过程就是 jwt 字符串生成的过程。</li><li>接下来是处理刷新 token，刷新 token 如果是 jwt 字符串，则需要有一个解码操作，否则不需要，刷新 token 如果是 ExpiringOAuth2RefreshToken 的实例，表示刷新 token 已经过期，则重新生成一个，这里的逻辑比较简单，我就不啰嗦了。</li></ol><p>最后我们再来看看这里多次出现的 encode 方法，就是 jwt 字符串编码的过程：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">encode</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;</span><br><span class="line">String content;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">content = objectMapper.formatMap(tokenConverter.convertAccessToken(accessToken, authentication));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot convert access token to JSON"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">String token = JwtHelper.encode(content, signer).getEncoded();</span><br><span class="line"><span class="hljs-keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里首先是把用户信息和 access_token 生成一个 JSON 字符串，然后调用 JwtHelper.encode 方法进行 jwt 编码。</p><p>jwt 编码的过程其实也不难，松哥之前也写过相应的文章，感兴趣的小伙伴可以公众号后台回复 springboot，里边有一篇文章就是讲自动手动生成 jwt 字符串的，这里我就不赘述了。</p><p>OK，本文和小伙伴们聊了一些 OAuth2+JWT 的问题，完成案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>如果小伙伴们觉得有用的话，记得点个在看鼓励下松哥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;本文是我们 OAuth2 系列的第五篇，通过前面四篇文章相信大家对于 OAuth2 中的各种授权登录流程已经轻车熟路了。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>松哥手把手教你玩转 OAuth2 授权码模式|视频版</title>
    <link href="http://www.javaboy.org/2020/0420/oauth2-authorization-code-video.html"/>
    <id>http://www.javaboy.org/2020/0420/oauth2-authorization-code-video.html</id>
    <published>2020-04-20T09:17:19.000Z</published>
    <updated>2020-04-23T09:31:00.652Z</updated>
    
    <content type="html"><![CDATA[<p>*<a href="https://mp.weixin.qq.com/s/Zm-K7R1UGEaIKtwdnw6JuQ" target="_blank" rel="noopener">视频地址</a></p><p>昨天和小伙伴们介绍了 OAuth2 的基本概念，在讲解 Spring Cloud Security OAuth2 之前，我还是先来通过实际代码来和小伙伴们把 OAuth2 中的各个授权模式走一遍，今天我们来看最常用也最复杂的授权码模式。</p><a id="more"></a><p>本文我将通过一个<strong>完整的 Demo</strong> ，注意，是一个<strong>完整的 Demo</strong>，带领小伙伴们把授权码模式走一遍。</p><p>如果小伙伴们还没有看上篇文章可以先看下，这有助于你理解本文中的一些概念：</p><ul><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li></ul><h2 id="1-案例架构"><a href="#1-案例架构" class="headerlink" title="1.案例架构"></a>1.案例架构</h2><p>因为 OAuth2 涉及到的东西比较多，网上的案例大多都是简化的，对于很多初学者而言，简化的案例看的人云里雾里，所以松哥这次想自己搭建一个完整的测试案例，在这个案例中，主要包括如下服务：</p><ul><li>第三方应用</li><li>授权服务器</li><li>资源服务器</li><li>用户</li></ul><p>我用一个表格来给大家整理下：</p><table><thead><tr><th style="text-align:left">项目</th><th style="text-align:left">端口</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">auth-server</td><td style="text-align:left">8080</td><td style="text-align:left">授权服务器</td></tr><tr><td style="text-align:left">user-server</td><td style="text-align:left">8081</td><td style="text-align:left">资源服务器</td></tr><tr><td style="text-align:left">client-app</td><td style="text-align:left">8082</td><td style="text-align:left">第三方应用</td></tr></tbody></table><p>就是说，我们常见的 OAuth2 授权码模式登录中，涉及到的各个角色，我都会自己提供，自己测试，这样可以最大限度的让小伙伴们了解到 OAuth2 的工作原理（文末可以下载案例源码）。</p><p>注意：小伙伴们一定先看下<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>松哥所讲的 OAuth2 授权码模式登录流程，再来学习本文。</p><p>那我们首先来创建一个空的 Maven 父工程，创建好之后，里边什么都不用加，也不用写代码。我们将在这个父工程中搭建这个子模块。</p><h2 id="2-授权服务器搭建"><a href="#2-授权服务器搭建" class="headerlink" title="2.授权服务器搭建"></a>2.授权服务器搭建</h2><p>首先我们搭建一个名为 auth-server 的授权服务，搭建的时候，选择如下三个依赖：</p><ul><li>web</li><li>spring cloud security</li><li>spirng cloud OAuth2</li></ul><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建完成后，首先提供一个 Spring Security 的基本配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                .withUser(<span class="hljs-string">"sang"</span>)</span><br><span class="line">                .password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .password(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.csrf().disable().formLogin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，为了代码简洁，我就不把 Spring Security 用户存到数据库中去了，直接存在内存中。</p><p>这里我创建了一个名为 sang 的用户，密码是 123，角色是 admin。同时我还配置了一个表单登录。</p><p>这段配置的目的，实际上就是配置用户。例如你想用微信登录第三方网站，在这个过程中，你得先登录微信，登录微信就要你的用户名/密码信息，那么我们在这里配置的，其实就是用户的用户名/密码/角色信息。</p><p>基本的用户信息配置完成后，接下来我们来配置授权服务器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccessTokenConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryTokenStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    ClientDetailsService clientDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthorizationServerTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        DefaultTokenServices services = <span class="hljs-keyword">new</span> DefaultTokenServices();</span><br><span class="line">        services.setClientDetailsService(clientDetailsService);</span><br><span class="line">        services.setSupportRefreshToken(<span class="hljs-keyword">true</span>);</span><br><span class="line">        services.setTokenStore(tokenStore);</span><br><span class="line">        services.setAccessTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">2</span>);</span><br><span class="line">        services.setRefreshTokenValiditySeconds(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        security.checkTokenAccess(<span class="hljs-string">"permitAll()"</span>)</span><br><span class="line">                .allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">                .withClient(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">                .secret(<span class="hljs-keyword">new</span> BCryptPasswordEncoder().encode(<span class="hljs-string">"123"</span>))</span><br><span class="line">                .resourceIds(<span class="hljs-string">"res1"</span>)</span><br><span class="line">                .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>,<span class="hljs-string">"refresh_token"</span>)</span><br><span class="line">                .scopes(<span class="hljs-string">"all"</span>)</span><br><span class="line">                .redirectUris(<span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        endpoints.authorizationCodeServices(authorizationCodeServices())</span><br><span class="line">                .tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">AuthorizationCodeServices <span class="hljs-title">authorizationCodeServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InMemoryAuthorizationCodeServices();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有点长，我来给大家挨个解释：</p><ol><li>首先我们提供了一个 TokenStore 的实例，这个是指你生成的 Token 要往哪里存储，我们可以存在 Redis 中，也可以存在内存中，也可以结合 JWT 等等，这里，我们就先把它存在内存中，所以提供一个 InMemoryTokenStore 的实例即可。</li><li>接下来我们创建 AuthorizationServer 类继承自 AuthorizationServerConfigurerAdapter，来对授权服务器做进一步的详细配置，AuthorizationServer 类记得加上 @EnableAuthorizationServer 注解，表示开启授权服务器的自动化配置。</li><li>在 AuthorizationServer 类中，我们其实主要重写三个 configure 方法。</li><li>AuthorizationServerSecurityConfigurer 用来配置令牌端点的安全约束，也就是这个端点谁能访问，谁不能访问。checkTokenAccess 是指一个 Token 校验的端点，这个端点我们设置为可以直接访问（在后面，当资源服务器收到 Token 之后，需要去校验 Token 的合法性，就会访问这个端点）。</li><li>ClientDetailsServiceConfigurer 用来配置客户端的详细信息，在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>中，松哥和大家讲过，授权服务器要做两方面的检验，一方面是校验客户端，另一方面则是校验用户，校验用户，我们前面已经配置了，这里就是配置校验客户端。客户端的信息我们可以存在数据库中，这其实也是比较容易的，和用户信息存到数据库中类似，但是这里为了简化代码，我还是将客户端信息存在内存中，这里我们分别配置了客户端的 id，secret、资源 id、授权类型、授权范围以及重定向 uri。授权类型我在<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">上篇文章</a>中和大家一共讲了四种，四种之中不包含 refresh_token 这种类型，但是在实际操作中，refresh_token 也被算作一种。</li><li>AuthorizationServerEndpointsConfigurer 这里用来配置令牌的访问端点和令牌服务。authorizationCodeServices用来配置授权码的存储，这里我们是存在在内存中，tokenServices 用来配置令牌的存储，即 access_token 的存储位置，这里我们也先存储在内存中。有小伙伴会问，授权码和令牌有什么区别？授权码是用来获取令牌的，使用一次就失效，令牌则是用来获取资源的，如果搞不清楚，建议重新阅读上篇文章恶补一下：<a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li>tokenServices 这个 Bean 主要用来配置 Token 的一些基本信息，例如 Token 是否支持刷新、Token 的存储位置、Token 的有效期以及刷新 Token 的有效期等等。Token 有效期这个好理解，刷新 Token 的有效期我说一下，当 Token 快要过期的时候，我们需要获取一个新的 Token，在获取新的 Token 时候，需要有一个凭证信息，这个凭证信息不是旧的 Token，而是另外一个 refresh_token，这个 refresh_token 也是有有效期的。</li></ol><p>好了，如此之后，我们的授权服务器就算是配置完成了，接下来我们启动授权服务器。</p><h2 id="3-资源服务器搭建"><a href="#3-资源服务器搭建" class="headerlink" title="3.资源服务器搭建"></a>3.资源服务器搭建</h2><p>接下来我们搭建一个资源服务器。大家网上看到的例子，资源服务器大多都是和授权服务器放在一起的，如果项目比较小的话，这样做是没问题的，但是如果是一个大项目，这种做法就不合适了。</p><p>资源服务器就是用来存放用户的资源，例如你在微信上的图像、openid 等信息，用户从授权服务器上拿到 access_token 之后，接下来就可以通过 access_token 来资源服务器请求数据。</p><p>我们创建一个新的 Spring Boot 项目，叫做 user-server ，作为我们的资源服务器，创建时，添加如下依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-1.png" alt></p><p>项目创建成功之后，添加如下配置：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableResourceServer</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">RemoteTokenServices <span class="hljs-title">tokenServices</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        RemoteTokenServices services = <span class="hljs-keyword">new</span> RemoteTokenServices();</span><br><span class="line">        services.setCheckTokenEndpointUrl(<span class="hljs-string">"http://localhost:8080/oauth/check_token"</span>);</span><br><span class="line">        services.setClientId(<span class="hljs-string">"javaboy"</span>);</span><br><span class="line">        services.setClientSecret(<span class="hljs-string">"123"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resources.resourceId(<span class="hljs-string">"res1"</span>).tokenServices(tokenServices());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置代码很简单，我简单的说一下：</p><ol><li>tokenServices 我们配置了一个 RemoteTokenServices 的实例，这是因为资源服务器和授权服务器是分开的，资源服务器和授权服务器是放在一起的，就不需要配置 RemoteTokenServices 了。</li><li>RemoteTokenServices 中我们配置了 access_token 的校验地址、client_id、client_secret 这三个信息，当用户来资源服务器请求资源时，会携带上一个 access_token，通过这里的配置，就能够校验出 token 是否正确等。</li><li>最后配置一下资源的拦截规则，这就是 Spring Security 中的基本写法，我就不再赘述。</li></ol><p>接下来我们再来配置两个测试接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此之后，我们的资源服务器就算配置成功了。</p><h2 id="4-第三方应用搭建"><a href="#4-第三方应用搭建" class="headerlink" title="4.第三方应用搭建"></a>4.第三方应用搭建</h2><p>接下来搭建我们的第三方应用程序。</p><p>注意，第三方应用并非必须，下面所写的代码也可以用 POSTMAN 去测试，这个小伙伴们可以自行尝试。</p><p>第三方应用就是一个普通的 Spring Boot 工程，创建时加入 Thymeleaf 依赖和 Web 依赖：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-2.png" alt></p><p>在 resources/templates 目录下，创建 index.html ，内容如下：</p><figure class="highlight html hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>江南一点雨<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="line">你好，江南一点雨！</span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://localhost:8080/oauth/authorize?client_id=javaboy&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://localhost:8082/index.html"</span>&gt;</span>第三方登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;msg&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是一段 Thymeleaf 模版，点击超链接就可以实现第三方登录，超链接的参数如下：</p><ul><li>client_id 客户端 ID，根据我们在授权服务器中的实际配置填写。</li><li>response_type 表示响应类型，这里是 code 表示响应一个授权码。</li><li>redirect_uri 表示授权成功后的重定向地址，这里表示回到第三方应用的首页。</li><li>scope 表示授权范围。</li></ul><p>h1 标签中的数据是来自资源服务器的，当授权服务器通过后，我们拿着 access_token 去资源服务器加载数据，加载到的数据就在 h1 标签中显示出来。</p><p>接下来我们来定义一个 HelloController：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/index.html"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String code, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (code != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            MultiValueMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">            map.add(<span class="hljs-string">"code"</span>, code);</span><br><span class="line">            map.add(<span class="hljs-string">"client_id"</span>, <span class="hljs-string">"javaboy"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"client_secret"</span>, <span class="hljs-string">"123"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"redirect_uri"</span>, <span class="hljs-string">"http://localhost:8082/index.html"</span>);</span><br><span class="line">            map.add(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"authorization_code"</span>);</span><br><span class="line">            Map&lt;String,String&gt; resp = restTemplate.postForObject(<span class="hljs-string">"http://localhost:8080/oauth/token"</span>, map, Map.class);</span><br><span class="line">            String access_token = resp.get(<span class="hljs-string">"access_token"</span>);</span><br><span class="line">            System.out.println(access_token);</span><br><span class="line">            HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();</span><br><span class="line">            headers.add(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer "</span> + access_token);</span><br><span class="line">            HttpEntity&lt;Object&gt; httpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(headers);</span><br><span class="line">            ResponseEntity&lt;String&gt; entity = restTemplate.exchange(<span class="hljs-string">"http://localhost:8081/admin/hello"</span>, HttpMethod.GET, httpEntity, String.class);</span><br><span class="line">            model.addAttribute(<span class="hljs-string">"msg"</span>, entity.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 HelloController 中，我们定义出 /index.html 的地址。</p><p>如果 code 不为 null，也就是如果是通过授权服务器重定向到这个地址来的，那么我们做如下两个操作：</p><ol><li>根据拿到的 code，去请求 <code>http://localhost:8080/oauth/token</code> 地址去获取 Token，返回的数据结构如下：</li></ol><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"e7f223c4-7543-43c0-b5a6-5011743b5af4"</span>,</span><br><span class="line">    <span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,</span><br><span class="line">    <span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string">"aafc167b-a112-456e-bbd8-58cb56d915dd"</span>,</span><br><span class="line">    <span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">7199</span>,</span><br><span class="line">    <span class="hljs-attr">"scope"</span>: <span class="hljs-string">"all"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>access_token 就是我们请求数据所需要的令牌，refresh_token 则是我们刷新 token 所需要的令牌，expires_in 表示 token 有效期还剩多久。</p><ol start="2"><li>接下来，根据我们拿到的 access_token，去请求资源服务器，注意 access_token 通过请求头传递，最后将资源服务器返回的数据放到 model 中。</li></ol><p><strong>这里我只是举一个简单的例子，目的是和大家把这个流程走通，正常来说，access_token 我们可能需要一个定时任务去维护，不用每次请求页面都去获取，定期去获取最新的 access_token 即可。后面的文章中，松哥还会继续完善这个案例，到时候再来和大家解决这些细节问题。</strong></p><p>OK，代码写完后，我们就可以启动第三方应用开始测试了。</p><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><p>接下来我们去测试。</p><p>首先我们去访问 <code>http://localhost:8082/index.html</code> 页面，结果如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-3.png" alt></p><p>然后我们点击 第三方登录 这个超链接，点完之后，会进入到授权服务器的默认登录页面：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-4.png" alt></p><p>接下来我们输入在授权服务器中配置的用户信息来登录，登录成功后，会看到如下页面：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-5.png" alt></p><p>在这个页面中，我们可以看到一个提示，询问是否授权 javaboy 这个用户去访问被保护的资源，我们选择 approve(批准)，然后点击下方的 Authorize 按钮，点完之后，页面会自动跳转回我的第三方应用中：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-6.png" alt></p><p>大家注意，这个时候地址栏多了一个 code 参数，这就是授权服务器给出的授权码，拿着这个授权码，我们就可以去请求 access_token，授权码使用一次就会失效。</p><p>同时大家注意到页面多了一个 admin，这个 admin 就是从资源服务器请求到的数据。</p><p>当然，我们在授权服务器中配置了两个用户，大家也可以尝试用 javaboy/123 这个用户去登录，因为这个用户不具备 admin 角色，所以使用这个用户将无法获取到 admin 这个字符串，报错信息如下：</p><p><img src="http://img.itboyhub.com/2020/04/oauth-2-7.png" alt></p><p>这个小伙伴们可以自己去测试，我就不再演示了。</p><p>最后在说一句，这不是终极版，只是一个雏形，后面的文章，松哥再带大家来继续完善这个案例。</p><p>好了，本文案例下载地址：<a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></p><p>如果小伙伴们觉得有用的话，记得点个在看鼓励下松哥。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;*&lt;a href=&quot;https://mp.weixin.qq.com/s/Zm-K7R1UGEaIKtwdnw6JuQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;视频地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;昨天和小伙伴们介绍了 OAuth2 的基本概念，在讲解 Spring Cloud Security OAuth2 之前，我还是先来通过实际代码来和小伙伴们把 OAuth2 中的各个授权模式走一遍，今天我们来看最常用也最复杂的授权码模式。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
</feed>
