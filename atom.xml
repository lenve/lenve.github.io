<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2019-09-21T06:48:59.572Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给数据库减负的八个思路</title>
    <link href="http://www.javaboy.org/2019/0921/mysql.html"/>
    <id>http://www.javaboy.org/2019/0921/mysql.html</id>
    <published>2019-09-21T06:47:18.000Z</published>
    <updated>2019-09-21T06:48:59.572Z</updated>
    
    <content type="html"><![CDATA[<p>传统的企业级应用，其实很少会有海量应用，因为企业的规模本身就摆在那里，能有多少数据？高并发？海量数据？不存在的！</p><p>不过在互联网公司中，因为应用大多是面向广大人民群众，数据量动辄上千万上亿，那么这些海量数据要怎么存储？光靠数据库吗？肯定不是。</p><a id="more"></a><p>今天松哥和大家简单的聊一聊这个话题。</p><p>海量数据，光用数据库肯定是没法搞定的，即使不读松哥这篇文章，相信大家也能凝聚这样的共识，海量数据，不是说一种方案、两种方案就能搞定，它是一揽子方案。那么这一揽子方案都包含哪些东西呢？松哥从以下八个方面来和大家聊聊。</p><h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h1><p>首先第一种解决方案就是缓存了。</p><p>缓存，我们可以将数据直接缓存在内从中，例如 Map、也可以使用缓存框架如 Redis 等，将一些需要频繁使用的热点数据保存在缓存中，每当用户来访问的时候，就可以直接将缓存中的数据返回给用户，这样可以有效降低服务器的压力。</p><p>可以缓存起来使用的数据，一般都不能对实时性要求太高。</p><h1 id="2-页面静态化"><a href="#2-页面静态化" class="headerlink" title="2.页面静态化"></a>2.页面静态化</h1><p>页面静态化其实可以算作是缓存的另外一种形式，相当于直接将相关的页面渲染结果缓存起来。首先大家知道，在我们的 Web 项目中，资源分为两大类：</p><ul><li>静态资源</li><li>动态资源</li></ul><p>静态资源就是我们常见的 HTML、CSS、JavaScript、图片等资源，这些资源可以不经过服务端处理，就可以直接返回给前端浏览器，浏览器就可以直接显示出来。</p><p>动态资源则是指我们项目中的 Servlet 接口、Jsp 文件、Freemarker 等，这些需要经过服务端渲染之后，才可以返回前端的资源。</p><p>在实际项目中，静态资源的访问速度要远远高于动态资源，动态资源往往很容易遇到服务器瓶颈、数据库瓶颈，因此，对于一些不经常更新的页面，或者说更新比较缓慢的页面，我们可以通过页面静态化，将一个动态资源保存为静态资源，这样当服务端需要访问的时候，直接将静态资源返回，就可以避免去操作数据库了，降低数据库的压力。</p><p>例如松哥以前做过的一个电商项目，系统根据大数据统计，自动统计出用户当前搜索的热点商品，这些热点商品，10 分钟更新一次，也就是说，在十分钟内，用户登录上来看到的热点商品都是相同的。那么就没有必要每次都去查询数据库，而是将热点数据的页面，通过输出流自动写到服务器上，写成一个普通的 HTML 文件，下次用户来访问，在 10 分钟有效期内，直接将 HTML 页面返回给用户，就不必操作数据库了。</p><p>一般来说，Freemarker、Velocity 等都有相关的方法可以帮助我们快速将动态页面生成静态页面。</p><p>这就是页面静态化。</p><h1 id="3-数据库优化"><a href="#3-数据库优化" class="headerlink" title="3.数据库优化"></a>3.数据库优化</h1><p>很多时候程序跑得慢，不是因为设备落后，而是因为数据库 SQL 写的太差劲。</p><p>要解决海量数据的问题，数据库优化肯定也是不可避免的。一般来说，我们可以从 SQL 优化、表结构优化、以及数据库分区分表等多个方面来对数据库进行优化。数据库优化其实也是一门巨大的学问，松哥以后看有时间写个连载和大家仔细聊聊这个话题。</p><h1 id="4-热点数据分离"><a href="#4-热点数据分离" class="headerlink" title="4.热点数据分离"></a>4.热点数据分离</h1><p>数据库中的数据，虽然是海量数据，但是这些数据并不见得所有数据都是活跃数据，例如用户注册，有的用户注册完就消失的无影无踪了，而有的用户则在不停的登录，因此，对于这两种不同的用户，我们可以将活跃用户分离出来，在主要操作的数据表中只保存活跃用户数据。每次用户登录，先去主表中查看有没有记录，有的话，直接登录，没有的话，再去查看其他表。</p><p>通过判断用户在某一段时间内的登录次数，就可以很快分离出热点数据。</p><h1 id="5-合并数据库操作"><a href="#5-合并数据库操作" class="headerlink" title="5.合并数据库操作"></a>5.合并数据库操作</h1><p>这个方案的宗旨其实是减少数据库操作的次数，例如多次插入操作，我们可以合并成一条 SQL 搞定。多个不同条件的查询，如果条件允许的话，也可以合并成为一个查询，尽量减少数据库的操作，减少在网络上消耗，同时也降低数据库的压力。</p><h1 id="6-数据库读写分离"><a href="#6-数据库读写分离" class="headerlink" title="6.数据库读写分离"></a>6.数据库读写分离</h1><p>数据库的读写分离其实松哥在之前的 MyCat 中也和大伙聊过了（<a href="https://mp.weixin.qq.com/s/oNsTcrWCjntQefD2B0sq1A" target="_blank" rel="noopener">MyCat 系列</a>），读写分离之后，一方面可以提高数据库的操作效率，另一方面也算是对数据库的一个备份。这一块的具体操作大家可以参考松哥前面的文章。</p><h1 id="7-分布式数据库"><a href="#7-分布式数据库" class="headerlink" title="7.分布式数据库"></a>7.分布式数据库</h1><p>数据库读写分离之后，无形中增大了代码的复杂度，所以一般还需要借助分布式数据库中间件，这样可以有效提高数据库的弹性，可以方便的随时为数据库扩容，同时也降低代码的耦合度。</p><h1 id="8-NoSQL-和-Hadoop"><a href="#8-NoSQL-和-Hadoop" class="headerlink" title="8.NoSQL 和 Hadoop"></a>8.NoSQL 和 Hadoop</h1><p>另外，引入 NoSQL 和 Hadoop 也是解决方案之一。NoSQL 突破了关系型数据库中对表结构、字段等定义的条条框框，使用户可以非常灵活方便的操作，另外 NoSQL 通过多个存储块存储数据的特点，使得天然具备操作大数据的优势（快）。不过，老实说，NoSQL 目前还是在互联网项目中比较常见，在传统的企业级应用中还是比较少见。</p><p>Hadoop 就不必说了，大数据处理利器。</p><p>很多时候技术和架构只是一个工具，所有的东西都摆在你面前，关键是如何把这些东西组合在一起，使之产生最大化收益，这就需要大家慢慢琢磨，松哥后面也尽量和大家多分享一些这方面的经验。</p><p>好了，简单的从 8 个方面和大家聊一聊这个问题，大家在工作中有没有遇到类似问题呢？你都是怎么处理的？欢迎留言讨论。</p><p>参考资料：</p><p>[1] 韩路彪.看透Spring MVC：源代码分析与实践[M].北京：机械工业出版社，2015.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传统的企业级应用，其实很少会有海量应用，因为企业的规模本身就摆在那里，能有多少数据？高并发？海量数据？不存在的！&lt;/p&gt;
&lt;p&gt;不过在互联网公司中，因为应用大多是面向广大人民群众，数据量动辄上千万上亿，那么这些海量数据要怎么存储？光靠数据库吗？肯定不是。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了</title>
    <link href="http://www.javaboy.org/2019/0920/springboot-vue-online.html"/>
    <id>http://www.javaboy.org/2019/0920/springboot-vue-online.html</id>
    <published>2019-09-20T05:07:20.000Z</published>
    <updated>2019-09-21T06:05:01.688Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了一周的域名备案昨天终于搞定了。</p><p>松哥第一时间想到赶紧把<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>部署上去，我知道很多小伙伴已经等不及了。</p><a id="more"></a><h2 id="1-也曾经上过线"><a href="#1-也曾经上过线" class="headerlink" title="1. 也曾经上过线"></a>1. 也曾经上过线</h2><p>其实这两个项目当时刚做好的时候，我就把它们部署到服务器上了，以帮助小伙伴们更好的查看效果。但是那个是一台国外服务器，之所以购买国外服务器，主要是嫌国内备案麻烦，当然也有其他大家都懂的原因。</p><p>国外服务器有方便的地方，同时也有很多不便，例如网络不稳，随时有失联的风险。所以我在 2018 年年初，虽然把这两个项目都部署在服务器上，但是很多小伙伴的访问体验都不好，主要还是网络的问题。后来一段时间，经过几轮围剿与反围剿，这台服务器就彻底和松哥失联了。</p><p>失联之后，因为工作比较忙，我也就懒得去折腾了，所以导致<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>大家在很长一段时间内无法在线查看效果。</p><h2 id="2-重新上线"><a href="#2-重新上线" class="headerlink" title="2. 重新上线"></a>2. 重新上线</h2><p>最近因为有一些其他的计划，于是购买了阿里云服务，完事之后就是备案，所有东西都搞定之后，想着先把<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>部署起来，方便大家查看效果。</p><p>说干就干，我首先规划了两个二级域名：</p><ul><li><a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a></li><li><a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a></li></ul><p>这两个二级域名分别用来部署 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>和<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>。</p><p>大家可以通过这两个地址查看效果：</p><p><strong><a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a></strong></p><p><img src="http://www.javaboy.org/images/fronted-backend/70-1.png" alt></p><p><strong><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a></strong></p><p><img src="http://www.javaboy.org/images/fronted-backend/70-2.png" alt></p><p>为了确保每位小伙伴都能看到完整的演示效果，防止有的小伙伴不慎把所有数据清空了，导致其他小伙伴啥都看不到，我只开通了演示账户的查询和部分字段的更新权限，因此大家在查看演示效果时，可能会有一些涉及到增删改的操作会执行失败，请勿见怪，将项目部署到本地运行之后，就可以查看完整效果了。</p><h2 id="3-技能树"><a href="#3-技能树" class="headerlink" title="3. 技能树"></a>3. 技能树</h2><p>既然都写到这儿了，就和大家聊一聊这两个部署是怎么实现的。</p><h3 id="3-1-部署方案选择"><a href="#3-1-部署方案选择" class="headerlink" title="3.1 部署方案选择"></a>3.1 部署方案选择</h3><p>大家知道前后端分离部署的时候，我们有两种不同的方案：</p><ul><li>一种就是将前端项目打包编译之后，放到后端项目中（例如 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下）</li><li>另外一种则是将前端打包之后的静态资源用 Nginx 来部署，后端单独部署只需要单纯的提供接口即可。</li></ul><p>一般在公司项目中，我们更多的是采用后者。不过松哥这里部署为了省事，我采用了第一种方案。（以后抽空我会和大家聊聊第二种部署方案）</p><h3 id="3-2-域名映射"><a href="#3-2-域名映射" class="headerlink" title="3.2 域名映射"></a>3.2 域名映射</h3><p>域名映射这块简单，登录阿里云后台，添加两个 A 记录即可。</p><p><img src="http://www.javaboy.org/images/fronted-backend/70-3.png" alt></p><h3 id="3-3-启动-Spring-Boot"><a href="#3-3-启动-Spring-Boot" class="headerlink" title="3.3 启动 Spring Boot"></a>3.3 启动 Spring Boot</h3><p>将<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>分别打包上传到服务器，这个过程应该就不用我多说了吧，然后分别启动这两个项目，两个项目的默认端口分别是 8081 和 8082，命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar vblog.jar &gt; vblog.log &amp;</span><br><span class="line">nohup java -jar vhr.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><p>将两个项目的运行日志分别写入到 vblog.log 和 vhr.log 文件中。</p><p>启动成功之后，我们就可以通过 <code>itboyhub.com:8081</code> 和 <code>itboyhub.com:8082</code> 两个端口来分别访问这两个项目了。但是这还没达到松哥的目标，我想通过二级域名来访问，并且想通过 80 端口来访问，这就要借助 Nginx 了。</p><p><strong>注意</strong></p><p>启动完成后，大家需要登录阿里云后台，确认 8081 和 8082 端口已经开启。</p><h3 id="3-4-Nginx-配置"><a href="#3-4-Nginx-配置" class="headerlink" title="3.4 Nginx 配置"></a>3.4 Nginx 配置</h3><p>Nginx 的基本用法，大家可以参考松哥的这篇旧文：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></li></ul><p>这里我们主要来看看 Nginx 的配置。</p><p>由于有两个二级域名，而且未来服务器还要配置其他域名，因此域名要能够做到动态解析，因此在具体配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  *.itboyhub.com;</span><br><span class="line"></span><br><span class="line">    if ($http_host ~* &quot;^(.*?)\.itboyhub\.com$&quot;) &#123;</span><br><span class="line">            set $domain $1;</span><br><span class="line">    &#125;</span><br><span class="line">    # 其他配置...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先监听的端口为 80</li><li>二级域名则用一个通配符 <code>*</code> 代替</li><li>接下来在 if 语句用，通过正则表达式提取出二级域名的名字，交给变量 $domain，以备后用。</li></ul><p>接下来配置转发规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  if ($domain ~* &quot;vhr&quot;) &#123;</span><br><span class="line">    proxy_pass http://itboyhub.com:8082;</span><br><span class="line">  &#125;</span><br><span class="line">  if ($domain ~* &quot;vblog&quot;) &#123;</span><br><span class="line">    proxy_pass http://itboyhub.com:8081;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  tcp_nodelay     on;</span><br><span class="line">  proxy_set_header Host            $host;</span><br><span class="line">  proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当定义的 $domain 中包含 vhr 字符时，将请求转发到 <a href="http://itboyhub.com:8082" target="_blank" rel="noopener">http://itboyhub.com:8082</a></li><li>当定义的 $domain 中包含 vblog 字符时，将请求转发到 <a href="http://itboyhub.com:8081" target="_blank" rel="noopener">http://itboyhub.com:8081</a></li><li>最后再配置将代理服务器收到的用户的信息传到 real server 上</li></ul><p>另一方面，由于默认的后端首页是 <code>/index.html</code>，如果用户直接访问 <a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a> 或者 <a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a>，会被权限管理机制拦截（会自动重定向到 <code>/login_p</code>），因此，如果用户访问地址中没有 <code>/index.html</code> ，则自动添加上 <code>/index.html</code>，配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /login_p &#123;</span><br><span class="line">   if ($domain ~* &quot;vhr&quot;) &#123;</span><br><span class="line">     rewrite ^/(.*)$ http://vhr.itboyhub.com/index.html permanent;</span><br><span class="line">   &#125;</span><br><span class="line">   if ($domain ~* &quot;vblog&quot;) &#123;</span><br><span class="line">     rewrite ^/(.*)$ http://vblog.itboyhub.com/index.html permanent;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这行配置在 <code>location /</code> 之前进行配置，这里两个 if 的含义和前面的一样，不再赘述。</p><p>OK，如此之后我们的配置就算是完成了（上面 nginx 完整的配置文件小伙伴可以在公众号后台回复 nginx.conf 获取​）。</p><p>接下来我们就可以通过如下两个二级域名访问这两个开源项目了，小伙伴们赶紧试一把吧。</p><ul><li><a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a></li><li><a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a></li></ul><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>最后，再向小伙伴们安利一把这两个开源项目：</p><ul><li><a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li><li><a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>如果你要学习 Spring Boot + Vue 前后端分离项目，这两个是不可多得的好资料。 其中 V 部落无论是从技术点还是业务上来说，都要简单一些，所以如果你是新手，可以先看看 V 部落。微人事虽然稍微复杂一点，但好在松哥配有完整的开发文档，照着开发文档，相信大家也能理解大部分的功能。文档如下：</p><p><img src="http://www.javaboy.org/images/fronted-backend/70-4.png" alt></p><p>如果大家在部署的过程中遇到问题，也可以参考松哥手把手的部署视频：</p><ul><li><a href="https://mp.weixin.qq.com/s/qN01Le434FWom0c3jqiQmA" target="_blank" rel="noopener">微人事项目部署视频教程</a></li></ul><p>好了，本文说到这里，小伙伴们有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了一周的域名备案昨天终于搞定了。&lt;/p&gt;
&lt;p&gt;松哥第一时间想到赶紧把&lt;a href=&quot;https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微人事&lt;/a&gt;和 &lt;a href=&quot;https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;V 部落&lt;/a&gt;部署上去，我知道很多小伙伴已经等不及了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Java 操作 MongoDB</title>
    <link href="http://www.javaboy.org/2019/0919/mongodb-in-java.html"/>
    <id>http://www.javaboy.org/2019/0919/mongodb-in-java.html</id>
    <published>2019-09-19T02:17:28.000Z</published>
    <updated>2019-09-21T09:06:51.900Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们介绍的 MongoDB 的操作都是在 shell 命令中写的，在项目开发时我们当然都是用程序去操作 MongoDB 的，本文我们来看看如何用 Java 代码操作 MongoDB。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先我们需要驱动，MongoDB 的 Java 驱动我们可以直接在 Maven 中央仓库去下载，也可以创建 Maven 工程添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mongodb-driver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>建议通过 Maven 来添加依赖，如果自己下载 jar，需要下载如下三个 jar：</p><blockquote><ol><li>org.mongodb:bson:jar:3.5.0</li><li>org.mongodb:mongodb-driver-core:jar:3.5.0</li><li>org.mongodb:mongodb-driver:jar:3.5.0</li></ol></blockquote><p>另外，在使用 Java 操作 MongoDB 之前，记得启动 MongoDB 哦~</p><h2 id="获取集合"><a href="#获取集合" class="headerlink" title="获取集合"></a>获取集合</h2><p>所有准备工作完成之后，我们首先需要一个 MongoClient，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoClient client = <span class="hljs-keyword">new</span> MongoClient(<span class="hljs-string">"192.168.248.136"</span>, <span class="hljs-number">27017</span>);</span><br></pre></td></tr></table></figure><p>然后通过如下方式获取一个数据库，如果要获取的数据库本身就存在，直接获取到，不存在 MongoDB 会自动创建：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoDatabase sang = client.getDatabase(<span class="hljs-string">"sang"</span>);</span><br></pre></td></tr></table></figure><p>然后通过如下方式获取一个名为c1的集合，这个集合存在的话就直接获取到，不存在的话 MongoDB 会自动创建出来，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoCollection&lt;Document&gt; c = sang.getCollection(<span class="hljs-string">"c1"</span>);</span><br></pre></td></tr></table></figure><p>有了集合之后，我们就可以向集合中插入数据了。</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>和在 shell 中的操作一样，我们可以一条一条的添加数据，也可以批量添加，添加单条数据操作如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Document d1 = <span class="hljs-keyword">new</span> Document();</span><br><span class="line">d1.append(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义"</span>).append(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>);</span><br><span class="line">c.insertOne(d1);</span><br></pre></td></tr></table></figure><p>添加多条数据的操作如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Document&gt; collections = <span class="hljs-keyword">new</span> ArrayList&lt;Document&gt;();</span><br><span class="line">Document d1 = <span class="hljs-keyword">new</span> Document();</span><br><span class="line">d1.append(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义"</span>).append(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>);</span><br><span class="line">collections.add(d1);</span><br><span class="line">Document d2 = <span class="hljs-keyword">new</span> Document();</span><br><span class="line">d2.append(<span class="hljs-string">"name"</span>, <span class="hljs-string">"红楼梦"</span>).append(<span class="hljs-string">"author"</span>, <span class="hljs-string">"曹雪芹"</span>);</span><br><span class="line">collections.add(d2);</span><br><span class="line">c.insertMany(collections);</span><br></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>可以修改查到的第一条数据，操作如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.updateOne(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>), <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"$set"</span>, <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义123"</span>)));</span><br></pre></td></tr></table></figure><p>上例中小伙伴们也看到了修改器要如何使用，不管是 $set 还是 $inc，用法都一致，我这里不再一个一个演示。也可以修改查到的所有数据，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.updateMany(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>), <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"$set"</span>, <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义456"</span>)));</span><br></pre></td></tr></table></figure><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>可以删除查到的一条数据，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.deleteOne(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>));</span><br></pre></td></tr></table></figure><p>也可以删除查到的所有数据：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.deleteMany(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>));</span><br></pre></td></tr></table></figure><p>Filters 里边还有其他的查询条件，都是见名知意，不赘述。</p><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>可以直接查询所有文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FindIterable&lt;Document&gt; documents = c.find();</span><br><span class="line">MongoCursor&lt;Document&gt; iterator = documents.iterator();</span><br><span class="line"><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以按照条件查询：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FindIterable&lt;Document&gt; documents = c.find(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>));</span><br><span class="line">MongoCursor&lt;Document&gt; iterator = documents.iterator();</span><br><span class="line"><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的方法基本都是见名知意，这里不再赘述。</p><h2 id="验证问题"><a href="#验证问题" class="headerlink" title="验证问题"></a>验证问题</h2><p>上面我们演示的获取一个集合是不需要登录 MongoDB 数据库的，如果需要登录，我们获取集合的方式改为下面这种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServerAddress serverAddress = <span class="hljs-keyword">new</span> ServerAddress(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">27017</span>);</span><br><span class="line">List&lt;MongoCredential&gt; credentialsList = <span class="hljs-keyword">new</span> ArrayList&lt;MongoCredential&gt;();</span><br><span class="line">MongoCredential mc = MongoCredential.createScramSha1Credential(<span class="hljs-string">"readuser"</span>,<span class="hljs-string">"sang"</span>,<span class="hljs-string">"123"</span>.toCharArray());</span><br><span class="line">credentialsList.add(mc);</span><br><span class="line">MongoClient client = <span class="hljs-keyword">new</span> MongoClient(serverAddress,credentialsList);</span><br><span class="line">MongoDatabase sang = client.getDatabase(<span class="hljs-string">"sang"</span>);</span><br><span class="line">c = sang.getCollection(<span class="hljs-string">"c1"</span>);</span><br></pre></td></tr></table></figure><p>MongoCredential 是一个凭证，第一个参数为用户名，第二个参数是要在哪个数据库中验证，第三个参数是密码的 char 数组，然后将登录地址封装成一个 ServerAddress，最后将两个参数都传入 MongoClient 中实现登录功能。</p><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>在连接数据库的时候也可以设置连接超时等信息，在MongoClientOptions中设置即可，设置方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerAddress serverAddress = <span class="hljs-keyword">new</span> ServerAddress(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">27017</span>);</span><br><span class="line">List&lt;MongoCredential&gt; credentialsList = <span class="hljs-keyword">new</span> ArrayList&lt;MongoCredential&gt;();</span><br><span class="line">MongoCredential mc = MongoCredential.createScramSha1Credential(<span class="hljs-string">"rwuser"</span>,<span class="hljs-string">"sang"</span>,<span class="hljs-string">"123"</span>.toCharArray());</span><br><span class="line">credentialsList.add(mc);</span><br><span class="line">MongoClientOptions options = MongoClientOptions.builder()</span><br><span class="line">        <span class="hljs-comment">//设置连接超时时间为10s</span></span><br><span class="line">        .connectTimeout(<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>)</span><br><span class="line">        <span class="hljs-comment">//设置最长等待时间为10s</span></span><br><span class="line">        .maxWaitTime(<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>)</span><br><span class="line">        .build();</span><br><span class="line">MongoClient client = <span class="hljs-keyword">new</span> MongoClient(serverAddress,credentialsList,options);</span><br><span class="line">MongoDatabase sang = client.getDatabase(<span class="hljs-string">"sang"</span>);</span><br><span class="line">c = sang.getCollection(<span class="hljs-string">"c1"</span>);</span><br></pre></td></tr></table></figure><p>好了，Java 操作 MongoDB 我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们介绍的 MongoDB 的操作都是在 shell 命令中写的，在项目开发时我们当然都是用程序去操作 MongoDB 的，本文我们来看看如何用 Java 代码操作 MongoDB。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>初识 MongoDB 分片</title>
    <link href="http://www.javaboy.org/2019/0918/mongodb-shard.html"/>
    <id>http://www.javaboy.org/2019/0918/mongodb-shard.html</id>
    <published>2019-09-18T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:06.693Z</updated>
    
    <content type="html"><![CDATA[<p>分片是指将数据拆分，拆分后存放在不同的机器上的过程，以此来降低单个服务器的压力，同时也解决单个服务器硬盘空间不足的问题，让我们可以用廉价的机器实现高性能的数据架构。</p><a id="more"></a><p>有的小伙伴不理解分片和副本集的差异，一言以蔽之：副本集上每个备份节点存储的数据都是相同的，分片上存储的数据则是不同的。好了，本文我们就先来看看分片环境的搭建。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>准备三台已经装好了 MongoDB 的服务器，地址分别是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128</span><br><span class="line">192.168.248.135</span><br><span class="line">192.168.248.136</span><br></pre></td></tr></table></figure><p>本文使用的 MongoDB 版本为 3.4.9</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>首先我们需要三台配置服务器，配置服务器相当于集群的大脑，配置服务器中保存着集群和分片的元数据，即每个分片都包含了哪些数据信息，这些数据都是保存在配置服务器中的，我这里将开启三个配置服务器实例，这三个配置服务器将运行在三个 MongoDB 服务器上，地址分别如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128:20000</span><br><span class="line">192.168.248.135:20000</span><br><span class="line">192.168.248.136:20000</span><br></pre></td></tr></table></figure><p>接下来需要一个 Mongos 实例，Mongos 对请求进行路由，Mongos 扮演的角色有点类似于一个门面，我们以后访问的时候，直接访问 Mongos 即可，再由 Mongos 将请求路由到不同的分片上去，Mongos 在启动时会去访问配置服务器，它将从配置服务器中获取数据的存储信息，Mongos 我将启动在如下服务器上：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128:30000</span><br></pre></td></tr></table></figure><p>最后需要三个分片实例，三个分片依然运行在三台服务器上，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128:27017</span><br><span class="line">192.168.248.135:27017</span><br><span class="line">192.168.248.136:27017</span><br></pre></td></tr></table></figure><h2 id="搭建配置服务器"><a href="#搭建配置服务器" class="headerlink" title="搭建配置服务器"></a>搭建配置服务器</h2><p>配置服务器中不需要太多的空间和资源，因为配置服务器上保存的只是数据的分布表，不保存具体的数据，具体的数据都保存在分片上，配置服务器中 1KB 的空间约为 200MB 的真实数据。<strong>注意，从 MongoDB3.4 开始，配置服务器要做成集群的方式。</strong></p><p>由于配置服务器是独立的 mongod 进程，所以我们可以像启动普通的 MongoDB 服务一样启动配置服务器，只是这里的配置不同罢了。</p><p>我这里以 <code>192.168.248.128</code> 服务器为例来讲述配置服务器的配置启动，另外两台服务器如法炮制即可：</p><ol><li>在 mongodb 解压目录下创建 db20000 文件夹，用来存储配置服务器中的数据。</li><li>复制一份 mongodb.conf，命名为 mongodb20000.conf，修改文件内容如下：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/opt/mongodb/db20000</span><br><span class="line">logpath=/opt/mongodb/logs/mongodb20000.log</span><br><span class="line">port=20000</span><br><span class="line">fork=true</span><br><span class="line">configsvr=true</span><br><span class="line">replSet=rs</span><br></pre></td></tr></table></figure><p>注意 dbpath 改为我们第一步创建的目录，端口号改为 20000 （这个随意，只要该端口没被占用即可）， configsvr 表示这是一个配置服务器，另外由于我们的配置服务器要做成备份集，所以要设置 replSet。</p><p>3.做好前两步之后，执行如下命令启动配置服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /opt/mongodb/bin/mongodb20000.conf</span><br></pre></td></tr></table></figure><p>最后，在另外两台服务器上重复上面三个步骤。</p><p>三台服务器上都启动成功之后，参考我们之前的<a href>MongoDB 副本集搭建</a>一文，将这三台配置服务器配成一个副本集，副本集的配置我这里就不再赘述。</p><h2 id="搭建Mongos"><a href="#搭建Mongos" class="headerlink" title="搭建Mongos"></a>搭建Mongos</h2><p>Mongos 实例我们可以启动在任意一台服务器上，我这里就启动在 <code>192.168.248.128</code>上，Mongos 的配置步骤如下：</p><p>1.复制一份 mongodb.conf，命名为 mongos.conf，修改内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logpath=/opt/mongodb/logs/mongos.log</span><br><span class="line">port=30000</span><br><span class="line">fork=true</span><br><span class="line">configdb=rs/192.168.248.128:20000,192.168.248.135:20000,192.168.248.136:20000</span><br></pre></td></tr></table></figure><p>因为 mongos 中不需要保存数据，所以不需要 dbpath，端口号改为 30000，configdb 表示三个配置服务器的地址，注意最前面的 rs 表示配置服务器副本集的名称。</p><p>2.配置完成后，执行如下命令启动 mongos:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongos -f /opt/mongodb/bin/mongos.conf</span><br></pre></td></tr></table></figure><h2 id="搭建三个分片"><a href="#搭建三个分片" class="headerlink" title="搭建三个分片"></a>搭建三个分片</h2><p>三个分片实际上就是三个普通的 MongoDB 服务器，给大家看下我的配置文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/opt/mongodb/db</span><br><span class="line">logpath=/opt/mongodb/logs/mongodb.log</span><br><span class="line">port=27017</span><br><span class="line">fork=true</span><br><span class="line">shardsvr=true</span><br></pre></td></tr></table></figure><p>注意多了个 shardsvr 表示这是一个分片服务器。<br>然后在三台服务器上分别执行如下命令启动分片：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /opt/mongodb/bin/mongodb.conf</span><br></pre></td></tr></table></figure><h2 id="添加分片"><a href="#添加分片" class="headerlink" title="添加分片"></a>添加分片</h2><p>上面三个步骤完成之后，我们就进入到 mongos 的 shell 命令行了，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port=30000</span><br></pre></td></tr></table></figure><p>然后我们可以通过如下命令查看一下分片的当前状态：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.status()</span><br></pre></td></tr></table></figure><p>执行结果如下(部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">  databases:</span><br></pre></td></tr></table></figure><p>shards 表示分片服务器，目前还没有，databases 表示分片的库，目前也还没有，接下来我们通过如下命令添加分片服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh.addShard(&quot;192.168.248.128:27017&quot;)</span><br><span class="line">sh.addShard(&quot;192.168.248.135:27017&quot;)</span><br><span class="line">sh.addShard(&quot;192.168.248.136:27017&quot;)</span><br></pre></td></tr></table></figure><p>添加三个分片服务器，然后再执行 <code>sh.status()</code>,结果如下(部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;192.168.248.128:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;192.168.248.135:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0002&quot;,  &quot;host&quot; : &quot;192.168.248.136:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard0000&quot;,  &quot;partitioned&quot; : false &#125;</span><br></pre></td></tr></table></figure><h2 id="设置集合分片"><a href="#设置集合分片" class="headerlink" title="设置集合分片"></a>设置集合分片</h2><p>接下来我们来设置集合的分片，首先执行如下命令表示给某个数据库分片：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.enableSharding(&quot;sang&quot;)</span><br></pre></td></tr></table></figure><p>对集合分片时，需要选择一个片键，片键实际上就是集合中的一个键，MongoDB 将根据这个片键来拆分数据，我们需要先对片键建立索引，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.c1.ensureIndex(&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>然后以 x 为片键，对 c1 集合进行分片，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.shardCollection(&quot;sang.c1&quot;,&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>做完这些之后，再执行 <code>sh.status()</code> 命令，查看目前状态，结果如下(部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;192.168.248.128:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;192.168.248.135:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0002&quot;,  &quot;host&quot; : &quot;192.168.248.136:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard0000&quot;,  &quot;partitioned&quot; : false &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;sang&quot;,  &quot;primary&quot; : &quot;shard0001&quot;,  &quot;partitioned&quot; : true &#125;</span><br><span class="line">                sang.c1</span><br><span class="line">                        shard key: &#123; &quot;x&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard0001       1</span><br><span class="line">                        &#123; &quot;x&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;x&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard0001 Timestamp(1, 0)</span><br></pre></td></tr></table></figure><p>做完上面这些之后，我们再做两个操作：</p><p>1.设置自动分片：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.setBalancerState(true)</span><br></pre></td></tr></table></figure><p>2.设置 chunksize,chunksize 这一项是用来指定 chunk 的大小的，为了方便测试分片效果，我们把 chunksize 指定为 1MB，即当这个分片中插入的数据大于 1M 时开始进行数据分片</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.settings.save(&#123;_id:&quot;chunksize&quot;,value:1&#125;)</span><br></pre></td></tr></table></figure><p>OK，做好这些之后，大功告成。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试方式很简单，我们直接在 mongos 的命令行向 sang 的 c1 集合中插入 50000 条数据，然后再查看这些数据的分布，就知道分片有没有成功了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;50000;i++)&#123;db.c1.insert(&#123;x:Math.random()*1000000,name:&quot;hahah&quot;+i&#125;)&#125;</span><br></pre></td></tr></table></figure><p>然后执行 <code>db.c1.stats()</code> ,结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="hljs-attr">"sharded"</span> : <span class="hljs-literal">true</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">50000</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">2688890</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">1781760</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">1978368</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"nchunks"</span> : <span class="hljs-number">5</span>,</span><br><span class="line"><span class="hljs-attr">"shards"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"shard0000"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">926504</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">17229</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">462848</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">516096</span>,</span><br><span class="line"><span class="hljs-attr">"indexSizes"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"_id_"</span> : <span class="hljs-number">184320</span>,</span><br><span class="line"><span class="hljs-attr">"x_1"</span> : <span class="hljs-number">331776</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"ok"</span> : <span class="hljs-number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"shard0001"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">392593</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">7299</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">667648</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">737280</span>,</span><br><span class="line"><span class="hljs-attr">"indexSizes"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"_id_"</span> : <span class="hljs-number">253952</span>,</span><br><span class="line"><span class="hljs-attr">"x_1"</span> : <span class="hljs-number">483328</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"ok"</span> : <span class="hljs-number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"shard0002"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">1369793</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">25472</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">651264</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">724992</span>,</span><br><span class="line"><span class="hljs-attr">"indexSizes"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"_id_"</span> : <span class="hljs-number">237568</span>,</span><br><span class="line"><span class="hljs-attr">"x_1"</span> : <span class="hljs-number">487424</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"ok"</span> : <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，看到如上结果，说明我们的数据已经分布在三个分片服务器中了。</p><p>好了，MongoDB 中分片环境的搭建我们就先说到这里，小伙伴们有问题欢迎留言讨论。<br>参考资料：</p><ol><li>《MongoDB权威指南第2版》 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分片是指将数据拆分，拆分后存放在不同的机器上的过程，以此来降低单个服务器的压力，同时也解决单个服务器硬盘空间不足的问题，让我们可以用廉价的机器实现高性能的数据架构。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>一个小小的里程碑！啥也不说了，签名书奉上！</title>
    <link href="http://www.javaboy.org/2019/0917/official-accounts-20000.html"/>
    <id>http://www.javaboy.org/2019/0917/official-accounts-20000.html</id>
    <published>2019-09-17T05:06:41.000Z</published>
    <updated>2019-09-21T06:04:43.642Z</updated>
    
    <content type="html"><![CDATA[<p>就在昨天，松哥的公众号【江南一点雨】迎来了第 20000 个读者，算是一个小小的里程碑吧。</p><a id="more"></a><p>距离公众号读者到达 10000 差不多过去三个月了，3 个月时间，用户又增加了 10000，很多小伙伴可能不知道，我在今年 3 月份的时候，公众号的读者才只有 5200+，到现在差不多半年时间，用户增长了 15000，今天我想和大家聊聊我的运营故事。</p><p>故事很简单，无非就是<strong>死撑</strong>二字。</p><h3 id="漫不经心的开始"><a href="#漫不经心的开始" class="headerlink" title="漫不经心的开始"></a>漫不经心的开始</h3><p>我是在 2017 年 2 月 19 号申请的公众号，到 2019 年 1 月 31 号的时候，公众号的用户才终于突破 5000，这 5000+ 小伙伴基本上都是看了我的博客或者开源项目关注了我的公众号。我觉得早期关注我的小伙伴真的很不容易，因为那个时候，我公众号基本上都是连着更一两个月，然后又歇好几个月，歇几个月之后，又开始更，断断续续的，在这样的状态下还没有取关，真爱无疑。</p><p>这一段时间里，我没有专门去运营公众号，也是因为不懂公众号要怎么运营，公众号在我眼里就只是一个类似于 CSDN、sf 那样的博客发布平台而已，我甚至傻傻的想着通过公众号里边的阅读原文增加博客的访问量。不得不说，松哥在运营公众号这事上后知后觉没有一丁点的天赋。</p><p>基于这样不成熟的想法，这一段时间也谈不上坚持，就是顺其自然，心情好了发几篇，心情不好了就断更几个月。</p><h3 id="下定决心"><a href="#下定决心" class="headerlink" title="下定决心"></a>下定决心</h3><p>今年 3 月份，华为云组织了云享专家的线下活动，活动中认识了微笑哥（公众号：纯洁的微笑），活动结束后和微笑哥一起吃了个饭，听他讲做公众号的事，感觉很有意思，也极大的吸引到我。于是当天晚上回到家，我就下定决心今年要好好做我的公众号。</p><h3 id="小号的倔强"><a href="#小号的倔强" class="headerlink" title="小号的倔强"></a>小号的倔强</h3><p>下定决心后，真正要动手的时候，我却发现没有头绪。我只有 5000+ 读者，一篇原创技术干货只有 200 左右的阅读，怎么办？这时候是我最缺乏信心的时候，因为我也不知道我是否适合做这个事。虽然我从大学毕业那年就开始写博客，但是把公众号当成一件事认认真真去做，还是有些不够自信。</p><p>刚好那段时间，我写了一篇文章，回忆了一路坚持写博客，再到最后出书的历程(<a href="https://mp.weixin.qq.com/s/Lr5CwOSqYvx-JrFCSGf_Dw" target="_blank" rel="noopener">起早贪黑几个月，我写完了人生第一本书！</a>)，在写这篇文章的时候，我就在想，当初决定要写博客，其实也不知道写了之后有没有用，就是觉得时间不能浪费，于是就开干了，写博客这事是典型的坚持了之后才看到希望。那么做公众号是否也一样？把当初写博客的那股劲用到写公众号上，先坚持几个月，看看到底怎么样，就这样，我慢慢的说服了自己，不要怂，就是干。</p><p>做公众号虽然有很多运营技巧，但其实最关键的就是内容，没有内容，再多技巧都是白搭，对于像松哥这样的小号而言，内容就更显得重要了，所以我从一开始就下定决心，要坚持做原创，实际上从 2017 年到 2019 年 3 月份，我的公众号上基本都是原创技术干货，而且我几乎很少写零散的问题解决方案，基本上都是成体系的教程，例如：</p><ul><li><a href="https://mp.weixin.qq.com/s/RqGddTAfIxSZOhfkjqhMFg" target="_blank" rel="noopener">Spring Cloud 系列</a></li><li><a href="https://mp.weixin.qq.com/s/0Bukv4bFGMWosG8SWWoDDw" target="_blank" rel="noopener">Redis 系列</a></li><li><a href="https://mp.weixin.qq.com/s/WSloXbauYnecGTFWizH9HQ" target="_blank" rel="noopener">Git 系列</a></li><li><a href="https://mp.weixin.qq.com/s/8L-RMZorVAFVamzncVTQBw" target="_blank" rel="noopener">MongoDB 系列</a></li><li><a href="https://mp.weixin.qq.com/s/8d3OxnGX17ik1g7H_ocwIA" target="_blank" rel="noopener">Elasticsearch 系列</a></li><li><a href="https://mp.weixin.qq.com/s/bAL90MQvSM1SJsye_LQ5Nw" target="_blank" rel="noopener">Docker 系列</a></li></ul><p>这些系列教程都是我一个字一个字码出来的。于是我就想继续延续我公众号原创的这一优良传统。</p><p>于是，<strong>从今年 3 月份到现在，一共发了 106 篇原创</strong>，这些原创主要围绕 Spring Boot 和前后端分离来写的(例如 <a href="https://mp.weixin.qq.com/s/tm1IqiEvRZwDAb-F5yJ5Aw" target="_blank" rel="noopener">Spring Boot 系列</a>)，当然也有一个小小的 MyCat 系列，这些松哥以后都会给大家整理好。</p><p>由于一直坚持原创，公众号的阅读数也慢慢上来了，从 200 到 300、500、700、1000….直到现在的 2000 左右，不断增长的阅读给了我继续做下去的信心。</p><h3 id="全靠死撑"><a href="#全靠死撑" class="headerlink" title="全靠死撑"></a>全靠死撑</h3><p>然而写原创并不容易，特别是写出一篇皆大欢喜的原创更难。今天的文章发了，就得琢磨明天发啥，明天的准备好了，又得琢磨后天发发啥，每天晚上写到 12 点如同家常便饭，因为一篇文章不是把几百个字码出来就完事了，你要写案例，写 Demo，然后运行 Demo，截图保存，然后在文章中使用，这个过程费时费力，一篇原创干货往往要好几个小时才能出炉。</p><p>松哥写原创技术文最疯狂的时候，差不多连续两个月，篇篇原创，大家可以翻一下 4 月到 7 月的文章。那个时候我经常一坐好几个小时，坐久了腰疼屁股疼，最近买了个升降桌，情况才得以慢慢缓解。</p><p>松哥并不是全职做公众号，白天和大部分小伙伴一样，松哥也要上班，晚上回家后，除了写公众号上的技术文章之外，还有很多其他的事情要做。3-6 月份期间，应慕课网邀请，我和微笑哥一起在慕课网上出了一个 Spring Cloud 微服务开发实践 的专栏，那段时间，晚上除了写公众号，还要写专栏，周末也是一样。专栏在六月份完工之后，七月份松哥又开始录制 Spring Boot + 微人事 的视频教程，这个教程目前还在录制中，没有完工，所以我基本上没有什么业余活动，周末也是正常作息，时间都是一分一分抠出来的，除了偶尔去游个泳。</p><p>七月底的时候，实在是有点扛不住了，那段时间状态很差，做事效率也很低，但看着每天增长的数据，实在不忍心放弃，最终还是坚持了下来。</p><h3 id="不得不说的广告"><a href="#不得不说的广告" class="headerlink" title="不得不说的广告"></a>不得不说的广告</h3><p>做公众号这段时间，松哥前前后后算起来一共就接过 4 个商业广告，老实说，这个数字在我目前这个同量级的号主中算是很少了，很少的原因不是因为我接不到广告，相反，随着号越来越大，找上门的广告主其实挺多的，每天公众号后台都有很多广告主留言，只不过基本上都被我拒绝掉了。</p><p>但是有的时候松哥推荐其他号主，这个还是希望大家能理解，因为做公众号，或者说写一篇技术干货，从松哥的角度来说，当然是希望文章被越多的人看到越好，毕竟几个小时产出一篇技术干货，结果就十来个人看了，自己心里都凉透了，写作的动力也会减弱，而公众号本身是一个封闭的平台，通过其他号主的推荐，显然可以有效的将自己的文章曝光给更多的小伙伴，因此这个还是希望小伙伴们能多多理解。</p><h3 id="革命尚未成功，同志仍需努力"><a href="#革命尚未成功，同志仍需努力" class="headerlink" title="革命尚未成功，同志仍需努力"></a>革命尚未成功，同志仍需努力</h3><p>松哥经历过公司倒闭，技术栈也从当年如日中天的 Android 切换到如今的 JavaEE，深知这个行业虽然薪水高，但是高处不胜寒，技术之路不进则退，那些火爆一时的技术，让人眼花缭乱的薪水，极有可能冲昏你的头脑，当潮水退去，日子最难过的就是技术菜鸟了。所以，Coding 与学习之路不能停下来，这也是我一直坚持写博客的原因之一，写完一篇博客就会感觉到充实，要是长时间没写，会有很强烈的不安全感，似乎要被技术同行抛弃了。</p><p>自从松哥开始认真做公众号，也认识了很多同行，我最近发现 4 月份认识的公众号主有好几个人都停更了，说明做公众号这个事确实不易。很多时候你都不用拼智商、拼资源、拼人脉，靠死撑，就能够超过很多同行了。</p><p>当然我也希望自己能把做公众号这件事认真坚持下去。小伙伴平时看到了合胃口的文章，顺手点个在看我就很开心啦，如果还能转发一下，那松哥就要膨胀了。</p><p>好了，和大家又叨叨了这么多，最后，5 本松哥自己的签名书《Spring Boot + Vue 全栈开发实战》送给经常来公众号打卡的小伙伴。</p><p>送书规则：大家留言说说<strong>你坚持做的最久的一件事</strong>，我会挑选出 5 位幸运读者，签名版《Spring Boot + Vue 全栈开发实战》包邮到家。也欢迎各位小伙伴多来公众号打卡学习哦，可以有效提高送书时的获奖概率哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;就在昨天，松哥的公众号【江南一点雨】迎来了第 20000 个读者，算是一个小小的里程碑吧。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB副本集其他细节</title>
    <link href="http://www.javaboy.org/2019/0917/mongodb-replicaset-details.html"/>
    <id>http://www.javaboy.org/2019/0917/mongodb-replicaset-details.html</id>
    <published>2019-09-17T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:13.050Z</updated>
    
    <content type="html"><![CDATA[<p>副本集环境的搭建以及一些基本的操作我们都了解了，本文我们来看看这个数据复制到底是怎么实现的。</p><a id="more"></a><h2 id="数据同步方式"><a href="#数据同步方式" class="headerlink" title="数据同步方式"></a>数据同步方式</h2><p>MongoDB 中的复制功能主要是使用操作日志 oplog.rs 来实现的，oplog.rs 包含了主节点的每一次写操作，oplog.rs 是主节点中 local 数据库的一个固定集合，我们可以通过如下命令查看到：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use local</span><br><span class="line">show tables</span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://www.javaboy.org/images/mongodb/17-1.png" alt="p254"></p><p>备份节点通过查询这个集合就知道要复制哪些数据，同时，每一个备份节点也都维护着自己的 oplog.rs，自己的 oplog.rs 则用来记录每一次从主节点复制数据的操作，如此，每一个备份节点都可以再作为数据源提供给其他成员使用，如果某一个备份节点在使用的过程中挂掉了，那么当它重启之后，会自动从 oplog.rs 的最后一个操作开始同步。</p><p>上文我们也已经说过 oplog.rs 是一个固定集合，我们可以通过 <code>db.getCollection(&#39;oplog.rs&#39;).stats()</code> 这个命令来查看这个固定集合的属性，包括集合大小等，执行部分结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"ns"</span> : <span class="hljs-string">"local.oplog.rs"</span>,</span><br><span class="line">    <span class="hljs-attr">"size"</span> : <span class="hljs-number">18170305</span>,</span><br><span class="line">    <span class="hljs-attr">"count"</span> : <span class="hljs-number">177443</span>,</span><br><span class="line">    <span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">102</span>,</span><br><span class="line">    <span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">5902336</span>,</span><br><span class="line">    <span class="hljs-attr">"capped"</span> : <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"max"</span> : <span class="hljs-number">-1</span>,</span><br><span class="line">    <span class="hljs-attr">"maxSize"</span> : <span class="hljs-number">1038090240</span>,</span><br><span class="line">    <span class="hljs-attr">"sleepCount"</span> : <span class="hljs-number">0</span>,</span><br><span class="line">    <span class="hljs-attr">"sleepMS"</span> : <span class="hljs-number">0</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是固定集合，它里边能够保存的数据大小就是有限的。通常，oplog.rs 使用空间的增长速度与系统处理处理写请求的速率近乎相同，比如主节点每分钟处理了 1KB 的写入请求，那么 oplog.rs 也可能会在一分钟内写入 1KB 条操作日志，但是如果主节点执行了批量删除的命令，比如下面这种：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.c1.deleteMany(&#123;x:&#123;$type:1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时每一个受影响的文档都会产生一条 oplog 中的日志，这个时候 oplog.rs 中的日志会快速增加。</p><h2 id="成员状态"><a href="#成员状态" class="headerlink" title="成员状态"></a>成员状态</h2><p>到目前为止我们了解到的成员状态有两种，一个是 PRIMARY ，还有一个是 SECONDDARY ，成员状态的获取需要靠心跳来维护，副本集中的每一个成员每隔两秒就会向其他成员发送一个心跳请求，用来检查成员的状态，成员的状态主要有如下几种：</p><h4 id="STARTUP"><a href="#STARTUP" class="headerlink" title="STARTUP"></a>STARTUP</h4><p>副本集中的成员刚刚启动时处于这个状态下，此时，MongoDB 会去加载成员的副本集配置，配置加载成功之后，就进入到 STARTUP2 的状态。</p><h4 id="STARTUP2"><a href="#STARTUP2" class="headerlink" title="STARTUP2"></a>STARTUP2</h4><p>整个初始化同步过程都处于这个状态。</p><h4 id="RECOVERING"><a href="#RECOVERING" class="headerlink" title="RECOVERING"></a>RECOVERING</h4><p>这个状态是由 STARTUP2 状态来的，此时成员运转正常，但是此时还不能处理读取请求。</p><h4 id="ARBITER"><a href="#ARBITER" class="headerlink" title="ARBITER"></a>ARBITER</h4><p>这是仲裁者所处的状态。</p><h4 id="DOWN"><a href="#DOWN" class="headerlink" title="DOWN"></a>DOWN</h4><p>当一个原本运行正常的成员无法访问到时，该成员就处于 DOWN 的状态。</p><h4 id="UNKNOWN"><a href="#UNKNOWN" class="headerlink" title="UNKNOWN"></a>UNKNOWN</h4><p>如果一个成员无法到达其他任何成员，该成员就处于 UNKNOWN 状态，比如我们利用 rs.add() 方法添加一个不存在的成员，这个成员的状态就是 UNKNOWN。</p><h4 id="REMOVED"><a href="#REMOVED" class="headerlink" title="REMOVED"></a>REMOVED</h4><p>成员被从副本集中移除时就变成这个状态。</p><h4 id="ROLLBACK"><a href="#ROLLBACK" class="headerlink" title="ROLLBACK"></a>ROLLBACK</h4><p>如果成员正在进行数据回滚，它就处于 ROLLBACK 状态，回滚结束后会转换为 RECOVERING 状态。</p><h4 id="FATAL"><a href="#FATAL" class="headerlink" title="FATAL"></a>FATAL</h4><p>当一个成员发生了不可挽回的错误时，且不再尝试恢复正常的话，就处于这个状态。</p><h2 id="主节点转备份节点"><a href="#主节点转备份节点" class="headerlink" title="主节点转备份节点"></a>主节点转备份节点</h2><p>通过如下命令可以让主节点转为备份节点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.stepDown()</span><br></pre></td></tr></table></figure><p>主节点转为备份节点之后会有新的主节点被选举出来，可以通过 rs.status() 来查看新的主节点。</p><h2 id="rs-status-方法"><a href="#rs-status-方法" class="headerlink" title="rs.status()方法"></a>rs.status()方法</h2><p>前面我们已经多次使用过 rs.status() 方法， rs.status() 方法会列出每个备份节点的含义，我们来看看这些参数的含义，先来列出一个 rs.status() 方法的返回值样例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;members&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;_id&quot; : 1,</span><br><span class="line">        &quot;name&quot; : &quot;192.168.248.135:27017&quot;,</span><br><span class="line">        &quot;health&quot; : 1,</span><br><span class="line">        &quot;state&quot; : 2,</span><br><span class="line">        &quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class="line">        &quot;uptime&quot; : 241,</span><br><span class="line">        &quot;optime&quot; : &#123;</span><br><span class="line">                &quot;ts&quot; : Timestamp(1509881297, 1),</span><br><span class="line">                &quot;t&quot; : NumberLong(16)</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;optimeDurable&quot; : &#123;</span><br><span class="line">                &quot;ts&quot; : Timestamp(1509881297, 1),</span><br><span class="line">                &quot;t&quot; : NumberLong(16)</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;optimeDate&quot; : ISODate(&quot;2017-11-05T11:28:17Z&quot;),</span><br><span class="line">        &quot;optimeDurableDate&quot; : ISODate(&quot;2017-11-05T11:28:17Z&quot;),</span><br><span class="line">        &quot;lastHeartbeat&quot; : ISODate(&quot;2017-11-05T11:28:18.073Z&quot;),</span><br><span class="line">        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-11-05T11:28:18.769Z&quot;),</span><br><span class="line">        &quot;pingMs&quot; : NumberLong(0),</span><br><span class="line">        &quot;syncingTo&quot; : &quot;192.168.248.136:27017&quot;,</span><br><span class="line">        &quot;configVersion&quot; : 15</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;_id&quot; : 3,</span><br><span class="line">        &quot;name&quot; : &quot;192.168.248.136:27017&quot;,</span><br><span class="line">        &quot;health&quot; : 1,</span><br><span class="line">        &quot;state&quot; : 1,</span><br><span class="line">        &quot;stateStr&quot; : &quot;PRIMARY&quot;,</span><br><span class="line">        &quot;uptime&quot; : 250,</span><br><span class="line">        &quot;optime&quot; : &#123;</span><br><span class="line">                &quot;ts&quot; : Timestamp(1509881297, 1),</span><br><span class="line">                &quot;t&quot; : NumberLong(16)</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;optimeDate&quot; : ISODate(&quot;2017-11-05T11:28:17Z&quot;),</span><br><span class="line">        &quot;electionTime&quot; : Timestamp(1509881276, 1),</span><br><span class="line">        &quot;electionDate&quot; : ISODate(&quot;2017-11-05T11:27:56Z&quot;),</span><br><span class="line">        &quot;configVersion&quot; : 15,</span><br><span class="line">        &quot;self&quot; : true</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>stateStr用来描述当前节点的状态。</li><li>uptime表示从成员可达到现在所经历的时间。</li><li>optimeDate表示每个成员的oplog中最后一个操作发生的时间。</li><li>lastHeartbeat表示当前服务器最后一次收到其他成员心跳的时间。</li><li>pingMs表示心跳从当前服务器到达某个成员所花费的平均时间。</li><li>syncingTo表示同步的数据源。</li><li>health表示该服务器是否可达，1表示可达，0表示不可达。</li></ol><h2 id="复制链问题"><a href="#复制链问题" class="headerlink" title="复制链问题"></a>复制链问题</h2><p>数据复制时可以从主节点直接复制，也可以从备份节点开始复制，从备份节点复制可以形成复制链，如果想禁止复制链，即所有的数据都从主节点复制，可以通过 chainingAllowed 属性来设置，具体步骤如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config=rs.config()</span><br><span class="line">config.settings.chainingAllowed=false</span><br><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><p>好了，MongoDB 中副本集的其他细节我们就先说到这里，小伙伴们有问题欢迎留言讨论。<br>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;副本集环境的搭建以及一些基本的操作我们都了解了，本文我们来看看这个数据复制到底是怎么实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 副本集配置</title>
    <link href="http://www.javaboy.org/2019/0916/mongodb-replicaset-settings.html"/>
    <id>http://www.javaboy.org/2019/0916/mongodb-replicaset-settings.html</id>
    <published>2019-09-16T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:18.751Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们搭建了 MongoDB 副本集的环境，验证了数据已经可以成功的复制，本文我们就来看看 MongoDB 副本集的其他操作。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>三台服务器，地址分别是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128</span><br><span class="line">192.168.248.135</span><br><span class="line">192.168.248.136</span><br></pre></td></tr></table></figure><p>按照上文介绍的步骤搭建副本集环境，这里不再赘述。</p><h2 id="副本集成员添加删除"><a href="#副本集成员添加删除" class="headerlink" title="副本集成员添加删除"></a>副本集成员添加删除</h2><p>在副本集环境搭建好之后，我们可以利用如下命令删除一个副本集成员：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.remove(&apos;192.168.248.128:27017&apos;)</span><br></pre></td></tr></table></figure><p>上面的命令执行完成后，我们可以通过 rs.status() 命令来查看是否删除成功，也可以通过如下命令来为副本集添加一个成员：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.add(&apos;192.168.248.128:27017&apos;)</span><br></pre></td></tr></table></figure><p>当然，副本集也是可以更新的，使用 reconfig 命令即可，如下：</p><p>首先定义 config，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config=&#123;_id:&quot;rs&quot;,members:[&#123;_id:3,host:&quot;192.168.248.128&quot;&#125;,&#123;_id:1,host:&quot;192.168.248.135&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>然后执行更新操作：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><p>我们也可以利用 config=rs.config() 获取原始的 config 文件，然后进行修改，修改之后再执行 rs.reconfig(config)，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config=rs.config()</span><br><span class="line">config.members[0].host=&quot;192.168.248.136&quot;</span><br><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><h2 id="选举仲裁者"><a href="#选举仲裁者" class="headerlink" title="选举仲裁者"></a>选举仲裁者</h2><p>在上文中给小伙伴们演示了主节点挂掉后的情况，和其他的(如 Redis )数据库主从复制不同，MongoDB 中主节点挂掉之后会自动从备份节点中选出一个新的主节点出来，这是一个选举的过程，投票选举，但是如果备份节点数为偶数的话，可能会出现两台服务器票数相等的情况，为了避免这种问题的出现，我们一般有两种解决方案：</p><blockquote><ol><li>数据节点为奇数个，这样就会避免上面描述的问题出现。</li><li>使用选举仲裁者，这是一种特殊的成员，仲裁者不保存数据，也不为客户端提供服务，只是在选举投票出现僵持时出来投个票，一个副本集中最多只能有一个仲裁者。</li></ol></blockquote><p>选举仲裁者占用的系统资源很小，因此对部署的服务器性能没多大要求，向副本集中添加仲裁者的方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.addArb(&apos;192.168.248.128:27017&apos;)</span><br></pre></td></tr></table></figure><p>也可以利用我们之前说的 reconfig 来操作：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config=rs.config()</span><br><span class="line">config.members[2]=&#123;_id:2,host:&apos;192.168.248.128&apos;,arbiterOnly:true&#125;</span><br><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><p>添加完成之后，我们可以通过 rs.status() 命令来查看是否添加成功，如果看到如下内容，表示添加成功：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="hljs-attr">"_id"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"name"</span> : <span class="hljs-string">"192.168.248.128:27017"</span>,</span><br><span class="line"><span class="hljs-attr">"health"</span> : <span class="hljs-number">1</span>,</span><br><span class="line"><span class="hljs-attr">"state"</span> : <span class="hljs-number">7</span>,</span><br><span class="line"><span class="hljs-attr">"stateStr"</span> : <span class="hljs-string">"ARBITER"</span>,</span><br><span class="line"><span class="hljs-attr">"uptime"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"lastHeartbeat"</span> : ISODate(<span class="hljs-string">"2017-11-03T08:56:12.406Z"</span>),</span><br><span class="line"><span class="hljs-attr">"lastHeartbeatRecv"</span> : ISODate(<span class="hljs-string">"2017-11-03T08:56:08.417Z"</span>),</span><br><span class="line"><span class="hljs-attr">"pingMs"</span> : NumberLong(<span class="hljs-number">1</span>),</span><br><span class="line"><span class="hljs-attr">"configVersion"</span> : <span class="hljs-number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仲裁者的移除和普通节点的移除是一样的，这里不再赘述。</p><h2 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h2><p>优先级用来描述一个备份节点成为主节点的优先性问题，优先级的取值范围为 [0-100]，默认为 1，数字越大优先级越高，越有可能成为主节点，0 表示该节点永远不能成为主节点。</p><p>我们可以在添加节点时指定优先级，如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.add(&#123;_id:0,host:&apos;192.168.248.128:27017&apos;,priority:2&#125;)</span><br></pre></td></tr></table></figure><p>也可以为已有的节点设置优先级：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config=rs.config()</span><br><span class="line">config.members[0].priority=99</span><br><span class="line">rs.reconfig(config)</span><br></pre></td></tr></table></figure><p>好了，MongoDB 中副本集的配置我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们搭建了 MongoDB 副本集的环境，验证了数据已经可以成功的复制，本文我们就来看看 MongoDB 副本集的其他操作。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 副本集搭建</title>
    <link href="http://www.javaboy.org/2019/0915/mongodb-replicaset-install.html"/>
    <id>http://www.javaboy.org/2019/0915/mongodb-replicaset-install.html</id>
    <published>2019-09-15T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:29.385Z</updated>
    
    <content type="html"><![CDATA[<p>我们之前的案例都是在单个节点上实现的，在生产环境中这种做法是有风险的，如果服务宕机、崩溃或者硬盘坏了都会对公司业务造成损失，因此我们需要数据备份。</p><a id="more"></a><p>在 MongoDB 中我们可以通过副本集来实现这一需求，MongoDB 副本集 (Replica Set) 是有自动故障恢复功能的主从集群，有一个 Primary 节点和一个或多个 Secondary 节点组成，如果 Primary 崩溃了，会自动从 Secondary 中选择一个将其升级为新的主服务器，本文我们先来看看副本集环境的搭建。</p><h2 id="单台服务器模拟"><a href="#单台服务器模拟" class="headerlink" title="单台服务器模拟"></a>单台服务器模拟</h2><p>我们在实际的生产环境中肯定是多台服务器部署，但是在自己学习过程中，我们可以在一台服务器上来模拟这个环境，这样可以简化我们的操作，让小伙伴们快速上手。下一小节我会和大家分享如何在真实的生产环境中创建副本集。</p><p>好了，开始吧。</p><p>首先我们在 Linux 根目录下创建 /data/db 目录作为我们的数据保存目录，然后执行如下命令启动一个 mongo shell：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --nodb</span><br></pre></td></tr></table></figure><p>–nodb 表示启动时不连接任何数据库，然后通过如下命令创建一个副本集：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaSet=new ReplSetTest(&#123;nodes:3&#125;)</span><br></pre></td></tr></table></figure><p>在创建的日志中，我们可以看到三个实例的端口号，我这里分别是 20000、20001、20002，此时我们的副本集创建好了，但是并未启动，接下来执行如下命令启动三个 mongodb 实例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaSet.startSet()</span><br></pre></td></tr></table></figure><p>再执行如下命令配置复制功能：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaSet.initiate()</span><br></pre></td></tr></table></figure><p>这样环境基本就配好了，此时当前的 shell 不要关闭，我们重新打开一个 Linux 命令窗口，执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo 192.168.248.128:20000/sang_1</span><br></pre></td></tr></table></figure><p>表示连接端口为 20000 的那个实例中的 sang_1 数据库，连接成功后，我们可以执行如下命令查看当前实例的身份，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.isMaster()</span><br></pre></td></tr></table></figure><p>返回的数据很多，其中有一条是 <code>&quot;ismaster&quot; : true</code>，表示这是一个主节点，此时我们再分别打开两个 Linux 窗口，分别执行如下两条命令，进入另外两个节点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongo 192.168.248.128:20001/sang_1</span><br><span class="line">mongo 192.168.248.128:20002/sang_1</span><br></pre></td></tr></table></figure><p>连接成功之后，依然可以通过 <code>db.isMaster()</code> 命令来查看备份节点的身份，我们发现此时 <code>&quot;ismaster&quot; : false</code>，表示这是一个备份节点，此时我们可以先做个简单的测试了，此时我在主节点(端口为 20000)那个节点上写一个文档，写完之后，我们看看其他副本集成员上是否有我刚才的写的文档的副本，执行命令顺序如下：</p><p>主节点写入数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collect1.insert(&#123;x:&quot;hahaha&quot;&#125;)</span><br></pre></td></tr></table></figure><p>任意一个副本节点，先执行如下命令表示可以从备份节点读取数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.setSlaveOk()</span><br></pre></td></tr></table></figure><p>然后再在备份节点中执行如下命令读取数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collect1.find()</span><br></pre></td></tr></table></figure><p>此时，我们发现数据已经备份成功了。</p><p>如果此时我们尝试向备份节点中直接写入文档，会发现写入失败，这里需要注意备份节点中的数据都是备份来的，不可以直接写入，想写入，除非等它的身份转为主节点才可以。</p><p>此时，我们尝试通过如下命令关闭主节点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.shutdownServer()</span><br></pre></td></tr></table></figure><p>然后查看两个备份节点的 db.isMaster(),发现有一个备份节点自动上位成为了主节点。</p><p>最后如果想关闭副本集，可以回到第一个shell命令行中，输入如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaSet.stopSet()</span><br></pre></td></tr></table></figure><h2 id="多台服务器模拟"><a href="#多台服务器模拟" class="headerlink" title="多台服务器模拟"></a>多台服务器模拟</h2><p>OK，以上操作是我们单台服务器模拟搭建副本集，方便我们做实验，在生产环境中，我们可能有多个服务器，多台服务器又要如何搭建副本集呢？各位看官继续向下看。</p><p>首先准备好三台装好了MongoDB的服务器，地址分别如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128</span><br><span class="line">192.168.248.135</span><br><span class="line">192.168.248.136</span><br></pre></td></tr></table></figure><p>修改每台服务器的配置文件 mongodb.conf，添加 replSet=rs，表示副本集的名称，修改后的配置文件内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/opt/mongodb/db</span><br><span class="line">logpath=/opt/mongodb/logs/mongodb.log</span><br><span class="line">port=27017</span><br><span class="line">fork=true</span><br><span class="line">replSet=rs</span><br></pre></td></tr></table></figure><p>修改完成之后，分别启动三台服务器上的 MongoDB，启动成功之后，连接上任意一台的 shell，连接成功之后，先定义配置文件，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config=&#123;_id:&quot;rs&quot;,members:[&#123;_id:0,host:&quot;192.168.248.128:27017&quot;&#125;,&#123;_id:1,host:&quot;192.168.248.135:27017&quot;&#125;,&#123;_id:2,host:&quot;192.168.248.136:27017&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>id 后面跟着的是副本集的名称，也就是我们在 mongodb.conf 中定义的名称，后面三个是副本集的成员，定义好之后，再执行如下命令初始化副本集：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure><p>初始化成功之后，我们就可以通过 rs.status() 来查看副本集的状态，也可以看到每个服务器的角色，部分日志内容如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="hljs-attr">"members"</span> : [</span><br><span class="line">&#123;</span><br><span class="line">        <span class="hljs-attr">"_id"</span> : <span class="hljs-number">0</span>,</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"192.168.248.128:27017"</span>,</span><br><span class="line">        <span class="hljs-attr">"health"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"state"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"stateStr"</span> : <span class="hljs-string">"PRIMARY"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">        <span class="hljs-attr">"_id"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"192.168.248.135:27017"</span>,</span><br><span class="line">        <span class="hljs-attr">"health"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"state"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"stateStr"</span> : <span class="hljs-string">"SECONDARY"</span>,</span><br><span class="line">        <span class="hljs-attr">"syncingTo"</span> : <span class="hljs-string">"192.168.248.128:27017"</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">        <span class="hljs-attr">"_id"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"192.168.248.136:27017"</span>,</span><br><span class="line">        <span class="hljs-attr">"health"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"state"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"stateStr"</span> : <span class="hljs-string">"SECONDARY"</span>,</span><br><span class="line">        <span class="hljs-attr">"syncingTo"</span> : <span class="hljs-string">"192.168.248.128:27017"</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到每台服务器的角色，有 primary，也有 secondary，secondary 上还注明了从哪个服务器上同步数据。所有这些工作做好之后，我们就可以按照上文介绍的方式来测一下这里的副本集了，测试工作我就不再重复介绍了。</p><p>好了，MongoDB 中副本集的搭建我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们之前的案例都是在单个节点上实现的，在生产环境中这种做法是有风险的，如果服务宕机、崩溃或者硬盘坏了都会对公司业务造成损失，因此我们需要数据备份。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 中 MapReduce 使用</title>
    <link href="http://www.javaboy.org/2019/0914/mongodb-in-mapreduce.html"/>
    <id>http://www.javaboy.org/2019/0914/mongodb-in-mapreduce.html</id>
    <published>2019-09-14T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:40.159Z</updated>
    
    <content type="html"><![CDATA[<p>玩过 Hadoop 的小伙伴对 MapReduce 应该不陌生，MapReduce 的强大且灵活，它可以将一个大问题拆分为多个小问题，将各个小问题发送到不同的机器上去处理，所有的机器都完成计算后，再将计算结果合并为一个完整的解决方案，这就是所谓的分布式计算。本文我们就来看看 MongoDB 中 MapReduce 的使用。</p><a id="more"></a><h2 id="mapReduce"><a href="#mapReduce" class="headerlink" title="mapReduce"></a>mapReduce</h2><p>MongoDB 中的 MapReduce 可以用来实现更复杂的聚合命令，使用 MapReduce 主要实现两个函数：map 函数和 reduce 函数，map 函数用来生成键值对序列， map 函数的结果作为 reduce 函数的参数，reduce 函数中再做进一步的统计，比如我的数据集如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908d7"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"呐喊"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">38.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"人民文学出版社"</span>&#125;</span><br><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908d8"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"曹雪芹"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"红楼梦"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">22.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"人民文学出版社"</span>&#125;</span><br><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908d9"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"钱钟书"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"宋诗选注"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">99.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"人民文学出版社"</span>&#125;</span><br><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908da"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"钱钟书"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"谈艺录"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">66.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"三联书店"</span>&#125;</span><br><span class="line">&#123;<span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59fa71d71fd59c3b2cd908db"</span>),<span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,<span class="hljs-attr">"book"</span> : <span class="hljs-string">"彷徨"</span>,<span class="hljs-attr">"price"</span> : <span class="hljs-number">55.0</span>,<span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"花城出版社"</span>&#125;</span><br></pre></td></tr></table></figure><p>假如我想查询每位作者所出的书的总价，操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,this.price)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return Array.sum(value)&#125;</span><br><span class="line">var options=&#123;out:&quot;totalPrice&quot;&#125;</span><br><span class="line">db.sang_books.mapReduce(map,reduce,options);</span><br><span class="line">db.totalPrice.find()</span><br></pre></td></tr></table></figure><p>emit 函数主要用来实现分组，接收两个参数，第一个参数表示分组的字段，第二个参数表示要统计的数据，reduce 来做具体的数据处理操作，接收两个参数，对应 emit 方法的两个参数，这里使用了 Array 中的 sum 函数对 price 字段进行自加处理，options 中定义了将结果输出的集合，届时我们将在这个集合中去查询数据，默认情况下，这个集合即使在数据库重启后也会保留，并且保留集合中的数据。查询结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">22.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">165.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">93.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如我想查询每位作者出了几本书，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,1)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return Array.sum(value)&#125;</span><br><span class="line">var options=&#123;out:&quot;bookNum&quot;&#125;</span><br><span class="line">db.sang_books.mapReduce(map,reduce,options);</span><br><span class="line">db.bookNum.find()</span><br></pre></td></tr></table></figure><p>查询结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">2.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-number">2.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将每位作者的书列出来，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,&apos;)&#125;</span><br><span class="line">var options=&#123;out:&quot;books&quot;&#125;</span><br><span class="line">db.sang_books.mapReduce(map,reduce,options);</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"红楼梦"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"宋诗选注,谈艺录"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"呐喊,彷徨"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如查询每个人售价在 ￥40 以上的书：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,&apos;)&#125;</span><br><span class="line">var options=&#123;query:&#123;price:&#123;$gt:40&#125;&#125;,out:&quot;books&quot;&#125;</span><br><span class="line">db.sang_books.mapReduce(map,reduce,options);</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>query 表示对查到的集合再进行筛选。</p><p>结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"宋诗选注,谈艺录"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"彷徨"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="runCommand实现"><a href="#runCommand实现" class="headerlink" title="runCommand实现"></a>runCommand实现</h2><p>我们也可以利用 runCommand 命令来执行 MapReduce。格式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(</span><br><span class="line">               &#123;</span><br><span class="line">                 mapReduce: &lt;collection&gt;,</span><br><span class="line">                 map: &lt;function&gt;,</span><br><span class="line">                 reduce: &lt;function&gt;,</span><br><span class="line">                 finalize: &lt;function&gt;,</span><br><span class="line">                 out: &lt;output&gt;,</span><br><span class="line">                 query: &lt;document&gt;,</span><br><span class="line">                 sort: &lt;document&gt;,</span><br><span class="line">                 limit: &lt;number&gt;,</span><br><span class="line">                 scope: &lt;document&gt;,</span><br><span class="line">                 jsMode: &lt;boolean&gt;,</span><br><span class="line">                 verbose: &lt;boolean&gt;,</span><br><span class="line">                 bypassDocumentValidation: &lt;boolean&gt;,</span><br><span class="line">                 collation: &lt;document&gt;</span><br><span class="line">               &#125;</span><br><span class="line">             )</span><br></pre></td></tr></table></figure><p>含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">mapReduce</td><td style="text-align:left">表示要操作的集合</td></tr><tr><td style="text-align:left">map</td><td style="text-align:left">map函数</td></tr><tr><td style="text-align:left">reduce</td><td style="text-align:left">reduce函数</td></tr><tr><td style="text-align:left">finalize</td><td style="text-align:left">最终处理函数</td></tr><tr><td style="text-align:left">out</td><td style="text-align:left">输出的集合</td></tr><tr><td style="text-align:left">query</td><td style="text-align:left">对结果进行过滤</td></tr><tr><td style="text-align:left">sort</td><td style="text-align:left">对结果排序</td></tr><tr><td style="text-align:left">limit</td><td style="text-align:left">返回的结果数</td></tr><tr><td style="text-align:left">scope</td><td style="text-align:left">设置参数值，在这里设置的值在map、reduce、finalize函数中可见</td></tr><tr><td style="text-align:left">jsMode</td><td style="text-align:left">是否将map执行的中间数据由javascript对象转换成BSON对象，默认为false</td></tr><tr><td style="text-align:left">verbose</td><td style="text-align:left">是否显示详细的时间统计信息</td></tr><tr><td style="text-align:left">bypassDocumentValidation</td><td style="text-align:left">是否绕过文档验证</td></tr><tr><td style="text-align:left">collation</td><td style="text-align:left">其他一些校对</td></tr></tbody></table><p>如下操作，表示执行 MapReduce 操作并对统计的集合限制返回条数，限制返回条数之后再进行统计操作，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,&apos;)&#125;</span><br><span class="line">db.runCommand(&#123;mapreduce:&apos;sang_books&apos;,map,reduce,out:&quot;books&quot;,limit:4,verbose:true&#125;)</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"红楼梦"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"宋诗选注,谈艺录"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : <span class="hljs-string">"呐喊"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小伙伴们看到，鲁迅有一本书不见了，就是因为 limit 是先限制集合返回条数，然后再执行统计操作。</p><p>finalize 操作表示最终处理函数，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function(key,reduceValue)&#123;var obj=&#123;&#125;;obj.author=key;obj.books=reduceValue; return obj&#125;</span><br><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,&apos;)&#125;</span><br><span class="line">db.runCommand(&#123;mapreduce:&apos;sang_books&apos;,map,reduce,out:&quot;books&quot;,finalize:f1&#125;)</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>f1 第一个参数 key 表示 emit 中的第一个参数，第二个参数表示 reduce 的执行结果，我们可以在 f1 中对这个结果进行再处理，结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"红楼梦"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"宋诗选注,谈艺录"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"呐喊,彷徨"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scope 则可以用来定义一个在 map、reduce 和 finalize 中都可见的变量，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f1 = function(key,reduceValue)&#123;var obj=&#123;&#125;;obj.author=key;obj.books=reduceValue;obj.sang=sang; return obj&#125;</span><br><span class="line">var map=function()&#123;emit(this.name,this.book)&#125;</span><br><span class="line">var reduce=function(key,value)&#123;return value.join(&apos;,--&apos;+sang+&apos;--,&apos;)&#125;</span><br><span class="line">db.runCommand(&#123;mapreduce:&apos;sang_books&apos;,map,reduce,out:&quot;books&quot;,finalize:f1,scope:&#123;sang:&quot;haha&quot;&#125;&#125;)</span><br><span class="line">db.books.find()</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"曹雪芹"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"红楼梦"</span>,</span><br><span class="line">        <span class="hljs-attr">"sang"</span> : <span class="hljs-string">"haha"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"钱钟书"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"宋诗选注,--haha--,谈艺录"</span>,</span><br><span class="line">        <span class="hljs-attr">"sang"</span> : <span class="hljs-string">"haha"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"value"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"author"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">        <span class="hljs-attr">"books"</span> : <span class="hljs-string">"呐喊,--haha--,彷徨"</span>,</span><br><span class="line">        <span class="hljs-attr">"sang"</span> : <span class="hljs-string">"haha"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，MongoDB 中的 MapReduce 我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li><li><a href="http://www.cnblogs.com/xiazh/archive/2012/09/05/2671730.html" target="_blank" rel="noopener">mongodb mapreduce小试</a></li><li><a href="http://blog.csdn.net/gaopeng0071/article/details/42027745" target="_blank" rel="noopener">mongoDB–mapreduce用法详解(未找到原始出处)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;玩过 Hadoop 的小伙伴对 MapReduce 应该不陌生，MapReduce 的强大且灵活，它可以将一个大问题拆分为多个小问题，将各个小问题发送到不同的机器上去处理，所有的机器都完成计算后，再将计算结果合并为一个完整的解决方案，这就是所谓的分布式计算。本文我们就来看看 MongoDB 中 MapReduce 的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 管道操作符(二)</title>
    <link href="http://www.javaboy.org/2019/0913/mongodb-pipelines.html"/>
    <id>http://www.javaboy.org/2019/0913/mongodb-pipelines.html</id>
    <published>2019-09-13T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:45.538Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中我们已经学习了 MongoDB 中几个基本的管道操作符，本文我们再来看看其他的管道操作符。</p><a id="more"></a><h2 id="group"><a href="#group" class="headerlink" title="$group"></a>$group</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>$group 可以用来对文档进行分组，比如我想将订单按照城市进行分组，并统计出每个城市的订单数量：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,count:&#123;$sum:1&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>我们将要分组的字段传递给 $group 函数的 <code>_id</code> 字段，然后每当查到一个，就给 count 加 1，这样就可以统计出每个城市的订单数量。</p><h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>通过算术操作符我们可以对分组后的文档进行求和或者求平均数。比如我想计算每个城市订单运费总和，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,totalFreight:&#123;$sum:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>先按地址分组，再求和。这里贴出部分查询结果，如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"HaiKou"</span>,</span><br><span class="line">    <span class="hljs-attr">"totalFreight"</span> : <span class="hljs-number">20.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : <span class="hljs-string">"HangZhou"</span>,</span><br><span class="line">    <span class="hljs-attr">"totalFreight"</span> : <span class="hljs-number">10.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以计算每个城市运费的平均数，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,avgFreight:&#123;$avg:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>先按地址分组，然后再计算平均数。</p><h3 id="极值操作符"><a href="#极值操作符" class="headerlink" title="极值操作符"></a>极值操作符</h3><p>极值操作符用来获取分组后数据集的边缘值，比如获取每个城市最贵的运费，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,maxFreight:&#123;$max:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>查询每个城市最便宜的运费：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,minFreight:&#123;$min:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>按城市分组之后，获取该城市第一个运费单：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,firstFreight:&#123;$first:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>获取分组后的最后一个运费单：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,lastFreight:&#123;$last:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据操作符"><a href="#数据操作符" class="headerlink" title="数据操作符"></a>数据操作符</h3><p>$addToSet 可以将分组后的某一个字段放到一个数组中，但是重复的元素将只出现一次，而且元素加入到数组中的顺序是无规律的，比如将分组后的每个城市的运费放到一个数组中，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,freights:&#123;$addToSet:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>重复的 freight 将不会被添加进来。</p><p>$push 则对重复的数据不做限制，都可以添加进来，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$group:&#123;_id:&quot;$orderAddressL&quot;,freights:&#123;$push:&quot;$freight&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="unwind"><a href="#unwind" class="headerlink" title="$unwind"></a>$unwind</h2><p>$unwind 用来实现对文档的拆分,可以将文档中的值拆分为单独的文档，比如我的数据如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f93c8b8523cfae4cf4ba86"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"books"</span> : [ </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span> : <span class="hljs-string">"呐喊"</span>,</span><br><span class="line">            <span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"花城出版社"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span> : <span class="hljs-string">"彷徨"</span>,</span><br><span class="line">            <span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"南海出版出"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 $unwind 命令将其拆分为独立文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_books.aggregate(&#123;$unwind:&quot;$books&quot;&#125;)</span><br></pre></td></tr></table></figure><p>拆分结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f93c8b8523cfae4cf4ba86"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"books"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"呐喊"</span>,</span><br><span class="line">        <span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"花城出版社"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f93c8b8523cfae4cf4ba86"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"鲁迅"</span>,</span><br><span class="line">    <span class="hljs-attr">"books"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"彷徨"</span>,</span><br><span class="line">        <span class="hljs-attr">"publisher"</span> : <span class="hljs-string">"南海出版出"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h2><p>$sort 操作可以对文档进行排序，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$sort:&#123;orderAddressL:1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>用法和我们之前介绍普通搜索中的一致，可以按照存在的字段排序，也可以按照重命名的字段排序，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;oa:&quot;$orderAddressL&quot;&#125;&#125;,&#123;$sort:&#123;oa:-1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>1 表示升序、-1 表示降序。</p><p>$limit 返回结果中的前 n 个文档，如下表示返回结果中的前三个文档：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;oa:&quot;$orderAddressL&quot;&#125;&#125;,&#123;$limit:3&#125;)</span><br></pre></td></tr></table></figure><p>$skip 表示跳过前 n 个文档，比如跳过前 5 个文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;oa:&quot;$orderAddressL&quot;&#125;&#125;,&#123;$skip:5&#125;)</span><br></pre></td></tr></table></figure><p>$skip 的效率低，要慎用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在管道开始执行的阶段尽可能过滤掉足够多的数据，这样做有两个好处：</p><ol><li>只有从集合中直接查询时才会使用索引，尽早执行过滤可以让索引发挥作用；</li><li>该过滤的数据过滤掉之后，也可以降低后面管道的执行压力。另外，MongoDB 不允许一个聚合操作占用过多的内存，如果有一个聚合操作占用了超过 20% 的内存，则会直接报错。</li></ol><p>好了，MongoDB 中的管道操作符我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中我们已经学习了 MongoDB 中几个基本的管道操作符，本文我们再来看看其他的管道操作符。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 管道操作符(一)</title>
    <link href="http://www.javaboy.org/2019/0912/mongodb-pipelines.html"/>
    <id>http://www.javaboy.org/2019/0912/mongodb-pipelines.html</id>
    <published>2019-09-12T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:55.507Z</updated>
    
    <content type="html"><![CDATA[<p>熟悉 Linux 操作系统的小伙伴们应该知道 Linux 中有管道的说法，可以用来方便的处理数据。</p><a id="more"></a><p>MongoDB2.2 版本也引入了新的数据聚合框架，一个文档可以经过多个节点组成的管道，每个节点都有自己特殊的功能，比如文档分组、文档过滤等，每一个节点都会接受一连串的文档，对这些文档做一些类型转换，然后将转换后的文档传递给下一个节点，最后一个节点则会将结果返回给客户端。本文我们就先来看几个基本的管道操作符。</p><h2 id="match"><a href="#match" class="headerlink" title="$match"></a>$match</h2><p>$match 可以用来对文档进行筛选，筛选完成之后我们就可以在筛选获得到的文档子集上来做数据聚合操作了，我们之前介绍的查询的操作符在 $match 中都可以使用，比如获取集合中所有 author 为”杜甫”的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$match:&#123;author:&quot;杜甫&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>我们在实际使用时最好将 $match 放在管道的前面，这样可以减少后面管道的工作量，同时，我们在投射和分组之前执行 $match 还可以用索引。</p><h2 id="project"><a href="#project" class="headerlink" title="$project"></a>$project</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>$project 可以用来 <strong> 提取想要的字段 </strong>，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;title:1,_id:0&#125;&#125;)</span><br></pre></td></tr></table></figure><p>1 表示要该字段，0 表示不要该字段，也可以对返回的字段进行 <strong> 重命名 </strong>，比如将 title 改为 articleTitle，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;&quot;articleTitle&quot;:&quot;$title&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>不过这里有一个问题需要注意，如果原字段上有索引，重命名之后的字段上就没有索引了，因此最好在重命名之前使用索引。</p><h3 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h3><p>数学表达式可以用来对一组数值进行加减乘除取模，比如我的数据结构如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;59f841f5b998d8acc7d08863&quot;),</span><br><span class="line">    &quot;orderAddressL&quot; : &quot;ShenZhen&quot;,</span><br><span class="line">    &quot;prodMoney&quot; : 45.0,</span><br><span class="line">    &quot;freight&quot; : 13.0,</span><br><span class="line">    &quot;discounts&quot; : 3.0,</span><br><span class="line">    &quot;orderDate&quot; : ISODate(&quot;2017-10-31T09:27:17.342Z&quot;),</span><br><span class="line">    &quot;prods&quot; : [ </span><br><span class="line">        &quot;可乐&quot;, </span><br><span class="line">        &quot;奶茶&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订单的总费用为商品费用加上运费，查询如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;totalMoney:&#123;$add:[&quot;$prodMoney&quot;,&quot;$freight&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>实际付款的费用是总费用减去折扣，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;totalPay:&#123;$subtract:[&#123;$add:[&quot;$prodMoney&quot;,&quot;$freight&quot;]&#125;,&quot;$discounts&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再来三个无厘头运算，比如计算 prodMoney 和 freight 和 discounts 的乘积：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test1:&#123;$multiply:[&quot;$prodMoney&quot;,&quot;$freight&quot;,&quot;$discounts&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再比如求 $prodMoney 和 $freight 的商，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test1:&#123;$divide:[&quot;$prodMoney&quot;,&quot;$freight&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再比如用 $freight 对 $prodMoney 取模，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test1:&#123;$mod:[&quot;$prodMoney&quot;,&quot;$freight&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>加法和乘法都可以接收多个参数，其余的都接收两个参数。</p><h3 id="日期表达式"><a href="#日期表达式" class="headerlink" title="日期表达式"></a>日期表达式</h3><p>日期表达式可以从一个日期类型中提取出年、月、日、星期、时、分、秒等信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;&quot;年份&quot;:&#123;$year:&quot;$orderDate&quot;&#125;,&quot;月份&quot;:&#123;$month:&quot;$orderDate&quot;&#125;,&quot;一年中第几周&quot;:&#123;$week:&quot;$orderDate&quot;&#125;,&quot;日期&quot;:&#123;$dayOfMonth:&quot;$orderDate&quot;&#125;,&quot;星期&quot;:&#123;$dayOfWeek:&quot;$orderDate&quot;&#125;,&quot;一年中第几天&quot;:&#123;$dayOfYear:&quot;$orderDate&quot;&#125;,&quot;时&quot;:&#123;$hour:&quot;$orderDate&quot;&#125;,&quot;分&quot;:&#123;$minute:&quot;$orderDate&quot;&#125;,&quot;秒&quot;:&#123;$second:&quot;$orderDate&quot;&#125;,&quot;毫秒&quot;:&#123;$millisecond:&quot;$orderDate&quot;&#125;,&quot;自定义格式化时间&quot;:&#123;$dateToString:&#123;format:&quot;%Y年%m月%d %H:%M:%S&quot;,date:&quot;$orderDate&quot;&#125;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f841f5b998d8acc7d08861"</span>),</span><br><span class="line">    <span class="hljs-attr">"年份"</span> : <span class="hljs-number">2017</span>,</span><br><span class="line">    <span class="hljs-attr">"月份"</span> : <span class="hljs-number">10</span>,</span><br><span class="line">    <span class="hljs-attr">"一年中第几周"</span> : <span class="hljs-number">44</span>,</span><br><span class="line">    <span class="hljs-attr">"日期"</span> : <span class="hljs-number">31</span>,</span><br><span class="line">    <span class="hljs-attr">"星期"</span> : <span class="hljs-number">3</span>,</span><br><span class="line">    <span class="hljs-attr">"一年中第几天"</span> : <span class="hljs-number">304</span>,</span><br><span class="line">    <span class="hljs-attr">"时"</span> : <span class="hljs-number">9</span>,</span><br><span class="line">    <span class="hljs-attr">"分"</span> : <span class="hljs-number">27</span>,</span><br><span class="line">    <span class="hljs-attr">"秒"</span> : <span class="hljs-number">17</span>,</span><br><span class="line">    <span class="hljs-attr">"毫秒"</span> : <span class="hljs-number">342</span>,</span><br><span class="line">    <span class="hljs-attr">"自定义格式化时间"</span> : <span class="hljs-string">"2017年10月31 09:27:17"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$dayOfWeek 返回的是星期，1 表示星期天，7 表示星期六，$week 表示本周是本年的第几周，从 0 开始计。$dateToString 是 MongoDB3.0+ 中的功能。格式化的字符还有以下几种：</p><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">含义</th><th style="text-align:left">取值范围</th></tr></thead><tbody><tr><td style="text-align:left">%Y</td><td style="text-align:left">Year (4 digits, zero padded)</td><td style="text-align:left">0000-9999</td></tr><tr><td style="text-align:left">%m</td><td style="text-align:left">Month (2 digits, zero padded)</td><td style="text-align:left">01-12</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">Day of Month (2 digits, zero padded)</td><td style="text-align:left">01-31</td></tr><tr><td style="text-align:left">%H</td><td style="text-align:left">Hour (2 digits, zero padded, 24-hour clock)</td><td style="text-align:left">00-23</td></tr><tr><td style="text-align:left">%M</td><td style="text-align:left">Minute (2 digits, zero padded)</td><td style="text-align:left">00-59</td></tr><tr><td style="text-align:left">%S</td><td style="text-align:left">Second (2 digits, zero padded)</td><td style="text-align:left">00-60</td></tr><tr><td style="text-align:left">%L</td><td style="text-align:left">Millisecond (3 digits, zero padded)</td><td style="text-align:left">000-999</td></tr><tr><td style="text-align:left">%j</td><td style="text-align:left">Day of year (3 digits, zero padded)</td><td style="text-align:left">001-366</td></tr><tr><td style="text-align:left">%w</td><td style="text-align:left">Day of week (1-Sunday, 7-Saturday)</td><td style="text-align:left">1-7</td></tr><tr><td style="text-align:left">%U</td><td style="text-align:left">Week of year (2 digits, zero padded)</td><td style="text-align:left">00-53</td></tr></tbody></table><h3 id="字符串表达式"><a href="#字符串表达式" class="headerlink" title="字符串表达式"></a>字符串表达式</h3><p>字符串表达式中有字符串的截取、拼接、转大写、转小写等操作，比如我截取 orderAddressL 前两个字符返回，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;addr:&#123;$substr:[&quot;$orderAddressL&quot;,0,2]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再比如我将 orderAddressL 和 orderDate 拼接后返回：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;addr:&#123;$concat:[&quot;$orderAddressL&quot;,&#123;$dateToString:&#123;format:&quot;--%Y年%m月%d&quot;,date:&quot;$orderDate&quot;&#125;&#125;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f841f5b998d8acc7d08861"</span>),</span><br><span class="line">    <span class="hljs-attr">"addr"</span> : <span class="hljs-string">"NanJing--2017年10月31"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如我将 orderAddressL 全部转为小写返回：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;addr:&#123;$toLower:&quot;$orderAddressL&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>再比如我将 orderAddressL 全部转为大写返回：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;addr:&#123;$toUpper:&quot;$orderAddressL&quot;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>想要比较两个数字的大小，可以使用 $cmp 操作符，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$cmp:[&quot;$freight&quot;,&quot;$discounts&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果第一个参数大于第二个参数返回正数，第一个参数小于第二个则返回负数，也可以利用 $strcasecmp 来比较字符串（中文无效）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$strcasecmp:[&#123;$dateToString:&#123;format:&quot;..%Y年%m月%d&quot;,date:&quot;$orderDate&quot;&#125;&#125;,&quot;$orderAddressL&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>至于我们之前介绍的 $eq/$ne/$gt/$gte/$lt/$lte 等操作符在这里一样是适用的。另外还有 and、$or、$not 等表达式可用，以 $and 为例，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$and:[&#123;&quot;$eq&quot;:[&quot;$freight&quot;,&quot;$prodMoney&quot;]&#125;,&#123;&quot;$eq&quot;:[&quot;$freight&quot;,&quot;$discounts&quot;]&#125;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$and 中的每个参数都为 true 时返回 true，$or 则表示参数中有一个为 true 就返回 true，$not 则会对它的参数的值取反，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$not:&#123;&quot;$eq&quot;:[&quot;$freight&quot;,&quot;$prodMoney&quot;]&#125;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>另外还有两个流程控制语句，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$cond:[false,&quot;trueExpr&quot;,&quot;falseExpr&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$cond 第一个参数如果为 true，则返回 trueExpr，否则返回 falseExpr.</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.aggregate(&#123;$project:&#123;test:&#123;$ifNull:[null,&quot;replacementExpr&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$ifNull 第一个参数如果为 null，则返回 replacementExpr，否则就返回第一个参数。</p><p>好了，MongoDB 中的管道操作符我们就先说到这里，下篇文章继续，小伙伴们有问题欢迎留言讨论。<br>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li><li><a href="http://blog.csdn.net/u013066244/article/details/53842355" target="_blank" rel="noopener">mongodb聚合利用日期分组</a>  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟悉 Linux 操作系统的小伙伴们应该知道 Linux 中有管道的说法，可以用来方便的处理数据。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 固定集合</title>
    <link href="http://www.javaboy.org/2019/0911/mongodb-collections.html"/>
    <id>http://www.javaboy.org/2019/0911/mongodb-collections.html</id>
    <published>2019-09-11T02:17:28.000Z</published>
    <updated>2019-09-21T09:08:10.515Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下我们创建的集合是没有大小的，可以一直往里边添加文档，这种集合可以动态增长，MongoDB 中还有一种集合叫做固定集合，这种集合的大小是固定的，我可以在创建的时候设置该集合中文档的数目，假设为 100 条，当集合中的文档数目达到 100 条时，如果再向集合中插入文档，则只会保留最新的 100 个文档，之前的文档则会被删除。</p><a id="more"></a><p>一般像日志信息我们就可以使用固定集合，其他一些需要定期删除的数据也可以使用固定集合，本文我们就来看看这个固定集合的使用。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>固定集合的创建方式也比较简单，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&quot;my_collect&quot;,&#123;capped:true,size:10000,max:100&#125;)</span><br></pre></td></tr></table></figure><p>capped:true 参数表示该集合为一个固定大小集合，size 表示集合的大小，单位为 kb，max 则表示集合中文档的最大数量。我们这里相当于给了固定集合两个限制条件，只要有任意一个限制条件满足，集合都会开始将更古老的数据删除。固定集合一旦创建成功就不能再修改，想修改只能删除重来。此时我们可以尝试向集合中添加 120 条简单的数据，然后我们会发现最早的 20 条数据消失了。</p><p>除了直接创建一个固定集合外，我们也可以通过 convertToCapped 操作将一个普通集合转为一个固定集合，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123;convertToCapped:&quot;sang_collect&quot;,size:10&#125;)</span><br></pre></td></tr></table></figure><h2 id="自然排序问题"><a href="#自然排序问题" class="headerlink" title="自然排序问题"></a>自然排序问题</h2><p>自然排序就是按照文档在磁盘中的顺序来进行排列，在普通的集合中自然排序并没有多大的意义，因为文档的位置总是在变化，而固定集合中的文档是按照文档被插入的顺序保存的，自然顺序也就是文档的插入顺序，因此我们可以利用自然排序对文档从旧到新排序，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find().sort(&#123;$natural:1&#125;)</span><br></pre></td></tr></table></figure><p>也可以从新到旧排序：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find().sort(&#123;$natural:-1&#125;)</span><br></pre></td></tr></table></figure><p>固定集合中的其他操作和普通集合基本一致，这里就不再赘述。</p><p>好了，MongoDB 中的固定集合我们就说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下我们创建的集合是没有大小的，可以一直往里边添加文档，这种集合可以动态增长，MongoDB 中还有一种集合叫做固定集合，这种集合的大小是固定的，我可以在创建的时候设置该集合中文档的数目，假设为 100 条，当集合中的文档数目达到 100 条时，如果再向集合中插入文档，则只会保留最新的 100 个文档，之前的文档则会被删除。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 中各种类型的索引</title>
    <link href="http://www.javaboy.org/2019/0910/mongodb-index-types.html"/>
    <id>http://www.javaboy.org/2019/0910/mongodb-index-types.html</id>
    <published>2019-09-10T02:17:28.000Z</published>
    <updated>2019-09-21T09:05:21.741Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中我们介绍了 MongoDB 中索引的简单操作，创建、查看、删除等基本操作，不过上文我们只介绍了一种类型的索引，本文我们来看看其他类型的索引。</p><a id="more"></a><h2 id="id-索引"><a href="#id-索引" class="headerlink" title="_id 索引"></a>_id 索引</h2><p>我们在上文介绍过，我们往集合中添加文档时，默认情况下 MongoDB 都会帮助我们创建一个名为 <code>_id</code> 的字段，这个字段就是一个索引。默认情况下，一般的集合都会帮我们创建这个字段作为索引，但也有一些集合不会将 <code>_id</code> 默认作为索引，比如固定集合，这个我们后面的文章会详细说到这个问题。</p><h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>如果我们的查询条件有多个的话，我们可以对这多个查询条件都建立索引，比如我们可以对文档中的 x 和 y 字段都建立索引，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:1,y:-1&#125;)</span><br></pre></td></tr></table></figure><p>此时执行如下查询语句时就会用到这个复合索引：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:1,y:999&#125;)</span><br></pre></td></tr></table></figure><p>小伙伴们也可以通过查看查询计划来确定确实使用到了上文创建好的索引。</p><h2 id="过期索引"><a href="#过期索引" class="headerlink" title="过期索引"></a>过期索引</h2><p>顾名思义，过期索引就是一种会过期的索引，在索引过期之后，索引对应的数据会被删除，创建方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds:30&#125;)</span><br></pre></td></tr></table></figure><p>expireAfterSeconds 表示索引的过期时间，单位为秒。time 表示索引的字段，time 的数据类型必须是 ISODate 或者 ISODate 数组，否则的话，当索引过期之后，time 的数据就不会被删除。</p><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>全文索引虽然好用，可惜不支持中文，我们这里就先做一个简单的了解。</p><p>比如，我的数据集如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a3da1f9e8e181ffc3189"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"Java C# Python PHP"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a3da1f9e8e181ffc318a"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"Java C#"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a3da1f9e8e181ffc318b"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"Java Python"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a3da1f9e8e181ffc318c"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"PHP Python"</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5a4541f9e8e181ffc318d"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-string">"C C++"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以给 x 字段建立一个全文索引，创建方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:&quot;text&quot;&#125;)</span><br></pre></td></tr></table></figure><p>MongoDB 会自动对 x 字段的数据进行分词，然后我们就可以通过如下语句进行查询：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;Java&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时 x 中包含 Java 的文档都会被查询出来。如果想查询既包含 Java 又包含 C# 的文档，操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;\&quot;Java C#\&quot;&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>用一对双引号将查询条件括起来，如果想查询包含 PHP 或者 Python 的文档，操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;PHP Python&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果想查询既有 PHP，又有 Python，但是又不包括 Java 的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;PHP Python -Java&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>建立了全文索引之后，我们也可以查看查询结果的相似度，使用 $meta，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;PHP Python&quot;&#125;&#125;,&#123;score:&#123;$meta:&quot;textScore&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时查询结果中会多出一个 score 字段，该字段的值越大，表示相似度越高，我们可以根据 score 利用 sort 来对其进行排序，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$text:&#123;$search:&quot;PHP Python&quot;&#125;&#125;,&#123;score:&#123;$meta:&quot;textScore&quot;&#125;&#125;).sort(&#123;score:&#123;$meta:&quot;textScore&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>全文索引目前看起来功能还是很强大，可惜暂时不支持中文，不过网上对此也有很多解决方案，小伙伴们可以自行搜索查看。</p><h2 id="地理空间索引"><a href="#地理空间索引" class="headerlink" title="地理空间索引"></a>地理空间索引</h2><h3 id="地理空间索引类型"><a href="#地理空间索引类型" class="headerlink" title="地理空间索引类型"></a>地理空间索引类型</h3><p>地理空间索引可以分为两类：</p><ol><li>2d 索引，可以用来存储和查找平面上的点。</li><li>2d sphere 索引，可以用来存储和查找球面上的点。</li></ol><h4 id="2d索引"><a href="#2d索引" class="headerlink" title="2d索引"></a>2d索引</h4><p>2d 索引一般我们可以用在游戏地图中。<br>向集合中插入一条记录点的数据：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.insert(&#123;x:[90,0]&#125;)</span><br></pre></td></tr></table></figure><p>插入数据的格式为[经度,纬度]，取值范围，经度 [-180,180]，纬度 [-90,90]。数据插入成功之后，我们先通过如下命令创建索引：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:&quot;2d&quot;&#125;)</span><br></pre></td></tr></table></figure><p>然后通过 $near 我们可以查询某一个点附近的点，如下:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$near:[90,0]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下返回该点附近 100 个点，我们可以通过 $maxDistance 来设置返回的最远距离：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$near:[90,0],$maxDistance:99&#125;&#125;)</span><br></pre></td></tr></table></figure><p>我们也可以通过 $geoWithin 查询某个形状内的点，比如查询矩形中的点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$box:[[0,0],[91,1]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>两个坐标点用来确定矩形的位置。</p><p>查询圆中的点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$center:[[0,0],90]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>参数分别表示圆的圆心和半径。</p><p>查询多边形中的点：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$geoWithin:&#123;$polygon:[[0,0],[100,0],[100,1],[0,1]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里可以填入任意多个点，表示多边形中的各个点。</p><h4 id="2d-sphere索引"><a href="#2d-sphere索引" class="headerlink" title="2d sphere索引"></a>2d sphere索引</h4><p>2dsphere 适用于球面类型的地图，它的数据类型是 GeoJSON 格式的，我们可以在 <a href="http://geojson.org/" target="_blank" rel="noopener">http://geojson.org/</a> 地址上查看 GeoJSON 格式的样式，比如我们描述一个点， GeoJSON 如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5e0571f9e8e181ffc3196"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"shenzhen"</span>,</span><br><span class="line">    <span class="hljs-attr">"location"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span> : <span class="hljs-string">"Point"</span>,</span><br><span class="line">        <span class="hljs-attr">"coordinates"</span> : [ </span><br><span class="line">            <span class="hljs-number">90.0</span>, </span><br><span class="line">            <span class="hljs-number">0.0</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述线，GeoJSON 格式如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5e0d01f9e8e181ffc3199"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"shenzhen"</span>,</span><br><span class="line">    <span class="hljs-attr">"location"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span> : <span class="hljs-string">"LineString"</span>,</span><br><span class="line">        <span class="hljs-attr">"coordinates"</span> : [ </span><br><span class="line">            [ </span><br><span class="line">                <span class="hljs-number">90.0</span>, </span><br><span class="line">                <span class="hljs-number">0.0</span></span><br><span class="line">            ], </span><br><span class="line">            [ </span><br><span class="line">                <span class="hljs-number">90.0</span>, </span><br><span class="line">                <span class="hljs-number">1.0</span></span><br><span class="line">            ], </span><br><span class="line">            [ </span><br><span class="line">                <span class="hljs-number">90.0</span>, </span><br><span class="line">                <span class="hljs-number">2.0</span></span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述多边形，GeoJSON 格式如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f5e3f91f9e8e181ffc31d0"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"beijing"</span>,</span><br><span class="line">    <span class="hljs-attr">"location"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"type"</span> : <span class="hljs-string">"Polygon"</span>,</span><br><span class="line">        <span class="hljs-attr">"coordinates"</span> : [ </span><br><span class="line">            [ </span><br><span class="line">                [ </span><br><span class="line">                    <span class="hljs-number">0.0</span>, </span><br><span class="line">                    <span class="hljs-number">1.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="hljs-number">0.0</span>, </span><br><span class="line">                    <span class="hljs-number">2.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="hljs-number">1.0</span>, </span><br><span class="line">                    <span class="hljs-number">2.0</span></span><br><span class="line">                ], </span><br><span class="line">                [ </span><br><span class="line">                    <span class="hljs-number">0.0</span>, </span><br><span class="line">                    <span class="hljs-number">1.0</span></span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有其他的类型，具体小伙伴们可以参考 <a href="http://geojson.org/" target="_blank" rel="noopener">http://geojson.org/</a> 。有了数据之后，我们可以通过如下操作来创建地理空间索引了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;location:&quot;2dsphere&quot;&#125;)</span><br></pre></td></tr></table></figure><p>比如我想查询和深圳这个区域有交集的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var shenzhen = db.sang_collect.findOne(&#123;name:&quot;shenzhen&quot;&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$geoIntersects:&#123;$geometry:shenzhen.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这里的查询结果是和深圳这个区域有交集的都会查到(比如经过深圳的高速公路、铁路等)，我们也可以只查询深圳市内的区域(比如深圳市内所有的学校)，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var shenzhen = db.sang_collect.findOne(&#123;name:&quot;shenzhen&quot;&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>也可以查询腾讯附近的其他位置，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var QQ = db.sang_collect.findOne(&#123;name:&quot;QQ&quot;&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$near:&#123;$geometry:QQ.location&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="复合地理空间索引"><a href="#复合地理空间索引" class="headerlink" title="复合地理空间索引"></a>复合地理空间索引</h3><p>位置往往只是我们查询的一个条件，比如我要查询深圳市内所有的学校，那我得再增加一个查询条件，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var shenzhen = db.sang_collect.findOne(&#123;name:&quot;shenzhen&quot;&#125;)</span><br><span class="line">db.sang_collect.find(&#123;location:&#123;$within:&#123;$geometry:shenzhen.location&#125;&#125;,name:&quot;QQ&quot;&#125;)</span><br></pre></td></tr></table></figure><p>其他的查询条件跟在后面就行了。</p><p>好了，MongoDB 中的索引问题我们就说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中我们介绍了 MongoDB 中索引的简单操作，创建、查看、删除等基本操作，不过上文我们只介绍了一种类型的索引，本文我们来看看其他类型的索引。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>初识 MongoDB 中的索引</title>
    <link href="http://www.javaboy.org/2019/0909/mongodb-index-basic.html"/>
    <id>http://www.javaboy.org/2019/0909/mongodb-index-basic.html</id>
    <published>2019-09-09T02:17:28.000Z</published>
    <updated>2019-09-21T09:05:30.560Z</updated>
    
    <content type="html"><![CDATA[<p>索引就像图书的目录一样，可以让我们快速定位到需要的内容，关系型数据库中有索引，NoSQL 中当然也有，本文我们就先来简单介绍下 MongoDB 中的索引。</p><a id="more"></a><h2 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h2><p>默认情况下，集合中的 <code>_id</code> 字段就是索引，我们可以通过 getIndexes() 方法来查看一个集合中的索引：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.getIndexes()</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-attr">"v"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"key"</span> : &#123;</span><br><span class="line">            <span class="hljs-attr">"_id"</span> : <span class="hljs-number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"_id_"</span>,</span><br><span class="line">        <span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.sang_collect"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们看到这里只有一个索引，就是 <code>_id</code>。</p><p>现在我的集合中有 10000 个文档，我想要查询 x 为 1 的文档，我的查询操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>这种查询默认情况下会做全表扫描，我们可以用上篇文章介绍的 explain() 来查看一下查询计划，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:1&#125;).explain(&quot;executionStats&quot;)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"queryPlanner"</span> : &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"executionStats"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"executionSuccess"</span> : <span class="hljs-literal">true</span>,</span><br><span class="line">        <span class="hljs-attr">"nReturned"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"executionTimeMillis"</span> : <span class="hljs-number">15</span>,</span><br><span class="line">        <span class="hljs-attr">"totalKeysExamined"</span> : <span class="hljs-number">0</span>,</span><br><span class="line">        <span class="hljs-attr">"totalDocsExamined"</span> : <span class="hljs-number">10000</span>,</span><br><span class="line">        <span class="hljs-attr">"executionStages"</span> : &#123;</span><br><span class="line">            <span class="hljs-attr">"stage"</span> : <span class="hljs-string">"COLLSCAN"</span>,</span><br><span class="line">            <span class="hljs-attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="hljs-attr">"x"</span> : &#123;</span><br><span class="line">                    <span class="hljs-attr">"$eq"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-attr">"nReturned"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">            <span class="hljs-attr">"executionTimeMillisEstimate"</span> : <span class="hljs-number">29</span>,</span><br><span class="line">            <span class="hljs-attr">"works"</span> : <span class="hljs-number">10002</span>,</span><br><span class="line">            <span class="hljs-attr">"advanced"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">            <span class="hljs-attr">"needTime"</span> : <span class="hljs-number">10000</span>,</span><br><span class="line">            <span class="hljs-attr">"needYield"</span> : <span class="hljs-number">0</span>,</span><br><span class="line">            <span class="hljs-attr">"saveState"</span> : <span class="hljs-number">78</span>,</span><br><span class="line">            <span class="hljs-attr">"restoreState"</span> : <span class="hljs-number">78</span>,</span><br><span class="line">            <span class="hljs-attr">"isEOF"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">            <span class="hljs-attr">"invalidates"</span> : <span class="hljs-number">0</span>,</span><br><span class="line">            <span class="hljs-attr">"direction"</span> : <span class="hljs-string">"forward"</span>,</span><br><span class="line">            <span class="hljs-attr">"docsExamined"</span> : <span class="hljs-number">10000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"serverInfo"</span> : &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"ok"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果比较长，我摘取了关键的一部分。我们可以看到查询方式是全表扫描，一共扫描了 10000 个文档才查出来我要的结果。实际上我要的文档就排第二个，但是系统不知道这个集合中一共有多少个 x 为 1 的文档，所以会把全表扫描完，这种方式当然很低效，但是如果我加上 limit，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:1&#125;).limit(1)</span><br></pre></td></tr></table></figure><p>此时再看查询计划发现只扫描了两个文档就有结果了，但是如果我要查询 x 为 9999 的记录，那还是得把全表扫描一遍，此时，我们就可以给该字段建立索引，索引建立方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>1 表示升序，-1 表示降序。当我们给 x 字段建立索引之后，再根据 x 字段去查询，速度就非常快了，我们看下面这个查询操作的执行计划：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:9999&#125;).explain(&quot;executionStats&quot;)</span><br></pre></td></tr></table></figure><p>这个查询计划过长我就不贴出来了，我们可以重点关注查询要耗费的时间大幅度下降。</p><p>此时调用 getIndexes() 方法可以看到我们刚刚创建的索引，如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-attr">"v"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"key"</span> : &#123;</span><br><span class="line">            <span class="hljs-attr">"_id"</span> : <span class="hljs-number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"_id_"</span>,</span><br><span class="line">        <span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.sang_collect"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-attr">"v"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"key"</span> : &#123;</span><br><span class="line">            <span class="hljs-attr">"x"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"x_1"</span>,</span><br><span class="line">        <span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.sang_collect"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们看到每个索引都有一个名字，默认的索引名字为 <code>字段名_排序值</code>，当然我们也可以在创建索引时自定义索引名字，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:1&#125;,&#123;name:&quot;myfirstindex&quot;&#125;)</span><br></pre></td></tr></table></figure><p>此时创建好的索引如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"v"</span> : <span class="hljs-number">2</span>,</span><br><span class="line">    <span class="hljs-attr">"key"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"x"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"myfirstindex"</span>,</span><br><span class="line">    <span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.sang_collect"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然索引在创建的过程中还有许多其他可选参数，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.ensureIndex(&#123;x:1&#125;,&#123;name:&quot;myfirstindex&quot;,dropDups:true,background:true,unique:true,sparse:true,v:1,weights:99999&#125;)</span><br></pre></td></tr></table></figure><p>关于这里的参数，我说一下：</p><blockquote><ol><li>name 表示索引的名称</li><li>dropDups 表示创建唯一性索引时如果出现重复，则将重复的删除，只保留第一个</li><li>background 是否在后台创建索引，在后台创建索引不影响数据库当前的操作，默认为 false</li><li>unique 是否创建唯一索引，默认 false</li><li>sparse 对文档中不存在的字段是否不起用索引，默认 false</li><li>v 表示索引的版本号，默认为 2</li><li>weights 表示索引的权重</li></ol></blockquote><p>此时创建好的索引如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"v"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">    <span class="hljs-attr">"unique"</span> : <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"key"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"x"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"myfirstindex"</span>,</span><br><span class="line">    <span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.sang_collect"</span>,</span><br><span class="line">    <span class="hljs-attr">"background"</span> : <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"sparse"</span> : <span class="hljs-literal">true</span>,</span><br><span class="line">    <span class="hljs-attr">"weights"</span> : <span class="hljs-number">99999.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><p>上文我们介绍了 getIndexes() 可以用来查看索引，我们还可以通过 totalIndexSize() 来查看索引的大小，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.totalIndexSize()</span><br></pre></td></tr></table></figure><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>我们可以按名称删除索引，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.dropIndex(&quot;xIndex&quot;)</span><br></pre></td></tr></table></figure><p>表示删除一个名为xIndex的索引，当然我们也可以删除所有索引，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.dropIndexes()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>索引是个好东西，可以有效的提高查询速度，但是索引会降低插入、更新和删除的速度，因为这些操作不仅要更新文档，还要更新索引，MongoDB 限制每个集合上最多有 64 个索引，我们在创建索引时要仔细斟酌索引的字段。</p><p>好了，MongoDB 中的索引入门我们就说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引就像图书的目录一样，可以让我们快速定位到需要的内容，关系型数据库中有索引，NoSQL 中当然也有，本文我们就先来简单介绍下 MongoDB 中的索引。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 查看执行计划</title>
    <link href="http://www.javaboy.org/2019/0908/mongodb-query-planner.html"/>
    <id>http://www.javaboy.org/2019/0908/mongodb-query-planner.html</id>
    <published>2019-09-08T02:17:28.000Z</published>
    <updated>2019-09-21T09:05:37.748Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 中的 explain() 函数可以帮助我们查看查询相关的信息，这有助于我们快速查找到搜索瓶颈进而解决它，本文我们就来看看 explain() 的一些用法及其查询结果的含义。</p><a id="more"></a><p>本文是 MongoDB 系列的第八篇文章，了解前面的文章有助于更好的理解本文：</p><p>整体来说，explain() 的用法和 sort()、limit() 用法差不多，不同的是 explain() 必须放在最后面。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先来看一个基本用法：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:1&#125;).explain()</span><br></pre></td></tr></table></figure><p>直接跟在 find() 函数后面，表示查看 find() 函数的执行计划，结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"queryPlanner"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"plannerVersion"</span> : <span class="hljs-number">1</span>,</span><br><span class="line">        <span class="hljs-attr">"namespace"</span> : <span class="hljs-string">"sang.sang_collect"</span>,</span><br><span class="line">        <span class="hljs-attr">"indexFilterSet"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line">        <span class="hljs-attr">"parsedQuery"</span> : &#123;</span><br><span class="line">            <span class="hljs-attr">"x"</span> : &#123;</span><br><span class="line">                <span class="hljs-attr">"$eq"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="hljs-attr">"winningPlan"</span> : &#123;</span><br><span class="line">            <span class="hljs-attr">"stage"</span> : <span class="hljs-string">"COLLSCAN"</span>,</span><br><span class="line">            <span class="hljs-attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="hljs-attr">"x"</span> : &#123;</span><br><span class="line">                    <span class="hljs-attr">"$eq"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="hljs-attr">"direction"</span> : <span class="hljs-string">"forward"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="hljs-attr">"rejectedPlans"</span> : []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"serverInfo"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"host"</span> : <span class="hljs-string">"localhost.localdomain"</span>,</span><br><span class="line">        <span class="hljs-attr">"port"</span> : <span class="hljs-number">27017</span>,</span><br><span class="line">        <span class="hljs-attr">"version"</span> : <span class="hljs-string">"3.4.9"</span>,</span><br><span class="line">        <span class="hljs-attr">"gitVersion"</span> : <span class="hljs-string">"876ebee8c7dd0e2d992f36a848ff4dc50ee6603e"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"ok"</span> : <span class="hljs-number">1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果包含两大块信息，一个是 queryPlanner，即查询计划，还有一个是 serverInfo，即 MongoDB 服务的一些信息。那么这里涉及到的参数比较多，我们来一一看一下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">plannerVersion</td><td style="text-align:left">查询计划版本</td></tr><tr><td style="text-align:left">namespace</td><td style="text-align:left">要查询的集合</td></tr><tr><td style="text-align:left">indexFilterSet</td><td style="text-align:left">是否使用索引</td></tr><tr><td style="text-align:left">parsedQuery</td><td style="text-align:left">查询条件，此处为x=1</td></tr><tr><td style="text-align:left">winningPlan</td><td style="text-align:left">最佳执行计划</td></tr><tr><td style="text-align:left">stage</td><td style="text-align:left">查询方式，常见的有**COLLSCAN/全表扫描、IXSCAN/索引扫描、FETCH/根据索引去检索文档、SHARD_MERGE/合并分片结果、IDHACK/针对<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">|filter|过滤条件|</span><br><span class="line">|direction|搜索方向|</span><br><span class="line">|rejectedPlans|拒绝的执行计划|</span><br><span class="line">|serverInfo|MongoDB服务器信息|</span><br><span class="line"></span><br><span class="line">## 添加不同参数</span><br><span class="line"></span><br><span class="line">explain() 也接收不同的参数，通过设置不同参数我们可以查看更详细的查询计划。</span><br><span class="line"></span><br><span class="line">### queryPlanner</span><br><span class="line"></span><br><span class="line">queryPlanner 是默认参数，添加 queryPlanner 参数的查询结果就是我们上文看到的查询结果，so，这里不再赘述。</span><br><span class="line"></span><br><span class="line">### executionStats</span><br><span class="line"></span><br><span class="line">executionStats 会返回最佳执行计划的一些统计信息，如下：</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;queryPlanner&quot; : &#123;</span><br><span class="line">        &quot;plannerVersion&quot; : 1,</span><br><span class="line">        &quot;namespace&quot; : &quot;sang.sang_collect&quot;,</span><br><span class="line">        &quot;indexFilterSet&quot; : false,</span><br><span class="line">        &quot;parsedQuery&quot; : &#123;&#125;,</span><br><span class="line">        &quot;winningPlan&quot; : &#123;</span><br><span class="line">            &quot;stage&quot; : &quot;COLLSCAN&quot;,</span><br><span class="line">            &quot;direction&quot; : &quot;forward&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;rejectedPlans&quot; : []</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;executionStats&quot; : &#123;</span><br><span class="line">        &quot;executionSuccess&quot; : true,</span><br><span class="line">        &quot;nReturned&quot; : 10000,</span><br><span class="line">        &quot;executionTimeMillis&quot; : 4,</span><br><span class="line">        &quot;totalKeysExamined&quot; : 0,</span><br><span class="line">        &quot;totalDocsExamined&quot; : 10000,</span><br><span class="line">        &quot;executionStages&quot; : &#123;</span><br><span class="line">            &quot;stage&quot; : &quot;COLLSCAN&quot;,</span><br><span class="line">            &quot;nReturned&quot; : 10000,</span><br><span class="line">            &quot;executionTimeMillisEstimate&quot; : 0,</span><br><span class="line">            &quot;works&quot; : 10002,</span><br><span class="line">            &quot;advanced&quot; : 10000,</span><br><span class="line">            &quot;needTime&quot; : 1,</span><br><span class="line">            &quot;needYield&quot; : 0,</span><br><span class="line">            &quot;saveState&quot; : 78,</span><br><span class="line">            &quot;restoreState&quot; : 78,</span><br><span class="line">            &quot;isEOF&quot; : 1,</span><br><span class="line">            &quot;invalidates&quot; : 0,</span><br><span class="line">            &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">            &quot;docsExamined&quot; : 10000</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;serverInfo&quot; : &#123;</span><br><span class="line">        &quot;host&quot; : &quot;localhost.localdomain&quot;,</span><br><span class="line">        &quot;port&quot; : 27017,</span><br><span class="line">        &quot;version&quot; : &quot;3.4.9&quot;,</span><br><span class="line">        &quot;gitVersion&quot; : &quot;876ebee8c7dd0e2d992f36a848ff4dc50ee6603e&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ok&quot; : 1.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>这里除了我们上文介绍到的一些参数之外，还多了 executionStats 参数，含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">executionSuccess</td><td style="text-align:left">是否执行成功</td></tr><tr><td style="text-align:left">nReturned</td><td style="text-align:left">返回的结果数</td></tr><tr><td style="text-align:left">executionTimeMillis</td><td style="text-align:left">执行耗时</td></tr><tr><td style="text-align:left">totalKeysExamined</td><td style="text-align:left">索引扫描次数</td></tr><tr><td style="text-align:left">totalDocsExamined</td><td style="text-align:left">文档扫描次数</td></tr><tr><td style="text-align:left">executionStages</td><td style="text-align:left">这个分类下描述执行的状态</td></tr><tr><td style="text-align:left">stage</td><td style="text-align:left">扫描方式，具体可选值与上文的相同</td></tr><tr><td style="text-align:left">nReturned</td><td style="text-align:left">查询结果数量</td></tr><tr><td style="text-align:left">executionTimeMillisEstimate</td><td style="text-align:left">预估耗时</td></tr><tr><td style="text-align:left">works</td><td style="text-align:left">工作单元数，一个查询会分解成小的工作单元</td></tr><tr><td style="text-align:left">advanced</td><td style="text-align:left">优先返回的结果数</td></tr><tr><td style="text-align:left">docsExamined</td><td style="text-align:left">文档检查数目，与totalDocsExamined一致</td></tr></tbody></table><h3 id="allPlansExecution"><a href="#allPlansExecution" class="headerlink" title="allPlansExecution"></a>allPlansExecution</h3><p>allPlansExecution 用来获取所有执行计划，结果参数基本与上文相同，这里就不再细说了。</p><p>好了，MongoDB 中的 explain() 我们就说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li><li><a href="http://blog.csdn.net/leshami/article/details/53521990" target="_blank" rel="noopener">MongoDB执行计划获取(db.collection.explain())</a></li><li><a href="http://www.360doc.com/content/17/0110/11/3261457_621487815.shtml" target="_blank" rel="noopener">mongodb .explain(‘executionStats’) 查询性能分析</a>(没找到原文出处)  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB 中的 explain() 函数可以帮助我们查看查询相关的信息，这有助于我们快速查找到搜索瓶颈进而解决它，本文我们就来看看 explain() 的一些用法及其查询结果的含义。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 文档查询操作（三）</title>
    <link href="http://www.javaboy.org/2019/0907/mongodb-documents-query.html"/>
    <id>http://www.javaboy.org/2019/0907/mongodb-documents-query.html</id>
    <published>2019-09-07T02:17:28.000Z</published>
    <updated>2019-09-21T09:05:45.760Z</updated>
    
    <content type="html"><![CDATA[<p>关于 MongoDB 中的查询，我们已经连着介绍了两篇文章了，本文我们来介绍另外一个查询概念<strong>游标</strong>。</p><a id="more"></a><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>游标这个概念在很多地方都有，Java 中 JDBC 里的 ResultSet ，Android 中的 Cursor 等等都是，MongoDB 中也有类似的概念。当我们调用 find 方法时，就可以返回一个游标，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cursor = db.sang_collect.find();</span><br></pre></td></tr></table></figure><p>游标中有 hasNext() 方法，也有 next() 方法，这两个方法结合可以用来遍历结果，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(cursor.hasNext())&#123;</span><br><span class="line">    print(cursor.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next() 方法可以获取查询到的每一个文档，如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f299579babb96c21ddc9e8"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-number">0.0</span>,</span><br><span class="line">    <span class="hljs-attr">"y"</span> : <span class="hljs-number">1000.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 2 */</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f299579babb96c21ddc9e9"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : <span class="hljs-number">1.0</span>,</span><br><span class="line">    <span class="hljs-attr">"y"</span> : <span class="hljs-number">999.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我只想获取文档中的某一个字段，可以按如下方式：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(cursor.hasNext())&#123;</span><br><span class="line">    print(cursor.next().y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cursor 也实现了 JavaScript 中的迭代器接口，所以我们也可以直接调用 forEach 方法来遍历：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cursor.forEach(function(x)&#123;</span><br><span class="line">    print(x)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>当我们调用 find 方法获取 cursor 时，shell 并不会立即查询数据库，而是在真正使用数据时才会去加载，这有点类似于数据库框架中的懒加载，shell 在每次查询的时候会获取前 100 条结果或者前 4MB 数据(两者之间取最小)，然后我们调用 hasNext 和 next 时 shell 就不用再去连接数据库了，直接一条一条的返回查询到的数据，这 100 条或者 4MB 数据全部被返回之后，shell 才会再次发起请求向 MongoDB 要数据。</p><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>limit 是 cursor 中的方法，用来限制返回结果的数量，比如我只想获取查询的前三条结果，方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cursor = db.sang_collect.find().limit(3)</span><br></pre></td></tr></table></figure><h2 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h2><p>skip 也是 cursor 中的方法，用来表示跳过的记录数，比如我想获取第2到第5条记录，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cursor = db.sang_collect.find().skip(2).limit(4)</span><br></pre></td></tr></table></figure><p>跳过前两条( 0 和 1 )然后获取后面 4 条数据，skip 和 limit 结合有点类似于 MySQL 中的 limit，可以用来做分页，不过这种分页方式效率过低。</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort 用来实现排序功能，比如按 x 排序，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var cursor = db.sang_collect.find().sort(&#123;x:-1&#125;)</span><br></pre></td></tr></table></figure><p>1 表示升序，-1 表示降序。</p><p>好了，MongoDB 中的查询我们就说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 MongoDB 中的查询，我们已经连着介绍了两篇文章了，本文我们来介绍另外一个查询概念&lt;strong&gt;游标&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 文档查询操作(二)</title>
    <link href="http://www.javaboy.org/2019/0906/mongodb-documents-query.html"/>
    <id>http://www.javaboy.org/2019/0906/mongodb-documents-query.html</id>
    <published>2019-09-06T02:17:28.000Z</published>
    <updated>2019-09-21T09:05:52.666Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们对 MongoDB 中的查询操作做了简单介绍，本文我们继续来看更丰富的查询操作。</p><a id="more"></a><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>null 的查询稍微有点不同，假如我想查询 z 为 null 的数据，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;z:null&#125;)</span><br></pre></td></tr></table></figure><p>这样不仅会查出 z 为 null 的文档，也会查出所有没有 z 字段的文档，如果只想查询 z 为 null 的字段，那就再多加一个条件，判断一下z这个字段存在不，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;z:&#123;$in:[null],$exists:true&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="正则表达式查询"><a href="#正则表达式查询" class="headerlink" title="正则表达式查询"></a>正则表达式查询</h2><p>使用正则表达式查询我们在前面也已经介绍过了，这里的正则表达式语法和 JavaScript 中的正则表达式语法一致，比如查询所有 key 为 x，value 以 hello 开始的文档且不区分大小写：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collec.find(&#123;x:/^(hello)(.[a-zA-Z0-9])+/i&#125;)</span><br></pre></td></tr></table></figure><h2 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h2><p>假设我有一个数据集如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f1ad41e26b36b25bc605ae"</span>),</span><br><span class="line">    <span class="hljs-attr">"books"</span> : [ </span><br><span class="line">        <span class="hljs-string">"三国演义"</span>, </span><br><span class="line">        <span class="hljs-string">"红楼梦"</span>, </span><br><span class="line">        <span class="hljs-string">"水浒传"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询 books 中含有三国演义的文档，如下： </p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;books:&quot;三国演义&quot;&#125;)</span><br></pre></td></tr></table></figure><p>如果要查询既有三国演义又有红楼梦的文档，可以使用 $all，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;books:&#123;$all:[&quot;三国演义&quot;,&quot;红楼梦&quot;]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>当然我们也可以使用精确匹配，比如查询 books 为 <code>&quot;三国演义&quot;,&quot;红楼梦&quot;, &quot;水浒传&quot;</code> 的数据，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;books:[&quot;三国演义&quot;,&quot;红楼梦&quot;, &quot;水浒传&quot;]&#125;)</span><br></pre></td></tr></table></figure><p>不过这种就会一对一的精确匹配。</p><p>也可以按照下标匹配，比如我想查询数组中下标为 2 的项的为 <code>&quot;水浒传&quot;</code> 的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;&quot;books.2&quot;:&quot;水浒传&quot;&#125;)</span><br></pre></td></tr></table></figure><p>也可以按照数组长度来查询，比如我想查询数组长度为 3 的文档：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;books:&#123;$size:3&#125;&#125;)</span><br></pre></td></tr></table></figure><p>如果想查询数组中的前两条数据，可以使用 $slice，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;&#125;,&#123;books:&#123;$slice:2&#125;&#125;)</span><br></pre></td></tr></table></figure><p>注意这里要写在 find 的第二个参数的位置。2 表示数组中前两个元素，-2 表示从后往前数两个元素。也可以截取数组中间的元素，比如查询数组的第二个到第四个元素：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;&#125;,&#123;books:&#123;$slice:[1,3]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>数组中的与的问题也值得说一下，假设我有如下数据：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f208bc7b00f982986c669c"</span>),</span><br><span class="line">    <span class="hljs-attr">"x"</span> : [ </span><br><span class="line">        <span class="hljs-number">5.0</span>, </span><br><span class="line">        <span class="hljs-number">25.0</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想将数组中 value 取值在 (10,20) 之间的文档获取到，如下操作：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$lt:20,$gt:10&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时上面这个文档虽然不满足条件却依然被查找出来了，因为 <code>5&lt;20</code> ，而 <code>25&gt;10</code>，要解决这个问题，我们可以使用 $elemMatch，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$elemMatch:&#123;$lt:20,$gt:10&#125;&#125;&#125;)</span><br><span class="line">```  </span><br><span class="line">$elemMatch 要求 MongoDB 同时使用查询条件中的两个语句与一个数组元素进行比较。</span><br><span class="line"></span><br><span class="line">## 嵌套文档查询</span><br><span class="line"></span><br><span class="line">嵌套文档有两种查询方式，比如我的数据如下：</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;59f20c9b7b00f982986c669f&quot;),</span><br><span class="line">    &quot;x&quot; : 1.0,</span><br><span class="line">    &quot;y&quot; : &#123;</span><br><span class="line">        &quot;z&quot; : 2.0,</span><br><span class="line">        &quot;k&quot; : 3.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要查询上面这个文档，我的查询语句如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;y:&#123;z:2,k:3&#125;&#125;)</span><br></pre></td></tr></table></figure><p>但是这种写法要求严格匹配，顺序都不能变，假如写成了 <code>db.sang_collect.find({y:{k:3,z:2}})</code>，就匹配不到了，因此这种方法不够灵活，我们一般推荐的是下面这种写法：</p><pre><code>db.sang_collect.find({&quot;y.z&quot;:2,&quot;y.k&quot;:3})</code></pre><p>这种写法可以任意颠倒顺序。 </p><p>好了，MongoDB 中的查询操作还是非常丰富的，本文我们先说到这里，下篇文章我们介绍游标，小伙伴们有问题欢迎留言讨论。 </p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们对 MongoDB 中的查询操作做了简单介绍，本文我们继续来看更丰富的查询操作。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 文档查询操作(一)</title>
    <link href="http://www.javaboy.org/2019/0905/mongodb-documents-query.html"/>
    <id>http://www.javaboy.org/2019/0905/mongodb-documents-query.html</id>
    <published>2019-09-05T02:17:28.000Z</published>
    <updated>2019-09-21T09:05:59.315Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们主要介绍了 MongoDB 的修改操作，本文我们来看看查询操作。</p><a id="more"></a><h2 id="find-方法再探"><a href="#find-方法再探" class="headerlink" title="find 方法再探"></a>find 方法再探</h2><p>find 方法是很重要的一个查询方法，我们在前面也已经使用过多次了，一般情况下我们调用的是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find()</span><br></pre></td></tr></table></figure><p>没有传入任何参数，这个等价于：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>都表示没有查询条件，查询所有的数据。如果有查询条件，我们传入查询条件即可，查询条件也是一个文档，如下表示查询 x 为 1 的文档：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>如果查询条件文档中有多个字段，多个字段之间的关系是 AND，如下表示查询 x 为 1 并且 y 为 99 的文档：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:1,y:99&#125;)</span><br></pre></td></tr></table></figure><p>默认情况下，每次查询都会返回文档中所有的 key/value 对，我们也可以自定义返回的字段，如下表示只返回 x 字段，其他字段都不返回：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;&#125;,&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>参数 1 表示返回某一个字段，0 表示不返回某一个字段，当我们设置只返回 x 的时候， <code>_id</code> 默认还是返回的，如果不想返回 <code>_id</code> ，我们可以设置 <code>_id</code> 为 0，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;&#125;,&#123;x:1,_id:0&#125;)</span><br></pre></td></tr></table></figure><p>此时返回的数据中就不包括 <code>_id</code> 字段了。</p><h2 id="各种查询条件"><a href="#各种查询条件" class="headerlink" title="各种查询条件"></a>各种查询条件</h2><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>这里的比较运算符都比较好理解，如下表：</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">|```$lte```|```&lt;=```|</span><br><span class="line">|```$gt```|```&gt;```|</span><br><span class="line">|```$gte```|```&gt;=```|</span><br><span class="line">|```$ne```|```!=```|</span><br><span class="line"></span><br><span class="line">比如我想查询所有成绩在 [90,100] 之间的学生：</span><br><span class="line"></span><br><span class="line">原始数据如下：</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">/* 2 */</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;59f0b17249fc5c9c2412a666&quot;),</span><br><span class="line">    &quot;name&quot; : &quot;zs&quot;,</span><br><span class="line">    &quot;score&quot; : 100.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 3 */</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;59f0b17249fc5c9c2412a667&quot;),</span><br><span class="line">    &quot;name&quot; : &quot;ls&quot;,</span><br><span class="line">    &quot;score&quot; : 90.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 4 */</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;59f0b17249fc5c9c2412a668&quot;),</span><br><span class="line">    &quot;name&quot; : &quot;ww&quot;,</span><br><span class="line">    &quot;score&quot; : 70.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 5 */</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;59f0b17249fc5c9c2412a669&quot;),</span><br><span class="line">    &quot;name&quot; : &quot;zl&quot;,</span><br><span class="line">    &quot;score&quot; : 80.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td></tr></tbody></table><p>查询操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;score:&#123;$lte:100,$gte:90&#125;&#125;)</span><br></pre></td></tr></table></figure><p>查询结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 1 */</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f0b17249fc5c9c2412a666"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"zs"</span>,</span><br><span class="line">    <span class="hljs-attr">"score"</span> : <span class="hljs-number">100.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 2 */</span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f0b17249fc5c9c2412a667"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"ls"</span>,</span><br><span class="line">    <span class="hljs-attr">"score"</span> : <span class="hljs-number">90.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要查询分数不为 90 的学生，操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;score:&#123;$ne:90&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="in和-nin"><a href="#in和-nin" class="headerlink" title="$in和$nin"></a>$in和$nin</h3><p>$in 有点类似于 SQL 中的 in 关键字，表示查询某一个字段在某一个范围中的所有文档，比如我想查询<strong>x为1或者2</strong>的所有文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$in:[1,2]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$nin 的作用和 $in 恰好相反，表示查询某一个字段不在某一个范围内的所有文档，比如我想查询<strong>x不为1或者2(不为1且不为2)</strong>的所有文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$nin:[1,2]&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="or"><a href="#or" class="headerlink" title="$or"></a>$or</h3><p>$or 有点类似于 SQL 中的 or 关键字，表示多个查询条件之间是<strong>或</strong>的关系，比如我想查询 x 为 1 或者 y 为 99 的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$or:[&#123;x:1&#125;,&#123;y:99&#125;]&#125;)</span><br></pre></td></tr></table></figure><h3 id="type"><a href="#type" class="headerlink" title="$type"></a>$type</h3><p>$type 可以用来根据数据类型查找数据，比如我想要查找 x 类型为数字的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$type:1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>1 表示数字，其他数据类型对应的数字参见下表。</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">对应数字</th><th style="text-align:left">别名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:left">Double1</td><td style="text-align:center">1</td><td style="text-align:left">double</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">String</td><td style="text-align:center">2</td><td style="text-align:left">string</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Object</td><td style="text-align:center">3</td><td style="text-align:left">object</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Array</td><td style="text-align:center">4</td><td style="text-align:left">array</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Binary data</td><td style="text-align:center">5</td><td style="text-align:left">binData</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Undefined</td><td style="text-align:center">6</td><td style="text-align:left">undefined</td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:left">ObjectId</td><td style="text-align:center">7</td><td style="text-align:left">objectId</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Boolean</td><td style="text-align:center">8</td><td style="text-align:left">bool</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Date</td><td style="text-align:center">9</td><td style="text-align:left">date</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Null</td><td style="text-align:center">10</td><td style="text-align:left">null</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Regular Expression</td><td style="text-align:center">11</td><td style="text-align:left">regex</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">DBPointer</td><td style="text-align:center">12</td><td style="text-align:left">dbPointer</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">JavaScript</td><td style="text-align:center">13</td><td style="text-align:left">javascript</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Symbol</td><td style="text-align:center">14</td><td style="text-align:left">symbol</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">JavaScript(with scope)</td><td style="text-align:center">15</td><td style="text-align:left">javascriptWithScope</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">32-bit integer</td><td style="text-align:center">16</td><td style="text-align:left">int</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Timestamp</td><td style="text-align:center">17</td><td style="text-align:left">timestamp</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">64-bit integer</td><td style="text-align:center">18</td><td style="text-align:left">long</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Min key</td><td style="text-align:center">-1</td><td style="text-align:left">minKey</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Max key</td><td style="text-align:center">127</td><td style="text-align:left">maxKey</td></tr></tbody></table><h3 id="not"><a href="#not" class="headerlink" title="$not"></a>$not</h3><p>$not 用来执行取反操作，比如我想要查询所有 x 的类型不为数字的文档，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;x:&#123;$not:&#123;$type:1&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="and"><a href="#and" class="headerlink" title="$and"></a>$and</h3><p>$and 类似于 SQL 中的 and，比如我想查询 y 大于 98 并且小于 100 的数据，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;$and:[&#123;y:&#123;$gt:98&#125;&#125;,&#123;y:&#123;$lt:100&#125;&#125;]&#125;)</span><br></pre></td></tr></table></figure><p>上面的操作我们也可以使用下面简化的写法：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.find(&#123;y:&#123;$lt:100,$gt:98&#125;&#125;)</span><br></pre></td></tr></table></figure><p>好了，MongoDB 中的查询操作还是非常丰富的，本文我们先说到这里，下篇文章我们继续介绍，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》  </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们主要介绍了 MongoDB 的修改操作，本文我们来看看查询操作。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 文档更新操作</title>
    <link href="http://www.javaboy.org/2019/0904/mongodb-documents-update.html"/>
    <id>http://www.javaboy.org/2019/0904/mongodb-documents-update.html</id>
    <published>2019-09-04T02:17:28.000Z</published>
    <updated>2019-09-21T09:06:05.334Z</updated>
    
    <content type="html"><![CDATA[<p>我们在前面的文章中提到过文档的基本的增删改查操作，MongoDB 中提供的增删改查的语法非常丰富，本文我们主要来看看更新都有哪些好玩的语法。</p><a id="more"></a><h2 id="文档替换"><a href="#文档替换" class="headerlink" title="文档替换"></a>文档替换</h2><p>假设我的集合中现在存了如下一段数据：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f005402844ff254a1b68f6"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"三国演义"</span>,</span><br><span class="line">    <span class="hljs-attr">"authorName"</span> : <span class="hljs-string">"罗贯中"</span>,</span><br><span class="line">    <span class="hljs-attr">"authorGender"</span> : <span class="hljs-string">"男"</span>,</span><br><span class="line">    <span class="hljs-attr">"authorAge"</span> : <span class="hljs-number">99.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一本书，有书名和作者信息，但是作者是一个独立的实体，所以我想将之提取出来，变成下面这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f005402844ff254a1b68f6"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"三国演义"</span>,</span><br><span class="line">    <span class="hljs-attr">"author"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"罗贯中"</span>,</span><br><span class="line">        <span class="hljs-attr">"gender"</span> : <span class="hljs-string">"男"</span>,</span><br><span class="line">        <span class="hljs-attr">"age"</span> : <span class="hljs-number">99.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我可以采用如下操作：</p><p><img src="https://www.javaboy.org/images/mongodb/4-1.png" alt="p248"></p><p>另外一个问题是更新时，MongoDB 只会匹配第一个更新的文档，假设我的 MongoDB 中有如下数据：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f00d4a2844ff254a1b68f7"</span>), <span class="hljs-attr">"x"</span> : <span class="hljs-number">1</span> &#125;</span><br><span class="line">&#123; <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f00d4a2844ff254a1b68f8"</span>), <span class="hljs-attr">"x"</span> : <span class="hljs-number">1</span> &#125;</span><br><span class="line">&#123; <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f00d4a2844ff254a1b68f9"</span>), <span class="hljs-attr">"x"</span> : <span class="hljs-number">1</span> &#125;</span><br><span class="line">&#123; <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f00d4a2844ff254a1b68fa"</span>), <span class="hljs-attr">"x"</span> : <span class="hljs-number">2</span> &#125;</span><br></pre></td></tr></table></figure><p>我想把所有 x 为 1 的数据改为 99，我们很容易想到如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;x:1&#125;,&#123;x:99&#125;)</span><br></pre></td></tr></table></figure><p>但我们发现执行结果却是这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f00d4a2844ff254a1b68f7"</span>), <span class="hljs-attr">"x"</span> : <span class="hljs-number">99</span> &#125;</span><br><span class="line">&#123; <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f00d4a2844ff254a1b68f8"</span>), <span class="hljs-attr">"x"</span> : <span class="hljs-number">1</span> &#125;</span><br><span class="line">&#123; <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f00d4a2844ff254a1b68f9"</span>), <span class="hljs-attr">"x"</span> : <span class="hljs-number">1</span> &#125;</span><br><span class="line">&#123; <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f00d4a2844ff254a1b68fa"</span>), <span class="hljs-attr">"x"</span> : <span class="hljs-number">2</span> &#125;</span><br></pre></td></tr></table></figure><p>即只有第一条匹配的结果被更新了，其他的都没有变化。这是 MongoDB 的更新规则，即只更新第一条匹配结果。如果我们想将所有 x 为 1 的更新为 x 为 99，可以采用如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;x:1&#125;,&#123;$set:&#123;x:99&#125;&#125;,false,true)</span><br></pre></td></tr></table></figure><p>首先我们将要修改的数据赋值给 $set，$set 是一个修改器，我们将在下文详细讲解，然后后面多了两个参数，第一个 false 表示如果不存在 update 记录，是否将我们要更新的文档作为一个新文档插入，true 表示插入，false 表示不插入，默认为 false，第二个 true 表示是否更新全部查到的文档，false 表示只更新第一条记录，true 表示更新所有查到的文档。</p><h2 id="使用修改器"><a href="#使用修改器" class="headerlink" title="使用修改器"></a>使用修改器</h2><p>很多时候我们修改文档，只是要修改文章的某一部分，而不是全部，但是现在我面临这样一个问题，假设我有如下一个文档：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;x:1,y:2,z:3&#125;</span><br></pre></td></tr></table></figure><p>我现在想把这个文档中 x 的值改为 99，我可能使用如下操作：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;x:1&#125;,&#123;x:99&#125;)</span><br></pre></td></tr></table></figure><p>但是更新结果却变成了这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59f02dce95769f660c09955b&quot;), &quot;x&quot; : 99 &#125;</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://www.javaboy.org/images/mongodb/4-2.png" alt="p249"></p><p>MongoDB 帮我把整个文档更新了！要解决这个问题，我们可以使用修改器。</p><h3 id="set-修改器"><a href="#set-修改器" class="headerlink" title="$set 修改器"></a>$set 修改器</h3><p>$set 可以用来修改一个字段的值，如果这个字段不存在，则创建它。如下：</p><p><img src="https://www.javaboy.org/images/mongodb/4-3.png" alt="p250"></p><p>如果该字段不存在，则创建，如下：</p><p><img src="https://www.javaboy.org/images/mongodb/4-4.png" alt="p251"></p><p>也可以利用 $unset 删除一个字段，如下：</p><p><img src="https://www.javaboy.org/images/mongodb/4-5.png" alt="p252"></p><p>$set 也可以用来修改内嵌文档，还以刚才的书为例，如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f042cfcafd355da9486008"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"三国演义"</span>,</span><br><span class="line">    <span class="hljs-attr">"author"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"罗贯中"</span>,</span><br><span class="line">        <span class="hljs-attr">"gender"</span> : <span class="hljs-string">"男"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要修改作者的名字，操作如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$set:&#123;&quot;author.name&quot;:&quot;明代罗贯中&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>修改结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f042cfcafd355da9486008"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"三国演义"</span>,</span><br><span class="line">    <span class="hljs-attr">"author"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"明代罗贯中"</span>,</span><br><span class="line">        <span class="hljs-attr">"gender"</span> : <span class="hljs-string">"男"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inc-修改器"><a href="#inc-修改器" class="headerlink" title="$inc 修改器"></a>$inc 修改器</h3><p>$inc 用来增加已有键的值，如果该键不存在就新创建一个。比如我想给上文的罗贯中增加一个年龄为 99，方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$inc:&#123;&quot;author.age&quot;:99&#125;&#125;)</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f042cfcafd355da9486008"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"三国演义"</span>,</span><br><span class="line">    <span class="hljs-attr">"author"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"明代罗贯中"</span>,</span><br><span class="line">        <span class="hljs-attr">"gender"</span> : <span class="hljs-string">"男"</span>,</span><br><span class="line">        <span class="hljs-attr">"age"</span> : <span class="hljs-number">99.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入我想给罗贯中增加 1 岁，执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$inc:&#123;&quot;author.age&quot;:1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>这是会在现有值上加 1，结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f042cfcafd355da9486008"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"三国演义"</span>,</span><br><span class="line">    <span class="hljs-attr">"author"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"明代罗贯中"</span>,</span><br><span class="line">        <span class="hljs-attr">"gender"</span> : <span class="hljs-string">"男"</span>,</span><br><span class="line">        <span class="hljs-attr">"age"</span> : <span class="hljs-number">100.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 $inc 只能用来操作数字，不能用来操作 null、布尔等。</p><h3 id="数组修改器"><a href="#数组修改器" class="headerlink" title="数组修改器"></a>数组修改器</h3><p>数组修改器有好几种，我们分别来看。<br>$push 可以向已有数组末尾追加元素，要是不存在就创建一个数组，还是以我们的上面的 book 为例，假设 book 有一个字段为 comments，是一个数组，表示对这个 book 的评论，我们可以使用如下命令添加一条评论：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$push:&#123;comments:&quot;好书666&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>此时不存在 comments 字段，系统会自动帮我们创建该字段，结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f042cfcafd355da9486008"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"三国演义"</span>,</span><br><span class="line">    <span class="hljs-attr">"author"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"明代罗贯中"</span>,</span><br><span class="line">        <span class="hljs-attr">"gender"</span> : <span class="hljs-string">"男"</span>,</span><br><span class="line">        <span class="hljs-attr">"age"</span> : <span class="hljs-number">100.0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"comments"</span> : [ </span><br><span class="line">        <span class="hljs-string">"好书666"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们可以追加评论，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$push:&#123;comments:&quot;好书666啦啦啦啦&quot;&#125;&#125;)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;59f042cfcafd355da9486008&quot;),</span><br><span class="line">    &quot;name&quot; : &quot;三国演义&quot;,</span><br><span class="line">    &quot;author&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : &quot;明代罗贯中&quot;,</span><br><span class="line">        &quot;gender&quot; : &quot;男&quot;,</span><br><span class="line">        &quot;age&quot; : 100.0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;comments&quot; : [ </span><br><span class="line">        &quot;好书666&quot;, </span><br><span class="line">        &quot;好书666啦啦啦啦&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想一次添加 3 条评论，可以结合 $each 一起来使用，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$push:&#123;comments:&#123;$each:[&quot;111&quot;,&quot;222&quot;,&quot;333&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f042cfcafd355da9486008"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"三国演义"</span>,</span><br><span class="line">    <span class="hljs-attr">"author"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"明代罗贯中"</span>,</span><br><span class="line">        <span class="hljs-attr">"gender"</span> : <span class="hljs-string">"男"</span>,</span><br><span class="line">        <span class="hljs-attr">"age"</span> : <span class="hljs-number">100.0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"comments"</span> : [ </span><br><span class="line">        <span class="hljs-string">"好书666"</span>, </span><br><span class="line">        <span class="hljs-string">"好书666啦啦啦啦"</span>, </span><br><span class="line">        <span class="hljs-string">"111"</span>, </span><br><span class="line">        <span class="hljs-string">"222"</span>, </span><br><span class="line">        <span class="hljs-string">"333"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 $slice 来固定数组的长度，假设我固定数组的长度为 5，如果数组中的元素不足 5 个，则全部保留，如果数组中的元素超过 5 个，则只会保留最新的 5 个，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$push:&#123;comments:&#123;$each:[&quot;444&quot;,&quot;555&quot;],$slice:-5&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>注意 $slice 的值为负数，运行结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f042cfcafd355da9486008"</span>),</span><br><span class="line">    <span class="hljs-attr">"name"</span> : <span class="hljs-string">"三国演义"</span>,</span><br><span class="line">    <span class="hljs-attr">"author"</span> : &#123;</span><br><span class="line">        <span class="hljs-attr">"name"</span> : <span class="hljs-string">"明代罗贯中"</span>,</span><br><span class="line">        <span class="hljs-attr">"gender"</span> : <span class="hljs-string">"男"</span>,</span><br><span class="line">        <span class="hljs-attr">"age"</span> : <span class="hljs-number">100.0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="hljs-attr">"comments"</span> : [ </span><br><span class="line">        <span class="hljs-string">"111"</span>, </span><br><span class="line">        <span class="hljs-string">"222"</span>, </span><br><span class="line">        <span class="hljs-string">"333"</span>, </span><br><span class="line">        <span class="hljs-string">"444"</span>, </span><br><span class="line">        <span class="hljs-string">"555"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以在清理之前使用 $sort 对数据先进行排序，然后再清理比如我有一个 class 文档，如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f07f3649fc5c9c2412a662"</span>),</span><br><span class="line">    <span class="hljs-attr">"class"</span> : <span class="hljs-string">"三年级二班"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在向这个文档中插入 student，每个 student 有姓名和成绩，然后按照成绩降序排列，只要前 5 条数据，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;class:&quot;三年级二班&quot;&#125;,&#123;$push:&#123;students:&#123;$each:[&#123;name:&quot;张一百&quot;,score:100&#125;,&#123;name:&quot;张九九&quot;,score:99&#125;,&#123;name:&quot;张九八&quot;,score:98&#125;],$slice:5,$sort:&#123;score:-1&#125;&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>$sort 的取值为 -1 和 1，-1 表示降序，1 表示升序。<br>上面的命令执行两次之后（即插入两次），结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"_id"</span> : ObjectId(<span class="hljs-string">"59f07f3649fc5c9c2412a662"</span>),</span><br><span class="line">    <span class="hljs-attr">"class"</span> : <span class="hljs-string">"三年级二班"</span>,</span><br><span class="line">    <span class="hljs-attr">"students"</span> : [ </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span> : <span class="hljs-string">"张一百"</span>,</span><br><span class="line">            <span class="hljs-attr">"score"</span> : <span class="hljs-number">100.0</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span> : <span class="hljs-string">"张一百"</span>,</span><br><span class="line">            <span class="hljs-attr">"score"</span> : <span class="hljs-number">100.0</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span> : <span class="hljs-string">"张九九"</span>,</span><br><span class="line">            <span class="hljs-attr">"score"</span> : <span class="hljs-number">99.0</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span> : <span class="hljs-string">"张九九"</span>,</span><br><span class="line">            <span class="hljs-attr">"score"</span> : <span class="hljs-number">99.0</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"name"</span> : <span class="hljs-string">"张九八"</span>,</span><br><span class="line">            <span class="hljs-attr">"score"</span> : <span class="hljs-number">98.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>$slice和$sort不能只和$push一起使用，还要加上$each。</strong></p><h3 id="addToSet"><a href="#addToSet" class="headerlink" title="$addToSet"></a>$addToSet</h3><p>我们可以在插入的时候使用 $addToSet，表示要插入的值如果存在则不插入，否则插入，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$addToSet:&#123;comments:&quot;好书&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>上面的命令执行多次之后，发现只成功插入了一条数据。也可以将 $addToSet 和 $each 结合起来使用，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$addToSet:&#123;comments:&#123;$each:[&quot;111&quot;,&quot;222&quot;,&quot;333&quot;]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="pop"><a href="#pop" class="headerlink" title="$pop"></a>$pop</h3><p>$pop 可以用来删除数组中的数据，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$pop:&#123;comments:1&#125;&#125;)</span><br></pre></td></tr></table></figure><p>1 表示从 comments 数组的末尾删除一条数据，-1 表示从 comments 数组的开头删除一条数据。</p><h3 id="pull"><a href="#pull" class="headerlink" title="$pull"></a>$pull</h3><p>使用 $pull 我们可以按条件删除数组中的某个元素，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$pull:&#123;comments:&quot;444&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>表示删除数组中值为 444 的数据。</p><h3 id><a href="#" class="headerlink" title="$"></a>$</h3><p>既然是数组，我们当然可以通过下标来访问，如下一行操作表示将下标为 0 的(第一个 comments) comments 修改为 999：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;name:&quot;三国演义&quot;&#125;,&#123;$set:&#123;&quot;comments.0&quot;:&quot;999&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>可是有的时候我并不知道我要修改的数据处于数组中的什么位置，这个时候可以使用 $ 符号来解决：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.update(&#123;comments:&quot;333&quot;&#125;,&#123;$set:&#123;&quot;comments.$&quot;:&quot;333-1&quot;&#125;&#125;)</span><br></pre></td></tr></table></figure><p>查询条件查出来 333 的下标，$ 符号就代码这个下标，然后通过 $ 符号就能将之修改。</p><h2 id="save"><a href="#save" class="headerlink" title="save"></a>save</h2><p>save 是 shell 中的一个函数，接收一个参数，这个参数就是文档，如果文档中有 <code>_id</code> 参数 save 会执行更新操作，否则执行插入操作，使用 save 操作我们可以方便的完成一些更新操作。</p><p><img src="https://www.javaboy.org/images/mongodb/4-6.png" alt="p253"></p><p>类似于如下命令则表示一个插入操作(因为没有 <code>_id</code> )：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.save(&#123;x:111&#125;)</span><br></pre></td></tr></table></figure><p>好了，MongoDB 的更新操作我们就先介绍这么多，有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在前面的文章中提到过文档的基本的增删改查操作，MongoDB 中提供的增删改查的语法非常丰富，本文我们主要来看看更新都有哪些好玩的语法。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 数据类型</title>
    <link href="http://www.javaboy.org/2019/0903/mongodb-data-types.html"/>
    <id>http://www.javaboy.org/2019/0903/mongodb-data-types.html</id>
    <published>2019-09-03T02:17:28.000Z</published>
    <updated>2019-09-21T09:06:21.026Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们介绍了 MongoDB 的最基本的增删改查操作，也介绍了一些基础的概念，MongoDB 中每条记录称作一个文档，这个文档和我们平时用的 JSON 有点像，但也不完全一样。</p><a id="more"></a><p>JSON 是一种轻量级的数据交换格式。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言，JSON 易于阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率，但是 JSON 也有它的局限性，比如它只有 null、布尔、数字、字符串、数组和对象这几种数据类型，没有日期类型，只有一种数字类型，无法区分浮点数和整数，也没法表示正则表达式或者函数。由于这些局限性，BSON 闪亮登场啦，BSON 是一种类 JSON 的二进制形式的存储格式，简称 Binary JSON，它和 JSON 一样，支持内嵌的文档对象和数组对象，但是 BSON 有 JSON 没有的一些数据类型，如 Date 和 BinData 类型，MongoDB 使用 BSON 做为文档数据存储和网络传输格式。本文我们就来说说 MongoDB 中都支持哪些数据类型，其实也是来看看 BSON 有哪些好玩的地方。</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>shell 默认使用 64 位浮点型数值，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collec.insert(&#123;x:3.1415926&#125;)</span><br><span class="line">db.sang_collec.insert(&#123;x:3&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://www.javaboy.org/images/mongodb/3-1.png" alt="p238"></p><p>对于整型值，我们可以使用 NumberInt 或者 NumberLong 表示，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collec.insert(&#123;x:NumberInt(10)&#125;)</span><br><span class="line">db.sang_collec.insert(&#123;x:NumberLong(12)&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://www.javaboy.org/images/mongodb/3-2.png" alt="p239"></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串也可以直接存储，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collec.insert(&#123;x:&quot;hello MongoDB!&quot;&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://www.javaboy.org/images/mongodb/3-3.png" alt="p240"></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式主要用在查询里边，查询时我们可以使用正则表达式，语法和 JavaScript 中正则表达式的语法相同，比如查询所有 key 为 x ，value 以 hello 开始的文档且不区分大小写：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collec.find(&#123;x:/^(hello)(.[a-zA-Z0-9])+/i&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://www.javaboy.org/images/mongodb/3-4.png" alt="p241"></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组一样也是被支持的，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collec.insert(&#123;x:[1,2,3,4,new Date()]&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://www.javaboy.org/images/mongodb/3-5.png" alt="242"></p><p>数组中的数据类型可以是多种多样的。</p><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>MongoDB 支持 Date 类型的数据，可以直接 new 一个 Date 对象，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collec.insert(&#123;x:new Date()&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://www.javaboy.org/images/mongodb/3-6.png" alt="p243"></p><h2 id="内嵌文档"><a href="#内嵌文档" class="headerlink" title="内嵌文档"></a>内嵌文档</h2><p>一个文档也可以作为另一个文档的 value，这个其实很好理解，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.insert(&#123;name:&quot;三国演义&quot;,author:&#123;name:&quot;罗贯中&quot;,age:99&#125;&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://www.javaboy.org/images/mongodb/3-7.png" alt="p244"><br>书有一个属性是作者，作者又有 name，年龄等属性。</p><h2 id="ObjectId"><a href="#ObjectId" class="headerlink" title="ObjectId"></a>ObjectId</h2><p>我们在前面提到过，我们每次插入一条数据系统都会自动帮我们插入一个 <code>_id</code> 键，这个键的值不可以重复，它可以是任何类型的，我们也可以手动的插入，默认情况下它的数据类型是 ObjectId，由于 MongoDB 在设计之初就是用作分布式数据库，所以使用 ObjectId 可以避免不同数据库中 <code>_id</code> 的重复（如果使用自增的方式在分布式系统中就会出现重复的 <code>_id</code> 的值），这个特点有点类似于 Git 中的版本号和 Svn 中版本号的区别。</p><p>ObjectId 使用 12 字节的存储空间，每个字节可以存储两个十六进制数字，所以一共可以存储 24 个十六进制数字组成的字符串，在这 24 个字符串中，前 8 位表示时间戳，接下来 6 位是一个机器码，接下来 4 位表示进程 id，最后 6 位表示计数器。</p><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>MongoDB 中也可以存储二进制数据，不过这种情况并不多，二进制数据的存储不能在 shell 中操作，我们在后面的代码中会介绍这种存储方式。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>文档中也可以包括 JavaScript 代码，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.sang_collect.insert(&#123;x:function f1(a,b)&#123;return a+b;&#125;&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://www.javaboy.org/images/mongodb/3-8.png" alt="p245"></p><p>好了，MongoDB 的数据类型我们就先介绍这么多，这里只是做一个大致的了解，后文我们还会再详细的说到这些东西的详细使用方式。小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们介绍了 MongoDB 的最基本的增删改查操作，也介绍了一些基础的概念，MongoDB 中每条记录称作一个文档，这个文档和我们平时用的 JSON 有点像，但也不完全一样。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
</feed>
