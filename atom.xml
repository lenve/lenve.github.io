<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2019-11-20T02:12:39.203Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给大家整理了几个开源免费的 Spring Boot + Vue 学习资料</title>
    <link href="http://www.javaboy.org/2019/1120/sprinkgboot-vue.html"/>
    <id>http://www.javaboy.org/2019/1120/sprinkgboot-vue.html</id>
    <published>2019-11-20T01:52:13.000Z</published>
    <updated>2019-11-20T02:12:39.203Z</updated>
    
    <content type="html"><![CDATA[<p>最近抽空在整理前面的文章案例啥的，顺便把手上的几个 Spring Boot + Vue 的学习资料推荐给各位小伙伴。这些案例有知识点的讲解，也有项目实战，正在做这一块的小伙伴们可以收藏下。</p><a id="more"></a><h2 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h2><h3 id="javaboy-video-samples"><a href="#javaboy-video-samples" class="headerlink" title="javaboy-video-samples"></a>javaboy-video-samples</h3><ul><li>项目地址：<a href="https://github.com/lenve/javaboy-video-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-video-samples</a></li></ul><p>这个是松哥录制的 Spring Boot2 系列视频教程的案例，视频是加密的，但是案例从一开始就是开源的，这个可以毫无保留的共享给大家，案例可以说是非常全面，这个仓库会随着视频的录制而继续完善。</p><p><img src="http://www.javaboy.org/images/other/88-1.png" alt></p><h3 id="javaboy-code-samples"><a href="#javaboy-code-samples" class="headerlink" title="javaboy-code-samples"></a>javaboy-code-samples</h3><ul><li>项目地址：<a href="https://github.com/lenve/javaboy-code-samples" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples</a></li></ul><p>这个是我平时公众号上文章的案例，因为公众号的文章大部分都是以 Spring Boot + Vue 前后端分离开发为主，所以这些文章也是这一方面的，不同于上面的那个仓库，这里的每个案例都有对应的文章进行讲解，这个仓库中的内容会随着公众号文章的增加而继续增加：</p><p><img src="http://www.javaboy.org/images/other/88-2.png" alt></p><h3 id="spring-boot-vue-samples"><a href="#spring-boot-vue-samples" class="headerlink" title="spring-boot-vue-samples"></a>spring-boot-vue-samples</h3><ul><li>项目地址：<a href="https://github.com/lenve/spring-boot-vue-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-boot-vue-samples</a></li></ul><p>这个是松哥《Spring Boot + Vue 全栈开发实战》一书的官方案例，但是因为书里给出来的地址是一个百度云盘的地址，所以这个仓库很少受到小伙伴们的关注。不过这套案例的整理的不是很满意，另外这套案例也比较旧了，是去年的，所以建议小伙伴们关注第一个，里边的案例比较新，也比较整齐。</p><p><img src="http://www.javaboy.org/images/other/88-3.png" alt></p><h3 id="Spring-Boot2"><a href="#Spring-Boot2" class="headerlink" title="Spring Boot2"></a>Spring Boot2</h3><ul><li>项目地址：<a href="http://springboot.javaboy.org" target="_blank" rel="noopener">http://springboot.javaboy.org</a></li></ul><p>这个不是 GitHub 上的仓库，是松哥一系列 Spring Boot 相关文章的集合，我把它做成了电子书的形式，但是有两个不太满意的地方：一个是文章排版不太满意，另一个则是网站托管在国外服务器上，访问速度较慢，因此这个在线的电子书我最近也在整理，整理完成后，我会分享出来给大家免费下载，小伙伴们多多关注公众号上的消息哦。</p><p><img src="http://www.javaboy.org/images/other/88-4.png" alt></p><h3 id="awesome-github-vue"><a href="#awesome-github-vue" class="headerlink" title="awesome-github-vue"></a>awesome-github-vue</h3><ul><li>项目地址：<a href="https://github.com/opendigg/awesome-github-vue" target="_blank" rel="noopener">https://github.com/opendigg/awesome-github-vue</a></li></ul><p>这个不是松哥的仓库，这是我刚开始学习 Vue 的时候收藏的一个仓库，感觉非常棒，很多常用的 Vue 插件这里都有，不过稍微遗憾的是，这个仓库有两年没有更新了，不过对于刚刚开始接触 Vue 的小伙伴而言，这个仓库够用了。</p><p><img src="http://www.javaboy.org/images/other/88-5.png" alt><br><img src="http://www.javaboy.org/images/other/88-6.png" alt><br><img src="http://www.javaboy.org/images/other/88-7.png" alt></p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>项目就不用多说了，V 部落和微人事。</p><h3 id="微人事"><a href="#微人事" class="headerlink" title="微人事"></a>微人事</h3><ul><li>项目地址：<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li></ul><p>关于微人事我已经写过好多文章了，这里就不再赘述了，要告诉大家的一个好消息是，大概在 12 月，微人事会进行一次全面的版本升级，Spring Boot 切换到当前最新版，Vue 构建工具切换到 vue-cli3，而且还会引入消息中间件 RabbitMQ 等一些外部工具，进一步扩展微人事所涉及到的知识点。微人事项目最新体验地址：</p><ul><li><a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">http://vhr.itboyhub.com</a></li></ul><p>当然，松哥之前也录过一个微人事部署视频，大家可以参考：</p><h3 id="V-部落"><a href="#V-部落" class="headerlink" title="V 部落"></a>V 部落</h3><ul><li>项目地址：<a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>V 部落没有微人事那么丰富的文档，但是比较简单，业务简单，用到的技术点也简单，不过好多小伙伴竟然反映部署不起来，以后我看时间抽空也可以录一个部署教程吧，V 部落目前最新的体验地址是：</p><ul><li><a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">http://vblog.itboyhub.com</a></li></ul><p>最后再悄悄告诉大家，公众号后台回复 <code>2TB</code> 可以获取 2TB Java 学习资源下载地址哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近抽空在整理前面的文章案例啥的，顺便把手上的几个 Spring Boot + Vue 的学习资料推荐给各位小伙伴。这些案例有知识点的讲解，也有项目实战，正在做这一块的小伙伴们可以收藏下。&lt;/p&gt;
    
    </summary>
    
      <category term="学习资源" scheme="http://www.javaboy.org/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="学习资源" scheme="http://www.javaboy.org/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离，我怎么就选择了 Spring Boot + Vue 技术栈？</title>
    <link href="http://www.javaboy.org/2019/1119/springboot-vue-stack.html"/>
    <id>http://www.javaboy.org/2019/1119/springboot-vue-stack.html</id>
    <published>2019-11-19T01:51:53.000Z</published>
    <updated>2019-11-20T02:07:33.232Z</updated>
    
    <content type="html"><![CDATA[<p>前两天又有小伙伴私信松哥，问题还是职业规划，Java 技术栈路线这种，实际上对于这一类问题我经常不太敢回答，每个人的情况都不太一样，而小伙伴也很少详细介绍自己的情况，大都是一两句话就把问题抛出来了，啥情况都不了解，就要指出一个方向，这实在是太难了。</p><a id="more"></a><p>因此今天我想从我学习 Spring Boot + Vue 这套技术栈的角度，来和大家聊一聊没有人指导，我是如何一步一步建立起自己的技术体系的。</p><p>线上大家看我经常写文章，线下我其实比较宅，跟人交流比较少，我也很少问别人职业规划或者技术规划这些问题，因为这种学什么的问题，我喜欢自己把握，我不太喜欢被别人牵着走。</p><p><code>Rome was not built in a day</code>，刚开始接触 Spring Boot + Vue 时，我甚至都没有一个明确的想法，只是觉得该学点什么，不能让时间浪费，没有告诉我 Spring Boot 要火了，也没有人告诉我 Vue 要超过 React 了，都是我自己一直在摸索摸索，一步一步，直到构建起这套技术大厦。</p><h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>先说说 Spring Boot 吧，三年前差不多也是这个时候，是我第一次接触 Spring Boot ，那个时候我的正式身份还是一名 Android 工程师，那段时间在研究 Android7 的源码，还写了一些博客：</p><p><img src="http://www.javaboy.org/images/other/87-1.png" alt></p><p>但是那个时候 Android 的行情在慢慢下滑，而我刚毕业 1 年多，未来还有更加丰富的技术人生，我不愿意这么早就把技术栈定死，而且还定在一个行情日渐下滑的技术栈上。所以我打算学一点新的东西。</p><p>Python、Go、前端 和 Java 都是备选的方向，但是最终还是选择继续做 Java，有三个原因：</p><ul><li>做 Java 当时可以在公司内部转岗，做 Python 或者 Go 的话，可能就得换工作了，技术栈切换，一切从头开始，当时心里还是没底，于是就选择继续做 Java</li><li>刚好大学的时候也有 JavaEE 的底子，重新捡起来 JavaEE 相关的技术点倒也不是啥难事</li><li>第三点也是最重要的一点，我一直希望能够独立接点私活，这样有一天赚钱能够不受工作地点的限制，基于这样的初衷，我一直希望走全栈的路线，用 Python 和 Go 虽然也可以做企业级应用，但是在目前的技术环境下，这并不算是主流方案，主流方案依然是 Java ，虽然它被被多人吐槽</li></ul><p>基于以上三点，我决定还是走 Java 的方向吧。</p><p>2016 年那会，CSDN 几乎每个月送我一本技术图书，10 月份的图书我就和梦鸽美女要了一本 Spring Boot 相关的书，书到了之后，一直在忙各种事情没时间看，到了当年 12 月份的时候，公司安排我去深圳出差，出差的话，每天下班后时间就比较充裕了，于是我就带上了书，每天下班回到酒店，就开始搞 Spring Boot。</p><p>一开始我就发现这玩意相比我大学时候搞得 XML 配置的 SSM 太好用了，还是 SSM 那套东西，但是有了自动化配置，不用再去写让人头大的 XML 配置了，可以基于 Spring Boot 快速搞一个 SSM 应用出来。不过刚开始学的时候我还不知道 Spring Boot 在 Java 领域如此火爆，当我写了几篇博客之后，我发现每篇博客的阅读量都暴涨，远远高于其他博客的阅读，我隐隐约约感觉到这次稀里糊涂的技术栈切换，算是没走错路。</p><p>不过老实说，Spring Boot 技术栈其实不算难，都是 SSM 那一套东西，只是多了自动化配置（当然，Spring Boot 也有不少自己的东西，不过整体上基于 SSM 这点应该没啥争议），我刚开始搞 Spring Boot 的时候，有时候会有一些东西看的云里雾里，后来发现问题出在 Spring + SpringMVC 上，好几年不写 JavaEE，这些东西有一点点生疏了，后来又花了一些时间把 SSM 这些东西系统过了一遍，然后再去看 Spring Boot 就顺畅多了。</p><p>所以有一些小伙伴问松哥能不能跳过 SSM 直接学习 Spring Boot，这个我不建议，大家在 Spring Boot 中见到的很多神奇的自动化配置大部分都是基于 Spring 现有功能实现的，要是不懂实现原理，你会发现 Spring Boot 用得时候虽然好用，但是出了问题，你就束手无策了。</p><p>就这样，跳入了 Spring Boot 的坑里了。Spring Boot 学完没多久，工作上，马上要从 Android 切换到 JavaEE 了，亟需一个项目练练手，当时我的上司给我介绍了一个西藏大学的项目，我使用 Spring Boot+EasyUI 的技术栈花了不到一个礼拜做完了，从此就算是叩开了 JavaEE 的大门，那会是 2017 年。</p><p>当时前端选择 EasyUI 也是没办法，甲方催得紧，而我来不及搞其他的前端框架，当时只有 EasyUI 熟悉一些，不用花时间学，直接就能用，于是就选择了 EasyUI，但是 EasyUI 太丑了，所以在做完西藏大学的项目后，我就一直思量着再整一个专业的前端框架，这样以后再有私活，我就可以独立做出来一个好看的后端管理系统了。</p><p>就这样，在综合对比了 Vue、React 以及 Angular 之后，决定跳入 Vue 的坑。</p><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>前端其实还算接触的比较早，最早的 jQuery Mobile，PhoneGap 上大学的时候就玩过，我的第一本 NodeJS 的书是在 2013 年买的，那个时候 NodeJS 还算是一个比较新的事物。当我还是一名 Android 工程师的时候，我就玩过 React 和 ReactNative，RN 是当时比较流行的一个跨平台解决方案。但是在我比较这三个技术栈的时候，我发现 Vue 更加好用，生态也更加丰富，而且大有超过 React 的架势（当时 Vue 在 GitHub 上的 star 数还没超过 React），于是我就选择了 Vue。其实当时我心里想，大不了学完 Vue 再学 React，反正我才刚毕业两年多，没必要这么早就锁定技术栈停止学习。</p><p>Vue 的学习确实不费啥事，花了两三天时间刷了一遍官网，然后就开始做项目，但是要去深入学习，又是一个漫长的过程了。</p><p>Vue 有很多漂亮的 UI 库，像 ElementUI 等都算是做的比较好的，这些东西只要会用其中一个，其他的就可以手到擒来。</p><p>到 2018 年初，Spring Boot+Vue 技术栈基本上已经熟悉了，两个开源项目 V 部落(<a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>)和微人事(<a href="https://mp.weixin.qq.com/s/yr24hKXQdXBivGSTCRUufg" target="_blank" rel="noopener">视频揭秘微人事项目实现过程</a>)也受到小伙伴们的欢迎，常规的企业级应用可以一个人独立完成了，5 月份的时候，经朋友介绍，接了哈尔滨工程大学一位老师的项目，毫无疑问我就使用了最擅长的 Spring Boot+Vue 技术栈来做了，前后端都是自己做，没人扯皮，美滋滋。</p><p>再后来，就是写书（<a href="https://mp.weixin.qq.com/s/IJZukUhu-Rec8lF9KQseoQ" target="_blank" rel="noopener">我的第一本书，被选作大学教材了！</a>），业余继续搞点项目用 Spring Boot + Vue 来做，这些以前都和大家聊过我就不再多说了，业余接点项目来做这块倒是有一些经验，以后和小伙伴们细聊。</p><p>就这样，没有任何人的指引，我慢慢构建了 Spring Boot + Vue 这套技术体系，这个过程中，<strong>最大的学习经验就是要写博客，做笔记，写博客不仅仅是记录，也是总结提炼，在写的过程中，融入自己的思考，加深对技术的理解。</strong> 掌握了这套技术栈之后，我觉得我离全栈又更近了一步，离赚钱不受工作地点的限制这个目标也更近一步了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有前辈大佬的指引，你可能走得快，自己摸索，走的踏实。其实从我第一天自学 Java 开始，基本上都是一直在摸索。大学时候一个 BUG 折腾两三天才解决，但是一旦自己想明白解决了，以后类似的错误不会再犯，这是我的感受。</p><p>好了，一点点学习经验，和小伙伴们分享，要是觉得有启发，欢迎转发哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天又有小伙伴私信松哥，问题还是职业规划，Java 技术栈路线这种，实际上对于这一类问题我经常不太敢回答，每个人的情况都不太一样，而小伙伴也很少详细介绍自己的情况，大都是一两句话就把问题抛出来了，啥情况都不了解，就要指出一个方向，这实在是太难了。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://www.javaboy.org/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://www.javaboy.org/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>快来，松哥的免费资源库更新啦</title>
    <link href="http://www.javaboy.org/2019/1112/java-video.html"/>
    <id>http://www.javaboy.org/2019/1112/java-video.html</id>
    <published>2019-11-12T01:51:36.000Z</published>
    <updated>2019-11-20T02:02:52.952Z</updated>
    
    <content type="html"><![CDATA[<p>今年 5 月份的时候，松哥发了一个视频资源库，当时和大家说，这个资源库会定期更新，后来却迟迟未更新，其实不是我没资源了，是因为当时的关键字是我一个一个在微信后台配置的，配置到后面发现，后台配置关键字有数量上限，没法继续配置了，所以这事就搁置下来了。</p><a id="more"></a><p>九月份松哥上线了自己的服务，和微信的后台对接起来，具体实现大家可以参考这两篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw" target="_blank" rel="noopener">Spring Boot 开发微信公众号后台</a></li><li><a href="https://mp.weixin.qq.com/s/1jTl9kBeFeibjbe5EbsCzg" target="_blank" rel="noopener">Spring Boot 如何给微信公众号返回消息</a></li></ul><p>现在再配置关键字就没有限制了。于是最近抽空把资源更新了一波，废话不多说，大家在公众号【江南一点雨】后台回复相应的口令，就可以获取相应的视频下载地址。</p><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">Java 基础语法</td><td>javaboy4096</td></tr><tr><td style="text-align:left">Java 面向对象</td><td>javaboy6148</td></tr><tr><td style="text-align:left">JavaSE 飞机大战项目</td><td>javaboy2053</td></tr><tr><td style="text-align:left">深入面向对象和数组</td><td>javaboy8200</td></tr><tr><td style="text-align:left">Java 常用类详解</td><td>javaboy4105</td></tr><tr><td style="text-align:left">Java 异常机制解析</td><td>javaboy6157</td></tr><tr><td style="text-align:left">Java 集合与数据结构</td><td>javaboy2062</td></tr><tr><td style="text-align:left">JavaIO 流全解析</td><td>javaboy8209</td></tr><tr><td style="text-align:left">深入理解 Java 多线程</td><td>javaboy4114</td></tr><tr><td style="text-align:left">Java 网络编程</td><td>javaboy6166</td></tr><tr><td style="text-align:left">手动开发一个 Web 服务器</td><td>javaboy2071</td></tr><tr><td style="text-align:left">深入理解 Java 注解+反射</td><td>javaboy8218</td></tr><tr><td style="text-align:left">Java23 种设计模式</td><td>javaboy4123</td></tr><tr><td style="text-align:left">学会 Java 正则表达式</td><td>javaboy6175</td></tr><tr><td style="text-align:left">JDBC 详解</td><td>javaboy2080</td></tr><tr><td style="text-align:left">独立开发 SORM 框架</td><td>javaboy8227</td></tr><tr><td style="text-align:left">快人一步，Java10 新特性全解析</td><td>javaboy4132</td></tr><tr><td style="text-align:left">Java 数据结构和算法</td><td>javaboy6184</td></tr><tr><td style="text-align:left">深入理解 Java 虚拟机</td><td>javaboy2089</td></tr><tr><td style="text-align:left">Java 解析XML文件</td><td>javaboy8236</td></tr></tbody></table><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">Oracle 数据库安装及简单 SQL</td><td>javaboy4141</td></tr><tr><td style="text-align:left">Oracle 账户管理及查询语句</td><td>javaboy6193</td></tr><tr><td style="text-align:left">Oracle 中的函数</td><td>javaboy2098</td></tr><tr><td style="text-align:left">Oracle 中的子查询</td><td>javaboy8245</td></tr><tr><td style="text-align:left">Oracle 中常见的表操作</td><td>javaboy4150</td></tr><tr><td style="text-align:left">Oracle 中的数据备份</td><td>javaboy6202</td></tr><tr><td style="text-align:left">MySQL 基础</td><td>javaboy2107</td></tr><tr><td style="text-align:left">PowerDesigner 教程</td><td>javaboy8254</td></tr><tr><td style="text-align:left">JDBC 操作数据库</td><td>javaboy4159</td></tr><tr><td style="text-align:left">MySQL 优化</td><td>javaboy6211</td></tr><tr><td style="text-align:left">Oracle 高级课程</td><td>javaboy2116</td></tr><tr><td style="text-align:left">数据库与 SQL 优化</td><td>javaboy6283</td></tr><tr><td style="text-align:left">数据库集群与高并发</td><td>javaboy2188</td></tr></tbody></table><h2 id="Web-基础"><a href="#Web-基础" class="headerlink" title="Web 基础"></a>Web 基础</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">HTML 入门教程</td><td>javaboy8263</td></tr><tr><td style="text-align:left">CSS 教程</td><td>javaboy4168</td></tr><tr><td style="text-align:left">JavaScript 视频教程</td><td>javaboy6220</td></tr><tr><td style="text-align:left">jQuery 视频教程</td><td>javaboy2125</td></tr><tr><td style="text-align:left">EasyUI 视频教程</td><td>javaboy8272</td></tr><tr><td style="text-align:left">Servlet 基础</td><td>javaboy4177</td></tr><tr><td style="text-align:left">Servlet 中的 Request 和 Response</td><td>javaboy6229</td></tr><tr><td style="text-align:left">Servlet 请求转发与重定向</td><td>javaboy2134</td></tr><tr><td style="text-align:left">Session 和 Cookie</td><td>javaboy8281</td></tr><tr><td style="text-align:left">JSP 详解</td><td>javaboy4186</td></tr><tr><td style="text-align:left">用户管理系统实战</td><td>javaboy6238</td></tr><tr><td style="text-align:left">Ajax 详解</td><td>javaboy2143</td></tr><tr><td style="text-align:left">EL 和 JSTL</td><td>javaboy8290</td></tr><tr><td style="text-align:left">过滤器详解</td><td>javaboy4195</td></tr><tr><td style="text-align:left">监听器详解</td><td>javaboy6247</td></tr><tr><td style="text-align:left">KnockoutJS 实战视频</td><td>javaboy2152</td></tr></tbody></table><h2 id="Java-高级"><a href="#Java-高级" class="headerlink" title="Java 高级"></a>Java 高级</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">IntelliJIDEA 视频教程</td><td>javaboy4285</td></tr><tr><td style="text-align:left">Java 高并发秒杀方案</td><td>javaboy8299</td></tr><tr><td style="text-align:left">Activiti 工作流实战解析</td><td>javaboy4204</td></tr><tr><td style="text-align:left">Java 并发编程与高并发实战</td><td>javaboy6256</td></tr><tr><td style="text-align:left">Linux 快速入门</td><td>javaboy2161</td></tr><tr><td style="text-align:left">Maven 详解</td><td>javaboy8308</td></tr><tr><td style="text-align:left">Git 应用详解</td><td>javaboy4213</td></tr><tr><td style="text-align:left">Svn 入门教程</td><td>javaboy6265</td></tr><tr><td style="text-align:left">高并发编程与线程池</td><td>javaboy2170</td></tr><tr><td style="text-align:left">系统优化与 JVM 调优</td><td>javaboy8317</td></tr><tr><td style="text-align:left">Java 编程规范</td><td>javaboy4222</td></tr><tr><td style="text-align:left">AIO、BIO、NIO 详解</td><td>javaboy6274</td></tr><tr><td style="text-align:left">Netty 高级视频教程</td><td>javaboy2179</td></tr><tr><td style="text-align:left">ActiveMQ 消息中间详解</td><td>javaboy8326</td></tr><tr><td style="text-align:left">单点登录视频教程</td><td>javaboy4231</td></tr><tr><td style="text-align:left">Dubbo 详解</td><td>javaboy8335</td></tr><tr><td style="text-align:left">Redis 全解析</td><td>javaboy4240</td></tr><tr><td style="text-align:left">VSFTPD+NGINX 视频教程</td><td>javaboy6292</td></tr><tr><td style="text-align:left">MyBatis 视频教程</td><td>javaboy2197</td></tr><tr><td style="text-align:left">Spring4 视频教程</td><td>javaboy8344</td></tr><tr><td style="text-align:left">SpringMVC 视频教程</td><td>javaboy4249</td></tr><tr><td style="text-align:left">SSM 框架整合视频教程</td><td>javaboy6301</td></tr><tr><td style="text-align:left">RBAC 权限控制视频教程</td><td>javaboy2206</td></tr><tr><td style="text-align:left">Hibernate4 视频教程</td><td>javaboy8353</td></tr><tr><td style="text-align:left">Jfinal 视频教程</td><td>javaboy4258</td></tr><tr><td style="text-align:left">Shiro 视频教程</td><td>javaboy6310</td></tr><tr><td style="text-align:left">Solr 视频教程</td><td>javaboy2215</td></tr><tr><td style="text-align:left">Struts2 视频教程</td><td>javaboy8362</td></tr><tr><td style="text-align:left">Nginx 视频教程</td><td>javaboy4267</td></tr><tr><td style="text-align:left">Redis 缓存详解</td><td>javaboy6319</td></tr><tr><td style="text-align:left">JVM 虚拟机优化</td><td>javaboy2224</td></tr><tr><td style="text-align:left">Zookeeper 详解视频</td><td>javaboy8371</td></tr><tr><td style="text-align:left">Linux 基本操作</td><td>javaboy6328</td></tr><tr><td style="text-align:left">架构师面试攻略（文档）</td><td>javaboy2233</td></tr><tr><td style="text-align:left">架构师面试攻略（视频）</td><td>javaboy8380</td></tr><tr><td style="text-align:left">JUC 视频教程</td><td>javaboy6400</td></tr><tr><td style="text-align:left">MySQL 高级教程</td><td>javaboy2305</td></tr><tr><td style="text-align:left">Java 邮件开发教程</td><td>javaboy8452</td></tr><tr><td style="text-align:left">Maven 实战视频</td><td>javaboy8443</td></tr><tr><td style="text-align:left">自己 DIY 一个 Tomcat</td><td>javaboy4339</td></tr></tbody></table><h2 id="大前端"><a href="#大前端" class="headerlink" title="大前端"></a>大前端</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">HTML5 新特性</td><td>javaboy4276</td></tr><tr><td style="text-align:left">AngularJS 视频教程</td><td>javaboy6337</td></tr><tr><td style="text-align:left">Grunt 视频教程</td><td>javaboy2242</td></tr><tr><td style="text-align:left">Gulp 视频教程</td><td>javaboy8389</td></tr><tr><td style="text-align:left">Webpack 视频教程</td><td>javaboy4294</td></tr><tr><td style="text-align:left">Bootstrap 视频教程</td><td>javaboy6346</td></tr><tr><td style="text-align:left">CSS3 视频教程</td><td>javaboy2251</td></tr><tr><td style="text-align:left">ES6 视频教程</td><td>javaboy8398</td></tr><tr><td style="text-align:left">HTML5 核心技术</td><td>javaboy4303</td></tr><tr><td style="text-align:left">HTML5 实战</td><td>javaboy6355</td></tr><tr><td style="text-align:left">HTML5 项目实战</td><td>javaboy2260</td></tr><tr><td style="text-align:left">JS 模块化视频教程</td><td>javaboy8407</td></tr><tr><td style="text-align:left">less 视频教程</td><td>javaboy4312</td></tr><tr><td style="text-align:left">NodeJS 视频教程</td><td>javaboy6364</td></tr><tr><td style="text-align:left">React 视频教程</td><td>javaboy2269</td></tr><tr><td style="text-align:left">Zepto 视频教程</td><td>javaboy8416</td></tr><tr><td style="text-align:left">HTML+CSS 实战视频</td><td>javaboy4321</td></tr><tr><td style="text-align:left">JavaScript140 集</td><td>javaboy6373</td></tr><tr><td style="text-align:left">jQuery 视频教程</td><td>javaboy2278</td></tr><tr><td style="text-align:left">JavaScript 高级语法视频教程</td><td>javaboy8425</td></tr><tr><td style="text-align:left">Vue 项目实战视频</td><td>javaboy4330</td></tr><tr><td style="text-align:left">CSS3 特效实战</td><td>javaboy6382</td></tr><tr><td style="text-align:left">HTML5 特效实战</td><td>javaboy2287</td></tr><tr><td style="text-align:left">HTML5+Canvas 实现刮刮卡</td><td>javaboy8434</td></tr><tr><td style="text-align:left">Gradle 从入门到精通</td><td>javaboy6391</td></tr><tr><td style="text-align:left">mpvue 项目实战</td><td>javaboy2296</td></tr><tr><td style="text-align:left">Vue 最新最全视频教程</td><td>javaboy4348</td></tr></tbody></table><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">Linux 操作系统</td><td>javaboy4357</td></tr><tr><td style="text-align:left">Linux 基本命令</td><td>javaboy6409</td></tr><tr><td style="text-align:left">Linux 文件安装</td><td>javaboy2314</td></tr><tr><td style="text-align:left">Shell 编程</td><td>javaboy8461</td></tr><tr><td style="text-align:left">网络基础知识</td><td>javaboy4366</td></tr><tr><td style="text-align:left">LVS 集群与高并发</td><td>javaboy6418</td></tr><tr><td style="text-align:left">Nginx 和高并发</td><td>javaboy2323</td></tr><tr><td style="text-align:left">keepalive 和单点故障</td><td>javaboy8470</td></tr><tr><td style="text-align:left">HDFS 分布式文件系统</td><td>javaboy4375</td></tr><tr><td style="text-align:left">mapreduce 分布式计算</td><td>javaboy6427</td></tr><tr><td style="text-align:left">YARN 资源管理与任务调度</td><td>javaboy2332</td></tr><tr><td style="text-align:left">mapreduce 计算案例</td><td>javaboy8479</td></tr><tr><td style="text-align:left">HIVE 视频教程</td><td>javaboy4384</td></tr><tr><td style="text-align:left">Hbase 数据库详解</td><td>javaboy6436</td></tr><tr><td style="text-align:left">zookeeper 协同处理</td><td>javaboy2341</td></tr><tr><td style="text-align:left">CDH 使用</td><td>javaboy8488</td></tr><tr><td style="text-align:left">HUE 使用</td><td>javaboy4393</td></tr><tr><td style="text-align:left">IMPALA 详解</td><td>javaboy6445</td></tr><tr><td style="text-align:left">oozie 详解</td><td>javaboy2350</td></tr><tr><td style="text-align:left">elasticsearch 详解</td><td>javaboy8497</td></tr><tr><td style="text-align:left">Redis 内存数据</td><td>javaboy4402</td></tr><tr><td style="text-align:left">Scala 入门</td><td>javaboy6454</td></tr><tr><td style="text-align:left">Spark 详解</td><td>javaboy2359</td></tr><tr><td style="text-align:left">Spark 高级</td><td>javaboy8506</td></tr><tr><td style="text-align:left">Spark-Stream 流式计算</td><td>javaboy4411</td></tr><tr><td style="text-align:left">Kafka 分布式消息队列</td><td>javaboy6463</td></tr><tr><td style="text-align:left">STORM 流式计算框架</td><td>javaboy2368</td></tr><tr><td style="text-align:left">Python 语言基础</td><td>javaboy8515</td></tr><tr><td style="text-align:left">回归算法</td><td>javaboy4420</td></tr><tr><td style="text-align:left">分类算法、决策树</td><td>javaboy6472</td></tr><tr><td style="text-align:left">聚类算法、微博案例</td><td>javaboy2377</td></tr><tr><td style="text-align:left">推荐算法</td><td>javaboy8524</td></tr><tr><td style="text-align:left">大型电商日志分析（项目实战）</td><td>javaboy4429</td></tr><tr><td style="text-align:left">智慧交通（项目实战）</td><td>javaboy6481</td></tr><tr><td style="text-align:left">智能 App（项目实战）</td><td>javaboy2386</td></tr></tbody></table><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">人工智能入门</td><td>javaboy8533</td></tr><tr><td style="text-align:left">线性回归深入与代码实现</td><td>javaboy4438</td></tr><tr><td style="text-align:left">梯度下降算发实现</td><td>javaboy6490</td></tr><tr><td style="text-align:left">逻辑回归详解和应用</td><td>javaboy2395</td></tr><tr><td style="text-align:left">分类项目案例与神经网络算法</td><td>javaboy8542</td></tr><tr><td style="text-align:left">多分类、决策树分类与随机森林分类</td><td>javaboy4447</td></tr><tr><td style="text-align:left">分类评估与聚类</td><td>javaboy6499</td></tr><tr><td style="text-align:left">密度聚类与谱聚类</td><td>javaboy2404</td></tr><tr><td style="text-align:left">Tensorflow 安装并实现线性回归</td><td>javaboy8551</td></tr><tr><td style="text-align:left">TensorFlow 深入、TensorFlow可视化</td><td>javaboy4456</td></tr><tr><td style="text-align:left">DNN 深度神经网络手写图片识别</td><td>javaboy6508</td></tr><tr><td style="text-align:left">TensorBoard 可视化</td><td>javaboy2413</td></tr><tr><td style="text-align:left">卷积神经网络、CNN 识别图片</td><td>javaboy8560</td></tr><tr><td style="text-align:left">卷积神经网络深入，AlexNet 模型实现</td><td>javaboy4465</td></tr><tr><td style="text-align:left">Keras 深度学习框架</td><td>javaboy6517</td></tr></tbody></table><h2 id="分布式相关"><a href="#分布式相关" class="headerlink" title="分布式相关"></a>分布式相关</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">ZooKeeper 简介</td><td>javaboy2422</td></tr><tr><td style="text-align:left">ZooKeeper 安装</td><td>javaboy8569</td></tr><tr><td style="text-align:left">ZooKeeper 基本数据模型</td><td>javaboy4474</td></tr><tr><td style="text-align:left">基于 Linux 的 ZK 客户端命令</td><td>javaboy6526</td></tr><tr><td style="text-align:left">选举模式和 ZK 集群安装</td><td>javaboy2431</td></tr><tr><td style="text-align:left">JavaAPI 操作 ZK</td><td>javaboy8578</td></tr><tr><td style="text-align:left">ApacheCurator 客户端</td><td>javaboy4483</td></tr><tr><td style="text-align:left">Dubbo 入门到重构服务</td><td>javaboy6535</td></tr><tr><td style="text-align:left">分布式锁</td><td>javaboy2440</td></tr><tr><td style="text-align:left">Zookeeper 总结</td><td>javaboy8587</td></tr></tbody></table><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">OA 办公自动化项目1</td><td>javaboy4492</td></tr><tr><td style="text-align:left">OA 办公自动化项目2</td><td>javaboy6544</td></tr><tr><td style="text-align:left">OA 办公自动化项目3</td><td>javaboy2449</td></tr><tr><td style="text-align:left">OA 办公自动化项目4</td><td>javaboy8596</td></tr><tr><td style="text-align:left">备锋客户关系管理(CRM)系统</td><td>javaboy4501</td></tr><tr><td style="text-align:left">百战客户关系管理系统</td><td>javaboy6553</td></tr><tr><td style="text-align:left">宅急送项目</td><td>javaboy2458</td></tr><tr><td style="text-align:left">高仿人人网项目</td><td>javaboy8605</td></tr><tr><td style="text-align:left">Java 邮件开发项目</td><td>javaboy4510</td></tr><tr><td style="text-align:left">在线支付实战视频</td><td>javaboy6562</td></tr><tr><td style="text-align:left">俄罗斯方块游戏实战</td><td>javaboy2467</td></tr><tr><td style="text-align:left">贪吃蛇视频教程</td><td>javaboy8614</td></tr><tr><td style="text-align:left">交通灯管理系统</td><td>javaboy4519</td></tr><tr><td style="text-align:left">银行业务调度系统实战</td><td>javaboy6571</td></tr><tr><td style="text-align:left">供应链系统实战视频</td><td>javaboy2476</td></tr><tr><td style="text-align:left">网上商城项目实战</td><td>javaboy8623</td></tr><tr><td style="text-align:left">医药采购平台管理系统</td><td>javaboy4528</td></tr><tr><td style="text-align:left">点餐系统实战</td><td>javaboy6580</td></tr><tr><td style="text-align:left">杰信商贸 SSM 版</td><td>javaboy2485</td></tr><tr><td style="text-align:left">国家税务协同平台项目</td><td>javaboy8632</td></tr><tr><td style="text-align:left">javaWeb 聊天室</td><td>javaboy4537</td></tr><tr><td style="text-align:left">网上书店</td><td>javaboy6589</td></tr><tr><td style="text-align:left">手机进销存系统</td><td>javaboy2494</td></tr><tr><td style="text-align:left">QQ 聊天器</td><td>javaboy8641</td></tr><tr><td style="text-align:left">ERP 项目</td><td>javaboy4546</td></tr><tr><td style="text-align:left">坦克大战</td><td>javaboy6598</td></tr><tr><td style="text-align:left">五子棋游戏</td><td>javaboy2503</td></tr><tr><td style="text-align:left">报名系统 Activity</td><td>javaboy8650</td></tr><tr><td style="text-align:left">OA 供应链系统</td><td>javaboy4555</td></tr><tr><td style="text-align:left">用户管理系统</td><td>javaboy6607</td></tr><tr><td style="text-align:left">JavaWeb 图书商城</td><td>javaboy2512</td></tr><tr><td style="text-align:left">VIP 商场</td><td>javaboy8659</td></tr><tr><td style="text-align:left">企业招聘系统</td><td>javaboy4564</td></tr><tr><td style="text-align:left">博客系统项目</td><td>javaboy6616</td></tr><tr><td style="text-align:left">超级玛丽</td><td>javaboy2521</td></tr><tr><td style="text-align:left">成绩管理系统</td><td>javaboy8668</td></tr><tr><td style="text-align:left">个人理财系统</td><td>javaboy4573</td></tr><tr><td style="text-align:left">人事管理系统</td><td>javaboy6625</td></tr><tr><td style="text-align:left">JBPM 采购申请系统</td><td>javaboy2530</td></tr><tr><td style="text-align:left">电子商务网站</td><td>javaboy8677</td></tr><tr><td style="text-align:left">跨平台 App 开发</td><td>javaboy4582</td></tr></tbody></table><h2 id="文档资源"><a href="#文档资源" class="headerlink" title="文档资源"></a>文档资源</h2><table><thead><tr><th style="text-align:left">资源名称</th><th>口令</th></tr></thead><tbody><tr><td style="text-align:left">Docker 教程</td><td>docker</td></tr><tr><td style="text-align:left">Redis 教程</td><td>redis</td></tr><tr><td style="text-align:left">RocketMQ 教程</td><td>rocketmq</td></tr><tr><td style="text-align:left">Java8 新特性文档</td><td>java8</td></tr><tr><td style="text-align:left">设计模式教程</td><td>设计模式</td></tr><tr><td style="text-align:left">网络协议教程</td><td>网络</td></tr><tr><td style="text-align:left">netty 教程</td><td>netty</td></tr><tr><td style="text-align:left">web 全栈指南</td><td>web全栈</td></tr></tbody></table><p><strong>好了，本次就先更新这么多，如果这里没有你想要的，也也可以留言说说你需要的资料，松哥会及时更新资源哦。</strong> 另外，大家在公众号后台回复 <strong>资源</strong> ，也可以获取本文电子版。</p><p><img src="http://www.javaboy.org/images/other/86-1.png" alt></p><p>如果这些资源帮助到你了，欢迎转发给更多小伙伴哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年 5 月份的时候，松哥发了一个视频资源库，当时和大家说，这个资源库会定期更新，后来却迟迟未更新，其实不是我没资源了，是因为当时的关键字是我一个一个在微信后台配置的，配置到后面发现，后台配置关键字有数量上限，没法继续配置了，所以这事就搁置下来了。&lt;/p&gt;
    
    </summary>
    
      <category term="学习资源" scheme="http://www.javaboy.org/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="学习资源" scheme="http://www.javaboy.org/tags/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>还在用 Dockerfile 部署 Spring Boot？out 啦！试试谷歌的大杀器 Jib</title>
    <link href="http://www.javaboy.org/2019/1107/docker-springboot.html"/>
    <id>http://www.javaboy.org/2019/1107/docker-springboot.html</id>
    <published>2019-11-07T02:33:35.000Z</published>
    <updated>2019-11-20T03:02:33.010Z</updated>
    
    <content type="html"><![CDATA[<p>之前松哥和大家分享过一篇将 Spring Boot 项目部署到远程 Docker 上的文章：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/vSCQLvQBYMYoPhdlO2v3XA" target="_blank" rel="noopener">一键部署 Spring Boot 到远程 Docker 容器</a></li></ul><p>但是这种部署有一个问题，就是一个小小的 helloworld 构建成镜像之后，竟然都有 660 MB+，这就有点过分了；而且这种方式步骤繁琐，很多人看了头大。</p><p>因此松哥今天想再和大家聊一聊另外一种方案 <strong>Jib</strong>，这是谷歌开源的一个容器化运行方案，使用它我们将 Spring Boot 进行容器化部署只要两步：</p><ul><li>第一步配置 Maven Plugin</li><li>第二步构建</li></ul><p>我们一起来看看。</p><h2 id="Jib"><a href="#Jib" class="headerlink" title="Jib"></a>Jib</h2><p>在之前那篇文章中，我们将 Spring Boot 项目进行容器化部署，要求开发人员要有一定的 Docker 技能作为支撑，然而在实际开发中，并非每个人都是 Docker 专家，或者说会用 Docker。</p><p>有鉴于此，Google 搞出来一个 Jib，使 Spring Boot 容器化部署变得更加简便，开发人员可以不需要任何 Docker 相关的技能，就能将 Spring Boot 项目构建成 Docker 中的镜像，而且还可以“顺便”将镜像 push 到 register 上，极大的简化了部署过程。</p><p>Jib 使用 Java 开发，使用也非常简单，可以作为 Maven 或者 Gradle 的插件直接集成到我们的项目中。它利用镜像分层和注册表缓存来实现快速、增量的构建。Jib 会自动读取项目的构建配置，代码组织到不同的层（依赖项、资源、类）中，然后它只会重新构建和推送发生变更的层。在项目进行快速迭代时，Jib 只将发生变更的层推送到 registers 来缩短构建时间。</p><p>好了，大致了解了 Jib 之后，接下来我们来看看 Jib 要怎么使用。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Jib 可以直接将构建好的镜像 push 到 registers 上，如果公司有自己的私有镜像站的话，可以直接推送到私有镜像站上，本文我就将构建好的镜像推送到官方的 Docker Hub 上，因此需要大家提前准备一个 Docker Hub 的账号，账号大家可以直接去 Docker Hub 上面注册（<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a>），大家要是对 Docker Hub 这些东西不了解，可以在公众号后台回复 docker，获取松哥自制的 Docker 教程。</p><h2 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h2><p>首先我们来创建一个 Spring Boot 工程，创建时只需要添加一个 Web 依赖即可：</p><p><img src="http://www.javaboy.org/images/boot/46-1.png" alt></p><p>项目创建成功后，添加一个 HelloController 用来做测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello jib"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在 pom.xml 中添加上 Jib 的插件，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.cloud.tools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jib-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>openjdk:alpine<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>docker.io/wongsung/dockerjib<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">tags</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">tag</span>&gt;</span>v1<span class="hljs-tag">&lt;/<span class="hljs-name">tag</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">tags</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">auth</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>wongsung<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>你的密码<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">auth</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于这段配置，我说如下几点：</p><ol><li>首先就是版本号的问题，我这里使用的是 <code>1.7.0</code> ，网上有的教程比较老，用的 0.x 的版本，老的版本在配置 Docker 认证的时候非常麻烦，所以版本这块建议大家使用当前最新版。</li><li>from 中的配置表示本镜像构建所基于的根镜像为 <code>openjdk:alpine</code></li><li>to 中的配置表示本镜像构建完成后，要发布到哪里去，如果是发布到私有镜像站，就写自己私有镜像站的地址，如果是发布到 Docker Hub 上，就参考我这里的写法 <code>docker.io/wongsung/dockerjib</code>，其中 wongsung 表示你在 Docker Hub 上注册的用户名，dockerjib 表示你镜像的名字，可以随意取。</li><li>tags 中配置的是自己镜像的版本。</li><li>auth 中配置你在 Docker Hub 上的用户名/密码。</li><li>executions 节点中的就是常规配置了，我就不再多说了。</li></ol><p>配置完成后，在命令行执行如下命令将当前下项目构建成一个 Docker 镜像并 push 到 Docker Hub：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile jib:build</span><br></pre></td></tr></table></figure><p>构建完成后，我们在 Docker Hub 上就能看到自己的镜像了：</p><p><img src="http://www.javaboy.org/images/boot/46-2.png" alt></p><p>接下来，启动 Docker ，在 Docker 中执行如下命令拉取镜像下来并运行：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mydockerjib -p 8080:8080 docker.io/wongsung/dockerjib:v1</span><br></pre></td></tr></table></figure><p>启动成功后，我们在浏览器中就可以直接访问我们刚才的 Spring Boot 项目中的 hello 接口了：</p><p><img src="http://www.javaboy.org/images/boot/46-3.png" alt></p><p>是不是很方便？比我第一次给大家介绍的方案要方便很多。</p><p><strong>注意</strong></p><p>这种方式是将项目构建成镜像后并 push 到 registers 上，这种构建方式不需要你本地安装 Docker，如果你需要在本地运行镜像，那当然需要 Docker，单纯的构建是不需要 Docker 环境的。</p><h2 id="本地构建"><a href="#本地构建" class="headerlink" title="本地构建"></a>本地构建</h2><p>如果你电脑本地刚好安装了 Docker ，有 Docker 环境，那么也可以将项目构建成本地 Docker 的镜像，</p><p>首先我们来查看一下本地镜像：</p><p><img src="http://www.javaboy.org/images/boot/46-4.png" alt></p><p>可以看到只有 MySQL 镜像，然后我们执行如下命令构建本地镜像：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn compile jib:dockerBuild</span><br></pre></td></tr></table></figure><p>看到如下构建日志信息表示构建成功：</p><p><img src="http://www.javaboy.org/images/boot/46-5.png" alt></p><p>构建完成后，我们再来看本地镜像：</p><p><img src="http://www.javaboy.org/images/boot/46-6.png" alt></p><p>可以都看到，已经构建成功了，接下来启动命令和上面一样，我就不重复展示了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>容器的出现，让我们的 Java 程序比任何时候都接近“一次编写，到处运行”，Spring Boot 容器化部署也是越来越方便，后面有空松哥再和大家聊聊结合 jenkins 的用法，好了，本文的案例我已经上传到 GitHub：<a href="https://github.com/lenve/javaboy-code-samples，有问题欢迎留言讨论。" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples，有问题欢迎留言讨论。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前松哥和大家分享过一篇将 Spring Boot 项目部署到远程 Docker 上的文章：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Docker" scheme="http://www.javaboy.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker 搭建 MySQL 主从复制</title>
    <link href="http://www.javaboy.org/2019/1101/docker-mysql.html"/>
    <id>http://www.javaboy.org/2019/1101/docker-mysql.html</id>
    <published>2019-11-01T02:34:22.000Z</published>
    <updated>2019-11-20T02:48:43.402Z</updated>
    
    <content type="html"><![CDATA[<p>hello 各位小伙伴大家好，今年 5 月份的时候，松哥和大家聊过如何搭建 MySQL 主从复制：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/_lsNyXHrsu131mHONQi5rg" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(一)</a></li><li><a href="https://mp.weixin.qq.com/s/SC0OYM6yO_GxQh9DvSsnoQ" target="_blank" rel="noopener">提高性能，MySQL 读写分离环境搭建(二)</a></li></ul><p>不过很多小伙伴反映在 Linux 中安装 MySQL 比较费劲，弄错了想从头开始都难，因此今天松哥就来和大家分享一下如何通过 Docker 快速搭建 MySQL 主从复制。</p><h2 id="关于-Docker"><a href="#关于-Docker" class="headerlink" title="关于 Docker"></a>关于 Docker</h2><p>关于 Docker，松哥这里就不再多说了，松哥之前有出过一个 Docker 教程，大家在公众号后台回复 Docker ，就可以获取教程下载地址。</p><h2 id="主从规划"><a href="#主从规划" class="headerlink" title="主从规划"></a>主从规划</h2><p>首先规划两个 MySQL 实例：</p><ul><li>192.168.66.131:33061/主机</li><li>192.168.66.131:33062/从机</li></ul><p>当然大家可以准备多个从机，从机的配置步骤是一样的。</p><p>在 Docker 中创建两个 MySQL 实例的命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql1 -p 33061:3306 -e MYSQL_ROOT_PASSWORD=123 -d mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line">docker run --name mysql2 -p 33062:3306 -e MYSQL_ROOT_PASSWORD=123 -d mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure><p>创建完成后，通过 <code>docker ps</code> 命令可以查看 MySQL 实例的运行情况：</p><p><img src="http://www.javaboy.org/images/mysql/10-0.png" alt></p><p>如此，表示 MySQL 实例已经在运行了。使用 Docker 配置 MySQL 主从最方便的莫过于配错了可以非常方便的从头开始。</p><p>接下来，我们就开始主从的配置。</p><h2 id="配置主机"><a href="#配置主机" class="headerlink" title="配置主机"></a>配置主机</h2><p>主机上的配置，主要是两个地方：</p><ul><li>第一个是配置一个从机登录用户</li><li>第二个配置开启 binlog。</li></ul><p>Docker 中创建的 MySQL 实例，默认只有一个用户，就是 root，这里我们需要进入到 MySQL 命令行，再给它分配一个用户。在宿主机中通过如下命令连接上主机：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -h 192.168.66.131 -P 33061 -p</span><br></pre></td></tr></table></figure><p>输入密码后，进入到主机的命令行。然后给从机分配用户(因为我的宿主机上也安装了 MySQL，所以可以直接执行 mysql 命令，如果宿主机没有安装 MySQL，建议通过 <code>docker exec</code> 进入到 MySQL 容器中，然后执行如下命令)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* to &apos;rep1&apos;@&apos;%&apos; identified by &apos;123&apos;;</span><br></pre></td></tr></table></figure><p>这个表示从机一会使用 <code>rep1/123</code> 来登录主机，<code>%</code> 表示这个账户可以从任意地址登录，也可以给一个固定的 <code>IP</code>，表示这个账户只能从某一个 IP 登录。</p><p><img src="http://www.javaboy.org/images/mysql/10-1.png" alt></p><p>接下来开启 binlog。</p><p>binlog 的开启，需要修改 MySQL 的配置，因此，我们需要进入到容器内部去执行。</p><p>首先进入到容器内部：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql1 /bin/bash</span><br></pre></td></tr></table></figure><p>然后找到 MySQL 配置文件的位置：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p>这就是 MySQL 的配置文件。我们要在这里进行修改操作。因为 MySQL 容器中，默认没有 VI 编辑器，安装费事，所以我们可以在宿主机中将配置文件写好，然后拷贝到 MySQL 容器中，覆盖原有配置。我们主要在该配置文件中添加如下内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log-bin=/var/lib/mysql/binlog</span><br><span class="line">server-id=1</span><br><span class="line">binlog-do-db = cmdb</span><br></pre></td></tr></table></figure><ul><li>第一行表示配置 binlog 的位置，理论上 binlog 可以放在任意位置，但是该位置，MySQL 一定要有操作权限。</li><li>server-id 表示集群中，每个实例的唯一标识符。</li><li>bindlog-do-db 表示要同步的数据库有哪些。当从机连上主机后，并不是主机中的每一个库都要同步，这里表示配置哪些库需要同步。</li></ul><p><img src="http://www.javaboy.org/images/mysql/10-2.png" alt></p><p>配置完成后，保存退出。</p><p>接下来执行命令，将宿主机中的 mysqld.cnf 拷贝到容器中：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp ./mysqld.cnf mysql1:/etc/mysql/mysql.conf.d/</span><br></pre></td></tr></table></figure><p>拷贝完成后，重启容器。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql1</span><br></pre></td></tr></table></figure><p>容器重启完成后，进入到主机的命令行中，查看配置是否成功：</p><p><img src="http://www.javaboy.org/images/mysql/10-3.png" alt></p><p>File 和 Position 需要记着，这两个标记了二进制日志的起点位置，在从机的配置中将使用到这两个参数。</p><p>至此，主机的配置就算完成了。</p><h2 id="配置从机"><a href="#配置从机" class="headerlink" title="配置从机"></a>配置从机</h2><p>从机的配置比较简单，不用开启 binlog，也不用配置要同步的库，只需要在配置文件中，添加一个 server-id 即可。</p><p>这是从机的 mysqld.cnf 配置：</p><p><img src="http://www.javaboy.org/images/mysql/10-4.png" alt></p><p>配置完成后，一样拷贝到容器中。拷贝方式和主机一样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp ./mysqld.cnf mysql2:/etc/mysql/mysql.conf.d/</span><br></pre></td></tr></table></figure><p>配置完成后，重启从机容器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql2</span><br></pre></td></tr></table></figure><p>重启完成后，进入到 mysql2 的命令行，执行如下命令，开启数据同步：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;192.168.66.131&apos;,master_port=33061,master_user=&apos;rep1&apos;,master_password=&apos;123&apos;,master_log_file=&apos;binlog.000001&apos;,master_log_pos=154;</span><br></pre></td></tr></table></figure><p><img src="http://www.javaboy.org/images/mysql/10-5.png" alt></p><p>配置完成后，开启从机进程。在从机命令行执行如下命令：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><p><img src="http://www.javaboy.org/images/mysql/10-6.png" alt></p><p>接下来，执行 show slave status\G；查看从机状态：</p><p><img src="http://www.javaboy.org/images/mysql/10-7.png" alt></p><p>这里重点查看 Slave_IO_Running 和 Slave_SQL_Running ，这两个的值必须为 Yes。如果有一个的值不为 Yes，表示配置失败，一般情况下，配置失败，下面会有失败提示。</p><p>至此，我们的 MySQL 主从就算是配置成功了。</p><h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p>配置成功之后，我们可以通过 Navicat 或者 SQLyog 等工具连接上我们的两个 MySQL 实例，然后在主机中创建一个名为 db1 的库，你会发现从机中也会自动同步这个库。</p><p>OK，本文就说这么多，有问题欢迎大家留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 各位小伙伴大家好，今年 5 月份的时候，松哥和大家聊过如何搭建 MySQL 主从复制：&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="Docker" scheme="http://www.javaboy.org/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 开发微信公众号后台(二)</title>
    <link href="http://www.javaboy.org/2019/1031/springboot-weixin.html"/>
    <id>http://www.javaboy.org/2019/1031/springboot-weixin.html</id>
    <published>2019-10-31T02:32:24.000Z</published>
    <updated>2019-11-20T03:01:42.598Z</updated>
    
    <content type="html"><![CDATA[<p>hello 各位小伙伴，今天我们来继续学习如何通过 Spring Boot 开发微信公众号。还没阅读过上篇文章的小伙伴建议先看看上文，有助于理解本文：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/f3QexxLp9vT6aE1Pl3jHGw" target="_blank" rel="noopener">Spring Boot 开发微信公众号后台</a></li></ul><p>上篇文章中我们将微信服务器和我们自己的服务器对接起来了，并且在自己的服务器上也能收到微信服务器发来的消息，本文我们要看的就是如何给微信服务器回复消息。</p><h2 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h2><p>在讨论如何给微信服务器回复消息之前，我们需要先来了解下微信服务器发来的消息主要有哪些类型以及我们回复给微信的消息都有哪些类型。</p><p>在上文中大家了解到，微信发送来的 xml 消息中有一个 MsgType 字段，这个字段就是用来标记消息的类型。这个类型可以标记出这条消息是普通消息还是事件消息还是图文消息等。</p><p>普通消息主要是指：</p><ul><li>文本消息</li><li>图片消息</li><li>语音消息</li><li>视频消息</li><li>小视频消息</li><li>地址位置消息</li><li>链接消息</li></ul><p>不同的消息类型，对应不同的 MsgType，这里我还是以普通消息为例，如下：</p><table><thead><tr><th style="text-align:left">消息类型</th><th style="text-align:left">MsgType</th></tr></thead><tbody><tr><td style="text-align:left">文本消息</td><td style="text-align:left">text</td></tr><tr><td style="text-align:left">图片消息</td><td style="text-align:left">image</td></tr><tr><td style="text-align:left">语音消息</td><td style="text-align:left">voice</td></tr><tr><td style="text-align:left">视频消息</td><td style="text-align:left">video</td></tr><tr><td style="text-align:left">小视频消息</td><td style="text-align:left">shortvideo</td></tr><tr><td style="text-align:left">地址位置消息</td><td style="text-align:left">location</td></tr><tr><td style="text-align:left">链接消息</td><td style="text-align:left">link</td></tr></tbody></table><p>大家千万不要以为不同类型消息的格式是一样的，其实是不一样的，也就是说，MsgType 为 text 的消息和 MsgType 为 image 的消息，微信服务器发给我们的消息内容是不一样的，这样带来一个问题就是我无法使用一个 Bean 去接收不同类型的数据，因此这里我们一般使用 Map 接收即可。</p><p>这是消息的接收，除了消息的接收之外，还有一个消息的回复，我们回复的消息也有很多类型，可以回复普通消息，也可以回复图片消息，回复语音消息等，不同的回复消息我们可以进行相应的封装。因为不同的返回消息实例也是有一些共同的属性的，例如消息是谁发来的，发给谁，消息类型，消息 id 等，所以我们可以将这些共同的属性定义成一个父类，然后不同的消息再去继承这个父类。</p><h2 id="返回消息类型定义"><a href="#返回消息类型定义" class="headerlink" title="返回消息类型定义"></a>返回消息类型定义</h2><p>首先我们来定义一个公共的消息类型：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String ToUserName;</span><br><span class="line">    <span class="hljs-keyword">private</span> String FromUserName;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> CreateTime;</span><br><span class="line">    <span class="hljs-keyword">private</span> String MsgType;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> MsgId;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li>ToUserName 表示开发者的微信号</li><li>FromUserName 表示发送方账号（用户的 OpenID）</li><li>CreateTime 消息的创建时间</li><li>MsgType 表示消息的类型</li><li>MsgId 表示消息 id</li></ul><p>这是我们的基本消息类型，就是说，我们返回给用户的消息，无论是什么类型的消息，都有这几个基本属性。然后在此基础上，我们再去扩展出文本消息、图片消息 等。</p><p>我们来看下文本消息的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String Content;</span><br><span class="line">    <span class="hljs-comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文本消息在前面消息的基础上多了一个 Content 属性，因此文本消息继承自 BaseMessage ，再额外添加一个 Content 属性即可。</p><p>其他的消息类型也是类似的定义，我就不一一列举了，至于其他消息的格式，大家可以参考微信开放文档（<a href="http://1t.click/aPXK）。" target="_blank" rel="noopener">http://1t.click/aPXK）。</a></p><h2 id="返回消息生成"><a href="#返回消息生成" class="headerlink" title="返回消息生成"></a>返回消息生成</h2><p>消息类型的 Bean 定义完成之后，接下来就是将实体类生成 XML。</p><p>首先我们定义一个消息工具类，将常见的消息类型枚举出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：文本</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_TEXT = <span class="hljs-string">"text"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：音乐</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_MUSIC = <span class="hljs-string">"music"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：图文</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_NEWS = <span class="hljs-string">"news"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：图片</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Image = <span class="hljs-string">"image"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：语音</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Voice = <span class="hljs-string">"voice"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 返回消息类型：视频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RESP_MESSAGE_TYPE_Video = <span class="hljs-string">"video"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：文本</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_TEXT = <span class="hljs-string">"text"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：图片</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_IMAGE = <span class="hljs-string">"image"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：链接</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_LINK = <span class="hljs-string">"link"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：地理位置</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_LOCATION = <span class="hljs-string">"location"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：音频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_VOICE = <span class="hljs-string">"voice"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：视频</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_VIDEO = <span class="hljs-string">"video"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 请求消息类型：推送</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REQ_MESSAGE_TYPE_EVENT = <span class="hljs-string">"event"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：subscribe(订阅)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_SUBSCRIBE = <span class="hljs-string">"subscribe"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：unsubscribe(取消订阅)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_UNSUBSCRIBE = <span class="hljs-string">"unsubscribe"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：CLICK(自定义菜单点击事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_CLICK = <span class="hljs-string">"CLICK"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：VIEW(自定义菜单 URl 视图)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_VIEW = <span class="hljs-string">"VIEW"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：LOCATION(上报地理位置事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_LOCATION = <span class="hljs-string">"LOCATION"</span>;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 事件类型：LOCATION(上报地理位置事件)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EVENT_TYPE_SCAN = <span class="hljs-string">"SCAN"</span>;</span><br></pre></td></tr></table></figure><p>大家注意这里消息类型的定义，以 RESP 开头的表示返回的消息类型，以 REQ 表示微信服务器发来的消息类型。然后在这个工具类中再定义两个方法，用来将返回的对象转换成 XML：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">textMessageToXml</span><span class="hljs-params">(TextMessage textMessage)</span> </span>&#123;</span><br><span class="line">    xstream.alias(<span class="hljs-string">"xml"</span>, textMessage.getClass());</span><br><span class="line">    <span class="hljs-keyword">return</span> xstream.toXML(textMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> XStream xstream = <span class="hljs-keyword">new</span> XStream(<span class="hljs-keyword">new</span> XppDriver() &#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> HierarchicalStreamWriter <span class="hljs-title">createWriter</span><span class="hljs-params">(Writer out)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PrettyPrintWriter(out) &#123;</span><br><span class="line">            <span class="hljs-keyword">boolean</span> cdata = <span class="hljs-keyword">true</span>;</span><br><span class="line">            <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"rawtypes"</span>)</span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startNode</span><span class="hljs-params">(String name, Class clazz)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">super</span>.startNode(name, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeText</span><span class="hljs-params">(QuickWriter writer, String text)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (cdata) &#123;</span><br><span class="line">                    writer.write(<span class="hljs-string">"&lt;![CDATA["</span>);</span><br><span class="line">                    writer.write(text);</span><br><span class="line">                    writer.write(<span class="hljs-string">"]]&gt;"</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    writer.write(text);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>textMessageToXML 方法用来将 TextMessage 对象转成 XML 返回给微信服务器，类似的方法我们还需要定义 imageMessageToXml、voiceMessageToXml 等，不过定义的方式都基本类似，我就不一一列出来了。</p><h2 id="返回消息分发"><a href="#返回消息分发" class="headerlink" title="返回消息分发"></a>返回消息分发</h2><p>由于用户发来的消息可能存在多种情况，我们需要分类进行处理，这个就涉及到返回消息的分发问题。因此我在这里再定义一个返回消息分发的工具类，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageDispatcher</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">processMessage</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        String openid = map.get(<span class="hljs-string">"FromUserName"</span>); <span class="hljs-comment">//用户 openid</span></span><br><span class="line">        String mpid = map.get(<span class="hljs-string">"ToUserName"</span>);   <span class="hljs-comment">//公众号原始 ID</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (map.get(<span class="hljs-string">"MsgType"</span>).equals(MessageUtil.REQ_MESSAGE_TYPE_TEXT)) &#123; </span><br><span class="line">            <span class="hljs-comment">//普通文本消息</span></span><br><span class="line">            TextMessage txtmsg = <span class="hljs-keyword">new</span> TextMessage();</span><br><span class="line">            txtmsg.setToUserName(openid);</span><br><span class="line">            txtmsg.setFromUserName(mpid);</span><br><span class="line">            txtmsg.setCreateTime(<span class="hljs-keyword">new</span> Date().getTime());</span><br><span class="line">            txtmsg.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);</span><br><span class="line">            txtmsg.setContent(<span class="hljs-string">"这是返回消息"</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> MessageUtil.textMessageToXml(txtmsg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">processEvent</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//在这里处理事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还可以多加几个 elseif 去判断不同的消息类型，我这里因为只有普通文本消息，所以一个 if 就够用了。</p><p>在这里返回值我写死了，实际上这里需要根据微信服务端传来的 Content 去数据中查询，将查询结果返回，数据库查询这一套相信大家都能搞定，我这里就不重复介绍了。</p><p>最后在消息接收 Controller 中调用该方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(value = <span class="hljs-string">"/verify_wx_token"</span>,produces = <span class="hljs-string">"application/xml;charset=utf-8"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">handler</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    Map&lt;String, String&gt; map = MessageUtil.parseXml(request);</span><br><span class="line">    String msgType = map.get(<span class="hljs-string">"MsgType"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (MessageUtil.REQ_MESSAGE_TYPE_EVENT.equals(msgType)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageDispatcher.processEvent(map);</span><br><span class="line">    &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> messageDispatcher.processMessage(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Controller 中，我们首先判断消息是否是事件，如果是事件，进入到事件处理通道，如果不是事件，则进入到消息处理通道。</p><p><strong>注意，这里需要配置一下返回消息的编码，否则可能会出现中文乱码。</strong></p><p>如此之后，我们的服务器就可以给公众号返回消息了。</p><p>上篇文章发出后，有小伙伴问松哥这个会不会开源，我可以负责任的告诉大家，肯定会开源，这个系列截稿后，我把代码处理下就上传到 GitHub。</p><p>好了，本文我们就先说到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 各位小伙伴，今天我们来继续学习如何通过 Spring Boot 开发微信公众号。还没阅读过上篇文章的小伙伴建议先看看上文，有助于理解本文：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="weixin" scheme="http://www.javaboy.org/tags/weixin/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 开发微信公众号后台</title>
    <link href="http://www.javaboy.org/2019/1029/springboot-weixin.html"/>
    <id>http://www.javaboy.org/2019/1029/springboot-weixin.html</id>
    <published>2019-10-29T02:32:07.000Z</published>
    <updated>2019-11-20T02:57:49.788Z</updated>
    
    <content type="html"><![CDATA[<p>Hello 各位小伙伴，松哥今天要和大家聊一个有意思的话题，就是使用 Spring Boot 开发微信公众号后台。</p><a id="more"></a><p>很多小伙伴可能注意到松哥的个人网站（<a href="http://www.javaboy.org）前一阵子上线了一个公众号内回复口令解锁网站文章的功能，还有之前就有的公众号内回复口令获取超" target="_blank" rel="noopener">http://www.javaboy.org）前一阵子上线了一个公众号内回复口令解锁网站文章的功能，还有之前就有的公众号内回复口令获取超</a> 2TB 免费视频教程的功能（<a href="https://mp.weixin.qq.com/s/yOVbTBVk4CJy6a0lrKjLXA" target="_blank" rel="noopener">免费视频教程</a>），这两个都是松哥基于 Spring Boot 来做的，最近松哥打算通过一个系列的文章，来向小伙伴们介绍下如何通过 Spring Boot 来开发公众号后台。</p><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1. 缘起"></a>1. 缘起</h2><p>今年 5 月份的时候，我想把我自己之前收集到的一些视频教程分享给公众号上的小伙伴，可是这些视频教程大太了，无法一次分享，单次分享分享链接立马就失效了，为了把这些视频分享给大家，我把视频拆分成了很多份，然后设置了不同的口令，小伙伴们在公众号后台通过回复口令就可以获取到这些视频，口令前前后后有 100 多个，我一个一个手动的在微信后台进行配置。这么搞工作量很大，前前后后大概花了三个晚上才把这些东西搞定。</p><p>于是我就在想，该写点代码了。</p><p>上个月买了服务器，也备案了，该有的都有了，于是就打算把这些资源用代码实现下，因为大学时候搞过公众号开发，倒也没什么难度，于是说干就干。</p><h2 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2. 实现思路"></a>2. 实现思路</h2><p>其实松哥这个回复口令获取视频链接的实现原理很简单，说白了，就是一个数据查询操作而已，回复的口令是查询关键字，回复的内容则是查询结果。这个原理很简单。</p><p>另一方面大家需要明白微信公众号后台开发消息发送的一个流程，大家看下面这张图：</p><p><img src="http://www.javaboy.org/images/boot/44-2.jpeg" alt></p><p>这是大家在公众号后台回复关键字的情况。那么这个消息是怎么样一个传递流程呢？我们来看看下面这张图：</p><p><img src="http://www.javaboy.org/images/boot/44-1.png" alt></p><p>这张图，我给大家稍微解释下：</p><ol><li>首先 <code>javaboy4096</code> 这个字符从公众号上发送到了微信服务器</li><li>接下来微信服务器会把 <code>javaboy4096</code> 转发到我自己的服务器上</li><li>我收到 <code>javaboy4096</code> 这个字符之后，就去数据库中查询，将查询的结果，按照腾讯要求的 XML 格式进行返回</li><li>微信服务器把从我的服务器收到的信息，再发回到微信上，于是小伙伴们就看到了返回结果了</li></ol><p>大致的流程就是这个样子。</p><p>接下来我们就来看一下实现细节。</p><h2 id="3-公众号后台配置"><a href="#3-公众号后台配置" class="headerlink" title="3. 公众号后台配置"></a>3. 公众号后台配置</h2><p>开发的第一步，是微信服务器要验证我们自己的服务器是否有效。</p><p>首先我们登录微信公众平台官网后，在公众平台官网的 <strong>开发-基本设置</strong> 页面，勾选协议成为开发者，然后点击“修改配置”按钮，填写：</p><ul><li>服务器地址（URL）</li><li>Token</li><li>EncodingAESKey</li></ul><p><img src="http://www.javaboy.org/images/boot/44-3.jpeg" alt></p><p>这里的 URL 配置好之后，我们需要针对这个 URL 开发两个接口，一个是 GET 请求的接口，这个接口用来做服务器有效性验证，另一个则是 POST 请求的接口，这个用来接收微信服务器发送来的消息。也就是说，微信服务器的消息都是通过 POST 请求发给我的。</p><p>Token 可由开发者可以任意填写，用作生成签名（该 Token 会和接口 URL 中包含的 Token 进行比对，从而验证安全性）。</p><p>EncodingAESKey 由开发者手动填写或随机生成，将用作消息体加解密密钥。</p><p>同时，开发者可选择消息加解密方式：明文模式、兼容模式和安全模式。明文模式就是我们自己的服务器收到微信服务器发来的消息是明文字符串，直接就可以读取并且解析，安全模式则是我们收到微信服务器发来的消息是加密的消息，需要我们手动解析后才能使用。</p><h2 id="4-开发"><a href="#4-开发" class="headerlink" title="4. 开发"></a>4. 开发</h2><p>公众号后台配置完成后，接下来我们就可以写代码了。</p><h3 id="4-1-服务器有效性校验"><a href="#4-1-服务器有效性校验" class="headerlink" title="4.1 服务器有效性校验"></a>4.1 服务器有效性校验</h3><p>我们首先来创建一个普通的 Spring Boot 项目，创建时引入 <code>spring-boot-starter-web</code> 依赖，项目创建成功后，我们创建一个 Controller ，添加如下接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/verify_wx_token"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    String signature = request.getParameter(<span class="hljs-string">"signature"</span>);</span><br><span class="line">    String timestamp = request.getParameter(<span class="hljs-string">"timestamp"</span>);</span><br><span class="line">    String nonce = request.getParameter(<span class="hljs-string">"nonce"</span>);</span><br><span class="line">    String echostr = request.getParameter(<span class="hljs-string">"echostr"</span>);</span><br><span class="line">    PrintWriter out = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        out = response.getWriter();</span><br><span class="line">        <span class="hljs-keyword">if</span> (CheckUtil.checkSignature(signature, timestamp, nonce)) &#123;</span><br><span class="line">            out.write(echostr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这段代码，我做如下解释：</p><ol><li>首先通过 request.getParameter 方法获取到微信服务器发来的 signature、timestamp、nonce 以及 echostr 四个参数，这四个参数中：signature 表示微信加密签名，signature 结合了开发者填写的 token 参数和请求中的timestamp参数、nonce参数；timestamp 表示时间戳；nonce    表示随机数；echostr    则表示一个随机字符串。</li><li>开发者通过检验 signature 对请求进行校验，如果确认此次 GET 请求来自微信服务器，则原样返回 echostr 参数内容，则接入生效，成为开发者成功，否则接入失败。</li><li>具体的校验就是松哥这里的 CheckUtil.checkSignature 方法，在这个方法中，首先将token、timestamp、nonce 三个参数进行字典序排序，然后将三个参数字符串拼接成一个字符串进行 sha1 加密，最后开发者获得加密后的字符串可与 signature 对比，标识该请求来源于微信。</li></ol><p>校验代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckUtil</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String token = <span class="hljs-string">"123456"</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkSignature</span><span class="hljs-params">(String signature, String timestamp, String nonce)</span> </span>&#123;</span><br><span class="line">        String[] str = <span class="hljs-keyword">new</span> String[]&#123;token, timestamp, nonce&#125;;</span><br><span class="line">        <span class="hljs-comment">//排序</span></span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        <span class="hljs-comment">//拼接字符串</span></span><br><span class="line">        StringBuffer buffer = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            buffer.append(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//进行sha1加密</span></span><br><span class="line">        String temp = SHA1.encode(buffer.toString());</span><br><span class="line">        <span class="hljs-comment">//与微信提供的signature进行匹对</span></span><br><span class="line">        <span class="hljs-keyword">return</span> signature.equals(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SHA1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] HEX_DIGITS = &#123;<span class="hljs-string">'0'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>,</span><br><span class="line">            <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>&#125;;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getFormattedText</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = bytes.length;</span><br><span class="line">        StringBuilder buf = <span class="hljs-keyword">new</span> StringBuilder(len * <span class="hljs-number">2</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            buf.append(HEX_DIGITS[(bytes[j] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0f</span>]);</span><br><span class="line">            buf.append(HEX_DIGITS[bytes[j] &amp; <span class="hljs-number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">encode</span><span class="hljs-params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string">"SHA1"</span>);</span><br><span class="line">            messageDigest.update(str.getBytes());</span><br><span class="line">            <span class="hljs-keyword">return</span> getFormattedText(messageDigest.digest());</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，完成之后，我们的校验接口就算是开发完成了。接下来就可以开发消息接收接口了。</p><h3 id="4-2-消息接收接口"><a href="#4-2-消息接收接口" class="headerlink" title="4.2 消息接收接口"></a>4.2 消息接收接口</h3><p>接下来我们来开发消息接收接口，消息接收接口和上面的服务器校验接口地址是一样的，都是我们一开始在公众号后台配置的地址。只不过消息接收接口是一个 POST 请求。</p><p>我在公众号后台配置的时候，消息加解密方式选择了明文模式，这样我在后台收到的消息直接就可以处理了。微信服务器给我发来的普通文本消息格式如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">xml</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">ToUserName</span>&gt;</span>&lt;![CDATA[toUser]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">ToUserName</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">FromUserName</span>&gt;</span>&lt;![CDATA[fromUser]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">FromUserName</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">CreateTime</span>&gt;</span>1348831860<span class="hljs-tag">&lt;/<span class="hljs-name">CreateTime</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">MsgType</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>&gt;</span>&lt;![CDATA[this is a test]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Content</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">MsgId</span>&gt;</span>1234567890123456<span class="hljs-tag">&lt;/<span class="hljs-name">MsgId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些参数含义如下：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ToUserName</td><td style="text-align:left">开发者微信号</td></tr><tr><td style="text-align:left">FromUserName</td><td style="text-align:left">发送方帐号（一个OpenID）</td></tr><tr><td style="text-align:left">CreateTime</td><td style="text-align:left">消息创建时间 （整型）</td></tr><tr><td style="text-align:left">MsgType</td><td style="text-align:left">消息类型，文本为text</td></tr><tr><td style="text-align:left">Content</td><td style="text-align:left">文本消息内容</td></tr><tr><td style="text-align:left">MsgId</td><td style="text-align:left">消息id，64位整型</td></tr></tbody></table><p>看到这里，大家心里大概就有数了，当我们收到微信服务器发来的消息之后，我们就进行 XML 解析，提取出来我们需要的信息，去做相关的查询操作，再将查到的结果返回给微信服务器。</p><p>这里我们先来个简单的，我们将收到的消息解析并打印出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/verify_wx_token"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    Map&lt;String, String&gt; parseXml = MessageUtil.parseXml(request);</span><br><span class="line">    String msgType = parseXml.get(<span class="hljs-string">"MsgType"</span>);</span><br><span class="line">    String content = parseXml.get(<span class="hljs-string">"Content"</span>);</span><br><span class="line">    String fromusername = parseXml.get(<span class="hljs-string">"FromUserName"</span>);</span><br><span class="line">    String tousername = parseXml.get(<span class="hljs-string">"ToUserName"</span>);</span><br><span class="line">    System.out.println(msgType);</span><br><span class="line">    System.out.println(content);</span><br><span class="line">    System.out.println(fromusername);</span><br><span class="line">    System.out.println(tousername);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; <span class="hljs-title">parseXml</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    InputStream inputStream = request.getInputStream();</span><br><span class="line">    SAXReader reader = <span class="hljs-keyword">new</span> SAXReader();</span><br><span class="line">    Document document = reader.read(inputStream);</span><br><span class="line">    Element root = document.getRootElement();</span><br><span class="line">    List&lt;Element&gt; elementList = root.elements();</span><br><span class="line">    <span class="hljs-keyword">for</span> (Element e : elementList)</span><br><span class="line">        map.put(e.getName(), e.getText());</span><br><span class="line">    inputStream.close();</span><br><span class="line">    inputStream = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看到其实都是一些常规代码，没有什么难度。</p><p>做完这些之后，我们将项目打成 jar 包在服务器上部署启动。启动成功之后，确认微信的后台配置也没问题，我们就可以在公众号上发一条消息了，这样我们自己的服务端就会打印出来刚刚消息的信息。</p><p>好了，篇幅限制，今天就和大家先聊这么多，后面再聊不同消息类型的解析和消息的返回问题。</p><p>不知道小伙伴们看懂没？有问题欢迎留言讨论。</p><p>参考资料：微信开放文档</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hello 各位小伙伴，松哥今天要和大家聊一个有意思的话题，就是使用 Spring Boot 开发微信公众号后台。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="weixin" scheme="http://www.javaboy.org/tags/weixin/"/>
    
  </entry>
  
  <entry>
    <title>1024，20个入行故事，浮世中见证着程序员的奋斗</title>
    <link href="http://www.javaboy.org/2019/1024/1024.html"/>
    <id>http://www.javaboy.org/2019/1024/1024.html</id>
    <published>2019-10-24T01:50:15.000Z</published>
    <updated>2019-11-20T02:01:10.823Z</updated>
    
    <content type="html"><![CDATA[<p>上周，在 1024 来临之际，松哥向大家征集程序员的入行故事，收到了许多小伙伴的留言。</p><a id="more"></a><p>有杭州某宝出来的大佬，也有华中某 985 毕业的程序员，也有自学转行的牛人，还有一些通过培训转行的程序员，每个人都有自己的精彩故事。</p><p>我一直觉得一个优秀的程序员必然是不停的学习，这些学习的故事见证了一个人技术之路上的成长。小伙伴们的留言很多都很精彩，无法一一列举，松哥这里就只遴选了 22 个入行故事和大家分享，哪位小伙伴的故事令你印象深刻，可以在文末给他投上一票，那么他就有可能获取松哥准备的大奖。</p><p>由于有的小伙伴需要匿名，所以我这里就用开发语言来来给每个故事进行编号，令你印象深刻的故事可以记着对应的开发语言哦，然后在文末进行投票。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><blockquote><p>18 岁前属于基耕道文青，破三本，18岁前没想过做工程师相关的职业，18那年在学校遇到了一帮有志青年，加入某学校技术组织，遇到了头儿和狮虎，19岁稀里糊涂从学校生活娱乐类网站某网编编程了某java后台开发，此后二年接触jsp servlet 自写小框架，struts1 struts2 springMVC…ajax…java 虚拟机…而后一年际遇高人恩师，去了杭州某宝，且与恩人合伙，又二年，家中召唤，遂携资回蓉，去了某成研院，不敢言衣锦二次，已饱腹无虑，路遇佳人，成缘，遂稀里糊涂买买买，买了好些水泥，而后至今，无变动，其间某司上市，亦获其蝇头小利，与水泥获利相比，不够塞牙，但看某司浪潮浪起，身边人来人去，终觉无趣，正欲归隐。</p></blockquote><hr><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><blockquote><p>两周面试了 7 家公司，最终在今年 3 月 20 在合肥入职，这六个月一路走来，真的很不容易！这也是我第一次从学校出来，正式步入社会，每天过着 12 点睡觉，6 点起床的日子，一刻都不敢多睡，因为我知道，新人只有多学习，才不会落伍，我每天争分夺秒的与时间竞争，我不敢睡觉，我甚至认为睡觉就是在浪费时间，哪天如果多睡几个小时，就会感觉到内疚，在陌生的城市，一个人，真的很不容易！加油。</p></blockquote><hr><h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><blockquote><p>我来讲讲我去华为实习的坑，实习刚开始被一个项目组老大联系，说的做的项目很高端，到了之后才发现项目组去年刚成立，大家都是刚从另一个方向转过来的，做的东西也和说的项目差别很大。进入项目组后，刚开始让花很大精力标注数据，时常会加班，有时候会在 6:30 之后开会。实习答辩，实习生的通过率大概在 1/3–1/2，周围很多参加秋招的同学都收到 offer 签约了。从 8 月中下旬答辩通过，等到现在都没有一点消息。听周围同学说，当实习岗位和正式工作内容不一致时（算法干开发，开发干测试）。这样就算通过答辩，还需要再重新面试一次，甚至重新参加秋招。（有个同学就是 8 月答辩，10 月中旬才通知让重新参加秋招，黄瓜菜早都凉了）</p></blockquote><hr><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><blockquote><p>谁能想到，我一个日语专业毕业的，会走上 JAVA 码农的道路。因为机遇，日本公司想试着在中国招聘没 JAVA 基础的日语系毕业生简单培训/自学四个月，即将踏上日本国土，唉，现在是日语天天被批评</p></blockquote><hr><h2 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h2><blockquote><p>17 岁某马培训出来的，找了大半年的工作，因为学历被拒绝了很多家，后来终于有一家录取我了，公司地方在河北沧州，过去以后被骗了，依稀还记得是 6 月 18 号到的，被关到了 6 月 23 号晚上 10 点放出来的，还被贷款了一万块钱财（我只想在这说 不是可怜啥的 只想提醒各位在找工作的和要出去找工作的一个提醒 一定要去查一下该公司 公司包住的千万一定一定要查 特别是外地让你过去的，直接去公司报道 不要相信人家会来接你），回到家后我还是在找工作 后来在找工作的 q 群里面找到了（当时我在那几个工作群很活跃 很多人知道我 我退群了，后来我加群后 继续找工作 然后说出来这个悲伤的故事）有几个好心人就收留了我，开的 3k 我现在还在公司做，已经有快3个多月了，加油吧，相信自己，万事开头难，没有什么过不去的坎</p></blockquote><hr><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><blockquote><p>我是大学修的双学位，主冶金(打铁)，另外一个是计算机，入了个门。也是在大学认识的女友，到现在七年了，今年领的证。大学毕业了没想着去干计算机相关的，就跑去钢铁厂了。后面女友快研究生毕业了，感觉来钢铁厂太亏待她了，就让她找工作往大城市找，自己自学 Java 也去同样的城市找工作。在钢铁厂上班的最后一年，一下班就自学，然后后面辞职了三个月自学再去找工作。那时候也是菜，找了半个多月才入的坑。1024了，keep study，day day up</p></blockquote><hr><h2 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h2><blockquote><p>第一次听到 1024 还是去年这个时候吧。那时候还在培训班培训，转眼出来工作快一年了。身为非科班的我，在帝都找了两个月找到一份勉强能保障自己生活的工作。这一年来，每天有时间就会不断的学习，因为我清楚我与别人的差距(基础很不扎实)。可能只有类似我这种的，才会清楚压力有多吧。这里不说培训班的好坏。至少它带你入了门。幸好努力还是有回报的，比起之前确实成长太多了。薪资也成长了蛮多。但是我惊喜的是我好像对编程真的感兴趣。</p></blockquote><hr><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><blockquote><p>因为家里发生了一些事情，所以离开了之前的工厂，来的北京，由于自己原来的专业属于重工业，在北京几乎找不到工作，所以就一边尝试新工作，一边发现北京这个地，什么适合自己，后来发现 Java 比较适合我，在咨询了一个同学后，决定学 Java。自学了差不多一个月吧，由于是闭门造车，结果没方向，不知道学些什么，后来报班学了半年，开始工作了</p></blockquote><hr><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><blockquote><p>17 年电气工程及其自动化毕业，毕业做了大半年发电厂工人，然后本来想去培训机构学 Python，当时还没开班，就先学了 java，从此爱上 java，感谢李刚老师，他的书写的详细易懂，给了我很多帮助，后来培训完，开始找工作，换工作，工作不到一年踩了很多坑，很艰难，但从来没后悔过</p></blockquote><hr><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><blockquote><p>2013 年底从山东滨州回到西安大本营（魏桥铝业相信山东的人并不陌生），头也不回的把抡大锤的工作辞掉了，回来也不知道干啥，陪朋友在西安送了三个月的快递，（对于我这种路痴，地方都找不到，更何况让我送快递），偶尔一次用朋友电脑上网，刚开始想学平面设计（一看要有画画的基础，立马觉得不合适，连个鸟都不会画），页面上显示出了编程的培训机构，达内（说有一周试听课），听了一周，就被老师连”拐带忽悠 ”的入了”坑“， 2014 年底终于出山，到现在 2019 年了， 5 年虽有过挫折困苦，但我们必须碾破困苦，我是程序员，我骄傲。</p></blockquote><hr><h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><blockquote><p>18 年决心学编程，为什么选择 Java 呢？曾经用塞班玩游戏的时候那个一杯咖啡启动画面深深印在心中，当在选择什么编程语言的时候，搜了下语言排行榜，接着各种百度排行第一的 Java，当搜索结果出现那杯咖啡，我滴个亲娘，好亲切的 log,那是一杯我的青春啊。然后在我要自学网自学了 Java 基础，感觉 Java 可以搞，后来就报了个培训班，现在是馅在那杯咖啡里无法自拔。</p></blockquote><hr><h2 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h2><blockquote><p>大四学生，之前一年一直在刚 cv，本来打算出国继续读，幸好看清了行情(可能是自己设水平不够），刚转学开发 10 天，幸好有一点基础，一开始就看了松哥视频，感觉完全就是我想要的！太棒了！昨天刚开始看微人事，加油大家！！！</p></blockquote><hr><h2 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h2><blockquote><p>百度：喵喵喵，这也能黑我？都怪我年少不懂事，经不住诱惑一时脚滑，进了一个 1024 社区，不然纯洁的我哪里能成为纵横<strong>X矧?燉鵡羖は繵脺</strong>的老司机呢？至于为什么走向开发，还不是因为要饿死了，2016 年华中某 985 劝退专业毕业，去广州某国企拿 3000 工资，要不是地方偏僻，钱不太好用出去，讲不定真饿死咯。给我点赞的估计都是老司机了，也别问我要资源了，我已经从良了，被杀了一网盘也就剩个硬盘了。</p></blockquote><hr><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><blockquote><p>15 年机械专业毕业。农村娃，高考完选专业的时候也是啥都不了解，就想学个工科，当时把专业里面带自动化的全选了一遍，结果就入了机械的坑。大学生活过得平淡无奇，虽然对专业没有多大兴趣，但是成绩还可以，毕业之后，进入了一家国企，一干就是三年。在国企，低微的收入，压抑的工作氛围，还有一些官僚主义让我迷茫彷徨，借鉴周围朋友的成功经历，让我下定决心转行学 IT。去年这个时候辞职，直接去找了一家 JAVA 培训机构，学费一万八，培训了 5 个月吧。培训学习的那段时间很辛苦但是也很充实，每天都是新的知识，白天上一天，晚上还有自习，甚至回到家里还要学习一会儿，每天一两点睡觉再正常不过了。周末基本上没有出去过，都是待在房子里面看视频，做笔记。中间也一度迷茫过，感觉没自信，学得不好，不过还好，第一次做项目的时候我负责了大部分的工作，最后得到了班里唯一的一个最佳个人奖，感觉自信了好多。培训结束之后，也是包装了工作经验去找的，虽然没有真正的工作经验，但是基础理论知识还是比较扎实的，也是顺利入职。现在工作已经快半年了，虽然也一度也很艰难，但是我很庆幸自己选对了路，因为对这个感兴趣，而且收入几乎是之前的两倍。现在每天也都在努力地提高着自己。总之一句话，相信自己，脚踏实地，一定会有个好结果的！＾０＾~</p></blockquote><hr><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><blockquote><p>填志愿偶然选中软件专业。高考分不到二本线，也算是意料之中。考虑过了，没打算复习，没打算上三本，我希望减轻父亲的压力，早点读完大学出去工作，所以我选择了大专。在填报志愿时，随便选了一个大专，软件开发（两年制），这个专业也跟我喜欢玩游戏有关系，其他志愿随便填，填完志愿就上工地打工了。大学的我活成了废物。在大学，白天上课随便听，想睡就睡，作业随便抄；晚上在寝室，沉迷于游戏，疯狂熬夜。大学一年半，游戏占满了我的课余和课上时间；大学没有参加过一个课外活动，图书馆没去过。求职莫名进入培训的坑。我海投简历，各种职位；收到一个软件教育公司的面试，笔试没过；但他们说可以参加内部培训提高自己，免费一个月；我去了，后来才知道这种招聘叫‘招转培’。我参加的是前端培训，遇到了各样的学员。这期间，我接到过学校老师的电话，问我工作情况，她听了我的经历，说这是招转培，希望我能去达内培训，毕竟我们是校企合作，有优惠的补贴，我说考虑一下。培训20天左右，这边让我们签合同：全付或分期付，我决定离开。当时的我也不知道要做些什么，不知道能干什么工作，就这样又迷迷糊糊去参加了培训。两天后，我来到达内，开始了 5 个月的 Java 培训，很辛苦，但也收获满满。现在我工作了大概7个月了，很感谢经理能给我这个机会，他没有多问我的技术，我也实话实说，没有实际经验（培训的都包装），他说他是过来人，想拉我一把，我现在想想都很感动。</p></blockquote><hr><h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><blockquote><p>松哥好，我是来自苏州的一名菜鸟程序员，第一次留言，最近空闲时候在看你的文章，收益匪浅，我虽然毕业三年，但是今年初才转行做开发(去年开始自学 Java 和数据库这类开发知识，本来打算报班的，但是公司同意我转开发岗位)，一路磕磕碰碰，但是越战越勇，公司做 mes 业务的，Java 开发主要是移动端和看板系统，业务方面是罗克韦尔的 mes 开发平台。但是我依然坚持空闲时间写写 Java 练习，熟悉主流的框架(最近在写一个前后端分离的后台管理案例)，可以的话，希望松哥能抽到我，送我一本签名版springboot+vue全栈的书，最后衷心祝愿松哥和广大其他的程序员节日快乐！</p></blockquote><hr><h2 id="VB"><a href="#VB" class="headerlink" title="VB"></a>VB</h2><blockquote><p>要说为什么要入这行，其实也要从我高考填志愿说起，我跟松哥一样都是农村的，因此也对大学专业这些是真的一点都不懂，我当时是怎么选志愿的呢？我当时选的是跟汽车，电脑还有化学制药方面有关的。我当时觉得我们社会车挺多的，感觉跟车有关的专业可能以后比较好找工作，至于电脑我当时比较喜欢玩游戏，化学制药则是我家里人推荐的。录取通知下来后我是有点后悔的，为什么？因为学费贵，计算机专业几乎是我们学校最贵的几个二本专业了，其他大部分专业包括土木以及我们学校的王牌专业车辆都是 4500 一学年，而我的则是 7900，讲真我也搞不懂为什么就我们这个专业最贵，但后悔也没办法只能去了啊，大学四年我就没有松哥那么勤奋了，直到大三下半年我的专业知识依然只停留在那本 Java 教材里，甚至连 eclipse 都不会装，所幸在后面去了培训机构打基础，我很庆幸在里面学习到了很多的基础知识，也知道在这个行业要学习的路线，基础差不是最致命的，最致命的是不知道学习的方向，到现在我终于成为了 IT 行业的新人。</p></blockquote><hr><h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><blockquote><p>2013,14 年的时候，拥有了一台 Windows Phone 手机，系统是微软的 WP 系统，很喜欢，但是生态太差了，很多软件都没有，甚至想到，既然没有，那就自己做吧，找了 C# 的视频，后面去了培训，发现没有教 WP 软件开发的了 ，最终学了安卓开发，现在已经做了 3 年半的安卓仔</p></blockquote><hr><h2 id="MATLAB"><a href="#MATLAB" class="headerlink" title="MATLAB"></a>MATLAB</h2><blockquote><p>18 年毕业，现在边工作边学习。在校期间也稍微学习点 Java 基础。真正学习估计是工作吧，其实一直对这个行业充满了好奇，就是不知道怎么学习。从刚开始的看学习资料再到学习视频，每一个小白都是这么过来的吧。加油</p></blockquote><hr><h2 id="SAS"><a href="#SAS" class="headerlink" title="SAS"></a>SAS</h2><blockquote><p>听说程序员每天九点上班，而且大牛可以在家里上班。我就转行了，我喜欢睡懒觉。后来…发现我想多了。</p></blockquote><hr><h2 id="Scratch"><a href="#Scratch" class="headerlink" title="Scratch"></a>Scratch</h2><blockquote><p>当初选计算机专业，是可能是电影看多了，看到黑客、红客，各种耍帅，入了坑发现了很大的问题，黑客一定懂编程，但是懂编程不一定是黑客。</p></blockquote><hr><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><blockquote><p>软件工程专业，入行差不多两年吧！可惜工作一直不是开发，一直在锻炼开发技能，同样很迷茫，想考个事业单位，也想在企业打拼，也想独立出来创业，最近也在考虑结婚生子哈哈哈，最近才开始坚持写博客，准备软考，96年的我呀！加油！</p></blockquote><hr><p>很多小伙伴的故事让人动容，真是应了那句话，成年人的世界没有容易二字。那么哪位小伙伴的故事让你印象深刻呢？可以多选哦。</p><p>投票结果排名前五名的小伙伴可以从以下三个奖品中任选一个，投票时间截止到今晚(10月24) 23:59。</p><ul><li>签名版 《Spring Boot + Vue 全栈开发实战》 一本</li><li>松哥录制的 Spring Boot2 系列视频教程一套（1-15章）</li><li>京东上 80 元以内的图书任选一本</li></ul><p>没有谁是容易的，我每天也是早起晚睡。早上起来录视频，晚上写博客，剪视频。技术之路，松哥和各位小伙伴一起进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周，在 1024 来临之际，松哥向大家征集程序员的入行故事，收到了许多小伙伴的留言。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.javaboy.org/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.javaboy.org/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>晚十点半之前下班是耻辱？老板干嘛老爱和员工谈创业精神？</title>
    <link href="http://www.javaboy.org/2019/1021/996.html"/>
    <id>http://www.javaboy.org/2019/1021/996.html</id>
    <published>2019-10-21T01:49:52.000Z</published>
    <updated>2019-11-20T02:00:00.645Z</updated>
    
    <content type="html"><![CDATA[<p>这两天又有一个话题触动了广大程序员的神经，某互联网公司高管在内部邮件中公开指责员工晚上 10:30 后没有加班，没有创业精神，表示这是公司的耻辱日。</p><a id="more"></a><p><img src="http://www.javaboy.org/images/other/79-1.jpg" alt></p><p>刚看到这个消息我也是虎躯一震，经过今年年中 <code>996.ICU</code> 那次风波之后，很少有公司再去公开发表支持加班、支持 996 了，没想到这才没过多久，又有人往枪口上撞。</p><p>很多时候员工烦的不是加班，而是无偿加班，比无偿加班还可恶的就是再把人当傻子画个饼，制造一种这好像不是无偿加班的错觉。</p><p>这位孙姓高管说</p><ul><li>Day One 创业精神是我们印在骨子里的基因</li></ul><p>这话用在她自己身上可能没错，或者她对她的合伙人讲可能也没错，问题是这话是给员工讲的。你在招聘的时候写的是员工招聘还是合伙人招募呢？员工和合伙人的利益不同，要承担的责任当然就不同。不愿意分享利益却要共同承担风险，这不是耍流氓么。</p><p>有人会说，不想当将军的士兵不是好士兵，员工也应该把公司的事业当成自己的事业，努力奋斗就会有回报。</p><p>这话不假，松哥曾经就是一个想当将军的好士兵，松哥的老东家，节假日加班三倍工资，每逢节假日那些单身的同事都来公司加班，日常加班可以调休或者折算成工资，松哥离职时加的二十多天班全部折算成工资发了，其他的福利就不说了，反正公司不把员工当傻子，不会白嫖员工。在这样的公司里干活很有劲头，大部分员工都是想当将军的好士兵。</p><p>所以，做一个想当将军的好士兵也是有条件的，公司的环境决定了这个士兵是否有可能成为将军。老板如果压榨员工，总是想从员工身上薅羊毛，这样的环境下，当将军的希望很小，那也就没人想当将军了。</p><p>其实大部分程序员不缺创业精神与奋斗精神，要调动员工的积极性，就得公司给一点实在的东西，空手套白狼这种操作简直就是侮辱一个程序员的智商。</p><p>程序员谁不知道菊厂加班猛，谁不知道去阿里修福报，可是每年秋招很多人不还是挤破头皮想进去，为啥？付出和回报成比例啊！这种回报可能是物质上的，也可能是对未来职业生涯有益的一些虚拟的东西，反正你得让大家觉得我虽然辛苦工作，但是值。总不能让员工用爱发电，这不现实。</p><p>所以这位孙姓高管说员工不具备创业精神，问题可能不是出在员工身上，她应该问问自己为什么没能激发员工的创业精神和奋斗精神？</p><p>话说回来，为什么有些老板老爱和员工谈创业精神？</p><p><strong>因为不想花钱。</strong></p><p>老板不想花钱，就得和员工谈创业精神、谈奋斗，这些饼吃多了，员工一个个虚胖，又因为这些饼没营养，员工的头都秃了。这些东西还是太虚，作用有限。</p><p><img src="http://www.javaboy.org/images/other/79-2.png" alt></p><p>领导希望员工能跟自己一条心，共同奋斗，这能理解，如果我是领导，我当然希望员工跟我一条心，但是姿势要对，该给的东西要给足，不能光画大饼，你觉得呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天又有一个话题触动了广大程序员的神经，某互联网公司高管在内部邮件中公开指责员工晚上 10:30 后没有加班，没有创业精神，表示这是公司的耻辱日。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://www.javaboy.org/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="杂谈" scheme="http://www.javaboy.org/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>微人事 star 数超 10k，如何打造一个 star 数超 10k 的开源项目</title>
    <link href="http://www.javaboy.org/2019/1016/vhr.html"/>
    <id>http://www.javaboy.org/2019/1016/vhr.html</id>
    <published>2019-10-16T11:51:55.000Z</published>
    <updated>2019-10-16T12:12:25.438Z</updated>
    
    <content type="html"><![CDATA[<p>看了下，微人事(<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>)项目 star 数超 10k 啦，松哥第一个 star 数过万的开源项目就这样诞生了。</p><a id="more"></a><p><img src="http://www.javaboy.org/images/other/76-1.png" alt></p><p>两年前差不多就是现在这个时候，松哥所在的公司业绩下滑严重，关门倒闭已成定局，很多同事在谋划的新的出路，松哥则被公司留下来善后，在一段并不太忙碌的日子里，做了两个 Spring Boot + Vue 的前后端分离开源项目，以期能给自己来年找工作增加一点筹码，没想到这两个项目后来受到很多关注，也帮助了很多人。有不少小伙伴在公司使用微人事项目做脚手架开发项目，也有国内 top20 的高校研究生借鉴微人事做毕设，我自己也因此收到一些大厂的橄榄枝，可以说还是收获满满。</p><p>关于这个项目诞生的故事，松哥之前写过一篇文章，感兴趣的小伙伴可以看看：</p><ul><li><a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a></li></ul><p>今天，我想和小伙伴们聊聊如何从零开始打造一个 star 数过万的开源项目。松哥把这些经验总结为三点：</p><ul><li>文档详细</li><li>项目有料</li><li>适当宣传</li></ul><p>这些经验不是什么惊世骇俗的大道理，都很普通，关键在于执行。</p><h2 id="1-文档详细"><a href="#1-文档详细" class="headerlink" title="1. 文档详细"></a>1. 文档详细</h2><p>其实在做微人事和 V 部落之前，松哥在 GitHub 上已经做过多个开源项目了，比较有意思的一个是一个 Android 上的自定义控件，我做了一个歌词展示的控件，这个控件引入到自己的项目中以后，可以根据当前歌曲的播放进度动态滚动歌词，效果如如下：</p><p><img src="http://www.javaboy.org/images/other/76-4.gif" alt></p><p>还有一个比较好玩的就是 Android 上自动抢红包的 App。不过这些开源工具和项目最终都石沉大海了。</p><p>究其原因，我觉得是自己对待这些项目不够认真，项目开源之后基本上都没有再继续维护了，一个项目提交次数一般都是个位数，项目做完之后，写一篇博客介绍下就算完事了。一个自己都不怎么重视的项目，其实很难引起别人的重视。</p><p>所以在 V 部落和微人事中，我就吸取教训，尽量把项目的文档写的详细一些，让不懂前后端分离开发的小伙伴看到我写的开发文档后，就能够快速理清项目的思路。就这样，我每写一个功能点，就写一篇技术文档，微人事项目前前后后一共写了 30 多篇文档：</p><p><img src="http://www.javaboy.org/images/other/76-2.png" alt></p><p>同时我考虑到很多小伙伴第一次接触到这个项目，一个庞然大物不好处理，因此我在每一次项目提交之前，都会对项目打一个 tag，这样大家通过 <code>git clone</code> 命令获取到项目之后，就可以通过 tag 非常方便的定位到项目的任意时刻，例如只想看登录设计的，可以根据文档介绍回到 v20180107 这个版本：</p><p><img src="http://www.javaboy.org/images/other/76-3.png" alt></p><p>小伙伴也可以点击 GitHub 上的 release 下载不同时期的项目。我一开始担心有的小伙伴不熟悉 Git 上的 tag 操作，还针对此写了个教程，就是上面文档的第 17 篇。</p><p>可以说，这个项目我从头到尾考虑了很多小伙伴们可能遇到的问题，不是自嗨，确实是希望能够带着小伙伴们一起飞。</p><p>这么详细的文档当然也得到了小伙伴和一些平台的认可，项目刚刚发布的时候，也就是 2018 年年初的时候，慕课网在它的官方知乎账号、微博账号上都有推过我的介绍项目的文章，当时这个项目就受到了很多小伙伴的关注，收获了不少 star，小伙伴们的关注也鼓励我继续把这个项目向前推进。</p><p>这是我介绍的第一点经验，文档详细。</p><h2 id="2-项目有料"><a href="#2-项目有料" class="headerlink" title="2. 项目有料"></a>2. 项目有料</h2><p>项目有料，也就是这个项目对大家而言是有价值的，能够真正帮到大家。</p><p>很多小伙伴看到微人事会觉得奇怪，这个项目还有一些功能没有实现，怎么就有这么多人关注呢？其实原因很简单，这个项目的价值不在于它的业务，而在于它解决了很多小伙伴在前后端分离开发中遇到的问题，这也是我做这个项目的初衷之一。</p><p>作为一个 Java 攻城狮，我非常明白很多小伙伴去接触 Vue、接触 Nodejs、接触 SPA 以及接触前端工程化这些概念时所面临的困惑，因为这些困惑我也曾经遇到过。</p><p>例如前后端分离后，开发环境下前后端如何进行数据交互、权限管理怎么做、文件上传怎么做、项目怎么部署等等，事无巨细，我觉得小伙伴们可能会困惑的地方，我在微人事中直接用代码做出样例，然后再辅以详细的文字解释，这样对于大部分小伙伴而言，都能够快速理解这个项目了。</p><p>这个项目建立之初，一开始就定位是一个学习项目，目的就是帮助大家建立前后端分离开发知识体系，搞定前后端分离开发中常见的坑，<strong>因此，一旦将项目的框架搭建成功，大家理解了前后端分离架构中的各个细节，剩下的业务不过是堆代码，技术上已经没有挑战了，这也是这个项目最近一段时间更新慢的原因。</strong></p><p>这是我和大家分享的第二点经验，项目要有价值。</p><h2 id="3-适当宣传"><a href="#3-适当宣传" class="headerlink" title="3. 适当宣传"></a>3. 适当宣传</h2><p>微人事和 V 部落刚刚上线的时候，我的相关文章被慕课网猛推过几次，当时就让微人事受到了比较多的关注，印象中，大概不到一个月的时间，star 数就超过 1k 了。</p><p>由于文档比较详细，很多大佬在整理相关资料的时候都会加上微人事项目，很多小伙伴可能见过标题类似下面这样的文章：</p><ul><li>13个优秀的 Spring Boot 学习项目</li><li>开源的13个Spring Boot 优秀学习项目！</li><li>六月份 GitHub 上最受欢迎的开源项目</li><li>七月份 GitHub 上最受欢迎的开源项目</li></ul><p>….</p><p>这一类的文章大部分都会收录微人事项目，进而将微人事项目曝光给更多小伙伴去学习。</p><p>今年七月份，有感于 1 年前公司倒闭时的无助，松哥写了一篇文章介绍了微人事项目的诞生过程：</p><ul><li><a href="https://mp.weixin.qq.com/s/qGFo2MKkD0AObBJDPR8veQ" target="_blank" rel="noopener">公司倒闭 1 年了，而我当年的项目上了 GitHub 热榜</a></li></ul><p>没想到这篇文章被很多大佬转发，单单在知乎上这篇文章的阅读量就超过 12w，那一段时间，微人事项目也被很多有需要的小伙伴关注到了。</p><p>宣传这一块，我的经验是如果项目确实帮助到了很多小伙伴，对很多人而言有价值，你会发现平台，一些有影响力的技术牛人会自然的帮你推。<strong>所以，我还是建议将重心放在项目上。所谓家有梧桐树，引得凤凰来。</strong></p><p>这是我介绍的第三点经验，适当宣传。</p><p>好了，一点点不太成熟的经验分享给小伙伴们，希望能帮到大家。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了下，微人事(&lt;a href=&quot;https://github.com/lenve/vhr&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lenve/vhr&lt;/a&gt;)项目 star 数超 10k 啦，松哥第一个 star 数过万的开源项目就这样诞生了。&lt;/p&gt;
    
    </summary>
    
      <category term="vhr" scheme="http://www.javaboy.org/categories/vhr/"/>
    
    
      <category term="微人事" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E4%BA%BA%E4%BA%8B/"/>
    
      <category term="vhr" scheme="http://www.javaboy.org/tags/vhr/"/>
    
  </entry>
  
  <entry>
    <title>原创的离线版 Redis 教程，给力！</title>
    <link href="http://www.javaboy.org/2019/1016/redis-guide.html"/>
    <id>http://www.javaboy.org/2019/1016/redis-guide.html</id>
    <published>2019-10-16T11:47:12.000Z</published>
    <updated>2019-10-16T12:04:41.959Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，你没看错，松哥又给大家送干货来了。这次是可以离线阅读的 PDF 版教程哦。</p><a id="more"></a><p>之前一直有小伙伴问我有没有 Redis 的电子书，老实说，有是有，但是公开给大家分享，其实有一点点风险，毕竟这都是有版权的东西，特别是松哥自己写书之后，深知作者的不易。</p><blockquote><p>一般情况下，出版社给作者的稿酬是 8%，一本售价 ￥70 的书，到作者手里就是 ￥5.6。</p></blockquote><p>不过松哥今天要分享的资源，不牵涉任何版权问题，因为是我一个字一个字码出来的，我要和大家堂堂正正的分享这个资源。</p><p>这个就是松哥自己码出来的 4w 余字的 Redis 教程。其实这个教程发布有一段时间了，只是一直没有电子版的，有不少小伙伴希望我能把这些教程整理成电子版的，包括以前写的 MongoDB、Git、Spring Cloud 以及今年一直在持续更新的 Spring Boot，大家有需求，松哥当然就要行动，于是前两天费了一番功夫，把 md 转成 word ，然后整理了下做成了 pdf，这样大家以后在没有网络的环境下也可以学习了。</p><p>先来看看目录吧：</p><p><img src="http://www.javaboy.org/images/other/73-1.png" alt><br><img src="http://www.javaboy.org/images/other/73-2.png" alt><br><img src="http://www.javaboy.org/images/other/73-3.png" alt><br><img src="http://www.javaboy.org/images/other/73-4.png" alt><br><img src="http://www.javaboy.org/images/other/73-5.png" alt></p><p>这个教程从 Redis 的安装开始，到基本数据类型操作、数据持久化、主从复制、集群搭建直到最后的用 Java 操作 Redis ，可以说覆盖到了 Redis 常见的各种用法，当然还有更多的实际项目中 Redis 的用法，大家可以留意公众号的内容，这些我还会继续更新。</p><p>好了，资源我已经上传到百度云盘了，大家在公众号后台回复 <code>redis</code> 就可以获取到下载链接。如果这个资料帮助到你了，也欢迎分享给更多的小伙伴哦。</p><p>未来，我还会整理更多的电子版出来，包括 Spring Boot 系列。请小伙伴们留意公众号消息哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯，你没看错，松哥又给大家送干货来了。这次是可以离线阅读的 PDF 版教程哦。&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="http://www.javaboy.org/categories/redis/"/>
    
    
      <category term="redis" scheme="http://www.javaboy.org/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>前后端分离开发中动态菜单的两种实现方案</title>
    <link href="http://www.javaboy.org/2019/1016/vue-router.html"/>
    <id>http://www.javaboy.org/2019/1016/vue-router.html</id>
    <published>2019-10-16T11:44:46.000Z</published>
    <updated>2019-10-16T12:05:54.798Z</updated>
    
    <content type="html"><![CDATA[<p>关于前后端分离开发中的权限处理问题，松哥之前写过一篇文章和大家聊这个问题：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/5GsOO4QK9AnR0K6FdZixOw" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离开发，权限管理的一点思路</a></li></ul><p>但是最近有小伙伴在学习微人事项目时，对动态菜单这一块还是有疑问（即不同用户登录成功后会看到不同的菜单项），因此松哥打算再来写一篇文章和大家聊一聊前后端分离开发中的动态菜单问题。</p><h2 id="1-一个原则"><a href="#1-一个原则" class="headerlink" title="1. 一个原则"></a>1. 一个原则</h2><p>做权限管理，一个核心思想就是后端做权限控制，前端做的所有工作都只是为了提高用户体验，我们不能依靠前端展示或者隐藏一个按钮来实现权限控制，这样肯定是不安全的。</p><p>就像用户注册时需要输入邮箱地址，前端校验之后，后端还是要校验，两个校验目的不同，前端校验是为了提高响应速度，优化用户体验，后端校验则是为了确保数据完整性。权限管理也是如此，前端按钮的<code>展示/隐藏</code>都只是为了提高用户体验，真正的权限管理需要后端来实现。</p><p>这是非常重要的一点，做前后端分离开发中的权限管理，我们首先要建立上面这样的思考框架，然后在这样的框架下，去考虑其他问题。</p><p>因此，下文我会和大家分享两种方式实现动态菜单，这两种方式仅仅只是探讨如何更好的给用户展示菜单，而不是探讨权限管理，因为权限管理是在后端完成的，也必须在后端完成。</p><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h2><p>一旦建立起这样的思考框架，你会发现动态菜单的实现办法太多了。</p><p>动态菜单就是用户登录之后看到的菜单，不用角色的用户登录成功之后，会看到不用的菜单项，这个动态菜单要怎么实现呢？整体来说，有两种不同的方案，松哥曾经做过的项目中，两种方案也都有用过，这里分别来和大家分享一下。</p><h3 id="2-1-后端动态返回"><a href="#2-1-后端动态返回" class="headerlink" title="2.1 后端动态返回"></a>2.1 后端动态返回</h3><p>后端动态返回，这是我在微人事中采用的方案。微人事中，权限管理相关的表一共有五张表，如下：</p><p><img src="http://www.javaboy.org/images/fe/9-1.png" alt></p><p>其中 <code>hr</code> 表就是用户表，用户登录成功之后，可以查询到用户的角色，再根据用户角色去查询出来用户可以操作的菜单（资源），然后把这些可以操作的资源，组织成一个 JSON 数据，返回给前端，前端再根据这个 JSON 渲染出相应的菜单。以微人事为例，我们返回的 JSON 数据格式如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"path"</span>:<span class="hljs-string">"/home"</span>,</span><br><span class="line">        <span class="hljs-attr">"component"</span>:<span class="hljs-string">"Home"</span>,</span><br><span class="line">        <span class="hljs-attr">"name"</span>:<span class="hljs-string">"员工资料"</span>,</span><br><span class="line">        <span class="hljs-attr">"iconCls"</span>:<span class="hljs-string">"fa fa-user-circle-o"</span>,</span><br><span class="line">        <span class="hljs-attr">"children"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-attr">"id"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">                <span class="hljs-attr">"path"</span>:<span class="hljs-string">"/emp/basic"</span>,</span><br><span class="line">                <span class="hljs-attr">"component"</span>:<span class="hljs-string">"EmpBasic"</span>,</span><br><span class="line">                <span class="hljs-attr">"name"</span>:<span class="hljs-string">"基本资料"</span>,</span><br><span class="line">                <span class="hljs-attr">"iconCls"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">                <span class="hljs-attr">"children"</span>:[</span><br><span class="line"></span><br><span class="line">                ],</span><br><span class="line">                <span class="hljs-attr">"meta"</span>:&#123;</span><br><span class="line">                    <span class="hljs-attr">"keepAlive"</span>:<span class="hljs-literal">false</span>,</span><br><span class="line">                    <span class="hljs-attr">"requireAuth"</span>:<span class="hljs-literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="hljs-attr">"meta"</span>:&#123;</span><br><span class="line">            <span class="hljs-attr">"keepAlive"</span>:<span class="hljs-literal">false</span>,</span><br><span class="line">            <span class="hljs-attr">"requireAuth"</span>:<span class="hljs-literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样的 JSON 在前端中再进行二次处理之后，就可以使用了，前端的二次处理主要是把 component 属性的字符串值转为对象。这一块具体操作大家可以参考微人事项目（具体在：<code>https://github.com/lenve/vhr/blob/master/vuehr/src/utils/utils.js</code>），我就不再赘述了。</p><p>这种方式的一个好处是前端的判断逻辑少一些，后端也不算复杂，就是一个 SQL 操作，前端拿到后端的返回的菜单数据，稍微处理一下就可以直接使用了。另外这种方式还有一个优势就是可以动态配置<strong>资源-角色</strong>以及<strong>用户-角色</strong>之间的关系，进而调整用户可以操作的资源(菜单)。</p><h3 id="2-2-前端动态渲染"><a href="#2-2-前端动态渲染" class="headerlink" title="2.2 前端动态渲染"></a>2.2 前端动态渲染</h3><p>另一种方式就是前端动态渲染，这种方式后端的工作要轻松一些，前端处理起来麻烦一些，松哥去年年末帮一个律所做的一个管理系统，因为权限上比较容易，我就采用了这种方案。</p><p>这种方式就是我直接在前端把所有页面都在路由表里边定义好，然后在 meta 属性中定义每一个页面需要哪些角色才能访问，例如下面这样：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-attr">"id"</span>:<span class="hljs-number">2</span>,</span><br><span class="line">        <span class="hljs-attr">"path"</span>:<span class="hljs-string">"/home"</span>,</span><br><span class="line">        <span class="hljs-attr">"component"</span>:Home,</span><br><span class="line">        <span class="hljs-attr">"name"</span>:<span class="hljs-string">"员工资料"</span>,</span><br><span class="line">        <span class="hljs-attr">"iconCls"</span>:<span class="hljs-string">"fa fa-user-circle-o"</span>,</span><br><span class="line">        <span class="hljs-attr">"children"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="hljs-attr">"id"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">                <span class="hljs-attr">"path"</span>:<span class="hljs-string">"/emp/basic"</span>,</span><br><span class="line">                <span class="hljs-attr">"component"</span>:EmpBasic,</span><br><span class="line">                <span class="hljs-attr">"name"</span>:<span class="hljs-string">"基本资料"</span>,</span><br><span class="line">                <span class="hljs-attr">"iconCls"</span>:<span class="hljs-literal">null</span>,</span><br><span class="line">                <span class="hljs-attr">"children"</span>:[</span><br><span class="line"></span><br><span class="line">                ],</span><br><span class="line">                <span class="hljs-attr">"meta"</span>:&#123;</span><br><span class="line">                    <span class="hljs-attr">"keepAlive"</span>:<span class="hljs-literal">false</span>,</span><br><span class="line">                    <span class="hljs-attr">"requireAuth"</span>:<span class="hljs-literal">true</span>,</span><br><span class="line">                    <span class="hljs-attr">"roles"</span>:['admin','user']</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="hljs-attr">"meta"</span>:&#123;</span><br><span class="line">            <span class="hljs-attr">"keepAlive"</span>:<span class="hljs-literal">false</span>,</span><br><span class="line">            <span class="hljs-attr">"requireAuth"</span>:<span class="hljs-literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样定义表示当前登录用户需要具备 admin 或者 user 角色，才可以访问 EmpBasic 组件，当然这里不是说我这样定义了就行，这个定义只是一个标记，在项目首页中，我会遍历这个数组做菜单动态渲染，然后根据当前登录用户的角色，再结合当前组件需要的角色，来决定是否把当前组件所对应的菜单项渲染出来。</p><p>这样的话，后端只需要在登录成功后返回当前用户的角色就可以了，剩下的事情则交给前端来做。不过这种方式有一个弊端就是菜单和角色的关系在前端代码中写死了，以后如果想要动态调整会有一些不方便，可能需要改代码。特别是大项目，权限比较复杂的时候，调整就更麻烦了，所以这种方式我一般建议在一些简单的项目中使用。</p><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h2><p>虽然我在微人事中使用了第一种方式，不过如果小伙伴是一个新项目，并且权限问题不是很复杂的话，我还是建议尝试一下第二种方式，感觉要方便一些。</p><p>不过在公司中，动态菜单到底在前端做还是后端做，可能会有一个前后端团队沟（si）通（bi）的过程，赢了的一方就可以少写几行代码了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于前后端分离开发中的权限处理问题，松哥之前写过一篇文章和大家聊这个问题：&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://www.javaboy.org/categories/vue/"/>
    
    
      <category term="router" scheme="http://www.javaboy.org/tags/router/"/>
    
      <category term="vue" scheme="http://www.javaboy.org/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>使用 Nginx 部署前后端分离项目，解决跨域问题</title>
    <link href="http://www.javaboy.org/2019/1016/nginx.html"/>
    <id>http://www.javaboy.org/2019/1016/nginx.html</id>
    <published>2019-10-16T11:44:24.000Z</published>
    <updated>2019-10-16T11:59:40.387Z</updated>
    
    <content type="html"><![CDATA[<p>前后端分离这个问题其实松哥和大家聊过很多了，上周松哥把自己的两个开源项目部署在服务器上以帮助大家可以快速在线预览（<a href="https://mp.weixin.qq.com/s/GvqLzCZngQiMqVE_ZTafeA" target="_blank" rel="noopener">喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了</a>），然后群里就有小伙伴想让松哥来聊聊如何结合 Nginx 来部署前后端分离项目？今天我们就来聊一聊这个话题。</p><a id="more"></a><h2 id="不得不说的跨域"><a href="#不得不说的跨域" class="headerlink" title="不得不说的跨域"></a>不得不说的跨域</h2><p>很多人对前后端分离部署感到困惑，其实主要是困惑跨域问题怎么解决。因为前后端分离项目在开发的时候，前端通过 nodejs 来运行，需要一个单独的端口，后端通过 Tomcat 或者 Jetty 来运行，也需要端口，两个不同的端口，就造成了跨域。</p><p>但是松哥之前多次和大家聊过这个问题，这种跨域并不是我们传统开发中真正的跨域，这个所谓的跨域只在开发环境中存在，生产环境下就不存在这个跨域问题了。所以我们不能按照以往的通过 JSONP 或者 CORS 之类的手段来解决这个跨域问题。</p><p>前后端分离开发中，前端为了能够模拟出测试数据，并且模拟出请求，一般需要借助于 nodejs 来运行，这是开发时候的状态，开发时候的配置大家可以参考这篇文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/szgfT3tnYMCHSeiE3_QnpA" target="_blank" rel="noopener">前后端分离历险记</a></li></ul><p>等开发完成后，我们会对前端项目编译打包，编译打包完成之后，就只剩下一堆 js、css 以及 html 文件了，我们把这些编译打包后的文件拷贝到后端项目中，这样再去运行就不存在跨域问题了（例如将编译打包后的静态文件拷贝到 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下）。这种方式我就不再多说了，相信大家都会，今天咱们主要来看看如何结合 Nginx 来部署。</p><h2 id="Nginx-大杀器"><a href="#Nginx-大杀器" class="headerlink" title="Nginx 大杀器"></a>Nginx 大杀器</h2><p>结合 Nginx 来部署前后端分离项目算是目前的主流方案。一来部署方便，二来通过动静分离也可以有效提高项目的运行效率。</p><p>大家知道我们项目中的资源包含动态资源和静态资源两种，其中：</p><ul><li>动态资源就是那些需要经过容器处理的资源，例如 jsp、freemarker、各种接口等。</li><li>静态资源则是那些不需要经过容器处理，收到客户端请求就可以直接返回的资源，像 js、css、html 以及各种格式的图片，都属于静态资源。</li></ul><p>将动静资源分开部署，可以有效提高静态资源的加载速度以及整个系统的运行效率。</p><p>在前后端分离项目部署中，我们用 Nginx 来做一个反向代理服务器，它既可以代理动态请求，也可以直接提供静态资源访问。我们来一起看下。建议大家先阅读松哥以前关于 Nginx 的一篇旧文，可以有效帮助大家理解后面的配置：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></li></ul><h3 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h3><p>后端接口的部署，主要看项目的形式，如果就是普通的 SSM 项目，那就提前准备好 Tomcat ，在 Tomcat 中部署项目，如果是 Spring Boot 项目，可以通过命令直接启动 jar，如果是微服务项目，存在多个 jar 的话，可以结合 Docker 来部署（参考<a href="https://mp.weixin.qq.com/s/vSCQLvQBYMYoPhdlO2v3XA" target="_blank" rel="noopener">一键部署 Spring Boot 到远程 Docker 容器</a>），无论是那种形式，对于我们 Java 工程师来说，这都不是问题，我相信这一步大家都能搞定。</p><p>后端项目可以在一个非 80 端口上部署，部署成功之后，因为这个后端项目只是提供接口，所以我们并不会直接去访问他。而是通过 Nginx 请求转发来访问这个后端接口。</p><p>松哥这里以我去年为一个律所的小程序为例，后端是一个 Spring Boot 工程，那么我可以通过 Docker 部署，也可以直接通过命令来启动，这里简单点，直接通过命令来启动 jar ，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar jinlu.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><p>后端启动成功之后，我并不急着直接去访问后端，而是安装并且去配置一个 Nginx，通过 Nginx 来转发请求，Nginx 的基本介绍与安装，大家可以参考（<a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a>），我这里就直接来说相关的配置了。</p><p>这里我们在 nginx.conf 中做出如下配置：</p><p>首先配置上游服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">upstream zqq.com&#123;</span><br><span class="line">  server 127.0.0.1:9999 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里主要是配置服务端的地址，如果服务端是集群化部署，那么这里就会有多个服务端地址，然后可以通过权重或者 ip hash 等方式进行请求分发。</p><p>然后我们在 server 中配置转发规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /jinlu/ &#123;</span><br><span class="line">  proxy_pass http://zqq.com;</span><br><span class="line">  tcp_nodelay     on;</span><br><span class="line">  proxy_set_header Host            $host;</span><br><span class="line">  proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置完成后，假设我目前的域名是 javaboy.org，那么用户通过 <code>http://www.javaboy.org/jinlu/**</code> 格式的地址就可以访问到我服务端的接口。</p><h3 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h3><p>以 Vue 为例，如果是 SPA 应用，项目打包之后，就是一个 index.html 还有几个 js、css、images 以及 fonts ，这些都是静态文件，我们将静态文件首先上传到服务器，然后在 nginx.conf 中配置静态资源访问，具体配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|) &#123;</span><br><span class="line">   root /usr/local/nginx/html/;#所有静态文件直接读取硬盘</span><br><span class="line">   expires 30d; #缓存30天</span><br><span class="line">&#125; ​​​​</span><br></pre></td></tr></table></figure><p>当然我这里是按照资源类型来拦截的，即后缀为 js、css、ico 等的文件，统统都不进行请求分发，直接从本地的 /usr/local/nginx/html/ 目录下读取并返回到前端（我们需要将静态资源文件上传到 <code>/usr/local/nginx/html/</code> 目录下）。</p><p>如果我们的服务器上部署了多个项目，这种写法就不太合适，因为多个项目的前端静态文件肯定要分门别类，各自放好的，这个时候我们一样可以通过路径来拦截，配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /jinlu-admin/ &#123;</span><br><span class="line">   root /usr/local/nginx/html/jinlu-admin/;#所有静态文件直接读取硬盘</span><br><span class="line">   expires 30d; #缓存30天</span><br><span class="line">&#125; ​​​​</span><br></pre></td></tr></table></figure><p>这样，请求路径是 /jinlu-admin/ 格式的请求，则不会进行请求分发，而是直接从本机的 <code>/usr/local/nginx/html/jinlu-admin/</code> 目录下返回相关资源。采用这方方式配置静态资源，我们就可以部署多个项目了，多个项目的部署方式和上面的一样。</p><p>这样部署完成之后，假设我的域名是 javaboy.org ，那么用户通过 <code>http://www.javaboy.org/jinlu-admin/**</code><br>格式的请求就可以访问到前端资源了。</p><p>此时大家发现，前端的静态资源和后端的接口现在处于同一个域之中了，这样就不存在跨域问题，所以我一开始基说<strong>不</strong>必用 JSONP 或者 CORS 去解决跨域。特殊情况可能需要在 nginx 中配置跨域，这个松哥以后再和大家细聊~​</p><p>好了，不知道小伙伴有没有看懂呢？有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前后端分离这个问题其实松哥和大家聊过很多了，上周松哥把自己的两个开源项目部署在服务器上以帮助大家可以快速在线预览（&lt;a href=&quot;https://mp.weixin.qq.com/s/GvqLzCZngQiMqVE_ZTafeA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了&lt;/a&gt;），然后群里就有小伙伴想让松哥来聊聊如何结合 Nginx 来部署前后端分离项目？今天我们就来聊一聊这个话题。&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://www.javaboy.org/categories/nginx/"/>
    
    
      <category term="前后端分离" scheme="http://www.javaboy.org/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
      <category term="nginx" scheme="http://www.javaboy.org/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 前后端分离登录，非法请求直接返回 JSON</title>
    <link href="http://www.javaboy.org/2019/1015/springsecurity.html"/>
    <id>http://www.javaboy.org/2019/1015/springsecurity.html</id>
    <published>2019-10-15T11:51:00.000Z</published>
    <updated>2019-10-16T12:06:33.614Z</updated>
    
    <content type="html"><![CDATA[<p>hello 各位小伙伴，国庆节终于过完啦，松哥也回来啦，今天开始咱们继续发干货！</p><p>关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用：</p><a id="more"></a><ol><li><a href="https://mp.weixin.qq.com/s/HKJOlatXDS8awBNyCe9JMg" target="_blank" rel="noopener">手把手带你入门 Spring Security！</a></li><li><a href="https://mp.weixin.qq.com/s/oDow2miLIst-R4NNzc_i4g" target="_blank" rel="noopener">Spring Security 登录添加验证码</a></li><li><a href="https://mp.weixin.qq.com/s/X1t-VCxzxIcQKOAu-pJrdw" target="_blank" rel="noopener">SpringSecurity 登录使用 JSON 格式数据</a></li><li><a href="https://mp.weixin.qq.com/s/7D0qJiEIzNuz8VAVvZsXCA" target="_blank" rel="noopener">Spring Security 中的角色继承问题</a></li><li><a href="https://mp.weixin.qq.com/s/riyFQSrkQBQBCyomE__fLA" target="_blank" rel="noopener">Spring Security 中使用 JWT!</a></li><li><a href="https://mp.weixin.qq.com/s/1rVPzJGCtDZKvMoA4BYzIA" target="_blank" rel="noopener">Spring Security 结合 OAuth2</a></li></ol><p>不过，今天要和小伙伴们聊一聊 Spring Security 中的另外一个问题，那就是在 Spring Security 中未获认证的请求默认会重定向到登录页，但是在前后端分离的登录中，这个默认行为则显得非常不合适，今天我们主要来看看如何实现未获认证的请求直接返回 JSON ，而不是重定向到登录页面。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>这里关于 Spring Security 的基本用法我就不再赘述了，如果小伙伴们不了解，可以参考上面的 6 篇文章。</p><p>大家知道，在自定义 Spring Security 配置的时候，有这样几个属性：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login"</span>)</span><br><span class="line">            <span class="hljs-comment">//其他配置</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个比较重要的属性：</p><ul><li>loginProcessingUrl：这个表示配置处理登录请求的接口地址，例如你是表单登录，那么 form 表单中 action 的值就是这里填的值。</li><li>loginPage：这个表示登录页的地址，例如当你访问一个需要登录后才能访问的资源时，系统就会自动给你通过重定向跳转到这个页面上来。</li></ul><p>这种配置在前后端不分的登录中是没有问题的，在前后端分离的登录中，这种配置就有问题了。我举个简单的例子，例如我想访问 <code>/hello</code> 接口，但是这个接口需要登录之后才能访问，我现在没有登录就直接去访问这个接口了，那么系统会给我返回 302，让我去登录页面，在前后端分离中，我的后端一般是没有登录页面的，就是一个提示 JSON，例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> RespBean <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> RespBean.error(<span class="hljs-string">"尚未登录，请登录!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整代码大家可以参考我的微人事项目。</p></blockquote><p>也就是说，当我没有登录直接去访问 <code>/hello</code> 这个接口的时候，我会看到上面这段 JSON 字符串。在前后端分离开发中，这个看起来没问题（后端不再做页面跳转，无论发生什么都是返回 JSON）。但是问题就出在这里，系统默认的跳转是一个重定向，就是说当你访问 <code>/hello</code> 的时候，服务端会给浏览器返回 302，同时响应头中有一个 Location 字段，它的值为 <code>http://localhost:8081/login</code> ，也就是告诉浏览器你去访问 <code>http://localhost:8081/login</code> 地址吧。浏览器收到指令之后，就会直接去访问 <code>http://localhost:8081/login</code> 地址，如果此时是开发环境并且请求还是 Ajax 请求，就会发生跨域。因为前后端分离开发中，前端我们一般在 NodeJS 上启动，然后前端的所有请求通过 NodeJS 做请求转发，现在服务端直接把请求地址告诉浏览器了，浏览器就会直接去访问 <code>http://localhost:8081/login</code> 了，而不会做请求转发了，因此就发生了跨域问题。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>很明显，上面的问题我们不能用跨域的思路来解决，虽然这种方式看起来也能解决问题，但不是最佳方案。</p><p>如果我们的 Spring Security 在用户未获认证的时候去请求一个需要认证后才能请求的数据，此时不给用户重定向，而是直接就返回一个 JSON，告诉用户这个请求需要认证之后才能发起，就不会有上面的事情了。</p><p>这里就涉及到 Spring Security 中的一个接口 <code>AuthenticationEntryPoint</code> ，该接口有一个实现类：<code>LoginUrlAuthenticationEntryPoint</code> ，该类中有一个方法 <code>commence</code>，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Performs the redirect (or forward) to the login form URL.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">AuthenticationException authException)</span> </span>&#123;</span><br><span class="line">String redirectUrl = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">if</span> (useForward) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (forceHttps &amp;&amp; <span class="hljs-string">"http"</span>.equals(request.getScheme())) &#123;</span><br><span class="line">redirectUrl = buildHttpsRedirectUrlForRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (redirectUrl == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">String loginForm = determineUrlToUseForThisRequest(request, response,</span><br><span class="line">authException);</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"Server side forward to: "</span> + loginForm);</span><br><span class="line">&#125;</span><br><span class="line">RequestDispatcher dispatcher = request.getRequestDispatcher(loginForm);</span><br><span class="line">dispatcher.forward(request, response);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line">redirectUrl = buildRedirectUrlToLoginPage(request, response, authException);</span><br><span class="line">&#125;</span><br><span class="line">redirectStrategy.sendRedirect(request, response, redirectUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们从这个方法的注释中就可以看出，这个方法是用来决定到底是要重定向还是要 forward，通过 Debug 追踪，我们发现默认情况下 useForward 的值为 false，所以请求走进了重定向。</p><p>那么我们解决问题的思路很简单，直接重写这个方法，在方法中返回 JSON 即可，不再做重定向操作，具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .loginProcessingUrl(<span class="hljs-string">"/doLogin"</span>)</span><br><span class="line">            .loginPage(<span class="hljs-string">"/login"</span>)</span><br><span class="line">            <span class="hljs-comment">//其他配置</span></span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable().exceptionHandling()</span><br><span class="line">                .authenticationEntryPoint(<span class="hljs-keyword">new</span> AuthenticationEntryPoint() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commence</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException authException)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                resp.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                PrintWriter out = resp.getWriter();</span><br><span class="line">                RespBean respBean = RespBean.error(<span class="hljs-string">"访问失败!"</span>);</span><br><span class="line">                <span class="hljs-keyword">if</span> (authException <span class="hljs-keyword">instanceof</span> InsufficientAuthenticationException) &#123;</span><br><span class="line">                    respBean.setMsg(<span class="hljs-string">"请求失败，请联系管理员!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(respBean));</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring Security 的配置中加上自定义的 <code>AuthenticationEntryPoint</code> 处理方法，该方法中直接返回相应的 JSON 提示即可。这样，如果用户再去直接访问一个需要认证之后才可以访问的请求，就不会发生重定向操作了，服务端会直接给浏览器一个 JSON 提示，浏览器收到 JSON 之后，该干嘛干嘛。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>好了，一个小小的重定向问题和小伙伴们分享下，不知道大家有没有看懂呢？这也是我最近在重构微人事的时候遇到的问题。预计 11 月份，微人事的 Spring Boot 版本会升级到目前最新版，请小伙伴们留意哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 各位小伙伴，国庆节终于过完啦，松哥也回来啦，今天开始咱们继续发干货！&lt;/p&gt;
&lt;p&gt;关于 Spring Security，松哥之前发过多篇文章和大家聊聊这个安全框架的使用：&lt;/p&gt;
    
    </summary>
    
      <category term="SpringSecurity" scheme="http://www.javaboy.org/categories/SpringSecurity/"/>
    
    
      <category term="SpringSecurity" scheme="http://www.javaboy.org/tags/SpringSecurity/"/>
    
      <category term="前后端分离" scheme="http://www.javaboy.org/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>微人事项目视频教程已经开始更新，国庆节有事情做啦！</title>
    <link href="http://www.javaboy.org/2019/1014/vhr-video.html"/>
    <id>http://www.javaboy.org/2019/1014/vhr-video.html</id>
    <published>2019-10-14T11:48:56.000Z</published>
    <updated>2019-10-16T12:02:27.485Z</updated>
    
    <content type="html"><![CDATA[<p>在正式介绍松哥最近在连载的微人事视频之前，我想要和大家先聊聊前后端分离到底难在哪里？</p><a id="more"></a><p><strong>老实说，前后端分离不难</strong>。</p><p>相反，前后端分离之后，对于后端工程师而言，事情反而变简单了。</p><p>在前后端不分的年代，很少有纯粹的后端工程师，一个 Java 工程师，多多少少得会一点 js、会一点 jQuery 吧？我相信大部分做过开发的小伙伴都有这样的经验。然而，当前后端分离之后，后端工程师的工作大大的减轻了，后端的工作也更加纯粹了，如果没有其他抱负，大概可以安安静静做一个接口仔了。</p><p>但是我相信，在程序员这个群体中，应该没有人愿意做一个安安静静的接口仔。想要提高自己的技能，全栈就是一个方向。然而前后端分离时代的全栈工程师，门槛可比从前的前后端不分时代的全栈工程师高多了。</p><p>为什么这么说呢？</p><p>前端经过这几年的发展，早已经变得非常强大，前端工程化、webpack、单页面应用/SPA，各种概念层出不穷。这种情况下，我们后端工程师想要去前端领域分一杯羹，进而提升自己的竞争力，着实得花点功夫。其实我一直觉得，目前前端的这些东西，对一个专业的前端工程师而言，其实应该都不算难，我们后端的 Spring Boot 这些，对一个专业的 Java 工程师也不算难，但是如果让一个人既写前端又写后端，多多少少有点难度，这些难度松哥从一个 Java 工程师的角度总结了，主要集中在以下几个方面：</p><ol><li>前后端分离开发，开发环境下前后端的通信到底是怎么进行的？因为前端在 nodejs 上启动，有自己的端口，后端在 Tomcat 或者 Jetty 上启动，也有自己的端口，这种看似跨域的问题要怎么解决？</li><li>权限管理要怎么做？以前大家做权限管理就是各种请求拦截，如果请求权限不足，则转发到某一个页面去，前后端分离之后，无论什么情况，后端都是只返回 JSON，那么此时权限管理要怎么做？</li><li>前端的单页面应用（SPA）到底是怎么回事？有哪些优势？</li><li>前端组件化又是什么鬼？</li><li>webpack 到底是什么？</li><li>前后端分离项目的部署</li></ol><p>这里的很多问题其实并不难，只是你缺乏一个令人恍然大悟的解释。且听松哥一一道来。</p><p>作为一个专业的后端工程师，当我们去学习很多前端概念的时候，如果能够把这些概念和我们 Java 中的某一个概念或者工具对应起来，你就会有一种恍然大悟的感觉，原来是这么回事！其实开发本语言和工具本来就是相似的，大部分语言不就是互相借鉴产生的么（例如 C#  和 Java），因此这些开发中的概念、工具等也都具有高度的相似性，如果能把前端的概念和 Java 中的一些概念对应起来理解，那就太棒啦！</p><p>然而我们在网上看到的大部分教程，前端就是专业的前端，后端就是专业的后端，很少有把这两个联合起来讲，不免有点遗憾。</p><p>松哥在 2018 年年初做微人事项目，就是考虑到这种前后端分离的案例太少了，我想打通前后端的任督二脉，很多小伙伴也亟需一个前后端分离的案例来练手，因此才有了后来的 V 部落和微人事项目。其中微人事项目我还写了一个非常详细的开发文档，当时心想着小伙伴们对照的开发文档应该就能搞出来微人事。</p><p><img src="http://www.javaboy.org/images/other/74-2.png" alt></p><p>但是事实证明，还是有点乐观了。有不少小伙伴通过微人事项目添加了我的微信，问了很多问题，其实大部分问题都不难，但是要给大家解释清楚又非三言两语能说清，因此，我才决定在 Spring Boot 系列完结之后，继续录制这一套微人事项目的手把手教程，到目前为止已经录制了接近 50 集了，以下是部分视频：</p><p><img src="http://www.javaboy.org/images/other/74-1.png" alt></p><p>在这套视频中，松哥从零开始，带领大家做一个和我的开源项目微人事一模一样的项目。我会从一个 Java 工程师的角度来和大家聊一聊全栈开发（Spring Boot + Vue）中的弯弯绕绕，很多前端的概念我会对照着 Java 中的一些工具来跟大家解释，这样可以帮助大家更好更快的理解并掌握前端的概念。我觉得这是非常难得的，你可以在网上找到专业的后端教程，也可以找到专业的前端教程，但是前后端结合的，老实说，并不多。</p><p>看过我博客的小伙伴都知道，松哥的博客力求简单易懂，让大家都看得明白，做得出效果，视频也是延续了这样的风格。无论是已经连载完毕的 Spring Boot 还是目前正在连载的微人事，都受到小伙伴的好评：</p><p><img src="http://www.javaboy.org/images/other/74-6.jpg" alt><br><img src="http://www.javaboy.org/images/other/74-3.jpg" alt><br><img src="http://www.javaboy.org/images/other/74-4.jpg" alt><br><img src="http://www.javaboy.org/images/other/74-5.jpg" alt></p><p>还有很多小伙伴把松哥视频教程推荐给他们身边的同事朋友，我想这足以说明松哥视频的质量了吧。（要是很坑的话，估计也没人推荐吧）</p><p><img src="http://www.javaboy.org/images/other/74-7.jpg" alt><br><img src="http://www.javaboy.org/images/other/74-8.jpg" alt></p><p>真的挺感动，这都是满满的信任。</p><p>当然视频的录制，还是和以前一样辛苦，早上六点起来录视频，录到八点半去上班，晚上回到家里，对视频进行二次处理，去噪，重新渲染，只是为了给小伙伴们一个更加清晰的视频教程：</p><p><img src="http://www.javaboy.org/images/other/74-9.png" alt></p><p>当然这些付出也决定了这是一套付费教程。</p><p>我自己还在网上搜集了很多别人录制的视频，这些视频对我来说没有多大成本，都是网络上找的，因此我都免费送给大家了，在我公众号底部菜单里有免费视频，这些免费视频大家都可以领取，我不会拿这些随处可见的视频来卖钱。</p><p>欢迎大家加入星球，一起学习进步！趁着国庆节弯道超车。现在直接扫码加入星球需要 199，这里我提供另外一个优惠的方式，大家可以加我微信，发红包只要 119，然后我手动拉你进星球。星球上每有一个课程完结的时候，就会提升一次价格，早点加入就是优势。<strong>同时为了保证加入星球的小伙伴的权益，我可以向大家保证，你在其他地方不会看到一模一样的免费的整套视频教程，因为这些视频都是我自己录制的，全部都是加密之后发布的，所以请大家放心。</strong></p><p><img src="http://www.javaboy.org/images/other/74-10.jpeg" alt></p><p>感谢大家信任。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在正式介绍松哥最近在连载的微人事视频之前，我想要和大家先聊聊前后端分离到底难在哪里？&lt;/p&gt;
    
    </summary>
    
      <category term="微人事" scheme="http://www.javaboy.org/categories/%E5%BE%AE%E4%BA%BA%E4%BA%8B/"/>
    
    
      <category term="微人事" scheme="http://www.javaboy.org/tags/%E5%BE%AE%E4%BA%BA%E4%BA%8B/"/>
    
      <category term="vhr" scheme="http://www.javaboy.org/tags/vhr/"/>
    
  </entry>
  
  <entry>
    <title>每次回西安，都会动摇我继续留在深圳的决心</title>
    <link href="http://www.javaboy.org/2019/1006/go-home.html"/>
    <id>http://www.javaboy.org/2019/1006/go-home.html</id>
    <published>2019-10-06T11:49:54.000Z</published>
    <updated>2019-10-16T12:03:42.749Z</updated>
    
    <content type="html"><![CDATA[<p>hello 小伙伴们国庆节快乐吖。</p><a id="more"></a><p>松哥国庆节回老家了，这两天一直忙哥没停。和女票在一起八年了，结婚的事情该慢慢准备了，国庆节趁机带女票家人来西安走走看看，好多近在眼前但是以前从来没有去过的景点如城墙、大唐不夜城等，这次都去走了走。不过老实说，西安的文化，单纯从一些典型的景点中其实不太容易体会到，西安的文化和历史沉淀在这个城市的每一个细节中，随便走两步，看见一个地名，这就是一个故事，这些以后松哥在再和大家细细聊。</p><p>回家呆这几天，真是感慨颇多，甚至又一次动摇了我继续留在深圳的决心。回家真是太舒服了，老家亲戚多朋友多，很多事情都可以热热闹闹的去做，村子里的晚上超级安静，只有远处村子的狗吠，没有了大城市的嘈杂，每天晚上都能安安稳稳的睡好久。这次回家，西安的房子也收拾好了可以住人了，小区旁边每逢 2/4/6 有集，今天去看了下，蘑菇十块钱一筐五块钱半框、提子一块五一斤十块八斤…等等，这价格真的太感人了，我心里思量着要是回西安生活，日子一定美滋滋（其实我也明白，要是真的回来了，日子也不见得就一定美滋滋。</p><p>在深圳就不一样了，完全是另外一种状态，周一到周五白天上班，晚上写公众号，周末录视频教程+写公众号，很少有自己的生活，甚至可以说只有工作没有生活。在深圳租的房子，我一般习惯称之为<strong>宿舍</strong>，我不太喜欢称之为<strong>家</strong>，因为我觉得那就是一个晚上睡觉的地方，而家，不仅仅指房子，也是心的寄托，将租的房子称之为家，我有点不太习惯，没有家，所以总有一种漂着的感觉。</p><p>每次过完年离家其实也是这样，刚走的时候，挺想家，感觉呆在西安真不错，时间久了，这种感觉就慢慢变淡了，开始谋划如何在广深两地立足，直到过年回到家，又开始思想上新一轮的轮回。</p><p>既然这样，那干嘛还要留在深圳或者广州呢？</p><p>对于一个农村出来的孩子，我有太多的不甘心，留在深圳，代表着奋斗，希望就有可能实现。而回老家，在我看来有一点点认命的感觉，就是不打算继续奋斗了，和一帮好朋友去吃吃喝喝了，生活乐悠悠，事业上能糊口就行了。</p><p>大学毕业后，我就羡慕两种人，一种人就是留在学校所在地工作的，可以随时见到老师同学，可以随时回学校看看，还有一种就是回老家工作的，虽然不知道他们真实的生活状态，不过我自己想象着应该是很美好的生活吧…</p><p>每次想到以后要不要回西安，就会很纠结，我想知道小伙伴们都在哪里工作呢？是老家还是一线城市？为什么作出这样的选择？欢迎大家来留言说说.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hello 小伙伴们国庆节快乐吖。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="http://www.javaboy.org/categories/life/"/>
    
    
      <category term="life" scheme="http://www.javaboy.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>给数据库减负的八个思路</title>
    <link href="http://www.javaboy.org/2019/0921/mysql.html"/>
    <id>http://www.javaboy.org/2019/0921/mysql.html</id>
    <published>2019-09-21T06:47:18.000Z</published>
    <updated>2019-09-21T06:48:59.572Z</updated>
    
    <content type="html"><![CDATA[<p>传统的企业级应用，其实很少会有海量应用，因为企业的规模本身就摆在那里，能有多少数据？高并发？海量数据？不存在的！</p><p>不过在互联网公司中，因为应用大多是面向广大人民群众，数据量动辄上千万上亿，那么这些海量数据要怎么存储？光靠数据库吗？肯定不是。</p><a id="more"></a><p>今天松哥和大家简单的聊一聊这个话题。</p><p>海量数据，光用数据库肯定是没法搞定的，即使不读松哥这篇文章，相信大家也能凝聚这样的共识，海量数据，不是说一种方案、两种方案就能搞定，它是一揽子方案。那么这一揽子方案都包含哪些东西呢？松哥从以下八个方面来和大家聊聊。</p><h1 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h1><p>首先第一种解决方案就是缓存了。</p><p>缓存，我们可以将数据直接缓存在内从中，例如 Map、也可以使用缓存框架如 Redis 等，将一些需要频繁使用的热点数据保存在缓存中，每当用户来访问的时候，就可以直接将缓存中的数据返回给用户，这样可以有效降低服务器的压力。</p><p>可以缓存起来使用的数据，一般都不能对实时性要求太高。</p><h1 id="2-页面静态化"><a href="#2-页面静态化" class="headerlink" title="2.页面静态化"></a>2.页面静态化</h1><p>页面静态化其实可以算作是缓存的另外一种形式，相当于直接将相关的页面渲染结果缓存起来。首先大家知道，在我们的 Web 项目中，资源分为两大类：</p><ul><li>静态资源</li><li>动态资源</li></ul><p>静态资源就是我们常见的 HTML、CSS、JavaScript、图片等资源，这些资源可以不经过服务端处理，就可以直接返回给前端浏览器，浏览器就可以直接显示出来。</p><p>动态资源则是指我们项目中的 Servlet 接口、Jsp 文件、Freemarker 等，这些需要经过服务端渲染之后，才可以返回前端的资源。</p><p>在实际项目中，静态资源的访问速度要远远高于动态资源，动态资源往往很容易遇到服务器瓶颈、数据库瓶颈，因此，对于一些不经常更新的页面，或者说更新比较缓慢的页面，我们可以通过页面静态化，将一个动态资源保存为静态资源，这样当服务端需要访问的时候，直接将静态资源返回，就可以避免去操作数据库了，降低数据库的压力。</p><p>例如松哥以前做过的一个电商项目，系统根据大数据统计，自动统计出用户当前搜索的热点商品，这些热点商品，10 分钟更新一次，也就是说，在十分钟内，用户登录上来看到的热点商品都是相同的。那么就没有必要每次都去查询数据库，而是将热点数据的页面，通过输出流自动写到服务器上，写成一个普通的 HTML 文件，下次用户来访问，在 10 分钟有效期内，直接将 HTML 页面返回给用户，就不必操作数据库了。</p><p>一般来说，Freemarker、Velocity 等都有相关的方法可以帮助我们快速将动态页面生成静态页面。</p><p>这就是页面静态化。</p><h1 id="3-数据库优化"><a href="#3-数据库优化" class="headerlink" title="3.数据库优化"></a>3.数据库优化</h1><p>很多时候程序跑得慢，不是因为设备落后，而是因为数据库 SQL 写的太差劲。</p><p>要解决海量数据的问题，数据库优化肯定也是不可避免的。一般来说，我们可以从 SQL 优化、表结构优化、以及数据库分区分表等多个方面来对数据库进行优化。数据库优化其实也是一门巨大的学问，松哥以后看有时间写个连载和大家仔细聊聊这个话题。</p><h1 id="4-热点数据分离"><a href="#4-热点数据分离" class="headerlink" title="4.热点数据分离"></a>4.热点数据分离</h1><p>数据库中的数据，虽然是海量数据，但是这些数据并不见得所有数据都是活跃数据，例如用户注册，有的用户注册完就消失的无影无踪了，而有的用户则在不停的登录，因此，对于这两种不同的用户，我们可以将活跃用户分离出来，在主要操作的数据表中只保存活跃用户数据。每次用户登录，先去主表中查看有没有记录，有的话，直接登录，没有的话，再去查看其他表。</p><p>通过判断用户在某一段时间内的登录次数，就可以很快分离出热点数据。</p><h1 id="5-合并数据库操作"><a href="#5-合并数据库操作" class="headerlink" title="5.合并数据库操作"></a>5.合并数据库操作</h1><p>这个方案的宗旨其实是减少数据库操作的次数，例如多次插入操作，我们可以合并成一条 SQL 搞定。多个不同条件的查询，如果条件允许的话，也可以合并成为一个查询，尽量减少数据库的操作，减少在网络上消耗，同时也降低数据库的压力。</p><h1 id="6-数据库读写分离"><a href="#6-数据库读写分离" class="headerlink" title="6.数据库读写分离"></a>6.数据库读写分离</h1><p>数据库的读写分离其实松哥在之前的 MyCat 中也和大伙聊过了（<a href="https://mp.weixin.qq.com/s/oNsTcrWCjntQefD2B0sq1A" target="_blank" rel="noopener">MyCat 系列</a>），读写分离之后，一方面可以提高数据库的操作效率，另一方面也算是对数据库的一个备份。这一块的具体操作大家可以参考松哥前面的文章。</p><h1 id="7-分布式数据库"><a href="#7-分布式数据库" class="headerlink" title="7.分布式数据库"></a>7.分布式数据库</h1><p>数据库读写分离之后，无形中增大了代码的复杂度，所以一般还需要借助分布式数据库中间件，这样可以有效提高数据库的弹性，可以方便的随时为数据库扩容，同时也降低代码的耦合度。</p><h1 id="8-NoSQL-和-Hadoop"><a href="#8-NoSQL-和-Hadoop" class="headerlink" title="8.NoSQL 和 Hadoop"></a>8.NoSQL 和 Hadoop</h1><p>另外，引入 NoSQL 和 Hadoop 也是解决方案之一。NoSQL 突破了关系型数据库中对表结构、字段等定义的条条框框，使用户可以非常灵活方便的操作，另外 NoSQL 通过多个存储块存储数据的特点，使得天然具备操作大数据的优势（快）。不过，老实说，NoSQL 目前还是在互联网项目中比较常见，在传统的企业级应用中还是比较少见。</p><p>Hadoop 就不必说了，大数据处理利器。</p><p>很多时候技术和架构只是一个工具，所有的东西都摆在你面前，关键是如何把这些东西组合在一起，使之产生最大化收益，这就需要大家慢慢琢磨，松哥后面也尽量和大家多分享一些这方面的经验。</p><p>好了，简单的从 8 个方面和大家聊一聊这个问题，大家在工作中有没有遇到类似问题呢？你都是怎么处理的？欢迎留言讨论。</p><p>参考资料：</p><p>[1] 韩路彪.看透Spring MVC：源代码分析与实践[M].北京：机械工业出版社，2015.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传统的企业级应用，其实很少会有海量应用，因为企业的规模本身就摆在那里，能有多少数据？高并发？海量数据？不存在的！&lt;/p&gt;
&lt;p&gt;不过在互联网公司中，因为应用大多是面向广大人民群众，数据量动辄上千万上亿，那么这些海量数据要怎么存储？光靠数据库吗？肯定不是。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.javaboy.org/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>喜大普奔，两个开源的 Spring Boot + Vue 前后端分离项目可以在线体验了</title>
    <link href="http://www.javaboy.org/2019/0920/springboot-vue-online.html"/>
    <id>http://www.javaboy.org/2019/0920/springboot-vue-online.html</id>
    <published>2019-09-20T05:07:20.000Z</published>
    <updated>2019-09-21T06:05:01.688Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了一周的域名备案昨天终于搞定了。</p><p>松哥第一时间想到赶紧把<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>部署上去，我知道很多小伙伴已经等不及了。</p><a id="more"></a><h2 id="1-也曾经上过线"><a href="#1-也曾经上过线" class="headerlink" title="1. 也曾经上过线"></a>1. 也曾经上过线</h2><p>其实这两个项目当时刚做好的时候，我就把它们部署到服务器上了，以帮助小伙伴们更好的查看效果。但是那个是一台国外服务器，之所以购买国外服务器，主要是嫌国内备案麻烦，当然也有其他大家都懂的原因。</p><p>国外服务器有方便的地方，同时也有很多不便，例如网络不稳，随时有失联的风险。所以我在 2018 年年初，虽然把这两个项目都部署在服务器上，但是很多小伙伴的访问体验都不好，主要还是网络的问题。后来一段时间，经过几轮围剿与反围剿，这台服务器就彻底和松哥失联了。</p><p>失联之后，因为工作比较忙，我也就懒得去折腾了，所以导致<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>大家在很长一段时间内无法在线查看效果。</p><h2 id="2-重新上线"><a href="#2-重新上线" class="headerlink" title="2. 重新上线"></a>2. 重新上线</h2><p>最近因为有一些其他的计划，于是购买了阿里云服务，完事之后就是备案，所有东西都搞定之后，想着先把<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>部署起来，方便大家查看效果。</p><p>说干就干，我首先规划了两个二级域名：</p><ul><li><a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a></li><li><a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a></li></ul><p>这两个二级域名分别用来部署 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>和<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>。</p><p>大家可以通过这两个地址查看效果：</p><p><strong><a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a></strong></p><p><img src="http://www.javaboy.org/images/fronted-backend/70-1.png" alt></p><p><strong><a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a></strong></p><p><img src="http://www.javaboy.org/images/fronted-backend/70-2.png" alt></p><p>为了确保每位小伙伴都能看到完整的演示效果，防止有的小伙伴不慎把所有数据清空了，导致其他小伙伴啥都看不到，我只开通了演示账户的查询和部分字段的更新权限，因此大家在查看演示效果时，可能会有一些涉及到增删改的操作会执行失败，请勿见怪，将项目部署到本地运行之后，就可以查看完整效果了。</p><h2 id="3-技能树"><a href="#3-技能树" class="headerlink" title="3. 技能树"></a>3. 技能树</h2><p>既然都写到这儿了，就和大家聊一聊这两个部署是怎么实现的。</p><h3 id="3-1-部署方案选择"><a href="#3-1-部署方案选择" class="headerlink" title="3.1 部署方案选择"></a>3.1 部署方案选择</h3><p>大家知道前后端分离部署的时候，我们有两种不同的方案：</p><ul><li>一种就是将前端项目打包编译之后，放到后端项目中（例如 Spring Boot 项目的 <code>src/main/resources/static</code> 目录下）</li><li>另外一种则是将前端打包之后的静态资源用 Nginx 来部署，后端单独部署只需要单纯的提供接口即可。</li></ul><p>一般在公司项目中，我们更多的是采用后者。不过松哥这里部署为了省事，我采用了第一种方案。（以后抽空我会和大家聊聊第二种部署方案）</p><h3 id="3-2-域名映射"><a href="#3-2-域名映射" class="headerlink" title="3.2 域名映射"></a>3.2 域名映射</h3><p>域名映射这块简单，登录阿里云后台，添加两个 A 记录即可。</p><p><img src="http://www.javaboy.org/images/fronted-backend/70-3.png" alt></p><h3 id="3-3-启动-Spring-Boot"><a href="#3-3-启动-Spring-Boot" class="headerlink" title="3.3 启动 Spring Boot"></a>3.3 启动 Spring Boot</h3><p>将<a href="https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw" target="_blank" rel="noopener">微人事</a>和 <a href="https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw" target="_blank" rel="noopener">V 部落</a>分别打包上传到服务器，这个过程应该就不用我多说了吧，然后分别启动这两个项目，两个项目的默认端口分别是 8081 和 8082，命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar vblog.jar &gt; vblog.log &amp;</span><br><span class="line">nohup java -jar vhr.jar &gt; vhr.log &amp;</span><br></pre></td></tr></table></figure><p>将两个项目的运行日志分别写入到 vblog.log 和 vhr.log 文件中。</p><p>启动成功之后，我们就可以通过 <code>itboyhub.com:8081</code> 和 <code>itboyhub.com:8082</code> 两个端口来分别访问这两个项目了。但是这还没达到松哥的目标，我想通过二级域名来访问，并且想通过 80 端口来访问，这就要借助 Nginx 了。</p><p><strong>注意</strong></p><p>启动完成后，大家需要登录阿里云后台，确认 8081 和 8082 端口已经开启。</p><h3 id="3-4-Nginx-配置"><a href="#3-4-Nginx-配置" class="headerlink" title="3.4 Nginx 配置"></a>3.4 Nginx 配置</h3><p>Nginx 的基本用法，大家可以参考松哥的这篇旧文：</p><ul><li><a href="https://mp.weixin.qq.com/s/ZN07_3ImmyRU0NQaqzcazQ" target="_blank" rel="noopener">Nginx 极简入门教程！</a></li></ul><p>这里我们主要来看看 Nginx 的配置。</p><p>由于有两个二级域名，而且未来服务器还要配置其他域名，因此域名要能够做到动态解析，因此在具体配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  *.itboyhub.com;</span><br><span class="line"></span><br><span class="line">    if ($http_host ~* &quot;^(.*?)\.itboyhub\.com$&quot;) &#123;</span><br><span class="line">            set $domain $1;</span><br><span class="line">    &#125;</span><br><span class="line">    # 其他配置...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先监听的端口为 80</li><li>二级域名则用一个通配符 <code>*</code> 代替</li><li>接下来在 if 语句用，通过正则表达式提取出二级域名的名字，交给变量 $domain，以备后用。</li></ul><p>接下来配置转发规则：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  if ($domain ~* &quot;vhr&quot;) &#123;</span><br><span class="line">    proxy_pass http://itboyhub.com:8082;</span><br><span class="line">  &#125;</span><br><span class="line">  if ($domain ~* &quot;vblog&quot;) &#123;</span><br><span class="line">    proxy_pass http://itboyhub.com:8081;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  tcp_nodelay     on;</span><br><span class="line">  proxy_set_header Host            $host;</span><br><span class="line">  proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当定义的 $domain 中包含 vhr 字符时，将请求转发到 <a href="http://itboyhub.com:8082" target="_blank" rel="noopener">http://itboyhub.com:8082</a></li><li>当定义的 $domain 中包含 vblog 字符时，将请求转发到 <a href="http://itboyhub.com:8081" target="_blank" rel="noopener">http://itboyhub.com:8081</a></li><li>最后再配置将代理服务器收到的用户的信息传到 real server 上</li></ul><p>另一方面，由于默认的后端首页是 <code>/index.html</code>，如果用户直接访问 <a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a> 或者 <a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a>，会被权限管理机制拦截（会自动重定向到 <code>/login_p</code>），因此，如果用户访问地址中没有 <code>/index.html</code> ，则自动添加上 <code>/index.html</code>，配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /login_p &#123;</span><br><span class="line">   if ($domain ~* &quot;vhr&quot;) &#123;</span><br><span class="line">     rewrite ^/(.*)$ http://vhr.itboyhub.com/index.html permanent;</span><br><span class="line">   &#125;</span><br><span class="line">   if ($domain ~* &quot;vblog&quot;) &#123;</span><br><span class="line">     rewrite ^/(.*)$ http://vblog.itboyhub.com/index.html permanent;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这行配置在 <code>location /</code> 之前进行配置，这里两个 if 的含义和前面的一样，不再赘述。</p><p>OK，如此之后我们的配置就算是完成了（上面 nginx 完整的配置文件小伙伴可以在公众号后台回复 nginx.conf 获取​）。</p><p>接下来我们就可以通过如下两个二级域名访问这两个开源项目了，小伙伴们赶紧试一把吧。</p><ul><li><a href="http://vblog.itboyhub.com" target="_blank" rel="noopener">vblog.itboyhub.com</a></li><li><a href="http://vhr.itboyhub.com" target="_blank" rel="noopener">vhr.itboyhub.com</a></li></ul><h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>最后，再向小伙伴们安利一把这两个开源项目：</p><ul><li><a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a></li><li><a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener">https://github.com/lenve/VBlog</a></li></ul><p>如果你要学习 Spring Boot + Vue 前后端分离项目，这两个是不可多得的好资料。 其中 V 部落无论是从技术点还是业务上来说，都要简单一些，所以如果你是新手，可以先看看 V 部落。微人事虽然稍微复杂一点，但好在松哥配有完整的开发文档，照着开发文档，相信大家也能理解大部分的功能。文档如下：</p><p><img src="http://www.javaboy.org/images/fronted-backend/70-4.png" alt></p><p>如果大家在部署的过程中遇到问题，也可以参考松哥手把手的部署视频：</p><ul><li><a href="https://mp.weixin.qq.com/s/qN01Le434FWom0c3jqiQmA" target="_blank" rel="noopener">微人事项目部署视频教程</a></li></ul><p>好了，本文说到这里，小伙伴们有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了一周的域名备案昨天终于搞定了。&lt;/p&gt;
&lt;p&gt;松哥第一时间想到赶紧把&lt;a href=&quot;https://mp.weixin.qq.com/s/6_D0srW4inv2ZbukN4ivBw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微人事&lt;/a&gt;和 &lt;a href=&quot;https://mp.weixin.qq.com/s/VRzcunh9flTJ_EZSBJrfYw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;V 部落&lt;/a&gt;部署上去，我知道很多小伙伴已经等不及了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="http://www.javaboy.org/tags/Spring-Boot/"/>
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Java 操作 MongoDB</title>
    <link href="http://www.javaboy.org/2019/0919/mongodb-in-java.html"/>
    <id>http://www.javaboy.org/2019/0919/mongodb-in-java.html</id>
    <published>2019-09-19T02:17:28.000Z</published>
    <updated>2019-09-21T09:06:51.900Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们介绍的 MongoDB 的操作都是在 shell 命令中写的，在项目开发时我们当然都是用程序去操作 MongoDB 的，本文我们来看看如何用 Java 代码操作 MongoDB。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先我们需要驱动，MongoDB 的 Java 驱动我们可以直接在 Maven 中央仓库去下载，也可以创建 Maven 工程添加如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mongodb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mongodb-driver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>建议通过 Maven 来添加依赖，如果自己下载 jar，需要下载如下三个 jar：</p><blockquote><ol><li>org.mongodb:bson:jar:3.5.0</li><li>org.mongodb:mongodb-driver-core:jar:3.5.0</li><li>org.mongodb:mongodb-driver:jar:3.5.0</li></ol></blockquote><p>另外，在使用 Java 操作 MongoDB 之前，记得启动 MongoDB 哦~</p><h2 id="获取集合"><a href="#获取集合" class="headerlink" title="获取集合"></a>获取集合</h2><p>所有准备工作完成之后，我们首先需要一个 MongoClient，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoClient client = <span class="hljs-keyword">new</span> MongoClient(<span class="hljs-string">"192.168.248.136"</span>, <span class="hljs-number">27017</span>);</span><br></pre></td></tr></table></figure><p>然后通过如下方式获取一个数据库，如果要获取的数据库本身就存在，直接获取到，不存在 MongoDB 会自动创建：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoDatabase sang = client.getDatabase(<span class="hljs-string">"sang"</span>);</span><br></pre></td></tr></table></figure><p>然后通过如下方式获取一个名为c1的集合，这个集合存在的话就直接获取到，不存在的话 MongoDB 会自动创建出来，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MongoCollection&lt;Document&gt; c = sang.getCollection(<span class="hljs-string">"c1"</span>);</span><br></pre></td></tr></table></figure><p>有了集合之后，我们就可以向集合中插入数据了。</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>和在 shell 中的操作一样，我们可以一条一条的添加数据，也可以批量添加，添加单条数据操作如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Document d1 = <span class="hljs-keyword">new</span> Document();</span><br><span class="line">d1.append(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义"</span>).append(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>);</span><br><span class="line">c.insertOne(d1);</span><br></pre></td></tr></table></figure><p>添加多条数据的操作如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Document&gt; collections = <span class="hljs-keyword">new</span> ArrayList&lt;Document&gt;();</span><br><span class="line">Document d1 = <span class="hljs-keyword">new</span> Document();</span><br><span class="line">d1.append(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义"</span>).append(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>);</span><br><span class="line">collections.add(d1);</span><br><span class="line">Document d2 = <span class="hljs-keyword">new</span> Document();</span><br><span class="line">d2.append(<span class="hljs-string">"name"</span>, <span class="hljs-string">"红楼梦"</span>).append(<span class="hljs-string">"author"</span>, <span class="hljs-string">"曹雪芹"</span>);</span><br><span class="line">collections.add(d2);</span><br><span class="line">c.insertMany(collections);</span><br></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>可以修改查到的第一条数据，操作如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.updateOne(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>), <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"$set"</span>, <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义123"</span>)));</span><br></pre></td></tr></table></figure><p>上例中小伙伴们也看到了修改器要如何使用，不管是 $set 还是 $inc，用法都一致，我这里不再一个一个演示。也可以修改查到的所有数据，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.updateMany(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>), <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"$set"</span>, <span class="hljs-keyword">new</span> Document(<span class="hljs-string">"name"</span>, <span class="hljs-string">"三国演义456"</span>)));</span><br></pre></td></tr></table></figure><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>可以删除查到的一条数据，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.deleteOne(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>));</span><br></pre></td></tr></table></figure><p>也可以删除查到的所有数据：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.deleteMany(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>));</span><br></pre></td></tr></table></figure><p>Filters 里边还有其他的查询条件，都是见名知意，不赘述。</p><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>可以直接查询所有文档：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FindIterable&lt;Document&gt; documents = c.find();</span><br><span class="line">MongoCursor&lt;Document&gt; iterator = documents.iterator();</span><br><span class="line"><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以按照条件查询：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FindIterable&lt;Document&gt; documents = c.find(Filters.eq(<span class="hljs-string">"author"</span>, <span class="hljs-string">"罗贯中"</span>));</span><br><span class="line">MongoCursor&lt;Document&gt; iterator = documents.iterator();</span><br><span class="line"><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的方法基本都是见名知意，这里不再赘述。</p><h2 id="验证问题"><a href="#验证问题" class="headerlink" title="验证问题"></a>验证问题</h2><p>上面我们演示的获取一个集合是不需要登录 MongoDB 数据库的，如果需要登录，我们获取集合的方式改为下面这种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServerAddress serverAddress = <span class="hljs-keyword">new</span> ServerAddress(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">27017</span>);</span><br><span class="line">List&lt;MongoCredential&gt; credentialsList = <span class="hljs-keyword">new</span> ArrayList&lt;MongoCredential&gt;();</span><br><span class="line">MongoCredential mc = MongoCredential.createScramSha1Credential(<span class="hljs-string">"readuser"</span>,<span class="hljs-string">"sang"</span>,<span class="hljs-string">"123"</span>.toCharArray());</span><br><span class="line">credentialsList.add(mc);</span><br><span class="line">MongoClient client = <span class="hljs-keyword">new</span> MongoClient(serverAddress,credentialsList);</span><br><span class="line">MongoDatabase sang = client.getDatabase(<span class="hljs-string">"sang"</span>);</span><br><span class="line">c = sang.getCollection(<span class="hljs-string">"c1"</span>);</span><br></pre></td></tr></table></figure><p>MongoCredential 是一个凭证，第一个参数为用户名，第二个参数是要在哪个数据库中验证，第三个参数是密码的 char 数组，然后将登录地址封装成一个 ServerAddress，最后将两个参数都传入 MongoClient 中实现登录功能。</p><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p>在连接数据库的时候也可以设置连接超时等信息，在MongoClientOptions中设置即可，设置方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerAddress serverAddress = <span class="hljs-keyword">new</span> ServerAddress(<span class="hljs-string">"192.168.248.128"</span>, <span class="hljs-number">27017</span>);</span><br><span class="line">List&lt;MongoCredential&gt; credentialsList = <span class="hljs-keyword">new</span> ArrayList&lt;MongoCredential&gt;();</span><br><span class="line">MongoCredential mc = MongoCredential.createScramSha1Credential(<span class="hljs-string">"rwuser"</span>,<span class="hljs-string">"sang"</span>,<span class="hljs-string">"123"</span>.toCharArray());</span><br><span class="line">credentialsList.add(mc);</span><br><span class="line">MongoClientOptions options = MongoClientOptions.builder()</span><br><span class="line">        <span class="hljs-comment">//设置连接超时时间为10s</span></span><br><span class="line">        .connectTimeout(<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>)</span><br><span class="line">        <span class="hljs-comment">//设置最长等待时间为10s</span></span><br><span class="line">        .maxWaitTime(<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>)</span><br><span class="line">        .build();</span><br><span class="line">MongoClient client = <span class="hljs-keyword">new</span> MongoClient(serverAddress,credentialsList,options);</span><br><span class="line">MongoDatabase sang = client.getDatabase(<span class="hljs-string">"sang"</span>);</span><br><span class="line">c = sang.getCollection(<span class="hljs-string">"c1"</span>);</span><br></pre></td></tr></table></figure><p>好了，Java 操作 MongoDB 我们就先说到这里，小伙伴们有问题欢迎留言讨论。</p><p>参考资料：</p><ol><li>《MongoDB权威指南第2版》 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们介绍的 MongoDB 的操作都是在 shell 命令中写的，在项目开发时我们当然都是用程序去操作 MongoDB 的，本文我们来看看如何用 Java 代码操作 MongoDB。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>初识 MongoDB 分片</title>
    <link href="http://www.javaboy.org/2019/0918/mongodb-shard.html"/>
    <id>http://www.javaboy.org/2019/0918/mongodb-shard.html</id>
    <published>2019-09-18T02:17:28.000Z</published>
    <updated>2019-09-21T09:07:06.693Z</updated>
    
    <content type="html"><![CDATA[<p>分片是指将数据拆分，拆分后存放在不同的机器上的过程，以此来降低单个服务器的压力，同时也解决单个服务器硬盘空间不足的问题，让我们可以用廉价的机器实现高性能的数据架构。</p><a id="more"></a><p>有的小伙伴不理解分片和副本集的差异，一言以蔽之：副本集上每个备份节点存储的数据都是相同的，分片上存储的数据则是不同的。好了，本文我们就先来看看分片环境的搭建。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>准备三台已经装好了 MongoDB 的服务器，地址分别是：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128</span><br><span class="line">192.168.248.135</span><br><span class="line">192.168.248.136</span><br></pre></td></tr></table></figure><p>本文使用的 MongoDB 版本为 3.4.9</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>首先我们需要三台配置服务器，配置服务器相当于集群的大脑，配置服务器中保存着集群和分片的元数据，即每个分片都包含了哪些数据信息，这些数据都是保存在配置服务器中的，我这里将开启三个配置服务器实例，这三个配置服务器将运行在三个 MongoDB 服务器上，地址分别如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128:20000</span><br><span class="line">192.168.248.135:20000</span><br><span class="line">192.168.248.136:20000</span><br></pre></td></tr></table></figure><p>接下来需要一个 Mongos 实例，Mongos 对请求进行路由，Mongos 扮演的角色有点类似于一个门面，我们以后访问的时候，直接访问 Mongos 即可，再由 Mongos 将请求路由到不同的分片上去，Mongos 在启动时会去访问配置服务器，它将从配置服务器中获取数据的存储信息，Mongos 我将启动在如下服务器上：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128:30000</span><br></pre></td></tr></table></figure><p>最后需要三个分片实例，三个分片依然运行在三台服务器上，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.248.128:27017</span><br><span class="line">192.168.248.135:27017</span><br><span class="line">192.168.248.136:27017</span><br></pre></td></tr></table></figure><h2 id="搭建配置服务器"><a href="#搭建配置服务器" class="headerlink" title="搭建配置服务器"></a>搭建配置服务器</h2><p>配置服务器中不需要太多的空间和资源，因为配置服务器上保存的只是数据的分布表，不保存具体的数据，具体的数据都保存在分片上，配置服务器中 1KB 的空间约为 200MB 的真实数据。<strong>注意，从 MongoDB3.4 开始，配置服务器要做成集群的方式。</strong></p><p>由于配置服务器是独立的 mongod 进程，所以我们可以像启动普通的 MongoDB 服务一样启动配置服务器，只是这里的配置不同罢了。</p><p>我这里以 <code>192.168.248.128</code> 服务器为例来讲述配置服务器的配置启动，另外两台服务器如法炮制即可：</p><ol><li>在 mongodb 解压目录下创建 db20000 文件夹，用来存储配置服务器中的数据。</li><li>复制一份 mongodb.conf，命名为 mongodb20000.conf，修改文件内容如下：</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/opt/mongodb/db20000</span><br><span class="line">logpath=/opt/mongodb/logs/mongodb20000.log</span><br><span class="line">port=20000</span><br><span class="line">fork=true</span><br><span class="line">configsvr=true</span><br><span class="line">replSet=rs</span><br></pre></td></tr></table></figure><p>注意 dbpath 改为我们第一步创建的目录，端口号改为 20000 （这个随意，只要该端口没被占用即可）， configsvr 表示这是一个配置服务器，另外由于我们的配置服务器要做成备份集，所以要设置 replSet。</p><p>3.做好前两步之后，执行如下命令启动配置服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /opt/mongodb/bin/mongodb20000.conf</span><br></pre></td></tr></table></figure><p>最后，在另外两台服务器上重复上面三个步骤。</p><p>三台服务器上都启动成功之后，参考我们之前的<a href>MongoDB 副本集搭建</a>一文，将这三台配置服务器配成一个副本集，副本集的配置我这里就不再赘述。</p><h2 id="搭建Mongos"><a href="#搭建Mongos" class="headerlink" title="搭建Mongos"></a>搭建Mongos</h2><p>Mongos 实例我们可以启动在任意一台服务器上，我这里就启动在 <code>192.168.248.128</code>上，Mongos 的配置步骤如下：</p><p>1.复制一份 mongodb.conf，命名为 mongos.conf，修改内容：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logpath=/opt/mongodb/logs/mongos.log</span><br><span class="line">port=30000</span><br><span class="line">fork=true</span><br><span class="line">configdb=rs/192.168.248.128:20000,192.168.248.135:20000,192.168.248.136:20000</span><br></pre></td></tr></table></figure><p>因为 mongos 中不需要保存数据，所以不需要 dbpath，端口号改为 30000，configdb 表示三个配置服务器的地址，注意最前面的 rs 表示配置服务器副本集的名称。</p><p>2.配置完成后，执行如下命令启动 mongos:</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongos -f /opt/mongodb/bin/mongos.conf</span><br></pre></td></tr></table></figure><h2 id="搭建三个分片"><a href="#搭建三个分片" class="headerlink" title="搭建三个分片"></a>搭建三个分片</h2><p>三个分片实际上就是三个普通的 MongoDB 服务器，给大家看下我的配置文件：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dbpath=/opt/mongodb/db</span><br><span class="line">logpath=/opt/mongodb/logs/mongodb.log</span><br><span class="line">port=27017</span><br><span class="line">fork=true</span><br><span class="line">shardsvr=true</span><br></pre></td></tr></table></figure><p>注意多了个 shardsvr 表示这是一个分片服务器。<br>然后在三台服务器上分别执行如下命令启动分片：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /opt/mongodb/bin/mongodb.conf</span><br></pre></td></tr></table></figure><h2 id="添加分片"><a href="#添加分片" class="headerlink" title="添加分片"></a>添加分片</h2><p>上面三个步骤完成之后，我们就进入到 mongos 的 shell 命令行了，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --port=30000</span><br></pre></td></tr></table></figure><p>然后我们可以通过如下命令查看一下分片的当前状态：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.status()</span><br></pre></td></tr></table></figure><p>执行结果如下(部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">  databases:</span><br></pre></td></tr></table></figure><p>shards 表示分片服务器，目前还没有，databases 表示分片的库，目前也还没有，接下来我们通过如下命令添加分片服务器：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh.addShard(&quot;192.168.248.128:27017&quot;)</span><br><span class="line">sh.addShard(&quot;192.168.248.135:27017&quot;)</span><br><span class="line">sh.addShard(&quot;192.168.248.136:27017&quot;)</span><br></pre></td></tr></table></figure><p>添加三个分片服务器，然后再执行 <code>sh.status()</code>,结果如下(部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;192.168.248.128:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;192.168.248.135:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0002&quot;,  &quot;host&quot; : &quot;192.168.248.136:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard0000&quot;,  &quot;partitioned&quot; : false &#125;</span><br></pre></td></tr></table></figure><h2 id="设置集合分片"><a href="#设置集合分片" class="headerlink" title="设置集合分片"></a>设置集合分片</h2><p>接下来我们来设置集合的分片，首先执行如下命令表示给某个数据库分片：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.enableSharding(&quot;sang&quot;)</span><br></pre></td></tr></table></figure><p>对集合分片时，需要选择一个片键，片键实际上就是集合中的一个键，MongoDB 将根据这个片键来拆分数据，我们需要先对片键建立索引，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.c1.ensureIndex(&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>然后以 x 为片键，对 c1 集合进行分片，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.shardCollection(&quot;sang.c1&quot;,&#123;x:1&#125;)</span><br></pre></td></tr></table></figure><p>做完这些之后，再执行 <code>sh.status()</code> 命令，查看目前状态，结果如下(部分)：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--- Sharding Status ---</span><br><span class="line">  sharding version: &#123;</span><br><span class="line">&#125;</span><br><span class="line">  shards:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;192.168.248.128:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;192.168.248.135:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;shard0002&quot;,  &quot;host&quot; : &quot;192.168.248.136:27017&quot;,  &quot;state&quot; : 1 &#125;</span><br><span class="line">  databases:</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;test&quot;,  &quot;primary&quot; : &quot;shard0000&quot;,  &quot;partitioned&quot; : false &#125;</span><br><span class="line">        &#123;  &quot;_id&quot; : &quot;sang&quot;,  &quot;primary&quot; : &quot;shard0001&quot;,  &quot;partitioned&quot; : true &#125;</span><br><span class="line">                sang.c1</span><br><span class="line">                        shard key: &#123; &quot;x&quot; : 1 &#125;</span><br><span class="line">                        unique: false</span><br><span class="line">                        balancing: true</span><br><span class="line">                        chunks:</span><br><span class="line">                                shard0001       1</span><br><span class="line">                        &#123; &quot;x&quot; : &#123; &quot;$minKey&quot; : 1 &#125; &#125; --&gt;&gt; &#123; &quot;x&quot; : &#123; &quot;$maxKey&quot; : 1 &#125; &#125; on : shard0001 Timestamp(1, 0)</span><br></pre></td></tr></table></figure><p>做完上面这些之后，我们再做两个操作：</p><p>1.设置自动分片：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh.setBalancerState(true)</span><br></pre></td></tr></table></figure><p>2.设置 chunksize,chunksize 这一项是用来指定 chunk 的大小的，为了方便测试分片效果，我们把 chunksize 指定为 1MB，即当这个分片中插入的数据大于 1M 时开始进行数据分片</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.settings.save(&#123;_id:&quot;chunksize&quot;,value:1&#125;)</span><br></pre></td></tr></table></figure><p>OK，做好这些之后，大功告成。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试方式很简单，我们直接在 mongos 的命令行向 sang 的 c1 集合中插入 50000 条数据，然后再查看这些数据的分布，就知道分片有没有成功了：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(var i=0;i&lt;50000;i++)&#123;db.c1.insert(&#123;x:Math.random()*1000000,name:&quot;hahah&quot;+i&#125;)&#125;</span><br></pre></td></tr></table></figure><p>然后执行 <code>db.c1.stats()</code> ,结果如下：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="hljs-attr">"sharded"</span> : <span class="hljs-literal">true</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">50000</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">2688890</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">1781760</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">1978368</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"nchunks"</span> : <span class="hljs-number">5</span>,</span><br><span class="line"><span class="hljs-attr">"shards"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"shard0000"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">926504</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">17229</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">462848</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">516096</span>,</span><br><span class="line"><span class="hljs-attr">"indexSizes"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"_id_"</span> : <span class="hljs-number">184320</span>,</span><br><span class="line"><span class="hljs-attr">"x_1"</span> : <span class="hljs-number">331776</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"ok"</span> : <span class="hljs-number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"shard0001"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">392593</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">7299</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">667648</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">737280</span>,</span><br><span class="line"><span class="hljs-attr">"indexSizes"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"_id_"</span> : <span class="hljs-number">253952</span>,</span><br><span class="line"><span class="hljs-attr">"x_1"</span> : <span class="hljs-number">483328</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"ok"</span> : <span class="hljs-number">1</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"shard0002"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"ns"</span> : <span class="hljs-string">"sang.c1"</span>,</span><br><span class="line"><span class="hljs-attr">"size"</span> : <span class="hljs-number">1369793</span>,</span><br><span class="line"><span class="hljs-attr">"count"</span> : <span class="hljs-number">25472</span>,</span><br><span class="line"><span class="hljs-attr">"avgObjSize"</span> : <span class="hljs-number">53</span>,</span><br><span class="line"><span class="hljs-attr">"storageSize"</span> : <span class="hljs-number">651264</span>,</span><br><span class="line"><span class="hljs-attr">"capped"</span> : <span class="hljs-literal">false</span>,</span><br><span class="line"><span class="hljs-attr">"nindexes"</span> : <span class="hljs-number">2</span>,</span><br><span class="line"><span class="hljs-attr">"totalIndexSize"</span> : <span class="hljs-number">724992</span>,</span><br><span class="line"><span class="hljs-attr">"indexSizes"</span> : &#123;</span><br><span class="line"><span class="hljs-attr">"_id_"</span> : <span class="hljs-number">237568</span>,</span><br><span class="line"><span class="hljs-attr">"x_1"</span> : <span class="hljs-number">487424</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="hljs-attr">"ok"</span> : <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，看到如上结果，说明我们的数据已经分布在三个分片服务器中了。</p><p>好了，MongoDB 中分片环境的搭建我们就先说到这里，小伙伴们有问题欢迎留言讨论。<br>参考资料：</p><ol><li>《MongoDB权威指南第2版》 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分片是指将数据拆分，拆分后存放在不同的机器上的过程，以此来降低单个服务器的压力，同时也解决单个服务器硬盘空间不足的问题，让我们可以用廉价的机器实现高性能的数据架构。&lt;/p&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://www.javaboy.org/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://www.javaboy.org/tags/MongoDB/"/>
    
  </entry>
  
</feed>
