<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2021-10-20T14:12:41.333Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>松哥 B 站视频上新啦～</title>
    <link href="http://www.javaboy.org/2021/1019/scheduling_video.html"/>
    <id>http://www.javaboy.org/2021/1019/scheduling_video.html</id>
    <published>2021-10-19T13:40:38.000Z</published>
    <updated>2021-10-20T14:12:41.333Z</updated>
    
    <content type="html"><![CDATA[<p>是的，终于更新啦～</p><p>这半年时间，松哥视频一直都在录，不过都是发在公众号上，基本上没有上传到 B 站。</p><a id="more"></a><p>可能由于手机屏幕较小且手机上看视频比较费流量，所以公众号上视频的播放量一直不怎么样，我也挺郁闷。</p><p>这里多说一句，公众号上看视频可以选择分辨率，有小伙伴反映手机上视频模糊，其实只要调一下分辨率即可，如下图：</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211018191948.png" alt></p><p>视频右下角可以选择视频分辨率，选择<strong>超清</strong>即可。</p><p>之前视频一直没上传到 B 站是因为我这里上传 B 站太麻烦了。一来家里的网络上载带宽一直不达标，上传到 B 站非常耗时；二来因为我录的都是视频教程，一般都是好几集，在 B 站上传时候要分 P 上传，Mac 端没有对应的工具，只有 Windows 端有上传工具可以分 P 上传，而我录视频都是在 Mac 上录的，一想想要把视频分类整理拷贝到 Windows 上去，就感觉好麻烦，还是再攒攒吧，攒多了一起搞。</p><p>现在终于攒的差不多了，开始上传啦～</p><p>不过网络依然很慢，昨天传了一个下午，上传了三集，把 DIY 定时任务的视频教程上传完了。。。</p><p><img src="http://img.itboyhub.com/2021/10/tran/20211018192530.png" alt></p><p>这个教程一共三集，约 80 分钟左右，就是手把手带领大家敲一个可动态配置的定时任务管理系统，松哥之前也写过专门的文章介绍，如下：</p><ul><li><a href="https://mp.weixin.qq.com/s/skZ7uU7q1iH9QrV2EKiGOg" target="_blank" rel="noopener">Spring 定时任务玩出花！</a></li><li><a href="https://mp.weixin.qq.com/s/H3RrpnBYDNwgtSOMlt3Ihg" target="_blank" rel="noopener">刚出炉热腾腾的定时任务可视化管理系统</a></li></ul><p>感兴趣的小伙伴可以先去 B 站围观下：</p><ul><li><a href="https://www.bilibili.com/video/BV1Yq4y157PM" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yq4y157PM</a></li></ul><p>前段时间在连载的 Spring Security 最近也会慢慢上传到 B 站上了，另外这个周末我还抽空了录了一个 Spring 事务的视频，这些视频我今天就会开始上传，不过由于网络问题，上传好了这两天就会和小伙伴们见面啦～</p><p>点击阅读原文，直达 B 站。</p><p><a href="https://space.bilibili.com/49484631" target="_blank" rel="noopener">https://space.bilibili.com/49484631</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是的，终于更新啦～&lt;/p&gt;
&lt;p&gt;这半年时间，松哥视频一直都在录，不过都是发在公众号上，基本上没有上传到 B 站。&lt;/p&gt;
    
    </summary>
    
      <category term="视频教程" scheme="http://www.javaboy.org/categories/%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="video" scheme="http://www.javaboy.org/tags/video/"/>
    
      <category term="视频" scheme="http://www.javaboy.org/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>松哥读者开发的这款 Chrome 插件，让你的项目联调 so easy！</title>
    <link href="http://www.javaboy.org/2021/1018/chrome.html"/>
    <id>http://www.javaboy.org/2021/1018/chrome.html</id>
    <published>2021-10-18T13:40:24.000Z</published>
    <updated>2021-10-20T14:12:29.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p><code>poseidon-chrome-proxy</code> 是一款浏览器请求代理插件；它能把向服务器发起的请求代理到本地，并且可以修改其请求头。</p><p>通过这个插件我们可以降低前后端联调的成本，以及帮助我们快速定位线上 bug。</p><a id="more"></a><p>插件作者：joyful 与 muggle，这个插件我们会长期维护下去，小伙伴们如果有想加进去的功能可以联系我们哟。</p><h2 id="插件使用说明"><a href="#插件使用说明" class="headerlink" title="插件使用说明"></a>插件使用说明</h2><p>插件下载地址：<a href="https://github.com/Poseidon-Service-Framework/poseidon-chrome-proxy/releases" target="_blank" rel="noopener">https://github.com/Poseidon-Service-Framework/poseidon-chrome-proxy/releases</a> </p><p><img src="http://img.itboyhub.com/2021/10/tran/插件下载.jpg" alt></p><p>目前最新版本是 <code>2.1.0-beta</code>，下载后解压并打开谷歌浏览器 <code>更多工具-&gt;扩展程序</code>：</p><p><img src="http://img.itboyhub.com/2021/10/tran/加载扩展程序1.jpg" alt></p><p>然后打开开发者模式选择解压的插件：</p><p><img src="http://img.itboyhub.com/2021/10/tran/加载扩展程序2.jpg" alt></p><p>插件安装好后，点击图标弹出配置页面，可以在该页面上配置我们的请求头信息与代理规则，配置使用的是 json 格式：</p><p><img src="http://img.itboyhub.com/2021/10/tran/插件pop.jpg" alt></p><p>点击右上角角的 <code>Json代码说明</code> 可以看到 json 中每个字段的含义，编辑完 json 后直接退出即可保存编辑内容。</p><p>点击最下方的<strong>停用/启用</strong>按钮，停用/启用代理功能；</p><h2 id="插件-json-内容说明"><a href="#插件-json-内容说明" class="headerlink" title="插件 json 内容说明"></a>插件 json 内容说明</h2><p>插件的 json 内容是一个数组，每个 json 代表一个代理规则，json 中字段说明</p><ul><li><code>domain</code>: 需要代理的域名，如 <code>www.javaboy.org</code></li><li><code>requestHeader</code>： 请求头设置数组， 请以 <code>name:value</code> 的形式填写请求头信息</li><li><code>matchingRules</code>：拦截规则数组。</li><li><code>route</code>：请求拦截前缀</li><li><code>targetUrl</code>：请求处理代理服务器的 <code>ip:端口</code></li></ul><p>配置示例：</p><figure class="highlight json hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="hljs-attr">"domain"</span>: <span class="hljs-string">"www.javaboy.org"</span>,</span><br><span class="line">    <span class="hljs-attr">"requestHeader"</span>: [<span class="hljs-string">"test:xxxxxxxxxx"</span>],</span><br><span class="line">    <span class="hljs-attr">"matchingRules"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="hljs-attr">"route"</span>: <span class="hljs-string">"/a/b"</span>,</span><br><span class="line">        <span class="hljs-attr">"targetUrl"</span>: <span class="hljs-string">"127.0.0.1:9020"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,  &#123;</span><br><span class="line">    <span class="hljs-attr">"domain"</span>: <span class="hljs-string">"xx.20yx.net"</span>,</span><br><span class="line">    <span class="hljs-attr">"requestHeader"</span>: [<span class="hljs-string">"test:8888"</span>],</span><br><span class="line">    <span class="hljs-attr">"matchingRules"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="hljs-attr">"route"</span>: <span class="hljs-string">"/"</span>,</span><br><span class="line">        <span class="hljs-attr">"targetUrl"</span>: <span class="hljs-string">"127.0.0.1:8080"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如上配置会将：</p><ol><li><code>https://www.javaboy.org/a/b/xxxx</code> 代理到 <code>127.0.0.1:9020/a/b/xxxx</code> 并携带请求头 <code>test:xxxxxxxxxx</code>。</li><li>将 <code>https://xxx.20yx.net/ss/ss</code> 代理到 <code>127.0.0.1:8080/ss/ss</code> 并携带请求头 <code>test:8888</code>。</li></ol><p>插件的原理可在项目的 readme 中查看。</p><h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p>插件注意事项：</p><ol><li>该插件和一些梯子冲突，如果你在使用梯子上网的时候请禁用该插件。</li><li><code>targetUrl</code> 只能填写 <code>ip:port</code>，形如 <code>127.0.0.1:8080/xxx</code> 这种是不会生效的；</li><li>部分代理的网址会失效，如 <code>www.baidu.com</code> 原因未知。</li></ol><p>特别鸣谢：</p><p>感谢 joyful 大佬参与开发，joyful 大佬是这个插件的主要开发，为本插件提供了很多想法并贡献了很多代码；joyful大佬的博客地址：<a href="https://blog.csdn.net/qq_42671576，感兴趣的可以关注哦。" target="_blank" rel="noopener">https://blog.csdn.net/qq_42671576，感兴趣的可以关注哦。</a></p><p>感谢参与插件测试的各位小伙伴。</p><p>如果小伙伴们对这个有好的想法，或者需要参与开发的请联系本人，撸码不易，感兴趣大佬给个star；求star 求star 求star ：<a href="https://github.com/Poseidon-Service-Framework/poseidon-chrome-proxy。" target="_blank" rel="noopener">https://github.com/Poseidon-Service-Framework/poseidon-chrome-proxy。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插件介绍&quot;&gt;&lt;a href=&quot;#插件介绍&quot; class=&quot;headerlink&quot; title=&quot;插件介绍&quot;&gt;&lt;/a&gt;插件介绍&lt;/h2&gt;&lt;p&gt;&lt;code&gt;poseidon-chrome-proxy&lt;/code&gt; 是一款浏览器请求代理插件；它能把向服务器发起的请求代理到本地，并且可以修改其请求头。&lt;/p&gt;
&lt;p&gt;通过这个插件我们可以降低前后端联调的成本，以及帮助我们快速定位线上 bug。&lt;/p&gt;
    
    </summary>
    
      <category term="chrome" scheme="http://www.javaboy.org/categories/chrome/"/>
    
    
      <category term="Chrome" scheme="http://www.javaboy.org/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 还能做延迟队列？nice！</title>
    <link href="http://www.javaboy.org/2021/1015/rabbitmq_delay_queue.html"/>
    <id>http://www.javaboy.org/2021/1015/rabbitmq_delay_queue.html</id>
    <published>2021-10-15T13:40:06.000Z</published>
    <updated>2021-10-20T14:12:23.336Z</updated>
    
    <content type="html"><![CDATA[<p>在很多场景下，我们都有延迟队列的需求，然而默认情况下 RabbitMQ 并未提供延迟队列相关的功能，不过，在前面的文章中，松哥和大家分享了 RabbitMQ 中的死信队列，结合死信队列以及消息过期时间的设定，我们也可以实现延迟队列的功能，今天我们就一起来看下。</p><a id="more"></a><blockquote><p>RabbitMQ 其实有提供专门的延迟队列插件，这个咱们有空了再聊。</p></blockquote><p>如果大家还没看过前面的文章，可以先去瞅瞅，这有助于理解本文：</p><ul><li><a href="https://mp.weixin.qq.com/s/fFqzuN2AnLazoCyahL3EFw" target="_blank" rel="noopener">RabbitMQ 中的消息会过期吗？</a></li></ul><h2 id="1-什么时候需要延迟队列？"><a href="#1-什么时候需要延迟队列？" class="headerlink" title="1. 什么时候需要延迟队列？"></a>1. 什么时候需要延迟队列？</h2><p>先来说说什么时候我们需要延迟队列。</p><p>举几个简单的例子。</p><ul><li>在电商项目中，当我们下单之后，一般需要 20 分钟之内或者 30 分钟之内付款，否则订单就会进入异常处理逻辑中，被取消，那么进入到异常处理逻辑中，就可以当成是一个延迟队列。</li><li>我买了一个智能砂锅，可以用来煮粥，上班前把素材都放到锅里，然后设置几点几分开始煮粥，这样下班后就可以喝到香喷喷的粥了，那么这个煮粥的指令也可以看成是一个延迟任务，放到一个延迟队列中，时间到了再执行。</li><li>公司的会议预定系统，在会议预定成功后，会在会议开始前半小时通知所有预定该会议的用户。</li><li>安全工单超过 24 小时未处理，则自动拉企业微信群提醒相关责任人。</li><li>用户下单外卖以后，距离超时时间还有 10 分钟时提醒外卖小哥即将超时。</li><li>…</li></ul><p>很多场景下我们都需要延迟队列。</p><p>可能有小伙伴说至于嘛，直接搞个定时任务不更方便？如果项目中只有一个这样的延迟队列的场景，那么搞个定时任务似乎也可以，但是如果项目中有很多这样的场景，那么定时任务很明显就不是最佳方案了，我们可以通过延迟队列来实现一个通用的解决方案。</p><h2 id="2-延迟队列实现思路"><a href="#2-延迟队列实现思路" class="headerlink" title="2. 延迟队列实现思路"></a>2. 延迟队列实现思路</h2><p>延迟队列实现的思路也很简单，就是<a href="https://mp.weixin.qq.com/s/fFqzuN2AnLazoCyahL3EFw" target="_blank" rel="noopener">上篇文章</a>我们所说的 DLX（死信交换机）+TTL（消息超时时间）。</p><p>我们可以把死信队列就当成延迟队列。</p><p>具体来说是这样：</p><p><strong>假如一条消息需要延迟 30 分钟执行，我们就设置这条消息的有效期为 30 分钟，同时为这条消息配置死信交换机和死信 <code>routing_key</code>，并且不为这个消息队列设置消费者，那么 30 分钟后，这条消息由于没有被消费者消费而进入死信队列，此时我们有一个消费者就在“蹲点”这个死信队列，消息一进入死信队列，就立马被消费了。</strong></p><p>这就是延迟队列的实现思路，是不是很简单？</p><h2 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h2><p>接下来松哥通过一个简单的案例，来和大家演示一下延迟队列的具体实现。</p><p>首先准备好一个启动的 RabbitMQ。</p><p>然后我们创建一个 Spring Boot 项目，引入 RabbitMQ 依赖：</p><p><img src="http://img.itboyhub.com/2021/07/20211010211954.png" alt></p><p>然后在 application.properties 中配置一下 RabbitMQ 的基本连接信息：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=localhost</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.port=5672</span><br></pre></td></tr></table></figure><p>接下来我们来配置两个消息队列：一个普通队列，一个死信队列：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_QUEUE_NAME = <span class="hljs-string">"javaboy_queue_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_EXCHANGE_NAME = <span class="hljs-string">"javaboy_exchange_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_ROUTING_KEY = <span class="hljs-string">"javaboy_routing_key"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_QUEUE_NAME = <span class="hljs-string">"dlx_queue_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_EXCHANGE_NAME = <span class="hljs-string">"dlx_exchange_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_ROUTING_KEY = <span class="hljs-string">"dlx_routing_key"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 死信队列</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Queue <span class="hljs-title">dlxQueue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DLX_QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 死信交换机</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DirectExchange <span class="hljs-title">dlxExchange</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DLX_EXCHANGE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 绑定死信队列和死信交换机</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Binding <span class="hljs-title">dlxBinding</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> BindingBuilder.bind(dlxQueue()).to(dlxExchange())</span><br><span class="line">                .with(DLX_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 普通消息队列</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Queue <span class="hljs-title">javaboyQueue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="hljs-comment">//设置消息过期时间</span></span><br><span class="line">        args.put(<span class="hljs-string">"x-message-ttl"</span>, <span class="hljs-number">1000</span>*<span class="hljs-number">10</span>);</span><br><span class="line">        <span class="hljs-comment">//设置死信交换机</span></span><br><span class="line">        args.put(<span class="hljs-string">"x-dead-letter-exchange"</span>, DLX_EXCHANGE_NAME);</span><br><span class="line">        <span class="hljs-comment">//设置死信 routing_key</span></span><br><span class="line">        args.put(<span class="hljs-string">"x-dead-letter-routing-key"</span>, DLX_ROUTING_KEY);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(JAVABOY_QUEUE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 普通交换机</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DirectExchange <span class="hljs-title">javaboyExchange</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(JAVABOY_EXCHANGE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 绑定普通队列和与之对应的交换机</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Binding <span class="hljs-title">javaboyBinding</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> BindingBuilder.bind(javaboyQueue())</span><br><span class="line">                .to(javaboyExchange())</span><br><span class="line">                .with(JAVABOY_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置代码虽然略长，不过原理其实简单。</p><ul><li>配置可以分为两组，第一组配置死信队列，第二组配置普通队列。每一组都由消息队列、消息交换机以及 Binding 三者组成。</li><li>配置消息队列时，为消息队列指定死信队列，不熟悉的小伙伴可以翻一下上篇文章，传送门：<a href="https://mp.weixin.qq.com/s/fFqzuN2AnLazoCyahL3EFw" target="_blank" rel="noopener">RabbitMQ 中的消息会过期吗？</a>。</li><li>配置队列中的消息过期时间时，默认的时间单位时毫秒。</li></ul><p>接下来我们为死信队列配置一个消费者，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DlxConsumer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(DlxConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@RabbitListener</span>(queues = QueueConfig.DLX_QUEUE_NAME)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        logger.info(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到消息后就将之打印出来。</p><p>这就完事了。</p><p>启动项目。</p><p>最后我们在单元测试中发送一条消息：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@SpringBootTest</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayQueueApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Test</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">        rabbitTemplate.convertAndSend(QueueConfig.JAVABOY_EXCHANGE_NAME, QueueConfig.JAVABOY_ROUTING_KEY, <span class="hljs-string">"hello javaboy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就没啥好说的了，就是普通的消息发送，10 秒之后这条消息会在死信队列的消费者中被打印出来。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，这就是我们用 RabbitMQ 做延迟队列的思路～</p><p>小伙伴们在公众号后台回复文章标题，可以下载本文案例～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在很多场景下，我们都有延迟队列的需求，然而默认情况下 RabbitMQ 并未提供延迟队列相关的功能，不过，在前面的文章中，松哥和大家分享了 RabbitMQ 中的死信队列，结合死信队列以及消息过期时间的设定，我们也可以实现延迟队列的功能，今天我们就一起来看下。&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
      <category term="延迟队列" scheme="http://www.javaboy.org/tags/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>闲扯Maven项目代码组织形式</title>
    <link href="http://www.javaboy.org/2021/1011/maven_code.html"/>
    <id>http://www.javaboy.org/2021/1011/maven_code.html</id>
    <published>2021-10-11T13:39:46.000Z</published>
    <updated>2021-10-20T14:13:17.843Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>因为最近有小伙伴问到了，所以我想和大家随便扯扯 Maven 项目中代码的组织形式这个问题。</p><p>其实也不是啥大问题，但是如果不懂的话，就像雾里看花，始终不能看的明明白白，懂了就像一层窗户纸，捅破就好了。</p><a id="more"></a><p>所以我们就简单扯几句。</p><h2 id="1-代码组织形式"><a href="#1-代码组织形式" class="headerlink" title="1. 代码组织形式"></a>1. 代码组织形式</h2><p>首先来说说代码组织形式。</p><p>一般来说，就两种比较常见的形式：</p><ul><li>平铺</li><li>父子结构</li></ul><p>这两种形式松哥在不同的项目中都有遇到过，所以我们就不说孰优孰劣，单纯来说这两种方案。</p><h3 id="1-1-平铺"><a href="#1-1-平铺" class="headerlink" title="1.1 平铺"></a>1.1 平铺</h3><p>平铺的代码类似下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── parent</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src</span><br><span class="line">│       ├── main</span><br><span class="line">│       │   ├── java</span><br><span class="line">│       │   └── resources</span><br><span class="line">│       └── test</span><br><span class="line">│           └── java</span><br><span class="line">├── vhr-dao</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── src</span><br><span class="line">│   │   ├── main</span><br><span class="line">│   │   │   ├── java</span><br><span class="line">│   │   │   └── resources</span><br><span class="line">│   │   └── test</span><br><span class="line">│   │       └── java</span><br><span class="line">└── vhr-service</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    ├── src</span><br><span class="line">    │   ├── main</span><br><span class="line">    │   │   ├── java</span><br><span class="line">    │   │   └── resources</span><br><span class="line">    │   └── test</span><br><span class="line">    │       └── java</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20211009194907.png" alt></p><p>可以看到，在这种结构下，parent 父工程和各个子工程从代码组织形式上来看都是平级的，都处于同一个目录下。</p><p>不过仔细查看 pom.xml 文件，还是能够清晰的看到这三个 module 的父子关系的：</p><p>parent：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>../vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可以看到，在指定 module 时，由于 vhr-dao 和 vhr-service 和 parent 的 pom.xml 不在同一个目录下，所以这里使用了相对路径，相对路径的参考依据是 parent 的 pom.xml 文件位置。</strong></p><p>vhr-dao：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>可以看到，relativePath 节点中，通过相对路径指定了 parent 的 pom.xml 文件位置，这个相对路径的参考依据是子模块的 pom.xml 文件。</strong></p><p>vhr-service：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>&gt;</span>../parent/pom.xml<span class="hljs-tag">&lt;/<span class="hljs-name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个和 vhr-dao 的差不多，不赘述。</p><h3 id="1-2-父子结构"><a href="#1-2-父子结构" class="headerlink" title="1.2 父子结构"></a>1.2 父子结构</h3><p>父子结构则类似于下面这样：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── maven_parent</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   ├── vhr-dao</span><br><span class="line">│   │   ├── pom.xml</span><br><span class="line">│   │   └── src</span><br><span class="line">│   │       ├── main</span><br><span class="line">│   │       │   ├── java</span><br><span class="line">│   │       │   └── resources</span><br><span class="line">│   │       └── test</span><br><span class="line">│   │           └── java</span><br><span class="line">│   └── vhr-service</span><br><span class="line">│       ├── pom.xml</span><br><span class="line">│       └── src</span><br><span class="line">│           ├── main</span><br><span class="line">│           │   ├── java</span><br><span class="line">│           │   └── resources</span><br><span class="line">│           └── test</span><br><span class="line">│               └── java</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20211009200853.png" alt></p><p>这种父子结构的看起来就非常的层次分明了，parent 和各个 module 一眼就能看出来，我们从 GitHub 上下载的很多开源项目如 Shiro，都是这种结构。</p><p>不过文件夹的层级并不能说明任何问题，关键还是要看 pom.xml 中的定义，接下来我们就来看看 parent 的 pom.xml 和各个子模块的 pom.xml 有何异同。</p><p>maven_parent：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>和前面不同的是，这里声明 modules 不需要相对路径了（其实还是相对路径，只是不需要 <code>../</code> 了），因为各个子模块和 parent 的 pom.xml 文件处于同一目录下。</strong></p><p>vhr-dao：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-dao<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>这里也不需要通过 relativePath 节点去指定 parent 的 pom.xml 文件位置了，因为 parent 的 pom.xml 和各个子模块处于同一目录下。</strong></p><p>vhr-service：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.javaboy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>vhr-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-打包问题"><a href="#2-打包问题" class="headerlink" title="2. 打包问题"></a>2. 打包问题</h2><h3 id="2-1-继承"><a href="#2-1-继承" class="headerlink" title="2.1 继承"></a>2.1 继承</h3><p>有的时候，单纯只是想通过 parent 来统一管理不同的项目的依赖，并非一个聚合项目。</p><p>这个时候只需要去掉 parent 的 pom.xml 中的 modules 节点及其中的内容即可，这样就不是聚合工程了，各个子模块也可以独立打包。</p><h3 id="2-2-聚合"><a href="#2-2-聚合" class="headerlink" title="2.2 聚合"></a>2.2 聚合</h3><p>当然很多情况我们是聚合工程。</p><p>聚合工程的话，一般松哥是建议大家从 parent 处统一进行打包：</p><p><img src="http://img.itboyhub.com/2021/07/20211009204226.png" alt></p><p>这样可以确保打包到的是最新的代码。</p><p>当然还有另外一种操作流程：</p><ol><li>首先将 parent 安装到本地仓库。</li><li>然后分别将 model、dao 以及 service 等模块安装到本地仓库。</li><li>最后 web 模块就可以独立打包了。</li></ol><p>如果使用这种操作流程，需要注意一点，就是每个模块代码更新之后，要及时安装到本地仓库，否则当 web 模块独立打包时，用到的其他模块就不是最新的代码。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，几个 Maven 中的小问题，窗户纸捅破了就豁然开朗啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;因为最近有小伙伴问到了，所以我想和大家随便扯扯 Maven 项目中代码的组织形式这个问题。&lt;/p&gt;
&lt;p&gt;其实也不是啥大问题，但是如果不懂的话，就像雾里看花，始终不能看的明明白白，懂了就像一层窗户纸，捅破就好了。&lt;/p&gt;
    
    </summary>
    
      <category term="Maven" scheme="http://www.javaboy.org/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://www.javaboy.org/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>LayUI 走了，JDK17 来了</title>
    <link href="http://www.javaboy.org/2021/0928/layui_jdk17.html"/>
    <id>http://www.javaboy.org/2021/0928/layui_jdk17.html</id>
    <published>2021-09-28T13:39:30.000Z</published>
    <updated>2021-10-20T14:11:08.388Z</updated>
    
    <content type="html"><![CDATA[<p>上周五松哥就在 QQ 群里看到了 LayUI 下线的消息：</p><a id="more"></a><p><img src="http://img.itboyhub.com/2021/07/20210927195612.png" alt></p><p>看到这条消息时充满了感慨，毕竟松哥虽然主业是 Java，但是也一直在关注着前端的发展。</p><p>2013 年还在大三的时候就玩过 TypeScript，2014 年的时候当时还买了一本书 NodeJS 的书，后来大学毕业，工作，慢慢的兴趣就集中在后端了，前端虽然也一直在关注，但是只能说略懂略懂。</p><p>这是 LayUI 官方的通告：</p><p><img src="http://img.itboyhub.com/2021/07/20210927202106.png" alt></p><p>不得不说 LayUI 作者这文笔还是可以滴。</p><p>LayUI 算是 jQuery 这一派的 UI 库了。</p><p>松哥早年也是 jQuery 的狂热爱好者，jQuery、jQuery UI、jQuery Mobile 都用过，甚至用 jQuery Mobile 还搞过 <code>香草兰移动农务栽培技术</code> 手机 App，这个 App 还有推广应用。想当年我接的第一个私活，前端就是用 jQuery EasyUI 做的，所以说，我对 jQuery 还是充满了感情的。</p><p>不过自从投入 Vue 的怀抱后，老实说，就不怎么待见 jQuery 了，毕竟 Vue 更香，配合着前端工程化，Vue + ElementUI + Spring Boot 几乎成了经典搭配。</p><p>然而，公司的实际情况和我们想象中的情况却总是存在着差距。</p><p>由于历史原因，或者实际使用场景等原因，大部分是前者。我们依然会在不少项目中遇到 jQuery 家族的产品，说出来你可能都不信，松哥前两天还在敲 jQuery EasyUI 的代码，上个月还敲过 LayUI 的代码，虽然我一点都不想写 LayUI，但是很多时候，很多事情不由你。</p><p>不过老实说，每次我打开 LayUI 官网的时候，我都在想，咋还能访问？难道真的还有很多人舍不得 jQuery，舍不得 LayUI？现在好啦，以后不会再有这样的困惑了。</p><p>Vue 袭来，有的 jQuery 库在积极转型，例如 jQuery EasyUI 也有 Vue 版本，没有转型的，如 LayUI 最终不免落入关站停更的地步。</p><p>LayUI 下线，也算是意料之中吧，这个行业就是这样，技术更新迭代如流水，唯有学习的态度永恒。</p><p>LayUI 走了，JDK17 来了。</p><p>以上内容来自一位 Java 程序员的见解，关于前端部分狂吹 Vue 不一定准确，大家且听之，轻喷。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周五松哥就在 QQ 群里看到了 LayUI 下线的消息：&lt;/p&gt;
    
    </summary>
    
      <category term="layui" scheme="http://www.javaboy.org/categories/layui/"/>
    
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/tags/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
      <category term="杂谈" scheme="http://www.javaboy.org/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>一个奇怪的登录需求</title>
    <link href="http://www.javaboy.org/2021/0927/spring_security_login.html"/>
    <id>http://www.javaboy.org/2021/0927/spring_security_login.html</id>
    <published>2021-09-27T13:39:16.000Z</published>
    <updated>2021-10-20T14:13:11.340Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>一个奇怪的登录需求。</p><a id="more"></a><p>这是小伙伴们在微信群里的一个提问，我觉得很有意思：</p><p><img src="http://img.itboyhub.com/2021/07/20210927122328.png" alt></p><p>虽然这并非一个典型需求，但是把这个问题解决了，有助于加深大家对于 Spring Security 的理解。</p><p>因此，松哥打算撸一篇文章和大家稍微聊聊这个话题。</p><h2 id="1-问题再现"><a href="#1-问题再现" class="headerlink" title="1. 问题再现"></a>1. 问题再现</h2><p>可能有小伙伴还不明白这个问题，因此我先稍微解释一下。</p><p>当我们登录失败的时候，可能用户名写错，也可能密码写错，但是出于安全考虑，服务端一般不会明确提示是用户名写错了还是密码写错了，而只会给出一个模糊的用户名或者密码写错了。</p><p>然而对于很多新手程序员而言，可能并不了解这样一些“潜规则”，可能会给用户一个明确的提示，明确提示是用户名写错了还是密码写错了。</p><p>为了避免这一情况，Spring Security 通过封装，隐藏了用户名不存在的异常，导致开发者在开发的时候，只能获取到 BadCredentialsException，这个异常既表示用户名不存在，也表示用户密码输入错误。Spring Security 这样做是为了确保我们的系统足够安全。</p><p>然而由于种种原因，有时候我们又希望能够分别获取到用户不存在的异常和密码输入错误的异常，这个时候就需要我们对 Spring Security 进行一些简单的定制了。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>首先我们要先找到问题发生的原因，发生的地方。</p><p>在 Spring Security 中，负责用户校验的工作的类有很多，我这里就不一一列举了（感兴趣的小伙伴可以查看《<a href="https://mp.weixin.qq.com/s/i4qsE1atlKMEcLV22qYjVw" target="_blank" rel="noopener">深入浅出Spring Security</a>》一书），我这里直接说我们涉及到的关键类 <code>AbstractUserDetailsAuthenticationProvider</code>。</p><p>这个类将负责用户名密码的校验工作，具体在 authenticate 方法里边，这个方法本来特别长，我这里只把和本文相关的代码列出来：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (UsernameNotFoundException ex) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hideUserNotFoundExceptions) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-keyword">this</span>.messages</span><br><span class="line">.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>, <span class="hljs-string">"Bad credentials"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>retrieveUser 方法就是根据用户登录输入的用户名去查找用户，如果没找到，就会抛出一个 UsernameNotFoundException，这个异常被 catch 之后，会首先判断是否要隐藏这个异常，如果不隐藏，则原异常原封不动抛出来，如果需要隐藏，则抛出一个新的 BadCredentialsException 异常，BadCredentialsException 异常从字面理解就是密码输入错误的异常。</p><p>所以问题的核心就变成了 hideUserNotFoundExceptions 变量了。</p><p>这是一个 Boolean 类型的属性，默认是 true，<code>AbstractUserDetailsAuthenticationProvider</code> 也为该属性提供了 set 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHideUserNotFoundExceptions</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hideUserNotFoundExceptions)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.hideUserNotFoundExceptions = hideUserNotFoundExceptions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来修改 hideUserNotFoundExceptions 属性并不难！只要找到 <code>AbstractUserDetailsAuthenticationProvider</code> 的实例，然后调用相应的 set 方法就能修改了。</p><p>现在问题的核心变成了从哪里获取 <code>AbstractUserDetailsAuthenticationProvider</code> 的实例？</p><p>看名字就知道，<code>AbstractUserDetailsAuthenticationProvider</code> 是一个抽象类，所以它的实例其实就是它子类的实例，子类是谁？当然是负责用户密码校验工作的 <code>DaoAuthenticationProvider</code>。</p><p>这个知识点先记住，我们一会会用到。</p><h2 id="3-登录流程"><a href="#3-登录流程" class="headerlink" title="3. 登录流程"></a>3. 登录流程</h2><p>为了弄明白这个问题，我们还需要搞懂 Spring Security 一个大致的认证流程，这个也非常重要。</p><p>首先大家知道，Spring Security 的认证工作主要是由 AuthenticationManager 来完成的，而 AuthenticationManager 则是一个接口，它的实现类是 ProviderManager。简而言之，Spring Security 中具体负责校验工作的是 ProviderManager#authenticate 方法。</p><p>但是校验工作并不是由 ProviderManager 直接完成的，ProviderManager 中管理了若干个 AuthenticationProvider，ProviderManager 会调用它所管理的 AuthenticationProvider 去完成校验工作，如下图：</p><p><img src="http://img.itboyhub.com/2020/07/20200709222237.png" alt></p><p>另一方面，ProviderManager 又分为全局的和局部的。</p><p>当我们登录的时候，首先由局部的 ProviderManager 出场进行用户名密码的校验工作，如果校验成功，那么用户就登录成功了，如果校验失败，则会调用局部 ProviderManager 的 parent，也就是全局 ProviderManager 去完成校验工作，如果全局 ProviderManager 校验成功，就表示用户登录成功，如果全局 ProviderManager 校验失败，就表示用户登录失败，如下图：</p><p><img src="http://img.itboyhub.com/2020/07/20200721164221.png" alt></p><p>OK，有了上面的知识储备，我们再来分析一下我们想要抛出 UsernameNotFoundException 该怎么做。</p><h2 id="4-思路分析"><a href="#4-思路分析" class="headerlink" title="4. 思路分析"></a>4. 思路分析</h2><p>首先我们的用户校验工作在局部的 ProviderManager 中进行，局部的 ProviderManager 中管理了若干个 AuthenticationProvider，这若干个 AuthenticationProvider 中就有可能包含了我们所需要的 DaoAuthenticationProvider。那我们是否需要在这里调用 DaoAuthenticationProvider 的 setHideUserNotFoundExceptions 方法完成属性的修改呢？</p><p>松哥的建议是没必要！</p><p>为什么？</p><p>因为当用户登录的时候，首先去局部的 ProviderManager 中去校验，如果校验成功当然最好；如果校验失败，并不会立马抛出异常，而是去全局的 ProviderManager 中继续校验，这样即使我们在局部 ProviderManager 中抛出了 UsernameNotFoundException 也没用，因为最终这个异常能不能抛出来决定权在全局 ProviderManager 中（如果全局的 ProviderManager 所管理的 DaoAuthenticationProvider 没做任何特殊处理，那么局部 ProviderManager 中抛出来的 UsernameNotFoundException 异常最终还是会被隐藏）。</p><p>所以，我们要做的就是获取全局的 ProviderManager，进而获取到全局 ProviderManager 所管理的 DaoAuthenticationProvider，然后调用其 setHideUserNotFoundExceptions 方法修改相应属性值即可。</p><p>弄明白了原理，代码就简单了。</p><h2 id="5-具体实践"><a href="#5-具体实践" class="headerlink" title="5. 具体实践"></a>5. 具体实践</h2><p>全局 ProviderManager 的修改在 <code>WebSecurityConfigurerAdapter#configure(AuthenticationManagerBuilder)</code> 类中，这里配置的 AuthenticationManagerBuilder 最终用来生成全局的 ProviderManager，所以我们的配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider daoAuthenticationProvider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        daoAuthenticationProvider.setHideUserNotFoundExceptions(<span class="hljs-keyword">false</span>);</span><br><span class="line">        InMemoryUserDetailsManager userDetailsService = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        userDetailsService.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        daoAuthenticationProvider.setUserDetailsService(userDetailsService);</span><br><span class="line">        auth.authenticationProvider(daoAuthenticationProvider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .failureHandler((request, response, exception) -&gt; System.out.println(exception))</span><br><span class="line">                .permitAll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码就简单了：</p><ol><li>创建一个 DaoAuthenticationProvider 对象。</li><li>调用 DaoAuthenticationProvider 对象的 setHideUserNotFoundExceptions 方法，修改相应的属性值。</li><li>为 DaoAuthenticationProvider 配置用户数据源。</li><li>将 DaoAuthenticationProvider 设置给 auth 对象，auth 将用来生成全局的 ProviderManager。</li><li>在另一个 configure 方法中，我们就配置一下登录回调即可，登录失败的时候，打印异常信息看看。</li></ol><p>行啦。</p><p>接下来启动项目进行测试。输入一个错误的用户名，可以看到 IDEA 控制台会打印出如下信息：</p><p><img src="http://img.itboyhub.com/2021/07/20210923214411.png" alt></p><p>可以看到，UsernameNotFoundException 异常已经抛出来了。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>好啦，今天就和小伙伴们分享了一下在 Spring Security 中如何抛出 UsernameNotFoundException 异常，虽然这只是一个小众需求，但是可以加深大家对 Spring Security 的理解，感兴趣的小伙伴可以仔细琢磨下。</p><p>题外话：</p><blockquote><p>这个需求还有一个简单的实现方式，就是自定义一个用户不存在的异常，当在 UserDetailsService 中查找用户查找不到时，抛出自定义的异常，这个自定义的异常不会被隐藏，这个比较简单，我就不写代码了，感兴趣的小伙伴可以去试试。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;一个奇怪的登录需求。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 玩出花！两种方式 DIY 登录</title>
    <link href="http://www.javaboy.org/2021/0924/spring_security_diy_login.html"/>
    <id>http://www.javaboy.org/2021/0924/spring_security_diy_login.html</id>
    <published>2021-09-24T13:38:59.000Z</published>
    <updated>2021-10-20T14:13:05.481Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>一般情况下，我们在使用 Spring Security 的时候，用的是 Spring Security 自带的登录方案，配置一下登录接口，配置一下登录参数，再配置一下登录回调就能用了，这种用法可以算是最佳实践了！</p><p>但是！</p><a id="more"></a><p>总会有一些奇奇怪怪得需求，例如想自定义登录，像 Shiro 那样自己写登录逻辑，如果要实现这一点，该怎么做？今天松哥就来和大家分享一下。</p><p>松哥琢磨了一下，想在 Spring Security 中自定义登录逻辑，我们有两种思路，不过这两种思路底层实现其实异曲同工，我们一起来看下。</p><h2 id="1-化腐朽为神奇"><a href="#1-化腐朽为神奇" class="headerlink" title="1. 化腐朽为神奇"></a>1. 化腐朽为神奇</h2><p>前面松哥和大家分享了一个 Spring Security 视频：</p><ul><li><a href="https://mp.weixin.qq.com/s/x3Xm8sNe8NR0evhiBwCWWw" target="_blank" rel="noopener">没见过的奇葩登录</a></li></ul><p>这个视频里主要是和大家分享了我们其实可以使用 HttpServletRequest 来完成系统的登录，这其实是 JavaEE 的规范，这种登录方式虽然冷门，但是却很好玩！</p><p>然后松哥还和大家分享了一个视频：</p><ul><li><a href="https://mp.weixin.qq.com/s/0gLhR52BMkb4yTaC0B3_kg" target="_blank" rel="noopener">SpringSecurity登录数据获取最后一讲</a></li></ul><p>这个视频其实是在讲 Spring Security 对 HttpServletRequest 登录逻辑的实现，或句话说，HttpServletRequest 中提供的那几个和登录相关的 API，Spring Security 都按照自己的实现方式对其进行了重写。</p><p>有了这两个储备知识后，第一个 DIY Spring Security 登录的方案呼之欲出。</p><h3 id="1-1-实践"><a href="#1-1-实践" class="headerlink" title="1.1 实践"></a>1.1 实践</h3><p>我们来看看具体操作。</p><p>首先我们来创建一个 Spring Boot 工程，引入 Web 和 Security 两个依赖，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210918192205.png" alt></p><p>方便起见，我们在 application.properties 中配置一下默认的用户名密码：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.security.user.name=javaboy</span><br><span class="line">spring.security.user.password=123</span><br></pre></td></tr></table></figure><p>接下来我们提供一个 SecurityConfig，为登录接口放行：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/login"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录接口就是 <code>/login</code>，一会我们自定义的登录逻辑就写在这个里边，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            req.login(username, password);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用 HttpServletRequest#login 方法，传入用户名和密码完成登录操作。</p><p>最后我们再提供一个测试接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello security!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>just this！</p><p>启动项目，我们首先访问 <code>/hello</code> 接口，会访问失败，接下来我们访问 <code>/login</code> 接口执行登录操作，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210918194657.png" alt></p><p>登录成功之后，再去访问 <code>/hello</code> 接口，此时就可以访问成功了。</p><p>是不是很 Easy？登录成功后，以后的授权等操作都还是原来的写法不变。</p><h3 id="1-2-原理分析"><a href="#1-2-原理分析" class="headerlink" title="1.2 原理分析"></a>1.2 原理分析</h3><p>上面这种登录方式的原理其实松哥一开始就介绍过了，如果大家还不熟悉，可以看看这两个视频就懂了：</p><ul><li><a href="https://mp.weixin.qq.com/s/x3Xm8sNe8NR0evhiBwCWWw" target="_blank" rel="noopener">没见过的奇葩登录</a></li><li><a href="https://mp.weixin.qq.com/s/0gLhR52BMkb4yTaC0B3_kg" target="_blank" rel="noopener">SpringSecurity登录数据获取最后一讲</a></li></ul><p>这里我也是稍微说两句。</p><p>我们在 LoginController#login 方法中所获取到的 HttpServletRequest 实例其实是 HttpServlet3RequestFactory 中的一个内部类 Servlet3SecurityContextHolderAwareRequestWrapper 的对象，在这个类中，重写了 HttpServletRequest 的 login 以及 authenticate 等方法，我们先来看看 login 方法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (isAuthenticated()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(<span class="hljs-string">"Cannot perform login for '"</span> + username + <span class="hljs-string">"' already authenticated as '"</span></span><br><span class="line">+ getRemoteUser() + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">AuthenticationManager authManager = HttpServlet3RequestFactory.<span class="hljs-keyword">this</span>.authenticationManager;</span><br><span class="line"><span class="hljs-keyword">if</span> (authManager == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">HttpServlet3RequestFactory.<span class="hljs-keyword">this</span>.logger.debug(</span><br><span class="line"><span class="hljs-string">"authenticationManager is null, so allowing original HttpServletRequest to handle login"</span>);</span><br><span class="line"><span class="hljs-keyword">super</span>.login(username, password);</span><br><span class="line"><span class="hljs-keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Authentication authentication = getAuthentication(authManager, username, password);</span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>如果用户已经认证了，就抛出异常。</li><li>获取到一个 AuthenticationManager 对象。</li><li>调用 getAuthentication 方法完成登录，在该方法中，会根据用户名密码构建 UsernamePasswordAuthenticationToken 对象，然后调用 Authentication#authenticate 方法完成登录，具体代码如下：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Authentication <span class="hljs-title">getAuthentication</span><span class="hljs-params">(AuthenticationManager authManager, String username, String password)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> authManager.authenticate(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">SecurityContextHolder.clearContext();</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ServletException(ex.getMessage(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该方法返回的是一个认证后的 Authentication 对象。</p></blockquote><ol start="4"><li>最后，将认证后的 Authentication 对象存入 SecurityContextHolder 中，这里的具体逻辑我就不啰嗦了，我在公众号【江南一点雨】之前的视频中已经讲过多次了。</li></ol><p>这就是 login 方法的执行逻辑。</p><p>Servlet3SecurityContextHolderAwareRequestWrapper 类也重写了 HttpServletRequest#authenticate 方法，这个也是做认证的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">authenticate</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">AuthenticationEntryPoint entryPoint = HttpServlet3RequestFactory.<span class="hljs-keyword">this</span>.authenticationEntryPoint;</span><br><span class="line"><span class="hljs-keyword">if</span> (entryPoint == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">HttpServlet3RequestFactory.<span class="hljs-keyword">this</span>.logger.debug(</span><br><span class="line"><span class="hljs-string">"authenticationEntryPoint is null, so allowing original HttpServletRequest to handle authenticate"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticate(response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (isAuthenticated()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">entryPoint.commence(<span class="hljs-keyword">this</span>, response,</span><br><span class="line"><span class="hljs-keyword">new</span> AuthenticationCredentialsNotFoundException(<span class="hljs-string">"User is not Authenticated"</span>));</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个方法用来判断用户是否已经完成认证操作，返回 true 表示用户已经完成认证，返回 false 表示用户尚未完成认证工作。</p><h2 id="2-源码的力量"><a href="#2-源码的力量" class="headerlink" title="2. 源码的力量"></a>2. 源码的力量</h2><p>看了上面的原理分析，大家应该也明白了第二种方案了，就是不使用 HttpServletRequest#login 方法，我们直接调用 AuthenticationManager 进行登录验证。</p><p>一起来看下。</p><p>首先我们修改配置类如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="hljs-string">"/login"</span>,<span class="hljs-string">"/login2"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        InMemoryUserDetailsManager manager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();</span><br><span class="line">        manager.createUser(User.withUsername(<span class="hljs-string">"javaboy"</span>).password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>).build());</span><br><span class="line">        provider.setUserDetailsService(manager);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProviderManager(provider);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先在登录放行中，添加 <code>/login2</code> 接口，这是我即将自定义的第二个登录接口。</li><li>提供一个 AuthenticationManager 实例，关于 AuthenticationManager 的玩法松哥在之前的 Spring Security 系列中已经多次分享过，这里就不再赘述（没看过的小伙伴公众号后台回复 <code>ss</code>）。创建 AuthenticationManager 实例时，还需要提供一个 DaoAuthenticationProvider，大家知道，用户密码的校验工作在这个类里边完成，并为 DaoAuthenticationProvider 配置一个 UserDetailsService 实例，该实体提供了用户数据源。</li></ol><p>接下来提供一个登录接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login2"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login2</span><span class="hljs-params">(String username, String password, HttpServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Authentication token = authenticationManager.authenticate(<span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password));</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(token);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在登录接口中，传入用户名密码等参数，然后将用户名密码等参数封装成一个 UsernamePasswordAuthenticationToken 对象，最后调用 AuthenticationManager#authenticate 方法进行验证，验证成功后会返回一个认证后的 Authentication 对象，再手动把该 Authentication 对象存入 SecurityContextHolder 中。</p><p>配置完成后，重启项目，进行登录测试即可。</p><p>第二种方案和第一种方案异曲同工，第二种实际上就是把第一种的底层拉出来自己重新实现，<strong>仅此而已</strong>。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>好啦，今天就和大家介绍了两种 Spring Security DIY 登录的方案，这些方案可能工作中并不常用，但是对于大家理解 Spring Security 原理还是大有裨益的，感兴趣的小伙伴可以敲一下试试哦～</p><p>另外，如果你感觉阅读本文吃力，不妨在公众号后台回复 <code>ss</code>，看看 Spring Security 系列的其他文章，这有助于理解本文，当然也可以看看松哥的新书：</p><p>《深入浅出Spring Security》一书已由清华大学出版社正式出版发行，感兴趣的小伙伴戳这里<a href="https://mp.weixin.qq.com/s/i4qsE1atlKMEcLV22qYjVw" target="_blank" rel="noopener">-&gt;-&gt;&gt;深入浅出Spring Security</a>，一本书学会 Spring Security。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;一般情况下，我们在使用 Spring Security 的时候，用的是 Spring Security 自带的登录方案，配置一下登录接口，配置一下登录参数，再配置一下登录回调就能用了，这种用法可以算是最佳实践了！&lt;/p&gt;
&lt;p&gt;但是！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 中的消息会过期吗？</title>
    <link href="http://www.javaboy.org/2021/0921/rabbitmq_msg_expire.html"/>
    <id>http://www.javaboy.org/2021/0921/rabbitmq_msg_expire.html</id>
    <published>2021-09-21T13:38:34.000Z</published>
    <updated>2021-10-20T14:12:17.396Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>RabbitMQ 中的消息长期未被消费会过期吗？用过 RabbitMQ 的小伙伴可能都有这样的疑问，今天松哥就来和大家捋一捋这个问题。</p><a id="more"></a><h2 id="1-默认情况"><a href="#1-默认情况" class="headerlink" title="1. 默认情况"></a>1. 默认情况</h2><p>首先我们来看看默认情况。</p><p>默认情况下，消息是不会过期的，也就是我们平日里在消息发送时，如果不设置任何消息过期的相关参数，那么消息是不会过期的，即使消息没被消费掉，也会一直存储在队列中。</p><p>这种情况具体代码就不用我再演示了吧，松哥之前的文章凡是涉及到 RabbitMQ 的，基本上都是这样的。</p><h2 id="2-TTL"><a href="#2-TTL" class="headerlink" title="2. TTL"></a>2. TTL</h2><p>TTL（Time-To-Live），消息存活的时间，即消息的有效期。如果我们希望消息能够有一个存活时间，那么我们可以通过设置 TTL 来实现这一需求。如果消息的存活时间超过了 TTL 并且还没有被消息，此时消息就会变成<code>死信</code>，关于<code>死信</code>以及<code>死信队列</code>，松哥后面再和大家介绍。</p><p>TTL 的设置有两种不同的方式：</p><ol><li>在声明队列的时候，我们可以在队列属性中设置消息的有效期，这样所有进入该队列的消息都会有一个相同的有效期。</li><li>在发送消息的时候设置消息的有效期，这样不同的消息就具有不同的有效期。</li></ol><p>那如果两个都设置了呢？</p><p><strong>以时间短的为准。</strong></p><p>当我们设置了消息有效期后，消息过期了就会被从队列中删除了（进入到死信队列，后文一样，不再标注），但是两种方式对应的删除时机有一些差异：</p><ol><li>对于第一种方式，当消息队列设置过期时间的时候，那么消息过期了就会被删除，因为消息进入 RabbitMQ 后是存在一个消息队列中，队列的头部是最早要过期的消息，所以 RabbitMQ 只需要一个定时任务，从头部开始扫描是否有过期消息，有的话就直接删除。</li><li>对于第二种方式，当消息过期后并不会立马被删除，而是当消息要投递给消费者的时候才会去删除，因为第二种方式，每条消息的过期时间都不一样，想要知道哪条消息过期，必须要遍历队列中的所有消息才能实现，当消息比较多时这样就比较耗费性能，因此对于第二种方式，当消息要投递给消费者的时候才去删除。</li></ol><p>介绍完 TTL 之后，接下来我们来看看具体用法。</p><p><strong>接下来所有代码松哥都以 Spring Boot 中封装的 AMPQ 为例来讲解。</strong></p><h3 id="2-1-单条消息过期"><a href="#2-1-单条消息过期" class="headerlink" title="2.1 单条消息过期"></a>2.1 单条消息过期</h3><p>我们先来看单条消息的过期时间。</p><p>首先创建一个 Spring Boot 项目，引入 Web 和 RabbitMQ 依赖，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210919182844.png" alt></p><p>然后在 application.properties 中配置一下 RabbitMQ 的连接信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host=127.0.0.1</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.virtual-host=/</span><br></pre></td></tr></table></figure><p>接下来稍微配置一下消息队列：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_QUEUE_DEMO = <span class="hljs-string">"javaboy_queue_demo"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_EXCHANGE_DEMO = <span class="hljs-string">"javaboy_exchange_demo"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HELLO_ROUTING_KEY = <span class="hljs-string">"hello_routing_key"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(JAVABOY_QUEUE_DEMO, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(JAVABOY_EXCHANGE_DEMO, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue())</span><br><span class="line">                .to(directExchange())</span><br><span class="line">                .with(HELLO_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类主要干了三件事：配置消息队列、配置交换机以及将两者绑定在一起。</p><ol><li>首先配置一个消息队列，new 一个 Queue：第一个参数是消息队列的名字；第二个参数表示消息是否持久化；第三个参数表示消息队列是否排他，一般我们都是设置为 false，即不排他；第四个参数表示如果该队列没有任何订阅的消费者的话，该队列会被自动删除，一般适用于临时队列。</li><li>配置一个 DirectExchange 交换机。</li><li>将交换机和队列绑定到一起。</li></ol><p>这段配置应该很简单，没啥好解释的，有一个排他性，松哥这里稍微多说两句：</p><blockquote><p>关于排他性，如果设置为 true，则该消息队列只有创建它的 Connection 才能访问，其他的 Connection 都不能访问该消息队列，如果试图在不同的连接中重新声明或者访问排他性队列，那么系统会报一个资源被锁定的错误。另一方面，对于排他性队列而言，当连接断掉的时候，该消息队列也会自动删除（无论该队列是否被声明为持久性队列都会被删除）。</p></blockquote><p>接下来提供一个消息发送接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Message message = MessageBuilder.withBody(<span class="hljs-string">"hello javaboy"</span>.getBytes())</span><br><span class="line">                .setExpiration(<span class="hljs-string">"10000"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(QueueConfig.JAVABOY_QUEUE_DEMO, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建 Message 对象的时候我们可以设置消息的过期时间，这里设置消息的过期时间为 10 秒。</p><p>这就可以啦！</p><p>接下来我们启动项目，进行消息发送测试。当消息发送成功之后，由于没有消费者，所以这条消息并不会被消费。打开 RabbitMQ 管理页面，点击到 Queues 选项卡，10s 之后，我们会发现消息已经不见了：</p><p><img src="http://img.itboyhub.com/2021/07/20210919220427.png" alt></p><p>很简单吧！</p><p>单条消息设置过期时间，就是在消息发送的时候设置一下消息有效期即可。</p><h3 id="2-2-队列消息过期"><a href="#2-2-队列消息过期" class="headerlink" title="2.2 队列消息过期"></a>2.2 队列消息过期</h3><p>给队列设置消息过期时间，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    args.put(<span class="hljs-string">"x-message-ttl"</span>, <span class="hljs-number">10000</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(JAVABOY_QUEUE_DEMO, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置完成后，我们修改消息的发送逻辑，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        Message message = MessageBuilder.withBody(<span class="hljs-string">"hello javaboy"</span>.getBytes())</span><br><span class="line">                .build();</span><br><span class="line">        rabbitTemplate.convertAndSend(QueueConfig.JAVABOY_QUEUE_DEMO, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，消息正常发送即可，不用设置消息过期时间。</p><p>OK，启动项目，发送一条消息进行测试。查看 RabbitMQ 管理页面，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210919225204.png" alt></p><p>可以看到，消息队列的 Features 属性为 D 和 TTL，D 表示消息队列中消息持久化，TTL 则表示消息会过期。</p><p>10s 之后刷新页面，发现消息数量已经恢复为 0。</p><p>这就是给消息队列设置消息过期时间，一旦设置了，所有进入到该队列的消息都有一个过期时间了。</p><h3 id="2-3-特殊情况"><a href="#2-3-特殊情况" class="headerlink" title="2.3 特殊情况"></a>2.3 特殊情况</h3><p>还有一种特殊情况，就是将消息的过期时间 TTL 设置为 0，这表示如果消息不能立马消费则会被立即丢掉，这个特性可以部分替代 RabbitMQ3.0 以前支持的 immediate 参数，之所以所部分代替，是因为 immediate 参数在投递失败会有 basic.return 方法将消息体返回（这个功能可以利用死信队列来实现）。</p><p>具体代码松哥就不演示了，这个应该比较容易。</p><h2 id="3-死信队列"><a href="#3-死信队列" class="headerlink" title="3. 死信队列"></a>3. 死信队列</h2><p>有小伙伴不禁要问，被删除的消息去哪了？真的被删除了吗？非也非也！这就涉及到死信队列了，接下来我们来看看死信队列。</p><h3 id="3-1-死信交换机"><a href="#3-1-死信交换机" class="headerlink" title="3.1 死信交换机"></a>3.1 死信交换机</h3><p>死信交换机，Dead-Letter-Exchange 即 DLX。</p><p>死信交换机用来接收死信消息（Dead Message）的，那什么是死信消息呢？一般消息变成死信消息有如下几种情况：</p><ul><li>消息被拒绝(Basic.Reject/Basic.Nack) ，井且设置requeue 参数为false</li><li>消息过期</li><li>队列达到最大长度</li></ul><p>当消息在一个队列中变成了死信消息后，此时就会被发送到 DLX，绑定 DLX 的消息队列则称为死信队列。</p><p>DLX 本质上也是一个普普通通的交换机，我们可以为任意队列指定 DLX，当该队列中存在死信时，RabbitMQ 就会自动的将这个死信发布到 DLX 上去，进而被路由到另一个绑定了 DLX 的队列上（即死信队列）。</p><h3 id="3-2-死信队列"><a href="#3-2-死信队列" class="headerlink" title="3.2 死信队列"></a>3.2 死信队列</h3><p>这个好理解，绑定了死信交换机的队列就是死信队列。</p><h3 id="3-3-实践"><a href="#3-3-实践" class="headerlink" title="3.3 实践"></a>3.3 实践</h3><p>我们来看一个简单的例子。</p><p>首先我们来创建一个死信交换机，接着创建一个死信队列，再将死信交换机和死信队列绑定到一起：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_EXCHANGE_NAME = <span class="hljs-string">"dlx_exchange_name"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_QUEUE_NAME = <span class="hljs-string">"dlx_queue_name"</span>;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DLX_ROUTING_KEY = <span class="hljs-string">"dlx_routing_key"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 配置死信交换机</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">DirectExchange <span class="hljs-title">dlxDirectExchange</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(DLX_EXCHANGE_NAME, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 配置死信队列</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Queue <span class="hljs-title">dlxQueue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(DLX_QUEUE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 绑定死信队列和死信交换机</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Binding <span class="hljs-title">dlxBinding</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> BindingBuilder.bind(dlxQueue())</span><br><span class="line">            .to(dlxDirectExchange())</span><br><span class="line">            .with(DLX_ROUTING_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实跟普通的交换机，普通的消息队列没啥两样。</p><p>接下来为消息队列配置死信交换机，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="hljs-comment">//设置消息过期时间</span></span><br><span class="line">    args.put(<span class="hljs-string">"x-message-ttl"</span>, <span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-comment">//设置死信交换机</span></span><br><span class="line">    args.put(<span class="hljs-string">"x-dead-letter-exchange"</span>, DLX_EXCHANGE_NAME);</span><br><span class="line">    <span class="hljs-comment">//设置死信 routing_key</span></span><br><span class="line">    args.put(<span class="hljs-string">"x-dead-letter-routing-key"</span>, DLX_ROUTING_KEY);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(JAVABOY_QUEUE_DEMO, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就两个参数：</p><ul><li>x-dead-letter-exchange：配置死信交换机。</li><li>x-dead-letter-routing-key：配置死信 <code>routing_key</code>。</li></ul><p>这就配置好了。</p><p>将来发送到这个消息队列上的消息，如果发生了 nack、reject 或者过期等问题，就会被发送到 DLX 上，进而进入到与 DLX 绑定的消息队列上。</p><p>死信消息队列的消费和普通消息队列的消费并无二致：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = QueueConfig.DLX_QUEUE_NAME)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dlxHandle</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"dlx msg = "</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易吧～</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，今天就和小伙伴们聊一聊 RabbitMQ 中的消息过期问题，感兴趣的小伙伴可以去试试哦～</p><p>公众号江南一点雨后台回复本文标题，可以获取本文案例下载链接。</p><p>参考资料：</p><ul><li>blog.csdn.net/u012988901/article/details/88958654</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;RabbitMQ 中的消息长期未被消费会过期吗？用过 RabbitMQ 的小伙伴可能都有这样的疑问，今天松哥就来和大家捋一捋这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
      <category term="消息过期" scheme="http://www.javaboy.org/tags/%E6%B6%88%E6%81%AF%E8%BF%87%E6%9C%9F/"/>
    
      <category term="死信队列" scheme="http://www.javaboy.org/tags/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Spring 定时任务玩出花！</title>
    <link href="http://www.javaboy.org/2021/0916/spring_scheduling_system.html"/>
    <id>http://www.javaboy.org/2021/0916/spring_scheduling_system.html</id>
    <published>2021-09-16T13:38:18.000Z</published>
    <updated>2021-10-20T14:12:59.697Z</updated>
    
    <content type="html"><![CDATA[<p>今天抽空撸一篇文章，和大家聊一聊上篇文章的可视化定时任务是怎么实现的。</p><p>上篇文章发了后，有不少小伙伴在评论区提出了一些问题，我觉得还挺有意思的，这篇文章应该能解决掉大家的大部分疑惑。</p><a id="more"></a><p>好啦，就不废话了，我们来看看具体实现方案。</p><p>对了，如果还没看过上篇文章的小伙伴可以先看看，不然可能不知道我在说啥，传送门：</p><ul><li><a href="https://mp.weixin.qq.com/s/H3RrpnBYDNwgtSOMlt3Ihg" target="_blank" rel="noopener">刚出炉热腾腾的定时任务可视化管理系统</a></li></ul><hr><h2 id="1-项目概览"><a href="#1-项目概览" class="headerlink" title="1. 项目概览"></a>1. 项目概览</h2><p>我们首先来大概看下这个项目：</p><p><img src="http://img.itboyhub.com/2021/07/20210912220951.png" alt></p><p>这里和定时任务相关的配置主要在 config 包里边，其他的都是业务类代码，换句话说其他的都是常规的 CURD，所以我这里主要和小伙伴们介绍 config 中的代码。</p><h2 id="2-整体思路"><a href="#2-整体思路" class="headerlink" title="2. 整体思路"></a>2. 整体思路</h2><p>我先来说说这个项目的整体思路，这样方便大家理解下面的内容。</p><p>在这个项目中，每一个定时任务都由一个线程去处理，负责处理每一个定时任务的线程类是 SchedulingRunnable，所有的线程都跑在一个线程池中，这个线程池是 ThreadPoolTaskScheduler，这是一个专为定时任务设计的线程池（支持 Cron 表达式），它的底层其实就是大家所熟知的 ScheduledThreadPoolExecutor。当有一个新的定时任务需要执行时，创建一个 SchedulingRunnable 线程，然后连同 Cron 表达式一起扔到 ThreadPoolTaskScheduler 池子里去执行就行了。</p><h2 id="3-配置分析"><a href="#3-配置分析" class="headerlink" title="3. 配置分析"></a>3. 配置分析</h2><p>几个配置类我们逐一来分析。</p><h3 id="3-1-SpringContextUtils"><a href="#3-1-SpringContextUtils" class="headerlink" title="3.1 SpringContextUtils"></a>3.1 SpringContextUtils</h3><p>首先我们提供了一个 SpringContextUtils 工具类，这个工具类实现了 ApplicationContextAware 接口，通过这个工具类，我们可以从 Spring 容器中查询一个 Bean 或者判断 Spring 容器中是否存在某一个 Bean，工具类的代码如下（我主要列出来了有哪些方法，具体实现大家可以参考：<a href="https://github.com/lenve/scheduling" target="_blank" rel="noopener">https://github.com/lenve/scheduling</a>）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringContextUtils</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span></span></span><br><span class="line"><span class="hljs-function">            <span class="hljs-keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        SpringContextUtils.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class&lt;? extends Object&gt; getType(String name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-SchedulingRunnable"><a href="#3-2-SchedulingRunnable" class="headerlink" title="3.2 SchedulingRunnable"></a>3.2 SchedulingRunnable</h3><p>将来每一个定时任务执行的时候，我们都开启一个新的线程去执行这个定时任务，SchedulingRunnable 就是关于这个线程的配置，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchedulingRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(SchedulingRunnable.class);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> String params;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Object targetBean;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SchedulingRunnable</span><span class="hljs-params">(String beanName, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>(beanName, methodName, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SchedulingRunnable</span><span class="hljs-params">(String beanName, String methodName, String params)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.beanName = beanName;</span><br><span class="line">        <span class="hljs-keyword">this</span>.methodName = methodName;</span><br><span class="line">        <span class="hljs-keyword">this</span>.params = params;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            targetBean = SpringContextUtils.getBean(beanName);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (StringUtils.hasText(params)) &#123;</span><br><span class="line">                method = targetBean.getClass().getDeclaredMethod(methodName, String.class);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                method = targetBean.getClass().getDeclaredMethod(methodName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="hljs-string">"定时任务开始执行 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;"</span>, beanName, methodName, params);</span><br><span class="line">        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (StringUtils.hasText(params)) &#123;</span><br><span class="line">                method.invoke(targetBean, params);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                method.invoke(targetBean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            logger.error(String.format(<span class="hljs-string">"定时任务执行异常 - bean：%s，方法：%s，参数：%s "</span>, beanName, methodName, params), ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">long</span> times = System.currentTimeMillis() - startTime;</span><br><span class="line">        logger.info(<span class="hljs-string">"定时任务执行结束 - bean：&#123;&#125;，方法：&#123;&#125;，参数：&#123;&#125;，耗时：&#123;&#125; 毫秒"</span>, beanName, methodName, params, times);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        SchedulingRunnable that = (SchedulingRunnable) o;</span><br><span class="line">        <span class="hljs-keyword">if</span> (params == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> beanName.equals(that.beanName) &amp;&amp;</span><br><span class="line">                    methodName.equals(that.methodName) &amp;&amp;</span><br><span class="line">                    that.params == <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> beanName.equals(that.beanName) &amp;&amp;</span><br><span class="line">                methodName.equals(that.methodName) &amp;&amp;</span><br><span class="line">                params.equals(that.params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (params == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> Objects.hash(beanName, methodName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> Objects.hash(beanName, methodName, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SchedulingRunnable 实现了 Runnable 接口，这里的实现逻辑也比较简单，我们一起来看下：</p><ol><li>首先声明了 beanName、methodName 以及 params 分别作为定时任务执行的 Bean 的 bean 名称、方法名称以及方法参数。不知道小伙伴们是否记得我们<a href="https://mp.weixin.qq.com/s/H3RrpnBYDNwgtSOMlt3Ihg" target="_blank" rel="noopener">上篇文章</a>中介绍的该系统的用法，在添加一个定时任务时，我们需要传入相应的 beanName、methodName 以及 params 参数，传入后就来到这里了。另外还有 targetBean 和 method 分别表示 beanName 对应的对象以及 methodName 对应的对象，其中 targetBean 通过 beanName 从 Spring 容器中查找，method 则通过 methodName 从 targetBean 中查找。</li><li>在 run 方法中，通过反射去调用 method 方法，这也是定时任务执行时候的具体逻辑。</li><li>另外，这里重写了 equals 和 hashCode 方法，这两个方法主要是比较了 beanName、methodName 以及 params 三个属性，换言之，如果这三个属性相同，则认为这是同一个对象（这三个属性相同表示这是同一个定时任务）。</li></ol><h3 id="3-3-SchedulingConfig"><a href="#3-3-SchedulingConfig" class="headerlink" title="3.3 SchedulingConfig"></a>3.3 SchedulingConfig</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchedulingConfig</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskScheduler <span class="hljs-title">taskScheduler</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskScheduler taskScheduler = <span class="hljs-keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">        taskScheduler.setPoolSize(<span class="hljs-number">4</span>);</span><br><span class="line">        taskScheduler.setRemoveOnCancelPolicy(<span class="hljs-keyword">true</span>);</span><br><span class="line">        taskScheduler.setThreadNamePrefix(<span class="hljs-string">"TaskSchedulerThreadPool-"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是配置一下 ThreadPoolTaskScheduler，这个可以很方便的对重复执行的任务进行调度管理，相比于通过 Java 自带的周期性任务线程池ScheduleThreadPoolExecutor，ThreadPoolTaskScheduler 对象支持根据 Cron 表达式创建周期性任务。</p><p>既然是线程池，必然就有线程数量等问题，它的核心线程池大小就是我们配置的 poolSize 属性，最大线程池大小是 <code>Integer.MAX_VALUE</code>，<code>keepAliveTime</code> 为 0 ,这里用到的队列是 <code>DelayedWorkQueue</code> ，这个队列有一个属性 <code>private final DelayQueue&lt;RunnableScheduledFuture&gt; dq = new DelayQueue&lt;RunnableScheduledFuture&gt;();</code> 对这个队列的操作实际是是对这个 DelayQueue 的操作，这个队列大小是 Integer.MAX_VALUE，所以线程数量肯定是够用了。</p><p>其他配置就没啥好说的。</p><h3 id="3-4-ScheduledTask"><a href="#3-4-ScheduledTask" class="headerlink" title="3.4 ScheduledTask"></a>3.4 ScheduledTask</h3><p>ScheduledTask 是 ScheduledFuture 的包装类，这个包装类中主要多了一个 future 属性，这个 future 属性表示 TaskScheduler 定时任务线程池的执行结果：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledTask</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">volatile</span> ScheduledFuture&lt;?&gt; future;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        ScheduledFuture&lt;?&gt; future = <span class="hljs-keyword">this</span>.future;</span><br><span class="line">        <span class="hljs-keyword">if</span> (future != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            future.cancel(<span class="hljs-keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-CronTaskRegistrar"><a href="#3-5-CronTaskRegistrar" class="headerlink" title="3.5 CronTaskRegistrar"></a>3.5 CronTaskRegistrar</h3><p>核心的方法都在这个里边。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CronTaskRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Runnable, ScheduledTask&gt; scheduledTasks = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-keyword">private</span> TaskScheduler taskScheduler;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskScheduler <span class="hljs-title">getScheduler</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCronTask</span><span class="hljs-params">(Runnable task, String cronExpression)</span> </span>&#123;</span><br><span class="line">        addCronTask(<span class="hljs-keyword">new</span> CronTask(task, cronExpression));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCronTask</span><span class="hljs-params">(CronTask cronTask)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (cronTask != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            Runnable task = cronTask.getRunnable();</span><br><span class="line">            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scheduledTasks.containsKey(task)) &#123;</span><br><span class="line">                removeCronTask(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">this</span>.scheduledTasks.put(task, scheduleCronTask(cronTask));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeCronTask</span><span class="hljs-params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        ScheduledTask scheduledTask = <span class="hljs-keyword">this</span>.scheduledTasks.remove(task);</span><br><span class="line">        <span class="hljs-keyword">if</span> (scheduledTask != <span class="hljs-keyword">null</span>)</span><br><span class="line">            scheduledTask.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> ScheduledTask <span class="hljs-title">scheduleCronTask</span><span class="hljs-params">(CronTask cronTask)</span> </span>&#123;</span><br><span class="line">        ScheduledTask scheduledTask = <span class="hljs-keyword">new</span> ScheduledTask();</span><br><span class="line">        scheduledTask.future = <span class="hljs-keyword">this</span>.taskScheduler.schedule(cronTask.getRunnable(), cronTask.getTrigger());</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> scheduledTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (ScheduledTask task : <span class="hljs-keyword">this</span>.scheduledTasks.values()) &#123;</span><br><span class="line">            task.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.scheduledTasks.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微说下这个类：</p><ol><li>首先这个类实现了 DisposableBean 接口，实现这个接口就重写了 destroy 方法，以便在 Bean 销毁的时候，清除所有的定时任务。</li><li>addCronTask(Runnable, String) 方法用来添加一个定时任务，传两个参数，第一个是 Runnable，也就是我们前面所说的定时任务，第二个则是一个 Cron 表达式。</li><li>addCronTask(CronTask) 方法也用来添加定时任务，添加之前先判断这个定时任务是否已经存在，如果已经存在，就先移除。然后将定时任务存入 scheduledTasks 中，存储的时候，key 就是那个 Runnable 对象，value 则是一个 ScheduledTask 对象。</li><li>ScheduledTask 对象从 scheduleCronTask 方法中获取，<strong>这也是整个系统最最核心的一段代码</strong>，调用 taskScheduler 对象把定时任务添加进去。</li><li>removeCronTask 方法用来移除一个定时任务，移除分为两部分：1. 从 scheduledTasks 集合中找到定时任务并移除；2. 取消定时任务的执行。</li><li>最后的 destroy 方法就是一个常规方法，该移除移除，该清空清空。</li></ol><h3 id="3-6-InitTask"><a href="#3-6-InitTask" class="headerlink" title="3.6 InitTask"></a>3.6 InitTask</h3><p>这是一个处理数据库中已有定时任务的类。当系统启动时，首先从数据库中读取需要定时执行的任务，然后挨个加入定时任务执行器中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    CronTaskRegistrar cronTaskRegistrar;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    SysJobService sysJobService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;SysJob&gt; list = sysJobService.getJobsByStatus(<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span> (SysJob sysJob : list) &#123;</span><br><span class="line">            cronTaskRegistrar.addCronTask(<span class="hljs-keyword">new</span> SchedulingRunnable(sysJob.getBeanName(), sysJob.getMethodName(), sysJob.getMethodParams()), sysJob.getCronExpression());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查询所有状态为 1 的定时任务。</li><li>遍历第一步查询出来的集合，添加定时任务。</li></ol><p>好啦，这就是整个项目最最核心的配置了，其他的代码都是一些业务层面的代码，乏善可陈，我就不啰嗦啦。</p><h2 id="4-定时任务怎么配"><a href="#4-定时任务怎么配" class="headerlink" title="4. 定时任务怎么配"></a>4. 定时任务怎么配</h2><p>有的小伙伴可能还不知道定时任务怎么配置，我这里稍微说两句。</p><p>项目中提供了如下一个测试类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span>(<span class="hljs-string">"schedulingTaskDemo"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchedulingTaskDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">taskWithParams</span><span class="hljs-params">(String params)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"执行有参示例任务："</span> + params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">taskNoParams</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"执行无参示例任务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是提前写好的，需要的时候我们配置的定时任务就是这里相关的参数，如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20210913221607.png" alt></p><p>Bean 名称、方法名称都和测试案例中的 Bean 一一对应。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>好啦，是不是很 Easy？小伙伴们赶紧去尝试下吧！</p><p>项目地址：</p><ul><li>GitHub：<a href="https://github.com/lenve/scheduling" target="_blank" rel="noopener">https://github.com/lenve/scheduling</a></li><li>Gitee：<a href="https://gitee.com/lenve/scheduling" target="_blank" rel="noopener">https://gitee.com/lenve/scheduling</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天抽空撸一篇文章，和大家聊一聊上篇文章的可视化定时任务是怎么实现的。&lt;/p&gt;
&lt;p&gt;上篇文章发了后，有不少小伙伴在评论区提出了一些问题，我觉得还挺有意思的，这篇文章应该能解决掉大家的大部分疑惑。&lt;/p&gt;
    
    </summary>
    
      <category term="定时任务" scheme="http://www.javaboy.org/categories/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="定时任务" scheme="http://www.javaboy.org/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>刚出炉热腾腾的定时任务可视化管理系统</title>
    <link href="http://www.javaboy.org/2021/0913/scheduling_system.html"/>
    <id>http://www.javaboy.org/2021/0913/scheduling_system.html</id>
    <published>2021-09-13T13:37:59.000Z</published>
    <updated>2021-10-20T14:12:53.539Z</updated>
    
    <content type="html"><![CDATA[<p>定时任务也算是我们日常开发中比较常见的需求了，市面上也有很多成熟的框架：</p><a id="more"></a><ul><li>quartz</li><li>elastic-job</li><li>xxl-job</li><li>…</li></ul><p>不过小伙伴们知道，其实我们 Spring 框架中也提供了相应的定时任务，这个定时任务通过 <code>@EnableScheduling</code> 注解开启，松哥之前也写过文章和大家分享这个注解的基本用法：</p><ul><li><a href="https://mp.weixin.qq.com/s/_20RYBkjKrB4tdpXI3hBOA" target="_blank" rel="noopener">Spring Boot 中实现定时任务的两种方式!</a></li></ul><p>不过之前的定时任务都是固定的，提前写死的，没法动态配置，前两天有小伙伴问松哥如何实现定时任务的动态配置？</p><p>这个东西要是基于 xxl-job 之类的框架来做其实是比较容易的，不过用 Spring 自带的 <code>@EnableScheduling</code> 注解其实也能实现，而且并不难，松哥基于此火急火燎的写了一个，今天先和大家聊聊大致用法，后面抽空再写一篇文章介绍实现原理。</p><p>项目已开源，项目地址：</p><ul><li><a href="https://github.com/lenve/scheduling" target="_blank" rel="noopener">https://github.com/lenve/scheduling</a></li></ul><h2 id="食用方式"><a href="#食用方式" class="headerlink" title="食用方式"></a>食用方式</h2><ol><li>克隆项目：<code>git clone https://github.com/lenve/scheduling.git</code>。</li><li>本地数据库创建一个名为 <code>scheduling</code> 的库。</li><li>修改配置文件 <code>src/main/resources/application.yaml</code>，主要修改数据库连接的用户名和地址。</li><li>启动项目。</li><li>浏览器访问 <code>http://localhost:8080</code>，可以看到如下页面：</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210910174209.png" alt></p><p>表示启动成功。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ol><li>项目启动时，会自动从数据库中加载状态为 1 的定时任务并开始执行，1 表示处于开启状态的定时任务，0 表示处于禁用状态的定时任务。</li><li>点击页面上的<strong>添加作业</strong>按钮，可以添加一个新的定时任务，新任务的 Bean 名称、方法名称以及方法参数如果和已有的记录相同，则认为是重复作业，重复作业会添加失败。</li></ol><p>添加作业的页面如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210910181820.png" alt></p><p>这里涉及到几个参数，含义如下：</p><ul><li>Bean 名称：这是项目中注入 Spring 的 Bean 名称，测试代码中以 <code>org/javaboy/scheduling02/service/SchedulingTaskDemo.java</code> 为例。</li><li>方法名称：参数 1 中 bean 里边的方法名称。</li><li>方法参数：参数 2 中方法的参数。</li><li>Cron 表达式：定时任务的 Cron 表达式。</li><li>作业状态：开启和禁用两种。开启的话，添加完成后这个定时任务就会开始执行，禁用的话，就单纯只是将记录添加到数据库中。</li></ul><p>作业添加成功提示如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210910182636.png" alt></p><p>作业添加失败提示如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210910181458.png" alt></p><ol start="3"><li>点击作业编辑，可以修改作业的各项数据：</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210910182736.png" alt></p><p>修改后会立马生效。</p><ol start="4"><li>点击作业删除，可以删除一个现有的作业。假如删除的作业正在执行，则先停止该作业，然后删除。</li><li>点击列表中的 switch 按钮也可以切换作业的状态。</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210910183133.png" alt></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>SpringBoot</li><li>Jpa</li><li>MySQL</li><li>Spring Job</li><li>Vue</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这是一个学习的 Demo，并非完整项目，后面松哥会出一篇文章和大家分享具体的实现思路。</p><p>好啦，先说这么多。</p><p>感兴趣的小伙伴赶紧去体验一把吧：</p><ul><li><a href="https://github.com/lenve/scheduling" target="_blank" rel="noopener">https://github.com/lenve/scheduling</a></li><li><a href="https://gitee.com/lenve/scheduling" target="_blank" rel="noopener">https://gitee.com/lenve/scheduling</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定时任务也算是我们日常开发中比较常见的需求了，市面上也有很多成熟的框架：&lt;/p&gt;
    
    </summary>
    
      <category term="定时任务" scheme="http://www.javaboy.org/categories/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
    
      <category term="Vue" scheme="http://www.javaboy.org/tags/Vue/"/>
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="定时任务" scheme="http://www.javaboy.org/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 高可用之如何确保消息成功消费</title>
    <link href="http://www.javaboy.org/2021/0907/rabbitmq.html"/>
    <id>http://www.javaboy.org/2021/0907/rabbitmq.html</id>
    <published>2021-09-07T13:37:42.000Z</published>
    <updated>2021-10-20T14:11:32.870Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前面一篇文章松哥和大家聊了 MQ 高可用之如何确保消息成功发送，各种配置齐上阵，最终确保了消息的成功发送，甚至在一些极端情况下还可能发生同一条消息重复发送的情况，不管怎么样，消息总算发送出去了，如果小伙伴们还没看过上篇文章，建议先看看，再来学习本文：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/hj8iqASSOk2AgdtkuLPCCQ" target="_blank" rel="noopener">四种策略确保 RabbitMQ 消息发送可靠性！你用哪种？</a></li></ul><p>今天我们就来聊一聊消息消费的问题，看看如何确保消息消费成功，并且确保幂等性。</p><h2 id="1-两种消费思路"><a href="#1-两种消费思路" class="headerlink" title="1. 两种消费思路"></a>1. 两种消费思路</h2><p>RabbitMQ 的消息消费，整体上来说有两种不同的思路：</p><ul><li>推（push）：MQ 主动将消息<strong>推送</strong>给消费者，这种方式需要消费者设置一个缓冲区去缓存消息，对于消费者而言，内存中总是有一堆需要处理的消息，所以这种方式的效率比较高，这也是目前大多数应用采用的消费方式。</li><li>拉（pull）：消费者主动从 MQ <strong>拉取</strong>消息，这种方式效率并不是很高，不过有的时候如果服务端需要批量拉取消息，倒是可以采用这种方式。</li></ul><p>两种方式我都举个例子看下。</p><p>先来看推（push）：</p><p>这种方式大家比较常见，就是通过 <code>@RabbitListener</code> 注解去标记消费者，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@RabbitListener</span>(queues = RabbitConfig.JAVABOY_QUEUE_NAME)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"msg = "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当监听的队列中有消息时，就会触发该方法。</p><p>再来看拉（pull）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    Object o = rabbitTemplate.receiveAndConvert(RabbitConfig.JAVABOY_QUEUE_NAME);</span><br><span class="line">    System.out.println(<span class="hljs-string">"o = "</span> + <span class="hljs-keyword">new</span> String(((<span class="hljs-keyword">byte</span>[]) o),<span class="hljs-string">"UTF-8"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 receiveAndConvert 方法，方法参数为队列名称，方法执行完成后，会从 MQ 上拉取一条消息下来，如果该方法返回值为 null，表示该队列上没有消息了。receiveAndConvert 方法有一个重载方法，可以在重载方法中传入一个等待超时时间，例如 3 秒。此时，假设队列中没有消息了，则 receiveAndConvert 方法会阻塞 3 秒，3 秒内如果队列中有了新消息就返回，3 秒后如果队列中还是没有新消息，就返回 null，这个等待超时时间要是不设置的话，默认为 0。</p><p>这是消息两种不同的消费模式。</p><p>如果需要从消息队列中持续获得消息，就可以使用推模式；如果只是单纯的消费一条消息，则使用拉模式即可。<strong>切忌将拉模式放到一个死循环中，变相的订阅消息，这会严重影响 RabbitMQ 的性能。</strong></p><h2 id="2-确保消费成功两种思路"><a href="#2-确保消费成功两种思路" class="headerlink" title="2. 确保消费成功两种思路"></a>2. 确保消费成功两种思路</h2><p>在<a href="https://mp.weixin.qq.com/s/hj8iqASSOk2AgdtkuLPCCQ" target="_blank" rel="noopener">上篇文章</a>中，我们想尽办法确保消息能够发送成功，对于消息消费成功，其实官方提供了相关的机制，我们一起来看下。</p><p>为了保证消息能够可靠的到达消息消费者，RabbitMQ 中提供了消息消费确认机制。当消费者去消费消息的时候，可以通过指定 autoAck 参数来表示消息消费的确认方式。</p><ul><li>当 autoAck 为 false 的时候，此时即使消费者已经收到消息了，RabbitMQ 也不会立马将消息移除，而是等待消费者显式的回复确认信号后，才会将消息打上删除标记，然后再删除。</li><li>当 autoAck 为 true 的时候，此时消息消费者就会自动把发送出去的消息设置为确认，然后将消息移除（从内存或者磁盘中），即使这些消息并没有到达消费者。</li></ul><p>我们来看一张图：</p><p><img src="http://img.itboyhub.com/2021/07/20210902220542.png" alt></p><p>如上图所示，在 RabbitMQ 的 web 管理页面：</p><ul><li>Ready 表示待消费的消息数量。</li><li>Unacked 表示已经发送给消费者但是还没收到消费者 ack 的消息数量。</li></ul><p>这是我们可以从 UI 层面观察消息的消费情况确认情况。</p><p>当我们将 autoAck 设置为 false 的时候，对于 RabbitMQ 而言，消费分成了两个部分：</p><ul><li>待消费的消息</li><li>已经投递给消费者，但是还没有被消费者确认的消息</li></ul><p>换句话说，当设置 autoAck 为 false 的时候，消费者就变得非常从容了，它将有足够的时间去处理这条消息，当消息正常处理完成后，再手动 ack，此时 RabbitMQ 才会认为这条消息消费成功了。如果 RabbitMQ 一直没有收到客户端的反馈，并且此时客户端也已经断开连接了，那么 RabbitMQ 就会将刚刚的消息重新放回队列中，等待下一次被消费。</p><p>综上所述，确保消息被成功消费，无非就是手动 Ack 或者自动 Ack，无他。当然，无论这两种中的哪一种，最终都有可能导致消息被重复消费，所以一般来说我们还需要在处理消息时，解决幂等性问题。</p><h2 id="3-消息拒绝"><a href="#3-消息拒绝" class="headerlink" title="3. 消息拒绝"></a>3. 消息拒绝</h2><p>当客户端收到消息时，可以选择消费这条消息，也可以选择拒绝这条消息。我们来看下拒绝的方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@RabbitListener</span>(queues = RabbitConfig.JAVABOY_QUEUE_NAME)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(Channel channel, Message message)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//获取消息编号</span></span><br><span class="line">        <span class="hljs-keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//拒绝消息</span></span><br><span class="line">            channel.basicReject(deliveryTag, <span class="hljs-keyword">true</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者收到消息之后，可以选择拒绝消费该条消息，拒绝的步骤分两步：</p><ol><li>获取消息编号 deliveryTag。</li><li>调用 basicReject 方法拒绝消息。</li></ol><p>调用 basicReject 方法时，第二个参数是 requeue，即是否重新入队。如果第二个参数为 true，则这条被拒绝的消息会重新进入到消息队列中，等待下一次被消费；如果第二个参数为 false，则这条被拒绝的消息就会被丢掉，不会有新的消费者去消费它了。</p><p>需要注意的是，basicReject 方法一次只能拒绝一条消息。</p><h2 id="4-消息确认"><a href="#4-消息确认" class="headerlink" title="4. 消息确认"></a>4. 消息确认</h2><p>消息确认分为自动确认和手动确认，我们分别来看。</p><h3 id="4-1-自动确认"><a href="#4-1-自动确认" class="headerlink" title="4.1 自动确认"></a>4.1 自动确认</h3><p>先来看看自动确认，在 Spring Boot 中，默认情况下，消息消费就是自动确认的。</p><p>我们来看如下一个消息消费方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Component</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@RabbitListener</span>(queues = RabbitConfig.JAVABOY_QUEUE_NAME)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle2</span><span class="hljs-params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"msg = "</span> + msg);</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @Componet 注解将当前类注入到 Spring 容器中，然后通过 @RabbitListener 注解来标记一个消息消费方法，默认情况下，消息消费方法自带事务，即如果该方法在执行过程中抛出异常，那么被消费的消息会重新回到队列中等待下一次被消费，如果该方法正常执行完没有抛出异常，则这条消息就算是被消费了。</p><h3 id="4-2-手动确认"><a href="#4-2-手动确认" class="headerlink" title="4.2 手动确认"></a>4.2 手动确认</h3><p>手动确认我又把它分为两种：推模式手动确认与拉模式手动确认。</p><h4 id="4-2-1-推模式手动确认"><a href="#4-2-1-推模式手动确认" class="headerlink" title="4.2.1 推模式手动确认"></a>4.2.1 推模式手动确认</h4><p>要开启手动确认，需要我们首先关闭自动确认，关闭方式如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br></pre></td></tr></table></figure><p>这个配置表示将消息的确认模式改为手动确认。</p><p>接下来我们来看下消费者中的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = RabbitConfig.JAVABOY_QUEUE_NAME)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle3</span><span class="hljs-params">(Message message,Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">long</span> deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-comment">//消息消费的代码写到这里</span></span><br><span class="line">        String s = <span class="hljs-keyword">new</span> String(message.getBody());</span><br><span class="line">        System.out.println(<span class="hljs-string">"s = "</span> + s);</span><br><span class="line">        <span class="hljs-comment">//消费完成后，手动 ack</span></span><br><span class="line">        channel.basicAck(deliveryTag, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="hljs-comment">//手动 nack</span></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            channel.basicNack(deliveryTag, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将消费者要做的事情放到一个 <code>try..catch</code> 代码块中。</p><p>如果消息正常消费成功，则执行 <code>basicAck</code> 完成确认。</p><p>如果消息消费失败，则执行 <code>basicNack</code> 方法，告诉 RabbitMQ 消息消费失败。</p><p>这里涉及到两个方法：</p><ul><li>basicAck：这个是手动确认消息已经成功消费，该方法有两个参数：第一个参数表示消息的 id；第二个参数 multiple 如果为 false，表示仅确认当前消息消费成功，如果为 true，则表示当前消息之前所有未被当前消费者确认的消息都消费成功。</li><li>basicNack：这个是告诉 RabbitMQ 当前消息未被成功消费，该方法有三个参数：第一个参数表示消息的 id；第二个参数 multiple 如果为 false，表示仅拒绝当前消息的消费，如果为 true，则表示拒绝当前消息之前所有未被当前消费者确认的消息；第三个参数 requeue 含义和前面所说的一样，被拒绝的消息是否重新入队。</li></ul><p><strong>当 basicNack 中最后一个参数设置为 false 的时候，还涉及到一个死信队列的问题，这个松哥以后再专门写文章和大家细聊。</strong></p><h4 id="4-2-2-拉模式手动确认"><a href="#4-2-2-拉模式手动确认" class="headerlink" title="4.2.2 拉模式手动确认"></a>4.2.2 拉模式手动确认</h4><p>拉模式手动 ack 比较麻烦一些，在 Spring 中封装的 RabbitTemplate 中并未找到对应的方法，所以我们得用原生的办法，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = rabbitTemplate.getConnectionFactory().createConnection().createChannel(<span class="hljs-keyword">true</span>);</span><br><span class="line">    <span class="hljs-keyword">long</span> deliveryTag = <span class="hljs-number">0L</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        GetResponse getResponse = channel.basicGet(RabbitConfig.JAVABOY_QUEUE_NAME, <span class="hljs-keyword">false</span>);</span><br><span class="line">        deliveryTag = getResponse.getEnvelope().getDeliveryTag();</span><br><span class="line">        System.out.println(<span class="hljs-string">"o = "</span> + <span class="hljs-keyword">new</span> String((getResponse.getBody()), <span class="hljs-string">"UTF-8"</span>));</span><br><span class="line">        channel.basicAck(deliveryTag, <span class="hljs-keyword">false</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            channel.basicNack(deliveryTag, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到的 basicAck 和 basicNack 方法跟前面的一样，我就不再赘述。</p><h2 id="5-幂等性问题"><a href="#5-幂等性问题" class="headerlink" title="5. 幂等性问题"></a>5. 幂等性问题</h2><p>最后我们再来说说消息的幂等性问题。</p><p>大家设想下面一个场景：</p><blockquote><p>消费者在消费完一条消息后，向 RabbitMQ 发送一个 ack 确认，此时由于网络断开或者其他原因导致 RabbitMQ 并没有收到这个 ack，那么此时 RabbitMQ 并不会将该条消息删除，当重新建立起连接后，消费者还是会再次收到该条消息，这就造成了消息的重复消费。同时，由于类似的原因，消息在发送的时候，同一条消息也可能会发送两次（参见<a href="https://mp.weixin.qq.com/s/hj8iqASSOk2AgdtkuLPCCQ" target="_blank" rel="noopener">四种策略确保 RabbitMQ 消息发送可靠性！你用哪种？</a>）。种种原因导致我们在消费消息时，一定要处理好幂等性问题。</p></blockquote><p>幂等性问题的处理倒也不难，基本上都是从业务上来处理，我来大概说说思路。</p><p>采用 Redis，在消费者消费消息之前，现将消息的 id 放到 Redis 中，存储方式如下：</p><ul><li>id-0（正在执行业务）</li><li>id-1（执行业务成功）</li></ul><p>如果 ack 失败，在 RabbitMQ 将消息交给其他的消费者时，先执行 setnx，如果 key 已经存在（说明之前有人消费过该消息），获取他的值，如果是 0，当前消费者就什么都不做，如果是 1，直接 ack。</p><p>极端情况：第一个消费者在执行业务时，出现了死锁，在 setnx 的基础上，再给 key 设置一个生存时间。生产者，发送消息时，指定 messageId。</p><p>当然这只是一个简单思路供大家参考。</p><p>松哥在 vhr 项目中也处理了消息幂等性问题，感兴趣的小伙伴可以查看 vhr 源码（<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>），代码在 mailserver 中。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>好啦，今天就和小伙伴们聊了下 RabbitMQ 中和消息消费相关的几个话题，感兴趣的小伙伴可以实践下哦～</p><p>复制文章标题并在公众号后台回复，可以下载本文案例～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前面一篇文章松哥和大家聊了 MQ 高可用之如何确保消息成功发送，各种配置齐上阵，最终确保了消息的成功发送，甚至在一些极端情况下还可能发生同一条消息重复发送的情况，不管怎么样，消息总算发送出去了，如果小伙伴们还没看过上篇文章，建议先看看，再来学习本文：&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>哪种分布式事务处理方案效率最高？必然是...</title>
    <link href="http://www.javaboy.org/2021/0903/transaction_rabbitmq.html"/>
    <id>http://www.javaboy.org/2021/0903/transaction_rabbitmq.html</id>
    <published>2021-09-03T13:37:19.000Z</published>
    <updated>2021-10-20T14:12:10.911Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前面几篇文章松哥和大家介绍了 Seata 中四种分布式事务处理方案，相信经过前面的几篇文章的学习，大家对于 Seata 中的分布式事务已经非常了解了。还没看过前面文章的小伙伴，可以先看一下：</p><ul><li><a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA" target="_blank" rel="noopener">看了那么多博客，还是不懂 TCC，不妨看看这个案例！</a></li><li><a href="https://mp.weixin.qq.com/s/BJHmVkNrvNL87hBT8DM8vg" target="_blank" rel="noopener">XA 事务水很深，小伙子我怕你把握不住！</a></li><li><a href="https://mp.weixin.qq.com/s/cZabAt7JF4QrQHERHHAWjA" target="_blank" rel="noopener">你这 Saga 事务保“隔离性”吗？</a></li></ul><a id="more"></a><p>不过很多小伙伴看完后感觉 Seata 对于分布式事务的处理，代码虽然简单，但是内部花费在网络上的时间消耗太多了，在高并发场景下，这似乎并不是一种很好的解决方案。</p><p>要说哪种分布式事务处理方案效率高，必然绕不开消息中间件！基于消息中间件的两阶段提交方案，通常用在高并发场景下。这种方式通过牺牲数据的强一致性换取性能的大幅提升，不过实现这种方式的成本和复杂度是比较高的，使用时还要看实际业务情况。</p><p>今天松哥想通过一个简单的案例，来和大家聊一聊如何通过消息中间件来处理分布式事务。</p><h2 id="1-思路分析"><a href="#1-思路分析" class="headerlink" title="1. 思路分析"></a>1. 思路分析</h2><p>先来说说整体思路。</p><p>有一个名词叫做消息驱动的微服务，相信很多小伙伴都听说过。怎么理解呢？</p><p>在微服务系统中，服务之间的互相调用，我们可以使用 HTTP 的方式，例如 OpenFeign，也可以使用 RPC 的方式，例如 Dubbo，除了这些方案之外，我们也可以使用消息驱动，这是一种典型的响应式系统设计方案。</p><p>在消息驱动的微服务中，服务之间不再互相直接调用，当服务之间需要通信时，就把通信内容发送到消息中间件上，另一个服务则通过监听消息中间件中的消息队列，来完成相应的业务逻辑调用，过程就是这么个过程，并不难，具体怎么玩，我们继续往下看。</p><h2 id="2-业务分析"><a href="#2-业务分析" class="headerlink" title="2. 业务分析"></a>2. 业务分析</h2><p>折腾了半天，后来松哥在网上找到了一个别人写好的例子，我觉得用来演示这个问题特别合适，所以我就没有自己写案例了，直接用别人的代码，我们来逐个分析，跟前面讲分布式事务 Seata 的方式一致。</p><p>首先我们来看如下一张流程图，这是一个用户购票的案例：</p><p><img src="http://img.itboyhub.com/2021/07/20210829194847.png" alt></p><p>当用户想要购买一张票时：</p><ol><li>向新订单队列中写入一条数据。</li><li>Order Service 负责消费这个队列中的消息，完成订单的创建，然后再向新订单缴费队列中写入一条消息。</li><li>User Service 负责消费新订单缴费队列中的消息，在 User Service 中完成对用户账户余额的划扣，然后向新订单转移票队列中写入一条消息。</li><li>Ticket Service 负责消费新订单转移票队列，在 Ticket Service 中完成票的转移，然后发送一条消息给订单完成队列。</li><li>最后 Order Service 中负责监听订单完成队列，处理完成后的订单。</li></ol><p>这就是一个典型的<strong>消息驱动微服务</strong>，也是一个典型的<strong>响应式系统</strong>。在这个系统中，一共有三个服务，分别是：</p><ul><li>Order Service</li><li>User Service</li><li>Ticket Service</li></ul><p>这三个服务之间不会进行任何形式的直接调用，大家有事都是直接发送到消息中间件，其他服务则从消息中间件中获取自己想要的消息然后进行处理。</p><p>具体到我们的实践中，则多了一个检查票是否够用的流程，如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20210829195014.png" alt></p><p>创建订单时，先由 Ticket 服务检查票是否够用，没问题的话再继续发起订单的创建。其他过程我就不说了。</p><p><strong>另外还需要注意，在售票系统中，由于每张票都不同，例如每张票可能有座位啥的，因此一张票在数据库中往往是被设计成一条记录。</strong></p><h2 id="3-实践"><a href="#3-实践" class="headerlink" title="3. 实践"></a>3. 实践</h2><p>流程我已经说明白了，接下来我们就来看看具体的代码实践。</p><h3 id="3-1-准备数据库"><a href="#3-1-准备数据库" class="headerlink" title="3.1 准备数据库"></a>3.1 准备数据库</h3><p>首先我们准备三个数据库，分别是：</p><ul><li>javaboy_order：订单库，用户创建订单等操作，在这个数据库中完成。</li><li>javaboy_ticket：票务库，这个库中保存着所有的票据信息，每一张票都是一条记录，都保存在这个库中。</li><li>javaboy_user：用户库，这里保存着用户的账户余额以及付款记录等信息。</li></ul><p>每个库中都有各自对应的表，为了操作方便，这些表不用自己创建，将来等项目启动了，利用 JPA 自动创建即可。</p><h3 id="3-2-项目概览"><a href="#3-2-项目概览" class="headerlink" title="3.2 项目概览"></a>3.2 项目概览</h3><p>我们先来整体上看下这个项目，公众号后台回复 <code>mq_tran</code> 可以下载完整代码：</p><p><img src="http://img.itboyhub.com/2021/07/20210831214348.png" alt></p><p>一共有五个服务：</p><ul><li>eureka：注册中心</li><li>order：订单服务</li><li>service：公共模块</li><li>ticket：票务服务</li><li>user：用户服务</li></ul><p>下面分别来说。</p><h3 id="3-3-注册中心"><a href="#3-3-注册中心" class="headerlink" title="3.3 注册中心"></a>3.3 注册中心</h3><p>有人说，都消息驱动了，还要注册中心干嘛？</p><p>消息驱动没错，消息驱动微服务之后每个服务只管把消息往消息中间件上扔，每个服务又只管消费消息中间件上的消息，这个时候对于服务注册中心似乎不是那么强需要。不过在我们这个案例中，消息驱动主要用来处理事务问题，其他常规需求我们还是用 OpenFeign 来处理，所以这里我们依然需要一个注册中心。</p><p>这里的注册中心我就选择常见的 Eureka，省事一些。<strong>由于本文主要是和大家聊分布式事务，所以涉及到微服务的东西我就简单介绍下，不会占用过多篇幅</strong>，如果大家还不熟悉 Spring Cloud 的用法，可以在公众号后台回复 vhr 有一套视频介绍。</p><p>服务注册中心的创建记得加上 Spring Security，将自己的服务注册中心保护起来。</p><p>这块有一个小小的细节和大家多说两句。</p><p>Eureka 用 Spring Security 保护起来之后，以后其他服务注册都是通过 Http Basic 来认证，所以我们要在代码中开启 Http Basic 认证，如下（以前旧版本不需要下面这段代码，但是新版本需要）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and().formLogin().and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-购票服务"><a href="#3-4-购票服务" class="headerlink" title="3.4 购票服务"></a>3.4 购票服务</h3><p>接下来我们就来看看购票服务。</p><p>购票是从下订单开始，所以我们就先从订单服务 order 开始整个流程的分析。</p><h4 id="3-4-1-新订单处理（order）"><a href="#3-4-1-新订单处理（order）" class="headerlink" title="3.4.1 新订单处理（order）"></a>3.4.1 新订单处理（order）</h4><p>当用户发起一个购票请求后，这个请求发送到 order 服务上，order 服务首先会向 <code>order:new</code> 队列发送一条消息，开启一个订单的处理流程。代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">""</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(@RequestBody OrderDTO dto)</span> </span>&#123;</span><br><span class="line">    dto.setUuid(UUID.randomUUID().toString());</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:new"</span>, dto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面设置的 UUID 是整个订单在处理过程中的一个唯一标志符，也算是一条主线。</p><p><code>order:new</code> 队列中的消息将被 ticket 服务消费，ticket 服务消费 <code>order:new</code> 中的消息，并进行锁票操作（锁票的目的防止有两个消费同时购买同一张票），锁票成功后，ticket 服务将向 <code>order:locked</code> 队列发送一条消息，表示锁票成功；否则向 <code>order:fail</code> 队列发送一条消息表示锁票失败。</p><p>这里的 OrderDTO 对象将贯穿整个购票过程。</p><h4 id="3-4-2-锁票（ticket）"><a href="#3-4-2-锁票（ticket）" class="headerlink" title="3.4.2 锁票（ticket）"></a>3.4.2 锁票（ticket）</h4><p>锁票操作是在 ticket 服务中完成的，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:new"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleTicketLock</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get new order for ticket lock:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-keyword">int</span> lockCount = ticketRepository.lockTicket(msg.getCustomerId(), msg.getTicketNum());</span><br><span class="line">    <span class="hljs-keyword">if</span> (lockCount == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        msg.setStatus(<span class="hljs-string">"TICKET_LOCK_FAIL"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="hljs-string">"order:fail"</span>, msg);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        msg.setStatus(<span class="hljs-string">"TICKET_LOCKED"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="hljs-string">"order:locked"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先调用 lockTicket 方法去数据库中锁票，所谓的锁票就是将要购买的票的 lock_user 字段设置为 customer_id（购买者的 id）。</p><p>如果锁票成功（即数据库修改成功），设置 msg 的状态为 <code>TICKET_LOCKED</code>，同时发送消息到 <code>order:locked</code> 队列，表示锁票成功。</p><p>如果锁票失败（即数据库修改失败），设置 msg 的状态为 <code>TICKET_LOCK_FAIL</code>，同时发送消息到 <code>order:fail</code> 队列，表示锁票失败。</p><h4 id="3-4-2-锁票成功（order）"><a href="#3-4-2-锁票成功（order）" class="headerlink" title="3.4.2 锁票成功（order）"></a>3.4.2 锁票成功（order）</h4><p>接下来，由 order 服务消费 <code>order:locked</code> 队列中的消息，也就是锁票成功后接下来的操作。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:locked"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get new order to create:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-keyword">if</span> (orderRepository.findOneByUuid(msg.getUuid()) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"Msg already processed:&#123;&#125;"</span>, msg);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        Order order = newOrder(msg);</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        msg.setId(order.getId());</span><br><span class="line">    &#125;</span><br><span class="line">    msg.setStatus(<span class="hljs-string">"NEW"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:pay"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁票成功后，先根据订单的 UUID 去订单数据库查询，是否已经有订单记录了，如果有，说明这条消息已经被处理了，可以防止订单的重复处理（这块主要是解决幂等性问题）。</p><p>如果订单还没有被处理，则创建一个新的订单对象，并保存到数据库中，创建新订单对象的时候，需要设置订单的 status 为 NEW。</p><p>最后设置 msg 的 status 为 NEW，然后向 <code>order:pay</code> 队列发送一条消息开启付款流程，付款是由 user 服务提供的。user 服务中会检查用户的账户余额是否够用，如果不够用，就会发送消息到 <code>order:ticket_error</code> 队列，表示订票失败；如果余额够用，则进行正常的付款操作，并在付款成功后发送消息到 <code>order:ticket_move</code> 队列，开启票的转移。</p><h4 id="3-4-3-缴费（user）"><a href="#3-4-3-缴费（user）" class="headerlink" title="3.4.3 缴费（user）"></a>3.4.3 缴费（user）</h4><p>锁票成功后，接下来就是付费了，付费服务由 user 提供。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:pay"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get new order to pay:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-comment">// 先检查payInfo判断重复消息。</span></span><br><span class="line">    PayInfo pay = payInfoRepository.findOneByOrderId(msg.getId());</span><br><span class="line">    <span class="hljs-keyword">if</span> (pay != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        LOG.warn(<span class="hljs-string">"Order already paid, duplicated message."</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Customer customer = customerRepository.getById(msg.getCustomerId());</span><br><span class="line">    <span class="hljs-keyword">if</span> (customer.getDeposit() &lt; msg.getAmount()) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"No enough deposit, need amount:&#123;&#125;"</span>, msg.getAmount());</span><br><span class="line">        msg.setStatus(<span class="hljs-string">"NOT_ENOUGH_DEPOSIT"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="hljs-string">"order:ticket_error"</span>, msg);</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pay = <span class="hljs-keyword">new</span> PayInfo();</span><br><span class="line">    pay.setOrderId(msg.getId());</span><br><span class="line">    pay.setAmount(msg.getAmount());</span><br><span class="line">    pay.setStatus(<span class="hljs-string">"PAID"</span>);</span><br><span class="line">    payInfoRepository.save(pay);</span><br><span class="line">    customerRepository.charge(msg.getCustomerId(), msg.getAmount());</span><br><span class="line">    msg.setStatus(<span class="hljs-string">"PAID"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:ticket_move"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的执行步骤如下：</p><ol><li>首先根据订单 id 去查找付款信息，检查当前订单是否已经完成付款，如果已经完成服务，则直接 return，这一步也是为了处理幂等性问题。</li><li>根据顾客的 id，查找到顾客的完整信息，包括顾客的账户余额。</li><li>检查顾客的账户余额是否足够支付票价，如果不够，则设置 msg 的 status 为 NOT_ENOUGH_DEPOSIT，同时向 <code>order:ticket_error</code> 队列发送消息，表示订票失败。</li><li>如果顾客账户余额足够支付票价，则创建一个 PayInfo 对象，设置相关的支付信息，并存入 <code>pay_info</code> 表中。</li><li>调用 charge 方法完成顾客账户余额的扣款。</li><li>发送消息到 <code>order:ticket_move</code> 队列中，开启交票操作。</li></ol><h4 id="3-4-4-交票（ticket）"><a href="#3-4-4-交票（ticket）" class="headerlink" title="3.4.4 交票（ticket）"></a>3.4.4 交票（ticket）</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:ticket_move"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleTicketMove</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get new order for ticket move:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-keyword">int</span> moveCount = ticketRepository.moveTicket(msg.getCustomerId(), msg.getTicketNum());</span><br><span class="line">    <span class="hljs-keyword">if</span> (moveCount == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"Ticket already transferred."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg.setStatus(<span class="hljs-string">"TICKET_MOVED"</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:finish"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 moveTicket 方法完成交票操作，也就是设置 ticket 表中票的 owner 为 customerId。</p><p>交票成功后，发送消息到 <code>order:finish</code> 队列，表示交票完成。</p><h4 id="3-4-5-订单完成（order）"><a href="#3-4-5-订单完成（order）" class="headerlink" title="3.4.5 订单完成（order）"></a>3.4.5 订单完成（order）</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:finish"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleFinish</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get finished order:&#123;&#125;"</span>, msg);</span><br><span class="line">    Order order = orderRepository.getById(msg.getId());</span><br><span class="line">    order.setStatus(<span class="hljs-string">"FINISH"</span>);</span><br><span class="line">    orderRepository.save(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理就比较简单，订单完成后，就设置订单的状态为 FINISH 即可。</p><p>上面介绍的是一条主线，顺利的话，消息顺着这条线走一遍，一个订单就处理完成了。</p><p>不顺利的话，就有各种幺蛾子，我们分别来看。</p><h4 id="3-4-6-锁票失败（order）"><a href="#3-4-6-锁票失败（order）" class="headerlink" title="3.4.6 锁票失败（order）"></a>3.4.6 锁票失败（order）</h4><p>锁票是在 ticket 服务中完成的，如果锁票失败，就会直接向 <code>order:fail</code> 队列发送消息，该队列的消息由 order 服务负责消费。</p><h4 id="3-4-7-扣款失败（ticket）"><a href="#3-4-7-扣款失败（ticket）" class="headerlink" title="3.4.7 扣款失败（ticket）"></a>3.4.7 扣款失败（ticket）</h4><p>扣款操作是在 user 中完成的，扣款失败就会向 <code>order:ticket_error</code> 队列中发送消息，该队列的消息由 ticket 服务负责消费。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:ticket_error"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get order error for ticket unlock:&#123;&#125;"</span>, msg);</span><br><span class="line">    <span class="hljs-keyword">int</span> count = ticketRepository.unMoveTicket(msg.getCustomerId(), msg.getTicketNum());</span><br><span class="line">    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"Ticket already unlocked:"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    count = ticketRepository.unLockTicket(msg.getCustomerId(), msg.getTicketNum());</span><br><span class="line">    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        LOG.info(<span class="hljs-string">"Ticket already unmoved, or not moved:"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="hljs-string">"order:fail"</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当扣款失败的时候，做三件事：</p><ol><li>撤销票的转移，也就是把票的 owner 字段重新置为 null。</li><li>撤销锁票，也就是把票的 <code>lock_user</code> 字段重新置为 null。</li><li>向 <code>order:fail</code> 队列发送订单失败的消息。</li></ol><h4 id="3-4-8-下单失败（order）"><a href="#3-4-8-下单失败（order）" class="headerlink" title="3.4.8 下单失败（order）"></a>3.4.8 下单失败（order）</h4><p>下单失败的处理在 order 服务中，有三种情况会向 <code>order:fail</code> 队列发送消息：</p><ol><li>锁票失败</li><li>扣款失败（客户账户余额不足）</li><li>订单超时</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"order:fail"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleFailed</span><span class="hljs-params">(OrderDTO msg)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="hljs-string">"Get failed order:&#123;&#125;"</span>, msg);</span><br><span class="line">    Order order;</span><br><span class="line">    <span class="hljs-keyword">if</span> (msg.getId() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        order = newOrder(msg);</span><br><span class="line">        order.setReason(<span class="hljs-string">"TICKET_LOCK_FAIL"</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        order = orderRepository.getById(msg.getId());</span><br><span class="line">        <span class="hljs-keyword">if</span> (msg.getStatus().equals(<span class="hljs-string">"NOT_ENOUGH_DEPOSIT"</span>)) &#123;</span><br><span class="line">            order.setReason(<span class="hljs-string">"NOT_ENOUGH_DEPOSIT"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    order.setStatus(<span class="hljs-string">"FAIL"</span>);</span><br><span class="line">    orderRepository.save(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的具体处理逻辑如下：</p><ol><li>首先查看是否有订单 id，如果连订单 id 都没有，就说明是锁票失败，给订单设置 reason 属性的值为<code>TICKET_LOCK_FAIL</code>。</li><li>如果有订单 id，则根据 id 查询订单信息，并判断订单状态是否为 <code>NOT_ENOUGH_DEPOSIT</code>，这个表示扣款失败，如果订单状态是 <code>NOT_ENOUGH_DEPOSIT</code>，则设置失败的 reason 也为此。</li><li>最后设置订单状态为 FAIL，然后更新数据库中的订单信息即可。</li></ol><h4 id="3-4-9-订单超时（order）"><a href="#3-4-9-订单超时（order）" class="headerlink" title="3.4.9 订单超时（order）"></a>3.4.9 订单超时（order）</h4><p>order 服务中还有一个定时任务，定时去数据库中捞取那些处理失败的订单，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Scheduled</span>(fixedDelay = <span class="hljs-number">10000L</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkInvalidOrder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ZonedDateTime checkTime = ZonedDateTime.now().minusMinutes(<span class="hljs-number">1L</span>);</span><br><span class="line">    List&lt;Order&gt; orders = orderRepository.findAllByStatusAndCreatedDateBefore(<span class="hljs-string">"NEW"</span>, checkTime);</span><br><span class="line">    orders.stream().forEach(order -&gt; &#123;</span><br><span class="line">        LOG.error(<span class="hljs-string">"Order timeout:&#123;&#125;"</span>, order);</span><br><span class="line">        OrderDTO dto = <span class="hljs-keyword">new</span> OrderDTO();</span><br><span class="line">        dto.setId(order.getId());</span><br><span class="line">        dto.setTicketNum(order.getTicketNum());</span><br><span class="line">        dto.setUuid(order.getUuid());</span><br><span class="line">        dto.setAmount(order.getAmount());</span><br><span class="line">        dto.setTitle(order.getTitle());</span><br><span class="line">        dto.setCustomerId(order.getCustomerId());</span><br><span class="line">        dto.setStatus(<span class="hljs-string">"TIMEOUT"</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="hljs-string">"order:ticket_error"</span>, dto);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里是去数据库中捞取那些状态为 NEW 并且是 1 分钟之前的订单，根据前面的分析，当锁票成功后，就会将订单的状态设置为 NEW 并且存入数据库中。换言之，当锁票成功一分钟之后，这张票还没有卖掉，就设置订单超时，同时向 <code>order:ticket_error</code> 队列发送一条消息，这条消息在 ticket 服务中被消费，最终完成撤销交票、撤销锁票等操作。</p><p>这就是大致的代码处理流程。</p><p>再来回顾一下前面那张图：</p><p><img src="http://img.itboyhub.com/2021/07/20210829195014.png" alt></p><p>结合着代码来看这张图是不是就很容易懂了。</p><h3 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h3><p>接下来我们来进行一个简单的测试。</p><p>先来一个订票失败的测试，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210901194732.png" alt></p><p>由于用户只有 1000 块钱，这张票要 10000，所以购票必然失败。请求执行成功后，我们查看 order 表，多了如下一条记录：</p><p><img src="http://img.itboyhub.com/2021/07/20210901194945.png" alt></p><p>可以看到，订单失败的理由就是账户余额不足。此时查看 ticket 和 user 表，发现都完好如初（如果需要，则已经反向补偿了）。</p><p>接下来我们手动给 ticket 表中 lock_user 字段设置一个值，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210901195235.png" alt></p><p>这个表示这张票已经被人锁定了。</p><p>然后我们发起一次购票请求（这次可以把金额设置到合理范围，其实不设置也行，反正这次失败还没走到付款这一步）：</p><p><img src="http://img.itboyhub.com/2021/07/20210901195356.png" alt></p><p>请求发送成功后，接下来我们去查看 order 表，多了如下一条记录：</p><p><img src="http://img.itboyhub.com/2021/07/20210901195546.png" alt></p><p>可以看到，这次下单失败的理由是锁票失败。此时查看 ticket 和 user 表，发现都完好如初（如果需要，则已经反向补偿了）。</p><p>最后再来一次成功测试，先把 ticket 表中的 <code>lock_user</code> 字段置空，然后发送如下请求：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200004.png" alt></p><p>这次购票成功，查看 ticket 表，发票已经票有所属：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200110.png" alt></p><p>查看订单表：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200403.png" alt></p><p>可以多了一条成功的购票记录。</p><p>查看用户表：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200443.png" alt></p><p>用户账户已扣款。</p><p>查看支付记录表：</p><p><img src="http://img.itboyhub.com/2021/07/20210901200516.png" alt></p><p>可以看到已经有了支付记录。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>整体上来说，上面这个案例，技术上并没有什么难的，复杂之处在于设计。一开始要设计好消息的处理流程以及消息处理失败后如何进行补偿，这个是比较考验大家技术的。</p><p>另外上面案例中，消息的发送和消费都用到了 RabbitMQ 中的事务机制（确保消息消费成功）以及 Spring 中的事务机制（确保消息发送和数据保存同时成功），这些我就不再赘述了。</p><p>总之，通过消息中间件处理分布式事务，这种方式通过牺牲数据的强一致性换取性能的大幅提升，但是实现这种方式的成本和复杂度是比较高的，使用时还要看实际业务情况。</p><p>好啦，小伙伴们有什么想说的欢迎留言讨论～</p><p>公众号后台回复 <code>mq_tran</code> 可以下载上面案例的完整代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前面几篇文章松哥和大家介绍了 Seata 中四种分布式事务处理方案，相信经过前面的几篇文章的学习，大家对于 Seata 中的分布式事务已经非常了解了。还没看过前面文章的小伙伴，可以先看一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五分钟带你体验一把分布式事务！so easy！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;看了那么多博客，还是不懂 TCC，不妨看看这个案例！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BJHmVkNrvNL87hBT8DM8vg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XA 事务水很深，小伙子我怕你把握不住！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/cZabAt7JF4QrQHERHHAWjA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;你这 Saga 事务保“隔离性”吗？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="http://www.javaboy.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://www.javaboy.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="消息驱动" scheme="http://www.javaboy.org/tags/%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>四个案例看懂 MySQL 事务隔离级别</title>
    <link href="http://www.javaboy.org/2021/0830/mysql_isolation.html"/>
    <id>http://www.javaboy.org/2021/0830/mysql_isolation.html</id>
    <published>2021-08-30T13:36:55.000Z</published>
    <updated>2021-10-20T14:12:47.865Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>很多小伙伴对 MySQL 的隔离级别一直心存疑惑，其实这个问题一点都不难，关键看怎么讲！单纯的看理论，绝对让你晕头转向，但是，如果我们通过几个实际的 SQL 来演示一些，大家就会发现这玩意原来这么简单！</p><p>今天松哥想通过几个简单的案例，来和大家演示一下 MySQL 中的事务隔离级别问题。</p><a id="more"></a><h2 id="1-理论"><a href="#1-理论" class="headerlink" title="1. 理论"></a>1. 理论</h2><p>MySQL 中事务的隔离级别一共分为四种，分别如下：</p><ul><li>序列化（SERIALIZABLE）</li><li>可重复读（REPEATABLE READ）</li><li>提交读（READ COMMITTED）</li><li>未提交读（READ UNCOMMITTED）</li></ul><p>四种不同的隔离级别含义分别如下：</p><ol><li>SERIALIZABLE</li></ol><blockquote><p>如果隔离级别为序列化，则用户之间通过一个接一个顺序地执行当前的事务，这种隔离级别提供了事务之间最大限度的隔离。</p></blockquote><ol start="2"><li>REPEATABLE READ</li></ol><blockquote><p>在可重复读在这一隔离级别上，事务不会被看成是一个序列。不过，当前正在执行事务的变化仍然不能被外部看到，也就是说，如果用户在另外一个事务中执行同条 SELECT 语句数次，结果总是相同的。（因为正在执行的事务所产生的数据变化不能被外部看到）。</p></blockquote><ol start="3"><li>READ COMMITTED</li></ol><blockquote><p>READ COMMITTED 隔离级别的安全性比 REPEATABLE READ 隔离级别的安全性要差。处于 READ COMMITTED 级别的事务可以看到其他事务对数据的修改。也就是说，在事务处理期间，如果其他事务修改了相应的表，那么同一个事务的多个 SELECT 语句可能返回不同的结果。</p></blockquote><ol start="4"><li>READ UNCOMMITTED</li></ol><blockquote><p>READ UNCOMMITTED 提供了事务之间最小限度的隔离。除了容易产生虚幻的读操作和不能重复的读操作外，处于这个隔离级的事务可以读到其他事务还没有提交的数据，如果这个事务使用其他事务不提交的变化作为计算的基础，然后那些未提交的变化被它们的父事务撤销，这就导致了大量的数据变化。</p></blockquote><p><strong>在 MySQL 数据库种，默认的事务隔离级别是 REPEATABLE READ</strong></p><h2 id="2-SQL-实践"><a href="#2-SQL-实践" class="headerlink" title="2. SQL 实践"></a>2. SQL 实践</h2><p>接下来通过几条简单的 SQL 向读者验证上面的理论。</p><h3 id="2-1-查看隔离级别"><a href="#2-1-查看隔离级别" class="headerlink" title="2.1 查看隔离级别"></a>2.1 查看隔离级别</h3><p>通过如下 SQL 可以查看数据库实例默认的全局隔离级别和当前 session 的隔离级别：</p><p>MySQL8 之前使用如下命令查看 MySQL 隔离级别：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> @@GLOBAL.tx_isolation, @@tx_isolation;</span><br></pre></td></tr></table></figure><p>查询结果如图： </p><p><img src="http://img.itboyhub.com/2021/07/20210826193903.png" alt></p><p>可以看到，默认的隔离级别为 REPEATABLE-READ，全局隔离级别和当前会话隔离级别皆是如此。</p><p><strong>MySQL8 开始，通过如下命令查看 MySQL 默认隔离级别</strong>：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> @@GLOBAL.transaction_isolation, @@transaction_isolation;</span><br></pre></td></tr></table></figure><p>就是关键字变了，其他都一样。</p><p>通过如下命令可以修改隔离级别（建议开发者在修改时修改当前 session 隔离级别即可，不用修改全局的隔离级别）：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure><p>上面这条 SQL 表示将当前 session 的数据库隔离级别设置为 READ UNCOMMITTED，设置成功后，再次查询隔离级别，发现当前 session 的隔离级别已经变了，如图1-2：</p><p><img src="http://img.itboyhub.com/2021/07/20210826194455.png" alt></p><p><strong>注意，如果只是修改了当前 session 的隔离级别，则换一个 session 之后，隔离级别又会恢复到默认的隔离级别，所以我们测试时，修改当前 session 的隔离级别即可。</strong></p><h3 id="2-2-READ-UNCOMMITTED"><a href="#2-2-READ-UNCOMMITTED" class="headerlink" title="2.2 READ UNCOMMITTED"></a>2.2 READ UNCOMMITTED</h3><h4 id="2-2-1-准备测试数据"><a href="#2-2-1-准备测试数据" class="headerlink" title="2.2.1 准备测试数据"></a>2.2.1 准备测试数据</h4><p>READ UNCOMMITTED 是最低隔离级别，这种隔离级别中存在<strong>脏读、不可重复读以及幻象读</strong>问题，所以这里我们先来看这个隔离级别，借此大家可以搞懂这三个问题到底是怎么回事。</p><p>下面分别予以介绍。</p><p>首先创建一个简单的表，预设两条数据，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210826200353.png" alt></p><p>表的数据很简单，有 javaboy 和 itboyhub 两个用户，两个人的账户各有 1000 人民币。现在模拟这两个用户之间的一个转账操作。</p><p><strong>注意，如果读者使用的是 Navicat 的话，不同的查询窗口就对应了不同的 session，如果读者使用了 SQLyog 的话，不同查询窗口对应同一个 session，因此如果使用 SQLyog，需要读者再开启一个新的连接，在新的连接中进行查询操作。</strong></p><h4 id="2-2-2-脏读"><a href="#2-2-2-脏读" class="headerlink" title="2.2.2 脏读"></a>2.2.2 脏读</h4><p>一个事务读到另外一个事务还没有提交的数据，称之为脏读。具体操作如下：</p><ol><li>首先打开两个SQL操作窗口，假设分别为 A 和 B，在 A 窗口中输入如下几条 SQL （输入完成后不用执行）：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">set</span> balance=balance+<span class="hljs-number">100</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'javaboy'</span>;</span><br><span class="line"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">set</span> balance=balance<span class="hljs-number">-100</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'itboyhub'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 B 窗口执行如下 SQL，修改默认的事务隔离级别为 READ UNCOMMITTED，如下：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">SESSION</span> <span class="hljs-keyword">TRANSACTION</span> <span class="hljs-keyword">ISOLATION</span> <span class="hljs-keyword">LEVEL</span> <span class="hljs-keyword">READ</span> UNCOMMITTED</span><br></pre></td></tr></table></figure><ol start="3"><li>接下来在 B 窗口中输入如下 SQL，输入完成后，首先执行第一行开启事务（注意只需要执行一行即可）：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>接下来执行 A 窗口中的前两条 SQL，即开启事务，给 javaboy 这个账户添加 100 元。</p></li><li><p>进入到 B 窗口，执行 B 窗口的第二条查询 SQL（SELECT * from user;），结果如下：</p></li></ol><p><img src="http://img.itboyhub.com/2021/07/20210826201458.png" alt></p><p>可以看到，A 窗口中的事务，虽然还未提交，但是 B 窗口中已经可以查询到数据的相关变化了。</p><p>这就是<strong>脏读</strong>问题。</p><h4 id="2-2-3-不可重复读"><a href="#2-2-3-不可重复读" class="headerlink" title="2.2.3 不可重复读"></a>2.2.3 不可重复读</h4><p>不可重复读是指一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。具体操作步骤如下（操作之前先将两个账户的钱都恢复为1000）：</p><ol><li><p>首先打开两个查询窗口 A 和 B ，并且将 B 的数据库事务隔离级别设置为 READ UNCOMMITTED。具体 SQL 参考上文，这里不赘述。</p></li><li><p>在 B 窗口中输入如下 SQL，然后只执行前两条 SQL 开启事务并查询 javaboy 的账户：</p></li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'javaboy'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>前两条 SQL 执行结果如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210826201858.png" alt></p><ol start="3"><li>在 A 窗口中执行如下 SQL，给 javaboy 这个账户添加 100 块钱，如下：</li></ol><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">set</span> balance=balance+<span class="hljs-number">100</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'javaboy'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>4.再次回到 B 窗口，执行 B 窗口的第二条 SQL 查看 javaboy 的账户，结果如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210826202036.png" alt></p><p>javaboy 的账户已经发生了变化，即前后两次查看 javaboy 账户，结果不一致，这就是<strong>不可重复读</strong>。</p><p><strong>和脏读的区别在于，脏读是看到了其他事务未提交的数据，而不可重复读是看到了其他事务已经提交的数据（由于当前 SQL 也是在事务中，因此有可能并不想看到其他事务已经提交的数据）。</strong></p><h4 id="2-2-4-幻象读"><a href="#2-2-4-幻象读" class="headerlink" title="2.2.4 幻象读"></a>2.2.4 幻象读</h4><p>幻象读和不可重复读非常像，看名字就是产生幻觉了。</p><p>我举一个简单例子。</p><p>在 A 窗口中输入如下 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">account</span>(<span class="hljs-keyword">name</span>,balance) <span class="hljs-keyword">values</span>(<span class="hljs-string">'zhangsan'</span>,<span class="hljs-number">1000</span>);</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>然后在 B 窗口输入如下 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span>;</span><br><span class="line"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">name</span>=<span class="hljs-string">'zhangsan'</span>;</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>我们执行步骤如下：</p><ol><li>首先执行 B 窗口的前两行，开启一个事务，同时查询数据库中的数据，此时查询到的数据只有 javaboy 和 itboyhub。</li><li>执行 A 窗口的前两行，向数据库中添加一个名为 zhangsan 的用户，注意不用提交事务。</li><li>执行 B 窗口的第二行，由于脏读问题，此时可以查询到 zhangsan 这个用户。</li><li>执行 B 窗口的第三行，去删除 name 为 zhangsan 的记录，这个时候删除就会出问题，虽然在 B 窗口中可以查询到 zhangsan，但是这条记录还没有提交，是因为脏读的原因才看到了，所以是没法删除的。此时就产生了幻觉，明明有个 zhangsan，却无法删除。</li></ol><p>这就是<strong>幻读</strong>。</p><p>看了上面的案例，大家应该明白了<strong>脏读</strong>、<strong>不可重复读</strong>以及<strong>幻读</strong>各自是什么含义了。</p><h3 id="2-3-READ-COMMITTED"><a href="#2-3-READ-COMMITTED" class="headerlink" title="2.3 READ COMMITTED"></a>2.3 READ COMMITTED</h3><p>和 READ UNCOMMITTED 相比，READ COMMITTED 主要解决了脏读的问题，对于不可重复读和幻象读则未解决。</p><p>将事务的隔离级别改为 <code>READ COMMITTED</code> 之后，重复上面关于脏读案例的测试，发现已经不存在脏读问题了；重复上面关于不可重复读案例的测试，发现不可重复读问题依然存在。</p><p>上面那个案例不适用于幻读的测试，我们换一个幻读的测试案例。</p><p>还是两个窗口 A 和 B，将 B 窗口的隔离级别改为 <code>READ COMMITTED</code>，</p><p>然后在 A 窗口输入如下测试 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">account</span>(<span class="hljs-keyword">name</span>,balance) <span class="hljs-keyword">values</span>(<span class="hljs-string">'zhangsan'</span>,<span class="hljs-number">1000</span>);</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>在 B 窗口输入如下测试 SQL：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;</span><br><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">account</span>;</span><br><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">account</span>(<span class="hljs-keyword">name</span>,balance) <span class="hljs-keyword">values</span>(<span class="hljs-string">'zhangsan'</span>,<span class="hljs-number">1000</span>);</span><br><span class="line"><span class="hljs-keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>测试方式如下：</p><ol><li>首先执行 B 窗口的前两行 SQL，开启事务并查询数据，此时查到的只有 javaboy 和 itboyhub 两个用户。</li><li>执行 A 窗口的前两行 SQL，插入一条记录，但是并不提交事务。</li><li>执行 B 窗口的第二行 SQL，由于现在已经没有了脏读问题，所以此时查不到 A 窗口中添加的数据。</li><li>执行 B 窗口的第三行 SQL，由于 name 字段唯一，因此这里会无法插入。此时就产生幻觉了，明明没有 zhangsan 这个用户，却无法插入 zhangsan。</li></ol><h3 id="2-4-REPEATABLE-READ"><a href="#2-4-REPEATABLE-READ" class="headerlink" title="2.4 REPEATABLE READ"></a>2.4 REPEATABLE READ</h3><p>和 READ COMMITTED 相比，REPEATABLE READ 进一步解决了不可重复读的问题，但是幻象读则未解决。</p><p>REPEATABLE READ 中关于幻读的测试和上一小节基本一致，不同的是第二步中执行完插入 SQL 后记得提交事务。</p><p>由于 REPEATABLE READ 已经解决了不可重复读，因此第二步即使提交了事务，第三步也查不到已经提交的数据，第四步继续插入就会出错。</p><p><strong>注意，REPEATABLE READ 也是 InnoDB 引擎的默认数据库事务隔离级别</strong></p><h3 id="2-5-SERIALIZABLE"><a href="#2-5-SERIALIZABLE" class="headerlink" title="2.5 SERIALIZABLE"></a>2.5 SERIALIZABLE</h3><p>SERIALIZABLE 提供了事务之间最大限度的隔离，在这种隔离级别中，事务一个接一个顺序的执行，不会发生脏读、不可重复读以及幻象读问题，最安全。</p><p>如果设置当前事务隔离级别为 SERIALIZABLE，那么此时开启其他事务时，就会阻塞，必须等当前事务提交了，其他事务才能开启成功，因此前面的脏读、不可重复读以及幻象读问题这里都不会发生。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>总的来说，隔离级别和脏读、不可重复读以及幻象读的对应关系如下：</p><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻象读</th></tr></thead><tbody><tr><td style="text-align:left">READ UNCOMMITTED</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">READ COMMITED</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">REPEATABLE READ</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td></tr></tbody></table><p>性能关系如图：</p><p><img src="http://img.itboyhub.com/2021/07/1-72222.png" alt></p><p>好了，这篇文章就和小伙伴们先说这么多，大家不妨写几行 SQL 试一试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;很多小伙伴对 MySQL 的隔离级别一直心存疑惑，其实这个问题一点都不难，关键看怎么讲！单纯的看理论，绝对让你晕头转向，但是，如果我们通过几个实际的 SQL 来演示一些，大家就会发现这玩意原来这么简单！&lt;/p&gt;
&lt;p&gt;今天松哥想通过几个简单的案例，来和大家演示一下 MySQL 中的事务隔离级别问题。&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://www.javaboy.org/categories/mysql/"/>
    
    
      <category term="MySQL" scheme="http://www.javaboy.org/tags/MySQL/"/>
    
      <category term="事务" scheme="http://www.javaboy.org/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>你这 Saga 事务保“隔离性”吗？</title>
    <link href="http://www.javaboy.org/2021/0828/seata-saga.html"/>
    <id>http://www.javaboy.org/2021/0828/seata-saga.html</id>
    <published>2021-08-28T13:36:39.000Z</published>
    <updated>2021-10-20T14:12:02.900Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>Seata 一共提供了四种分布式事务的处理模式：</p><ul><li>AT</li><li>TCC</li><li>XA</li><li>Saga</li></ul><p>前面三种松哥都和大家介绍过了，今天我们来看看 Saga 这种模式。如果大家对于前三种还不太熟悉，可以先看看之前的文章，传送门：</p><ul><li><a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA" target="_blank" rel="noopener">看了那么多博客，还是不懂 TCC，不妨看看这个案例！</a></li><li><a href="https://mp.weixin.qq.com/s/BJHmVkNrvNL87hBT8DM8vg" target="_blank" rel="noopener">XA 事务水很深，小伙子我怕你把握不住！</a></li></ul><a id="more"></a><p>好啦，开始今天的正文吧。</p><h2 id="1-什么是-Saga-事务模式"><a href="#1-什么是-Saga-事务模式" class="headerlink" title="1. 什么是 Saga 事务模式"></a>1. 什么是 Saga 事务模式</h2><p>Saga 模式是 Seata 提供的长事务解决方案，在 Saga 模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，<strong>一阶段正向服务和二阶段补偿服务都由业务开发实现</strong>。</p><p>注意最后一句话很关键，说明 Saga 模式的回滚其实和 AT、TCC 的回滚一样，都是反向补偿操作（区别于 XA 模式）。</p><p>官方给了下面一张流程图，我们一起来看下：</p><p><img src="http://img.itboyhub.com/2021/07/20210822113735.png" alt></p><p>可以看到，T1、T2、T3 一直到 Tn 分别代表分布式事务中的分支事务，这条线都是事务的正常状态，如果在执行的过程中，有某一个抛出异常，则执行 C3、C2 一直到 C1 进行事务的回滚，这里的回滚实际上就是反向补偿操作。</p><p>一般来说，Saga 模式适用于业务流程长、业务流程多的分布式事务，就像上面的流程图这样，不过当业务流程比较长的时候，如何去定义每一个事务的状态也就成了问题。</p><p>这里就涉及到 Saga 分布式事务的状态机。</p><h2 id="2-Saga-的状态图"><a href="#2-Saga-的状态图" class="headerlink" title="2. Saga 的状态图"></a>2. Saga 的状态图</h2><p>状态图这个东西，如果小伙伴们用过 Activiti 流程引擎，那么基本上就知道什么是状态图，Saga 的状态图跟那个也差不多。</p><p>Saga 中的状态图是这样：</p><ol><li>首先我们需要定义一个状态流程图，像下面这样：</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210822190217.png" alt></p><p>这个流程图官方提供了绘制工具，地址如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://seata.io/saga_designer/index.html</span><br></pre></td></tr></table></figure><p>官方还为此提供了一个视频教程，松哥看了下，录视频的人估计也是第一次录视频，没啥经验，视频各种问题没法看，所以我就不放链接了，小伙伴们在工作中如果需要绘制状态图，可以参考这个文档：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://help.aliyun.com/document_detail/172550.html</span><br></pre></td></tr></table></figure><p>流程图上记录了每一个分支事务的状态以及相关的补偿操作，流程图画好之后，会自动生成 JSON 状态语言定义文件，把这个文件将来拷贝到项目中。</p><ol start="2"><li>状态图中的每一个节点可以调用一个服务，每一个节点都可以配置它的补偿节点，当节点出现异常时状态引擎反向执行已成功节点对应的补偿节点将事务回滚（是否回滚可由用户自行决定）。</li><li>状态图可以实现服务编排需求，支持单项选择、并发、子流程、参数转换、参数映射、服务执行状态判断、异常捕获等功能。</li></ol><h2 id="3-Saga-模式案例"><a href="#3-Saga-模式案例" class="headerlink" title="3. Saga 模式案例"></a>3. Saga 模式案例</h2><p>我们来看一个 Saga 模式的案例，看完案例大家就懂什么是 Saga 模式了。</p><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><p>我们还是使用官方的案例。不过还是松哥之前说的，官方的案例容易导入失败，并且里边有的地方有问题，所以小伙伴们可以直接在公众号后台回复 <code>seata-demo</code> 下载本文案例。</p><p>Saga 的例子我们用这个：</p><p><img src="http://img.itboyhub.com/2021/07/20210822213010.png" alt></p><p>如果小伙伴们直接使用官方的案例，需要做如下修改：</p><ol><li>修改 Dubbo 的版本为 2.7.3，原本默认的 3.0.1 这个版本运行时候有问题。</li></ol><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>官方默认提供的数据库脚本少一个字段，不知道咋回事，这么明显的 BUG。这个需要我们在 <code>src/main/resources/sql/h2_init.sql</code> 文件中，为 seata_state_inst 表添加一个 <code>gmt_updated         timestamp(3)   not null</code> 字段。</li></ol><p>准备工作就算完成啦。</p><h3 id="3-2-测试运行"><a href="#3-2-测试运行" class="headerlink" title="3.2 测试运行"></a>3.2 测试运行</h3><p>接下来我们来测试运行。</p><p>首先我们先来执行 <code>src/main/java/io/seata/samples/saga/starter/DubboSagaProviderStarter.java</code> 中的 main 方法，启动服务端。</p><p>然后打开 <code>src/main/java/io/seata/samples/saga/starter/DubboSagaTransactionStarter.java</code> 类，这个类需要修改一下才能运行。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-keyword">new</span> String[] &#123;<span class="hljs-string">"spring/seata-saga.xml"</span>, <span class="hljs-string">"spring/seata-dubbo-reference.xml"</span>&#125;);</span><br><span class="line">    StateMachineEngine stateMachineEngine = (StateMachineEngine) applicationContext.getBean(<span class="hljs-string">"stateMachineEngine"</span>);</span><br><span class="line">    transactionCommittedDemo(stateMachineEngine);</span><br><span class="line">    transactionCompensatedDemo(stateMachineEngine);</span><br><span class="line">    <span class="hljs-keyword">new</span> ApplicationKeeper(applicationContext).keep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个 main 方法中有两个测试方法：</p><ul><li>transactionCommittedDemo</li><li>transactionCompensatedDemo</li></ul><p>第一个方法是二阶段提交的测试，第二个方法是二阶段补偿的测试，我们注释掉其中一个，每次执行的时候只要执行其中一个就可以了。</p><p>另外，对于 transactionCommittedDemo 方法，它里边提供了两种状态的获取方式：同步和异步，我们需要注释掉其中一种然后进行测试，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transactionCommittedDemo</span><span class="hljs-params">(StateMachineEngine stateMachineEngine)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; startParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">3</span>);</span><br><span class="line">    String businessKey = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    startParams.put(<span class="hljs-string">"businessKey"</span>, businessKey);</span><br><span class="line">    startParams.put(<span class="hljs-string">"count"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    startParams.put(<span class="hljs-string">"amount"</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"100"</span>));</span><br><span class="line">    <span class="hljs-comment">//sync test</span></span><br><span class="line">    <span class="hljs-comment">//StateMachineInstance inst = stateMachineEngine.startWithBusinessKey("reduceInventoryAndBalance", null, businessKey, startParams);</span></span><br><span class="line">    <span class="hljs-comment">//Assert.isTrue(ExecutionStatus.SU.equals(inst.getStatus()), "saga transaction execute failed. XID: " + inst.getId());</span></span><br><span class="line">    <span class="hljs-comment">//System.out.println("saga transaction commit succeed. XID: " + inst.getId());</span></span><br><span class="line">    <span class="hljs-comment">//async test</span></span><br><span class="line">    businessKey = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    StateMachineInstance inst = stateMachineEngine.startWithBusinessKeyAsync(<span class="hljs-string">"reduceInventoryAndBalance"</span>, <span class="hljs-keyword">null</span>, businessKey, startParams, CALL_BACK);</span><br><span class="line">    waittingForFinish(inst);</span><br><span class="line">    Assert.isTrue(ExecutionStatus.SU.equals(inst.getStatus()), <span class="hljs-string">"saga transaction execute failed. XID: "</span> + inst.getId());</span><br><span class="line">    System.out.println(<span class="hljs-string">"saga transaction commit succeed. XID: "</span> + inst.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释掉同步的代码块或者注释掉异步的代码块，注释掉之后，执行 main 方法进行测试。</p><p>如果测试 transactionCommittedDemo 方法，控制台打印日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saga transaction commit succeed. XID: 192.168.1.105:8091:2612256553007833092</span><br></pre></td></tr></table></figure><p>如果测试 transactionCompensatedDemo 方法，控制台打印日志如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saga transaction compensate succeed. XID: 192.168.1.105:8091:2612256553007833094</span><br></pre></td></tr></table></figure><p>能看到如上两个日志，说明案例运行没问题了。</p><p>接下来我们就来分析一下，这个案例到底讲了个啥！</p><h3 id="3-3-案例分析"><a href="#3-3-案例分析" class="headerlink" title="3.3 案例分析"></a>3.3 案例分析</h3><h4 id="3-3-1-JSON-状态描述分析"><a href="#3-3-1-JSON-状态描述分析" class="headerlink" title="3.3.1 JSON 状态描述分析"></a>3.3.1 JSON 状态描述分析</h4><p>这个案例并没有一个明确的业务，就单纯是一个案例。</p><p>首先定义了两个 Action：</p><ul><li>InventoryAction</li><li>BalanceAction</li></ul><p>这两个 Action 中各自定义了两个方法：</p><ul><li>reduce</li><li>compensateReduce</li></ul><p>从方法名就能看出，reduce 方法就是正常的执行逻辑，compensateReduce 方法则是代码补偿逻辑，即回滚的时候需要执行的代码。</p><p>具体到这两个方法的实现上，并没有啥，都是打印日志，所以这个项目我们只需要认真观察打印出来的日志，就能知道事务是提交了还是回滚了。</p><p>在 <code>src/main/resources/statelang/reduce_inventory_and_balance.json</code> 文件中定义了各个事务的状态，我们可以大概看一下，由于完整 JSON 文件比较长，我就分段贴出来。</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="hljs-attr">"Name"</span>: <span class="hljs-string">"reduceInventoryAndBalance"</span>,</span><br><span class="line">    <span class="hljs-attr">"Comment"</span>: <span class="hljs-string">"reduce inventory then reduce balance in a transaction"</span>,</span><br><span class="line">    <span class="hljs-attr">"StartState"</span>: <span class="hljs-string">"ReduceInventory"</span>,</span><br><span class="line">    <span class="hljs-attr">"Version"</span>: <span class="hljs-string">"0.0.1"</span>,</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>上面这段定义了状态机的名称为 reduceInventoryAndBalance，在一个项目中，我们可以同时存在多个这样的 JSON 文件，每一个都有一个 name 属性，这样在 Java 代码调用的时候就可以通过具体的名字去指定需要调用哪一个流程了。StartState 则定义了整个流程从 ReduceInventory 开始，ReduceInventory 是后面定义的节点。</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">"ReduceInventory": &#123;</span><br><span class="line">    "Type": "ServiceTask",</span><br><span class="line">    "ServiceName": "inventoryAction",</span><br><span class="line">    "ServiceMethod": "reduce",</span><br><span class="line">    "CompensateState": "CompensateReduceInventory",</span><br><span class="line">    "Next": "ChoiceState",</span><br><span class="line">    "Input": [</span><br><span class="line">        "$.[businessKey]",</span><br><span class="line">        <span class="hljs-string">"$.[count]"</span></span><br><span class="line">    ],</span><br><span class="line">    "Output": &#123;</span><br><span class="line">        "reduceInventoryResult": "$.#root"</span><br><span class="line">    &#125;,</span><br><span class="line">    "Status": &#123;</span><br><span class="line">        "#root == true": "SU",</span><br><span class="line">        "#root == false": "FA",</span><br><span class="line">        "$Exception&#123;java.lang.Throwable&#125;": "UN"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是整个流程图中的第一步，我挑几个关键的点说下。</p><ul><li>ServiceName：这个是服务的名字，也就是由哪个对象处理这里的请求，inventoryAction 是我们通过 dubbo 获取到的对象。</li><li>ServiceMethod：这个指定了要执行的方法，也就是正常执行的方法。</li><li>CompensateState：这个是指定了负责补偿服务的节点，它的取值是这个 JSON 文件中定义的另外一个节点。</li><li>Next：这是当前节点走完后，下一步要去的节点。</li><li>Input/Output/Status：分别表示输入参数/输出参数以及各个状态的取值。</li></ul><p>上面这个节点执行完，就会进入到下面这个节点中：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"ChoiceState":&#123;</span><br><span class="line">    "Type": "Choice",</span><br><span class="line">    "Choices":[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"Expression"</span>:<span class="hljs-string">"[reduceInventoryResult] == true"</span>,</span><br><span class="line">            <span class="hljs-attr">"Next"</span>:<span class="hljs-string">"ReduceBalance"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "Default":"Fail"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个很好懂，就是定义了期待上面一个节点的返回值为 true，如果上个节点返回值不为 true，那就是执行失败，要准备补偿操作了；如果上个节点执行结果是为 true，那就进入下个节点 ReduceBalance。</p><p>后面节点的定义也都差不多，我就不一一列出来了，小伙伴们公号后台回复 <code>seata-demo</code> 下载文章案例后，可以自行查看。</p><p>这是状态图。</p><h4 id="3-3-2-代码分析"><a href="#3-3-2-代码分析" class="headerlink" title="3.3.2 代码分析"></a>3.3.2 代码分析</h4><p>接下来再简单看下代码。</p><p>官方提供了两个测试方法，一个用来测试二阶段提交，一个用来测试二阶段回滚。</p><p>先来看这个这个测试二阶段提交的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transactionCommittedDemo</span><span class="hljs-params">(StateMachineEngine stateMachineEngine)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; startParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">3</span>);</span><br><span class="line">    String businessKey = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    startParams.put(<span class="hljs-string">"businessKey"</span>, businessKey);</span><br><span class="line">    startParams.put(<span class="hljs-string">"count"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    startParams.put(<span class="hljs-string">"amount"</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"100"</span>));</span><br><span class="line">    businessKey = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    StateMachineInstance inst = stateMachineEngine.startWithBusinessKeyAsync(<span class="hljs-string">"reduceInventoryAndBalance"</span>, <span class="hljs-keyword">null</span>, businessKey, startParams, CALL_BACK);</span><br><span class="line">    waittingForFinish(inst);</span><br><span class="line">    Assert.isTrue(ExecutionStatus.SU.equals(inst.getStatus()), <span class="hljs-string">"saga transaction execute failed. XID: "</span> + inst.getId());</span><br><span class="line">    System.out.println(<span class="hljs-string">"saga transaction commit succeed. XID: "</span> + inst.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方这个方法中有同步和异步的案例，我这里把同步的那几行代码删了，我们就来看异步的。</p><p>首先前面 startParams 就是项目的参数，在上面 JSON 分析中，每个方法（reduce、compensateReduce）都有参数，参数就是这。</p><p>接下来调用状态机的 startWithBusinessKeyAsync 方法开始各个流程的执行，这个方法的第一个参数就是流程的名字，也就是我们前面说的 JSON 中的 name，通过这个名字就可以确定是执行哪一个流程，startParams 也是在这里传进去。</p><p>waittingForFinish 是一个自定的阻塞方法，目的是使流程执行完，以便获取事务的执行结果，这就是基本的线程知识，我这里就不强调了，大家可以自行下载源码查看。</p><p>最后通过断言判断事务的执行状态（<code>inst.getStatus()</code>）并打印相关日志。</p><p>接下来我们再来看二阶段回滚的方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">transactionCompensatedDemo</span><span class="hljs-params">(StateMachineEngine stateMachineEngine)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; startParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">4</span>);</span><br><span class="line">    String businessKey = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    startParams.put(<span class="hljs-string">"businessKey"</span>, businessKey);</span><br><span class="line">    startParams.put(<span class="hljs-string">"count"</span>, <span class="hljs-number">10</span>);</span><br><span class="line">    startParams.put(<span class="hljs-string">"amount"</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"100"</span>));</span><br><span class="line">    startParams.put(<span class="hljs-string">"mockReduceBalanceFail"</span>, <span class="hljs-string">"true"</span>);</span><br><span class="line">    <span class="hljs-comment">//sync test</span></span><br><span class="line">    StateMachineInstance inst = stateMachineEngine.startWithBusinessKey(<span class="hljs-string">"reduceInventoryAndBalance"</span>, <span class="hljs-keyword">null</span>, businessKey, startParams);</span><br><span class="line">    Assert.isTrue(ExecutionStatus.SU.equals(inst.getCompensationStatus()), <span class="hljs-string">"saga transaction compensate failed. XID: "</span> + inst.getId());</span><br><span class="line">    System.out.println(<span class="hljs-string">"saga transaction compensate succeed. XID: "</span> + inst.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上个方法相比，这里就是多了一个 mockReduceBalanceFail 参数，在前面所说的那个 JSON 文件的定义中，定义了这个输入参数，大家看下面这段 JSON：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"ReduceBalance": &#123;</span><br><span class="line">    "Type": "ServiceTask",</span><br><span class="line">    "ServiceName": "balanceAction",</span><br><span class="line">    "ServiceMethod": "reduce",</span><br><span class="line">    "CompensateState": "CompensateReduceBalance",</span><br><span class="line">    "Input": [</span><br><span class="line">        "$.[businessKey]",</span><br><span class="line">        "$.[amount]",</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="hljs-attr">"throwException"</span> : <span class="hljs-string">"$.[mockReduceBalanceFail]"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "Output": &#123;</span><br><span class="line">        "compensateReduceBalanceResult": "$.#root"</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>可以看到这个输入参数中有 mockReduceBalanceFail，不过这里不是直接将其作为输入参数，而是将之转为了一个 Map，这个 Map 的 key 是 throwException，所以在 <code>BalanceActionImpl#reduce</code> 方法中会有如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">reduce</span><span class="hljs-params">(String businessKey, BigDecimal amount, Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(params != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-string">"true"</span>.equals(params.get(<span class="hljs-string">"throwException"</span>)))&#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"reduce balance failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="hljs-string">"reduce balance succeed, amount: "</span> + amount + <span class="hljs-string">", businessKey:"</span> + businessKey);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 throwException 的值为 true，就会抛出异常，此时就会触发事务的回滚。</p><p>再回到二阶段回滚的方法中，最后通过 <code>inst.getCompensationStatus()</code> 方法获取事务补偿操作的状态，如果该方法返回 true，表示事务的补偿操作执行成功。</p><p>案例中涉及到一些 Dubbo 的知识点我这里就不赘述了，这不是我们本文的主旨。</p><p>好啦，经过上面的分析，大家应该大致上明白了这个 Saga 到底是怎么玩的了。</p><h2 id="4-设计经验"><a href="#4-设计经验" class="headerlink" title="4. 设计经验"></a>4. 设计经验</h2><h3 id="4-1-允许空补偿"><a href="#4-1-允许空补偿" class="headerlink" title="4.1 允许空补偿"></a>4.1 允许空补偿</h3><p>空补偿就是原服务未执行，结果补偿服务执行了，当原服务出现超时、丢包等情况时或者在收到原服务请求之前先收到补偿请求，就可能会出现空补偿。</p><p>因此我们在服务设计时需要允许空补偿, 即没有找到要补偿的业务主键时返回补偿成功并将原业务主键记录下来，这也是案例中，无论是原服务还是补偿服务都有 businessKey 参数的原因。</p><h3 id="4-2-防悬挂控制"><a href="#4-2-防悬挂控制" class="headerlink" title="4.2 防悬挂控制"></a>4.2 防悬挂控制</h3><p>悬挂就是补偿服务比原服务先执行，出现的原因和前面说的差不多，所以我们需要在执行原服务时，要先检查一下当前业务主键是否已经在空补偿记录下来，如果已经被记录下来，说明补偿已经先执行了，此时我们可以停止原服务的执行。</p><h3 id="4-3-幂等控制"><a href="#4-3-幂等控制" class="headerlink" title="4.3 幂等控制"></a>4.3 幂等控制</h3><p>原服务与补偿服务都需要保证幂等性, 由于网络可能超时, 所以我们可能会设置重试策略，重试发生时要通过幂等控制，避免业务数据重复更新。如何保证幂等性，松哥之前公众号的文章中和大家聊过，这里就不再赘述了。</p><h3 id="4-4-缺乏隔离性的应对"><a href="#4-4-缺乏隔离性的应对" class="headerlink" title="4.4 缺乏隔离性的应对"></a>4.4 缺乏隔离性的应对</h3><p>由于 Saga 事务不保证隔离性, 在极端情况下可能由于脏写无法完成回滚操作。</p><p>举一个极端的例子, 分布式事务内先给用户 A 充值, 然后给用户 B 扣减余额, 如果在给 A 用户充值成功, 在事务提交以前, A 用户把余额消费掉了, 如果事务发生回滚, 这时则没有办法进行补偿了。这就是缺乏隔离性造成的典型的问题。</p><p>对于这种问题，我们可以通过如下方式来尝试解决：</p><p>业务流程设计时遵循“宁可长款, 不可短款”的原则, 长款意思是客户少了钱机构多了钱, 以机构信誉可以给客户退款, 反之则是短款, 少的钱可能追不回来了。所以在业务流程设计上一定是先扣款。</p><p>有些业务场景可以允许让业务最终成功, 在回滚不了的情况下可以继续重试完成后面的流程, 所以状态机引擎除了提供“回滚”能力还需要提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的。</p><h3 id="4-5-性能优化"><a href="#4-5-性能优化" class="headerlink" title="4.5 性能优化"></a>4.5 性能优化</h3><p>配置客户端参数 <code>client.rm.report.success.enable=false</code>，可以在当分支事务执行成功时不上报分支状态到 server，从而提升性能。</p><p>当上一个分支事务的状态还没有上报的时候，下一个分支事务已注册，可以认为上一个实际已成功</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>这就是 Seata 分布式事务中的 Saga 模式。至此，Seata 中的四种分布式事务模式松哥就都和大家扯完了，后面我在整一篇文章比较下这四种模式。</p><p>另外三篇传送门：</p><ul><li><a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA" target="_blank" rel="noopener">看了那么多博客，还是不懂 TCC，不妨看看这个案例！</a></li><li><a href="https://mp.weixin.qq.com/s/BJHmVkNrvNL87hBT8DM8vg" target="_blank" rel="noopener">XA 事务水很深，小伙子我怕你把握不住！</a></li></ul><p>公号后台回复 <code>seata-demo</code> 可以下载本文案例。</p><p>参考资料：</p><ul><li><a href="https://www.sofastack.tech/blog/sofa-channel-10-retrospect/" target="_blank" rel="noopener">https://www.sofastack.tech/blog/sofa-channel-10-retrospect/</a></li><li><a href="https://seata.io/zh-cn/docs/user/saga.html" target="_blank" rel="noopener">https://seata.io/zh-cn/docs/user/saga.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;Seata 一共提供了四种分布式事务的处理模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AT&lt;/li&gt;
&lt;li&gt;TCC&lt;/li&gt;
&lt;li&gt;XA&lt;/li&gt;
&lt;li&gt;Saga&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面三种松哥都和大家介绍过了，今天我们来看看 Saga 这种模式。如果大家对于前三种还不太熟悉，可以先看看之前的文章，传送门：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五分钟带你体验一把分布式事务！so easy！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;看了那么多博客，还是不懂 TCC，不妨看看这个案例！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BJHmVkNrvNL87hBT8DM8vg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XA 事务水很深，小伙子我怕你把握不住！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="http://www.javaboy.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://www.javaboy.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="seata" scheme="http://www.javaboy.org/tags/seata/"/>
    
      <category term="saga" scheme="http://www.javaboy.org/tags/saga/"/>
    
  </entry>
  
  <entry>
    <title>XA 事务水很深，小伙子我怕你把握不住！</title>
    <link href="http://www.javaboy.org/2021/0823/seata-xa.html"/>
    <id>http://www.javaboy.org/2021/0823/seata-xa.html</id>
    <published>2021-08-23T13:36:16.000Z</published>
    <updated>2021-10-20T14:11:55.703Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>分布式事务系列继续！</p><p>前面松哥和大家聊了 Seata 中的 TCC 模式以及 AT 模式，没看的小伙伴可以先看看：</p><ul><li><a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA" target="_blank" rel="noopener">看了那么多博客，还是不懂 TCC，不妨看看这个案例！</a></li></ul><a id="more"></a><p>今天我们来继续学习 XA 事务！</p><p>Seata 中支持四种不同的事务模式：AT、TCC、XA 以及 Saga，这四种不同的事务模式中，<strong>XA 是最与众不同的一个</strong>！为什么这么说，相信读完本文你就了解了。</p><h2 id="1-什么是-XA-规范"><a href="#1-什么是-XA-规范" class="headerlink" title="1. 什么是 XA 规范"></a>1. 什么是 XA 规范</h2><h3 id="1-1-什么是两阶段提交"><a href="#1-1-什么是两阶段提交" class="headerlink" title="1.1 什么是两阶段提交"></a>1.1 什么是两阶段提交</h3><p>我们先来稍微回顾一下两阶段提交。</p><p>先来看下面一张图：</p><p><img src="http://img.itboyhub.com/2021/07/20210818233345.png" alt></p><p>这张图里涉及到三个概念：</p><ul><li>AP：这个不用多说，AP 就是应用程序本身。</li><li>RM：RM 是资源管理器，也就是事务的参与者，大部分情况下就是指数据库，一个分布式事务往往涉及到多个 RM。</li><li>TM：TM 就是事务管理器，创建分布式事务并协调分布式事务中的各个子事务的执行和状态，子事务就是指在 RM 上执行的具体操作。</li></ul><p>那么什么是两阶段(Two-Phase Commit, 简称 2PC)提交？</p><p>两阶段提交说白了道理很简单，松哥举个简单例子来和大家说明两阶段提交：</p><p>比如下面一张图（在<a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a>一文中大家曾经见过这张图）：</p><p><img src="http://img.itboyhub.com/2021/07/20210810204721.png" alt></p><p>在<a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a>一文中，我们在 Business 中分别调用 Storage 与 Order、Account，这三个中的操作要同时成功或者同时失败，但是由于这三个分处于不同服务，因此我们只能先让这三个服务中的操作各自执行，三个服务中的事务各自执行就是两阶段中的第一阶段。</p><p>第一阶段执行完毕后，先不要急着提交，因为三个服务中有的可能执行失败了，此时需要三个服务各自把自己一阶段的执行结果报告给一个事务协调者（也就是前面文章中的 Seata Server），事务协调者收到消息后，如果三个服务的一阶段都执行成功了，此时就通知三个事务分别提交，如果三个服务中有服务执行失败了，此时就通知三个事务分别回滚。</p><p>这就是所谓的两阶段提交。</p><p>总结一下：两阶段提交中，事务分为参与者（例如上图的各个具体服务）与协调者（上文案例中的 Seata Server），参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是要提交操作还是中止操作，这里的参与者可以理解为 RM，协调者可以理解为 TM。</p><p>不过 Seata 中的各个分布式事务模式，基本都是在二阶段提交的基础上演化出来的，因此并不完全一样，这点需要小伙伴们注意。</p><h3 id="1-2-什么是-XA-规范"><a href="#1-2-什么是-XA-规范" class="headerlink" title="1.2 什么是 XA 规范"></a>1.2 什么是 XA 规范</h3><p>XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准。</p><p>XA 规范描述了全局的事务管理器与局部的资源管理器之间的接口。 XA规范的目的是允许的多个资源（如数据库，应用服务器，消息队列等）在同一事务中访问，这样可以使 <strong>ACID</strong> 属性跨越应用程序而保持有效。</p><p>XA 规范使用两阶段提交来保证所有资源同时提交或回滚任何特定的事务。</p><p>XA 规范在上世纪 90 年代初就被提出。目前，几乎所有主流的数据库都对 XA 规范提供了支持。</p><p>XA 事务的基础是两阶段提交协议。需要有一个事务协调者来保证所有的事务参与者都完成了准备工作(第一阶段)。如果协调者收到所有参与者都准备好的消息，就会通知所有的事务都可以提交了（第二阶段）。MySQL 在这个 XA 事务中扮演的是参与者的角色，而不是协调者(事务管理器)。</p><p>MySQL 的 XA 事务分为内部 XA 和外部 XA。外部 XA 可以参与到外部的分布式事务中，需要应用层介入作为协调者；内部 XA 事务用于同一实例下跨多引擎事务，由 Binlog 作为协调者，比如在一个存储引擎提交时，需要将提交信息写入二进制日志，这就是一个分布式内部 XA 事务，只不过二进制日志的参与者是 MySQL 本身。 MySQL 在 XA 事务中扮演的是一个参与者的角色，而不是协调者。</p><h2 id="2-MySQL-中的-XA"><a href="#2-MySQL-中的-XA" class="headerlink" title="2. MySQL 中的 XA"></a>2. MySQL 中的 XA</h2><p>接下来松哥通过一个简单的例子先给大家看下 MySQL 中的 XA 是怎么玩的。</p><h3 id="2-1-两阶段事务提交"><a href="#2-1-两阶段事务提交" class="headerlink" title="2.1 两阶段事务提交"></a>2.1 两阶段事务提交</h3><p>比如说我们<a href="https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA" target="_blank" rel="noopener">上文</a>中的转账操作，我用 MySQL 中的 XA 事务来和大家演示一下从一个账户中转出 10 块钱：</p><p><img src="http://img.itboyhub.com/2021/07/20210818220555.png" alt></p><p>上面这段事务提交是一个两阶段事务提交的案例。</p><p>具体执行步骤如下：</p><ol><li><code>XA START &quot;transfer_money&quot;</code>：这个表示开启一个 XA 事务，后面的字符串是事务的 xid，这是一个唯一字符串，开启之后，事务的状态变为 <code>ACTIVE</code>。</li><li><code>update account set amount=amount-10 where account_no=&#39;A&#39;</code>; 这个表示执行具体的 SQL。</li><li><code>XA END &quot;transfer_money&quot;</code>：这个表示结束一个 XA 事务，此时事务的状态转为 <code>IDLE</code>。</li><li><code>XA PREPARE &quot;transfer_money&quot;</code>：这个将事务置为 PREPARE 状态。</li><li><code>XA COMMIT &quot;transfer_money&quot;</code>：这个用来提交事务，提交之后，事务的状态就是 COMMITED。</li></ol><p>最后一步，可以通过 <code>XA COMMIT</code> 来提交，也可以通过 <code>XA ROLLBACK</code> 来回滚，回滚后事务的状态就是 ROLLBACK。</p><p><strong>另外第四步可以省略，即一个 IDLE 状态的 XA 事务可以直接提交或者回滚。</strong></p><p>我们来看下面一张流程图：</p><p><img src="http://img.itboyhub.com/2021/07/20210818230349.png" alt></p><p>从这张图里我们可以看出，事务可以一步提交，也可以两阶段提交，都是支持的。如果是两阶段提交，prepare 之后，其实是在等其他的资源管理器（RM）反馈结果。</p><h3 id="2-2-事务直接提交"><a href="#2-2-事务直接提交" class="headerlink" title="2.2 事务直接提交"></a>2.2 事务直接提交</h3><p>松哥再给大家演示一下事务一步提交：</p><p><img src="http://img.itboyhub.com/2021/07/20210818232232.png" alt></p><p>这个就比较简单，没啥好说的。</p><p>这块再跟大家介绍另外一个 XA 事务相关的命令 <code>XA RECOVER</code>，如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20210818232537.png" alt></p><p><code>XA RECOVER</code> 可以列出所有处于 PREPARE 状态的 XA 事务，其他状态的事务则都不会列出来，如上图。</p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>在用一个客户端环境下，XA 事务和本地(非 XA )事务互相排斥，如果已经通过 XA START 来开启一个事务，则本地事务不会被启动，直到 XA 事务被提交或者被回滚为止。</p><p>相反的，如果已经使用 START TRANSACTION 启动一个本地事务，则 XA 语句不能被使用，直到该事务被提交或者回滚为止，而且 XA 事务仅仅被 InnoDB 存储引擎支持。</p><h2 id="3-Seata-中的-XA"><a href="#3-Seata-中的-XA" class="headerlink" title="3. Seata 中的 XA"></a>3. Seata 中的 XA</h2><h3 id="3-1-Seata-中的-XA-模式"><a href="#3-1-Seata-中的-XA-模式" class="headerlink" title="3.1 Seata 中的 XA 模式"></a>3.1 Seata 中的 XA 模式</h3><p>我们先来看一点理论知识，3.2 小节我们再来看代码实践。</p><p>通过上面的介绍，大家已经知道了 MySQL 中的 XA 事务是怎么回事了，Seata 中的 XA 模式其实就是在 MySQL 中 XA 模式的基础上实现的。Seata 中的 XA 模式就是在 Seata 定义的分布式事务框架内，利用事务资源（数据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一种事务模式。</p><p>我们来看下面一张图：</p><p><img src="http://img.itboyhub.com/2021/07/20210819231216.png" alt></p><p>我来大概说一下这个执行步骤：</p><ol><li>首先由 TM 开启全局分布式事务。</li><li>各个业务 SQL 分别放在不同的 XA 分支中进行，具体执行的流程就是 <code>XA Start</code>-&gt;<code>业务 SQL</code>-&gt;<code>XA End</code>，这个流程跟我 2.1 小节和大家演示的 MySQL 中 XA 事务的流程是一致的。</li><li>分支中的 XA 事务执行完成后，执行 <code>XA prepare</code>，并将自己执行的状态报告给 TC。</li><li>其他的分支事务均按照 2、3 步骤来执行。</li><li>当所有分支事务都执行完毕后，TC 也收到了各个分支事务报告上来的执行状态，如果所有状态都 OK，则 TC 通知所有 RM 执行 <code>XA Commit</code> 完成事务的最终提交，否则 TC 通知所有 RM 执行 <code>XA Rollback</code> 进行事务回滚。</li></ol><p>这就是 Seata 中的 XA 模式！只要小伙伴们理解了 2.2 小节中 MySQL 的 XA 模式，那么 Seata 中的 XA 模式就很好理解了。</p><h3 id="3-2-代码实践"><a href="#3-2-代码实践" class="headerlink" title="3.2 代码实践"></a>3.2 代码实践</h3><p>接下来我们来看一下代码实践，通过一个具体的案例来看下 Seata 中的 XA 模式。</p><p>这里我们依然是使用官方的案例，案例的业务和 AT 的业务是一样的，也是一个下单案例，如果小伙伴们对这个案例的业务不熟悉，可以先看看<a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a>一文。</p><p>不过还是我之前说的，官方案例中的依赖较多，下载容易出错，并且有些依赖存在版本冲突，需要自行解决之后才能运行起来，所以松哥这里自己也整理了一套，如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210821220203.png" alt></p><p>小伙伴们可以在公众号后台回复 <code>seata-demo</code> 下载这个案例，下载之后可以直接运行。</p><p>这里案例代码这块的问题，另外数据库这块也需要我们提前准备下。</p><p>首先大家看到案例中有一个 sql 目录，这个目录下有对应的数据库脚本 all_in_one.sql，我们在数据库中创建一个名为 <code>seata_xa</code> 的数据库，然后在数据库中执行该脚本。</p><p>执行完成后，会生成三张表：</p><p><img src="http://img.itboyhub.com/2021/07/20210821221042.png" alt></p><p>和 AT 模式相比，这里就少了一张 <code>undo_log</code> 表，原因很简单，AT 二阶段回滚用的是反向补偿（通过更新语句将数据复原），而 XA 则是利用数据库自己的 XA 模式，通过 <code>XA ROLLBACK</code> 命令回滚的，所以 XA 模式不需要 <code>undo_log</code> 表。</p><p>接下来分别修改 <code>account-xa</code>、<code>order-xa</code>、<code>storage-xa</code> 以及 <code>business-xa</code> 四个模块的 application.properties 配置文件，将数据库连接地址改对，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:///seata_xa?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123</span><br></pre></td></tr></table></figure><p>修改完成后，准备工作就算做好啦，接下来就是项目启动了（<code>business-xa</code> 启动成功后会自动完成数据的初始化）。</p><p>首先需要确保你的 seata-server 是启动状态的，seata-server 的启动还需要 eureka 的支持，这个大家具体可以参考<a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a>一文。</p><p>然后分别启动 <code>account-xa</code>、<code>order-xa</code>、<code>storage-xa</code> 以及 <code>business-xa</code> 模块。</p><p>项目启动成功后，然后访问如下地址完成一个购买操作：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8084/purchase</span><br></pre></td></tr></table></figure><p>这是一个成功的购买操作，即事务的二阶段会提交而不是回滚，访问后浏览器响应如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210821232630.png" alt></p><p>接下来我们可以添加一个访问参数 count，表示购买的商品数量，这里设置要购买的商品数量为 999（实际上并没有这么多商品），因此在事务二阶段提交的时候会回滚。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8084/purchase?count=999</span><br></pre></td></tr></table></figure><p>访问后浏览器响应如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210821232707.png" alt></p><p>这就是通过 Seata XA 模式来处理分布式事务。</p><h3 id="3-3-代码简析"><a href="#3-3-代码简析" class="headerlink" title="3.3 代码简析"></a>3.3 代码简析</h3><p>可能有小伙伴觉得 XA 和 AT 很像，代码层面上确实很像！但是原理却差着十万八千里。</p><p>和 Seata AT 模式相比，Seata XA 模式主要是修改一下数据源，大家可以注意，<code>account-xa</code>、<code>order-xa</code> 以及 <code>storage-xa</code> 三个微服务的数据源都是 DataSourceProxyXA，以 <code>order-xa</code> 模式为例，数据源配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderXADataSourceConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title">druidDataSource</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"dataSourceProxy"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(DruidDataSource druidDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// DataSourceProxy for AT mode</span></span><br><span class="line">        <span class="hljs-comment">// return new DataSourceProxy(druidDataSource);</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// DataSourceProxyXA for XA mode</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxyXA(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"jdbcTemplate"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">(DataSource dataSourceProxy)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSourceProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里使用的数据源并非原生的数据源，而是经过包装后的 DataSourceProxyXA。</p><p>如果仅仅从代码层面来讲，把 DataSourceProxyXA 换成 DataSourceProxy 就是 AT 模式了，把 DataSourceProxy 换成 DataSourceProxyXA 就是 XA 模式了，就是这么简单！</p><p>这个案例中其他地方的代码基本上都是 AT 模式一样，所以我这里也就不啰嗦了。不过有一点需要注意，就是 <code>business-xa</code> 模块的数据源并没有使用 DataSourceProxyXA，原因在于该模块中配置数据源主要是为了初始化数据，并不涉及分布式事务。</p><p>另外需要注意，在各个分支事务上，需要通过 @Transactional 注解来开启事务，开启之后，就会按照 XA 的那一套来，否则出问题了该服务不会回滚，默认情况下，只有 <code>account-xa</code> 模块加了该注解，小伙伴们在具体测试过程中，可以给其他模块也加上该注解，并进行测试查看效果。</p><h2 id="4-XA-的几个问题"><a href="#4-XA-的几个问题" class="headerlink" title="4. XA 的几个问题"></a>4. XA 的几个问题</h2><p>XA 模式有几个被人广泛诟病的问题，我们一起来了解下。</p><ol><li>数据锁定</li></ol><p>当使用 XA 事务时，数据在整个事务处理过程结束前，都被锁定，读写都按隔离级别的定义约束起来。这确实是 XA 模式的一个劣势，不过这也是获得更高隔离性和全局一致性所要付出的代价。松哥前面和大家分享的补偿型事务处理机制（AT、TCC）虽然不存在这个问题，但是却牺牲了隔离性。AT 模式使用全局锁保障基本的写隔离，实际上也是锁定数据的，只不过锁在 TC 侧集中管理，解锁效率高且没有阻塞的问题。</p><ol start="2"><li>协议阻塞</li></ol><p>XA prepare 后，分支事务进入阻塞阶段，收到 XA commit 或 XA rollback 前必须阻塞等待。议的阻塞机制本身并不是问题，关键问题在于协议阻塞遇上数据锁定，如果一个参与全局事务的资源 “失联” 了（收不到分支事务结束的命令），那么它锁定的数据，将一直被锁定，进而可能因此产生死锁。这是 XA 协议的核心痛点，也是 Seata 引入 XA 模式要重点解决的问题，Seata 中主要是解决了失联问题，并通过增加自解锁机制来解决这个问题。</p><ol start="3"><li>性能差</li></ol><p>这可能是被诟病最多的地方了，XA 模式性能的损耗主要来自两个方面：一方面，事务协调过程，增加单个事务的 RT；另一方面，并发事务数据的锁冲突，降低吞吐。</p><p>和不使用分布式事务支持的运行场景比较，性能肯定是下降的，这点毫无疑问。本质上，事务（无论是本地事务还是分布式事务）机制就是拿部分 性能的牺牲 ，换来 编程模型的简单。与同为业务无侵入的 AT 模式比较：</p><ul><li>同样运行在 Seata 定义的分布式事务框架下，XA 模式并没有产生更多事务协调的通信开销。</li><li>并发事务间，如果数据存在热点，产生锁冲突，这种情况，在 AT 模式（默认使用全局锁）下同样存在的。</li></ul><p>所以，在影响性能的两个主要方面，XA 模式并不比 AT 模式有非常明显的劣势。</p><p>AT 模式性能优势主要在于：集中管理全局数据锁，锁的释放不需要 RM 参与，释放锁非常快；另外，全局提交的事务，完成阶段 异步化。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>在当前的技术发展阶段，不存一个分布式事务处理机制可以完美满足所有场景的需求。</p><p>一致性、可靠性、易用性、性能等诸多方面的系统设计约束，需要用不同的事务处理机制去满足。</p><p>Seata 项目最核心的价值在于：构建一个全面解决分布式事务问题的标准化平台。</p><p>基于 Seata，上层应用架构可以根据实际场景的需求，灵活选择合适的分布式事务解决方案。</p><p><img src="http://img.itboyhub.com/2021/07/20210822003410.png" alt></p><p>参考资料：</p><ol><li><a href="https://seata.io/zh-cn/blog/seata-xa-introduce.html" target="_blank" rel="noopener">https://seata.io/zh-cn/blog/seata-xa-introduce.html</a></li><li><a href="https://www.cnblogs.com/duyanming/p/7326960.html" target="_blank" rel="noopener">https://www.cnblogs.com/duyanming/p/7326960.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;分布式事务系列继续！&lt;/p&gt;
&lt;p&gt;前面松哥和大家聊了 Seata 中的 TCC 模式以及 AT 模式，没看的小伙伴可以先看看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;五分钟带你体验一把分布式事务！so easy！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/83-I7hPDuWRTTfrldHJ0VA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;看了那么多博客，还是不懂 TCC，不妨看看这个案例！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="http://www.javaboy.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://www.javaboy.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="seata" scheme="http://www.javaboy.org/tags/seata/"/>
    
      <category term="xa" scheme="http://www.javaboy.org/tags/xa/"/>
    
  </entry>
  
  <entry>
    <title>看了那么多博客，还是不懂 TCC，不妨看看这个案例！</title>
    <link href="http://www.javaboy.org/2021/0819/seata-tcc.html"/>
    <id>http://www.javaboy.org/2021/0819/seata-tcc.html</id>
    <published>2021-08-19T13:35:59.000Z</published>
    <updated>2021-10-20T14:11:47.033Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>还是那句老话，网上关于分布式事务讲解理论比较多，案例比较少，最近松哥想通过几个案例，来和大家把常见的分布式事务解决方案过一遍，前面我和大家分享了 Seata 中的 AT 模式，今天我们来看 TCC 模式。</p><a id="more"></a><p>TCC 模式和松哥前面跟大家演示的 AT 模式有很多相似的地方，也有很多不同的地方，之前读者麻瓜大佬投稿过一篇文章讲 TCC 模式：</p><ul><li><a href="https://mp.weixin.qq.com/s/WdiGEriMLx4RyafPsvjXaA" target="_blank" rel="noopener">分布式事务 TCC 原来是这么来的！</a></li></ul><p>感兴趣的小伙伴也可以先看看。</p><p>今天我们还是先来整一个案例，把案例分析完了，大家基本上就明白 TCC 是咋回事了，同时也就明白 TCC 和 AT 之间的差异了。</p><h2 id="1-上代码"><a href="#1-上代码" class="headerlink" title="1. 上代码"></a>1. 上代码</h2><p>还是 Seata 官方的那个仓库，它里边有 TCC 的案例，不过由于它这个仓库案例较多，需要下载的依赖也较多，所以全部导入会容易导入失败，下面是松哥整理好的案例（去除了不必要的工程），可以直接导入，大家可以在公号后台回复 <code>seata-demo</code> 下载这个案例。</p><p><img src="http://img.itboyhub.com/2021/07/20210816145913.png" alt></p><p>官方给的 TCC 案例是一个经典的转账案例，很多小伙伴第一次接触事务的时候，学的案例就是转账，所以这个业务对于大家来说很好理解。</p><h3 id="1-1-业务流程"><a href="#1-1-业务流程" class="headerlink" title="1.1 业务流程"></a>1.1 业务流程</h3><p>我先来说一下这个案例的业务逻辑，然后我们再来看代码，他的流程是这样的：</p><ol><li>这个项目分两部分，provider 和 consumer（要是只有一个项目也就不存在分布式事务问题了）。</li><li>provider 中提供两个转账相关的接口，一个是负责处理扣除账户余额的接口，另一个则是负责给账户添加金额的接口。在该案例中，这两个项目中由一个 provider 提供，在实际操作中，小伙伴们也可以用两个 provider 来分别提供这两个接口。</li><li>provider 提供的接口通过 dubbo 暴露出去，consumer 则通过 dubbo 来引用这些暴露出来的接口。</li><li>转账操作分两步：首先调用 FirstTccAction 从一个账户中减除金额；然后调用 SecondTccAction 给一个账户增加金额。两个操作要么同时成功，要么同时失败。</li></ol><p><strong>有人可能会说，都是 provider 提供的接口，也算分布式事务？算！当然算！虽然上面提到的两个接口都是 provider 提供的，但是由于这里存在两个数据库，不同接口操作不同的数据库，所以依然是分布式事务。</strong></p><p>这是这个项目大致上要做的事情。</p><h3 id="1-2-案例配置"><a href="#1-2-案例配置" class="headerlink" title="1.2 案例配置"></a>1.2 案例配置</h3><p>官方的案例用的是 H2 数据库，这个大家不方便看效果，因此，我们这里稍微做一点配置，将数据库换为 MySQL，这样我们方便看转账效果。</p><p>具体配置步骤如下：</p><ol><li>首先在本地 MySQL 中创建两个数据库：</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210816161113.png" alt></p><p>创建两个空的库就行了，不用创建表，项目启动的时候会自动初始化表。</p><ul><li>transfer_from_db：转出账户的库。</li><li>transfer_to_db：转入账户的库。</li></ul><ol start="2"><li>修改项目的数据库连接池版本。</li></ol><p>官方给的案例有点小问题，直接启动会报错，原因在于案例中使用的 DBCP 和 MyBatis 版本冲突，需要大家先在 pom.xml 中把 DBCP 的版本号改为 1.4，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">curator.version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">curator.version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">commons-dbcp.version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">commons-dbcp.version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">h2.version</span>&gt;</span>1.4.181<span class="hljs-tag">&lt;/<span class="hljs-name">h2.version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.version</span>&gt;</span>3.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.version</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.spring.version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.spring.version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们再加入 MySQL 驱动，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然案例中有的东西有点像老古董了，但是本着能简则简的原则，我就不去修改了，咱们只要项目跑起来，能够帮助我们理解 TCC 就行了。</p><p>另外，这个项目引用的 Dubbo 版本也有问题，我们手动给其加上版本号(默认的 3.0.1 这个版本有问题，松哥亲测 2.7.3 可用)：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>修改数据库配置。</li></ol><p>数据库配置有两个，一个是转账转出数据源，另一个是转账转入数据源，相关配置在 <code>src/main/resources/db-bean</code> 目录下。</p><p><img src="http://img.itboyhub.com/2021/07/20210816172443.png" alt></p><p>先来修改 from-datasource-bean.xml，主要修改数据源，如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"fromAccountDataSource"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>jdbc:mysql:///transfer_from_db?serverTimezone=Asia/Shanghai<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改四个东西：数据库驱动、数据库连接地址、数据库用户名、数据库密码。</p><p>再来修改 to-datasource-bean.xml：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"toAccountDataSource"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">"close"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driverClassName"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>jdbc:mysql:///transfer_to_db?serverTimezone=Asia/Shanghai<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两个配置主要是连接的数据库不同。</p><p>OK，如此之后，我们的配置就算完成了。</p><h3 id="1-3-案例运行"><a href="#1-3-案例运行" class="headerlink" title="1.3 案例运行"></a>1.3 案例运行</h3><p>案例运行分为两部分。</p><h4 id="1-3-1-启动-Provider"><a href="#1-3-1-启动-Provider" class="headerlink" title="1.3.1 启动 Provider"></a>1.3.1 启动 Provider</h4><p>找到 <code>src/main/java/io/seata/samples/tcc/transfer/starter/TransferProviderStarter.java</code>，执行 main 方法，直接执行即可，执行之后，控制台看到如下信息就表示项目启动成功并且表结构以及表数据初始化成功：</p><p><img src="http://img.itboyhub.com/2021/07/20210816180710.png" alt></p><p>启动过程中，可能会有一个空指针异常，不过并不影响使用，所以可以忽略之。</p><p>项目启动成功之后，我们可以查看一下刚刚创建好的两个数据库，每个数据库里边都有三张表：</p><p>先来看转出的库：</p><p><img src="http://img.itboyhub.com/2021/07/20210816182437.png" alt></p><p>account 表中有两条记录：</p><p><img src="http://img.itboyhub.com/2021/07/20210816182536.png" alt></p><p>这张表中有 A、B 两个账户，各有 100 块钱，各自被冻结的资金（freezed_amount）都为 0。</p><p>business_action 和 business_activity 都是空表。</p><p>再来看转入的库：</p><p><img src="http://img.itboyhub.com/2021/07/20210816182805.png" alt></p><p>可以看到，和 transfer_from_db 一模一样的三张表，就是 account 中的用户是 C，也有 100 块钱。</p><h4 id="1-3-2-开启转账逻辑"><a href="#1-3-2-开启转账逻辑" class="headerlink" title="1.3.2 开启转账逻辑"></a>1.3.2 开启转账逻辑</h4><p>找到 <code>src/main/java/io/seata/samples/tcc/transfer/starter/TransferApplication.java</code> ，这个里边的 main 方法中有两个测试方法，<code>doTransferSuccess</code> 会转账成功，<code>doTransferFailed</code> 则会转账失败。</p><p>这两个方法我们首先注释掉 <code>doTransferFailed</code>，运行 <code>doTransferSuccess</code> 方法，控制台输出日志如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210816182159.png" alt></p><p>这表示转账成功。</p><p>此时查看数据库，A 账户少了 10 块钱，C 账户多了 10 块钱：</p><p><img src="http://img.itboyhub.com/2021/07/20210816183400.png" alt><br><img src="http://img.itboyhub.com/2021/07/20210816183430.png" alt></p><p>然后我们注释掉 <code>doTransferSuccess</code> ，运行 <code>doTransferFailed</code> 方法，结果如下：</p><p><img src="http://img.itboyhub.com/2021/07/20210816182326.png" alt></p><p>可以看到，转账失败，此时查看数据库，发现两个库中的数据均未发生改变，说明数据已经回滚了。</p><p>好啦，这就是官方给我们提供的一个典型的转账案例。那么这个转账案例是怎么实现的？接下来我们来分析一下代码，代码分析完了，大家就明白什么是 TCC 了！</p><h2 id="2-代码分析"><a href="#2-代码分析" class="headerlink" title="2. 代码分析"></a>2. 代码分析</h2><p>这里关于 Dubbo 的调用逻辑，松哥就不多说了，相信大家都会，咱们主要来说说跟分布式事务相关的代码。</p><p>首先，这个项目中提供了两个接口：</p><ul><li>FirstTccAction</li><li>SecondTccAction</li></ul><p>这两个接口分别代表了转账时候的两个步骤：</p><ul><li>FirstTccAction：这个接口中用来处理转出账户余额问题（减钱），这个接口中使用的数据源就是 transfer_from_db。</li><li>SecondTccAction：这个接口用来处理转入账户问题（加钱），这个接口中使用的数据源就是 transfer_to_db。</li></ul><p>这两个接口的定义其实非常类似，只要我们看懂其中一个，另外一个就很容易懂了。</p><h3 id="2-1-FirstTccAction"><a href="#2-1-FirstTccAction" class="headerlink" title="2.1 FirstTccAction"></a>2.1 FirstTccAction</h3><p>这是把钱转出去的接口，我们先来看接口的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">FirstTccAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 一阶段方法</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessActionContext</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> accountNo</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@TwoPhaseBusinessAction</span>(name = <span class="hljs-string">"firstTccAction"</span>, commitMethod = <span class="hljs-string">"commit"</span>, rollbackMethod = <span class="hljs-string">"rollback"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">prepareMinus</span><span class="hljs-params">(BusinessActionContext businessActionContext,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                @BusinessActionContextParameter(paramName = <span class="hljs-string">"accountNo"</span>)</span> String accountNo,</span></span><br><span class="line"><span class="hljs-function">                                @<span class="hljs-title">BusinessActionContextParameter</span><span class="hljs-params">(paramName = <span class="hljs-string">"amount"</span>)</span> <span class="hljs-keyword">double</span> amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 二阶段提交</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessActionContext</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">(BusinessActionContext businessActionContext)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 二阶段回滚</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessActionContext</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">rollback</span><span class="hljs-params">(BusinessActionContext businessActionContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，接口中有三个方法：</p><ol><li>prepareMinus</li><li>commit</li><li>rollback</li></ol><p>这三个方法的名字并不是固定的，可以自己定义，我们来看这三个方法是干嘛的（实现类是 FirstTccActionImpl）：</p><ol><li>prepareMinus：这个方法看名字就知道可以在该方法中做准备工作，转账的准备工作都是什么呢？检查账户是否存在、冻结转账资金等等操作都可以在这个方法中完成。以上面的案例为例（A 账户转账 10 块钱到 C 账户），具体来说，在 <code>FirstTccActionImpl#prepareMinus</code> 方法中：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">prepareMinus</span><span class="hljs-params">(BusinessActionContext businessActionContext, <span class="hljs-keyword">final</span> String accountNo, <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//分布式事务ID</span></span><br><span class="line">    <span class="hljs-keyword">final</span> String xid = businessActionContext.getXid();</span><br><span class="line">    <span class="hljs-keyword">return</span> fromDsTransactionTemplate.execute(<span class="hljs-keyword">new</span> TransactionCallback&lt;Boolean&gt;()&#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-comment">//校验账户余额</span></span><br><span class="line">                Account account = fromAccountDAO.getAccountForUpdate(accountNo);</span><br><span class="line">                <span class="hljs-keyword">if</span>(account == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"账户不存在"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">if</span> (account.getAmount() - amount &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"余额不足"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">//冻结转账金额</span></span><br><span class="line">                <span class="hljs-keyword">double</span> freezedAmount = account.getFreezedAmount() + amount;</span><br><span class="line">                account.setFreezedAmount(freezedAmount);</span><br><span class="line">                fromAccountDAO.updateFreezedAmount(account);</span><br><span class="line">                System.out.println(String.format(<span class="hljs-string">"prepareMinus account[%s] amount[%f], dtx transaction id: %s."</span>, accountNo, amount, xid));</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就干了三件事：1.检查 A 账户是否存在，不存在就抛异常；2.检查 A 账户余额是否小于 10 块钱，如果是，抛异常（钱不够，没法转账）；3.修改 A 账户的数据库记录，将冻结资金标记出来（A 账户的 freezed_amount 字段将被修改为 10）。</p><ol start="2"><li>prepareMinus 方法所做的事情都属于一阶段的事情。</li><li>prepareMinus 方法有一个 @TwoPhaseBusinessAction 注解，用来标记事务，该注解中，commitMethod 注解表示事务提交的方法，rollbackMethod 表示事务回滚的方法，这两个方法都是该事务中定义的方法。</li><li>prepareMinus 方法是由开发者自己调用，因此可以自定义参数传进来，而 commit 和 rollback 方法则是由框架来调用（如果一阶段出问题了，二阶段自动回滚；一阶段没问题，二阶段就自动提交），但是在框架调用的时候，我们可能还是需要一些业务相关的参数，所以在 prepareMinus 方法中，我们可以通过 @BusinessActionContextParameter 注解来把在 commit 以及 rollback 中需要的参数绑定到 BusinessActionContext 中，将来在 commit 和 rollback 方法中就可以获取到这些参数。</li><li>commit 方法是二阶段提交的方法，如果一阶段的工作都顺利进行完了，则进行二阶段的事务提交。具体实现在 <code>FirstTccActionImpl#commit</code> 方法中：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">(BusinessActionContext businessActionContext)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//分布式事务ID</span></span><br><span class="line">    <span class="hljs-keyword">final</span> String xid = businessActionContext.getXid();</span><br><span class="line">    <span class="hljs-comment">//账户ID</span></span><br><span class="line">    <span class="hljs-keyword">final</span> String accountNo = String.valueOf(businessActionContext.getActionContext(<span class="hljs-string">"accountNo"</span>));</span><br><span class="line">    <span class="hljs-comment">//转出金额</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> amount = Double.valueOf(String.valueOf(businessActionContext.getActionContext(<span class="hljs-string">"amount"</span>)));</span><br><span class="line">    <span class="hljs-keyword">return</span> fromDsTransactionTemplate.execute(<span class="hljs-keyword">new</span> TransactionCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">                Account account = fromAccountDAO.getAccountForUpdate(accountNo);</span><br><span class="line">                <span class="hljs-comment">//扣除账户余额</span></span><br><span class="line">                <span class="hljs-keyword">double</span> newAmount = account.getAmount() - amount;</span><br><span class="line">                <span class="hljs-keyword">if</span> (newAmount &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"余额不足"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                account.setAmount(newAmount);</span><br><span class="line">                <span class="hljs-comment">//释放账户 冻结金额</span></span><br><span class="line">                account.setFreezedAmount(account.getFreezedAmount()  - amount);</span><br><span class="line">                fromAccountDAO.updateAmount(account);</span><br><span class="line">                System.out.println(String.format(<span class="hljs-string">"minus account[%s] amount[%f], dtx transaction id: %s."</span>, accountNo, amount, xid));</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;<span class="hljs-keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看这个方法的执行逻辑：</p><ul><li>首先从 BusinessActionContext 对象中把 prepareMinus 中的那几个参数拎出来。</li><li>然后判断一下账户余额是否充足（是否够转账）。</li><li>更新账户余额和冻结的金额（余额正常转账，冻结的金额归零）。</li></ul><p>这就是 commit 方法所做的事情。</p><ol start="6"><li>rollback 方法是二阶段的回滚方法，如果一阶段的方法执行出问题了，二阶段就要回滚，回滚要做的事情就是反向补偿操作，具体实现在 <code>FirstTccActionImpl#rollback</code> 方法中：</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">rollback</span><span class="hljs-params">(BusinessActionContext businessActionContext)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//分布式事务ID</span></span><br><span class="line">    <span class="hljs-keyword">final</span> String xid = businessActionContext.getXid();</span><br><span class="line">    <span class="hljs-comment">//账户ID</span></span><br><span class="line">    <span class="hljs-keyword">final</span> String accountNo = String.valueOf(businessActionContext.getActionContext(<span class="hljs-string">"accountNo"</span>));</span><br><span class="line">    <span class="hljs-comment">//转出金额</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> amount = Double.valueOf(String.valueOf(businessActionContext.getActionContext(<span class="hljs-string">"amount"</span>)));</span><br><span class="line">    <span class="hljs-keyword">return</span> fromDsTransactionTemplate.execute(<span class="hljs-keyword">new</span> TransactionCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">                Account account = fromAccountDAO.getAccountForUpdate(accountNo);</span><br><span class="line">                <span class="hljs-keyword">if</span>(account == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                    <span class="hljs-comment">//账户不存在，回滚什么都不做</span></span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-comment">//释放冻结金额</span></span><br><span class="line">                account.setFreezedAmount(account.getFreezedAmount()  - amount);</span><br><span class="line">                fromAccountDAO.updateFreezedAmount(account);</span><br><span class="line">                System.out.println(String.format(<span class="hljs-string">"Undo prepareMinus account[%s] amount[%f], dtx transaction id: %s."</span>, accountNo, amount, xid));</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;<span class="hljs-keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">                t.printStackTrace();</span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，回滚的反向补偿其实很简单，先看下账户是否存在，账户存在的话，把冻结的资金取消冻结就行了。</p><p>这就是把钱转出去的整个过程。</p><h3 id="2-2-SecondTccAction"><a href="#2-2-SecondTccAction" class="headerlink" title="2.2 SecondTccAction"></a>2.2 SecondTccAction</h3><p>这是把钱转进来的接口。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecondTccAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 一阶段方法</span></span><br><span class="line"><span class="hljs-comment">     * </span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessActionContext</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> accountNo</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@TwoPhaseBusinessAction</span>(name = <span class="hljs-string">"secondTccAction"</span>, commitMethod = <span class="hljs-string">"commit"</span>, rollbackMethod = <span class="hljs-string">"rollback"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">prepareAdd</span><span class="hljs-params">(BusinessActionContext businessActionContext,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                              @BusinessActionContextParameter(paramName = <span class="hljs-string">"accountNo"</span>)</span> String accountNo,</span></span><br><span class="line"><span class="hljs-function">                              @<span class="hljs-title">BusinessActionContextParameter</span><span class="hljs-params">(paramName = <span class="hljs-string">"amount"</span>)</span> <span class="hljs-keyword">double</span> amount)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 二阶段提交</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessActionContext</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">(BusinessActionContext businessActionContext)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 二阶段回滚</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessActionContext</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">rollback</span><span class="hljs-params">(BusinessActionContext businessActionContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondTccActionImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SecondTccAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 加钱账户 DAP</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> AccountDAO toAccountDAO;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> TransactionTemplate toDsTransactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 一阶段准备，转入资金 准备</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessActionContext</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> accountNo</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">prepareAdd</span><span class="hljs-params">(<span class="hljs-keyword">final</span> BusinessActionContext businessActionContext, <span class="hljs-keyword">final</span> String accountNo, <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//分布式事务ID</span></span><br><span class="line">        <span class="hljs-keyword">final</span> String xid = businessActionContext.getXid();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> toDsTransactionTemplate.execute(<span class="hljs-keyword">new</span> TransactionCallback&lt;Boolean&gt;()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    <span class="hljs-comment">//校验账户</span></span><br><span class="line">                    Account account = toAccountDAO.getAccountForUpdate(accountNo);</span><br><span class="line">                    <span class="hljs-keyword">if</span>(account == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="hljs-string">"prepareAdd: 账户["</span>+accountNo+<span class="hljs-string">"]不存在, txId:"</span> + businessActionContext.getXid());</span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-comment">//待转入资金作为 不可用金额</span></span><br><span class="line">                    <span class="hljs-keyword">double</span> freezedAmount = account.getFreezedAmount() + amount;</span><br><span class="line">                    account.setFreezedAmount(freezedAmount);</span><br><span class="line">                    toAccountDAO.updateFreezedAmount(account);</span><br><span class="line">                    System.out.println(String.format(<span class="hljs-string">"prepareAdd account[%s] amount[%f], dtx transaction id: %s."</span>, accountNo, amount, xid));</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 二阶段提交</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessActionContext</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">commit</span><span class="hljs-params">(BusinessActionContext businessActionContext)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//分布式事务ID</span></span><br><span class="line">        <span class="hljs-keyword">final</span> String xid = businessActionContext.getXid();</span><br><span class="line">        <span class="hljs-comment">//账户ID</span></span><br><span class="line">        <span class="hljs-keyword">final</span> String accountNo = String.valueOf(businessActionContext.getActionContext(<span class="hljs-string">"accountNo"</span>));</span><br><span class="line">        <span class="hljs-comment">//转出金额</span></span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> amount = Double.valueOf(String.valueOf(businessActionContext.getActionContext(<span class="hljs-string">"amount"</span>)));</span><br><span class="line">        <span class="hljs-keyword">return</span> toDsTransactionTemplate.execute(<span class="hljs-keyword">new</span> TransactionCallback&lt;Boolean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">                    Account account = toAccountDAO.getAccountForUpdate(accountNo);</span><br><span class="line">                    <span class="hljs-comment">//加钱</span></span><br><span class="line">                    <span class="hljs-keyword">double</span> newAmount = account.getAmount() + amount;</span><br><span class="line">                    account.setAmount(newAmount);</span><br><span class="line">                    <span class="hljs-comment">//冻结金额 清除</span></span><br><span class="line">                    account.setFreezedAmount(account.getFreezedAmount()  - amount);</span><br><span class="line">                    toAccountDAO.updateAmount(account);</span><br><span class="line"></span><br><span class="line">                    System.out.println(String.format(<span class="hljs-string">"add account[%s] amount[%f], dtx transaction id: %s."</span>, accountNo, amount, xid));</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;<span class="hljs-keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 二阶段回滚</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> businessActionContext</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">rollback</span><span class="hljs-params">(BusinessActionContext businessActionContext)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//分布式事务ID</span></span><br><span class="line">        <span class="hljs-keyword">final</span> String xid = businessActionContext.getXid();</span><br><span class="line">        <span class="hljs-comment">//账户ID</span></span><br><span class="line">        <span class="hljs-keyword">final</span> String accountNo = String.valueOf(businessActionContext.getActionContext(<span class="hljs-string">"accountNo"</span>));</span><br><span class="line">        <span class="hljs-comment">//转出金额</span></span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> amount = Double.valueOf(String.valueOf(businessActionContext.getActionContext(<span class="hljs-string">"amount"</span>)));</span><br><span class="line">        <span class="hljs-keyword">return</span> toDsTransactionTemplate.execute(<span class="hljs-keyword">new</span> TransactionCallback&lt;Boolean&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">                    Account account = toAccountDAO.getAccountForUpdate(accountNo);</span><br><span class="line">                    <span class="hljs-keyword">if</span>(account == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                        <span class="hljs-comment">//账户不存在, 无需回滚动作</span></span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-comment">//冻结金额 清除</span></span><br><span class="line">                    account.setFreezedAmount(account.getFreezedAmount()  - amount);</span><br><span class="line">                    toAccountDAO.updateFreezedAmount(account);</span><br><span class="line"></span><br><span class="line">                    System.out.println(String.format(<span class="hljs-string">"Undo prepareAdd account[%s] amount[%f], dtx transaction id: %s."</span>, accountNo, amount, xid));</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;<span class="hljs-keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看懂了上面的 FirstTccActionImpl，SecondTccActionImpl 这个接口松哥就不啰嗦了，简单说一下：</p><ol><li>在 prepareAdd 方法中，判断转入账户是否存在，如果存在的话，就把转入资金先存入冻结的那个字段中（不是直接加到账户余额上）。</li><li>在 commit 方法中，事务提交的时候，把冻结的资金加入到账户余额中，同时清除冻结金额。</li><li>在 rollback 方法中，事务回滚的时候，反向补偿把冻结的资金清除即可。</li></ol><p>这就是把钱收进来的大致过程。</p><h3 id="2-3-TransferServiceImpl"><a href="#2-3-TransferServiceImpl" class="headerlink" title="2.3 TransferServiceImpl"></a>2.3 TransferServiceImpl</h3><p>具体转账是在 TransferServiceImpl 类中，在它的 transfer 方法中，去调用 FirstTccAction 和 SecondTccAction，一起来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransferServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TransferService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> FirstTccAction firstTccAction;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> SecondTccAction secondTccAction;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 转账操作</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> from  扣钱账户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> to  加钱账户</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount  转账金额</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-meta">@GlobalTransactional</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transfer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String from, <span class="hljs-keyword">final</span> String to, <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//扣钱参与者，一阶段执行</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span> ret = firstTccAction.prepareMinus(<span class="hljs-keyword">null</span>, from, amount);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(!ret)&#123;</span><br><span class="line">            <span class="hljs-comment">//扣钱参与者，一阶段失败; 回滚本地事务和分布式事务</span></span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"账号:["</span>+from+<span class="hljs-string">"] 预扣款失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//加钱参与者，一阶段执行</span></span><br><span class="line">        ret = secondTccAction.prepareAdd(<span class="hljs-keyword">null</span>, to, amount);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(!ret)&#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"账号:["</span>+to+<span class="hljs-string">"] 预收款失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="hljs-string">"transfer amount[%s] from [%s] to [%s] finish."</span>, String.valueOf(amount), from, to));</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFirstTccAction</span><span class="hljs-params">(FirstTccAction firstTccAction)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.firstTccAction = firstTccAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSecondTccAction</span><span class="hljs-params">(SecondTccAction secondTccAction)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.secondTccAction = secondTccAction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一下具体的转账逻辑：</p><ol><li>首先注入刚刚的 FirstTccAction 和 SecondTccAction，如果这是一个微服务项目，那就在这里把各自的 Feign 搞进来。</li><li>transfer 方法就执行具体的转账逻辑，该方法加上 @GlobalTransactional 注解。这个方法中主要是去调用 prepareXXX 完成一阶段的事情，如果一阶段出问题了，那么就会抛出异常，则事务会回滚（二阶段），回滚就会自动调用 FirstTccAction 和 SecondTccAction 各自的 rollback 方法（反向补偿）；如果一阶段执行没问题，则二阶段就调用 FirstTccAction 和 SecondTccAction 的 commit 方法，完成提交。</li></ol><p>这就是大致的转账逻辑。</p><h2 id="3-TCC-Vs-AT"><a href="#3-TCC-Vs-AT" class="headerlink" title="3. TCC Vs AT"></a>3. TCC Vs AT</h2><p>经过上面的分析，相信小伙伴们对 TCC 已经有一些感觉了。</p><p>那么什么是 TCC？</p><p>TCC 是 Try-Confirm-Cancel 英文单词的简写。</p><p>在 TCC 模式中，一个事物是通过 Do-Commit/Rollback 来实现的，开发者需要给每一个服务间调用的操作接口，都提供一套 Try-Confirm/Cancel 接口，这套接口就类似于我们上面的 prepareXXX/commit/rollback 接口。</p><p>再举一个简化的电商案例，用户支付完成的时候由先订单服务处理，然后调用商品服务去减库存，这两个操作同时成功或者同时失败，这就涉及到分布式事务了：在 TCC 模式下，我们需要 3 个接口。首先是减库存的 Try 接口，在这里，我们要检查业务数据的状态、检查商品库存够不够，然后做资源的预留，也就是在某个字段上设置预留的状态，然后在 Confirm 接口里，完成库存减 1 的操作，在 Cancel 接口里，把之前预留的字段重置（预留的状态其实就类似于前面案例的冻结资金字段 <code>freezed_amount</code>）。</p><p>为什么搞得这么麻烦呢？分成三个步骤来做有一个好处，就是在出错的时候，能够顺利的完成数据库重置（反向补偿），并且，只要我们 prepare 中的逻辑是正确的，那么即使 confirm 执行出错了，我们也可以进行重试。</p><p>我们再来看下面一张图：</p><p><img src="http://img.itboyhub.com/2021/07/20210817195754.png" alt></p><p>根据两阶段行为模式的不同，我们将分支事务划分为 Automatic (Branch) Transaction Mode 和 TCC (Branch) Transaction Mode。</p><p>AT 模式基于支持本地 ACID 事务的关系型数据库：</p><ul><li>一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。</li><li>二阶段 commit 行为：马上成功结束，自动异步批量清理回滚日志。</li><li>二阶段 rollback 行为：通过回滚日志，自动 生成补偿操作，完成数据回滚。</li></ul><p>关于 AT 这块，如果小伙伴们不熟悉，可以参考松哥前面的文章：</p><ul><li><a href="https://mp.weixin.qq.com/s/47efAPrm10l1Bxn1zECwvA" target="_blank" rel="noopener">五分钟带你体验一把分布式事务！so easy！</a></li></ul><p>相应的，TCC 模式，不依赖于底层数据资源的事务支持：</p><ul><li>一阶段 prepare 行为：调用自定义的 prepare 逻辑。</li><li>二阶段 commit 行为：调用自定义的 commit 逻辑。</li><li>二阶段 rollback 行为：调用自定义的 rollback 逻辑。</li></ul><p>所谓 TCC 模式，是指支持把自定义的分支事务纳入到全局事务的管理中。</p><p>回顾前面的案例，小伙伴们发现，分布式事务两阶段提交，在 TCC 中，prepare、commit 以及 rollback 中的逻辑都是我们自己写的，因此说 TCC 不依赖于底层数据资源的事务支持。</p><p>相比于 AT 模式，TCC 需要我们自己实现 prepare、commit 以及 rollback 逻辑，而在 AT 模式中，commit 和 rollback 都不用我们去管，Seata 会自动帮我们完成。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，今天这篇文章松哥就和大家简单分享一下 Seata 中的 TCC 模式，建议小伙伴们一定先跑一下文章中的案例，然后再去看分析，就很容易懂了～</p><p>分布式事务的其他解决方案，我们后面再继续聊～</p><p>公众号江南一点雨后台回复 <code>seata-demo</code>，可以下载本文案例。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;还是那句老话，网上关于分布式事务讲解理论比较多，案例比较少，最近松哥想通过几个案例，来和大家把常见的分布式事务解决方案过一遍，前面我和大家分享了 Seata 中的 AT 模式，今天我们来看 TCC 模式。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="http://www.javaboy.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://www.javaboy.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="seata" scheme="http://www.javaboy.org/tags/seata/"/>
    
      <category term="tcc" scheme="http://www.javaboy.org/tags/tcc/"/>
    
  </entry>
  
  <entry>
    <title>五分钟带你体验一把分布式事务！so easy！</title>
    <link href="http://www.javaboy.org/2021/0816/seata-at.html"/>
    <id>http://www.javaboy.org/2021/0816/seata-at.html</id>
    <published>2021-08-16T13:35:44.000Z</published>
    <updated>2021-10-20T14:11:39.504Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>网上关于分布式事务讲理论的多，讲实战的少，今天我想通过一个案例，来让小伙伴们感受一把分布式事务，咱们今天尽量少谈点理论。咱们今天的主角是 Seata！</p><p>分布式事务涉及到很多理论，如 CAP，BASE 等，很多小伙伴刚看到这些理论就被劝退了，所以我们今天不讲理论，咱们就看个 Demo，通过代码快速体验一把什么是分布式事务。</p><a id="more"></a><h2 id="1-什么是-Seata？"><a href="#1-什么是-Seata？" class="headerlink" title="1. 什么是 Seata？"></a>1. 什么是 Seata？</h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><p>Seata 支持的事务模式有四种分别是:</p><ul><li>Seata AT 模式</li><li>Seata TCC 模式</li><li>Seata Saga 模式</li><li>Seata XA 模式</li></ul><p>Seata 中有三个核心概念：</p><ul><li>TC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，驱动全局事务提交或回滚。</li><li>TM (Transaction Manager) - 事务管理器：定义全局事务的范围，开始全局事务、提交或回滚全局事务。</li><li>RM ( Resource Manager ) - 资源管理器：管理分支事务处理的资源( Resource )，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p>其中，TC 为单独部署的 Server 服务端，TM 和 RM 为嵌入到应用中的 Client 客户端。</p><p>这些概念小伙伴们作为一个了解即可，不了解也能用 Seata，了解了更能理解 Seata 的工作原理。</p><h2 id="2-搭建-Seata-服务端"><a href="#2-搭建-Seata-服务端" class="headerlink" title="2. 搭建 Seata 服务端"></a>2. 搭建 Seata 服务端</h2><p>我们先来把 Seata 服务端搭建起来。</p><p>Seata 下载地址：</p><ul><li><a href="https://github.com/seata/seata/releases" target="_blank" rel="noopener">https://github.com/seata/seata/releases</a></li></ul><p>目前最新版本是 1.4.2，我们就使用最新版本来做。</p><p>这个工具在 Windows 或者 Linux 上部署差别不大，所以我这里就直接部署在 Windows 上了，方便一些。</p><p>我们首先下载 1.4.2 版本的 zip 压缩包，下载之后解压，然后在 conf 目录中配置两个地方：</p><ol><li>首先配置 file.conf 文件</li></ol><p>file.conf 中配置 TC 的存储模式，TC 的存储模式有三种：</p><ul><li>file：适合单机模式，全局事务会话信息在内存中读写，并持久化本地文件 root.data，性能较高。</li><li>db：适合集群模式，全局事务会话信息通过 db 共享，相对性能差点。</li><li>redis：适合集群模式，全局事务会话信息通过 redis 共享，相对性能好点，但是要注意，redis 模式在 Seata-Server 1.3 及以上版本支持，性能较高，不过存在事务信息丢失的风险，所以需要开发者提前配置适合当前场景的 redis 持久化配置。</li></ul><p>这里我们为了省事，配置为 file 模式，这样事务会话信息读写在内存中完成，持久化则写到本地 file，如下图：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/seata-18.png" alt></p><p>如果配置 db 或者 redis 模式，大家记得填一下下面的相关信息。具体如下图：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210810165659.png" alt></p><p>题外话</p><p><strong>注意，如果使用 db 模式，需要提前准备好数据库脚本，如下（小伙伴们可以直接在公众号江南一点雨后台回复 seata-db 下载这个数据库脚本）：</strong></p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> <span class="hljs-comment">/*!32312 IF NOT EXISTS*/</span><span class="hljs-string">`seata2`</span> <span class="hljs-comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */</span> <span class="hljs-comment">/*!80016 DEFAULT ENCRYPTION='N' */</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">USE</span> <span class="hljs-string">`seata2`</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*Table structure for table `branch_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`branch_table`</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`branch_table`</span> (</span><br><span class="line">  <span class="hljs-string">`branch_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`xid`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`transaction_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`resource_group_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`resource_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`branch_type`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`status`</span> <span class="hljs-built_in">tinyint</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`client_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`application_data`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">2000</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`gmt_create`</span> datetime(<span class="hljs-number">6</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`gmt_modified`</span> datetime(<span class="hljs-number">6</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`branch_id`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_xid`</span> (<span class="hljs-string">`xid`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*Data for the table `branch_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*Table structure for table `global_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`global_table`</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`global_table`</span> (</span><br><span class="line">  <span class="hljs-string">`xid`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`transaction_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`status`</span> <span class="hljs-built_in">tinyint</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`application_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`transaction_service_group`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`transaction_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`timeout`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`begin_time`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`application_data`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">2000</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`gmt_create`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`gmt_modified`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`xid`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_gmt_modified_status`</span> (<span class="hljs-string">`gmt_modified`</span>,<span class="hljs-string">`status`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_transaction_id`</span> (<span class="hljs-string">`transaction_id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*Data for the table `global_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*Table structure for table `lock_table` */</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`lock_table`</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`lock_table`</span> (</span><br><span class="line">  <span class="hljs-string">`row_key`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`xid`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`transaction_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`branch_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`resource_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`table_name`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`pk`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">36</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`gmt_create`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`gmt_modified`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`row_key`</span>),</span><br><span class="line">  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_branch_id`</span> (<span class="hljs-string">`branch_id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>另外还需要注意的是自己的数据库版本信息，改数据库连接的时候按照实际情况修改，Seata 针对 MySQL5.x 和 MySQL8.x 都提供了对应的数据库驱动（在 lib 目录下），我们只需要把驱动改好就行了。</p><ol start="2"><li>再配置 registry.conf 文件</li></ol><p>registry.conf 主要配置 Seata 的注册中心，我们这里采用大家比较熟悉的 Eureka，配置如下：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210810174543.png" alt></p><p>可以看到，支持的配置中心比较多，我们选择 Eureka，选好配置中心之后，记得修改配置中心相关的信息。</p><p>OK，现在就配置完成了，但是先别启动，还差一个 Eureka 注册中心。</p><h2 id="3-项目配置"><a href="#3-项目配置" class="headerlink" title="3. 项目配置"></a>3. 项目配置</h2><p>接下来我们配置项目。</p><p>Seata 官方提供了一个非常经典的 Demo，我们直接来看这个 Demo。</p><p>官方案例下载地址：<a href="https://github.com/seata/seata-samples" target="_blank" rel="noopener">https://github.com/seata/seata-samples</a></p><p>不过这里是很多案例混在一起的，可能看起来会比较乱，而且由于要下载的依赖比较多，所以极有可能依赖下载失败，因此大家也可以在公众号后台回复 <code>seata-demo</code> 获取松哥整理好的案例，直接导入即可，如下图：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210810192353.png" alt></p><p>这是一个商品下单的案例，我来和大家稍微解释下：</p><ul><li>eureka：这是服务注册中心。</li><li>account：这是账户服务，可以查询/修改用户的账户信息（主要是账户余额）。</li><li>order：这是订单服务，可以下订单。</li><li>storage：这是一个仓储服务，可以查询/修改商品的库存数量。</li><li>bussiness：这是业务，用户下单操作将在这里完成。</li></ul><p>这个案例讲了一个什么事呢？</p><p><strong>当用户想要下单的时候，调用了 bussiness 中的接口，bussiness 中的接口又调用了它自己的 service，在 service 中，首先开启了全局分布式事务，然后通过 feign 调用 storage 中的接口去扣库存，然后再通过 feign 调用 order 中的接口去创建订单（order 在创建订单的时候，不仅会创建订单，还会扣除用户账户的余额），在扣除库存并完成订单创建之后，接下来会去检查用户的余额和库存数量是否正确，如果用户余额为负数或者库存数量为负数，则会进行事务回滚，否则提交事务。</strong></p><p>本案例具体架构如下图：</p><p><img src="http://img.itboyhub.com/2021/07/20210810204721.png" alt></p><p>这个案例就是一个典型的分布式事务问题，storage 和 order 中的事务分属于不同的微服务，但是我们希望他们同时成功或者同时失败。</p><p>现在大家明白了这个案例是干嘛的，我们就来把它跑起来。</p><p>首先创建一个名为 seata 的数据库，然后执行上面代码中的 all.sql 数据脚本。</p><p>接下来用 idea 打开上面这个项目，在每一个项目的 application.properties 文件中（Eureka 不用改），修改数据的连接信息，如下图：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210810193730.png" alt></p><p><strong>除了 Eureka 之外，另外四个都要改哦。</strong></p><p> OK，配置结束。</p><h2 id="4-启动测试"><a href="#4-启动测试" class="headerlink" title="4. 启动测试"></a>4. 启动测试</h2><p>首先启动 Eureka。</p><p>接下来先别记着启动其他服务，先启动 Seata Server，也就是我们第二小节配置的那个服务，在它的 bin 目录下，Windows 下双击/Linux 下执行启动脚本。</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210810194048.png" alt></p><p>最后再分别启动剩下的四个服务，启动完成后，我们可以在 Eureka 中查看相关信息：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210810194220.png" alt></p><p>可以看到，各个服务都注册上来了。</p><p>接下来我们访问 bussiness 中提供的两个测试接口。</p><p>第一个测试接口是：</p><p><code>http://127.0.0.1:8084/purchase/commit</code></p><p>这个接口对应的代码是：<code>io.seata.sample.controller.BusinessController#purchaseCommit</code>，这个地方是模拟 <code>U100000</code> 用户购买了 <code>30</code> 个 <code>C100000</code> 商品，每个商品的价格是 <code>100</code>，商品库存是 <code>200</code>，用户账户余额是 <code>10000</code>，所以购买之后，商品库存变为 <code>170</code>，用户账户余额变为 <code>7000</code>。这是正常购买的情况。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/purchase/commit"</span>, produces = <span class="hljs-string">"application/json"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">purchaseCommit</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        businessService.purchase(<span class="hljs-string">"U100000"</span>, <span class="hljs-string">"C100000"</span>, <span class="hljs-number">30</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception exx) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> exx.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"全局事务提交"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调完这个接口之后，就可以去数据库查看相应的数据。</p><p>第二个测试的接口是：</p><p><code>http://127.0.0.1:8084/purchase/rollback</code></p><p>这个接口对应的代码是：<code>io.seata.sample.controller.BusinessController#purchaseRollback</code>，这次是模拟用户购买 <code>99999</code> 个商品，无论是用户账户余额还是商品库存数量，都无法支撑这次购买行为，因此这个接口的调用最终会回滚，数据库中的数据会保持原样。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/purchase/rollback"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">purchaseRollback</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        businessService.purchase(<span class="hljs-string">"U100000"</span>, <span class="hljs-string">"C100000"</span>, <span class="hljs-number">99999</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception exx) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> exx.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"全局事务提交"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个分布式事务案例。</p><p>小伙伴们感兴趣也可以研究一下官方这个案例，我们会发现这里的东西非常简单，单纯是如下方法上多了一个注解而已(<code>io.seata.sample.service.BusinessService#purchase</code>)：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GlobalTransactional</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">purchase</span><span class="hljs-params">(String userId, String commodityCode, <span class="hljs-keyword">int</span> orderCount)</span> </span>&#123;</span><br><span class="line">    storageFeignClient.deduct(commodityCode, orderCount);</span><br><span class="line">    orderFeignClient.create(userId, commodityCode, orderCount);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!validData()) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"账户或库存不足,执行回滚"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>purchase 方法用 <code>@GlobalTransactional</code> 注解标记了下，就开启了全局事务了，里边的两个调用都是 feign 的调用，对应了不同的服务，最后再做一个数据校验，校验失败就抛出异常，一旦该方法抛出异常，上面已经执行的代码就会回滚。</p><p>这个项目其余的代码都是微服务中的常规代码，就不赘述了。</p><h2 id="5-实现原理"><a href="#5-实现原理" class="headerlink" title="5. 实现原理"></a>5. 实现原理</h2><p>我们稍微来说下 Seata 中这个分布式事务的原理，先来看一张图：</p><p><img src="http://img.itboyhub.com/2021/07/20210810213814.png" alt></p><p>这张图非常清晰的描述了上面的案例，大致流程如下：</p><ol><li>有三个概念：TM、RM、TC，这些我们在第一小节已经介绍过了，这里就不再赘述。</li><li>首先由 Business 开启全局事务。</li><li>接下来 Business 在调用 Storage 和 Order 的时候，这两个在数据库操作之前都会向 TC 注册一个分支事务并提交。</li><li>分支事务在操作时，都会向 undo_log 表中提交一条记录，当全局事务提交的时候会清空 undo_log 表中的记录，否则将以该表中的记录为依据进行反向补偿（将数据恢复原样）。</li></ol><p>具体到上面的案例，事务提交分两个阶段，过程如下：</p><p>一阶段：</p><ol><li>首先 Business 开启全局事务，这个过程中会向 TC 注册，然后会拿到一个 xid，这是一个全局事务 id。</li><li>接下来在 Business 中调用 Storage 微服务。</li><li>来解析 SQL：得到 SQL 的类型（UPDATE），表（storage_tbl），条件（where commodity_code = ‘C100000’）等相关的信息。</li><li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210811210508.png" alt></p><ol start="5"><li>执行业务 SQL，也就是做真正的数据更新操作。</li><li>查询后镜像：根据前镜像的结果，通过<strong>主键</strong>定位数据。</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210811210620.png" alt></p><ol start="7"><li>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 UNDO_LOG 表中。</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210811210734.png" alt></p><p>branch_id 和 xid 分别表示分支事务（即 Storage 自己的事务）和全局事务的 id，rollback_info 中保存着前后镜像的内容，<strong>这个将作为反向补偿（回滚）的依据</strong>，这个字段的值是一个 JSON，松哥挑出来这个 JSON 中比较重要的一部分来和大家分享：</p><ul><li>beforeImage：这个是修改前数据库中的数据，可以看到每个字段的值，id 为 4，count 的值为 200。</li><li>afterImage：这个是修改后数据库中的数据，可以看到，此时 id 为 4，count 的值为 170。</li></ul><p><img src="http://img.itboyhub.com/2021/07/20210811211321.png" alt><br><img src="http://img.itboyhub.com/2021/07/20210811211344.png" alt></p><ol start="8"><li>Storage 在提交前，会向 TC 注册分支：申请 storage_tbl 表中，主键值等于 4 的记录的全局锁。</li><li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li><li>同理，Order 和 Account 也按照上面的步骤提交数据。</li></ol><p>以上 1-10 步就是一阶段的数据提交。</p><p>再来看二阶段：</p><p>二阶段有两种可能，提交或者回滚。</p><p>还是以上面的案例为例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GlobalTransactional</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">purchase</span><span class="hljs-params">(String userId, String commodityCode, <span class="hljs-keyword">int</span> orderCount)</span> </span>&#123;</span><br><span class="line">    storageFeignClient.deduct(commodityCode, orderCount);</span><br><span class="line">    orderFeignClient.create(userId, commodityCode, orderCount);</span><br><span class="line">    <span class="hljs-keyword">if</span> (!validData()) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"账户或库存不足,执行回滚"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下单时候，扣除了库存，并且创建了订单，最后一检查，发现库存为负数或者用户账户余额为负数，说明这个订单有问题，此时就该抛异常回滚，否则就提交数据。</p><p>具体操作如下：</p><p><strong>回滚：</strong></p><ol><li>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</li><li>通过 xid 和 branch_id 去 undo_log 表中查找对应的记录。</li><li>数据校验：拿第二步查找到的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。</li><li>第三步的比较如果相同，则根据 undo_log 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句。</li><li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</li></ol><p><strong>提交：</strong></p><ol><li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li><li>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</li></ol><p><strong>换句话说，事务如果正常提交了，undo_log 表中是没有记录的，如果大家想看该表中的记录，可以在事务提交之前通过 DEBUG 的方式查看。</strong></p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>讲了这么多，是不是就把 Seata 讲完了呢？NONONO！这只是 AT 模式而已！还有三种模式，松哥下篇文章再和小伙伴们分享。</p><p>好啦，这就是一个简单的分布式事务，小伙伴们先来感受一把！标题是五分钟感受一把分布式事务，因为文章里边我还和大家分享了原理，如果大家只是跑一下案例感受，五分钟应该够了，不信试试！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;网上关于分布式事务讲理论的多，讲实战的少，今天我想通过一个案例，来让小伙伴们感受一把分布式事务，咱们今天尽量少谈点理论。咱们今天的主角是 Seata！&lt;/p&gt;
&lt;p&gt;分布式事务涉及到很多理论，如 CAP，BASE 等，很多小伙伴刚看到这些理论就被劝退了，所以我们今天不讲理论，咱们就看个 Demo，通过代码快速体验一把什么是分布式事务。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="http://www.javaboy.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://www.javaboy.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="seata" scheme="http://www.javaboy.org/tags/seata/"/>
    
  </entry>
  
  <entry>
    <title>四种策略确保 RabbitMQ 消息发送可靠性！你用哪种？</title>
    <link href="http://www.javaboy.org/2021/0810/mq_transaction.html"/>
    <id>http://www.javaboy.org/2021/0810/mq_transaction.html</id>
    <published>2021-08-10T13:35:24.000Z</published>
    <updated>2021-10-20T14:11:26.370Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>微服务可以设计成消息驱动的微服务，响应式系统也可以基于消息中间件来做，从这个角度来说，在互联网应用开发中，消息中间件真的是太重要了。</p><p>今天，以 RabbitMQ 为例，松哥来和大家聊一聊消息中间消息发送可靠性的问题。</p><a id="more"></a><p><strong>注意，以下内容我主要和大家讨论如何确保消息生产者将消息发送成功，并不涉及消息消费的问题。</strong></p><h2 id="1-RabbitMQ-消息发送机制"><a href="#1-RabbitMQ-消息发送机制" class="headerlink" title="1. RabbitMQ 消息发送机制"></a>1. RabbitMQ 消息发送机制</h2><p>大家知道，RabbitMQ 中的消息发送引入了 Exchange（交换机）的概念，消息的发送首先到达交换机上，然后再根据既定的路由规则，由交换机将消息路由到不同的 Queue（队列）中，再由不同的消费者去消费。</p><p><img src="http://img.itboyhub.com/2021/07/20210805191750.png" alt></p><p>大致的流程就是这样，所以要确保消息发送的可靠性，主要从两方面去确认：</p><ol><li>消息成功到达 Exchange</li><li>消息成功到达 Queue</li></ol><p>如果能确认这两步，那么我们就可以认为消息发送成功了。</p><p>如果这两步中任一步骤出现问题，那么消息就没有成功送达，此时我们可能要通过重试等方式去重新发送消息，多次重试之后，如果消息还是不能到达，则可能就需要人工介入了。</p><p>经过上面的分析，我们可以确认，要确保消息成功发送，我们只需要做好三件事就可以了：</p><ol><li>确认消息到达 Exchange。</li><li>确认消息到达 Queue。</li><li>开启定时任务，定时投递那些发送失败的消息。</li></ol><h2 id="2-RabbitMQ-的努力"><a href="#2-RabbitMQ-的努力" class="headerlink" title="2. RabbitMQ 的努力"></a>2. RabbitMQ 的努力</h2><p>上面提出的三个步骤，第三步需要我们自己实现，前两步 RabbitMQ 则有现成的解决方案。</p><p>如何确保消息成功到达 RabbitMQ？RabbitMQ 给出了两种方案：</p><ol><li>开启事务机制</li><li>发送方确认机制</li></ol><p>这是两种不同的方案，不可以同时开启，只能选择其中之一，如果两者同时开启，则会报如下错误：</p><p><img src="http://img.itboyhub.com/2021/07/20210805201041.png" alt></p><p>我们分别来看。以下所有案例都在 Spring Boot 中展开，文末可以下载相关源码。</p><h3 id="2-1-开启事务机制"><a href="#2-1-开启事务机制" class="headerlink" title="2.1 开启事务机制"></a>2.1 开启事务机制</h3><p>Spring Boot 中开启 RabbitMQ 事务机制的方式如下：</p><p>首先需要先提供一个事务管理器，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">RabbitTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RabbitTransactionManager(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在消息生产者上面做两件事：添加事务注解并设置通信信道为事务模式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Transactional</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setChannelTransacted(<span class="hljs-keyword">true</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitConfig.JAVABOY_EXCHANGE_NAME,RabbitConfig.JAVABOY_QUEUE_NAME,<span class="hljs-string">"hello rabbitmq!"</span>.getBytes());</span><br><span class="line">        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意两点：</p><ol><li>发送消息的方法上添加 <code>@Transactional</code> 注解标记事务。</li><li>调用 setChannelTransacted 方法设置为 true 开启事务模式。</li></ol><p>这就 OK 了。</p><p>在上面的案例中，我们在结尾来了个 1/0 ，这在运行时必然抛出异常，我们可以尝试运行该方法，发现消息并未发送成功。</p><p>当我们开启事务模式之后，RabbitMQ 生产者发送消息会多出四个步骤：</p><ol><li>客户端发出请求，将信道设置为事务模式。</li><li>服务端给出回复，同意将信道设置为事务模式。</li><li>客户端发送消息。</li><li>客户端提交事务。</li><li>服务端给出响应，确认事务提交。</li></ol><p>上面的步骤，除了第三步是本来就有的，其他几个步骤都是平白无故多出来的。所以大家看到，事务模式其实效率有点低，这并非一个最佳解决方案。我们可以想想，什么项目会用到消息中间件？一般来说都是一些高并发的项目，这个时候并发性能尤为重要。</p><p>所以，RabbitMQ 还提供了发送方确认机制（publisher confirm）来确保消息发送成功，这种方式，性能要远远高于事务模式，一起来看下。</p><h3 id="2-2-发送方确认机制"><a href="#2-2-发送方确认机制" class="headerlink" title="2.2 发送方确认机制"></a>2.2 发送方确认机制</h3><h4 id="2-2-1-单条消息处理"><a href="#2-2-1-单条消息处理" class="headerlink" title="2.2.1 单条消息处理"></a>2.2.1 单条消息处理</h4><p>首先我们移除刚刚关于事务的代码，然后在 application.properties 中配置开启消息发送方确认机制，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.publisher-confirm-type=correlated</span><br><span class="line">spring.rabbitmq.publisher-returns=true</span><br></pre></td></tr></table></figure><p>第一行是配置消息到达交换器的确认回调，第二行则是配置消息到达队列的回调。</p><p>第一行属性的配置有三个取值：</p><ol><li>none：表示禁用发布确认模式，默认即此。</li><li>correlated：表示成功发布消息到交换器后会触发的回调方法。</li><li>simple：类似 correlated，并且支持 <code>waitForConfirms()</code> 和 <code>waitForConfirmsOrDie()</code> 方法的调用。</li></ol><p>接下来我们要开启两个监听，具体配置如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RabbitTemplate</span>.<span class="hljs-title">ConfirmCallback</span>, <span class="hljs-title">RabbitTemplate</span>.<span class="hljs-title">ReturnsCallback</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_EXCHANGE_NAME = <span class="hljs-string">"javaboy_exchange_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JAVABOY_QUEUE_NAME = <span class="hljs-string">"javaboy_queue_name"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(RabbitConfig.class);</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(JAVABOY_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">DirectExchange <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectExchange(JAVABOY_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue())</span><br><span class="line">                .to(directExchange())</span><br><span class="line">                .with(JAVABOY_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostConstruct</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initRabbitTemplate</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="hljs-keyword">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="hljs-keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (ack) &#123;</span><br><span class="line">            logger.info(<span class="hljs-string">"&#123;&#125;:消息成功到达交换器"</span>,correlationData.getId());</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">            logger.error(<span class="hljs-string">"&#123;&#125;:消息发送失败"</span>, correlationData.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnedMessage</span><span class="hljs-params">(ReturnedMessage returned)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="hljs-string">"&#123;&#125;:消息未成功路由到队列"</span>,returned.getMessage().getMessageProperties().getMessageId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个配置类，我说如下几点：</p><ol><li>定义配置类，实现 <code>RabbitTemplate.ConfirmCallback</code> 和 <code>RabbitTemplate.ReturnsCallback</code> 两个接口，这两个接口，前者的回调用来确定消息到达交换器，后者则会在消息路由到队列失败时被调用。</li><li>定义 initRabbitTemplate 方法并添加 @PostConstruct 注解，在该方法中为 rabbitTemplate 分别配置这两个 Callback。</li></ol><p>这就可以了。</p><p>接下来我们对消息发送进行测试。</p><p>首先我们尝试将消息发送到一个不存在的交换机中，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(<span class="hljs-string">"RabbitConfig.JAVABOY_EXCHANGE_NAME"</span>,RabbitConfig.JAVABOY_QUEUE_NAME,<span class="hljs-string">"hello rabbitmq!"</span>.getBytes(),<span class="hljs-keyword">new</span> CorrelationData(UUID.randomUUID().toString()));</span><br></pre></td></tr></table></figure><p>注意第一个参数是一个字符串，不是变量，这个交换器并不存在，此时控制台会报如下错误：</p><p><img src="http://img.itboyhub.com/2021/07/20210806122327.png" alt></p><p>接下来我们给定一个真实存在的交换器，但是给一个不存在的队列，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(RabbitConfig.JAVABOY_EXCHANGE_NAME,<span class="hljs-string">"RabbitConfig.JAVABOY_QUEUE_NAME"</span>,<span class="hljs-string">"hello rabbitmq!"</span>.getBytes(),<span class="hljs-keyword">new</span> CorrelationData(UUID.randomUUID().toString()));</span><br></pre></td></tr></table></figure><p>注意此时第二个参数是一个字符串，不是变量。</p><p><img src="http://img.itboyhub.com/2021/07/20210806122521.png" alt></p><p>可以看到，消息虽然成功达到交换器了，但是没有成功路由到队列（因为队列不存在）。</p><p>这是一条消息的发送，我们再来看看消息的批量发送。</p><h4 id="2-2-2-消息批量处理"><a href="#2-2-2-消息批量处理" class="headerlink" title="2.2.2 消息批量处理"></a>2.2.2 消息批量处理</h4><p>如果是消息批量处理，那么发送成功的回调监听是一样的，这里不再赘述。</p><p>这就是 publisher-confirm 模式。</p><p>相比于事务，这种模式下的消息吞吐量会得到极大的提升。</p><h2 id="3-失败重试"><a href="#3-失败重试" class="headerlink" title="3. 失败重试"></a>3. 失败重试</h2><p>失败重试分两种情况，一种是压根没找到 MQ 导致的失败重试，另一种是找到 MQ 了，但是消息发送失败了。</p><p>两种重试我们分别来看。</p><h3 id="3-1-自带重试机制"><a href="#3-1-自带重试机制" class="headerlink" title="3.1 自带重试机制"></a>3.1 自带重试机制</h3><p>前面所说的事务机制和发送方确认机制，都是发送方确认消息发送成功的办法。如果发送方一开始就连不上 MQ，那么 Spring Boot 中也有相应的重试机制，但是这个重试机制就和 MQ 本身没有关系了，这是利用 Spring 中的 retry 机制来完成的，具体配置如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.template.retry.enabled=true</span><br><span class="line">spring.rabbitmq.template.retry.initial-interval=1000ms</span><br><span class="line">spring.rabbitmq.template.retry.max-attempts=10</span><br><span class="line">spring.rabbitmq.template.retry.max-interval=10000ms</span><br><span class="line">spring.rabbitmq.template.retry.multiplier=2</span><br></pre></td></tr></table></figure><p>从上往下配置含义依次是：</p><ul><li>开启重试机制。</li><li>重试起始间隔时间。</li><li>最大重试次数。</li><li>最大重试间隔时间。</li><li>间隔时间乘数。（这里配置间隔时间乘数为 2，则第一次间隔时间 1 秒，第二次重试间隔时间 2 秒，第三次 4 秒，以此类推）</li></ul><p>配置完成后，再次启动 Spring Boot 项目，然后关掉 MQ，此时尝试发送消息，就会发送失败，进而导致自动重试。</p><p><img src="http://img.itboyhub.com/2021/07/20210806201941.png" alt></p><h3 id="3-2-业务重试"><a href="#3-2-业务重试" class="headerlink" title="3.2 业务重试"></a>3.2 业务重试</h3><p>业务重试主要是针对消息没有到达交换器的情况。</p><p>如果消息没有成功到达交换器，根据我们第二小节的讲解，此时就会触发消息发送失败回调，在这个回调中，我们就可以做文章了！</p><p>整体思路是这样：</p><ol><li>首先创建一张表，用来记录发送到中间件上的消息，像下面这样：</li></ol><p><img src="http://img.itboyhub.com/2021/07/20210806202609.png" alt></p><p>每次发送消息的时候，就往数据库中添加一条记录。这里的字段都很好理解，有三个我额外说下：</p><ul><li>status：表示消息的状态，有三个取值，0，1，2 分别表示消息发送中、消息发送成功以及消息发送失败。</li><li>tryTime：表示消息的第一次重试时间（消息发出去之后，在 tryTime 这个时间点还未显示发送成功，此时就可以开始重试了）。</li><li>count：表示消息重试次数。</li></ul><p>其他字段都很好理解，我就不一一啰嗦了。</p><ol start="2"><li>在消息发送的时候，我们就往该表中保存一条消息发送记录，并设置状态 status 为 0，tryTime 为 1 分钟之后。</li><li>在 confirm 回调方法中，如果收到消息发送成功的回调，就将该条消息的 status 设置为1（在消息发送时为消息设置 msgId，在消息发送成功回调时，通过 msgId 来唯一锁定该条消息）。</li><li>另外开启一个定时任务，定时任务每隔 10s 就去数据库中捞一次消息，专门去捞那些 status 为 0 并且已经过了 tryTime 时间记录，把这些消息拎出来后，首先判断其重试次数是否已超过 3 次，如果超过 3 次，则修改该条消息的 status 为 2，表示这条消息发送失败，并且不再重试。对于重试次数没有超过 3 次的记录，则重新去发送消息，并且为其 count 的值+1。</li></ol><p>大致的思路就是上面这样，松哥这里就不给出代码了，松哥的 vhr 里边邮件发送就是这样的思路来处理的，完整代码大家可以参考 vhr 项目（<a href="https://github.com/lenve/vhr" target="_blank" rel="noopener">https://github.com/lenve/vhr</a>）。</p><p>当然这种思路有两个弊端：</p><ol><li>去数据库走一遭，可能拖慢 MQ 的 Qos，不过有的时候我们并不需要 MQ 有很高的 Qos，所以这个应用时要看具体情况。</li><li>按照上面的思路，可能会出现同一条消息重复发送的情况，不过这都不是事，我们在消息消费时，解决好幂等性问题就行了。</li></ol><p>当然，大家也要注意，消息是否要确保 100% 发送成功，也要看具体情况。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>好啦，这就是关于消息生产者的一些常见问题以及对应的解决方案，下篇文章松哥和大家探讨如果保证消息消费成功并解决幂等性问题。</p><p>本文涉及到的相关源代码大家可以在这里下载：<a href="https://github.com/lenve/javaboy-code-samples。" target="_blank" rel="noopener">https://github.com/lenve/javaboy-code-samples。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;微服务可以设计成消息驱动的微服务，响应式系统也可以基于消息中间件来做，从这个角度来说，在互联网应用开发中，消息中间件真的是太重要了。&lt;/p&gt;
&lt;p&gt;今天，以 RabbitMQ 为例，松哥来和大家聊一聊消息中间消息发送可靠性的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://www.javaboy.org/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>七种分布式全局 ID 生成策略，你更爱哪种？</title>
    <link href="http://www.javaboy.org/2021/0804/7_id.html"/>
    <id>http://www.javaboy.org/2021/0804/7_id.html</id>
    <published>2021-08-04T13:35:03.000Z</published>
    <updated>2021-10-20T14:11:15.359Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>上了微服务之后，很多原本很简单的问题现在都变复杂了，例如全局 ID 这事！</p><p>松哥最近工作中刚好用到这块内容，于是调研了市面上几种常见的全局 ID 生成策略，稍微做了一下对比，供小伙伴们参考。</p><a id="more"></a><p>当数据库分库分表之后，原本的主键自增就不方便继续使用了，需要找到一个新的合适的方案，松哥的需求就是在这样的情况下提出的。</p><p>接下来我们一起来捋一捋。</p><h2 id="1-两种思路"><a href="#1-两种思路" class="headerlink" title="1. 两种思路"></a>1. 两种思路</h2><p>整体上来说，这个问题有两种不同的思路：</p><ul><li>让数据库自己搞定</li><li>Java 代码来处理主键，然后直接插入数据库中即可。</li></ul><p>这两种思路又对应了不同的方案，我们一个一个来看。</p><h2 id="2-数据库自己搞定"><a href="#2-数据库自己搞定" class="headerlink" title="2. 数据库自己搞定"></a>2. 数据库自己搞定</h2><p>数据库自己搞定，就是说我在数据插入的时候，依然不考虑主键的问题，希望继续使用数据库的主键自增，但是很明显，原本默认的主键自增现在没法用了，我们必须有新的方案。</p><h3 id="2-1-修改数据库配置"><a href="#2-1-修改数据库配置" class="headerlink" title="2.1 修改数据库配置"></a>2.1 修改数据库配置</h3><p>数据库分库分表之后的结构如下图（假设数据库中间件用的 MyCat）：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/6-2-20210128205234196.png" alt></p><p>此时如果原本的 db1、db2、db3 继续各自主键自增，那么对于 MyCat 而言，主键就不是自增了，主键就会重复，用户从 MyCat 中查询到的数据主键就有问题。</p><p>找到问题的原因，那么剩下的就好解决了。</p><p>我们可以直接修改 MySQL 数据库主键自增的起始值和步长。</p><p>首先我们可以通过如下 SQL 查看与此相关的两个变量的取值：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">VARIABLES</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'auto_increment%'</span></span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com//2020/04/vhr/20210730201741.png" alt></p><p>可以看到，主键自增的起始值和步长都是 1。</p><p>起始值好改，在定义表的时候就可以设置，步长我们可以通过修改这个配置实现：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">set</span> @@auto_increment_increment=<span class="hljs-number">9</span>;</span><br></pre></td></tr></table></figure><p>修改后，再去查看对应的变量值，发现已经变了：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210730203544.png" alt></p><p>此时我们再去插入数据，主键自增就不是每次自增 1，而是每次自增 9 了。</p><p>至于自增起始值其实很好设置，创建表的时候就可以设置了。</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test01(<span class="hljs-keyword">id</span> <span class="hljs-built_in">integer</span> PRIMARY <span class="hljs-keyword">KEY</span> auto_increment,username <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>)) auto_increment=<span class="hljs-number">8</span>;</span><br></pre></td></tr></table></figure><p>既然 MySQL 可以修改自增的起始值和每次增长的步长，现在假设我有 db1、db2 和 db3，我就可以分别设置这三个库中表的自增起始值为 1、2、3，然后自增步长都是 3，这样就可以实现自增了。</p><p>但是很明显这种方式不够优雅，而且处理起来很麻烦，将来扩展也不方便，因此不推荐。</p><h3 id="2-2-MySQL-MyCat-ZooKeeper"><a href="#2-2-MySQL-MyCat-ZooKeeper" class="headerlink" title="2.2 MySQL+MyCat+ZooKeeper"></a>2.2 MySQL+MyCat+ZooKeeper</h3><p>如果大家分库分表工具恰好使用的是 MyCat，那么结合 Zookeeper 也能很好的实现主键全局自增。</p><p>MyCat 作为一个分布式数据库中间，屏蔽了数据库集群的操作，让我们操作数据库集群就像操作单机版数据库一样，对于主键自增，它有自己的方案：</p><ol><li>通过本地文件实现</li><li>通过数据库实现</li><li>通过本地时间戳实现</li><li>通过分布式 ZK ID 生成器实现</li><li>通过 ZK 递增方式实现</li></ol><p>这里我们主要来看方案 4。</p><p>配置步骤如下：</p><ul><li>首先修改主键自增方式为 4 ，4 表示使用 zookeeper 实现主键自增。</li></ul><p>server.xml</p><p><img src="http://img.itboyhub.com/2021/01/mysql/9-1-20210128205511515.png" alt></p><ul><li>配置表自增，并且设置主键</li></ul><p>schema.xml</p><p><img src="http://img.itboyhub.com/2021/01/mysql/9-2-20210128205518109.png" alt></p><p>设置主键自增，并且设置主键为 id 。</p><ul><li>配置 zookeeper 的信息</li></ul><p>在 myid.properties 中配置 zookeeper 信息：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/9-3.png" alt></p><ul><li>配置要自增的表</li></ul><p>sequence_conf.properties</p><p><img src="http://img.itboyhub.com/2021/01/mysql/9-4.png" alt></p><p>注意，这里表名字要大写。</p><ol><li>TABLE.MINID 某线程当前区间内最小值</li><li>TABLE.MAXID 某线程当前区间内最大值</li><li>TABLE.CURID 某线程当前区间内当前值</li><li>文件配置的MAXID以及MINID决定每次取得区间，这个对于每个线程或者进程都有效</li><li>文件中的这三个属性配置只对第一个进程的第一个线程有效，其他线程和进程会动态读取 ZK</li></ol><ul><li>重启 MyCat 测试</li></ul><p>最后重启 MyCat ，删掉之前创建的表，然后创建新表进行测试即可。</p><p>这种方式就比较省事一些，而且可扩展性也比较强，如果选择了 MyCat 作为分库分表工具，那么这种不失为一种最佳方案。</p><p>前面介绍这两种都是在数据库或者数据库中间件层面来处理主键自增，我们 Java 代码并不需要额外工作。</p><p>接下来我们再来看几种需要在 Java 代码中进行处理的方案。</p><h2 id="3-Java-代码处理"><a href="#3-Java-代码处理" class="headerlink" title="3. Java 代码处理"></a>3. Java 代码处理</h2><h3 id="3-1-UUID"><a href="#3-1-UUID" class="headerlink" title="3.1 UUID"></a>3.1 UUID</h3><p>最容易想到的就是 UUID (Universally Unique Identifier) 了，<br>UUID 的标准型式包含 32 个 16 进制数字，以连字号分为五段，形式为 8-4-4-4-12 的 36 个字符，这个是 Java 自带的，用着也简单，最大的优势就是本地生成，没有网络消耗，但是但凡在公司做开发的小伙伴都知道这个东西在公司项目中使用并不多。原因如下：</p><ol><li>字符串太长，对于 MySQL 而言，不利于索引。</li><li>UUID 的随机性对于 I/O 密集型的应用非常不友好！<strong>它会使得聚簇索引的插入变得完全随机，使得数据没有任何聚集特性。</strong></li><li>信息不安全：基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li></ol><p>因此，UUID 并非最佳方案。</p><h3 id="3-2-SNOWFLAKE"><a href="#3-2-SNOWFLAKE" class="headerlink" title="3.2 SNOWFLAKE"></a>3.2 SNOWFLAKE</h3><p>雪花算法是由 Twitter 公布的分布式主键生成算法，它能够保证不同进程主键的不重复性，以及相同进程主键的有序性。在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。</p><p>同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。</p><p>例如 MySQL 的 Innodb 存储引擎的主键。使用雪花算法生成的主键，二进制表示形式包含 4 部分，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210803171743.png" alt></p><ul><li>符号位 (1bit)</li></ul><p>预留的符号位，恒为零。</p><ul><li>时间戳位 (41bit)</li></ul><p>41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：365 <em> 24 </em> 60 <em> 60 </em> 1000。通过计算可知：<code>Math.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L);</code>结果约等于 69.73 年。</p><p>ShardingSphere 的雪花算法的时间纪元从 2016 年 11 月 1 日零点开始，可以使用到 2086 年，相信能满足绝大部分系统的要求。</p><ul><li>工作进程位 (10bit)</li></ul><p>该标志在 Java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。该值默认为 0，可通过属性设置。</p><ul><li>序列号位 (12bit)</li></ul><p>该序列是用来在同一个毫秒内生成不同的 ID。如果在这个毫秒内生成的数量超过 4096 (2 的 12 次幂)，那么生成器会等待到下个毫秒继续生成。</p><blockquote><p>注意： 该算法存在 <strong>时钟回拨</strong> 问题，服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为 0，可通过属性设置。</p></blockquote><p>下面松哥给出一个雪花算法的工具类，大家可以参考：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdWorker</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动）</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> twepoch = <span class="hljs-number">1288834974657L</span>;</span><br><span class="line">    <span class="hljs-comment">// 机器标识位数</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> workerIdBits = <span class="hljs-number">5L</span>;</span><br><span class="line">    <span class="hljs-comment">// 数据中心标识位数</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> datacenterIdBits = <span class="hljs-number">5L</span>;</span><br><span class="line">    <span class="hljs-comment">// 机器ID最大值</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> maxWorkerId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="hljs-comment">// 数据中心ID最大值</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> maxDatacenterId = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="hljs-comment">// 毫秒内自增位</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> sequenceBits = <span class="hljs-number">12L</span>;</span><br><span class="line">    <span class="hljs-comment">// 机器ID偏左移12位</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="hljs-comment">// 数据中心ID左移17位</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="hljs-comment">// 时间毫秒左移22位</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> sequenceMask = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line">    <span class="hljs-comment">/* 上次生产id时间戳 */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> lastTimestamp = -<span class="hljs-number">1L</span>;</span><br><span class="line">    <span class="hljs-comment">// 0，并发控制</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequence = <span class="hljs-number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> workerId;</span><br><span class="line">    <span class="hljs-comment">// 数据标识id部分</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IdWorker</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.datacenterId = getDatacenterId(maxDatacenterId);</span><br><span class="line">        <span class="hljs-keyword">this</span>.workerId = getMaxWorkerId(datacenterId, maxWorkerId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> workerId</span></span><br><span class="line"><span class="hljs-comment">     *            工作机器ID</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> datacenterId</span></span><br><span class="line"><span class="hljs-comment">     *            序列号</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IdWorker</span><span class="hljs-params">(<span class="hljs-keyword">long</span> workerId, <span class="hljs-keyword">long</span> datacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">"worker Id can't be greater than %d or less than 0"</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">"datacenter Id can't be greater than %d or less than 0"</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="hljs-keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 获取下一个ID</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="hljs-keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(String.format(<span class="hljs-string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            <span class="hljs-comment">// 当前毫秒内，则+1</span></span><br><span class="line">            sequence = (sequence + <span class="hljs-number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">// 当前毫秒内计数满了，则等待下一秒</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="hljs-number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="hljs-comment">// ID偏移组合生成最终的ID，并返回ID</span></span><br><span class="line">        <span class="hljs-keyword">long</span> nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift)</span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> nextId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">tilNextMillis</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> timestamp = <span class="hljs-keyword">this</span>.timeGen();</span><br><span class="line">        <span class="hljs-keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = <span class="hljs-keyword">this</span>.timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">timeGen</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 获取 maxWorkerId</span></span><br><span class="line"><span class="hljs-comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getMaxWorkerId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> datacenterId, <span class="hljs-keyword">long</span> maxWorkerId)</span> </span>&#123;</span><br><span class="line">        StringBuffer mpid = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line">        mpid.append(datacenterId);</span><br><span class="line">        String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">        <span class="hljs-keyword">if</span> (!name.isEmpty()) &#123;</span><br><span class="line">            <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">             * GET jvmPid</span></span><br><span class="line"><span class="hljs-comment">             */</span></span><br><span class="line">            mpid.append(name.split(<span class="hljs-string">"@"</span>)[<span class="hljs-number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">         * MAC + PID 的 hashcode 获取16个低位</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        <span class="hljs-keyword">return</span> (mpid.toString().hashCode() &amp; <span class="hljs-number">0xffff</span>) % (maxWorkerId + <span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="hljs-comment">     * 数据标识id部分</span></span><br><span class="line"><span class="hljs-comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDatacenterId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> maxDatacenterId)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> id = <span class="hljs-number">0L</span>;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">            NetworkInterface network = NetworkInterface.getByInetAddress(ip);</span><br><span class="line">            <span class="hljs-keyword">if</span> (network == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                id = <span class="hljs-number">1L</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">byte</span>[] mac = network.getHardwareAddress();</span><br><span class="line">                id = ((<span class="hljs-number">0x000000FF</span> &amp; (<span class="hljs-keyword">long</span>) mac[mac.length - <span class="hljs-number">1</span>])</span><br><span class="line">                        | (<span class="hljs-number">0x0000FF00</span> &amp; (((<span class="hljs-keyword">long</span>) mac[mac.length - <span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">8</span>))) &gt;&gt; <span class="hljs-number">6</span>;</span><br><span class="line">                id = id % (maxDatacenterId + <span class="hljs-number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">" getDatacenterId: "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IdWorker idWorker = <span class="hljs-keyword">new</span> IdWorker(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;</span><br><span class="line">    System.out.println(idWorker.nextId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-LEAF"><a href="#3-3-LEAF" class="headerlink" title="3.3 LEAF"></a>3.3 LEAF</h3><p>Leaf 是美团开源的分布式 ID 生成系统，最早期需求是各个业务线的订单 ID 生成需求。在美团早期，有的业务直接通过 DB 自增的方式生成 ID，有的业务通过 Redis 缓存来生成 ID，也有的业务直接用 UUID 这种方式来生成 ID。以上的方式各自有各自的问题，因此美团决定实现一套分布式 ID 生成服务来满足需求目前 Leaf 覆盖了美团点评公司内部金融、餐饮、外卖、酒店旅游、猫眼电影等众多业务线。在4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms（TP=Top Percentile，Top 百分数，是一个统计学里的术语，与平均数、中位数都是一类。TP50、TP90 和 TP99 等指标常用于系统性能监控场景，指高于 50%、90%、99% 等百分线的情况）。</p><p>目前 LEAF 的使用有两种不同的思路，号段模式和 SNOWFLAKE 模式，你可以同时开启两种方式，也可以指定开启某种方式（默认两种方式为关闭状态）。</p><p>我们从 GitHub 上 Clone LEAF 之后，它的配置文件在 <code>leaf-server/src/main/resources/leaf.properties</code> 中，各项配置的含义如下：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20210803173237.png" alt>。</p><p>可以看到，如果使用号段模式，需要数据库支持；如果使用 SNOWFLAKE 模式，需要 Zookeeper 支持。</p><h4 id="3-3-1-号段模式"><a href="#3-3-1-号段模式" class="headerlink" title="3.3.1 号段模式"></a>3.3.1 号段模式</h4><p>号段模式还是基于数据库，但是思路有些变化，如下：</p><ol><li>利用 proxy server 从数据库中批量获取 id，每次获取一个 segment (step 决定其大小) 号段的值，用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。</li><li>各个业务不同的发号需求用 biz_tag 字段来区分，每个 biz-tag 的 ID 获取相互隔离，互不影响。</li><li>如果有新的业务需要扩区 ID，只需要增加表记录即可。</li></ol><p>如果使用号段模式，我们首先需要创建一张数据表，脚本如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> leaf</span><br><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`leaf_alloc`</span> (</span><br><span class="line">  <span class="hljs-string">`biz_tag`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">128</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">''</span>,</span><br><span class="line">  <span class="hljs-string">`max_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'1'</span>,</span><br><span class="line">  <span class="hljs-string">`step`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`description`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">256</span>)  <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  <span class="hljs-string">`update_time`</span> <span class="hljs-built_in">timestamp</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`biz_tag`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> leaf_alloc(biz_tag, max_id, step, description) <span class="hljs-keyword">values</span>(<span class="hljs-string">'leaf-segment-test'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>, <span class="hljs-string">'Test leaf Segment Mode Get Id'</span>)</span><br></pre></td></tr></table></figure><p>这张表中各项字段的含义如下：</p><ul><li>biz_tag：业务标记（不同业务可以有不同的号段序列）</li><li>max_id：当前号段下的最大 id</li><li>step：每次取号段的步长</li><li>description：描述信息</li><li>update_time：更新时间</li></ul><p>配置完成后，启动项目，访问 <code>http://localhost:8080/api/segment/get/leaf-segment-test</code> 路径（路径最后面的 leaf-segment-test 是业务标记），即可拿到 ID。</p><p>可以通过如下地址访问到号段模式的监控页面 <code>http://localhost:8080/cache</code>。</p><p>号段模式优缺点：</p><p><strong>优点</strong></p><ul><li>Leaf 服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li><li>ID 号码是趋势递增的 8byte 的 64 位数字，满足上述数据库存储的主键要求。</li><li>容灾性高：Leaf 服务内部有号段缓存，即使 DB 宕机，短时间内 Leaf 仍能正常对外提供服务。</li><li>可以自定义 max_id 的大小，非常方便业务从原有的 ID 方式上迁移过来。</li></ul><p><strong>缺点</strong></p><ul><li>ID 号码不够随机，能够泄露发号数量的信息，不太安全。</li><li>DB 宕机会造成整个系统不可用。</li></ul><h4 id="3-3-2-SNOWFLAKE-模式"><a href="#3-3-2-SNOWFLAKE-模式" class="headerlink" title="3.3.2 SNOWFLAKE 模式"></a>3.3.2 SNOWFLAKE 模式</h4><p>SNOWFLAKE 模式需要配合 Zookeeper 一起，不过 SNOWFLAKE 对 Zookeeper 的依赖是弱依赖，把 Zookeeper 启动之后，我们可以在 SNOWFLAKE 中配置 Zookeeper 信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaf.snowflake.enable=true</span><br><span class="line">leaf.snowflake.zk.address=192.168.91.130</span><br><span class="line">leaf.snowflake.port=2183</span><br></pre></td></tr></table></figure><p>然后重新启动项目，启动成功后，通过如下地址可以访问到 ID：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/api/snowflake/get/test</span><br></pre></td></tr></table></figure><h3 id="3-4-Redis-生成"><a href="#3-4-Redis-生成" class="headerlink" title="3.4 Redis 生成"></a>3.4 Redis 生成</h3><p>这个主要是利用 Redis 的 incrby 来实现，这个我觉得没啥好说的。</p><h3 id="3-5-Zookeeper-处理"><a href="#3-5-Zookeeper-处理" class="headerlink" title="3.5 Zookeeper 处理"></a>3.5 Zookeeper 处理</h3><p>zookeeper 也能做，但是比较麻烦，不推荐。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>综上，如果项目中恰好使用了 MyCat，那么可以使用 MyCat+Zookeeper，否则建议使用 LEAF，两种模式皆可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;上了微服务之后，很多原本很简单的问题现在都变复杂了，例如全局 ID 这事！&lt;/p&gt;
&lt;p&gt;松哥最近工作中刚好用到这块内容，于是调研了市面上几种常见的全局 ID 生成策略，稍微做了一下对比，供小伙伴们参考。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式系统" scheme="http://www.javaboy.org/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式" scheme="http://www.javaboy.org/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="全局ID" scheme="http://www.javaboy.org/tags/%E5%85%A8%E5%B1%80ID/"/>
    
  </entry>
  
  <entry>
    <title>MySQL8 主从复制踩坑指南</title>
    <link href="http://www.javaboy.org/2021/0729/mysql8_master_slave.html"/>
    <id>http://www.javaboy.org/2021/0729/mysql8_master_slave.html</id>
    <published>2021-07-29T13:43:03.000Z</published>
    <updated>2021-10-20T14:12:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>松哥之前发过视频和大家聊 MySQL 的主从搭建，还没看过的小伙伴可以看这里：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/R89aCCFvCvudLp6FUn2JjQ" target="_blank" rel="noopener">手把手教大家搭建 MySQL 主从复制</a></li></ul><p>不过那一次是基于 MySQL5.7 搭建的，最近工作需要，搭建了基于 MySQL8 的主从，和 MySQL5.7 的搭建还是有一些不同，于是稍微记录下。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我这里有一张简单的图向大伙展示 MySQL 主从的工作方式：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/3-1-20210128205201707.png" alt></p><p>这里，我们准备两台机器：</p><ul><li>主机：192.168.248.128</li><li>从机：192.168.248.139</li></ul><h2 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h2><p>主机的配置就三个步骤，比较容易：</p><p><strong>1. 授权给从机服务器</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* to &apos;rep1&apos;@&apos;192.168.248.139&apos; identified by &apos;123&apos;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>这里表示配置从机登录用户名为 rep1，密码为 123，并且必须从 192.168.248.139这个地址登录，登录成功之后可以操作任意库中的任意表。其中，如果不需要限制登录地址，可以将 IP 地址更换为一个 <code>%</code>。</p><blockquote><p>注意，在 MySQL8 里边，这块有一些变化。MySQL8 中用户创建和授权需要分开，不能像上面那样一步到位，具体方式如下：</p></blockquote><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER `rep1`@`192.168.248.139` IDENTIFIED WITH caching_sha2_password BY &apos;javaboy.COM&apos;;</span><br><span class="line"></span><br><span class="line">GRANT Replication Slave ON *.* TO `rep1`@`192.168.248.139`;</span><br></pre></td></tr></table></figure><p><strong>2. 修改主库配置文件</strong></p><p>开启 binlog ，并设置 server-id ，每次修改配置文件后都要重启 MySQL 服务才会生效</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure><p><strong>这个配置文件位置也可能是 <code>/etc/mysql/my.cnf</code>，这个要看自己的系统和 MySQL 版本。</strong></p><p>修改的文件内容如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=/var/lib/mysql/binlog</span><br><span class="line">server-id=128</span><br><span class="line">binlog-do-db = cmdb</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="http://img.itboyhub.com/2021/01/mysql/3-2-20210128205207575.png" alt></p><ul><li>log-bin：同步的日志路径及文件名，一定注意这个目录要是 MySQL 有权限写入的（我这里是偷懒了，直接放在了下面那个datadir下面）。</li><li>binlog-do-db：要同步的数据库名，当从机连上主机后，只有这里配置的数据库才会被同步，其他的不会被同步。</li><li>server-id: MySQL 在主从环境下的唯一标志符，给个任意数字，注意不能和从机重复。</li></ul><p>配置完成后重启 MySQL 服务端：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p><strong>3. 查看主服务器当前二进制日志名和偏移量</strong></p><p>这个操作的目的是为了在从数据库启动后，从这个点开始进行数据的恢复：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/01/mysql/3-3-20210128205212596.png" alt></p><p>至此，主机配置完成。  </p><h2 id="从机配置"><a href="#从机配置" class="headerlink" title="从机配置"></a>从机配置</h2><p>从机的配置也比较简单，我们一步一步来看：</p><p><strong>1. 在/etc/my.cnf 添加配置</strong></p><p><img src="http://img.itboyhub.com/2021/01/mysql/3-4-20210128205217210.png" alt></p><p>注意从机这里只需要配置一下 server-id 即可。</p><p><strong>注意：如果从机是从主机复制来的，即我们通过复制 CentOS 虚拟机获取了 MySQL 实例 ，此时两个 MySQL 的 uuid 一样（正常安装是不会相同的），这时需要手动修改，修改位置在 <code>/var/lib/mysql/auto.cnf</code> ，注意随便修改这里几个字符即可，但也不可太过于随意，例如修改了 uuid 的长度。</strong></p><p><strong>2. 使用命令来配置从机</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;192.168.248.128&apos;,master_port=3306,master_user=&apos;rep1&apos;,master_password=&apos;123&apos;,master_log_file=&apos;binlog.000001&apos;,master_log_pos=120;</span><br></pre></td></tr></table></figure><p>这里配置了主机地址、端口以及从机登录主机的用户名和密码，注意最后两个参数要和 master 中的保持一致。</p><p>注意，由于 MySQL8 密码插件的问题，这个问题同样会给主从配置带来问题，所以在 MySQL8 配置主从上，上面这行命令需要添加 <code>get_master_public_key=1</code>，完整命令如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;192.168.248.128&apos;,master_port=3306,master_user=&apos;rep1&apos;,master_password=&apos;123&apos;,master_log_file=&apos;binlog.000001&apos;,master_log_pos=120,get_master_public_key=1;</span><br></pre></td></tr></table></figure><p><strong>3. 启动 slave 进程</strong></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>启动之后查看从机状态：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure><p><img src="http://img.itboyhub.com/2021/01/mysql/3-5-20210128205222293.png" alt></p><p><strong>4. 查看 slave 的状态</strong></p><p>主要是下面两项值都要为为 YES，则表示配置正确：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure><p>至此，配置完成，主机创建库，添加数据，从机会自动同步。 </p><p>如果这两个有一个不为 YES ，表示主从环境搭建失败，此时可以阅读日志，查看出错的原因，再具体问题具体解决。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要和大伙说了 MySQL 主从环境搭建，并且提醒了关于 MySQL8 主从搭建时需要注意的几个问题，这几个步骤松哥反反复复操作过很多遍，小伙伴只要按照松哥的步骤一般来说都能成功，有问题欢迎留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;松哥之前发过视频和大家聊 MySQL 的主从搭建，还没看过的小伙伴可以看这里：&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://www.javaboy.org/categories/mysql/"/>
    
    
      <category term="MySQL8" scheme="http://www.javaboy.org/tags/MySQL8/"/>
    
      <category term="主从复制" scheme="http://www.javaboy.org/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
</feed>
