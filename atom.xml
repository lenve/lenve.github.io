<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江南一点雨</title>
  
  <subtitle>江南一点雨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javaboy.org/"/>
  <updated>2020-11-25T02:53:22.935Z</updated>
  <id>http://www.javaboy.org/</id>
  
  <author>
    <name>江南一点雨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>想做个项目练练手却不知道做啥？松哥准备了 50 个热门需求文档给大家！</title>
    <link href="http://www.javaboy.org/2020/1123/java-doc.html"/>
    <id>http://www.javaboy.org/2020/1123/java-doc.html</id>
    <published>2020-11-23T02:30:00.000Z</published>
    <updated>2020-11-25T02:53:22.935Z</updated>
    
    <content type="html"><![CDATA[<p>之前有好几位小伙伴向松哥反映，学完了微人事项目的技术点之后，想再做个项目练练手，但是却不知道该做啥！不了解业务就无从下手。</p><a id="more"></a><p>其实我理解大家的这种处境，因此，这个周末松哥花了两天时间，整理了 50+ 个热门项目需求文档给大家参考，小伙伴们只需要认真研读这些需求文档，照着需求文档所描述的业务功能去开发项目即可。</p><p>这些需求文档基本都是 Java 企业级应用，一些业务简单的项目松哥建议大家采用 Spring Boot + Vue 技术栈来开发，有的业务比较复杂的，可以多找几个小伙伴一起开发，对于这种业务复杂的项目也可以考虑采用 Spring Cloud 技术栈。</p><p>如果大家想做，建议大家从一开始就认真规划项目、技术栈的选择、人员分工（如果多个人一起开发）等等，做好的项目可以上传到 GitHub 或者 Gitee，对自己以后找工作多多少少也都会有帮助。等大家项目开发完了，如果需要宣传，也可以在微信上私我（公号底部菜单有我微信号），松哥无偿帮大家宣传开源项目。</p><p>下面就是松哥收集到的各种需求文档了：</p><p>【ERP】</p><ul><li>人事管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1AFgBrymHhI4BECZHYfWHug" target="_blank" rel="noopener">https://pan.baidu.com/s/1AFgBrymHhI4BECZHYfWHug</a> 提取码：uzrg</li></ul></li><li>大通ERP系统需求规格说明书V3.0 <ul><li>链接：<a href="https://pan.baidu.com/s/1bax2USj7EkXcgL5nmde9Ow" target="_blank" rel="noopener">https://pan.baidu.com/s/1bax2USj7EkXcgL5nmde9Ow</a> 提取码：2hvz</li></ul></li><li>ERP需求分析 <ul><li>链接：<a href="https://pan.baidu.com/s/13vu96etHV-ic6WReg_0kOA" target="_blank" rel="noopener">https://pan.baidu.com/s/13vu96etHV-ic6WReg_0kOA</a> 提取码：c6ub</li></ul></li></ul><p>【物流】</p><ul><li>通天物流管理项目需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1a2_3D-GE9PmJmNCeJNubsA" target="_blank" rel="noopener">https://pan.baidu.com/s/1a2_3D-GE9PmJmNCeJNubsA</a> 提取码：xztf</li></ul></li><li>华润物流配送系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1lsLCU3eqMGwfWLQd7ExaKg" target="_blank" rel="noopener">https://pan.baidu.com/s/1lsLCU3eqMGwfWLQd7ExaKg</a> 提取码：d1sn</li></ul></li><li>中外运物流配送系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1f7pWsGCNHKy3H9gnNB8SCQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1f7pWsGCNHKy3H9gnNB8SCQ</a> 提取码：ly4w</li></ul></li><li>闵行国际物流中心仓储管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1omQANJVKhtZL3TvSFhoefg" target="_blank" rel="noopener">https://pan.baidu.com/s/1omQANJVKhtZL3TvSFhoefg</a> 提取码：48v7</li></ul></li><li>粤通物流系统设计说明书 <ul><li>链接：<a href="https://pan.baidu.com/s/1RvORJTuoAjhjjxAuIKqFGA" target="_blank" rel="noopener">https://pan.baidu.com/s/1RvORJTuoAjhjjxAuIKqFGA</a> 提取码：nlas</li></ul></li><li>物流指南App项目需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1Vhpvo2N0BcrFDMFB2KyJhw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Vhpvo2N0BcrFDMFB2KyJhw</a> 提取码：q383</li></ul></li></ul><p>【教育】</p><ul><li>在线考试系统需求说明书 <ul><li>链接：<a href="https://pan.baidu.com/s/1P9U29Mbz8u6dOhxCmxzKQA" target="_blank" rel="noopener">https://pan.baidu.com/s/1P9U29Mbz8u6dOhxCmxzKQA</a> 提取码：ssk8</li></ul></li><li>家校通系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1YyTRL4pZZD987NJfrL7JjA" target="_blank" rel="noopener">https://pan.baidu.com/s/1YyTRL4pZZD987NJfrL7JjA</a> 提取码：odo4</li></ul></li></ul><p>【医疗】</p><ul><li>中山大学医院管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1BZuLiMjtWpsgrhDQj5tCDA" target="_blank" rel="noopener">https://pan.baidu.com/s/1BZuLiMjtWpsgrhDQj5tCDA</a> 提取码：8m46</li></ul></li><li>ICU管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1jGZw_qKCfZrvzYWFhQxn9w" target="_blank" rel="noopener">https://pan.baidu.com/s/1jGZw_qKCfZrvzYWFhQxn9w</a> 提取码：j0oz</li></ul></li><li>X邦住院医生工作站需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1S3Nc_-KrpgOERDCWaoT5sQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1S3Nc_-KrpgOERDCWaoT5sQ</a> 提取码：r9tm</li></ul></li><li>楚雄州人民医院信息化建设一体化集成系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/10cEEEtXIVsVwyKYSooUSiw" target="_blank" rel="noopener">https://pan.baidu.com/s/10cEEEtXIVsVwyKYSooUSiw</a> 提取码：pzqi</li></ul></li><li>佛山区域卫生信息平台与区域电子病历需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1ogpedXfAvWDIxaufppkzfA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ogpedXfAvWDIxaufppkzfA</a> 提取码：wwup</li></ul></li><li>佛山区域医院信息系统 <ul><li>链接：<a href="https://pan.baidu.com/s/13o7HF8XCWvk0YIypCeJSuA" target="_blank" rel="noopener">https://pan.baidu.com/s/13o7HF8XCWvk0YIypCeJSuA</a> 提取码：xk23</li></ul></li><li>合理用药监测系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/12zP7u-LjHTrRCOVc1-J3RQ" target="_blank" rel="noopener">https://pan.baidu.com/s/12zP7u-LjHTrRCOVc1-J3RQ</a> 提取码：4nd9</li></ul></li><li>连锁药店进、销、存流程体系 <ul><li>链接：<a href="https://pan.baidu.com/s/1iH__CjwW6bhQm9BjppScwg" target="_blank" rel="noopener">https://pan.baidu.com/s/1iH__CjwW6bhQm9BjppScwg</a> 提取码：7rmj</li></ul></li><li>临床检验信息系统软件需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1sJ4yFPbkM4Nylg-H_kvXyw" target="_blank" rel="noopener">https://pan.baidu.com/s/1sJ4yFPbkM4Nylg-H_kvXyw</a> 提取码：uds1</li></ul></li><li>门诊医生工作站软件需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1FrKZOxq5PsjQpnk0cCfQqQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1FrKZOxq5PsjQpnk0cCfQqQ</a> 提取码：5q2j</li></ul></li><li>统一维护管理平台软件需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1iac0rRus6QHpmLYhChRKCA" target="_blank" rel="noopener">https://pan.baidu.com/s/1iac0rRus6QHpmLYhChRKCA</a> 提取码：umbg</li></ul></li><li>医学影像系统PACS、RIS软件需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1v861ilZCkr5Hlszs6ADqwQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1v861ilZCkr5Hlszs6ADqwQ</a> 提取码：bbga</li></ul></li><li>医院his系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1CRNCaMSVER5S9u2cf539Cg" target="_blank" rel="noopener">https://pan.baidu.com/s/1CRNCaMSVER5S9u2cf539Cg</a> 提取码：cel5</li></ul></li><li>医院科研教学管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1tw6ax84B4XcdhO8V4POsNg" target="_blank" rel="noopener">https://pan.baidu.com/s/1tw6ax84B4XcdhO8V4POsNg</a> 提取码：ohzo</li></ul></li><li>婴儿防盗系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1To2MyxckIKdqb-oFLoSvsA" target="_blank" rel="noopener">https://pan.baidu.com/s/1To2MyxckIKdqb-oFLoSvsA</a> 提取码：wo2i</li></ul></li><li>预防保健管理系统软件需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1UN8ya0puygmcRp2MnIrOsw" target="_blank" rel="noopener">https://pan.baidu.com/s/1UN8ya0puygmcRp2MnIrOsw</a> 提取码：5dbw</li></ul></li><li>预约挂号系统设计文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1eFSPDZlQvwul3fp4-51GVw" target="_blank" rel="noopener">https://pan.baidu.com/s/1eFSPDZlQvwul3fp4-51GVw</a> 提取码：qh6s</li></ul></li><li>中联医院客户关系管理系统 <ul><li>链接：<a href="https://pan.baidu.com/s/1kYhoVOtySZrfjPVNV97jEQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1kYhoVOtySZrfjPVNV97jEQ</a> 提取码：6ey6</li></ul></li><li>住院护士站软件需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1SE5WZ8594N4nM6Y1GjfzrQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1SE5WZ8594N4nM6Y1GjfzrQ</a> 提取码：sgj9</li></ul></li><li>住院结算信息系统软件需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1X_a_lfDtK40e84rh3EGj7w" target="_blank" rel="noopener">https://pan.baidu.com/s/1X_a_lfDtK40e84rh3EGj7w</a> 提取码：5oh2</li></ul></li></ul><p>【物业】</p><ul><li>锦东地产物业管理系统需求分析 <ul><li>链接：<a href="https://pan.baidu.com/s/1ERbJ9kiu3xh-D3FePhnPUQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1ERbJ9kiu3xh-D3FePhnPUQ</a> 提取码：bsdr</li></ul></li></ul><p>【CRM】</p><ul><li>CrmSky客户关系管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1W9PaUp09YBNqikDqKRMKyw" target="_blank" rel="noopener">https://pan.baidu.com/s/1W9PaUp09YBNqikDqKRMKyw</a> 提取码：jz6f</li></ul></li><li>江苏淮微CRM系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1aO0oWS2nEd3sV3hXoSJZgw" target="_blank" rel="noopener">https://pan.baidu.com/s/1aO0oWS2nEd3sV3hXoSJZgw</a> 提取码：esqq</li></ul></li><li>客户关系管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/17kIfQ4k3zWka6NvERqqlZw" target="_blank" rel="noopener">https://pan.baidu.com/s/17kIfQ4k3zWka6NvERqqlZw</a> 提取码：oa02</li></ul></li></ul><p>【OA】</p><ul><li>MyOffice办公自动化系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1LgeUhfU5UFiAVoT_3OuJCg" target="_blank" rel="noopener">https://pan.baidu.com/s/1LgeUhfU5UFiAVoT_3OuJCg</a> 提取码：6fs6</li></ul></li><li>OA项目需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1nebyPiCmdf7Y87RYJFpcbQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1nebyPiCmdf7Y87RYJFpcbQ</a> 提取码：cu1a</li></ul></li></ul><p>【进销存】</p><ul><li>展德光电进销存系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1EP1VYXcOhAxHI5vtvzEFqg" target="_blank" rel="noopener">https://pan.baidu.com/s/1EP1VYXcOhAxHI5vtvzEFqg</a> 提取码：7dab</li></ul></li><li>进销存软件需求说明书（含表设计清单） <ul><li>链接：<a href="https://pan.baidu.com/s/12-lMsLp2BECx0IR2KbeMAw" target="_blank" rel="noopener">https://pan.baidu.com/s/12-lMsLp2BECx0IR2KbeMAw</a> 提取码：9p0c</li></ul></li></ul><p>【银行】</p><ul><li>CHGM民生银行计费系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1GvXLIKk3zPtyTr13z_ISyg" target="_blank" rel="noopener">https://pan.baidu.com/s/1GvXLIKk3zPtyTr13z_ISyg</a> 提取码：qz2o</li></ul></li><li>民生银行业务活动管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1UeD1CWBU_BiPH9zK-LSg7Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1UeD1CWBU_BiPH9zK-LSg7Q</a> 提取码：vma5</li></ul></li></ul><p>【MRP】</p><ul><li>制衣业MRP系统需求说明书 <ul><li>链接：<a href="https://pan.baidu.com/s/19HQA3Nvsq2CnbwavbdwFkg" target="_blank" rel="noopener">https://pan.baidu.com/s/19HQA3Nvsq2CnbwavbdwFkg</a> 提取码：y6yt</li></ul></li></ul><p>【差旅报销】</p><ul><li>差旅管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1af0DoCFvOBxTRW1ugD0e3w" target="_blank" rel="noopener">https://pan.baidu.com/s/1af0DoCFvOBxTRW1ugD0e3w</a> 提取码：8804</li></ul></li></ul><p>【计费系统】</p><ul><li>电信客户计费系统需求说明书 <ul><li>链接：<a href="https://pan.baidu.com/s/1aGbA6fQivkno0bSUhaBFCg" target="_blank" rel="noopener">https://pan.baidu.com/s/1aGbA6fQivkno0bSUhaBFCg</a> 提取码：5dtv</li></ul></li></ul><p>【房产】</p><ul><li>房产中介需求规格书 <ul><li>链接：<a href="https://pan.baidu.com/s/1P8NPxj8SdptpNHJWfDAG5Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1P8NPxj8SdptpNHJWfDAG5Q</a> 提取码：y8uf</li></ul></li></ul><p>【单据】</p><ul><li>黄金珠宝首饰CS单据管理系统 <ul><li>链接：<a href="https://pan.baidu.com/s/1EIuBcUGeKXP-8ffzDYGS7Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1EIuBcUGeKXP-8ffzDYGS7Q</a> 提取码：7mz3</li></ul></li></ul><p>【WMS】</p><ul><li>芯片WMS管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1RsujMAz80OPh36vkC65Cow" target="_blank" rel="noopener">https://pan.baidu.com/s/1RsujMAz80OPh36vkC65Cow</a> 提取码：zkoz</li></ul></li></ul><p>【SCM】</p><ul><li>荆艺供应链管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1aqksrVN_B_7O0s00FyoxXQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1aqksrVN_B_7O0s00FyoxXQ</a> 提取码：j1hk</li></ul></li></ul><p>【电力】</p><ul><li>国家电力检测中心项目需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1cgZMHVvritbvfZTBNreSJQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1cgZMHVvritbvfZTBNreSJQ</a> 提取码：idzn</li></ul></li></ul><p>【保险】</p><ul><li>保险项目系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/10p3tkUqp8CwO8_ZlnZvtRQ" target="_blank" rel="noopener">https://pan.baidu.com/s/10p3tkUqp8CwO8_ZlnZvtRQ</a> 提取码：hw9r</li></ul></li></ul><p>【餐饮】</p><ul><li>百威美食尚餐饮管理系统需求文档 <ul><li>链接：<a href="https://pan.baidu.com/s/1YTEXycQJjtdWQPuFnqLKiQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1YTEXycQJjtdWQPuFnqLKiQ</a> 提取码：iyu2</li></ul></li></ul><p>【其他】</p><ul><li>智慧社区综合管控系统建设方案 <ul><li>链接：<a href="https://pan.baidu.com/s/15bMbHsXks62sB16_CKHMSA" target="_blank" rel="noopener">https://pan.baidu.com/s/15bMbHsXks62sB16_CKHMSA</a> 提取码：cym5</li></ul></li><li>生产计划执行系统需求分析说明书 <ul><li>链接：<a href="https://pan.baidu.com/s/1AQuPk82RKCofeJy5V6uPfg" target="_blank" rel="noopener">https://pan.baidu.com/s/1AQuPk82RKCofeJy5V6uPfg</a> 提取码：hetj</li></ul></li></ul><hr><p>这份需求文档我也在 GitHub 上保存了一份：</p><ul><li><a href="https://github.com/lenve/javadoc" target="_blank" rel="noopener">https://github.com/lenve/javadoc</a></li></ul><p>如果小伙伴们有其他需求文档，欢迎提交 pr 哦～</p><p>好啦，有了这份需求文档，再加上微人事的技术栈，是时候做个项目展示真正的实力啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有好几位小伙伴向松哥反映，学完了微人事项目的技术点之后，想再做个项目练练手，但是却不知道该做啥！不了解业务就无从下手。&lt;/p&gt;
    
    </summary>
    
      <category term="资料" scheme="http://www.javaboy.org/categories/%E8%B5%84%E6%96%99/"/>
    
    
      <category term="资料" scheme="http://www.javaboy.org/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 视频上传到 B 站了，撸起来！</title>
    <link href="http://www.javaboy.org/2020/1118/es-bilibili.html"/>
    <id>http://www.javaboy.org/2020/1118/es-bilibili.html</id>
    <published>2020-11-18T02:29:46.000Z</published>
    <updated>2020-11-25T02:54:13.820Z</updated>
    
    <content type="html"><![CDATA[<p>在小伙伴们的强烈要求下，松哥把 ElasticSearch 视频也在 B 站同步了一份。其实本来就有同步计划，只不过现在提前了。</p><a id="more"></a><p><img src="http://img.itboyhub.com/2020/20201118103919.png" alt></p><p>由于国内 jg 的原因，一般来说家里的上传带宽都是要远远小于下载带宽，松哥这里也是一样，因此视频上传特别费时间，没法做到 B 站视频和公众号实时同步，我只能在某一个网速好的时候统一将视频上传到 B 站，目前的做法是每周同步一次，所以 B 站的视频更新会略微滞后一些。</p><p>不过大家放心，<strong>B 站每周至少同步一次，公众号每天都会更新</strong>。</p><p>视频链接地址如下（也可以点击文末的阅读原文直达）：</p><ul><li><a href="https://www.bilibili.com/video/BV1ft4y1e7tq" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1ft4y1e7tq</a></li></ul><p>大家也可以扫码来 B 站找我：</p><p><img src="http://img.itboyhub.com/2020/20201118102301.png" alt></p><p>年轻人要讲武德，记得三连哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在小伙伴们的强烈要求下，松哥把 ElasticSearch 视频也在 B 站同步了一份。其实本来就有同步计划，只不过现在提前了。&lt;/p&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/tags/ElasticSearch/"/>
    
      <category term="es" scheme="http://www.javaboy.org/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>接了两个私活，都是血汗钱</title>
    <link href="http://www.javaboy.org/2020/1115/parttime.html"/>
    <id>http://www.javaboy.org/2020/1115/parttime.html</id>
    <published>2020-11-15T02:29:30.000Z</published>
    <updated>2020-11-25T02:54:09.624Z</updated>
    
    <content type="html"><![CDATA[<p>写代码，总想着接点私活，在家休息时，写写代码就能把钱赚了，美滋滋。</p><a id="more"></a><p>然而接了私活，钱有的时候并不是那么好赚。</p><p>松哥刚毕业的时候，对接私活非常执着，当时主要是两方面的原因：</p><ol><li>一个人周末比较宅，空闲时间除了写写博客也没其他事，如果能有个私活，周末应该会丰富很多。</li><li>当时一门心思想着以后回老家，如果能建立比较稳定的私活收入渠道，以后回老家收入就不会受影响。</li></ol><p>在这两个因素的驱动下，国内各种的众包平台我都去注册了，天天去上面浏览有没有人发项目，寻找合适的项目，虽然折腾了很久，但是一无所获。</p><p>一无所获的原因，我当时总结出来了两条：</p><p>第一，刚毕业那会我是做 Android 开发，但是很少有单独外包 Android 的，移动端的外包基本上都是全平台，Android、iOS、H5 都要（当时还没有小程序，否则估计连小程序都要）。这种情况下，要么就是找人组队，要么就是混合开发。找人组队我曾经试过，只能说找志同道合的人并不容易；混合开发我也试了，当时一个比较理想的解决方案是 RN，我还专门去学了，学完后却一直没接到活，囧。</p><p>第二，国内这些众包网站不太适合个人接单，适合小公司去接单。</p><p>我后来想想，感觉 Android 其实不太适合接私活，各种平台适配问题真的让人头大（除非跨平台开发），为了几万块的私活真的划不来。这也是我后来慢慢转向 Web 的原因之一。</p><p>到了 2017 年的时候，我已经开始做 JavaEE 了，对私活没有从前那么执着了，不过此时倒有活找上门来。</p><p>第一个私活是我当时的 leader 介绍给我的，leader 年纪比我大很多，圈子里人脉广，我之前薪水翻倍就是他帮我申请的，所以我对他非常信任。他有朋友想做一个小程序（当时小程序刚刚兴起），需要一个后台服务，问我能不能做，然后再给一个报价。</p><p>这个必须能呀！盼了两年总算接到单了。</p><p>这种后台技术上都没有什么难点，业务理清楚就可以动手做了，我花了差不多一周的时间就搞定了。出于对 leader 的信任，第一个外包没签合同，也没纠结付款的问题，基本上都是甲方说怎么就怎么。后来是项目开始之前，对方付了 50%，项目上线后付了 50%，然后项目免费维护三个月。</p><p>整个合作过程还是蛮顺利的，无论开发还是付款，都没有扯皮，所有事情都是一步到位，当时给我一种错觉，这私活的钱还是蛮好赚的。</p><p>第二个私活是我的高中室友介绍的，室友大学入学时他有一个博士师兄刚好毕业，师兄后来去了东北某 211 高校当老师。室友的师兄想做一个 Web 应用，但是不是我们 Java 擅长的这种企业级开发，他的需求是核工程相关的，相当于一个工业软件，输入大量的核燃料参数，后台进行计算，Web 端实时输出计算过程，计算完成后再绘制大量的图表。</p><p>其实我之前没怎么接触过工业软件，都是企业应用。工业软件还是有很大的不同，很多我们熟悉的库都用不上，我本来想用百度的 echarts 绘图，发现 echarts 提供的图没有一个是和需求相符的，后来没办法，直接上 Canvas 手动画。</p><p>第二次合作也是比较愉快的，毕竟大部分老师都是讲道理的，和讲道理的人共事真的很轻松。</p><p>不过第二个项目拖的时间比较久，主要是中间经过了一个暑假，老师去国外出差，一直没空和我讨论业务，我也就忙自己的事情去了，后来到了九月份才又重新开始搞起，导致这个项目前前后后弄了快半年，所以后来就感觉这个项目性价比一般。</p><p>经过这两个项目之后，我对接私活也有了一些自己的想法：</p><ol><li>大部分私活都是辛苦钱，牺牲自己的休息时间 coding，利润很高的私活很少，毕竟甲方爸爸也不是傻子。对于个人开发者而言，如果你有一个略微完整的项目，每个私活只需要稍微修改一下这个项目就可以交付，这种方式利润还可观一点，如果每次都是从头开始写代码，基本上都是辛苦钱了。</li><li>我还比较幸运，两次都是熟人，因此没签合同，正常来说签一个合同对双方来说都比较好。但是话说回来，需要签合同的私活，说明双方都不是特别信任，这种单子其实并不容易谈，这就很考验你的沟通能力了，这种沟通能力对大部分程序猿来说是一个蛮大的挑战。</li><li>接一个私活，也是交一个朋友。维护好和甲方的关系，往往会有很多意外收获。我做的两个私活都不是一锤子买卖，后来他们都有再次找到我，有新的需求想让我来做（这时候就很有成就感）。</li></ol><p>再后来工作就比较忙了，虽然也有人介绍私活但是我基本上都没有接，转介绍给其他小伙伴去做了。转介绍给其他小伙伴之后，我发现最终他们谈成的概率似乎都很小。</p><p>总之，私活并不太容易做，不是说技术难，而是对你的知识体系、技术栈、沟通能力等等各方面都有要求。</p><p>最后再说一个小插曲：</p><p>在注册众包网站的时候，有一个厦门的公司，但是我有点记不清名字了，注册完没多久，对方就有销售打电话过来，表示他们公司现在积压了很多外包订单，但是需要我先交 8000+ 的会员费，就可以享受他们的会员服务，他们也会优先给我派发订单，我肯定拒绝这种套路了。他们的销售也很不专业，一共给我打过两次电话，第二次打电话了解到我没有付款的意向，就很粗暴的挂掉电话了。后来我听其他人说，这个公司你交钱后它确实会给你派单，不过都是两三百的小单子，钱少事多，干个三五年能把会员费赚回来就不错了。</p><p>不知道小伙伴们有没有接过私活呢？在做的过程中有没有遇到什么奇葩事情？留言分享你的故事，松哥会从中选出 6 位幸运小伙伴，下面的图书任选一本，包邮到家。</p><ul><li>签名版《Spring Boot+Vue 全栈开发实战》一本</li><li>《Spring Boot+Spring Cloud+Vue+Element项目实战》（清华大学出版社，徐丽健 著）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写代码，总想着接点私活，在家休息时，写写代码就能把钱赚了，美滋滋。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="外包" scheme="http://www.javaboy.org/tags/%E5%A4%96%E5%8C%85/"/>
    
      <category term="私活" scheme="http://www.javaboy.org/tags/%E7%A7%81%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 入门</title>
    <link href="http://www.javaboy.org/2020/1105/elastic_search_guide.html"/>
    <id>http://www.javaboy.org/2020/1105/elastic_search_guide.html</id>
    <published>2020-11-05T02:32:10.000Z</published>
    <updated>2020-11-25T02:53:37.718Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>松哥前段时间连载的 Spring Security 基本上告一段落了，接下来我会抽空将这个系列的教程整理成一个系列分发给大家。最近一段时间自己也稍微休息了一下，不写教程的日子虽然可以早早睡觉但是又会感到无聊，得找点事情做，感觉是时候开启一波新的旅程了～</p><a id="more"></a><p>2018 年国庆节期间 ElasticSearch 母公司上市，那个时候我就想写一个 es 教程，可惜后来烂尾了，这事在我心里老是一个疙瘩。最近刚好有一个时间空档，就想着能不能把这个系列给完结了。</p><p>不同于之前的教程，这次的教程我打算出一个视频版+图文混合版的。视频为主，图文为辅。视频我会上传到百度网盘，文末会有文章对应的视频下载链接。</p><p>ElasticSearch 目前也算是非常火了，站内搜索、日志分析都会用到它，而且还可以直接当成 NoSQL 数据库来使用。</p><p>接下来，我们就通过下面这个简单介绍，开启 es 之旅吧～</p><p>松哥针对本文内容录制了一个视频，如下：</p><p><img src="http://img.itboyhub.com/2020/20201123201133.png" alt></p><p>视频下载链接：<a href="https://pan.baidu.com/s/1bIvtBv9OvTEXJUyZRtajgQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1bIvtBv9OvTEXJUyZRtajgQ</a> 提取码: pm94</p><h2 id="1-Lucene"><a href="#1-Lucene" class="headerlink" title="1.Lucene"></a>1.Lucene</h2><p>Lucene 是一个开源、免费、高性能、纯 Java 编写的全文检索引擎，可以算作是开源领域最好的全文检索工具包。</p><p>在实际开发中，Lucene 几乎适用于任何需要全文检索的场景，所以 Lucene 先后发展出好多语言版本，例如 C++、C#、Python 等。</p><p>早在 2005 年，Lucene 就升级为 Apache 顶级开源项目。它的作者是 Doug Cutting，有的人可能没听过这这个人，不过你肯定听过他的另一个大名鼎鼎的作品 Hadoop。</p><p>不过需要注意的是，Lucene 只是一个工具包，并非一个完整的搜索引擎，开发者可以基于 Lucene 来开发完整的搜索引擎。比较著名的有 Solr、ElasticSearch，不过在分布式和大数据环境下，ElasticSearch 更胜一筹。</p><p>Lucene 主要有如下特点：</p><ul><li>简单</li><li>跨语言</li><li>强大的搜索引擎</li><li>索引速度快</li><li>索引文件兼容不同平台</li></ul><h2 id="2-ElasticSearch"><a href="#2-ElasticSearch" class="headerlink" title="2.ElasticSearch"></a>2.ElasticSearch</h2><p>ElasticSearch 是一个分布式、可扩展、近实时性的高性能搜索与数据分析引擎。ElasticSearch 基于 Java 编写，通过进一步封装 Lucene，将搜索的复杂性屏蔽起来，开发者只需要一套简单的 RESTful API 就可以操作全文检索。</p><p>ElasticSearch 在分布式环境下表现优异，这也是它比较受欢迎的原因之一。它支持 PB 级别的结构化或非结构化海量数据处理</p><p>整体上来说，ElasticSearch 有三大功能：</p><ul><li>数据搜集</li><li>数据分析</li><li>数据存储</li></ul><p>ElasticSearch 的主要特点：</p><ol><li>分布式文件存储。</li><li>实时分析的分布式搜索引擎。</li><li>高可拓展性。</li><li>可插拔的插件支持。</li></ol><h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h2><h3 id="3-1-单节点安装"><a href="#3-1-单节点安装" class="headerlink" title="3.1 单节点安装"></a>3.1 单节点安装</h3><p>首先打开 Es 官网，找到 Elasticsearch：</p><ul><li><a href="https://www.elastic.co/cn/elasticsearch/" target="_blank" rel="noopener">https://www.elastic.co/cn/elasticsearch/</a></li></ul><p>然后点击下载按钮，选择合适的版本直接下载即可。</p><p><img src="http://img.itboyhub.com/2020/07/20201102193656.png" alt></p><p>将下载的文件解压，解压后的目录含义如下：</p><table><thead><tr><th>目录</th><th>含义</th></tr></thead><tbody><tr><td>modules</td><td>依赖模块目录</td></tr><tr><td>lib</td><td>第三方依赖库</td></tr><tr><td>logs</td><td>输出日志目录</td></tr><tr><td>plugins</td><td>插件目录</td></tr><tr><td>bin</td><td>可执行文件目录</td></tr><tr><td>config</td><td>配置文件目录</td></tr><tr><td>data</td><td>数据存储目录</td></tr></tbody></table><p>启动方式：</p><p>进入到 bin 目录下，直接执行 ./elasticsearch 启动即可。</p><p><img src="http://img.itboyhub.com/2020/07/20201102194336.png" alt></p><p>看到 started 表示启动成功。</p><p>默认监听的端口是 9200，所以浏览器直接输入 localhost:9200 可以查看节点信息。</p><p><img src="http://img.itboyhub.com/2020/07/20201102194500.png" alt></p><p>节点的名字以及集群（默认是 elasticsearch）的名字，我们都可以自定义配置。</p><p>打开 config/elasticsearch.yml 文件，可以配置集群名称以及节点名称。配置方式如下：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">cluster.name:</span> <span class="hljs-string">javaboy-es</span></span><br><span class="line"><span class="hljs-string">node.name:</span> <span class="hljs-string">master</span></span><br></pre></td></tr></table></figure><p>配置完成后，保存配置文件，并重启 es。重启成功后，刷新浏览器 localhost:9200 页面，就可以看到最新信息。</p><p><img src="http://img.itboyhub.com/2020/07/20201102194918.png" alt></p><p>Es 支持矩阵：</p><ul><li><a href="https://www.elastic.co/cn/support/matrix" target="_blank" rel="noopener">https://www.elastic.co/cn/support/matrix</a></li></ul><h3 id="3-2-HEAD-插件安装"><a href="#3-2-HEAD-插件安装" class="headerlink" title="3.2 HEAD 插件安装"></a>3.2 HEAD 插件安装</h3><p>Elasticsearch-head 插件，可以通过可视化的方式查看集群信息。</p><p>这里介绍两种安装思路。</p><h4 id="3-2-1-浏览器插件安装"><a href="#3-2-1-浏览器插件安装" class="headerlink" title="3.2.1 浏览器插件安装"></a>3.2.1 浏览器插件安装</h4><p>Chrome 直接在 App Store 搜索 Elasticsearch-head，点击安装即可。</p><p><img src="http://img.itboyhub.com/2020/07/20201102195448.png" alt></p><p>公众号<strong>江南一点雨</strong>后台回复 <strong>Elasticsearch-head</strong>，可以下载离线安装包。</p><h4 id="3-2-2-下载插件安装"><a href="#3-2-2-下载插件安装" class="headerlink" title="3.2.2 下载插件安装"></a>3.2.2 下载插件安装</h4><p>四个步骤</p><ul><li><code>git clone git://github.com/mobz/elasticsearch-head.git</code></li><li><code>cd elasticsearch-head</code></li><li><code>npm install</code></li><li><code>npm run start</code></li></ul><p>启动成功，页面如下：</p><p><img src="http://img.itboyhub.com/2020/07/20201102195758.png" alt></p><p>注意，此时看不到集群数据。原因在于这里通过跨域的方式请求集群数据的，默认情况下，集群不支持跨域，所以这里就看不到集群数据。</p><p>解决办法如下，修改 es 的 config/elasticsearch.yml 配置文件，添加如下内容，使之支持跨域：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">http.cors.enabled:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-string">http.cors.allow-origin:</span> <span class="hljs-string">"*"</span></span><br></pre></td></tr></table></figure><p>配置完成后，重启 es，此时 head 上就有数据了。</p><p><img src="http://img.itboyhub.com/2020/07/20201102200140.png" alt></p><h3 id="3-3-分布式安装"><a href="#3-3-分布式安装" class="headerlink" title="3.3 分布式安装"></a>3.3 分布式安装</h3><p>假设：</p><ul><li>一主二从</li><li>master 的端口是 9200，slave 端口分别是 9201 和 9202</li></ul><p>首先修改 master 的 config/elasticsearch.yml 配置文件：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">node.master:</span> <span class="hljs-literal">true</span></span><br><span class="line"><span class="hljs-string">network.host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></span><br></pre></td></tr></table></figure><p>配置完成后，重启 master。</p><p>将 es 的压缩包解压两份，分别命名为 slave01 和 slave02，代表两个从机。</p><p>分别对其进行配置。</p><p>slave01/config/elasticsearch.yml：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 集群名称必须保持一致</span></span><br><span class="line"><span class="hljs-string">cluster.name:</span> <span class="hljs-string">javaboy-es</span></span><br><span class="line"><span class="hljs-string">node.name:</span> <span class="hljs-string">slave01</span></span><br><span class="line"><span class="hljs-string">network.host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></span><br><span class="line"><span class="hljs-string">http.port:</span> <span class="hljs-number">9201</span></span><br><span class="line"><span class="hljs-string">discovery.zen.ping.unicast.hosts:</span> <span class="hljs-string">["127.0.0.1"]</span></span><br></pre></td></tr></table></figure><p>slave02/config/elasticsearch.yml：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 集群名称必须保持一致</span></span><br><span class="line"><span class="hljs-string">cluster.name:</span> <span class="hljs-string">javaboy-es</span></span><br><span class="line"><span class="hljs-string">node.name:</span> <span class="hljs-string">slave02</span></span><br><span class="line"><span class="hljs-string">network.host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></span><br><span class="line"><span class="hljs-string">http.port:</span> <span class="hljs-number">9202</span></span><br><span class="line"><span class="hljs-string">discovery.zen.ping.unicast.hosts:</span> <span class="hljs-string">["127.0.0.1"]</span></span><br></pre></td></tr></table></figure><p>然后分别启动 slave01 和 slave02。启动后，可以在 head 插件上查看集群信息。</p><p><img src="http://img.itboyhub.com/2020/07/20201102201428.png" alt></p><h3 id="3-4-Kibana-安装"><a href="#3-4-Kibana-安装" class="headerlink" title="3.4 Kibana 安装"></a>3.4 Kibana 安装</h3><p>Kibana 是一个 Elastic 公司推出的一个针对 es 的分析以及数据可视化平台，可以搜索、查看存放在 es 中的数据。</p><p>安装步骤如下：</p><ol><li>下载 Kibana：<a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/kibana</a></li><li>解压</li><li>配置 es 的地址信息（可选，如果 es 是默认地址以及端口，可以不用配置，具体的配置文件是 config/kibana.yml）</li><li>执行 ./bin/kibana 文件启动</li><li>localhost:5601</li></ol><p><img src="http://img.itboyhub.com/2020/07/20201102202326.png" alt></p><p>Kibana 安装好之后，首次打开时，可以选择初始化 es 提供的测试数据，也可以不使用。</p><h2 id="4-ElasticSearch-核心概念介绍"><a href="#4-ElasticSearch-核心概念介绍" class="headerlink" title="4.ElasticSearch 核心概念介绍"></a>4.ElasticSearch 核心概念介绍</h2><h3 id="4-1-ElasticSearch-十大核心概念"><a href="#4-1-ElasticSearch-十大核心概念" class="headerlink" title="4.1 ElasticSearch 十大核心概念"></a>4.1 ElasticSearch 十大核心概念</h3><h4 id="4-1-1-集群（Cluster）"><a href="#4-1-1-集群（Cluster）" class="headerlink" title="4.1.1 集群（Cluster）"></a>4.1.1 集群（Cluster）</h4><p>一个或者多个安装了 es 节点的服务器组织在一起，就是集群，这些节点共同持有数据，共同提供搜索服务。</p><p>一个集群有一个名字，这个名字是集群的唯一标识，该名字成为 cluster name，默认的集群名称是 elasticsearch，具有相同名称的节点才会组成一个集群。</p><p>可以在 config/elasticsearch.yml 文件中配置集群名称：</p><figure class="highlight yaml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">cluster.name:</span> <span class="hljs-string">javaboy-es</span></span><br></pre></td></tr></table></figure><p>在集群中，节点的状态有三种：绿色、黄色、红色：</p><ul><li>绿色：节点运行状态为健康状态。所有的主分片、副本分片都可以正常工作。</li><li>黄色：表示节点的运行状态为警告状态，所有的主分片目前都可以直接运行，但是至少有一个副本分片是不能正常工作的。</li><li>红色：表示集群无法正常工作。</li></ul><h4 id="4-1-2-节点（Node）"><a href="#4-1-2-节点（Node）" class="headerlink" title="4.1.2 节点（Node）"></a>4.1.2 节点（Node）</h4><p>集群中的一个服务器就是一个节点，节点中会存储数据，同时参与集群的索引以及搜索功能。一个节点想要加入一个集群，只需要配置一下集群名称即可。默认情况下，如果我们启动了多个节点，多个节点还能够互相发现彼此，那么它们会自动组成一个集群，这是 es 默认提供的，但是这种方式并不可靠，有可能会发生脑裂现象。所以在实际使用中，建议一定手动配置一下集群信息。</p><h4 id="4-1-3-索引（Index）"><a href="#4-1-3-索引（Index）" class="headerlink" title="4.1.3 索引（Index）"></a>4.1.3 索引（Index）</h4><p>索引可以从两方面来理解：</p><p><strong>名词</strong></p><p>具有相似特征文档的集合。</p><p><strong>动词</strong></p><p>索引数据以及对数据进行索引操作。</p><h4 id="4-1-4-类型（Type）"><a href="#4-1-4-类型（Type）" class="headerlink" title="4.1.4 类型（Type）"></a>4.1.4 类型（Type）</h4><p>类型是索引上的逻辑分类或者分区。在 es6 之前，一个索引中可以有多个类型，从 es7 开始，一个索引中，只能有一个类型。在 es6.x 中，依然保持了兼容，依然支持单 index 多个 type 结构，但是已经不建议这么使用。</p><h4 id="4-1-5-文档（Document）"><a href="#4-1-5-文档（Document）" class="headerlink" title="4.1.5 文档（Document）"></a>4.1.5 文档（Document）</h4><p>一个可以被索引的数据单元。例如一个用户的文档、一个产品的文档等等。文档都是 JSON 格式的。</p><h4 id="4-1-6-分片（Shards）"><a href="#4-1-6-分片（Shards）" class="headerlink" title="4.1.6 分片（Shards）"></a>4.1.6 分片（Shards）</h4><p>索引都是存储在节点上的，但是受限于节点的空间大小以及数据处理能力，单个节点的处理效果可能不理想，此时我们可以对索引进行分片。当我们创建一个索引的时候，就需要指定分片的数量。每个分片本身也是一个功能完善并且独立的索引。</p><p>默认情况下，一个索引会自动创建 1 个分片，并且为每一个分片创建一个副本。</p><h4 id="4-1-7-副本（Replicas）"><a href="#4-1-7-副本（Replicas）" class="headerlink" title="4.1.7 副本（Replicas）"></a>4.1.7 副本（Replicas）</h4><p>副本也就是备份，是对主分片的一个备份。</p><h4 id="4-1-8-Settings"><a href="#4-1-8-Settings" class="headerlink" title="4.1.8 Settings"></a>4.1.8 Settings</h4><p>集群中对索引的定义信息，例如索引的分片数、副本数等等。</p><h4 id="4-1-9-Mapping"><a href="#4-1-9-Mapping" class="headerlink" title="4.1.9 Mapping"></a>4.1.9 Mapping</h4><p>Mapping 保存了定义索引字段的存储类型、分词方式、是否存储等信息。</p><h4 id="4-1-10-Analyzer"><a href="#4-1-10-Analyzer" class="headerlink" title="4.1.10 Analyzer"></a>4.1.10 Analyzer</h4><p>字段分词方式的定义。</p><h3 id="4-2-ElasticSearch-Vs-关系型数据库"><a href="#4-2-ElasticSearch-Vs-关系型数据库" class="headerlink" title="4.2 ElasticSearch Vs 关系型数据库"></a>4.2 ElasticSearch Vs 关系型数据库</h3><table><thead><tr><th>关系型数据库</th><th>ElasticSearch</th></tr></thead><tbody><tr><td>数据库</td><td>索引</td></tr><tr><td>表</td><td>类型</td></tr><tr><td>行</td><td>文档</td></tr><tr><td>列</td><td>字段</td></tr><tr><td>表结构</td><td>映射（Mapping）</td></tr><tr><td>SQL</td><td>DSL(Domain Specific Language)</td></tr><tr><td>Select * from xxx</td><td>GET http://</td></tr><tr><td>update xxx set xx=xxx</td><td>PUT http://</td></tr><tr><td>Delete xxx</td><td>DELETE http://</td></tr><tr><td>索引</td><td>全文索引</td></tr></tbody></table><p>这篇文章其实是松哥所录制的 Es 视频教程的笔记，笔记相对简陋一些，小伙伴们也可以参考视频，视频下载链接：<a href="https://pan.baidu.com/s/1bIvtBv9OvTEXJUyZRtajgQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1bIvtBv9OvTEXJUyZRtajgQ</a> 提取码: pm94</p><p><img src="http://img.itboyhub.com/2020/20201123201133.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;松哥前段时间连载的 Spring Security 基本上告一段落了，接下来我会抽空将这个系列的教程整理成一个系列分发给大家。最近一段时间自己也稍微休息了一下，不写教程的日子虽然可以早早睡觉但是又会感到无聊，得找点事情做，感觉是时候开启一波新的旅程了～&lt;/p&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/categories/ElasticSearch/"/>
    
    
      <category term="es" scheme="http://www.javaboy.org/tags/es/"/>
    
      <category term="ElasticSerach" scheme="http://www.javaboy.org/tags/ElasticSerach/"/>
    
  </entry>
  
  <entry>
    <title>打算出一个 ElasticSearch 教程，谁赞成，谁反对？</title>
    <link href="http://www.javaboy.org/2020/1104/es-guide.html"/>
    <id>http://www.javaboy.org/2020/1104/es-guide.html</id>
    <published>2020-11-04T02:29:05.000Z</published>
    <updated>2020-11-25T02:53:59.960Z</updated>
    
    <content type="html"><![CDATA[<p>松哥前段时间连载的 Spring Security 基本上告一段落了，接下来我会抽空将这个系列的教程整理成一个系列分发给大家。最近一段时间自己也稍微休息了一下，不写教程的日子虽然可以早早睡觉但是又会感到无聊，得找点事情做，感觉是时候开启一波新的旅程了～</p><a id="more"></a><p>2018 年国庆节期间 ElasticSearch 母公司上市，那个时候我就想写一个 es 教程，可惜后来烂尾了，这事在我心里老是一个疙瘩。最近刚好有一个时间空档，就想着能不能把这个系列给完结了。</p><p>不同于之前的教程，这次的教程我打算出一个视频版+图文混合版的。视频会首发在公众号上，B 站上也会定期同步视频，可能会以视频为主，图文为辅。</p><p>ElasticSearch 目前也算是非常火了，站内搜索、日志分析都会用到它，而且还可以直接当成 NoSQL 数据库来使用。</p><p>接下来，我们就通过下面这个简单介绍，开启 es 之旅吧～</p><p>以下是视频笔记。</p><h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><p>Lucene 是一个开源、免费、高性能、纯 Java 编写的全文检索引擎，可以算作是开源领域最好的全文检索工具包。</p><p>在实际开发中，Lucene 几乎适用于任何需要全文检索的场景，所以 Lucene 先后发展出好多语言版本，例如 C++、C#、Python 等。</p><p>早在 2005 年，Lucene 就升级为 Apache 顶级开源项目。它的作者是 Doug Cutting，有的人可能没听过这这个人，不过你肯定听过他的另一个大名鼎鼎的作品 Hadoop。</p><p>不过需要注意的是，Lucene 只是一个工具包，并非一个完整的搜索引擎，开发者可以基于 Lucene 来开发完整的搜索引擎。比较著名的有 Solr、ElasticSearch，不过在分布式和大数据环境下，ElasticSearch 更胜一筹。</p><p>Lucene 主要有如下特点：</p><ul><li>简单</li><li>跨语言</li><li>强大的搜索引擎</li><li>索引速度快</li><li>索引文件兼容不同平台</li></ul><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>ElasticSearch 是一个分布式、可扩展、近实时性的高性能搜索与数据分析引擎。ElasticSearch 基于 Java 编写，通过进一步封装 Lucene，将搜索的复杂性屏蔽起来，开发者只需要一套简单的 RESTful API 就可以操作全文检索。</p><p>ElasticSearch 在分布式环境下表现优异，这也是它比较受欢迎的原因之一。它支持 PB 级别的结构化或非结构化海量数据处理</p><p>整体上来说，ElasticSearch 有三大功能：</p><ul><li>数据搜集</li><li>数据分析</li><li>数据存储</li></ul><p>ElasticSearch 的主要特点：</p><ol><li>分布式文件存储。</li><li>实时分析的分布式搜索引擎。</li><li>高可拓展性。</li><li>可插拔的插件支持。</li></ol><p><img src="http://img.itboyhub.com/2020/07/20201029150835.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;松哥前段时间连载的 Spring Security 基本上告一段落了，接下来我会抽空将这个系列的教程整理成一个系列分发给大家。最近一段时间自己也稍微休息了一下，不写教程的日子虽然可以早早睡觉但是又会感到无聊，得找点事情做，感觉是时候开启一波新的旅程了～&lt;/p&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/tags/ElasticSearch/"/>
    
      <category term="es" scheme="http://www.javaboy.org/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>68篇干货，手把手教你通关 Spring Security！</title>
    <link href="http://www.javaboy.org/2020/1102/es-bilibili.html"/>
    <id>http://www.javaboy.org/2020/1102/es-bilibili.html</id>
    <published>2020-11-02T02:30:20.000Z</published>
    <updated>2020-11-25T02:54:25.383Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Security 系列前前后后整了 68 篇文章了，是时候告一个段落了。</p><a id="more"></a><p>这两天松哥抽空把该系列的文章整理了一下，做成了一个索引，方便小伙伴们查找。</p><p>教程地址如下：</p><ul><li><a href="http://www.javaboy.org/springsecurity/">http://www.javaboy.org/springsecurity</a></li><li><a href="http://www.itboyhub.com/springsecurity" target="_blank" rel="noopener">http://www.itboyhub.com/springsecurity</a></li></ul><p>对应的 Demo 地址如下：</p><ul><li><a href="https://github.com/lenve/spring-security-samples" target="_blank" rel="noopener">https://github.com/lenve/spring-security-samples</a></li><li><a href="https://github.com/lenve/oauth2-samples" target="_blank" rel="noopener">https://github.com/lenve/oauth2-samples</a></li></ul><p>前面 javaboy.org 是国外服务器，如果响应慢小伙伴只需要 xxx 即可，不需要我多说了吧。</p><p>后面的 itboyhub.com 是国内服务器，虽然松哥已经买了 CDN 加速服务了，但是响应速度好像还是一般般，所以文末松哥也给出了微信公众号的文章索引。</p><p>小伙伴们按照松哥已经排列好的顺序，一篇一篇练级通关吧！</p><p><img src="http://img.itboyhub.com/2020/07/screencapture-javaboy-org-springsecurity-2020-10-30-20_51_53_01.jpg" alt></p><p><img src="http://img.itboyhub.com/2020/07/screencapture-javaboy-org-springsecurity-2020-10-30-20_51_53_02.jpg" alt></p><p><img src="http://img.itboyhub.com/2020/07/screencapture-javaboy-org-springsecurity-2020-10-30-20_51_53_03.jpg" alt></p><p><img src="http://img.itboyhub.com/2020/07/screencapture-javaboy-org-springsecurity-2020-10-30-20_51_53_04.jpg" alt></p><p><img src="http://img.itboyhub.com/2020/07/screencapture-javaboy-org-springsecurity-2020-10-30-20_51_53_05.jpg" alt></p><p><img src="http://img.itboyhub.com/2020/07/screencapture-javaboy-org-springsecurity-2020-10-30-20_51_53_06.jpg" alt></p><p><img src="http://img.itboyhub.com/2020/07/screencapture-javaboy-org-springsecurity-2020-10-30-20_51_53_07.jpg" alt></p><p><img src="http://img.itboyhub.com/2020/07/screencapture-javaboy-org-springsecurity-2020-10-30-20_51_53_08.jpg" alt></p><p>微信公众号文章索引：</p><ol><li><a href="https://mp.weixin.qq.com/s/3O2yNnG56uAsMnJyrVptDg" target="_blank" rel="noopener">挖一个大坑，Spring Security 开搞！</a></li><li><a href="https://mp.weixin.qq.com/s/Q0GkUb1Nt6ynV22LFHuQrQ" target="_blank" rel="noopener">松哥手把手带你入门 Spring Security，别再问密码怎么解密了</a></li><li><a href="https://mp.weixin.qq.com/s/kHJRKwH-WUx-JEeaQMa7jw" target="_blank" rel="noopener">手把手教你定制 Spring Security 中的表单登录</a></li><li><a href="https://mp.weixin.qq.com/s/Xzt9ymff0DCbAQbklHOxpQ" target="_blank" rel="noopener">Spring Security 做前后端分离，咱就别做页面跳转了！统统 JSON 交互</a></li><li><a href="https://mp.weixin.qq.com/s/BKAYXMaBBs0VrKZtzorn-w" target="_blank" rel="noopener">Spring Security 中的授权操作原来这么简单</a></li><li><a href="https://mp.weixin.qq.com/s/EurEXmU0M9AKuUs4Jh_V5g" target="_blank" rel="noopener">Spring Security 如何将用户数据存入数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/VWJvINbi1DB3fF-Mcx7mGg" target="_blank" rel="noopener">Spring Security+Spring Data Jpa 强强联手，安全管理只有更简单！</a></li><li><a href="https://mp.weixin.qq.com/s/aSsGNBSWMTsAEXjn9wQnYQ" target="_blank" rel="noopener">Spring Boot + Spring Security 实现自动登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/T6_PBRzIADE71af3yoKB6g" target="_blank" rel="noopener">Spring Boot 自动登录，安全风险要怎么控制？</a></li><li><a href="https://mp.weixin.qq.com/s/JucUstZoiTkRG2a2m1Vklg" target="_blank" rel="noopener">在微服务项目中，Spring Security 比 Shiro 强在哪？</a></li><li><a href="https://mp.weixin.qq.com/s/LeiwIJVevaU5C1Fn5nNEeg" target="_blank" rel="noopener">SpringSecurity 自定义认证逻辑的两种方式(高级玩法)</a></li><li><a href="https://mp.weixin.qq.com/s/pSX9XnPNQPyLWGc6oWR3hA" target="_blank" rel="noopener">Spring Security 中如何快速查看登录用户 IP 地址等信息？</a></li><li><a href="https://mp.weixin.qq.com/s/9f2e4Ua2_fxEd-S9Y7DDtA" target="_blank" rel="noopener">Spring Security 自动踢掉前一个登录用户，一个配置搞定！</a></li><li><a href="https://mp.weixin.qq.com/s/nfqFDaLDH8UJVx7mqqgHmQ" target="_blank" rel="noopener">Spring Boot + Vue 前后端分离项目，如何踢掉已登录用户？</a></li><li><a href="https://mp.weixin.qq.com/s/Fuu9rKoOvSyuvCKSyh6dUQ" target="_blank" rel="noopener">Spring Security 自带防火墙！你都不知道自己的系统有多安全！</a></li><li><a href="https://mp.weixin.qq.com/s/9SaNvVfiivWUIAe6OZgpZQ" target="_blank" rel="noopener">什么是会话固定攻击？Spring Boot 中要如何防御会话固定攻击？</a></li><li><a href="https://mp.weixin.qq.com/s/EAacxjaNg8BJRkTkGFLLpQ" target="_blank" rel="noopener">集群化部署，Spring Security 要如何处理 session 共享？</a></li><li><a href="https://mp.weixin.qq.com/s/TDm8ljxbHpMqteucfmeccA" target="_blank" rel="noopener">松哥手把手教你在 SpringBoot 中防御 CSRF 攻击！so easy！</a></li><li><a href="https://mp.weixin.qq.com/s/evyI9wo30JI78_ZYGaKFRg" target="_blank" rel="noopener">要学就学透彻！Spring Security 中 CSRF 防御源码解析</a></li><li><a href="https://mp.weixin.qq.com/s/jBoU5j4YChDVwyX22SbtgA" target="_blank" rel="noopener">Spring Boot 中密码加密的两种姿势！</a></li><li><a href="https://mp.weixin.qq.com/s/6YgV5z3Bbd7wKP5TwI1TQg" target="_blank" rel="noopener">Spring Security 要怎么学？为什么一定要成体系的学习？</a></li><li><a href="https://mp.weixin.qq.com/s/He_K-a-1JpQHZBPEUo2uZw" target="_blank" rel="noopener">Spring Security 两种资源放行策略，千万别用错了！</a></li><li><a href="https://mp.weixin.qq.com/s/BzdCr_rgLttRlq_SWQuG0Q" target="_blank" rel="noopener">松哥手把手教你入门 Spring Boot + CAS 单点登录</a></li><li><a href="https://mp.weixin.qq.com/s/YQMHms9BiVaTgYct4wk2cw" target="_blank" rel="noopener">Spring Boot 实现单点登录的第三种方案！</a></li><li><a href="https://mp.weixin.qq.com/s/dWwscpe9okkJjkGQMWVYvA" target="_blank" rel="noopener">Spring Boot+CAS 单点登录，如何对接数据库？</a></li><li><a href="https://mp.weixin.qq.com/s/uWib5RtH1aEC7p5VK4S1Ig" target="_blank" rel="noopener">Spring Boot+CAS 默认登录页面太丑了，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/LvMOKeX09liTvujZi6XO3Q" target="_blank" rel="noopener">用 Swagger 测试接口，怎么在请求头中携带 Token？</a></li><li><a href="https://mp.weixin.qq.com/s/FaSfN31z4BlxPI2QOa8t1Q" target="_blank" rel="noopener">Spring Boot 中三种跨域场景总结</a></li><li><a href="https://mp.weixin.qq.com/s/7T5XA1zxQkhMvffMxHKVvQ" target="_blank" rel="noopener">Spring Boot 中如何实现 HTTP 认证？</a></li><li><a href="https://mp.weixin.qq.com/s/7cm99q5ZM4qUkekx0Xa0YQ" target="_blank" rel="noopener">Spring Security 中的四种权限控制方式</a></li><li><a href="https://mp.weixin.qq.com/s/_iau1jsnc50vs794_ib0IA" target="_blank" rel="noopener">Spring Security 多种加密方案共存，老破旧系统整合利器！</a></li><li><a href="https://mp.weixin.qq.com/s/edtYkmgx_SnYoqsy-yFmsQ" target="_blank" rel="noopener">神奇！自己 new 出来的对象一样也可以被 Spring 容器管理！</a></li><li><a href="https://mp.weixin.qq.com/s/42-rjiZShvZXYM_ULQt0YQ" target="_blank" rel="noopener">Spring Security 配置中的 and 到底该怎么理解？</a></li><li><a href="https://mp.weixin.qq.com/s/f1teXTEuDR7S0j_Ml2qL8g" target="_blank" rel="noopener">一文搞定 Spring Security 异常处理机制！</a></li><li><a href="https://mp.weixin.qq.com/s/dm2SmUzb7vQZA3C0NFp86A" target="_blank" rel="noopener">写了这么多年代码，这样的登录方式还是头一回见！</a></li><li><a href="https://mp.weixin.qq.com/s/S_maV7OvvfmYUO53AgCu0g" target="_blank" rel="noopener">Spring Security 竟然可以同时存在多个过滤器链？</a></li><li><a href="https://mp.weixin.qq.com/s/sF4vPZQv7rtBYhBhmONJ5w" target="_blank" rel="noopener">Spring Security 可以同时对接多个用户表？</a></li><li><a href="https://mp.weixin.qq.com/s/4dcQ6lohB3sEcnkAXxdZwg" target="_blank" rel="noopener">在 Spring Security 中，我就想从子线程获取用户登录信息，怎么办？</a></li><li><a href="https://mp.weixin.qq.com/s/EZsChg5YG0TBadU4q_CAnA" target="_blank" rel="noopener">深入理解 FilterChainProxy【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/PWIM9jgEB-F-m4Ove470wg" target="_blank" rel="noopener">深入理解 SecurityConfigurer 【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/Kk5c5pK5_LFcCpcnIr2VrA" target="_blank" rel="noopener">深入理解 HttpSecurity【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/kB4m0YJas9LHuNT8JH5ZmQ" target="_blank" rel="noopener">深入理解 AuthenticationManagerBuilder 【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/LBgZu-mBifPG_-azCG7Lcg" target="_blank" rel="noopener">花式玩 Spring Security ，这样的用户定义方式你可能没见过！</a></li><li><a href="https://mp.weixin.qq.com/s/vP-QGm9GNxMInIeGSZvWwQ" target="_blank" rel="noopener">深入理解 WebSecurityConfigurerAdapter【源码篇】</a></li><li><a href="https://mp.weixin.qq.com/s/d2o9QpK1EfBMRR8zfHhv2g" target="_blank" rel="noopener">盘点 Spring Security 框架中的八大经典设计模式</a></li><li><a href="https://mp.weixin.qq.com/s/D0weIKPto4lcuwl9DQpmvQ" target="_blank" rel="noopener">Spring Security 初始化流程梳理</a></li><li><a href="https://mp.weixin.qq.com/s/0WOefpO6-aYSIRNiNnijyg" target="_blank" rel="noopener">为什么你使用的 Spring Security OAuth 过期了？松哥来和大家捋一捋！</a></li><li><a href="https://mp.weixin.qq.com/s/-kDQbP1htEfn_8n7ZfKqmA" target="_blank" rel="noopener">一个诡异的登录问题</a></li><li><a href="https://mp.weixin.qq.com/s/9yK32E44UnIep-5iX0s2Ow" target="_blank" rel="noopener">什么是计时攻击？Spring Boot 中该如何防御？</a></li><li><a href="https://mp.weixin.qq.com/s/1ZWyD41R827FhghiCHY-Sw" target="_blank" rel="noopener">Spring Security 中如何让上级拥有下级的所有权限？</a></li><li><a href="https://mp.weixin.qq.com/s/sU97RQjQq2-XXQt49LkSeQ" target="_blank" rel="noopener">Spring Security 权限管理的投票器与表决机制</a></li><li><a href="https://mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw" target="_blank" rel="noopener">Spring Security 中的 hasRole 和 hasAuthority 有区别吗？</a></li><li><a href="https://mp.weixin.qq.com/s/Q9lfrJ3iioUpYEO9elCtsw" target="_blank" rel="noopener">Spring Security 中如何细化权限粒度？</a></li><li><a href="https://mp.weixin.qq.com/s/98CIxDVrhAiE14EXvgf7Vw" target="_blank" rel="noopener">一个案例演示 Spring Security 中粒度超细的权限控制！</a></li><li><a href="https://mp.weixin.qq.com/s/B03cDEE1i3gT0yDhIxGATw" target="_blank" rel="noopener">Spring Security 中最流行的权限管理模型！</a></li><li><a href="https://mp.weixin.qq.com/s/FzNpjyjbi6bQEEkUDRsnXA" target="_blank" rel="noopener">我又发现 Spring Security 中一个小秘密！</a></li><li><a href="https://mp.weixin.qq.com/s/K5YDMBREzObp2yrmLtGdjw" target="_blank" rel="noopener">聊一个 GitHub 上开源的 RBAC 权限管理系统，很6！</a></li><li><a href="https://mp.weixin.qq.com/s/obLTxCddhJ0kqTqoVN-Axg" target="_blank" rel="noopener">RBAC 案例解读【2】</a></li></ol><p><strong>下面是 OAuth2 相关的技能点：</strong></p><ol><li><a href="https://mp.weixin.qq.com/s/AELXf1nmpWbYE3NINpLDRg" target="_blank" rel="noopener">做微服务绕不过的 OAuth2，松哥也来和大家扯一扯</a></li><li><a href="https://mp.weixin.qq.com/s/GXMQI59U6uzmS-C0WQ5iUw" target="_blank" rel="noopener">这个案例写出来，还怕跟面试官扯不明白 OAuth2 登录流程？</a></li><li><a href="https://mp.weixin.qq.com/s/33Oxu6YMjwco3WRE07_IiQ" target="_blank" rel="noopener">死磕 OAuth2，教练我要学全套的！</a></li><li><a href="https://mp.weixin.qq.com/s/cGopy8hDPtkn8Q7HUYabbA" target="_blank" rel="noopener">OAuth2 令牌还能存入 Redis ？越玩越溜！</a></li><li><a href="https://mp.weixin.qq.com/s/xEIWTduDqQuGL7lfiP735w" target="_blank" rel="noopener">想让 OAuth2 和 JWT 在一起愉快玩耍？请看松哥的表演</a></li><li><a href="https://mp.weixin.qq.com/s/aOXsHSPowmR2zLkF41wPlQ" target="_blank" rel="noopener">最近在做 Spring Cloud 项目，松哥和大家分享一点微服务架构中的安全管理思路</a></li><li><a href="https://mp.weixin.qq.com/s/EyAMTbKPqNNnEtZACIsMVw" target="_blank" rel="noopener">Spring Boot+OAuth2，一个注解搞定单点登录！</a></li><li><a href="https://mp.weixin.qq.com/s/tq4Q306J3hJFEtGL1EpOBA" target="_blank" rel="noopener">分分钟让自己的网站接入 GitHub 第三方登录功能</a></li><li><a href="https://mp.weixin.qq.com/s/lnuAejqGqh_8W_-GHEq5gA" target="_blank" rel="noopener">Spring Boot+OAuth2，如何自定义返回的 Token 信息？</a></li><li><a href="https://mp.weixin.qq.com/s/xJSyPVRq0EwvTi_TBjCI1g" target="_blank" rel="noopener">OAuth2，想说懂你不容易</a></li></ol><p>从三月份到十月份，大半年的业余时间都耗在这个上面了，现在整理索引这个过程真的很享受！感觉这一年的业余时间没浪费。</p><p>好啦，我就不废话了，<strong>这篇文章小伙伴们一定记得收藏哦，小心找不到了。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Security 系列前前后后整了 68 篇文章了，是时候告一个段落了。&lt;/p&gt;
    
    </summary>
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="http://www.javaboy.org/tags/ElasticSearch/"/>
    
      <category term="es" scheme="http://www.javaboy.org/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>毕业五年，身边的小伙伴们突然就开始扎堆结婚了。。。</title>
    <link href="http://www.javaboy.org/2020/1027/graduation-5-years.html"/>
    <id>http://www.javaboy.org/2020/1027/graduation-5-years.html</id>
    <published>2020-10-27T02:28:36.000Z</published>
    <updated>2020-11-25T02:53:44.011Z</updated>
    
    <content type="html"><![CDATA[<p>今天水一篇～</p><p>大学毕业前 5 年，每年都是一两个同学结婚的消息，今年下半年突然就扎堆结婚，而且今年结婚的都是关系比较好的小伙伴，松哥从六月份开始就一直参加婚礼+随份子钱，按照目前的排期，要一直随到 11 月份。</p><a id="more"></a><p>每次去参加婚礼，大家都会问你什么时候结婚，我倒是不着急，女朋友也不着急，我们已经谈了快十年了，稳稳当当，所谓手中有粮，心中不慌。</p><p>女朋友是我大学同班同学，常言道兔子不吃窝边草，不过松哥是只懒兔子。大一在一起，大学四年没有呆腻，大学毕业后异地三年也坚持过来了，现在又一起在深圳生活了快三年，日子平淡充实。</p><p>刚上大一的时候，开学没多久就赶上了校运动会，女朋友当时报了女子 5000 米，于是我天天厚着脸皮约她出来跑步，时间久了一切都顺其自然了，而我也因此爱上跑步，大一坚持跑，体重从高中的 160 狂降到 130 左右。</p><p>刚在一起的时候还没考过试，我万万没想到竟然追到了我们专业的学霸，要是一开始就知道是学霸，我可能都不敢追。记得女朋友有一门专业课考了 100 分，大四的时候，在新生的入学座谈会上，授课老师激动地跟新生讲她带课这么多年，从来没给过谁满分，但是女朋友那份答卷太完美了，破例给了满分，勉励新生都向她学习。松哥自己也是当了四年迷弟。</p><p>大三暑假的时候，女朋友的绩点是我们专业第一，保研是稳稳当当的事情。然后就是联系学校，她看了很多学校，但是我倾向于去西安，因为我家在西安，而且西安的高校也不差，去西安也并不亏，就这样女朋友被保送到西北工大读研，我去西安找工作，她在西安读书，一切都很完美。</p><p>但是当我在西安找工作的时候，发现西安工资太低了，虽然早有心理准备，但是转正后 4000 的工资还是觉得无法接受（2015 年），按这个数这要到猴年马月才能买房呀！父母都是农民，家里没什么钱，对于刚毕业的我来说，最缺的就是钱，广州深圳的薪水倒是不低，而且我也有 offer，但是这就意味着要异地三年。说好了一起回西安，结果你。。。</p><p>家里亲戚包括大学辅导员都劝我不要异地，什么感情经不起考验，也不应该考验感情吧啦吧啦。。。我觉得他们说的都很有道理，但是不适用于我，而且我也有自己的想法：<strong>长久的稳固的爱情，应该是不断提高自己，让自己变的优秀，这样才有能力在精神上或者物质上提供更好的东西给对方，这样的感情才会牢固</strong>。天天呆在一起腻歪，短期有效，但是并不能构建长期稳固的感情。其实这跟上班是一个道理，想要被老板重视，就去提高自己的业务能力让自己变的优秀。</p><p>我说出自己的想法，女朋友也很支持。就这样，我去了广州工作，女朋友则留在西安读书。我在广州也没让人失望，工作一年薪水翻了三倍，2016 年底在毕业一年半的时候，攒够了买房上车的钱，果断在西安把房子买了。买完房子长舒一口气，这是对女朋友也是一个交代，也是对异地的一个交代，当年决定异地是对的。后来大学同学聊天，他们会问你岳父母没说必须先买房才能结婚吗？我说我没等他们开口就已经把房买了。</p><p>异地很辛苦吗？我觉得并不是。女朋友一个人在学校可以专心读书，我在广州可以专心工作。当时公司处于行业红利期，加班三倍工资，有很多出差机会，出差补助标准超级高，而且经常是人还没动，出差补助先发下来，那些有老婆孩子的同事不愿意出差，而我就很愿意出差，领导也乐意让我去，因为不用额外做思想工作，我那一年跑了好多地方，对一个农村娃来说充满了新奇。</p><p>三年很快就过了，毕业后女朋友拿了深圳某大厂 offer，终于团聚了。</p><p>日子依然平平淡淡，我工作也比较忙，好在女朋友很支持。前两天华为的 DevOps 教练徐大师（尊称哈哈）来拜访，他们都快四十岁了，聊到我现在的工作，就问女朋友是否支持我现在的工作，我说她一直都很支持我，徐大师充满感慨，只要家里支持，就没有后顾之忧，就可以专心去干。</p><p>之前我还在想要不要去杭州定居，杭州的房价比深圳友好多了。但是女朋友在深圳上班，贸然让她离职不好，她也有自己的职业规划，我不想她的职业规划被我打断，我也不喜欢把自己的意志强加给别人，但是我会讲讲杭州的好处啥的，日常吹吹风，最终看她想不想去。</p><p>嗯，明年结婚吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天水一篇～&lt;/p&gt;
&lt;p&gt;大学毕业前 5 年，每年都是一两个同学结婚的消息，今年下半年突然就扎堆结婚，而且今年结婚的都是关系比较好的小伙伴，松哥从六月份开始就一直参加婚礼+随份子钱，按照目前的排期，要一直随到 11 月份。&lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="生活" scheme="http://www.javaboy.org/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2，想说懂你不容易</title>
    <link href="http://www.javaboy.org/2020/1016/oauth2.html"/>
    <id>http://www.javaboy.org/2020/1016/oauth2.html</id>
    <published>2020-10-16T02:27:50.000Z</published>
    <updated>2020-11-25T02:53:32.655Z</updated>
    
    <content type="html"><![CDATA[<p>最近几篇都是 OAuth2 相关的，因为松哥最近又在搞 OAuth2。</p><a id="more"></a><p>四月份的时候连载了十来篇文章介绍 OAuth2（公号后台回复 OAuth2 可以下载教程），那个时候用的是 Spring Cloud OAuth2，很多小伙伴可能不清楚 Spring Cloud OAuth2 和 Spring Security OAuth 以及 Spring Security5.x 之间的关系，今天我就来和大家聊一聊 OAuth 协议在 Spring 家族落地的故事。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>大家都知道，OAuth、OAuth2 都是一种协议，协议需要通过代码落地。</p><p>在 2018 年以前，如果我们想在 Spring 构建的项目中使用 OAuth2 协议，首选的框架就是 Spring Security OAuth 这个开源项目，也就是如下依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security.oauth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个项目是十年前 Spring 引入的一个社区驱动的开源项目，经过数十年的发展，它已经非常成熟，可以支持大部分 OAuth 规范，包括<code>资源服务器</code>、<code>客户端</code>和<code>授权服务器</code>等。</p><p>然而数十年前 Spring 家族在 Java 领域的影响力远不如今天这样庞大，虽然 Spring 家族中 OAuth2 的落地项目是 Spring Security OAuth，但是很多 Spring 子项目并不买账，他们自己又搞了一套跟 Spring Security OAuth 类似的 OAuth2 的实现。</p><p>数十年间，OAuth 协议也从 1.0 变成了 2.0，以前没有的 JWT 令牌现在也广泛应用起来了，而 Spring Security OAuth 竟然还支持已经市场抛弃的 OAuth1.0。</p><p>种种迹象表明，这个创建于十年前的 Spring Security OAuth 项目架构似乎需要来一次大换血了。</p><p>于是在 2018 年 1 月 30 号，官方说要逐渐停止 Spring Security OAuth 开源项目，将 OAuth2 的具体实现，在 Spring Security5.x 中进行重构。换句话说，以后如果想在 Spring 中使用 OAuth2，直接引入 Spring Security 依赖就行了，无需再额外引入 OAuth2 依赖。</p><p>从那个时候起，Spring Security OAuth 开源项目就处于维护状态了，现在当我们利用 IDEA 创建一个 Spring Boot 项目时，依赖选项就有没有 Spring Security OAuth 了，如果需要我们只能手动添加。手动添加并使用后，你会发现满屏的删除线：</p><p><img src="http://img.itboyhub.com/2020/07/20201016100711.png" alt></p><p>所以现在并不建议大家再去用这个已经过时的东西。有小伙伴可能会问，那你四月份写的 OAuth2 教程里边，相同的代码怎么都没有删除线呢？这个松哥一会给大家解释。</p><p>OAuth2 框架主要包含三种角色：</p><ul><li>客户端</li><li>资源服务器</li><li>授权服务器</li></ul><p>对于普通开发者而言，接触最多的就是客户端了。你想让你的项目接入 QQ 登录、接入微信登录，你所做的事情就是 OAuth2 客户端的开发，现在在 Spring Security5.x 中，可以直接在 Spring Security 配置的基础上快速配置 OAuth2 客户端，类似下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OAuth2WebSecurityConfigurerAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">http.authorizeRequests((requests) -&gt; requests.anyRequest().authenticated());</span><br><span class="line">http.oauth2Login(Customizer.withDefaults());</span><br><span class="line">http.oauth2Client();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前如果是 Spring Security OAuth 依赖的话，我们要通过 @EnableXXX 去开启客户端，现在在 Spring Security5.x 中重构之后，再去配置 OAuth2 客户端只需要通过一个方法就能搞定，还是非常方便的。</p><p>在少数场景下，你可能就是 QQ、微信的一方，你需要提供自己的登录服务给别人使用，这个时候就需要你开发资源服务器和授权服务器了。</p><p>在最新的 Spring Security5.x 中，我们可以通过如下方式开启资源服务器：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .oauth2ResourceServer()</span><br><span class="line">            .opaqueToken().introspectionUri(introspectionUri)</span><br><span class="line">            .introspectionClientCredentials(clientId, clientSecret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，都是在 Spring Security 的配置上进行配置，非常方便。</p><p>而授权服务器，则不包含在 Spring Security5.x 中。</p><p>在 2019.11.14 日，Spring 官方本来说是要放弃对授权服务器的支持了，因为现在市面上能用的授权服务器太多了，例如 keycloak、Nimbus SDK、Apache Oltu 以及 Vertx-auth-oauth2 等，这些开源的授权服务器都比较成熟稳定，用起来也蛮好用的。</p><p>然而广大开发者并不答应，在争吵了几个月之后，官方宣布了另外一个开源项目 Spring Authorization Server，这个项目用来构建授权服务器。目前该项目已经发布了 0.0.1 版，松哥也抽空体验了一把，功能较少，BUG 较多，官方给的 DEMO 都跑不起来，大家如果想体验这个项目，建议下载最新的源码去编译使用，这样可能问题反而少一些，而不是直接使用 0.0.1 版。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>现在当我们创建一个 Spring Boot 项目时，选择 OAuth2 依赖的时候，有两个地方可以选择：</p><p><img src="http://img.itboyhub.com/2020/07/20201016103020.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20201016103110.png" alt></p><p>两个都能用，但是有差异。</p><p>先说上面的。</p><p>在 Security 分类中，OAuth2 被细分为 OAuth2 Client、OAuth2 Resource Server，但是没有 Authorization Server，这就是目前最新的方案，Spring Security 中将不提供授权服务器。</p><p>如果你的项目是 OAuth2 客户端，那就选择 OAuth2 Client 依赖，如果是 OAuth2 资源服务器，那就选择 OAuth2 Resource Server 依赖。如果是授权服务器，那就。。。。用第三方开源项目吧。</p><p>如果选择的是 Security 中的这些依赖，那么像 @EnableResourceServer、ResourceServerConfigurerAdapter 这些注解或者类都是没有的，需要按照最新的方式去配置。</p><p>如果你是一个比较恋旧的人，还舍不得曾经的配置方式，但是又不想使用 Spring Security OAuth 开源项目，因为有烦人的删除线，那么你可以选择 Spring Cloud Security 中的 Cloud OAuth2 依赖。</p><p>这是针对 Spring Cloud 环境，对 Spring Security 做的一些封装，这个里边的 OAuth2 其实还是 Spring Security OAuth 中的那一套东西，不同的是，这里没有删除线，松哥四月份写的 OAuth2 教程，用的就是 Spring Cloud Security，所以项目打开后你都看不到删除线。</p><p>未来等 OAuth2 在 Spring Security5.x 中的实现稳定下来之后，相信 Spring Cloud Security 这边也会逐步跟进，大家期待的大统一的局面就会来临。</p><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>如果你需要将旧的 OAuth2 项目用最新的方式重构，那么可以参考这个迁移文档，里边有很多 DEMO：<a href="https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Migration-Guide。" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Migration-Guide。</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>作为 Java 工程师，Spring 家族的产品还是用过不少，但是没有哪个项目像 OAuth2 这么混乱这么让人纠结，初学者在选择 OAuth2 依赖时绝对是一脸懵。希望这篇文章能给大家一点启发，小伙伴们在 OAuth2 这块要是有一些使用经验或者见解，也欢迎大家投稿哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几篇都是 OAuth2 相关的，因为松哥最近又在搞 OAuth2。&lt;/p&gt;
    
    </summary>
    
      <category term="OAuth2" scheme="http://www.javaboy.org/categories/OAuth2/"/>
    
    
      <category term="OAuth2" scheme="http://www.javaboy.org/tags/OAuth2/"/>
    
  </entry>
  
  <entry>
    <title>刚过保修期的 MacBook 电池鼓包了。。。怎么就不香了！</title>
    <link href="http://www.javaboy.org/2020/1012/macbook.html"/>
    <id>http://www.javaboy.org/2020/1012/macbook.html</id>
    <published>2020-10-12T02:27:34.000Z</published>
    <updated>2020-11-25T02:53:27.630Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇文章和小伙伴们说过，松哥在 2018 年当时写的书交稿之后，入手了一台 MacBook Pro 犒劳自己，到现在，刚用了两年，电池鼓包了。 </p><a id="more"></a><p>突然就对苹果失去信心了。</p><p>由于 MacBook 的散热很差，我平时使用的时候都用了散热架，所以一直都没发现电池鼓包的问题，也不知道电池是什么时候鼓包的。国庆节期间，在女票家里，打开电脑准备撸几篇文章，突然发现电脑在桌子上放不稳，电脑四个角，轻轻按其中一个角，对角会翘起来。</p><p>一开始我还以为是桌子不平，电脑拿起来反复观察后，发现电脑 D 面（底部）中间鼓起来了，虽然看着不明显，但是已经影响到电脑的平放了。脑海里瞬间闪过一个词，电池鼓包。</p><p>于是赶紧查一下电脑的具体入手日期，看看是否还在保修期内，翻到了 2018 年购买电脑时候的邮件，具体日子是 2018.09.19，到今年国庆节刚刚过保修期十来天，这。。。</p><p>难道又要花钱消灾？</p><p>网上搜了下，发现 MacBook 电池鼓包似乎是一个非常普遍的问题，苹果之前还发布过电池召回通知：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20201009182415.png" alt></p><p>不过很明显我的电脑不在这个范围内。又看了下其他小伙伴的经验贴，送到 Apple Store 自费换电池得千把块，不过也可以在某宝买电池自己换，也不麻烦。</p><p>也在网上看到有人说电池是三年保修期，这个我也不太确定。不管怎么样，先预约去 Apple Store 修电脑吧，如果电池是三年保修期最好了，如果不是，就网上买电池自己换吧，毕竟花千把块换个电池还是蛮心疼的。</p><p>先在 Apple 官网预约附近的 Apple Store，松哥约的是深圳益田假日广场的 Apple Store，预约时候需要输入 MacBook 的序列号，个人的身份信息等，预约成功后，会收到一个预约成功的邮件：</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20201009183658.png" alt></p><p>官网提示要带身份证过去，不过亲测并不会检查身份证，只是需要你现场输入一下身份证号码即可。</p><p>预约好了到时间后把电脑拿去就行了，电池鼓包问题从外观上就能确认，小哥哥检查了之后确认了电池鼓包问题，然后介绍说苹果对于电池问题有三年的保修期，虽然电脑两年保修期过了，但是电池依然可以免费更换。更换时会连同键盘、触摸板等一起更换（我在网上看自己更换的话，可以只更换电池，不知道官方为什么会连同键盘、触摸板一起换）。理论上更换电池并不会影响电脑已有数据，但是保险起见还是建议将重要的数据自己提前备份一下。</p><p>整个过程很快，大概 10 分钟左右就完事了，小哥哥说是当天可能取不了，第二天应该可以修好。不过下午 5 点左右的时候就打电话说是修好了，可以去取了，不过晚上不想动了，明天再去拿电脑吧。</p><p><img src="http://img.itboyhub.com//2020/04/vhr/20201009201650.png" alt></p><p>对于 MacBook 电池鼓包的原因，网上小伙伴们说是因为长期插电使用导致的，老实说我确实是长期插电使用，因为我几乎没有移动办公的需求，不需要带着 MacBook 去星爸爸，大部分情况我都是在工位或者家里使用 MacBook，电源就一直插着懒得动；而且我的第一台笔记本是大一第二学期买的，也就是 2012 年 4 月份，一直插电使用，现在第九个年头了，没有发生电池鼓包问题，所以我从来没想到一直插电使用会发生电池鼓包问题。</p><p>不过网上这个说法有待商榷，我去修电脑时候也问了，对方说电池鼓包和使用习惯没关系，然后说了一大堆电池工作原理（我觉得潜台词就是电池质量有问题）。</p><p>不管怎么说，以后使用还是小心为妙。</p><p>松哥第一台电脑是 2012 年初买的索尼笔记本，做主力机用了将近 8 年，从来没有送修过。我自己手动给加过内存，换过固态硬盘，电脑一直很稳定。用到第 7 年的时候，散热风扇出问题了，电脑经常很烫，进而带来了卡顿的问题，于是我买了个散热底座（是的，前 7 年连散热底座都不需要），这样坚持了 1 年后，散热底座也不管用了，我就在某宝上买了风扇，自己换上了。现在这台电脑退居 2 线，主力机是我的 MacBook。基于第一台笔记本的使用经验，买 MacBook 时，我也希望也能用个七八年吧，但是现在用七八年的信心有点动摇。</p><p>其实我理想的电脑应该是一台自己 DIY 的台式机，里边跑着 Ubuntu，可是出门在外，有一种强烈的漂泊感，搬家也很不方便，所以我很少在深圳给自己置办“固定资产“。MacBook 就是携带方便，搬家方便，希望早点稳定下来吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇文章和小伙伴们说过，松哥在 2018 年当时写的书交稿之后，入手了一台 MacBook Pro 犒劳自己，到现在，刚用了两年，电池鼓包了。 &lt;/p&gt;
    
    </summary>
    
      <category term="侃侃而谈" scheme="http://www.javaboy.org/categories/%E4%BE%83%E4%BE%83%E8%80%8C%E8%B0%88/"/>
    
    
      <category term="MacBook" scheme="http://www.javaboy.org/tags/MacBook/"/>
    
  </entry>
  
  <entry>
    <title>假期结束了，撸一篇技术和大伙分享下吧！</title>
    <link href="http://www.javaboy.org/2020/1009/springsecurity-rbac.html"/>
    <id>http://www.javaboy.org/2020/1009/springsecurity-rbac.html</id>
    <published>2020-10-09T03:07:25.000Z</published>
    <updated>2020-10-30T03:08:43.333Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章是国庆节期间断断续续写的</p></blockquote><p>松哥从上个月 25 号开始一直在外奔波，直到 4 号参加完一个小伙伴的婚礼，见了好多多年未见的同学，现在总算闲下来，可以正式开启国庆假期了，这不赶紧坐在电脑前撸一篇技术文章（没错，国庆节的正确打开方式就是撸文章。</p><a id="more"></a><p>今天还是想和大家伙扯一扯 RBAC 的问题，因为<a href="https://mp.weixin.qq.com/s/K5YDMBREzObp2yrmLtGdjw" target="_blank" rel="noopener">上篇文章</a>发了后，我发现小伙伴们对这个话题很感兴趣，也有很多疑问，所以今天我想再和大家聊一个关于 RBAC 的案例。对于自己不熟悉的东西，多看几个别人写的，然后在某一天的某一刻，你就会突然“顿悟”。</p><p>今天要和小伙伴们分享的是一个来自 Gitee 上的权限管理项目，项目地址是：</p><ul><li><a href="https://gitee.com/vmaps/spring-app" target="_blank" rel="noopener">https://gitee.com/vmaps/spring-app</a></li></ul><p>这个项目的包命名竟然是 com.wangsong，但是小伙伴们注意，这个项目并不是我写的，松哥的项目一般都是 org.javaboy。</p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>springboot-rbac 是 J2EE 基础开发平台，技术栈包括：Spring-Boot、MyBatis、Spring-Security，业务模块包括：用户管理，角色管理、权限管理，字典管理。</p><p>该项目主要包含如下业务功能：</p><ol><li>用户管理：用户增删改查与角色关系</li><li>角色管理：角色增删改查与权限关系</li><li>菜单管理：菜单增删改查（树形结构）</li><li>字典管理：字典增删改查</li></ol><p>该项目涉及到的技术栈有：</p><ol><li>Spring-Boot 依赖注入，切面</li><li>MyBatis ORM</li><li>Spring-Security 权限会话</li></ol><p>和<a href="https://mp.weixin.qq.com/s/K5YDMBREzObp2yrmLtGdjw" target="_blank" rel="noopener">上篇文章</a>中介绍的 RBAC 项目相比，这个项目最大的优势在于它是通过 Spring Security 来实现的 RBAC，对于项目使用 Spring Security 的小伙伴而言，这个就具备较高的参考价值。</p><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><ol><li>导入数据库脚本 springboot-app.sql</li><li>启动 sprtingboot-rbac 位置 com.wangsong.Application</li><li>访问 /html/login.html</li></ol><p>这是官方给出的部署流程，松哥再详细说两句。</p><p>首先下载下来的项目根目录下就有 SQL 脚本，直接执行即可。</p><p>执行完毕后，在 application.properties 中修改数据库配置信息，主要是数据库连接地址以及数据库用户名/密码。</p><p>由于 JAXB API 是 JavaEE  的 API，因此在 JavaSE 9.0 中不再包含这个 Jar 包。Java9 中引入了模块的概念，默认情况下，JavaSE 中将不再包含 JavaEE 的 Jar 包。而在 Java6/7/8 中这个 API 都是捆绑在一起的。</p><p>所以如果你使用的 JDK9（含）以上的版本，还需要额外添加依赖：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>否则会报如下异常：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter</span><br></pre></td></tr></table></figure><p>配置完成后，启动项目即可。启动后访问 <a href="http://localhost:8080/html/login.html" target="_blank" rel="noopener">http://localhost:8080/html/login.html</a> 页面即可。</p><p>这个项目的前端是使用 jQuery EasyUI 来做的，虽然有点过时，但是这并不妨碍我们理解后端的权限管理系统。</p><p>我们来看几张效果图：</p><p><img src="http://img.itboyhub.com/2020/07/20201005110117.png" alt="登录页面"></p><p><img src="http://img.itboyhub.com/2020/07/20201005110150.png" alt="项目首页"></p><p><img src="http://img.itboyhub.com/2020/07/20201005111038.png" alt="用户管理"></p><p><img src="http://img.itboyhub.com/2020/07/20201005111107.png" alt="角色管理"></p><p><img src="http://img.itboyhub.com/2020/07/20201005211134.png" alt="权限管理"></p><p><img src="http://img.itboyhub.com/2020/07/20201005211204.png" alt="字典管理"></p><p>可以看到，一个权限管理的基础功能都是有的。</p><h2 id="数据库分析"><a href="#数据库分析" class="headerlink" title="数据库分析"></a>数据库分析</h2><p>正常来说，RBAC0 需要 5 张表，这个项目里给出了 6 张表，其中一个是 system_dict 字典表，字典表的作用是定义了权限的类型。</p><p>权限的类型分为两种，菜单权限和按钮权限。</p><p>菜单权限就是类似于微人事（<a href="https://github.com/lenve/vhr）中的那种，用户是否具备某一个菜单的访问权限，如果具备，左边显示的菜单列表就有对应的菜单项。" target="_blank" rel="noopener">https://github.com/lenve/vhr）中的那种，用户是否具备某一个菜单的访问权限，如果具备，左边显示的菜单列表就有对应的菜单项。</a></p><p>按钮权限就是用户是否具备某一个按钮的点击权限。</p><p>一般来说，如果用户不具备某一个按钮的点击权限，在前端我们应当将这个按钮隐藏起来，不让用户看到有这个按钮。当然后端也要通过注解等方式做出相应的权限控制。</p><p>该项目设计的权限表结构如下：</p><p><img src="http://img.itboyhub.com/2020/07/20201005212920.png" alt></p><p>作者给出的数据库脚本中都没有注释，不过看字段名大概也能猜出其含义，猜不出来的话，可以参考 Java 代码中对应的实体类，实体类上面都有注释。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>这个项目的代码虽然量比较大，但是和 Spring Security 相关的并不多，松哥来和大家简单梳理一下，方便大家理解这个项目。</p><p><strong>CustomUserDetails</strong></p><p>这个项目的标准用户类，也就是能被 Spring Security 识别的用户类，我们来看下其定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Data</span></span><br><span class="line"><span class="hljs-meta">@NoArgsConstructor</span></span><br><span class="line"><span class="hljs-meta">@AllArgsConstructor</span></span><br><span class="line"><span class="hljs-meta">@ApiModel</span>(value = <span class="hljs-string">"User"</span>, description = <span class="hljs-string">"用户"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"id"</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> String id;</span><br><span class="line">    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"账户名"</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-meta">@ApiModelProperty</span>(value = <span class="hljs-string">"密码"</span>)</span><br><span class="line">    <span class="hljs-keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Getter</span></span><br><span class="line"><span class="hljs-meta">@ToString</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUserDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1702923242319850756L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> enabled;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accountNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> credentialsNonExpired;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> accountNonLocked;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomUserDetails</span><span class="hljs-params">(User user, <span class="hljs-keyword">boolean</span> enabled, <span class="hljs-keyword">boolean</span> accountNonExpired, <span class="hljs-keyword">boolean</span> credentialsNonExpired, <span class="hljs-keyword">boolean</span> accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span></span><br><span class="line">                &amp;&amp; !StringUtils.isBlank(user.getUsername())</span><br><span class="line">                &amp;&amp; !StringUtils.isBlank(user.getPassword())) &#123;</span><br><span class="line">            setId(user.getId());</span><br><span class="line">            setUsername(user.getUsername());</span><br><span class="line">            setPassword(user.getPassword());</span><br><span class="line">            <span class="hljs-keyword">this</span>.enabled = enabled;</span><br><span class="line">            <span class="hljs-keyword">this</span>.accountNonExpired = accountNonExpired;</span><br><span class="line">            <span class="hljs-keyword">this</span>.credentialsNonExpired = credentialsNonExpired;</span><br><span class="line">            <span class="hljs-keyword">this</span>.accountNonLocked = accountNonLocked;</span><br><span class="line">            <span class="hljs-keyword">this</span>.authorities = Collections.unmodifiableSet(<span class="hljs-keyword">new</span> HashSet&lt;&gt;(CollectionUtils.emptyIfNull(authorities)));</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot pass null or empty values to constructor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，用户信息由普通的用户类 User 接收，然后其他属性通过构造方法参数传入进来。这个定义是比较简单的，松哥担心有的小伙伴发现 User 类没有实现 UserDetails 接口会觉得奇怪，因此这里说一下。</p><p><strong>JWTLoginFilter</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTLoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">  <span class="hljs-keyword">private</span> UserService userService;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JWTLoginFilter</span><span class="hljs-params">(AuthenticationManager authenticationManager)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JWTLoginFilter</span><span class="hljs-params">(AuthenticationManager authenticationManager, UserService userService)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">    <span class="hljs-keyword">this</span>.userService = userService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 接收并解析用户凭证</span></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest req,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                              HttpServletResponse res)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">    String username =  req.getParameter(<span class="hljs-string">"username"</span>);</span><br><span class="line">    String password = req.getParameter(<span class="hljs-string">"password"</span>);</span><br><span class="line"></span><br><span class="line">    UserDetails userDetails = userService.loadUserByUsername(username);</span><br><span class="line">    <span class="hljs-keyword">return</span> authenticationManager.authenticate(</span><br><span class="line">        <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(username, password, userDetails.getAuthorities()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// 用户成功登录后，这个方法会被调用，我们在这个方法里生成token</span></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest req,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                          HttpServletResponse res,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                          FilterChain chain,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                          Authentication auth)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String token = Jwts.builder()</span><br><span class="line">        .setSubject(((CustomUserDetails) auth.getPrincipal()).getUsername())</span><br><span class="line">        .setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">1000</span>))</span><br><span class="line">        .signWith(SignatureAlgorithm.HS512, <span class="hljs-string">"MyJwtSecret"</span>)</span><br><span class="line">        .compact();</span><br><span class="line">    res.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Bearer "</span> + token);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个自定义过滤器，用来替代 Spring Security 中默认的验证逻辑，在这里验证用户名密码正确后，生成一个 token，并将 token 返回给客户端。</p><p>该类继承自 UsernamePasswordAuthenticationFilter，重写了其中的两个方法：</p><ul><li>attemptAuthentication：接收并解析用户凭证。</li><li>successfulAuthentication：用户成功登录后，这个方法会被调用，我们在这个方法里生成 token 并添加到响应头中。</li></ul><p>这就是登录生成 JWT 的过程。</p><p><strong>JWTAuthenticationFilter</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BasicAuthenticationFilter</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">private</span> UserService userService;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JWTAuthenticationFilter</span><span class="hljs-params">(AuthenticationManager authenticationManager)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(authenticationManager);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JWTAuthenticationFilter</span><span class="hljs-params">(AuthenticationManager authenticationManager, UserService userService)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>(authenticationManager);</span><br><span class="line">    <span class="hljs-keyword">this</span>.userService=userService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    String header = request.getHeader(<span class="hljs-string">"Authorization"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (header == <span class="hljs-keyword">null</span> || !header.startsWith(<span class="hljs-string">"Bearer "</span>)) &#123;</span><br><span class="line">      chain.doFilter(request, response);</span><br><span class="line">      <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UsernamePasswordAuthenticationToken authentication = getAuthentication(request);</span><br><span class="line"></span><br><span class="line">    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">private</span> UsernamePasswordAuthenticationToken <span class="hljs-title">getAuthentication</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String token = request.getHeader(<span class="hljs-string">"Authorization"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (token != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">      <span class="hljs-comment">// parse the token.</span></span><br><span class="line">      String user = Jwts.parser()</span><br><span class="line">          .setSigningKey(<span class="hljs-string">"MyJwtSecret"</span>)</span><br><span class="line">          .parseClaimsJws(token.replace(<span class="hljs-string">"Bearer "</span>, <span class="hljs-string">""</span>))</span><br><span class="line">          .getBody()</span><br><span class="line">          .getSubject();</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        UserDetails userDetails = userService.loadUserByUsername(user);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(user, <span class="hljs-keyword">null</span>, userDetails.getAuthorities());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是一个自定义过滤器。当用户登录成功后，以后所有的请求都会携带一个 JWT 令牌，携带 JWT 令牌的请求将在这个过滤器中进行验证，验证成功后，将登录主体信息放入 SecurityContextHolder 中即可。</p><p>最后在 Security 配置类中，将两个自定义的过滤器添加进去即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>,securedEnabled =<span class="hljs-keyword">true</span>)<span class="hljs-comment">//激活方法上的PreAuthorize注解</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebSecurityConfig</span><span class="hljs-params">(UserService userService)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.userService = userService;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.headers().frameOptions().disable();</span><br><span class="line">    http.cors().and().csrf().disable().authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/html/**"</span>,<span class="hljs-string">"/login"</span>).permitAll()</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        .addFilter(<span class="hljs-keyword">new</span> JWTLoginFilter(authenticationManager(),userService))</span><br><span class="line">        .addFilter(<span class="hljs-keyword">new</span> JWTAuthenticationFilter(authenticationManager(),userService));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在各个 Controller 方法上通过注解去控制权限：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Api</span>(value = <span class="hljs-string">"权限管理"</span>)</span><br><span class="line"><span class="hljs-meta">@Controller</span></span><br><span class="line"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/system/resources"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourcesController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-keyword">private</span> ResourcesService resourcesService;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-keyword">private</span> UserService userService;</span><br><span class="line">    <span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"增加"</span>, httpMethod = <span class="hljs-string">"POST"</span>)</span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasAuthority('/system/resources/add')"</span>)</span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/add"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">add</span><span class="hljs-params">(@ModelAttribute Resources resources)</span> </span>&#123;</span><br><span class="line">        resourcesService.insertResources(resources);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(CodeEnum.SUCCESS.getCode(), <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"删除"</span>, httpMethod = <span class="hljs-string">"POST"</span>)</span><br><span class="line">    <span class="hljs-meta">@ApiImplicitParams</span>(&#123;</span><br><span class="line">            <span class="hljs-meta">@ApiImplicitParam</span>(name = <span class="hljs-string">"id"</span>, value = <span class="hljs-string">"id"</span>, paramType = <span class="hljs-string">"form"</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasAuthority('/system/resources/delete')"</span>)</span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/delete"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">delete</span><span class="hljs-params">(String[] id)</span> </span>&#123;</span><br><span class="line">        resourcesService.deleteResources(id);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(CodeEnum.SUCCESS.getCode(), <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"更新"</span>, httpMethod = <span class="hljs-string">"POST"</span>)</span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasAuthority('/system/resources/update')"</span>)</span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/update"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">update</span><span class="hljs-params">(@ModelAttribute Resources resources)</span> </span>&#123;</span><br><span class="line">        resourcesService.updateResources(resources);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(CodeEnum.SUCCESS.getCode(), <span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"列表"</span>, httpMethod = <span class="hljs-string">"POST"</span>)</span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasAuthority('/system/resources/list')"</span>)</span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/list"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(CodeEnum.SUCCESS.getCode(), resourcesService.findResources());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"权限码列表"</span>, httpMethod = <span class="hljs-string">"POST"</span>)</span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/findResourcesEMUByResources"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">findResourcesEMUByResources</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        String userDetails = (String) SecurityContextHolder.getContext()</span><br><span class="line">                .getAuthentication()</span><br><span class="line">                .getPrincipal();</span><br><span class="line">        User u=<span class="hljs-keyword">new</span> User();</span><br><span class="line">        u.setUsername(userDetails);</span><br><span class="line">        User tByT = userService.findTByT(u);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(CodeEnum.SUCCESS.getCode(), resourcesService.findResourcesEMUByResources(tByT.getId()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@ApiOperation</span>(value = <span class="hljs-string">"单条"</span>, httpMethod = <span class="hljs-string">"POST"</span>)</span><br><span class="line">    <span class="hljs-meta">@ApiImplicitParams</span>(&#123;</span><br><span class="line">            <span class="hljs-meta">@ApiImplicitParam</span>(name = <span class="hljs-string">"id"</span>, value = <span class="hljs-string">"id"</span>, paramType = <span class="hljs-string">"form"</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/selectByPrimaryKey"</span>)</span><br><span class="line">    <span class="hljs-meta">@ResponseBody</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(CodeEnum.SUCCESS.getCode(), resourcesService.selectByPrimaryKey(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到，资源和权限是绑定的，要修改就只能修改代码了。</p><p>但是权限和角色、角色和用户是在数据库中绑定的，如果需要调整用户的访问资源，只需要针对数据库做相应的增删改查即可。</p><p>整体来说，这个项目的实现思路还是非常 Easy 的，只要小伙伴们看了松哥本系列前面的文章，这个项目应该是很好理解的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>老实说，这个项目代码细节有一些槽点，不过单纯看 RBAC 的实现思路还是没问题的，槽点松哥这里就不多说了，我们只需要关注对我们有用的东西即可。小伙伴们也可以在学习过程中把重点放在理解 RBAC 实现思路上。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇文章是国庆节期间断断续续写的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;松哥从上个月 25 号开始一直在外奔波，直到 4 号参加完一个小伙伴的婚礼，见了好多多年未见的同学，现在总算闲下来，可以正式开启国庆假期了，这不赶紧坐在电脑前撸一篇技术文章（没错，国庆节的正确打开方式就是撸文章。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>为了避免“内卷”，松哥跑去上海见世面了</title>
    <link href="http://www.javaboy.org/2020/0928/huawei-connect.html"/>
    <id>http://www.javaboy.org/2020/0928/huawei-connect.html</id>
    <published>2020-09-28T01:57:32.000Z</published>
    <updated>2020-10-09T00:43:31.630Z</updated>
    
    <content type="html"><![CDATA[<p>25 号在 HC 会场跑了一天，脚都酸了。晚上回到酒店，刚打开手机，就看到网传华为松山湖一个在建的项目着火，万幸没有人员伤亡。2020 对华为来说真是坎坷。</p><a id="more"></a><p>我前两天也受邀参加了华为在上海世博中心举办的 2020 全联接大会（huawei connect），受疫情影响，今年的全联接大会规模缩水了很多，不过今年的 HC 大会还是有很多精彩的训练营、讲演以及比赛，感觉也是不虚此行。</p><p>今年的 HC 大会一共是四天，9.23-9.26，前两天是商业相关，后两天则和开发者相关，因此我是 25 号一大早出发，大概九点多到上海，十点多到会场。第一次来上海，中国的第一大都市，地铁竟然不能用微信/支付宝，感觉这实在不符合上海这座中国 GDP 第一城的身份。</p><p>从中华艺术宫地铁站出来，就有会务的小伙伴举着牌引导参会路线，每个转弯路口都有人，大概走三四百米就到会场了，世博中心南 2 号门。</p><p><img src="http://img.itboyhub.com/2020/07/20200925212355.png" alt></p><p>进来之后，左边是展厅，楼上的会议室会有不同的演讲和训练营，还有一个 2020 华为云无人车挑战杯二十强赛队的总决赛都在楼上举行，没法同时参加这么多活动，只能先选择自己相对感兴趣的活动参加，其他的如果感兴趣可以会后看录播。</p><p><img src="http://img.itboyhub.com/2020/07/20200925223302.png" alt></p><p>松哥就直奔展厅看黑科技去了。</p><p><img src="http://img.itboyhub.com/2020/07/20200925223335.png" alt></p><p>华为最广为人知的身份就是 ICT 解决方案供应商，其实这只是它的看家本领，除了看家本领，华为也涉及到很多其他领域，例如智慧城市、智能电网、智慧政务、智慧油气、智慧城轨、智能铁路、智慧教育等等。</p><p>比如这个，挖掘技术哪家强？</p><p><img src="http://img.itboyhub.com/2020/07/20200927220110.png" alt></p><p>这是华为的 5G+智慧天车，通过远程操控炼钢区天车，使工人远离高危场景、高温环境、粉尘污染等不利于身心健康的工作环境，有效提升生产效率，避免了安全生产问题。</p><p>再比如这个，智慧园区：</p><p><img src="http://img.itboyhub.com/2020/07/20200927220807.png" alt></p><p>园区火灾可以自动通知到附近的人，园区资产离开划定范围会自动报警等等。</p><p>还有很多其他的展示，比如智慧航空，如果有小伙伴最近一两年到过深圳宝安机场，应该也会见到华为和深圳宝安机场合作的智慧航空。</p><p>展台还是有点枯燥，不过还是有一些比较好玩的，例如这个叫做“绝影”的机器狗：</p><p><img src="http://img.itboyhub.com/2020/07/20200925224522.png" alt></p><p>松哥还录了一小段视频：</p><!--插入视频--><p>这个机器狗能翻跟斗能尬舞，跌倒了还能自己爬起来。它是通过华为的普惠 AI 开发平台 ModelArts 训练出来的，这条狗可以在模拟的工厂危险场景中规划路线，跑步关闭燃气控制阀门，解除火情！</p><p>松哥的读者可能都是搞 Java 的，华为的 ModelArts 可能接触的少，我大概说两句：这个 ModelArts 是面向开发者的一站式 AI 开发平台，为机器学习与深度学习提供海量数据预处理及半自动化标注、大规模分布式 Training、自动化模型生成，及端-边-云模型按需部署能力，帮助用户快速创建和部署模型，管理全周期 AI 工作流。简单来说，如果你想搞 AI，使用这个可以显著降低学习门槛。</p><p>人气最旺的展台应该是 Developer 了：</p><p><img src="http://img.itboyhub.com/2020/07/20200925225956.png" alt></p><p>松哥猜测可能是因为 Developer 送的小礼物较多（狗头</p><p>展区有一些专题演讲，比如深圳 HDZ 核心组织者曹一峰总介绍 HDZ：</p><p><img src="http://img.itboyhub.com/2020/07/20200925231112.png" alt></p><p>各地 HDZ 成员的合照：</p><p><img src="http://img.itboyhub.com/2020/07/20200927230901.png" alt></p><p>HDZ 是华为开发者地带，有点类似于谷歌的 GDG，由各地区的小伙伴自主运营，举办一些线下技术沙龙，技术分享会等等，感兴趣的小伙伴可以找找你们当地的 HDZ 组织哦～</p><p>在展区出口的地方竟然看到了 JetBrains 也去摆摊了，又惊又喜：</p><p><img src="http://img.itboyhub.com/2020/07/20200925230316.png" alt><br><img src="http://img.itboyhub.com/2020/07/20200925230459.png" alt></p><p>这是展区的情况，现场还有很多训练营，松哥因为时间关系，主要去听了云原生训练营，我把训练营的 ppt 上传到百度网盘了，有需要的小伙伴可以在公号后台回复<code>云原生</code>下载。</p><p>另外还有无人车挑战杯总决赛还是蛮有意思的，可惜我错过了现场，只好回来后看录播，感兴趣的小伙伴可以自己看看：<a href="https://live.huawei.com/Cloud-AI/meeting/cn/5893.html。" target="_blank" rel="noopener">https://live.huawei.com/Cloud-AI/meeting/cn/5893.html。</a></p><p>26 号则主要是开发者嘉年华，这应该是整个展会期间最嗨的一段了。</p><p><img src="http://img.itboyhub.com/2020/07/20200925223401.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927223745.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927223441.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927223500.png" alt></p><p>嘉年华穿插着各种颁奖，颁了两个五百万大奖：</p><p><img src="http://img.itboyhub.com/2020/07/20200927224038.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927224111.png" alt></p><p>还有社区之星的颁奖：</p><p><img src="http://img.itboyhub.com/2020/07/20200927224521.png" alt></p><p><img src="http://img.itboyhub.com/2020/07/20200927224535.png" alt></p><p>华为公有云虽然起步较晚，但是这两年发展迅猛，成果还是有目共睹的。这次的 HC 大会就很好的展示华为云的技术实力。</p><hr><p>老实说，松哥平时在深圳还是相当宅，周末也不怎么动，一方面是因为事情比较多，另一方面也是自己比较懒。但是对于一些行业的活动，只要时间允许，我还是比较乐意参加的，一方面可以去见见世面，看看同行们都在关注什么技术，也看看自己的不足；另一方面则是多认识一些小伙伴，总之就是要尽量避免自己“内卷”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;25 号在 HC 会场跑了一天，脚都酸了。晚上回到酒店，刚打开手机，就看到网传华为松山湖一个在建的项目着火，万幸没有人员伤亡。2020 对华为来说真是坎坷。&lt;/p&gt;
    
    </summary>
    
      <category term="HUAWEI" scheme="http://www.javaboy.org/categories/HUAWEI/"/>
    
    
      <category term="huawei" scheme="http://www.javaboy.org/tags/huawei/"/>
    
      <category term="hdz" scheme="http://www.javaboy.org/tags/hdz/"/>
    
  </entry>
  
  <entry>
    <title>聊一个 GitHub 上开源的 RBAC 权限管理系统，很6！</title>
    <link href="http://www.javaboy.org/2020/0925/springsecurity-rbac.html"/>
    <id>http://www.javaboy.org/2020/0925/springsecurity-rbac.html</id>
    <published>2020-09-25T01:57:17.000Z</published>
    <updated>2020-10-09T00:45:32.266Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>前两天写了一篇文章，和大家大概聊了聊 RBAC 权限管理系统：</p><a id="more"></a><ul><li><a href="https://mp.weixin.qq.com/s/B03cDEE1i3gT0yDhIxGATw" target="_blank" rel="noopener">Spring Security 中最流行的权限管理模型！</a></li></ul><p>RBAC 理论其实并不难，相信大家看完文章都能明白。但是如何将理论转为实践代码，这还需要一点功力。</p><p>大家可能在网上也会见到众多自称 RBAC 的权限管理系统，这些系统有的确实是 RBAC，有的虽然自称 RBAC，其实并不是。</p><p>为了帮助小伙伴掌握 RBAC 权限管理模型，松哥经过大量的摸排，找到了一些开源的 RBAC 权限管理系统，我想写几篇文章和大家分析一下这些系统的实现，搞懂了别人的实现逻辑，自己再去做就非常容易了。</p><p>今天要和大家介绍的是一个来自 GitHub 上的项目，叫做 wetech-admin。</p><h2 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1.项目介绍"></a>1.项目介绍</h2><p>wetech-admin 是基于 Spring Boot 2.0+Mybatis+Vue 的轻量级后台管理系统，适用于中小型项目的管理后台，支持按钮级别的权限控制，系统具有最基本的用户管理、角色管理、权限管理等通用性功能，企业或个人可直接在此基础上进行开发，扩展，添加各自的需求和业务功能!</p><ul><li>项目地址：<a href="https://github.com/cjbi/wetech-admin" target="_blank" rel="noopener">https://github.com/cjbi/wetech-admin</a></li></ul><p>松哥看了下这个项目，基本上是满足 RBAC0 模型，功能上比较完整，唯一有点遗憾的是，它是用 Shiro 开发的，而不是 Spring Security。</p><p>不过这个并不影响我们学习 RBAC，RBAC 作为一种权限模型是语言无关的，无论你用什么语言都可以实现 RBAC，更不用说同一种语言的不同框架了。</p><p>只要我们把这个 RBAC 搞懂，用 Spring Security 实现 RBAC 自然也不在话下。其实 Spring Security 实现 RBAC 所需要的技术，在松哥本系列的文章中基本上都已经介绍过了，现在只要大家搞懂了模型，就能很快实现。</p><p>我们来看看这个项目的几个效果图：</p><p><img src="http://img.itboyhub.com/2020/07/20200924112633.png" alt></p><p>可以看到，用户列表、角色列表、权限列表，三个菜单涉及到了权限管理中三张表。</p><p><img src="http://img.itboyhub.com/2020/07/20200924112742.png" alt="用户管理"></p><p><img src="http://img.itboyhub.com/2020/07/20200924113024.png" alt="角色管理"></p><p><img src="http://img.itboyhub.com/2020/07/20200924112843.png" alt="权限管理"></p><h2 id="2-项目部署"><a href="#2-项目部署" class="headerlink" title="2.项目部署"></a>2.项目部署</h2><ol><li>通过 git 下载源码</li><li>创建数据库 wetech_admin，数据库编码为UTF-8</li><li>依次执行 src/main/resources/schema.sql 和 dsrc/main/resources/data.sql 文件，初始化数据</li><li>修改 application-dev.properties 文件，更新 MySQL 账号和密码</li><li>启动服务，账号密码：admin/123456 或者 guest/123456</li></ol><p>这是官方给出的部署步骤，松哥再详细说两句。</p><p>首先项目下载下来后，包含两个目录：</p><p><img src="http://img.itboyhub.com/2020/07/20200924113320.png" alt></p><ul><li>wetech-admin-server：服务端项目，但是由于存在一个 parent，所以不能直接打开 wetech-admin-server，从它的上级目录处打开。</li><li>wetech-admin-ui：前端项目，需要首先执行 npm install 安装所需依赖，然后执行 npm run serve 启动前端项目。</li></ul><p>没搞过前后端分离的小伙伴注意，需要前后端同时启动才能访问。</p><p>松哥在启动前端时遇到一个问题，就是一直报这个错误：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot read property &apos;range&apos; of null</span><br></pre></td></tr></table></figure><p>检查过后，发现是 eslint 作怪，我就把 eslint 整个关闭了，然后就清净了。</p><p>因为我们这里主要是看 RBAC，前端不做过多涉及，项目跑起来就行。如果大家也遇到这个错误，可以按照松哥的办法试下。</p><p>另外需要注意，他这项目用了 Lombok，随意 idea 上需要安装一下 Lombok 插件。</p><h2 id="3-数据库分析"><a href="#3-数据库分析" class="headerlink" title="3.数据库分析"></a>3.数据库分析</h2><p>这个项目数据库只有三张表：</p><p><img src="http://img.itboyhub.com/2020/07/20200924140357.png" alt></p><p>权限表、角色表以及用户表。</p><p>他没有设计关联表，而是将关联数据做成了一个字段。</p><p>比如角色表中有一个 permission_ids 字段，表示该角色对应的权限：</p><p><img src="http://img.itboyhub.com/2020/07/20200924140639.png" alt></p><p>用户表中有一个 role_ids 字段，表示用户对应的角色：</p><p><img src="http://img.itboyhub.com/2020/07/20200924140723.png" alt></p><p>这样设计的好处很明显，就是查询的时候非常方便，不用做一对多查询，SQL 好写并且执行效率高。</p><p>缺点就是数据更新不太方便，不过一般来说，权限系统数据更新频率较低，大部分都是查询，所以我觉得这样设计也能接受。</p><p>我们来看下这里的权限表：</p><p><img src="http://img.itboyhub.com/2020/07/20200924141311.png" alt></p><p>type 表示资源的类型，分为两种：菜单和按钮。</p><p>其中 1 表示菜单，2 表示按钮。如果是菜单，则需要有一个动态路由字符串，也就是 config 字段。该字段返回到前端之后，前端就会动态加载出对应的页面（这点和松哥 vhr （<a href="https://github.com/lenve/vhr）是一致的）。" target="_blank" rel="noopener">https://github.com/lenve/vhr）是一致的）。</a></p><p>角色表和用户表都比较简单，我就不再多说。</p><h2 id="4-代码分析"><a href="#4-代码分析" class="headerlink" title="4.代码分析"></a>4.代码分析</h2><p>普通的 CURD 代码我就不说了，和权限管理相关的代码在 tech.wetech.admin.shiro 包里边。登录在 LoginController 里边。</p><p>先来说这个登录，具体的操作是在 tech.wetech.admin.service.impl.UserServiceImpl#login 方法中：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> UserTokenDTO <span class="hljs-title">login</span><span class="hljs-params">(LoginDTO loginDTO)</span> </span>&#123;</span><br><span class="line">    User user = userMapper.selectByUsername(loginDTO.getUsername());</span><br><span class="line">    <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(CommonResultStatus.LOGIN_ERROR, <span class="hljs-string">"用户不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!passwordHelper.verifyPassword(user, loginDTO.getPassword())) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BusinessException(CommonResultStatus.LOGIN_ERROR, <span class="hljs-string">"密码错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    UserTokenDTO userInfoDTO = <span class="hljs-keyword">new</span> UserTokenDTO();</span><br><span class="line">    userInfoDTO.setUsername(user.getUsername());</span><br><span class="line">    userInfoDTO.setToken(JwtUtil.sign(user.getUsername(), String.valueOf(System.currentTimeMillis())));</span><br><span class="line">    <span class="hljs-keyword">return</span> userInfoDTO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是纯手工登录，登录成功后，生成一个 jwt 字符串返回给前端，以后前端每次请求，都需要携带上这个 jwt 字符串来。</p><p>tech.wetech.admin.shiro.JwtFilter 是专门处理认证请求的过滤器，所有需要认证的请求，都会经过该过滤器。这个过滤器所做的事情，就是从所有的请求头中提取出 Access-Token（就是登录成功后返回的那个 jwt 令牌），然后从令牌中解析出用户名，调用 JwtRealm 完成校验。</p><p>这是 JwtFilter：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Slf</span>4j</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AccessControlFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AUTHORIZATION_HEADER = <span class="hljs-string">"Access-Token"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLoginAttempt</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        String authorization = req.getHeader(AUTHORIZATION_HEADER);</span><br><span class="line">        <span class="hljs-keyword">return</span> authorization != <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAccessAllowed</span><span class="hljs-params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onAccessDenied</span><span class="hljs-params">(ServletRequest request, ServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        <span class="hljs-keyword">if</span> (isLoginAttempt(request, response)) &#123;</span><br><span class="line">            <span class="hljs-comment">//生成jwt token</span></span><br><span class="line">            JwtToken token = <span class="hljs-keyword">new</span> JwtToken(req.getHeader(AUTHORIZATION_HEADER));</span><br><span class="line">            <span class="hljs-comment">//委托给Realm进行验证</span></span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                getSubject(request, response).login(token);</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onLoginFail(response);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 登录失败时默认返回401状态码</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoginFail</span><span class="hljs-params">(ServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HttpServletResponse httpResponse = (HttpServletResponse) response;</span><br><span class="line">        httpResponse.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">        httpResponse.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        httpResponse.getWriter().write(JSONUtil.toJSONString(Result.failure(CommonResultStatus.LOGIN_ERROR)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JwtRealm 如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Slf</span>4j</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(AuthenticationToken token)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> token <span class="hljs-keyword">instanceof</span> JwtToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span><span class="hljs-params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        String username = principals.toString();</span><br><span class="line">        SimpleAuthorizationInfo authorizationInfo = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        authorizationInfo.setRoles(userService.queryRoles(username));</span><br><span class="line">        authorizationInfo.setStringPermissions(userService.queryPermissions(username));</span><br><span class="line">        <span class="hljs-keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span><span class="hljs-params">(AuthenticationToken token)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String credentials = (String) token.getCredentials();</span><br><span class="line">        String username = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">boolean</span> verify = JwtUtil.verify(credentials);</span><br><span class="line">            <span class="hljs-keyword">if</span> (!verify) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationException(<span class="hljs-string">"Token校验不正确"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            username = JwtUtil.getClaim(credentials, JwtUtil.ACCOUNT);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="hljs-string">"Token校验不正确："</span>, e);</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，不设置则使用默认的SimpleCredentialsMatcher</span></span><br><span class="line">        SimpleAuthenticationInfo authenticationInfo = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(</span><br><span class="line">                username, <span class="hljs-comment">//用户名</span></span><br><span class="line">                credentials, <span class="hljs-comment">//凭证</span></span><br><span class="line">                getName()  <span class="hljs-comment">//realm name</span></span><br><span class="line">        );</span><br><span class="line">        <span class="hljs-keyword">return</span> authenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>认证逻辑松哥刚才已经说过了，就不再赘述。</p><p>授权逻辑就是根据用户名查询出用户角色，根据用户角色查询出用户权限，将角色和权限分别赋值给 SimpleAuthorizationInfo 对象即可。</p><p>最后在 ShiroConfig 中还有一些常规配置，我就不再多说。</p><p>权限的控制主要是在各个接口上添加 @RequiresPermissions 注解实现的。如 PermissionController、RoleController 以及 UserController。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>整体上来说，这个项目并没有太多难度。还是松哥一开始所说的，RBAC 只是一种权限设计模型，模型本身很好理解，涉及到的技术也都很简单。无论是 Shiro 还是 Spring Security，实现 RBAC 虽然有一些差别，但是用的都是最基本的技术点。</p><p>好啦，今天就和小伙伴们聊这么多，感兴趣的小伙伴可以看看哦～如果你有好的 RBAC 项目也可以留言告诉松哥，我抽空解析一波。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;前两天写了一篇文章，和大家大概聊了聊 RBAC 权限管理系统：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>我又发现 Spring Security 中一个小秘密！</title>
    <link href="http://www.javaboy.org/2020/0923/spring-expressionurlauthorizationconfigurer-urlauthorizationconfigurer.html"/>
    <id>http://www.javaboy.org/2020/0923/spring-expressionurlauthorizationconfigurer-urlauthorizationconfigurer.html</id>
    <published>2020-09-23T01:56:29.000Z</published>
    <updated>2020-10-09T00:44:22.393Z</updated>
    
    <content type="html"><![CDATA[<p>说来惭愧，Spring Security 系列前前后后写了 60 多篇文章了，竟然漏掉了如此重要的一块。</p><a id="more"></a><p>平时在公司项目中，都是能用则用，先把需求整出来，有的时候也不去深究它的原理，这无形中就给自己挖了大坑。</p><p>松哥这次就是，不过也因此又发现了 Spring Security 的一个用法，今天就和小伙伴们分享下。</p><h2 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1.缘起"></a>1.缘起</h2><p>事情是这样的，看过 vhr 项目（<a href="https://github.com/lenve/vhr）的小伙伴都知道" target="_blank" rel="noopener">https://github.com/lenve/vhr）的小伙伴都知道</a> vhr 里边有一个动态权限管理功能，实现的思路就是重写了 FilterInvocationSecurityMetadataSource 以及决策管理器 AccessDecisionManager，代码就类似下面这样（小伙伴们可以在 GitHub 上查看完整代码）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http.authorizeRequests()</span><br><span class="line">            .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                    object.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">                    object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);</span><br><span class="line">                    <span class="hljs-keyword">return</span> object;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>昨天我想再写一个类似的功能，本想着很简单，三下五除二就搞定，大家看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">        .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                object.setSecurityMetadataSource(customSecurityMetadataSource);</span><br><span class="line">                object.setAccessDecisionManager(accessDecisionManager());</span><br><span class="line">                <span class="hljs-keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .and()</span><br><span class="line">        .csrf().disable();</span><br></pre></td></tr></table></figure><p>小伙伴们能看出这两段代码的差别吗？</p><p>写完之后，启动项目，一启动就报错了！</p><p><img src="http://img.itboyhub.com/2020/07/20200922092356.png" alt></p><p>我就有点懵。之前的 vhr 启动是没问题的，但是这次新的项目启动就有问题。</p><p>在 IDEA 中，通过 Ctrl+Shift+F 全局搜索，找到了异常抛出的位置：</p><p><img src="http://img.itboyhub.com/2020/07/20200922092547.png" alt></p><p>如果 requestMap 变量为空，就会抛出异常。requestMap 就是我们在 configure 方法中配置的请求和权限的映射，不过在上面的案例中，我是想像 vhr 那样做动态权限管理，所以请求和角色的映射关系我是保存在数据库中，没有必要在代码中配置。</p><p>但是根据异常提示，我就先随便加一个映射，果然启动就不报错了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">        .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                object.setSecurityMetadataSource(customSecurityMetadataSource);</span><br><span class="line">                object.setAccessDecisionManager(accessDecisionManager());</span><br><span class="line">                <span class="hljs-keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/hello"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .and()</span><br><span class="line">        .formLogin()</span><br><span class="line">        .and()</span><br><span class="line">        .csrf().disable();</span><br></pre></td></tr></table></figure><p>现在让我有两个郁闷的地方：</p><ol><li>vhr 为什么可以启动而不报错</li><li>这里代码中多出来的一行映射明显是累赘，最好能够去掉</li></ol><h2 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h2><p>第一个问题很好办，仔细对比最开始贴出来的代码就能找到端倪，vhr 中的代码多了一个 permitAll 方法，这就是一个表达式，有了该方法，就意味着里边多了一个映射关系，<code>/login -&gt; permitAll</code>，这样 requestMap 就不会为空，所以启动时就不报错了。</p><p>按照这个思路，我去修改了自己的代码，去除冗余的映射，加上 permitAll，这次果然可以了。</p><p>问题虽然解决了，但是心里还是有点膈应。</p><p>为什么呢？因为用户-角色-资源的映射关系我都保存在数据库中了，权限数据库类似下面这样：</p><p><img src="http://img.itboyhub.com/2020/07/20200922094346.png" alt></p><p>既然所有的权限管理都保存在数据库中了，再在代码中配置似乎就不太合适！但是不配置，项目启动又会出错，看来还是得从源码入手。</p><p>于是松哥花了点时间，把这里涉及到的相关源码仔细梳理了一遍。</p><h2 id="3-源码梳理"><a href="#3-源码梳理" class="headerlink" title="3.源码梳理"></a>3.源码梳理</h2><p>首先大家知道，Spring Security 中的权限控制有两种不同的方式：</p><ol><li>通过 URL 请求地址进行控制。</li><li>通过方法进行控制。</li></ol><p>如果通过 URL 请求地址进行控制，负责控制类配置的是 AbstractInterceptUrlConfigurer，我们来看下它的子类：</p><p><img src="http://img.itboyhub.com/2020/07/AbstractInterceptUrlConfigurer.png" alt></p><p>可以看到它有两个子类：</p><ul><li>ExpressionUrlAuthorizationConfigurer</li><li>UrlAuthorizationConfigurer</li></ul><p>两个都可以处理基于 URL 请求地址的权限控制。不同的是，第一个 ExpressionUrlAuthorizationConfigurer<br>支持权限表达式，第二个不支持。</p><p>什么是权限表达式？其实大家都有用，只是可能没注意过这些概念，下图就是 Spring Security 中提供的内置通用权限表达式：</p><p><img src="http://img.itboyhub.com/2020/07/20200922102919.png" alt="图片源自网络"></p><p>ExpressionUrlAuthorizationConfigurer 支持权限表达式的原因是因为它使用的投票器是 WebExpressionVoter，这个投票器就是用来处理权限表达式的。</p><p>而 UrlAuthorizationConfigurer 不支持权限表达式，是因为它使用的投票器是 RoleVoter 和 AuthenticatedVoter，这两者可以用来处理角色或者权限，但是没法处理权限表达式。</p><p>关于投票器，小伙伴们可以参考松哥之前的文章：<a href="https://mp.weixin.qq.com/s/sU97RQjQq2-XXQt49LkSeQ" target="_blank" rel="noopener">Spring Security 权限管理的投票器与表决机制</a>。</p><p>上面说的都是默认行为，我们也可以通过修改配置，让 UrlAuthorizationConfigurer 支持权限表达式，不过一般来说没必要这样做，如果需要支持权限表达式，直接用 ExpressionUrlAuthorizationConfigurer 即可。</p><p>当我们调用如下这行代码时：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br></pre></td></tr></table></figure><p>实际上就是通过 ExpressionUrlAuthorizationConfigurer 去配置基于 URL 请求地址的权限控制，所以它是支持权限表达式的。例如下面这段大家再熟悉不过的代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"ADMIN"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).access(<span class="hljs-string">"hasRole('USER')"</span>)</span><br></pre></td></tr></table></figure><p>在 ExpressionUrlAuthorizationConfigurer 中创建 SecurityMetadataSource 时，就会检查映射关系，如果 requestMap 为空就会抛出异常：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function">ExpressionBasedFilterInvocationSecurityMetadataSource <span class="hljs-title">createMetadataSource</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">H http)</span> </span>&#123;</span><br><span class="line">LinkedHashMap&lt;RequestMatcher, Collection&lt;ConfigAttribute&gt;&gt; requestMap = REGISTRY</span><br><span class="line">.createRequestMap();</span><br><span class="line"><span class="hljs-keyword">if</span> (requestMap.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="hljs-string">"At least one mapping is required (i.e. authorizeRequests().anyRequest().authenticated())"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExpressionBasedFilterInvocationSecurityMetadataSource(requestMap,</span><br><span class="line">getExpressionHandler(http));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UrlAuthorizationConfigurer 中也有 createMetadataSource 方法，但是却是另外一套实现方案： </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function">FilterInvocationSecurityMetadataSource <span class="hljs-title">createMetadataSource</span><span class="hljs-params">(H http)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultFilterInvocationSecurityMetadataSource(</span><br><span class="line">REGISTRY.createRequestMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UrlAuthorizationConfigurer 并不会检查 requestMap 是否为空，但是它会在 createRequestMap 方法中检查一下映射关系是否完整，例如下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.antMatchers(<span class="hljs-string">"/admin/**"</span>).access(<span class="hljs-string">"ROLE_ADMIN"</span>)</span><br><span class="line">.mvcMatchers(<span class="hljs-string">"/user/**"</span>).access(<span class="hljs-string">"ROLE_USER"</span>)</span><br><span class="line">.antMatchers(<span class="hljs-string">"/getinfo"</span>);</span><br></pre></td></tr></table></figure><p>最后的 /getinfo 没有指定需要的权限，这种就是不完整，就会抛出异常。</p><p>现在大家应该大致明白 ExpressionUrlAuthorizationConfigurer 和 UrlAuthorizationConfigurer 的区别了吧。</p><h2 id="4-问题解决"><a href="#4-问题解决" class="headerlink" title="4.问题解决"></a>4.问题解决</h2><p>ExpressionUrlAuthorizationConfigurer 会要求至少配置一个映射关系，UrlAuthorizationConfigurer 则无此要求。</p><p>当我们想要动态配置权限拦截时，一般来说也不会使用权限表达式，数据库中保存的就是普通的权限或者角色，所以这个时候我们可以选择 UrlAuthorizationConfigurer 而不是 ExpressionUrlAuthorizationConfigurer。</p><p>反映到代码上，就是下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = http.getSharedObject(ApplicationContext.class);</span><br><span class="line">    http.apply(<span class="hljs-keyword">new</span> UrlAuthorizationConfigurer&lt;&gt;(applicationContext))</span><br><span class="line">            .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                    object.setSecurityMetadataSource(customSecurityMetadataSource);</span><br><span class="line">                    <span class="hljs-keyword">return</span> object;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    http.formLogin()</span><br><span class="line">            .and()</span><br><span class="line">            .csrf().disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来就更合理一些，不用额外配置一条映射关系。</p><p>今天这篇文章可能对没了解过动态权限控制的小伙伴来说略难，大家可以参考松哥的 vhr（<a href="https://github.com/lenve/vhr）项目去了解下动态权限控制。当然，也可以参考松哥的[Spring" target="_blank" rel="noopener">https://github.com/lenve/vhr）项目去了解下动态权限控制。当然，也可以参考松哥的[Spring</a> Boot+Vue+微人事视频教程](<a href="https://mp.weixin.qq.com/s/EEmEL6tpuBT0qLfPwhj2OQ)，里边也有讲动态权限控制问题。" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EEmEL6tpuBT0qLfPwhj2OQ)，里边也有讲动态权限控制问题。</a></p><p>好啦，今天就和小伙伴们分享这么多，要不是这次遇到问题，我一直都懒得去研究 ExpressionUrlAuthorizationConfigurer 和 UrlAuthorizationConfigurer 有什么区别。感兴趣的小伙伴可以自己 DEBUG 验证下本文内容哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说来惭愧，Spring Security 系列前前后后写了 60 多篇文章了，竟然漏掉了如此重要的一块。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中最流行的权限管理模型！</title>
    <link href="http://www.javaboy.org/2020/0921/springsecurity-rbac.html"/>
    <id>http://www.javaboy.org/2020/0921/springsecurity-rbac.html</id>
    <published>2020-09-21T01:56:14.000Z</published>
    <updated>2020-10-09T00:45:24.786Z</updated>
    
    <content type="html"><![CDATA[<p>前面和大家说了 ACL，讲了理论，也给了一个完整的案例，相信小伙伴们对于 ACL 权限控制模型都已经比较了解了。</p><a id="more"></a><p>本文我要和大家聊一聊另外一个非常流行的权限管理模型，那就是 RBAC。</p><h2 id="1-RBAC-简介"><a href="#1-RBAC-简介" class="headerlink" title="1.RBAC 简介"></a>1.RBAC 简介</h2><p>RBAC（Role-based access control）是一种以角色为基础的访问控制（Role-based access control，RBAC），它是一种较新且广为使用的权限控制机制，这种机制不是直接给用户赋予权限，而是将权限赋予角色。</p><p>RBAC 权限模型将用户按角色进行归类，通过用户的角色来确定用户对某项资源是否具备操作权限。RBAC 简化了用户与权限的管理，它将用户与角色关联、角色与权限关联、权限与资源关联，这种模式使得用户的授权管理变得非常简单和易于维护。</p><h2 id="2-RBAC-的提出"><a href="#2-RBAC-的提出" class="headerlink" title="2.RBAC 的提出"></a>2.RBAC 的提出</h2><p>权限、角色这些东西，在早期 1970 年代的商业计算机程序中就可以找到相关的应用，但是早期的程序相对简单，而且并不存在一个明确的、通用的、公认的权限管理模型。</p><p>Ferraiolo 和 Kuhn 两位大佬于 1992 年提出了一种基于通用角色的访问控制模型（看来这个模型比松哥年龄还大），首次提出了 RBAC 权限模型用来代替传统的 MAC 和 DAC 两种权限控制方案，并且就 RBAC 中的相关概念给出了解释。</p><p>Ferraiolo，Cugini 和 Kuhn 于 1995 年扩展了 1992 年提出的权限模型。该模型的主要功能是所有访问都是通过角色进行的，而角色本质上是权限的集合，并且所有用户只能通过角色获得权限。在组织内，角色相对稳定，而用户和权限都很多，并且可能会迅速变化。因此，通过角色控制权限可以简化访问控制的管理和检查。</p><p>到了 1996 年，Sandhu，Coyne，Feinstein 和 Youman 正式提出了 RBAC 模型，该模型以模块化方式细化了 RBAC，并提出了基于该理论的 RBAC0-RBAC3 四种不同模型。</p><p>今天，大多数信息技术供应商已将 RBAC 纳入其产品线，除了常规的企业级应用，RBAC 也广泛应用在医疗、国防等领域。</p><p>目前网上关于 RBAC 理论性的东西松哥只找到英文的，感兴趣的小伙伴可以看下，地址是：</p><ul><li><a href="https://csrc.nist.gov/projects/Role-Based-Access-Control" target="_blank" rel="noopener">https://csrc.nist.gov/projects/Role-Based-Access-Control</a></li></ul><p>如果小伙伴们有中文的资料链接，欢迎留言说明。</p><h2 id="3-RBAC-三原则"><a href="#3-RBAC-三原则" class="headerlink" title="3.RBAC 三原则"></a>3.RBAC 三原则</h2><ol><li>最小权限：给角色配置的权限是其完成任务所需要的最小权限集合。</li><li>责任分离：通过相互独立互斥的角色来共同完成任务。</li><li>数据抽象：通过权限的抽象来体现，RBAC 支持的数据抽象程度与 RBAC 的实现细节有关。</li></ol><h2 id="4-RBAC-模型分类"><a href="#4-RBAC-模型分类" class="headerlink" title="4.RBAC 模型分类"></a>4.RBAC 模型分类</h2><p>说到 RBAC，我们就得从它的模型分类开始看起。</p><h3 id="4-1-RBAC0"><a href="#4-1-RBAC0" class="headerlink" title="4.1 RBAC0"></a>4.1 RBAC0</h3><p>RBAC0 是最简单的用户、角色、权限模型。RBAC0 是 RBAC 权限模型中最核心的一部分，后面其他模型都是在此基础上建立。</p><p><img src="http://img.itboyhub.com/2020/07/20200920112318.png" alt="图片源自网络"></p><p>在 RBAC0 中，一个用户可以具备多个角色，一个角色可以具备多个权限，最终用户所具备的权限是用户所具备的角色的权限并集。</p><h3 id="4-2-RBAC1"><a href="#4-2-RBAC1" class="headerlink" title="4.2 RBAC1"></a>4.2 RBAC1</h3><p>RBAC1 则是在 RABC0 的基础上引入了角色继承，让角色有了上下级关系。</p><p><img src="http://img.itboyhub.com/2020/07/20200920112156.png" alt="图片源自网络"></p><p>在本系列前面的文章中，松哥也曾多次向大家介绍过 Spring Security 中的角色继承。</p><h3 id="4-3-RBAC2"><a href="#4-3-RBAC2" class="headerlink" title="4.3 RBAC2"></a>4.3 RBAC2</h3><p>RBAC2 也是在 RBAC0 的基础上进行扩展，引入了静态职责分离和动态职责分离。</p><p><img src="http://img.itboyhub.com/2020/07/20200920112222.png" alt="图片源自网络"></p><p>要理解职责分离，我们得先明白角色互斥。</p><p>在实际项目中，有一些角色是互斥的，对立的，例如财务这个角色一般是不能和其他角色兼任的，否则自己报账自己审批，岂不是爽歪歪！</p><p>通过职责分离可以解决这个问题：</p><p><strong>静态职责分离</strong></p><p>在设置阶段就做好了限制。比如同一用户不能授予互斥的角色，用户只能有有限个角色，用户获得高级权限之前要有低级权限等等。</p><p><strong>动态职责分离</strong></p><p>在运行阶段进行限制。比如运行时同一用户下5个角色中只能同时有2个角色激活等等。</p><h3 id="4-4-RBAC3"><a href="#4-4-RBAC3" class="headerlink" title="4.4 RBAC3"></a>4.4 RBAC3</h3><p>将 RBAC1 和 RBAC2 结合起来，就形成了 RBAC3。</p><p><img src="http://img.itboyhub.com/2020/07/20200920112247.png" alt="图片源自网络"></p><h2 id="5-扩展"><a href="#5-扩展" class="headerlink" title="5.扩展"></a>5.扩展</h2><p>我们日常见到的很多权限模型都是在 RBAC 的基础上扩展出来的。</p><p>例如在有的系统中我们可以见到用户组的概念，就是将用户分组，用户同时具备自身的角色以及分组的角色。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><p>好啦，今天就和小伙伴们简单介绍下 RBAC 权限模型。其实 RBAC 只要把权限模型搞清楚了，技术上来说，基本上没啥问题。如果你把松哥 vhr 中涉及到的 Spring Security 技术搞懂了，结合今天的文章，用 Spring Security 实现 RBAC 完全不成问题～当然，我后面也抽空给大家整一个 RBAC 的 DEMO。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面和大家说了 ACL，讲了理论，也给了一个完整的案例，相信小伙伴们对于 ACL 权限控制模型都已经比较了解了。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>一个案例演示 Spring Security 中粒度超细的权限控制！</title>
    <link href="http://www.javaboy.org/2020/0917/springsecurity-acl-demo.html"/>
    <id>http://www.javaboy.org/2020/0917/springsecurity-acl-demo.html</id>
    <published>2020-09-17T01:55:57.000Z</published>
    <updated>2020-10-09T00:45:16.978Z</updated>
    
    <content type="html"><![CDATA[<p>想要细化权限控制粒度，办法很多。本文接着上文（<a href="https://mp.weixin.qq.com/s/Q9lfrJ3iioUpYEO9elCtsw" target="_blank" rel="noopener">Spring Security 中如何细化权限粒度？</a>），通过一个具体的案例来向小伙伴们展示基于 Acl 的权限控制。其他的权限控制模型后面也会一一介绍。</p><a id="more"></a><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>首先创建一个 Spring Boot 项目，由于我们这里涉及到数据库操作，所以除了 Spring Security 依赖之外，还需要加入数据库驱动以及 MyBatis 依赖。</p><p>由于没有 acl 相关的 starter，所以需要我们手动添加 acl 依赖，另外 acl 还依赖于 ehcache 缓存，所以还需要加上缓存依赖。</p><p>最终的 pom.xml 文件如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-acl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>net.sf.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context-support<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>项目创建成功之后，我们在 acl 的 jar 包中可以找到数据库脚本文件：</p><p><img src="http://img.itboyhub.com/2020/07/20200913155708.png" alt></p><p>根据自己的数据库选择合适的脚本执行，执行后一共创建了四张表，如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200913173811.png" alt></p><p>表的含义我就不做过多解释了，不清楚的小伙伴可以参考上篇文章：<a href="https://mp.weixin.qq.com/s/Q9lfrJ3iioUpYEO9elCtsw" target="_blank" rel="noopener">Spring Security 中如何细化权限粒度？</a></p><p>最后，再在项目的 application.properties 文件中配置数据库信息，如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:///acls?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>至此，准备工作就算完成了。接下来我们来看配置。</p><h2 id="2-ACL-配置"><a href="#2-ACL-配置" class="headerlink" title="2.ACL 配置"></a>2.ACL 配置</h2><p>这块配置代码量比较大，我先把代码摆上来，我们再逐个分析：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Configuration</span></span><br><span class="line"><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>, securedEnabled = <span class="hljs-keyword">true</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AclConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AclAuthorizationStrategy <span class="hljs-title">aclAuthorizationStrategy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AclAuthorizationStrategyImpl(<span class="hljs-keyword">new</span> SimpleGrantedAuthority(<span class="hljs-string">"ROLE_ADMIN"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> PermissionGrantingStrategy <span class="hljs-title">permissionGrantingStrategy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultPermissionGrantingStrategy(<span class="hljs-keyword">new</span> ConsoleAuditLogger());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AclCache <span class="hljs-title">aclCache</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EhCacheBasedAclCache(aclEhCacheFactoryBean().getObject(), permissionGrantingStrategy(), aclAuthorizationStrategy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> EhCacheFactoryBean <span class="hljs-title">aclEhCacheFactoryBean</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        EhCacheFactoryBean ehCacheFactoryBean = <span class="hljs-keyword">new</span> EhCacheFactoryBean();</span><br><span class="line">        ehCacheFactoryBean.setCacheManager(aclCacheManager().getObject());</span><br><span class="line">        ehCacheFactoryBean.setCacheName(<span class="hljs-string">"aclCache"</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> ehCacheFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> EhCacheManagerFactoryBean <span class="hljs-title">aclCacheManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EhCacheManagerFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> LookupStrategy <span class="hljs-title">lookupStrategy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicLookupStrategy(dataSource, aclCache(), aclAuthorizationStrategy(), <span class="hljs-keyword">new</span> ConsoleAuditLogger()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> AclService <span class="hljs-title">aclService</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcMutableAclService(dataSource, lookupStrategy(), aclCache());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Bean</span></span><br><span class="line">    <span class="hljs-function">PermissionEvaluator <span class="hljs-title">permissionEvaluator</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        AclPermissionEvaluator permissionEvaluator = <span class="hljs-keyword">new</span> AclPermissionEvaluator(aclService());</span><br><span class="line">        <span class="hljs-keyword">return</span> permissionEvaluator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>@EnableGlobalMethodSecurity 注解的配置表示开启项目中 @PreAuthorize、@PostAuthorize 以及 @Secured 注解的使用，一会我们要通过这些注解配置权限。</li><li>由于引入了数据库的一整套东西，并且配置了数据库连接信息，所以这里可以注入 DataSource 实例以备后续使用。</li><li>AclAuthorizationStrategy 实例用来判断当前的认证主体是否有修改 Acl 的权限，准确来说是三种权限：修改 Acl 的 owner；修改 Acl 的审计信息以及修改 ACE 本身。这个接口只有一个实现类就是 AclAuthorizationStrategyImpl，我们在创建实例时，可以传入三个参数，分别对应了这三种权限，也可以传入一个参数，表示这一个角色可以干三件事。</li><li>PermissionGrantingStrategy 接口提供了一个 isGranted 方法，这个方法就是最终真正进行权限比对的方法，该接口只有一个实现类 DefaultPermissionGrantingStrategy，直接 new 就行了。</li><li>在 ACL 体系中，由于权限比对总是要查询数据库，造成了性能问题，因此引入了 Ehcache 做缓存。AclCache 共有两个实现类：SpringCacheBasedAclCache 和 EhCacheBasedAclCache。我们前面已经引入了 ehcache 实例，所以这里配置 EhCacheBasedAclCache 实例即可。</li><li>LookupStrategy 可以通过 ObjectIdentity 解析出对应的 Acl。LookupStrategy 只有一个实现类就是 BasicLookupStrategy，直接 new 即可。</li><li>AclService 这个我们在上文已经介绍过了，这里不再赘述。</li><li>PermissionEvaluator 是为表达式 hasPermission 提供支持的。由于本案例后面使用类似于 <code>@PreAuthorize(&quot;hasPermission(#noticeMessage, &#39;WRITE&#39;)&quot;)</code> 这样的注解进行权限控制，因此之类需要配置一个 PermissionEvaluator 实例。</li></ol><p>至此，这里的配置类就和大家介绍完了。</p><h2 id="3-情节设定"><a href="#3-情节设定" class="headerlink" title="3.情节设定"></a>3.情节设定</h2><p>假设我现在有一个通知消息类 NoticeMessage，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoticeMessage</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer id;</span><br><span class="line">    <span class="hljs-keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"NoticeMessage&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"id="</span> + id +</span><br><span class="line">                <span class="hljs-string">", content='"</span> + content + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据该类创建了数据表：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`system_message`</span> (</span><br><span class="line">  <span class="hljs-string">`id`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="hljs-string">`content`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)</span><br><span class="line">) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8mb4 <span class="hljs-keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p>那么接下来的权限控制就是针对这个 NoticeMessage 的。</p><p>创建 NoticeMessageMapper，并添加几个测试方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Mapper</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NoticeMessageMapper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">List&lt;NoticeMessage&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function">NoticeMessage <span class="hljs-title">findById</span><span class="hljs-params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(NoticeMessage noticeMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(NoticeMessage noticeMessage)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NoticeMessageMapper.xml 内容如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="hljs-meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="hljs-meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"org.javaboy.acls.mapper.NoticeMessageMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findAll"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.acls.model.NoticeMessage"</span>&gt;</span></span><br><span class="line">        select * from system_message;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.javaboy.acls.model.NoticeMessage"</span>&gt;</span></span><br><span class="line">        select * from system_message where id=#&#123;id&#125;;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"save"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.javaboy.acls.model.NoticeMessage"</span>&gt;</span></span><br><span class="line">        insert into system_message (id,content) values (#&#123;id&#125;,#&#123;content&#125;);</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"update"</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">"org.javaboy.acls.model.NoticeMessage"</span>&gt;</span></span><br><span class="line">        update system_message set content = #&#123;content&#125; where id=#&#123;id&#125;;</span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些应该都好理解，没啥好说的。</p><p>接下来创建 NoticeMessageService，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoticeMessageService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    NoticeMessageMapper noticeMessageMapper;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostFilter</span>(<span class="hljs-string">"hasPermission(filterObject, 'READ')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;NoticeMessage&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        List&lt;NoticeMessage&gt; all = noticeMessageMapper.findAll();</span><br><span class="line">        <span class="hljs-keyword">return</span> all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PostAuthorize</span>(<span class="hljs-string">"hasPermission(returnObject, 'READ')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> NoticeMessage <span class="hljs-title">findById</span><span class="hljs-params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> noticeMessageMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission(#noticeMessage, 'CREATE')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> NoticeMessage <span class="hljs-title">save</span><span class="hljs-params">(NoticeMessage noticeMessage)</span> </span>&#123;</span><br><span class="line">        noticeMessageMapper.save(noticeMessage);</span><br><span class="line">        <span class="hljs-keyword">return</span> noticeMessage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"hasPermission(#noticeMessage, 'WRITE')"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(NoticeMessage noticeMessage)</span> </span>&#123;</span><br><span class="line">        noticeMessageMapper.update(noticeMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到了两个新注解，稍微说下：</p><ul><li>@PostFilter：在执行方法后过滤返回的集合或数组（筛选出当前用户具有 READ 权限的数据），returnObject 就表示方法的返回值。有一个和它对应的注解 @PreFilter，这个注解允许方法调用，但必须在进入方法之前对参数进行过滤。</li><li>@PostAuthorize：允许方法调用，但是如果表达式计算结果为false，将抛出一个安全性异常，<code>#noticeMessage</code> 对应了方法的参数。</li><li>@PreAuthorize：在方法调用之前，基于表达式的计算结果来限制对方法的访问。</li></ul><p>明白了注解的含义，那么上面的方法应该就不用多做解释了吧。</p><p>配置完成，接下来我们进行测试。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p>为了方便测试，我们首先准备几条测试数据，如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`acl_class`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`class`</span>)</span><br><span class="line"><span class="hljs-keyword">VALUES</span></span><br><span class="line">(<span class="hljs-number">1</span>,<span class="hljs-string">'org.javaboy.acls.model.NoticeMessage'</span>);</span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`acl_sid`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`principal`</span>, <span class="hljs-string">`sid`</span>)</span><br><span class="line"><span class="hljs-keyword">VALUES</span></span><br><span class="line">(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'hr'</span>),</span><br><span class="line">(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'manager'</span>),</span><br><span class="line">(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-string">'ROLE_EDITOR'</span>);</span><br><span class="line"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`system_message`</span> (<span class="hljs-string">`id`</span>, <span class="hljs-string">`content`</span>)</span><br><span class="line"><span class="hljs-keyword">VALUES</span></span><br><span class="line">(<span class="hljs-number">1</span>,<span class="hljs-string">'111'</span>),</span><br><span class="line">(<span class="hljs-number">2</span>,<span class="hljs-string">'222'</span>),</span><br><span class="line">(<span class="hljs-number">3</span>,<span class="hljs-string">'333'</span>);</span><br></pre></td></tr></table></figure><p>首先添加了 acl_class，然后添加了三个 Sid，两个是用户，一个是角色，最后添加了三个 NoticeMessage 实例。</p><p>目前没有任何用户/角色能够访问到 system_message 中的三条数据。例如执行如下代码获取不到任何数据：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(roles = <span class="hljs-string">"EDITOR"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;NoticeMessage&gt; all = noticeMessageService.findAll();</span><br><span class="line">    System.out.println(<span class="hljs-string">"all = "</span> + all);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@WithMockUser(roles = “EDITOR”) 表示使用 EDITOR 角色访问。松哥这里是为了方便。小伙伴们也可以自己给 Spring Security 配置用户，设置相关接口，然后 Controller 中添加接口进行测试，我这里就不那么麻烦了。</p></blockquote><p>现在我们对其进行配置。</p><p>首先我想设置让 hr 这个用户可以读取 system_message 表中 id 为 1 的记录，方式如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">NoticeMessageService noticeMessageService;</span><br><span class="line"><span class="hljs-meta">@Autowired</span></span><br><span class="line">JdbcMutableAclService jdbcMutableAclService;</span><br><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"javaboy"</span>)</span><br><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@Rollback</span>(value = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ObjectIdentity objectIdentity = <span class="hljs-keyword">new</span> ObjectIdentityImpl(NoticeMessage.class, <span class="hljs-number">1</span>);</span><br><span class="line">    Permission p = BasePermission.READ;</span><br><span class="line">    MutableAcl acl = jdbcMutableAclService.createAcl(objectIdentity);</span><br><span class="line">    acl.insertAce(acl.getEntries().size(), p, <span class="hljs-keyword">new</span> PrincipalSid(<span class="hljs-string">"hr"</span>), <span class="hljs-keyword">true</span>);</span><br><span class="line">    jdbcMutableAclService.updateAcl(acl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设置了 mock user 是 javaboy，也就是这个 acl 创建好之后，它的 owner 是 javaboy，但是我们前面预设数据中 Sid 没有 javaboy，所以会自动向 acl_sid 表中添加一条记录，值为 javaboy。</p><p>在这个过程中，会分别向 acl_entry、acl_object_identity 以及 acl_sid 三张表中添加记录，因此需要添加事务，同时因为我们是在单元测试中执行，为了确保能够看到数据库中数据的变化，所以需要添加 @Rollback(value = false) 注解让事务不要自动回滚。</p><p>在方法内部，首先分别创建 ObjectIdentity 和 Permission 对象，然后创建一个 acl 对象出来，这个过程中会将 javaboy 添加到 acl_sid 表中。</p><p>接下来调用 acl_insertAce 方法，将 ace 存入 acl 中，最后调用 updateAcl 方法去更新 acl 对象即可。</p><p>配置完成后，执行该方法，执行完成后，数据库中就会有相应的记录了。</p><p>接下来，使用 hr 这个用户就可以读取到 id 为 1 的记录了。如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"hr"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    List&lt;NoticeMessage&gt; all = noticeMessageService.findAll();</span><br><span class="line">    assertNotNull(all);</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, all.size());</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, all.get(<span class="hljs-number">0</span>).getId());</span><br><span class="line">    NoticeMessage byId = noticeMessageService.findById(<span class="hljs-number">1</span>);</span><br><span class="line">    assertNotNull(byId);</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, byId.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>松哥这里用了两个方法来和大家演示。首先我们调用了 findAll，这个方法会查询出所有的数据，然后返回结果会被自动过滤，只剩下 hr 用户具有读取权限的数据，即 id 为 1 的数据；另一个调用的就是 findById 方法，传入参数为 1，这个好理解。</p><p>如果此时想利用 hr 这个用户修改对象，则是不可以的。我们可以继续使用上面的代码，让 hr 这个用户可以修改 id 为 1 的记录，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"javaboy"</span>)</span><br><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@Rollback</span>(value = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ObjectIdentity objectIdentity = <span class="hljs-keyword">new</span> ObjectIdentityImpl(NoticeMessage.class, <span class="hljs-number">1</span>);</span><br><span class="line">    Permission p = BasePermission.WRITE;</span><br><span class="line">    MutableAcl acl = (MutableAcl) jdbcMutableAclService.readAclById(objectIdentity);</span><br><span class="line">    acl.insertAce(acl.getEntries().size(), p, <span class="hljs-keyword">new</span> PrincipalSid(<span class="hljs-string">"hr"</span>), <span class="hljs-keyword">true</span>);</span><br><span class="line">    jdbcMutableAclService.updateAcl(acl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里权限改为 WRITE 权限。由于 acl 中已经存在这个 ObjectIdentity 了，所以这里通过 readAclById 方法直接读取已有的 acl 即可。方法执行完毕后，我们再进行 hr 用户写权限的测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"hr"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    NoticeMessage msg = noticeMessageService.findById(<span class="hljs-number">1</span>);</span><br><span class="line">    assertNotNull(msg);</span><br><span class="line">    assertEquals(<span class="hljs-number">1</span>, msg.getId());</span><br><span class="line">    msg.setContent(<span class="hljs-string">"javaboy-1111"</span>);</span><br><span class="line">    noticeMessageService.update(msg);</span><br><span class="line">    msg = noticeMessageService.findById(<span class="hljs-number">1</span>);</span><br><span class="line">    assertNotNull(msg);</span><br><span class="line">    assertEquals(<span class="hljs-string">"javaboy-1111"</span>, msg.getContent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，hr 就可以使用 WRITE 权限去修改对象了。</p><p>假设我现在想让 manager 这个用户去创建一个 id 为 99 的 NoticeMessage，默认情况下，manager 是没有这个权限的。我们现在可以给他赋权：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"javaboy"</span>)</span><br><span class="line"><span class="hljs-meta">@Transactional</span></span><br><span class="line"><span class="hljs-meta">@Rollback</span>(value = <span class="hljs-keyword">false</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ObjectIdentity objectIdentity = <span class="hljs-keyword">new</span> ObjectIdentityImpl(NoticeMessage.class, <span class="hljs-number">99</span>);</span><br><span class="line">    Permission p = BasePermission.CREATE;</span><br><span class="line">    MutableAcl acl = jdbcMutableAclService.createAcl(objectIdentity);</span><br><span class="line">    acl.insertAce(acl.getEntries().size(), p, <span class="hljs-keyword">new</span> PrincipalSid(<span class="hljs-string">"manager"</span>), <span class="hljs-keyword">true</span>);</span><br><span class="line">    jdbcMutableAclService.updateAcl(acl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的权限是 CREATE。</p><p>接下来使用 manager 用户就可以添加数据了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Test</span></span><br><span class="line"><span class="hljs-meta">@WithMockUser</span>(username = <span class="hljs-string">"manager"</span>)</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    NoticeMessage noticeMessage = <span class="hljs-keyword">new</span> NoticeMessage();</span><br><span class="line">    noticeMessage.setId(<span class="hljs-number">99</span>);</span><br><span class="line">    noticeMessage.setContent(<span class="hljs-string">"999"</span>);</span><br><span class="line">    noticeMessageService.save(noticeMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就可以添加成功了。添加成功后，manager 这个用户没有读 id 为 99 的数据的权限，可以参考前面案例自行添加。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>从上面的案例中大家可以看到，ACL 权限模型中的权限控制真的是非常非常细，细到每一个对象的 CURD。</p><p>优点就不用说了，够细！同时将业务和权限成功分离。缺点也很明显，权限数据量庞大，扩展性弱。</p><p>最后，公号后台回复 acl 获取本文案例下载链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要细化权限控制粒度，办法很多。本文接着上文（&lt;a href=&quot;https://mp.weixin.qq.com/s/Q9lfrJ3iioUpYEO9elCtsw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Security 中如何细化权限粒度？&lt;/a&gt;），通过一个具体的案例来向小伙伴们展示基于 Acl 的权限控制。其他的权限控制模型后面也会一一介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中如何细化权限粒度？</title>
    <link href="http://www.javaboy.org/2020/0916/springsecurity-acl.html"/>
    <id>http://www.javaboy.org/2020/0916/springsecurity-acl.html</id>
    <published>2020-09-16T01:55:35.000Z</published>
    <updated>2020-10-09T00:45:08.213Z</updated>
    
    <content type="html"><![CDATA[<p>有小伙伴表示微人事(<a href="https://github.com/lenve/vhr)的权限粒度不够细。不过松哥想说的是，技术都是相通的，明白了" target="_blank" rel="noopener">https://github.com/lenve/vhr)的权限粒度不够细。不过松哥想说的是，技术都是相通的，明白了</a> vhr 中权限管理的原理，在此基础上就可以去细化权限管理粒度，细化过程和还是用的 vhr 中用的技术，只不过设计层面重新规划而已。</p><a id="more"></a><p>当然今天我想说的并不是这个话题，主要是想和大家聊一聊 Spring Security 中权限管理粒度细化的问题。因为这个问题会涉及到不同的权限管理模型，今天和小伙伴们聊一聊～</p><h2 id="1-权限管理模型"><a href="#1-权限管理模型" class="headerlink" title="1.权限管理模型"></a>1.权限管理模型</h2><p>要想将细化权限粒度，我们不可避免会涉及到一些权限模型，例如 ACL、RBAC、DAC、MAC 以及 ABAC、PBAC 等。</p><p>在这些众多的权限模型中，我们使用较多的是 RBAC，ACL 也有一些项目在使用，另外几种则使用相对较少。因此松哥这里重点和大家介绍 ACL 和 RBAC。</p><h3 id="1-1-ACL"><a href="#1-1-ACL" class="headerlink" title="1.1 ACL"></a>1.1 ACL</h3><p>ACL 是一种比较古老的权限控制模型。英文全称是 Access Control List，中文称作访问控制列表，这是一种面向资源的访问控制模型，所有的权限配置都是针对资源的。</p><p>它的原理是这样：</p><p>对于系统中的每一个资源，都会配置一个访问列表，这个列表中记录了用户/角色对于资源的 CURD 权限，当系统需要访问这些资源时，会首先检查列表中是否存在当前用户的访问权限，进而确定当前用户是否可以执行相应的操作。</p><p>ACL 的使用非常简单，搞明白它的原理自己分分钟就能实现。但是 ACL 有一个明显的缺点，就是需要维护大量的访问权限列表。大量的访问控制列表带来的问题就是性能下降以及维护复杂。</p><h3 id="1-2-RBAC"><a href="#1-2-RBAC" class="headerlink" title="1.2 RBAC"></a>1.2 RBAC</h3><p>RBAC（Role-based access control）是一种以角色为基础的访问控制，也是目前使用较多的一种权限模型，它有多种不同的变体，松哥后面会专门写一篇文章来介绍 RBAC，这里仅简单科普下。</p><p>RBAC 权限模型将用户按角色进行归类，通过用户的角色来确定用户对某项资源是否具备操作权限。RBAC 简化了用户与权限的管理，它将用户与角色关联、角色与权限管理、权限与资源关联，这种模式使得用户的授权管理变得非常简单和易于维护。</p><h3 id="1-3-其他"><a href="#1-3-其他" class="headerlink" title="1.3 其他"></a>1.3 其他</h3><p>下面这些使用常见较少，小伙伴们做一个了解即可，感兴趣的小伙伴也可以自行研究下。</p><ul><li><strong>ABAC</strong>：这是一种基于属性的访问控制。</li><li><strong>PBAC</strong>：这是一种基于策略的访问控制。</li><li><strong>DAC</strong>：除了权限控制，主体也可以将权限授予其他主体。</li><li><strong>MAC</strong>：资源可以被哪些类别的主体进行哪些操作，主体可以对哪些等级的资源进行哪些操作，这两个条件同时满足时，允许访问。</li></ul><h2 id="2-ACL"><a href="#2-ACL" class="headerlink" title="2.ACL"></a>2.ACL</h2><p>接下来松哥要和大家仔细介绍一下 ACL 这种权限模型，RBAC 我后面专门写文章介绍，本文先不做讨论。</p><p>Acl 的全称是 Access Control List，也就是我们所说的访问控制列表，是用以控制对象的访问权限的。Acl 的一个核心思路就是将某个对象的某种权限授予某个用户或某种角色，它们之间的关系是多对多，即一个用户/角色可以具备某个对象的多种权限，某个对象的权限也可以被多个用户/角色所持有。</p><p>举个简单例子：</p><p>现在有一个 User 对象，针对该对象有查询、修改、删除等权限，可以将这些权限赋值给某一个用户，也可以将这些权限赋值给某一个角色，当用户具备这些角色时就具有执行相应操作的权限。</p><p>从这个角度看，Acl 是一种粒度非常细的权限控制，它就是专门控制某一个对象的操作权限。所有的这些权限都记录在数据库中，这带来了另外一个问题就是需要维护的权限数据量非常庞大，不利于后期扩展。当然，对于一个简单的系统，使用 Acl 还是可以的，没有任何问题。</p><h3 id="2-1-核心概念"><a href="#2-1-核心概念" class="headerlink" title="2.1 核心概念"></a>2.1 核心概念</h3><p>接下来我们来看看 Acl 中一些核心概念。</p><p><strong>Sid</strong></p><p>Sid 代表了用户和角色，它有两种：GrantedAuthoritySid 和 PrincipalSid，前者代表角色，后者代表用户。在 Spring Security 中，用户和角色信息都是保存在 Authentication 对象中的，即 Sid 是从 Authentication 对象中提取出来的，提取出来的值是 GrantedAuthoritySid+PrincipalSid，而不是其中某一项，具体的提取方法是 SidRetrievalStrategyImpl#getSids，相关源码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Sid&gt; <span class="hljs-title">getSids</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities = roleHierarchy</span><br><span class="line">.getReachableGrantedAuthorities(authentication.getAuthorities());</span><br><span class="line">List&lt;Sid&gt; sids = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(authorities.size() + <span class="hljs-number">1</span>);</span><br><span class="line">sids.add(<span class="hljs-keyword">new</span> PrincipalSid(authentication));</span><br><span class="line"><span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line">sids.add(<span class="hljs-keyword">new</span> GrantedAuthoritySid(authority));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> sids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Sid 大家可以简单理解为当前用户的权限（这个说法不是很准确，可以近似理解）。</p><p><strong>ObjectIdentity</strong></p><p>ObjectIdentity 是一个域对象，这是官方的说法，有点拗口。实际上这就是你要操作的对象。</p><p>例如我有一个 User 对象，如果直接去记录能够对 User 对象执行哪些操作，这就会导致高耦和。所以我们需要对其解耦，将所有需要操作的对象通过 ObjectIdentity 描述出来，这样就能确保权限系统不和具体的业务绑定。</p><p>ObjectIdentity 中有两个关键方法，getType 和 getIdentifier。一般来说，getType 方法返回真实对象类的全路径，例如 <code>org.javaboy.acl.model.User</code>，getIdentifier 方法则返回真实对象的 id，通过这两个方法，就能够锁定一个对象。</p><p><strong>Acl</strong></p><p>看名字就知道，这算是整个系统的核心调度部分。</p><p>一个 Acl 对象会关联一个 ObjectIdentity，一个 Acl 对象还拥有一个 Sid，这个 Sid 表示这个 Acl 是属于谁的？属于谁，谁就可以修改甚至删除这个 Acl 对象。</p><p><strong>AccessControlEntry</strong></p><p>AccessControlEntry 简写为 ACE，一个 AccessControlEntry 对象代表一条权限记录。每一个 AccessControlEntry 都对应了一个 Acl，一个 Acl 对象对应多个 AccessControlEntry，有了这层对应关系，相当于就知道这个权限操作的是哪个对象。</p><p>然后 AccessControlEntry 中还包含一个 Sid 和一个 Permission 对象，表示某个 Sid 具备某种权限。</p><p>可以看到，Acl+ACE，就描述出来了某个 Sid 可以具备某个 ObjectIdentity 的某种 Permission。</p><p><strong>Permission</strong></p><p>这个就是具体的权限对象。似乎是受 Linux 影响，它使用了权限掩码，最多支持 2<sup>32</sup>-1 种权限。</p><p>Spring Security 种默认定义了五种：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePermission</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractPermission</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission READ = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-string">'R'</span>); <span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission WRITE = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-string">'W'</span>); <span class="hljs-comment">// 2</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission CREATE = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>, <span class="hljs-string">'C'</span>); <span class="hljs-comment">// 4</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission DELETE = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>, <span class="hljs-string">'D'</span>); <span class="hljs-comment">// 8</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Permission ADMINISTRATION = <span class="hljs-keyword">new</span> BasePermission(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>, <span class="hljs-string">'A'</span>); <span class="hljs-comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">BasePermission</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">BasePermission</span><span class="hljs-params">(<span class="hljs-keyword">int</span> mask, <span class="hljs-keyword">char</span> code)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">super</span>(mask, code);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AclService</strong></p><p>AclService 接口中主要定义了一些解析 Acl 对象的方法，通过 ObjectIdentity 对象解析出其对应的 Acl。</p><p>AclService 主要有两类实现接口：</p><ul><li>JdbcAclService</li><li>JdbcMutableAclService</li></ul><p>前者主要是针对 Acl 的查询操作，后者支持 Acl 的添加、更新以及删除等操作。我们常用的是 JdbcMutableAclService。</p><p>至此，Acl 中一些核心概念就和小伙伴们介绍完了。</p><h3 id="2-2-Acl-数据表"><a href="#2-2-Acl-数据表" class="headerlink" title="2.2 Acl 数据表"></a>2.2 Acl 数据表</h3><p>上面提到的对象数据，都需要对应的数据表来维护，在 spring-security-acl 依赖中，为这些数据表都提供了脚本。</p><p><img src="http://img.itboyhub.com/2020/07/20200913155708.png" alt></p><p>可以看到，针对不同类型的数据库，都有对应的脚本。</p><p>这里主要涉及到四张表，接下来松哥以 MySQL 脚本为例，来分别介绍每张表的作用及其字段的含义。</p><p><strong>acl_class</strong></p><p>acl_class 是用来保存对象类型的全路径，如下：</p><p><img src="http://img.itboyhub.com/2020/07/20200913160034.png" alt></p><p>这里的 id 自增长，class 中保存的是相应对象的全路径名。</p><p><strong>acl_sid</strong></p><p>acl_sid 表用来保存 Sid 的。</p><p><img src="http://img.itboyhub.com/2020/07/20200913160149.png" alt></p><p>根据前面的介绍，存在两种类型的 Sid，GrantedAuthoritySid 和 PrincipalSid。所以这里的 principal 字段表示该 Sid 是哪种类型的。</p><p><strong>acl_object_identity</strong></p><p>acl_object_identity 用来保存需要进行访问控制的对象信息。</p><p><img src="http://img.itboyhub.com/2020/07/20200913160557.png" alt></p><ul><li>object_id_class：关联 acl_class.id。</li><li>object_id_identity：需要控制的对象的 id。</li><li>parent_object：父对象 ID，关联一条 acl_object_identity 记录。</li><li>owner_sid：这个 acl 记录拥有者的 sid。</li><li>entries_inheriting：是否需要继承父对象的权限。</li></ul><p>简单来说，这个表中的 object_id_class 和 object_id_identity 字段锁定了你要进行权限控制的对象，具体如何控制呢？则要看 acl_entry 中的关联关系了。</p><p><strong>acl_entry</strong></p><p>这个表单纯看数据，一堆数字。</p><p><img src="http://img.itboyhub.com/2020/07/20200913162338.png" alt></p><p>松哥来捋一下，大家就懂了。</p><ul><li>acl_object_identity：关联 acl_object_identity.id。</li><li>ace_order：权限顺序。acl_object_identity 和 ace_order 的组合要唯一。</li><li>sid：关联 acl_sid.id。这条权限记录关联哪个用户/角色。</li><li>mask：权限掩码。</li><li>granting：表示当前记录是否生效。</li><li>audit_success/audit_failure：审计信息。</li></ul><p>简单来说，acl_entry 中的一条记录，关联了一个要操作的对象（acl_object_identity 和 ace_order 字段），关联了 Sid（sid 字段），也描述了权限（mask），将权限涉及到的东西都在该字段中整合起来了。</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h2><p>好啦，这就本文和小伙伴们科普一下 ACL 的概念，下篇文章松哥通过一个完整的案例来和小伙伴们演示具体用法～</p><p>参考资料：</p><ol><li><a href="https://blog.gaoyuexiang.cn/2020/07/02/spring-security-acl-conception-and-component" target="_blank" rel="noopener">https://blog.gaoyuexiang.cn/2020/07/02/spring-security-acl-conception-and-component</a></li><li><a href="https://www.iteye.com/blog/elim-2269021" target="_blank" rel="noopener">https://www.iteye.com/blog/elim-2269021</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有小伙伴表示微人事(&lt;a href=&quot;https://github.com/lenve/vhr)的权限粒度不够细。不过松哥想说的是，技术都是相通的，明白了&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lenve/vhr)的权限粒度不够细。不过松哥想说的是，技术都是相通的，明白了&lt;/a&gt; vhr 中权限管理的原理，在此基础上就可以去细化权限管理粒度，细化过程和还是用的 vhr 中用的技术，只不过设计层面重新规划而已。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中的 hasRole 和 hasAuthority 有区别吗？</title>
    <link href="http://www.javaboy.org/2020/0914/springsecurity-hasrole-hasauthority.html"/>
    <id>http://www.javaboy.org/2020/0914/springsecurity-hasrole-hasauthority.html</id>
    <published>2020-09-14T01:55:19.000Z</published>
    <updated>2020-10-09T00:45:00.824Z</updated>
    
    <content type="html"><![CDATA[<p>我相信很多小伙伴在初次接触 Spring Security 时，一定会被这个问题所困扰，例如如下两段配置：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasAuthority(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasAuthority(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br></pre></td></tr></table></figure><p>那么这两种配置有什么区别呢？</p><p>今天我们就来和大家聊一聊这个问题。</p><h2 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1.源码分析"></a>1.源码分析</h2><p>单纯从源码上来分析，你会发现这两个东西似乎一样，先来看 hasAuthority。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ExpressionInterceptUrlRegistry <span class="hljs-title">hasAuthority</span><span class="hljs-params">(String authority)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> access(ExpressionUrlAuthorizationConfigurer.hasAuthority(authority));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">hasAuthority</span><span class="hljs-params">(String authority)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"hasAuthority('"</span> + authority + <span class="hljs-string">"')"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用了 access 方法，传入了权限表达式 hasAuthority(‘xxx’)。</p><p>再看 hasRole：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ExpressionInterceptUrlRegistry <span class="hljs-title">hasRole</span><span class="hljs-params">(String role)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> access(ExpressionUrlAuthorizationConfigurer.hasRole(role));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">hasRole</span><span class="hljs-params">(String role)</span> </span>&#123;</span><br><span class="line">Assert.notNull(role, <span class="hljs-string">"role cannot be null"</span>);</span><br><span class="line"><span class="hljs-keyword">if</span> (role.startsWith(<span class="hljs-string">"ROLE_"</span>)) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(</span><br><span class="line"><span class="hljs-string">"role should not start with 'ROLE_' since it is automatically inserted. Got '"</span></span><br><span class="line">+ role + <span class="hljs-string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-string">"hasRole('ROLE_"</span> + role + <span class="hljs-string">"')"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，hasRole 的处理逻辑和 hasAuthority 似乎一模一样，不同的是，hasRole 这里会自动给传入的字符串加上 <code>ROLE_</code> 前缀，所以在数据库中的权限字符串需要加上 <code>ROLE_</code> 前缀。即数据库中存储的用户角色如果是 <code>ROLE_admin</code>，这里就是 admin。</p><p>我们在调用 <code>hasAuthority</code> 方法时，如果数据是从数据库中查询出来的，这里的权限和数据库中保存一致即可，可以不加 <code>ROLE_</code> 前缀。即数据库中存储的用户角色如果是 admin，这里就是 admin。</p><p><strong>也就是说，使用 <code>hasAuthority</code> 更具有一致性，你不用考虑要不要加 <code>ROLE_</code> 前缀，数据库什么样这里就是什么样！而 <code>hasRole</code> 则不同，代码里如果写的是 <code>admin</code>，框架会自动加上 <code>ROLE_</code> 前缀，所以数据库就必须是 <code>ROLE_admin</code>。</strong></p><p>看起来 hasAuthority 和 hasRole 的区别似乎仅仅在于有没有 <code>ROLE_</code> 前缀。</p><p>在最终的权限比对中，更是过分，hasAuthority 和 hasRole 居然最终都是调用了 hasAnyAuthorityName 方法（SecurityExpressionRoot 类）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAuthority</span><span class="hljs-params">(String authority)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> hasAnyAuthority(authority);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAnyAuthority</span><span class="hljs-params">(String... authorities)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> hasAnyAuthorityName(<span class="hljs-keyword">null</span>, authorities);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasRole</span><span class="hljs-params">(String role)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> hasAnyRole(role);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAnyRole</span><span class="hljs-params">(String... roles)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> hasAnyAuthorityName(defaultRolePrefix, roles);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAnyAuthorityName</span><span class="hljs-params">(String prefix, String... roles)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; roleSet = getAuthoritySet();</span><br><span class="line"><span class="hljs-keyword">for</span> (String role : roles) &#123;</span><br><span class="line">String defaultedRole = getRoleWithDefaultPrefix(prefix, role);</span><br><span class="line"><span class="hljs-keyword">if</span> (roleSet.contains(defaultedRole)) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasAnyRole 在调用 hasAnyAuthorityName 方法时设置了 <code>ROLE_</code> 前缀，hasAnyAuthority 在调用 hasAnyAuthorityName 方法时没有设置前缀。</p><p>所以我们单纯从源码角度来看，<code>hasRole</code> 和 <code>hasAuthority</code> 这两个功能似乎一模一样，除了前缀之外就没什么区别了。</p><p>那么 Spring Security 设计者为什么要搞两个看起来一模一样的东西呢？</p><h2 id="2-设计理念"><a href="#2-设计理念" class="headerlink" title="2.设计理念"></a>2.设计理念</h2><p>从设计上来说，这是两个不同的东西。同时提供 role 和 authority 就是为了方便开发者从两个不同的维度去设计权限，所以并不冲突。</p><p>authority 描述的的是一个具体的权限，例如针对某一项数据的查询或者删除权限，它是一个 permission，例如 read_employee、delete_employee、update_employee 之类的，这些都是具体的权限，相信大家都能理解。</p><p>role 则是一个 permission 的集合，它的命名约定就是以 <code>ROLE_</code> 开始，例如我们定义的 ROLE 是 <code>ROLE_ADMIN</code>、<code>ROLE_USER</code> 等等。我们在 Spring Security 中的很多地方都能看到对 Role 的特殊处理，例如上篇文章我们所讲的<a href="https://mp.weixin.qq.com/s/sU97RQjQq2-XXQt49LkSeQ" target="_blank" rel="noopener">投票器和决策器中</a>，RoleVoter 在处理 Role 时会自动添加 <code>ROLE_</code> 前缀。</p><p>在项目中，我们可以将用户和角色关联，角色和权限关联，权限和资源关联。</p><p>反映到代码上，就是下面这样：</p><p>假设用 Spring Security 提供的 SimpleGrantedAuthority 的代表 authority，然后我们自定义一个 Role，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GrantedAuthority</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;SimpleGrantedAuthority&gt; allowedOperations = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAuthority</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SimpleGrantedAuthority&gt; <span class="hljs-title">getAllowedOperations</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> allowedOperations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAllowedOperations</span><span class="hljs-params">(List&lt;SimpleGrantedAuthority&gt; allowedOperations)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.allowedOperations = allowedOperations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 Role 就是某些 authority 的集合，然后在 User 中定义 roles 集合。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetails</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;Role&gt; roles = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Role&gt; <span class="hljs-title">getRoles</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoles</span><span class="hljs-params">(List&lt;Role&gt; roles)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.roles = roles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            authorities.addAll(role.getAllowedOperations());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> authorities.stream().distinct().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getAuthorities 方法中，加载 roles 中的权限去重后再返回即可。</p><p>通过这个例子大家应该就能搞明白 Role 和 Authority 了。</p><p>松哥在 Spring Security 的 issue 上也看到了一个类似的问题：<a href="https://github.com/spring-projects/spring-security/issues/4912" target="_blank" rel="noopener">https://github.com/spring-projects/spring-security/issues/4912</a></p><p>从作者对这个问题的回复中，也能看到一些端倪：</p><ol><li>作者承认了目前加 <code>ROLE_</code> 前缀的方式一定程度上给开发者带来了困惑，但这是一个历史积累问题。</li><li>作者说如果不喜欢 <code>ROLE_</code>，那么可以直接使用 <code>hasAuthority</code> 代替 <code>hasRole</code>，言下之意，就是这两个功能是一样的。</li><li>作者还说了一些关于权限问题的看法，权限是典型的对对象的控制，但是 Spring Security 开发者不能向 Spring Security 用户添加所有权限，因为在大多数系统中，权限都过于复杂庞大而无法完全包含在内存中。当然，如果开发者有需要，可以自定义类继承自 GrantedAuthority 以扩展其功能。</li></ol><p>从作者的回复中我们也可以看出来，<code>hasAuthority</code> 和 <code>hasRole</code> 功能上没什么区别，设计层面上确实是两个不同的东西。</p><h2 id="3-历史沿革"><a href="#3-历史沿革" class="headerlink" title="3.历史沿革"></a>3.历史沿革</h2><p>实际上，在 Spring Security4 之前，<code>hasAuthority</code> 和 <code>hasRole</code> 几乎是一模一样的，连 <code>ROLE_</code> 区别都没有！</p><p>即 <code>hasRole(&quot;admin&quot;)</code> 和 <code>hasAuthority(&quot;admin&quot;)</code> 是一样的。</p><p>而在 Spring Security4 之后，才有了前缀 <code>ROLE_</code> 的区别。</p><p>这块如果小伙伴们感兴趣的话，可以看看 Spring Security3 到 Spring Security4 的迁移文档：</p><ul><li><a href="http://docs.spring.io/spring-security/site/migrate/current/3-to-4/html5/migrate-3-to-4-jc.html#m3to4-role-prefixing" target="_blank" rel="noopener">http://docs.spring.io/spring-security/site/migrate/current/3-to-4/html5/migrate-3-to-4-jc.html#m3to4-role-prefixing</a></li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>一言以蔽之，代码上来说，hasRole 和 hasAuthority 写代码时前缀不同，但是最终执行是一样的；设计上来说，role 和 authority 这是两个层面的权限设计思路，一个是角色，一个是权限，角色是权限的集合。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信很多小伙伴在初次接触 Spring Security 时，一定会被这个问题所困扰，例如如下两段配置：&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 权限管理的投票器与表决机制</title>
    <link href="http://www.javaboy.org/2020/0911/springsecurity-voter.html"/>
    <id>http://www.javaboy.org/2020/0911/springsecurity-voter.html</id>
    <published>2020-09-11T01:55:04.000Z</published>
    <updated>2020-10-09T00:44:53.385Z</updated>
    
    <content type="html"><![CDATA[<p>今天咱们来聊一聊 Spring Security 中的表决机制与投票器。</p><a id="more"></a><p>当用户想访问 Spring Security 中一个受保护的资源时，用户具备一些角色，该资源的访问也需要一些角色，在比对用户具备的角色和资源需要的角色时，就会用到投票器和表决机制。</p><p>当用户想要访问某一个资源时，投票器根据用户的角色投出赞成或者反对票，表决方式则根据投票器的结果进行表决。</p><p>在 Spring Security 中，默认提供了三种表决机制，当然，我们也可以不用系统提供的表决机制和投票器，而是完全自己来定义，这也是可以的。</p><p>本文松哥将和大家重点介绍三种表决机制和默认的投票器。</p><h2 id="1-投票器"><a href="#1-投票器" class="headerlink" title="1.投票器"></a>1.投票器</h2><p>先来看投票器。</p><p>在 Spring Security 中，投票器是由 AccessDecisionVoter 接口来规范的，我们来看下 AccessDecisionVoter 接口的实现：</p><p><img src="http://img.itboyhub.com/2020/06/AccessDecisionVoter.png" alt></p><p>可以看到，投票器的实现有好多种，我们可以选择其中一种或多种投票器，也可以自定义投票器，默认的投票器是 WebExpressionVoter。</p><p>我们来看 AccessDecisionVoter 的定义：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AccessDecisionVoter</span>&lt;<span class="hljs-title">S</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> ACCESS_GRANTED = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ACCESS_ABSTAIN = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> ACCESS_DENIED = -<span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vote</span><span class="hljs-params">(Authentication authentication, S object,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;ConfigAttribute&gt; attributes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我稍微解释下：</p><ol><li>首先一上来定义了三个常量，从常量名字中就可以看出每个常量的含义，1 表示赞成；0 表示弃权；-1 表示拒绝。</li><li>两个 supports 方法用来判断投票器是否支持当前请求。</li><li>vote 则是具体的投票方法。在不同的实现类中实现。三个参数，authentication 表示当前登录主体；object 是一个 ilterInvocation，里边封装了当前请求；attributes 表示当前所访问的接口所需要的角色集合。</li></ol><p>我们来分别看下几个投票器的实现。</p><h3 id="1-1-RoleVoter"><a href="#1-1-RoleVoter" class="headerlink" title="1.1 RoleVoter"></a>1.1 RoleVoter</h3><p>RoleVoter 主要用来判断当前请求是否具备该接口所需要的角色，我们来看下其 vote 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vote</span><span class="hljs-params">(Authentication authentication, Object object,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;ConfigAttribute&gt; attributes)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authentication == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ACCESS_DENIED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">int</span> result = ACCESS_ABSTAIN;</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities = extractAuthorities(authentication);</span><br><span class="line"><span class="hljs-keyword">for</span> (ConfigAttribute attribute : attributes) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.supports(attribute)) &#123;</span><br><span class="line">result = ACCESS_DENIED;</span><br><span class="line"><span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (attribute.getAttribute().equals(authority.getAuthority())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ACCESS_GRANTED;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的判断逻辑很简单，如果当前登录主体为 null，则直接返回 ACCESS_DENIED 表示拒绝访问；否则就从当前登录主体 authentication 中抽取出角色信息，然后和 attributes 进行对比，如果具备 attributes 中所需角色的任意一种，则返回 ACCESS_GRANTED 表示允许访问。例如 attributes 中的角色为 [a,b,c]，当前用户具备 a，则允许访问，不需要三种角色同时具备。</p><p>另外还有一个需要注意的地方，就是 RoleVoter 的 supports 方法，我们来看下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleVoter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AccessDecisionVoter</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> String rolePrefix = <span class="hljs-string">"ROLE_"</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRolePrefix</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> rolePrefix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRolePrefix</span><span class="hljs-params">(String rolePrefix)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.rolePrefix = rolePrefix;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(ConfigAttribute attribute)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> ((attribute.getAttribute() != <span class="hljs-keyword">null</span>)</span><br><span class="line">&amp;&amp; attribute.getAttribute().startsWith(getRolePrefix())) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">else</span> &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里涉及到了一个 rolePrefix 前缀，这个前缀是 <code>ROLE_</code>，在 supports 方法中，只有主体角色前缀是 <code>ROLE_</code>，这个 supoorts 方法才会返回 true，这个投票器才会生效。</p><h3 id="1-2-RoleHierarchyVoter"><a href="#1-2-RoleHierarchyVoter" class="headerlink" title="1.2 RoleHierarchyVoter"></a>1.2 RoleHierarchyVoter</h3><p>RoleHierarchyVoter 是 RoleVoter 的一个子类，在 RoleVoter 角色判断的基础上，引入了角色分层管理，也就是角色继承，关于角色继承，小伙伴们可以参考松哥之前的文章（<a href="https://mp.weixin.qq.com/s/1ZWyD41R827FhghiCHY-Sw" target="_blank" rel="noopener">Spring Security 中如何让上级拥有下级的所有权限？</a>）。</p><p>RoleHierarchyVoter 类的 vote 方法和 RoleVoter 一致，唯一的区别在于 RoleHierarchyVoter 类重写了 extractAuthorities 方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; extractAuthorities(</span><br><span class="line">Authentication authentication) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> roleHierarchy.getReachableGrantedAuthorities(authentication</span><br><span class="line">.getAuthorities());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角色分层之后，需要通过 getReachableGrantedAuthorities 方法获取实际具备的角色，具体请参考：<a href>Spring Security 中如何让上级拥有下级的所有权限？</a> 一文。</p><h3 id="1-3-WebExpressionVoter"><a href="#1-3-WebExpressionVoter" class="headerlink" title="1.3 WebExpressionVoter"></a>1.3 WebExpressionVoter</h3><p>这是一个基于表达式权限控制的投票器，松哥后面专门花点时间和小伙伴们聊一聊基于表达式的权限控制，这里我们先不做过多展开，简单看下它的 vote 方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">vote</span><span class="hljs-params">(Authentication authentication, FilterInvocation fi,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;ConfigAttribute&gt; attributes)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">assert</span> authentication != <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">assert</span> fi != <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-keyword">assert</span> attributes != <span class="hljs-keyword">null</span>;</span><br><span class="line">WebExpressionConfigAttribute weca = findConfigAttribute(attributes);</span><br><span class="line"><span class="hljs-keyword">if</span> (weca == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> ACCESS_ABSTAIN;</span><br><span class="line">&#125;</span><br><span class="line">EvaluationContext ctx = expressionHandler.createEvaluationContext(authentication,</span><br><span class="line">fi);</span><br><span class="line">ctx = weca.postProcess(ctx, fi);</span><br><span class="line"><span class="hljs-keyword">return</span> ExpressionUtils.evaluateAsBoolean(weca.getAuthorizeExpression(), ctx) ? ACCESS_GRANTED</span><br><span class="line">: ACCESS_DENIED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你熟练使用 SpEL 的话，这段代码应该说还是很好理解的，不过根据我的经验，实际工作中用到 SpEL 场景虽然有，但是不多，所以可能有很多小伙伴并不了解 SpEL 的用法，这个需要小伙伴们自行复习下，我也给大家推荐一篇还不错的文章：<a href="https://www.cnblogs.com/larryzeal/p/5964621.html" target="_blank" rel="noopener">https://www.cnblogs.com/larryzeal/p/5964621.html</a>。</p><p>这里代码实际上就是根据传入的 attributes 属性构建 weca 对象，然后根据传入的 authentication 参数构建 ctx 对象，最后调用 evaluateAsBoolean 方法去判断权限是否匹配。</p><p>上面介绍这三个投票器是我们在实际开发中使用较多的三个。</p><h3 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4 其他"></a>1.4 其他</h3><p>另外还有几个比较冷门的投票器，松哥也稍微说下，小伙伴们了解下。</p><p><strong>Jsr250Voter</strong></p><p>处理 Jsr-250 权限注解的投票器，如 <code>@PermitAll</code>，<code>@DenyAll</code> 等。</p><p><strong>AuthenticatedVoter</strong></p><p>AuthenticatedVoter 用于判断 ConfigAttribute 上是否拥有 IS_AUTHENTICATED_FULLY、IS_AUTHENTICATED_REMEMBERED、IS_AUTHENTICATED_ANONYMOUSLY 三种角色。</p><p>IS_AUTHENTICATED_FULLY 表示当前认证用户必须是通过用户名/密码的方式认证的，通过 RememberMe 的方式认证无效。</p><p>IS_AUTHENTICATED_REMEMBERED 表示当前登录用户必须是通过 RememberMe 的方式完成认证的。</p><p>IS_AUTHENTICATED_ANONYMOUSLY 表示当前登录用户必须是匿名用户。</p><p>当项目引入 RememberMe 并且想区分不同的认证方式时，可以考虑这个投票器。</p><p><strong>AbstractAclVoter</strong></p><p>提供编写域对象 ACL 选项的帮助方法，没有绑定到任何特定的 ACL 系统。</p><p><strong>PreInvocationAuthorizationAdviceVoter</strong></p><p>使用 @PreFilter 和 @PreAuthorize 注解处理的权限，通过 PreInvocationAuthorizationAdvice 来授权。</p><p>当然，如果这些投票器不能满足需求，也可以自定义。</p><h2 id="2-表决机制"><a href="#2-表决机制" class="headerlink" title="2.表决机制"></a>2.表决机制</h2><p>一个请求不一定只有一个投票器，也可能有多个投票器，所以在投票器的基础上我们还需要表决机制。</p><p><img src="http://img.itboyhub.com/2020/07/20200909203727.png" alt></p><p>表决相关的类主要是三个：</p><ul><li>AffirmativeBased</li><li>ConsensusBased</li><li>UnanimousBased</li></ul><p>他们的继承关系如上图。</p><p>三个决策器都会把项目中的所有投票器调用一遍，默认使用的决策器是 AffirmativeBased。</p><p>三个决策器的区别如下：</p><ul><li>AffirmativeBased：有一个投票器同意了，就通过。</li><li>ConsensusBased：多数投票器同意就通过，平局的话，则看 allowIfEqualGrantedDeniedDecisions 参数的取值。</li><li>UnanimousBased 所有投票器都同意，请求才通过。</li></ul><p>这里的具体判断逻辑比较简单，松哥就不贴源码了，感兴趣的小伙伴可以自己看看。</p><h2 id="3-在哪里配置"><a href="#3-在哪里配置" class="headerlink" title="3.在哪里配置"></a>3.在哪里配置</h2><p>当我们使用基于表达式的权限控制时，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().fullyAuthenticated()</span><br></pre></td></tr></table></figure><p>那么默认的投票器和决策器是在 AbstractInterceptUrlConfigurer#createDefaultAccessDecisionManager 方法中配置的：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> AccessDecisionManager <span class="hljs-title">createDefaultAccessDecisionManager</span><span class="hljs-params">(H http)</span> </span>&#123;</span><br><span class="line">AffirmativeBased result = <span class="hljs-keyword">new</span> AffirmativeBased(getDecisionVoters(http));</span><br><span class="line"><span class="hljs-keyword">return</span> postProcess(result);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;AccessDecisionVoter&lt;?&gt;&gt; getDecisionVoters(H http) &#123;</span><br><span class="line">List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">WebExpressionVoter expressionVoter = <span class="hljs-keyword">new</span> WebExpressionVoter();</span><br><span class="line">expressionVoter.setExpressionHandler(getExpressionHandler(http));</span><br><span class="line">decisionVoters.add(expressionVoter);</span><br><span class="line"><span class="hljs-keyword">return</span> decisionVoters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以看到默认的决策器和投票器，并且决策器 AffirmativeBased 对象创建好之后，还调用 postProcess 方法注册到 Spring 容器中去了，结合松哥本系列前面的文章，大家知道，如果我们想要修改该对象就非常容易了：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().fullyAuthenticated()</span><br><span class="line">        .withObjectPostProcessor(<span class="hljs-keyword">new</span> ObjectPostProcessor&lt;AffirmativeBased&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-keyword">public</span> &lt;O extends AffirmativeBased&gt; <span class="hljs-function">O <span class="hljs-title">postProcess</span><span class="hljs-params">(O object)</span> </span>&#123;</span><br><span class="line">                List&lt;AccessDecisionVoter&lt;?&gt;&gt; decisionVoters = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                decisionVoters.add(<span class="hljs-keyword">new</span> RoleHierarchyVoter(roleHierarchy()));</span><br><span class="line">                AffirmativeBased affirmativeBased = <span class="hljs-keyword">new</span> AffirmativeBased(decisionVoters);</span><br><span class="line">                <span class="hljs-keyword">return</span> (O) affirmativeBased;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .and()</span><br><span class="line">        .csrf()</span><br><span class="line">        .disable();</span><br></pre></td></tr></table></figure><p><strong>这里只是给大家一个演示，正常来说我们是不需要这样修改的</strong>。当我们使用不同的权限配置方式时，会有自动配置对应的投票器和决策器。或者我们手动配置投票器和决策器，如果是系统配置好的，大部分情况下并不需要我们修改。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>本文主要和小伙伴们简单分享一下 Spring Security 中的投票器和决策器，关于授权的更多知识，松哥下篇文章继续和小伙伴们细聊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天咱们来聊一聊 Spring Security 中的表决机制与投票器。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 中如何让上级拥有下级的所有权限？</title>
    <link href="http://www.javaboy.org/2020/0909/springsecurity-role-hierarchy.html"/>
    <id>http://www.javaboy.org/2020/0909/springsecurity-role-hierarchy.html</id>
    <published>2020-09-09T01:54:47.000Z</published>
    <updated>2020-10-09T00:44:45.168Z</updated>
    
    <content type="html"><![CDATA[<p>答案是能！</p><a id="more"></a><p>松哥之前写过类似的文章，但是主要是讲了用法，今天我们来看看原理！</p><p>本文基于当前 Spring Security 5.3.4 来分析，为什么要强调最新版呢？因为在在 5.0.11 版中，角色继承配置和现在不一样。旧版的方案我们现在不讨论了，直接来看当前最新版是怎么处理的。</p><h2 id="1-角色继承案例"><a href="#1-角色继承案例" class="headerlink" title="1.角色继承案例"></a>1.角色继承案例</h2><p>我们先来一个简单的权限案例。</p><p>创建一个 Spring Boot 项目，添加 Spring Security 依赖，并创建两个测试用户，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="hljs-string">"javaboy"</span>)</span><br><span class="line">            .password(<span class="hljs-string">"&#123;noop&#125;123"</span>).roles(<span class="hljs-string">"admin"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .withUser(<span class="hljs-string">"江南一点雨"</span>)</span><br><span class="line">            .password(<span class="hljs-string">"&#123;noop&#125;123"</span>)</span><br><span class="line">            .roles(<span class="hljs-string">"user"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后准备三个测试接口，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@RestController</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/admin/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">admin</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"admin"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/hello"</span>)</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"user"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个测试接口，我们的规划是这样的：</p><ol><li>/hello 是任何人都可以访问的接口</li><li>/admin/hello 是具有 admin 身份的人才能访问的接口</li><li>/user/hello 是具有 user 身份的人才能访问的接口</li><li>所有 user 能够访问的资源，admin 都能够访问</li></ol><p><strong>注意第四条规范意味着所有具备 admin 身份的人自动具备 user 身份。</strong></p><p>接下来我们来配置权限的拦截规则，在 Spring Security 的 configure(HttpSecurity http) 方法中，代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http.authorizeRequests()</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/admin/**"</span>).hasRole(<span class="hljs-string">"admin"</span>)</span><br><span class="line">        .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"user"</span>)</span><br><span class="line">        .anyRequest().authenticated()</span><br><span class="line">        .and()</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这里的匹配规则我们采用了 Ant 风格的路径匹配符，Ant 风格的路径匹配符在 Spring 家族中使用非常广泛，它的匹配规则也非常简单：</p><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>**</code></td><td style="text-align:left">匹配多层路径</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">匹配一层路径</td></tr><tr><td style="text-align:left"><code>?</code></td><td style="text-align:left">匹配任意单个字符</td></tr></tbody></table><p>上面配置的含义是：</p><ol><li>如果请求路径满足 <code>/admin/**</code> 格式，则用户需要具备 admin 角色。</li><li>如果请求路径满足 <code>/user/**</code> 格式，则用户需要具备 user 角色。</li><li>剩余的其他格式的请求路径，只需要认证（登录）后就可以访问。</li></ol><p>注意代码中配置的三条规则的顺序非常重要，和 Shiro 类似，Spring Security 在匹配的时候也是按照从上往下的顺序来匹配，一旦匹配到了就不继续匹配了，<strong>所以拦截规则的顺序不能写错</strong>。</p><p>如果使用角色继承，这个功能很好实现，我们只需要在 SecurityConfig 中添加如下代码来配置角色继承关系即可：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Bean</span></span><br><span class="line"><span class="hljs-function">RoleHierarchy <span class="hljs-title">roleHierarchy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    RoleHierarchyImpl hierarchy = <span class="hljs-keyword">new</span> RoleHierarchyImpl();</span><br><span class="line">    hierarchy.setHierarchy(<span class="hljs-string">"ROLE_admin &gt; ROLE_user"</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> hierarchy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在配置时，需要给角色手动加上 <code>ROLE_</code> 前缀。上面的配置表示 <code>ROLE_admin</code> 自动具备 <code>ROLE_user</code> 的权限。</p><p>接下来，我们启动项目进行测试。</p><p>项目启动成功后，我们首先以 江南一点雨的身份进行登录：</p><p><img src="http://img.itboyhub.com/2020/04/security-5-2.png" alt></p><p>登录成功后，分别访问 <code>/hello</code>，<code>/admin/hello</code> 以及 <code>/user/hello</code> 三个接口，其中：</p><ol><li><code>/hello</code> 因为登录后就可以访问，这个接口访问成功。</li><li><code>/admin/hello</code> 需要 admin 身份，所以访问失败。</li><li><code>/user/hello</code> 需要 user 身份，所以访问成功。</li></ol><p>再以 javaboy 身份登录，登录成功后，我们发现 javaboy 也能访问 <code>/user/hello</code> 这个接口了，说明我们的角色继承配置没问题！</p><h2 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2.原理分析"></a>2.原理分析</h2><p>这里配置的核心在于我们提供了一个 RoleHierarchy 实例，所以我们的分析就从该类入手。</p><p>RoleHierarchy 是一个接口，该接口中只有一个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RoleHierarchy</span> </span>&#123;</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; getReachableGrantedAuthorities(</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法参数 authorities 是一个权限集合，从方法名上看方法的返回值是一个可访问的权限集合。</p><p>举个简单的例子，假设角色层次结构是 <code>ROLE_A &gt; ROLE_B &gt; ROLE_C</code>，现在直接给用户分配的权限是 <code>ROLE_A</code>，但实际上用户拥有的权限有 <code>ROLE_A</code>、<code>ROLE_B</code> 以及 <code>ROLE_C</code>。</p><p>getReachableGrantedAuthorities 方法的目的就是是根据角色层次定义，将用户真正可以触达的角色解析出来。</p><p>RoleHierarchy 接口有两个实现类，如下图：</p><p><img src="http://img.itboyhub.com/2020/07/20200908153034.png" alt></p><ul><li>NullRoleHierarchy 这是一个空的实现，将传入的参数原封不动返回。</li><li>RoleHierarchyImpl 这是我们上文所使用的实现，这个会完成一些解析操作。</li></ul><p>我们来重点看下 RoleHierarchyImpl 类。</p><p>这个类中实际上就四个方法 <code>setHierarchy</code>、<code>getReachableGrantedAuthorities</code>、<code>buildRolesReachableInOneStepMap</code> 以及 <code>buildRolesReachableInOneOrMoreStepsMap</code>，我们来逐个进行分析。</p><p>首先是我们一开始调用的 setHierarchy 方法，这个方法用来设置角色层级关系：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHierarchy</span><span class="hljs-params">(String roleHierarchyStringRepresentation)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.roleHierarchyStringRepresentation = roleHierarchyStringRepresentation;</span><br><span class="line"><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="hljs-string">"setHierarchy() - The following role hierarchy was set: "</span></span><br><span class="line">+ roleHierarchyStringRepresentation);</span><br><span class="line">&#125;</span><br><span class="line">buildRolesReachableInOneStepMap();</span><br><span class="line">buildRolesReachableInOneOrMoreStepsMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户传入的字符串变量设置给 roleHierarchyStringRepresentation 属性，然后通过 buildRolesReachableInOneStepMap 和 buildRolesReachableInOneOrMoreStepsMap 方法完成对角色层级的解析。</p><p>buildRolesReachableInOneStepMap 方法用来将角色关系解析成一层一层的形式。我们来看下它的源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRolesReachableInOneStepMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneStepMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String line : <span class="hljs-keyword">this</span>.roleHierarchyStringRepresentation.split(<span class="hljs-string">"\n"</span>)) &#123;</span><br><span class="line">String[] roles = line.trim().split(<span class="hljs-string">"\\s+&gt;\\s+"</span>);</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; roles.length; i++) &#123;</span><br><span class="line">String higherRole = roles[i - <span class="hljs-number">1</span>];</span><br><span class="line">GrantedAuthority lowerRole = <span class="hljs-keyword">new</span> SimpleGrantedAuthority(roles[i]);</span><br><span class="line">Set&lt;GrantedAuthority&gt; rolesReachableInOneStepSet;</span><br><span class="line"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.containsKey(higherRole)) &#123;</span><br><span class="line">rolesReachableInOneStepSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.put(higherRole, rolesReachableInOneStepSet);</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">rolesReachableInOneStepSet = <span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.get(higherRole);</span><br><span class="line">&#125;</span><br><span class="line">rolesReachableInOneStepSet.add(lowerRole);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先大家看到，按照换行符来解析用户配置的多个角色层级，这是什么意思呢？</p><p>我们前面案例中只是配置了 <code>ROLE_admin &gt; ROLE_user</code>，如果你需要配置多个继承关系，怎么配置呢？多个继承关系用 <code>\n</code> 隔开即可，如下 <code>ROLE_A &gt; ROLE_B \n ROLE_C &gt; ROLE_D</code>。还有一种情况，如果角色层级关系是连续的，也可以这样配置 <code>ROLE_A &gt; ROLE_B &gt; ROLE_C &gt; ROLE_D</code>。</p><p>所以这里先用 <code>\n</code> 将多层继承关系拆分开形成一个数组，然后对数组进行遍历。</p><p>在具体遍历中，通过 <code>&gt;</code> 将角色关系拆分成一个数组，然后对数组进行解析，高一级的角色作为 key，低一级的角色作为 value。</p><p>代码比较简单，最终的解析出来存入 rolesReachableInOneStepMap 中的层级关系是这样的：</p><p>假设角色继承关系是 <code>ROLE_A &gt; ROLE_B \n ROLE_C &gt; ROLE_D \n ROLE_C &gt; ROLE_E</code>，Map 中的数据是这样：</p><ul><li>A–&gt;B</li><li>C–&gt;[D,E]</li></ul><p>假设角色继承关系是 <code>ROLE_A &gt; ROLE_B &gt; ROLE_C &gt; ROLE_D</code>，Map 中的数据是这样：</p><ul><li>A–&gt;B</li><li>B–&gt;C</li><li>C–&gt;D</li></ul><p>这是 buildRolesReachableInOneStepMap 方法解析出来的 rolesReachableInOneStepMap 集合。</p><p>接下来的 buildRolesReachableInOneOrMoreStepsMap 方法则是对 rolesReachableInOneStepMap 集合进行再次解析，将角色的继承关系拉平。</p><p>例如 rolesReachableInOneStepMap 中保存的角色继承关系如下：</p><ul><li>A–&gt;B</li><li>B–&gt;C</li><li>C–&gt;D</li></ul><p>经过 buildRolesReachableInOneOrMoreStepsMap 方法解析之后，新的 Map 中保存的数据如下：</p><ul><li>A–&gt;[B、C、D]</li><li>B–&gt;[C、D]</li><li>C–&gt;D</li></ul><p>这样解析完成后，每一个角色可以触达到的角色就一目了然了。</p><p>我们来看下 buildRolesReachableInOneOrMoreStepsMap 方法的实现逻辑：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRolesReachableInOneOrMoreStepsMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneOrMoreStepsMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (String roleName : <span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.keySet()) &#123;</span><br><span class="line">Set&lt;GrantedAuthority&gt; rolesToVisitSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(<span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.get(roleName));</span><br><span class="line">Set&lt;GrantedAuthority&gt; visitedRolesSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">while</span> (!rolesToVisitSet.isEmpty()) &#123;</span><br><span class="line">GrantedAuthority lowerRole = rolesToVisitSet.iterator().next();</span><br><span class="line">rolesToVisitSet.remove(lowerRole);</span><br><span class="line"><span class="hljs-keyword">if</span> (!visitedRolesSet.add(lowerRole) ||</span><br><span class="line">!<span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.containsKey(lowerRole.getAuthority())) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (roleName.equals(lowerRole.getAuthority())) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CycleInRoleHierarchyException();</span><br><span class="line">&#125;</span><br><span class="line">rolesToVisitSet.addAll(<span class="hljs-keyword">this</span>.rolesReachableInOneStepMap.get(lowerRole.getAuthority()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">this</span>.rolesReachableInOneOrMoreStepsMap.put(roleName, visitedRolesSet);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法还比较巧妙。首先根据 roleName 从 rolesReachableInOneStepMap 中获取对应的 rolesToVisitSet，这个 rolesToVisitSet 是一个 Set 集合，对其进行遍历，将遍历结果添加到 visitedRolesSet 集合中，如果 rolesReachableInOneStepMap 集合的 key 不包含当前读取出来的 lowerRole，说明这个 lowerRole 就是整个角色体系中的最底层，直接 continue。否则就把 lowerRole 在 rolesReachableInOneStepMap 中对应的 value 拿出来继续遍历。</p><p>最后将遍历结果存入 rolesReachableInOneOrMoreStepsMap 集合中即可。</p><p>这个方法有点绕，小伙伴们可以自己打个断点品一下。</p><p>看了上面的分析，小伙伴们可能发现了，其实角色继承，最终还是拉平了去对比。</p><p>我们定义的角色有层级，但是代码中又将这种层级拉平了，方便后续的比对。</p><p>最后还有一个 getReachableGrantedAuthorities 方法，根据传入的角色分析出其可能潜在包含的一些角色：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;GrantedAuthority&gt; <span class="hljs-title">getReachableGrantedAuthorities</span><span class="hljs-params">(</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authorities == <span class="hljs-keyword">null</span> || authorities.isEmpty()) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> AuthorityUtils.NO_AUTHORITIES;</span><br><span class="line">&#125;</span><br><span class="line">Set&lt;GrantedAuthority&gt; reachableRoles = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; processedNames = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span> (GrantedAuthority authority : authorities) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (authority.getAuthority() == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">reachableRoles.add(authority);</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">if</span> (!processedNames.add(authority.getAuthority())) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">reachableRoles.add(authority);</span><br><span class="line">Set&lt;GrantedAuthority&gt; lowerRoles = <span class="hljs-keyword">this</span>.rolesReachableInOneOrMoreStepsMap.get(authority.getAuthority());</span><br><span class="line"><span class="hljs-keyword">if</span> (lowerRoles == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line"><span class="hljs-keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (GrantedAuthority role : lowerRoles) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (processedNames.add(role.getAuthority())) &#123;</span><br><span class="line">reachableRoles.add(role);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;GrantedAuthority&gt; reachableRoleList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(reachableRoles.size());</span><br><span class="line">reachableRoleList.addAll(reachableRoles);</span><br><span class="line"><span class="hljs-keyword">return</span> reachableRoleList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的逻辑比较直白，就是从 rolesReachableInOneOrMoreStepsMap 集合中查询出当前角色真正可访问的角色信息。</p><h2 id="3-RoleHierarchyVoter"><a href="#3-RoleHierarchyVoter" class="headerlink" title="3.RoleHierarchyVoter"></a>3.RoleHierarchyVoter</h2><p>getReachableGrantedAuthorities 方法将在 RoleHierarchyVoter 投票器中被调用。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleHierarchyVoter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RoleVoter</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">private</span> RoleHierarchy roleHierarchy = <span class="hljs-keyword">null</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoleHierarchyVoter</span><span class="hljs-params">(RoleHierarchy roleHierarchy)</span> </span>&#123;</span><br><span class="line">Assert.notNull(roleHierarchy, <span class="hljs-string">"RoleHierarchy must not be null"</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.roleHierarchy = roleHierarchy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; extractAuthorities(</span><br><span class="line">Authentication authentication) &#123;</span><br><span class="line"><span class="hljs-keyword">return</span> roleHierarchy.getReachableGrantedAuthorities(authentication</span><br><span class="line">.getAuthorities());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 Spring Security 投票器，将是另外一个故事，松哥将在下篇文章中和小伙伴们分享投票器和决策器～</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，今天就和小伙伴们简简单单聊一下角色继承的问题，感兴趣的小伙伴可以自己试一下～如果觉得有收获，记得点个在看鼓励下松哥哦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;答案是能！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Security" scheme="http://www.javaboy.org/categories/Spring-Security/"/>
    
    
      <category term="Spring Security" scheme="http://www.javaboy.org/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring 源码系列之容器概览～</title>
    <link href="http://www.javaboy.org/2020/0907/spring-container-overview.html"/>
    <id>http://www.javaboy.org/2020/0907/spring-container-overview.html</id>
    <published>2020-09-07T01:54:33.000Z</published>
    <updated>2020-10-09T00:43:49.809Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章和小伙伴们分享了 Spring 中的 FactoryBean（<a href="https://mp.weixin.qq.com/s/uNmbDpiAZ1Lku1GQz7IqDQ" target="_blank" rel="noopener">Spring 源码第 9 篇，深入分析 FactoryBean</a>），大家知道 Spring 中还有一个和 FactoryBean 单词很像的类叫做 BeanFactory！</p><a id="more"></a><p>今天松哥就再通过一篇文章来和大家聊聊 BeanFactory！</p><h2 id="1-容器概览"><a href="#1-容器概览" class="headerlink" title="1.容器概览"></a>1.容器概览</h2><p>Spring 中的 Ioc 容器，我们可以大致上分为两种：</p><ul><li>BeanFactory</li><li>ApplicationContext</li></ul><h3 id="1-1-BeanFactory"><a href="#1-1-BeanFactory" class="headerlink" title="1.1 BeanFactory"></a>1.1 BeanFactory</h3><p>BeanFactory 是最最基础的 IoC 容器，它提供了一个 IoC 容器所需的基本功能。在本系列前面文章中我们所用到的 XmlBeanFactory 就是它的实现之一。</p><p>BeanFactory 默认采用延迟初始化策略，即当容器启动时，并未完成 Bean 的初始化，只有当调用到该 Bean 的实例时，才会完成其初始化操作，并进行依赖注入。</p><p>例如如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanFactory factory = <span class="hljs-keyword">new</span> XmlBeanFactory(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"beans.xml"</span>));</span><br><span class="line">User user = factory.getBean(User.class);</span><br></pre></td></tr></table></figure><p>当第一行代码执行的时候，beans.xml 中配置的 User 对象并未进行初始化，只有当第二行 getBean 方法调用时，User 对象才进行了初始化操作。</p><p>这样设计的好处是容器启动速度快，因为要做的事情比较少。</p><h3 id="1-2-ApplicationContext"><a href="#1-2-ApplicationContext" class="headerlink" title="1.2 ApplicationContext"></a>1.2 ApplicationContext</h3><p>ApplicationContext 是在 BeanFactory 的基础上实现的，BeanFactory 的功能它都有，算是一种高级容器。</p><p>ApplicationContext 在 BeanFactory 的基础上提供了事件发布、国际化等功能。</p><p>同时，ApplicationContext 和 BeanFactory 还有一个很大的不同在于 ApplicationContext 在容器启动时，就会完成所有 Bean 的初始化，这也就以为着容器启动时间较长，并且对系统资源要求也较高。</p><p>例如如下一段代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans.xml"</span>);</span><br></pre></td></tr></table></figure><p>当这段代码执行时，beans.xml 中配置的 User 对象就会完成初始化操作。</p><h2 id="2-BeanFactory"><a href="#2-BeanFactory" class="headerlink" title="2.BeanFactory"></a>2.BeanFactory</h2><p>BeanFactory 的继承关系图太大了，放在文章里显示不全。小伙伴们可以在 IDEA 中自行查看，我这里就不贴图出来了。</p><p>我们来看下 BeanFactory 的源码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="hljs-string">"&amp;"</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name, <span class="hljs-keyword">boolean</span> allowFactoryBeanInit) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，BeanFactory 主要提供了一些和 Bean 相关的查询方法。</p><p><strong>FACTORY_BEAN_PREFIX</strong></p><p>这是定义的 FactoryBean 前缀，具体参考<a href="https://mp.weixin.qq.com/s/uNmbDpiAZ1Lku1GQz7IqDQ" target="_blank" rel="noopener">Spring 源码第 9 篇，深入分析 FactoryBean</a>。</p><p><strong>getBean</strong></p><p>getBean 方法一共有五个。</p><p>在获取一个 Bean 的时候，可以指定 Bean 的名字，也可以指定 Bean 的类型，也可以同时指定，这个好理解。</p><p>还有两个重载的方法里边有一个 args 参数，这个可能有的小伙伴们没怎么用过，我这里稍微解释下。</p><p>其实我们大概能猜出来 args 是获取 Bean 时所需要的参数，如果使用该方法给 Bean 配置参数，需要将 Bean 的 scope 设置为 prototype，这就意味着每次获取 Bean 的时候，才去进行 Bean 的初始化（否则配置的参数无法生效）。</p><p>松哥通过一个例子来给大家演示下。</p><p>首先我们提供一个 User 类：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String username;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">        <span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"username='"</span> + username + <span class="hljs-string">'\''</span> +</span><br><span class="line">                <span class="hljs-string">", age="</span> + age +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，User 类只有一个有参的构造方法。</p><p>接下来我们在 XML 文件中进行配置，XML 文件中需要配置 User 类的构造方法参数，我们可以配置为 null，同时记得设置 scope 属性为 prototype。</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.javaboy.spring_demo04.User"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user1"</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">null</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后再通过如下方式加载 Bean：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"beans.xml"</span>);</span><br><span class="line">User user = ctx.getBean(User.class,<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">"javaboy"</span>,<span class="hljs-number">99</span>&#125;);</span><br><span class="line">System.out.println(<span class="hljs-string">"user = "</span> + user);</span><br></pre></td></tr></table></figure><p>最终打印结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;username=&apos;javaboy&apos;, age=99&#125;</span><br></pre></td></tr></table></figure><p>可以看到，为 Bean 配置的参数都生效了。</p><p><strong>getBeanProvider</strong></p><p>方法用于获取指定 Bean 的提供者，可以看到它返回的是一个 ObjectProvider，该类扩展自 ObjectFactory，从 Spring4.3 时开始提供。</p><p>可能大家对 ObjectProvider 接触较少，这里我也稍微说一下。</p><p>先来看 ObjectFactory：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ObjectFactory</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectFactory 有点类似于我们在 <a href="https://mp.weixin.qq.com/s/uNmbDpiAZ1Lku1GQz7IqDQ" target="_blank" rel="noopener">Spring 源码第 9 篇，深入分析 FactoryBean</a> 一文中所讲的 FactoryBean。</p><p>不同的是，ObjectFactory 中只有一个 getObject 方法，该方法可以返回 Object 实例。ObjectFactory 与 FactoryBean 相似，但是后者的实现通常是在 BeanFactory 中定义为 SPI 实例，而此类的实现通常是作为 API 注入给其他 Bean。</p><p>再来看 ObjectProvider（部分）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ObjectProvider</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ObjectFactory</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//返回指定类型的 bean, 如果容器中不存在, 抛出 NoSuchBeanDefinitionException 异常；如果容器中有多个此类型的 bean, 抛出 NoUniqueBeanDefinitionException 异常</span></span><br><span class="line"><span class="hljs-function">T <span class="hljs-title">getObject</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="hljs-comment">//如果指定类型的 bean 注册到容器中, 返回 bean 实例, 否则返回 null</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">T <span class="hljs-title">getIfAvailable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="hljs-comment">//如果指定类型的 bean 在容器中只有一个 bean, 返回 bean 实例, 如果不存在则返回 null；如果容器中有多个此类型的 bean, 抛出 NoUniqueBeanDefinitionException 异常</span></span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">T <span class="hljs-title">getIfUnique</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="hljs-comment">// Spring5.0 之后提供，返回指定类型 Bean 的迭代器</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> stream().iterator();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="hljs-comment">//转为 Stream</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;T&gt; <span class="hljs-title">stream</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Multi element access not supported"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">default</span> Stream&lt;T&gt; <span class="hljs-title">orderedStream</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"Ordered element access not supported"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 ObjectProvider 的源码，那么它有什么用呢？松哥举个简单例子。</p><p>在 Spring4.3 之前。</p><p>假设我有一个 UserDao，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Repository</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个 UserService，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Autowired</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"UserService&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"userDao="</span> + userDao +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 UserService 中注入 UserDao 时，必须明确给出 @Autowired 注解。</p><p>这看起来不够优雅！</p><p>从 Spring4.3 开始，在 UserService 中注入 UserDao 时，如果构造方法只有一个参数，可以不用添加 @Autowired 注解，像下面这样：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"UserService&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"userDao="</span> + userDao +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果 UserDao 为 null，则会导致 UserService 初始化失败，通过 ObjectProvider 可以解决，如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Service</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span><span class="hljs-params">(ObjectProvider&lt;UserDao&gt; userDao)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.userDao = userDao.getIfUnique();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"UserService&#123;"</span> +</span><br><span class="line">                <span class="hljs-string">"userDao="</span> + userDao +</span><br><span class="line">                <span class="hljs-string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是 ObjectProvider。好啦，扯远了，我们回到 BeanFactory 继续看它里边的方法。</p><p><strong>containsBean</strong></p><p>判断容器中是否包含某个 Bean。</p><p><strong>isSingleton</strong></p><p>判断某个 Bean 是否是单例的。</p><p><strong>isPrototype</strong></p><p>判断某个 Bean 是否是 prototype。</p><p><strong>isTypeMatch</strong></p><p>返回指定名称的 Bean 是否匹配指定的类型。</p><p><strong>getType</strong></p><p>返回指定名称的 Bean 对应的数据类型。</p><p><strong>getAliases</strong></p><p>返回 Bean 的别名。</p><p>这就是 BeanFactory 中定义的所有方法，可以看到，基本上都是容器相关的查询方法，接下来将在 BeanFactory 的各种实现类中，对其进行实现。</p><h2 id="3-二级接口"><a href="#3-二级接口" class="headerlink" title="3.二级接口"></a>3.二级接口</h2><p>BeanFactory 作为 IoC 容器中最顶层的定义，没有继承任何接口，我们可以称之为一级接口，直接继承自 BeanFactory 的接口有三个，我们称之为二级接口。</p><h3 id="3-1-HierarchicalBeanFactory"><a href="#3-1-HierarchicalBeanFactory" class="headerlink" title="3.1 HierarchicalBeanFactory"></a>3.1 HierarchicalBeanFactory</h3><p>HierarchicalBeanFactory 继承自 BeanFactory，定义了工厂分层，在其基础上又扩展了两个方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HierarchicalBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="hljs-function">BeanFactory <span class="hljs-title">getParentBeanFactory</span><span class="hljs-params">()</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsLocalBean</span><span class="hljs-params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getParentBeanFactory 方法返回 Bean 工厂的父工厂，实现了工厂分层。</li><li>containsLocalBean 方法则判断本地工厂是否包含这个 Bean。</li></ul><p>HierarchicalBeanFactory 有一个接口 <strong>ConfigurableBeanFactory</strong>，ConfigurableBeanFactory 接口继承自 HierarchicalBeanFactory 和 SingletonBeanRegistry，其中 SingletonBeanRegistry 这个接口定义了对单例 Bean 的定义以及获取方法。也就是说，ConfigurableBeanFactory 中兼具工厂分层和单例处理功能。同时，在 HierarchicalBeanFactory 中 getParentBeanFactory 所 get 到的对象，也是在 ConfigurableBeanFactory 中完成配置。</p><h3 id="3-2-AutowireCapableBeanFactory"><a href="#3-2-AutowireCapableBeanFactory" class="headerlink" title="3.2 AutowireCapableBeanFactory"></a>3.2 AutowireCapableBeanFactory</h3><p>AutowireCapableBeanFactory 继承自 BeanFacotory，它扩展了自动装配的功能。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AutowireCapableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_NO = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_BY_NAME = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_BY_TYPE = <span class="hljs-number">2</span>;</span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_CONSTRUCTOR = <span class="hljs-number">3</span>;</span><br><span class="line"><span class="hljs-meta">@Deprecated</span></span><br><span class="line"><span class="hljs-keyword">int</span> AUTOWIRE_AUTODETECT = <span class="hljs-number">4</span>;</span><br><span class="line">String ORIGINAL_INSTANCE_SUFFIX = <span class="hljs-string">".ORIGINAL"</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">createBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">createBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-keyword">int</span> autowireMode, <span class="hljs-keyword">boolean</span> dependencyCheck)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">autowireBean</span><span class="hljs-params">(Object existingBean)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">autowire</span><span class="hljs-params">(Class&lt;?&gt; beanClass, <span class="hljs-keyword">int</span> autowireMode, <span class="hljs-keyword">boolean</span> dependencyCheck)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">autowireBeanProperties</span><span class="hljs-params">(Object existingBean, <span class="hljs-keyword">int</span> autowireMode, <span class="hljs-keyword">boolean</span> dependencyCheck)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">configureBean</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">initializeBean</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">applyBeanPropertyValues</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">applyBeanPostProcessorsBeforeInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">applyBeanPostProcessorsAfterInitialization</span><span class="hljs-params">(Object existingBean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroyBean</span><span class="hljs-params">(Object existingBean)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">NamedBeanHolder&lt;T&gt; <span class="hljs-title">resolveNamedBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">resolveBeanByName</span><span class="hljs-params">(String name, DependencyDescriptor descriptor)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line"><span class="hljs-function">Object <span class="hljs-title">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, @Nullable String requestingBeanName,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">@Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过五个常量定义了五种不同的装配策略，分别是：不自动装配、通过名称自动装配、通过类型自动装配、通过构造方法自动装配，还有一个过期的常量。</p><p><code>ORIGINAL_INSTANCE_SUFFIX</code> 则是初始化实例给定名称时约定的后缀，该后缀会添加到类的全路径后面，例如：<code>com.mypackage.MyClass.ORIGINAL</code>。</p><p><code>createBean</code> 方法用来创建 <code>Bean</code> 实例；<code>autowire*</code> 方法则用来完成自动装配；<code>configureBean</code> 用来配置 <code>Bean</code>；<code>initializeBean</code> 用来初始化 <code>Bean</code>；<code>applyBeanPropertyValues</code> 将指定 <code>bean</code> 的 <code>BeanDefinition</code> 应用到一个已经存在的 <code>Bean</code> 上；<code>applyBeanPostProcessorsBeforeInitialization/applyBeanPostProcessorsAfterInitialization</code> 调用 <code>Bean</code> 的后置处理器；<code>destroyBean</code> 方法用来销毁 <code>Bean</code>；<code>resolve*</code> 方法用来解析 <code>Bean</code>。</p><h3 id="3-3-ListableBeanFactory"><a href="#3-3-ListableBeanFactory" class="headerlink" title="3.3 ListableBeanFactory"></a>3.3 ListableBeanFactory</h3><p>ListableBeanFactory 继承自 BeanFacotory，该接口可以列出工厂可以生产的所有实例。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactory</span> </span>&#123;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span></span>;</span><br><span class="line">String[] getBeanDefinitionNames();</span><br><span class="line">String[] getBeanNamesForType(ResolvableType type);</span><br><span class="line">String[] getBeanNamesForType(ResolvableType type, <span class="hljs-keyword">boolean</span> includeNonSingletons, <span class="hljs-keyword">boolean</span> allowEagerInit);</span><br><span class="line">String[] getBeanNamesForType(<span class="hljs-meta">@Nullable</span> Class&lt;?&gt; type);</span><br><span class="line">String[] getBeanNamesForType(<span class="hljs-meta">@Nullable</span> Class&lt;?&gt; type, <span class="hljs-keyword">boolean</span> includeNonSingletons, <span class="hljs-keyword">boolean</span> allowEagerInit);</span><br><span class="line">&lt;T&gt; <span class="hljs-function">Map&lt;String, T&gt; <span class="hljs-title">getBeansOfType</span><span class="hljs-params">(@Nullable Class&lt;T&gt; type)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="hljs-function">Map&lt;String, T&gt; <span class="hljs-title">getBeansOfType</span><span class="hljs-params">(@Nullable Class&lt;T&gt; type, <span class="hljs-keyword">boolean</span> includeNonSingletons, <span class="hljs-keyword">boolean</span> allowEagerInit)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line">String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType);</span><br><span class="line"><span class="hljs-function">Map&lt;String, Object&gt; <span class="hljs-title">getBeansWithAnnotation</span><span class="hljs-params">(Class&lt;? extends Annotation&gt; annotationType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="hljs-meta">@Nullable</span></span><br><span class="line">&lt;A extends Annotation&gt; <span class="hljs-function">A <span class="hljs-title">findAnnotationOnBean</span><span class="hljs-params">(String beanName, Class&lt;A&gt; annotationType)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>containsBeanDefinition：判断容器是否包含某一个 Bean 的定义。</li><li>getBeanDefinitionCount：获取 BeanDefinition 数量。getBeanDefinitionCount 和 containsBeanDefinition 执行效率较低，慎用。</li><li>getBeanDefinitionNames：获取所有 Bean 的名字。</li><li>getBeanNamesForType：返回指定类型的 BeanName。</li><li>getBeansOfType：返回指定类的名称和 Bean Map（相同类型的 Bean 可能存在多种实例）。</li><li>getBeanNamesForAnnotation：根据注解获取指定的 BeanName。</li><li>getBeansWithAnnotation：根据注解获取指定的 BeanName 以及 Bean Map。</li><li>findAnnotationOnBean：根据指定 beanName 和注解类型查找指定的 Bean。</li></ul><p>ListableBeanFactory 有一个实现接口 <strong>ConfigurableListableBeanFactory</strong>，这是以上所介绍接口的集大成者，ConfigurableListableBeanFactory 继承自 ListableBeanFactory、AutowireCapableBeanFactory 以及 ConfigurableBeanFactory，可以看到，三个二级接口功能集于一身，它包含了 BeanFactory 体系目前的所有方法。这些方法都在 DefaultListableBeanFactory 中进行实现，也就是我们前面所讲的 <a href="https://mp.weixin.qq.com/s/vQatn3w9BvdSdOY05yQa0Q" target="_blank" rel="noopener">Spring 源码第六弹！松哥和大家聊聊容器的始祖 DefaultListableBeanFactory</a>。</p><p>这就是直接继承自 BeanFactory 的三个接口。这三个接口中，有的方法大家可能用过，有的可能没用过，松哥后面抽空整一个视频，把这里涉及到的方法用法给小伙伴们演示一遍，加深大家的理解。</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4.小结"></a>4.小结</h2><p>好啦，本文主要和小伙伴们梳理了一下 BeanFactory 体系，扯的有点多了，下篇文章我们来继续看基于 BeanFactory 的 ApplicationContext。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章和小伙伴们分享了 Spring 中的 FactoryBean（&lt;a href=&quot;https://mp.weixin.qq.com/s/uNmbDpiAZ1Lku1GQz7IqDQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring 源码第 9 篇，深入分析 FactoryBean&lt;/a&gt;），大家知道 Spring 中还有一个和 FactoryBean 单词很像的类叫做 BeanFactory！&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://www.javaboy.org/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://www.javaboy.org/tags/Spring/"/>
    
      <category term="源码解析" scheme="http://www.javaboy.org/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
